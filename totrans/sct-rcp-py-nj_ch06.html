<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Improving Python Performance with PyPy</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Improving Python Performance with PyPy</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover PyPy, a compiled version of Python that aims to increase the performance of Python programs. We will talk about the following:</p>
<ul>
<li>What is PyPy?</li>
<li>What is RPython?</li>
<li>Some real-world examples</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Python is an interpreted language. Interpreted languages use middleware to read the source code and generate system-specific machine language. Compiled languages use a compiler to convert the source code directly into machine language; there is no middle step in the process.</p>
<p>The benefit of compiled languages is that, without the interpretation step, the code is executed directly by the system and yields the fastest processing time available. In addition, compilers have the ability to look at the source code as it is being converted and apply optimizations to make the machine code that much faster.</p>
<p>For example, if the compiler is analyzing the source code and sees that code spends a large amount of time in a particular loop, it can apply one of several optimization algorithms to the code to improve performance, such as breaking a single loop into multiple loops that each process a smaller part of the original loop's body.</p>
<p>Conversely, interpreted languages make the life of a programmer easier, as the languages tend to be easier to code in and they generally have an interactive prompt, allowing a developer to test code before putting it into the final program. This leads to another point about interpreted languages: they don't have a compilation step so seeing the results of a program is more or less immediate. If there is a bug in the code, the developer knows immediately rather than after the (potentially long) compilation. (While most bugs are identified by the compiler during compilation, there are some bugs that won't be caught, such as those identified at <a href="http://www.learncpp.com/cpp-programming/eight-c-programming-mistakes-the-compiler-wont-catch/">http://www.learncpp.com/cpp-programming/eight-c-programming-mistakes-the-compiler-wont-catch/</a>.)</p>
<p>Just as a quick example of the possible speed differences that can occur between interpreted and compiled languages, here are some times for C++ versus Python from <a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=python3&amp;lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=python3&amp;amp;lang2=gpp</a>:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>Task</strong></td>
<td><strong>Python (secs)</strong></td>
<td><strong>C++ (secs)</strong></td>
</tr>
<tr>
<td>Pi digits</td>
<td>3.43</td>
<td>1.88</td>
</tr>
<tr>
<td>Reverse complement</td>
<td>18.79</td>
<td>3.08</td>
</tr>
<tr>
<td>Regex redux</td>
<td>15.22</td>
<td>1.61</td>
</tr>
<tr>
<td>Mandelbrot</td>
<td>225.24</td>
<td>1.51</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What is PyPy?</h1>
                </header>
            
            <article>
                
<p>PyPy is an alternative implementation of Python. While normal Python is built using the C language (hence the alternative term: CPython), PyPy is built on the <strong>RPython</strong>&#160;(<strong>Restricted Python</strong>)&#160;<span>language</span><span>&#160;</span><span>. RPython constrains the Python language; these constraints mean that PyPy can look at the RPython code, translate it into C code, and then compile it to machine code.</span></p>
<p>The main aspects of PyPy is the <strong>j<span>ust-in-time</span></strong><span><strong>&#160;(JIT)</strong>&#160;compiler. Specifically, it uses a tracing JIT, which monitors frequently executed loops and compiles them into native machine code. Since programs frequently spend much of their time in loops, compiling those loops to native code maximizes the speed at which they process data.</span></p>
<p>Using RPython, the JIT compiler receives known code, that is, the compiler doesn't have to spend time parsing the metadata of the code to determine what type an object is, how much memory space is taken up, and so on. Thus, it is able to effectively convert the CPython code into C code and then to native assembly language for the system.</p>
<p>While object types are still inferred, like normal Python, and are not declared like statically typed languages, each variable can only have one type associated with it and cannot change later in the code. For example, a favorite thing to show about Python is that the following&#160;<span>are both legitimate variable assignments in Python;</span><span>&#160;</span><kbd>x</kbd><span>&#160;has no inherited knowledge about itself so it can be changed at any time:</span><span>&#160;</span></p>
<div>
<pre>x = 2
x = "a_string"</pre>
</div>
<p>But with RPython, this would not be allowed because, once a variable is declared, even if as something like an empty list, it can never change types, for example, converting from a list to a tuple.</p>
<p>Because it is different from CPython, there may be compatibility issues when using PyPy. While their designers strive to provide maximum compatibility between the two implementations, there are some known problems (<a href="http://pypy.org/compat.html">http://pypy.org/compat.html</a>).</p>
<p>The main features of PyPy are the following:</p>
<ul class="itemize">
<li>Speed: Currently, PyPy is an average of 7.6x faster than CPython (<a href="http://speed.pypy.org">http://speed.pypy.org</a>). Depending on the module, speed improvements can be up to 98%. Note that there are two main cases where PyPy will not provide a speed increase:
<ul>
<li>Programs that are too short for the JIT compiler to warm up. A program has to run for a few seconds, so a large number of simple scripts will not benefit from PyPy.</li>
<li>Obviously, if the program isn't running Python code but is working with runtime libraries such as C functions (for example, Python is just a glue language between blocks of compiled code) you won't notice a performance difference with PyPy.</li>
</ul>
</li>
<li>Memory usage: PyPy programs tend to have better memory management than CPython, that is, hundreds of MBs in size. While it isn't always the case, there may be some resource improvement through PyPy, though it depends on the details of the program.</li>
<li>Stackless support is integrated into PyPy, allowing improved concurrent processing support.</li>
<li>Other languages implement RPython: Prolog, Smalltalk, JavaScript, Io, Scheme, Gameboy, Ruby (called Topaz), and PHP (called HippyVM).</li>
<li>A prototype sandbox environment is available for testing. It is designed to replace calls to external libraries with a code stub that handles communications with an external process that handles the policy.</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Installing PyPy can be easy or hard, depending on your system. Binaries are available (<a href="http://pypy.org/download.html#default-with-a-jit-compiler">http://pypy.org/download.html#default-with-a-jit-compiler</a>) for x86, ARM, PowerPC, and s390x CPUs for Windows, macOS, and Linux OSes. In addition, Python 2.7 and 3.5 versions are available.</p>
<p>If installing on Linux, binaries are only usable for the distributions they are compiled for. Unfortunately, this means that many more recent distribution versions are out of luck. For example, the latest Ubuntu version supported is 16.04, while Windows doesn't have a 64-bit version available. If you don't use a binary that is expressly written for your version, you will most likely get error messages.</p>
<p>If you are running Linux and it isn't one of the distributions listed in the downloads site, you have the choice of hacking your distribution to make things work, or trying out the portable PyPy binary. Portable PyPy is an attempt to write a 64-bit x86-compatible binary for a variety of Linux distributions without requiring additional libraries or OS configuration changes. These portable binaries are created using Docker, so while they should work without issue, like any technology, your mileage may vary.</p>
<p>In addition to PyPy, these portable binaries include <kbd>virtenv</kbd> to keep everything separate, as well as providing OpenSSL, SQLite3, libffi, expat, and Tcl/Tk.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>To run PyPy, simply go to the location where you placed the binary and call PyPy:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="images/57cd3fbb-f88f-412a-829e-6c4a19243655.png" style="width:37.83em;height:9.25em;"/></div>
<p style="padding-left: 90px">As can be seen, it looks like a standard Python interactive interpreter, so you can experiment with your code as normal.</p>
<ol start="2">
<li>For a simple test to demonstrate how quick PyPy compares with normal Python, we will make a couple of files, as well as a C file, to see how well PyPy's JIT compiler compares:</li>
</ol>
<ul>
<li>
<ul>
<li>We save the following as <kbd>add_funct.py</kbd><span>:</span></li>
</ul>
</li>
</ul>
<pre>                 def add(x, y):<br/>                      return x + y </pre>
<ul>
<li>
<ul>
<li>The following is <kbd>loop_funct.py</kbd><em><em>:</em></em></li>
</ul>
</li>
</ul>
<pre>                  from file1 import add<br/>                      def loop():<br/>                          i = 0<br/>                          a = 0.0<br/>                          while i &lt; 1000000000:    <br/>                              a += 1.0<br/>                              add(a, a)<br/>                              i += 1<br/>                      if __name__ == "__main__":<br/>                          loop() </pre>
<ul>
<li>
<ul>
<li><kbd>loop_funct.c</kbd> is the C code for comparison:</li>
</ul>
</li>
</ul>
<pre>                  double add(double x, double y)<br/>                  {<br/>                    return x + y;<br/>                  }<br/>                  int main(void)<br/>                  {<br/>                    int i = 0;<br/>                    double x = 0;<br/>                    while (i &lt; 1000000000) {<br/>                      x += 1.0;<br/>                      add(x, x);<br/>                      i++;<br/>                    }<br/>                    return 0;<br/>                  }</pre>
<ol start="3">
<li>The following screenshots show the timings for each program type:</li>
</ol>
<ul>
<li>
<ul>
<li>Python:</li>
</ul>
</li>
</ul>
<div class="standard CDPAlignCenter CDPAlign"><img src="images/0e650d5f-ee08-4a28-863c-257b9ca22547.png" style="width:37.75em;height:10.25em;"/></div>
<ul>
<li>
<ul>
<li>PyPy:</li>
</ul>
</li>
</ul>
<div class="standard CDPAlignCenter CDPAlign"><img src="images/651cae91-dd2f-471e-8186-de33f0bc251b.png" style="width:37.17em;height:10.00em;"/></div>
<ul>
<li>
<ul>
<li>C:</li>
</ul>
</li>
</ul>
<div class="standard CDPAlignCenter CDPAlign"><img src="images/48b2e619-bc97-4f20-9372-9aeca4e4f20c.png" style="width:36.83em;height:9.92em;"/></div>
<ol start="4">
<li>The speed increase using PyPy over Python was 99.5%. The speed difference between PyPy and C was 97.3%, but comparing C to Python resulted in a 99.9% increase. In programs that use human interaction, the difference between C and PyPy times is effectively nil, but in long-running, non-interactive programs, that time difference adds up. Is it enough to warrant rewriting Python code into C code? Probably not, but it might be worth rewriting just the the bottleneck code in C and then passing that data into Python.</li>
</ol>
<ol start="5">
<li><kbd>beer_loop.py</kbd> shows that PyPy is most effective if it can work on loops that execute functions. The following program, while having a long iteration, is essentially just a counter. The loop doesn't call any functions or do much besides print strings:</li>
</ol>
<pre>        for i in range(1000000, 0, -1):<br/>            if i &gt; 1:<br/>                print("{} bottles of beer on the wall, <br/>                       {} bottles of beer.".format(i, i))<br/>            if i &gt; 2:<br/>                additional = str(i - 1) + " bottles of beer on the wall."<br/>            else:<br/>                additional = "1 bottle of beer on the wall."<br/>            if i == 1:    <br/>                print("1 bottle of beer on the wall, 1 bottle of beer.")<br/>                additional = "no more beer on the wall!"<br/>                print("Take one down, pass it around, <br/>                       {}\n".format(additional)) </pre>
<ol start="6">
<li>If we time both a normal Python call and PyPy, we'll see that the times are roughly the same:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="images/39caa66b-8e55-487d-af3a-c2f0f6482892.png" style="width:38.92em;height:21.83em;"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">The preceding screenshot is the time for normal Python 3 to run through 1 million iterations.</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/04762c1d-84ed-4c38-8a72-52e886ed5988.png" style="width:39.67em;height:22.25em;"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">The preceding screenshot is for PyPy. While there is about a 25% difference between the two, the speed improvement with PyPy is nowhere near what is was in the results shown in step 4 above (more than 99% speed increase). Even after running it a few additional times to see&#160;whether having a compiled file already available made a difference, this author was not able to improve the results. Hence, while PyPy can improve performance on a number of different Python programs, the improvement really occurs on functions that are hottest, that is, the functions that are executed most often. Thus, one way to maximize performance is to simply make your code utilize functions whenever possible.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Of course, there are ways to improve code, such as actually using a loop rather than an iterator, but this demonstrates a couple of points:</p>
<ul>
<li>Just because PyPy is being used doesn't mean that it will improve program performance. Not only do you have to ensure that the PyPy subset of Python commands is utilized, it also means that the code has to be written in a manner that utilizes the improvement capabilities of PyPy.</li>
</ul>
<ul>
<li>While maximum performance can be achieved using a compiled language, using PyPy means that you don't have to bother rewriting your code very often. Of course, if your code is taking a long time to process, but can't be optimized for PyPy, then compiling may be your best bet.
<p>For example, writing a C version of the Million Bottles code resulted in a compilation time of &lt; 1 second. This is 99&#160;<span>percent</span> faster than PyPy's time.</p>
</li>
<li>
<p>This also points out that it is better to write your code first, then conduct performance modeling and identify bottlenecks. Those areas will be the key places to focus on, whether it's rewriting in a compiled language or looking into PyPy.</p>
</li>
</ul>
<p>The PyPy documentation (<a href="http://pypy.org/performance.html">http://pypy.org/performance.html</a>) provides some hints on how to optimize your code prior to refactoring or rewriting it:</p>
<ul>
<li>Use regression testing. Like any testing code, it requires significant time upfront to determine what tests are needed, as well as the actual code writing. But the payout comes when refactoring as it allows you to try different optimizations without worrying about adding a lot of hidden bugs.</li>
<li>Use profilers to actually measure the time of your code overall, as well as individual portions. This way, you know exactly where the time sinks are so you can focus on those areas, rather than guessing where the bottlenecks are.</li>
<li>Harking back to parallel processing, be aware of code that is I/O-bound versus CPU-bound. I/O-bound code is reliant upon data transfers and benefits most from multithreading, rather than significant code optimization; there is only so much you can do with your code before the data processing becomes reliant on the speed of the I/O connections.
<p>CPU-bound code is where you get the most value in terms of refactoring and optimization. That's because the CPU has to process a lot of data, so any sort of optimization in the code, such as compiling it or parallelizing it, will have an impact on the performance speed.</p>
</li>
<li>
<p>While you can always rewrite your code in a compiled language, it defeats the purpose of using Python. A better technique is to tune your algorithms to maximize performance in terms how the data is processed. You will probably go through several iterations of tuning and algorithm optimizing as you discover new bottlenecks.</p>
</li>
</ul>
<ul>
<li>Smaller programs are intrinsically faster than larger ones. This is because the different levels of cache on CPUs are progressively smaller the closer to the core they are, but they are also faster as well. If you can create a program, or at least subroutines, that can fit inside a cache space, it will be as fast as the cache itself is.
<p>Smaller programs imply simpler code, as simple code creates shorter machine language opcodes. The problem comes from algorithm tuneup; improving algorithm performance generally implies using time-saving but space-filling techniques such as pre-computations or reverse maps.</p>
</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What is RPython?</h1>
                </header>
            
            <article>
                
<p>RPython is the language used to create PyPy. Technically, it is considered a translation and support framework for implementing dynamic programming languages, separating the language specs from the implementation aspects. This means that RPython can be used for other languages besides Python, though it is most commonly associated with Python. This also means that any dynamic language will benefit from the JIT compiler and allows for a mix-and-match style when making implementation choices.</p>
<p>While certain environments have been created in the past to provide abstraction between source code and the target system, such as .NET and Java Virtual Machines, RPython uses a subset of CPython to create languages that act as simple interpreters, with little direct connectivity to low-level, system details. The subsequent toolchain creates a solid virtual machine for a designated platform by using the appropriate lower-level aspects as needed. This allows further customization of features and platform configuration.</p>
<p>When implementing languages, developers have to contend with the languages themselves, the platforms that will run the languages, and the design decisions made during development. The overriding goal of PyPy and RPython development is to make it so that these development variables can be modified independently. Thus, the language used can be modified or replaced, the platform-specific code can be optimized to meet different model needs and desired trade-offs, and the translator backends can be written to target different physical and virtual platforms.</p>
<p>Thus, while a framework such as .NET tries to create a common environment for developers to target, PyPy strives to allow developers to essentially do whatever they want, however they want. JIT compilers are one way to do this, as they are made in a language-independent manner.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<div class="standard packt_infobox">RPython is not designed for writing programs, as such, but is designed for writing software interpreters. If you want to speed up your Python code, then just use PyPy. RPython's sole purpose is to allow development of dynamic language interpreters.</div>
<p>In the light of the preceding tip, this section won't walk through the normal code examples. We will cover the differences between RPython and Python, just so you understand what is meant by RPython being a subset of Python, and possibly some of the considerations necessary if you are looking to write an interpreter.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Flow restrictions</h1>
                </header>
            
            <article>
                
<ul>
<li>Variables should only contain values that are only one type at each control point. In other words, when combining paths of control, for example, <kbd>if...else</kbd> statements, using the same variable name for two different types of values, for example, a string and an integer, must be avoided.</li>
<li>All global values within a module are considered constants and can't change while the program is running.</li>
<li>All control structures are allowed but <kbd>for</kbd> loops are restricted to built-in types and generators are heavily restricted.</li>
<li>The&#160;<kbd>range</kbd> and <kbd>xrange</kbd>&#160;functions are treated equally, though <kbd>xrange</kbd> fields are not accessible to Python.</li>
<li>Defining classes or functions at runtime is prohibited.</li>
<li>While generators are supported, their scope is limited and you cannot merge different generators at a single control point.</li>
<li>Exceptions are fully supported. However, the generation of exceptions is slightly different compared to regular Python.</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Object restrictions</h1>
                </header>
            
            <article>
                
<ul>
<li>Integers, floats, and booleans all work as expected.</li>
<li>Most string methods are implemented but, of the ones that are implemented, not all arguments are accepted. String formatting is limited, as is Unicode support.</li>
</ul>
<ul>
<li>Tuples must be a fixed length and list-to-tuple conversion is not handled in a general way, as there is no way for RPython to determine, non-statically, what the length of the result would be.</li>
<li>Lists are implemented as allocated arrays. Negative and out-of-bounds indexing is only allowed in limited cases. Obviously, fixed-length lists will optimize better, but appending to lists is relatively quick.</li>
<li>Dictionaries must have unique keys but custom hash functions or custom equality will be ignored.</li>
<li>Sets are not directly supported but can be simulated by creating a dictionary and providing the values for each key as <kbd>None</kbd>.</li>
<li>List comprehensions can be used to create allocated, initialized arrays.</li>
<li>Functions may be declared with default arguments and <kbd>*args</kbd>, but <kbd>**keywords</kbd> arguments aren't allowed. Generally speaking, functions operate normally but care must be taken when calling a function with a dynamic number of arguments.</li>
<li>Most built-in functions are available, but their support may be different from expected.</li>
<li>Classes are supported, as long as methods and attributes don't change after startup. Single inheritance is fully supported, but not multiple inheritance.</li>
<li>General object support is provided for, so creating custom objects shouldn't run into significant problems. However, only a limited set of special methods, for example,&#160;<kbd>__init__</kbd>, are available to custom objects.</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Integer types</h1>
                </header>
            
            <article>
                
<p>Because integers are implemented differently between Python 2 and Python 3, normal integers are used for signed arithmetic. This means that, prior to translation, <em>longs</em> are used in the case of overflow but, after translation, silent wraparound occurs. However, in cases where more control is necessary, the following functions and class are provided:</p>
<ul>
<li><kbd>ovfcheck()</kbd>: Should only be used when a single arithmetic operation is used as the argument. This function will perform its operation in overflow-checking mode.</li>
<li><kbd>intmask()</kbd>: Used for wraparound arithmetic and returns the lower bits of its argument, masking anything that isn't part of a C signed-long-int. This allows Python to convert from a <kbd>long</kbd> from a previous operation to an <kbd>int</kbd>. Code generators ignore this function, as they conduct wraparound, signed arithmetic by default.</li>
</ul>
<ul>
<li><kbd>r_uint</kbd>: This class is a pure Python implementation of native machine-sized, unsigned integers that silently wrap around. This is provided to allow consistent typing by utilizing <kbd>r_uint</kbd> instances throughout the program; all operations with these instances will be assumed to be unsigned. Mixing signed integers and <kbd>r_uint</kbd> instances results in unsigned integers. To convert back to signed integers, the <kbd>intmask()</kbd> function should be used.</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Just for clarification, RPython is not a compiler. It is a development framework, as well as a programming language, specifically a subset of regular Python. PyPy uses RPython as its programming language to implement a JIT compiler.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Some real-world examples</h1>
                </header>
            
            <article>
                
<p>Here are more examples of how PyPy can improve performance, as well as some practical uses of the environment.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>The following code (<kbd>time.py</kbd><em>)</em> uses the Pythagorean Theorem to calculate the hypotenuse for a number of triangles with increasing side lengths:</li>
</ol>
<pre>        import math<br/><br/>        TIMES = 10000000<br/>        a = 1<br/>        b = 1<br/> <br/>        for i in range(TIMES):<br/>            c = math.sqrt(math.pow(a, 2) + math.pow(b, 2))<br/>            a += 1<br/>            b += 2</pre>
<ol start="2">
<li>The following code (<kbd>time2.py</kbd>) does the same thing as <kbd>pythag_theorem.py</kbd> but puts the calculations within a function, rather than performing the calculation in line:</li>
</ol>
<pre>        import math<br/><br/>        TIMES = 10000000<br/>        a = 1<br/>        b = 1<br/> <br/>        def calcMath(i, a, b):<br/>            return math.sqrt(math.pow(a, 2) + math.pow(b, 2))<br/> <br/>        for i in range(TIMES):<br/>            c = calcMath(i, a, b)<br/>            a += 1<br/>            b += 2 </pre>
<ol start="3">
<li>The following screenshot shows the time-to-complete differences between regular Python and PyPy, for both <kbd>time.py</kbd> and <kbd>time2.py</kbd>:</li>
</ol>
<div class="standard CDPAlignCenter CDPAlign"><img src="images/aea3ff84-b35c-4fda-b1a4-1842a14c9fe1.png" style="width:36.50em;height:20.42em;"/></div>
<p style="padding-left: 90px" class="standard">The times for Python for both inline and function calls are within a second of each other. The difference for PyPy between the two calculations is the same, but there is a 96%&#160;speed improvement between PyPy and Python.</p>
<p style="padding-left: 90px" class="standard">This demonstrates two main things:</p>
<ul>
<li>
<ul>
<li>Python takes a performance hit when calling functions, due to the overhead costs involved in looking up the function and calling the function</li>
<li>PyPy can have a significant effect when allowed to optimize code that is repeatedly called</li>
</ul>
</li>
</ul>
<ol start="4">
<li>If we modify the code so both <kbd>time.py</kbd> and <kbd>time2.py</kbd> are only run once, that is,&#160;<kbd>TIMES=1</kbd>, the following results occur:</li>
</ol>
<div style="color: black;font-size: 1em" class="standard CDPAlignCenter CDPAlign"><img src="images/9d3d3ec3-65c2-45c5-957b-f1b064583c62.png" style="width:38.33em;height:21.50em;"/></div>
<p style="color: black;padding-left: 60px" class="standard">With one pass through the code, the time for Python is functionally equivalent for both inline and function calls. Also, the overhead required by PyPy to compile the code, then process it, leads to a longer time-to-process.</p>
<ol start="5">
<li>Going to the other extreme, we change the count to 1 billion and run the programs again:</li>
</ol>
<ul>
<li>
<ul>
<li>The following is regular Python, running&#160;<kbd>time.py</kbd>:</li>
</ul>
</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="images/a13b72fc-acc8-472a-965f-1ff579d9764f.png" style="width:36.75em;height:9.83em;"/></div>
<ul>
<li>
<ul>
<li>The following is regular Python, running&#160;<kbd>time2.py</kbd>:</li>
</ul>
</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="images/ed5c52d0-8072-4121-8885-19151b46075e.png" style="width:39.50em;height:10.67em;"/></div>
<ul>
<li>
<ul>
<li>The following is PyPy, running&#160;<kbd>time.py</kbd>:</li>
</ul>
</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="images/30b32837-fa8d-413f-8a77-8882db5a6854.png" style="width:39.83em;height:10.75em;"/></div>
<ul>
<li>
<ul>
<li>The following is PyPy, running <kbd>time2.py</kbd>:</li>
</ul>
</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="images/a683124a-6d82-44cc-bcfc-b7da52965944.png" style="width:41.08em;height:11.08em;"/></div>
<p style="padding-left: 60px" class="standard">The first screenshot is the time for Python to complete <kbd>time.py</kbd>: nearly 14.5 minutes. By having to deal with function calls, the second screenshot shows that Python's time increases to nearly 17 minutes.<br/>
By comparison, PyPy didn't really seem to care too much. The third and fourth screenshots both show nearly the same time, less than 1 minute. Considering that we calculated 1 billion Pythagorean equations, that is an outstanding time.</p>
<ol start="6">
<li>A real-world example is calculating the Great Circle distance, a common calculation for navigation to determine the shortest distance between two points on a sphere. <kbd>great_circle.py</kbd> was created using the formula from Wikipedia (<a href="https://en.wikipedia.org/w/index.php?title=Great-circle_distance&amp;oldid=819870157">https://en.wikipedia.org/w/index.php?title=Great-circle_distance&amp;amp;oldid=819870157</a>):</li>
</ol>
<pre>        from math import cos, sin, atan2, fabs, sqrt, pow, radians<br/>        r = 6371 # Earth's radius at equator in kilometers<br/><br/>        # Alamo<br/>        lat1 = 29.42569<br/>        lat1_rads = radians(lat1)<br/>        long1 = -98.48503<br/>        long1_rads = radians(long1)<br/><br/>        # Tokyo Tower<br/>        lat2 = 35.65857<br/>        lat2_rads = radians(lat2)<br/>        long2 = 139.745484<br/>        long2_rads = radians(long2)<br/><br/>        delta = fabs(long1_rads - long2_rads)<br/><br/></pre>
<pre>        def great_circle(lat1_rads, lat2_rads, delta):<br/>            x = (sin(lat1_rads) * sin(lat2_rads)) + (cos(lat1_rads) * cos(lat2_rads) * cos(delta))<br/>            y = sqrt(pow((cos(lat2_rads) * sin(delta)), 2)  + pow((cos(lat1_rads) * sin(lat2_rads)) - (sin(lat1_rads) * cos(lat2_rads) * cos(delta)), 2))<br/>            angle = atan2(y, x)<br/>            dist = r * angle<br/>            return dist<br/><br/>        num = 100000000<br/>        for i in range(num):<br/>            great_circle(lat1_rads, lat2_rads, delta) </pre>
<p style="padding-left: 60px" class="mce-root"><span>It's worth pointing out that we are using some of the</span> <kbd>math</kbd> <span>module functions. In the interests of full disclosure, this author forgot to account for the use of radians initially, and the result was off by 1,300.</span></p>
<ol start="7">
<li>We can set up a loop to calculate the distance between the same two points, much like the previous example. In this case, we used 1 billion again:</li>
</ol>
<div style="color: black;font-size: 1em" class="standard CDPAlignCenter CDPAlign"><img src="images/8da03b73-15f3-4592-8a07-6ac8a8fe4a1e.png" style="width:39.83em;height:15.08em;"/></div>
<p style="color: black;font-size: 1em;padding-left: 60px" class="standard">The time differences here work out to a 97%&#160;improvement with PyPy.</p>
<ol start="8">
<li>As an interesting comparison, we will rewrite the Great Circle code to use multiprocessing. This was done because there are no I/O operations occurring, so multithreading wouldn't do much good in a CPU-intensive operation.</li>
</ol>
<p style="padding-left: 60px" class="mce-root"><span>As this is just a simple test, the code is not optimized in any fashion. It just creates a pool of eight workers and calls the</span> <kbd>great_circle()</kbd> <span>function in an asynchronous fashion.</span></p>
<ol start="9">
<li>So as to not drag out the time, only 1 million function calls were made for this example:</li>
</ol>
<div style="color: black;font-size: 1em" class="standard CDPAlignCenter CDPAlign"><img src="images/87445af2-c8e2-4095-945f-d58cdde971f8.png" style="width:39.75em;height:19.50em;"/></div>
<p style="color: black;padding-left: 60px" class="standard">In this example, the multiprocessing call was performed first, with a time of nearly 45 seconds. The code was modified to remove the multiprocessing calls and ran with normal Python and PyPy, resulting in times of nearly 1.5 seconds and 0.5 seconds, respectively.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>The multiprocessing example demonstrates that, while multiprocessing is useful in some situations, considerable effort must be made to optimize the program to best utilize multiprocessing. In addition, multiprocessing can be slower than single thread operations because each process must be started anew, much like the function call overhead.</p>
<p>There is also the problem of each process taking over a CPU core. While this helps with the parallelization of code processing, it means that the core is essentially locked until the processing is done.</p>
<p>For counts under than 1 million, multiprocessing performed well. At 100,000 calls, the total time was just under 4 seconds. At 10,000 calls, the time was less than 0.5 seconds, which is comparable to PyPy's time.</p>
<p>However, when attempting to run this code with the original 1&#160; billion calls, this author's computer (with eight cores) locked up hard. After attempting to kill the process, the computer finally released the lock after 1.5 hours.</p>
<p>There are multiple reasons why the multiprocessing code caused this. The main part is that it isn't well optimized and simply tries to call the function as resources are available. Each process takes up both CPU cycles and memory space, so there eventually comes a point when new processes have to wait for resources to become available.</p>
<p>On the other hand, serial processing, such as Python or PyPy, don't have this overhead problem and can simply plug and chug to process the code. Even on multiple calls, they are still able to process quickly. Of course, this is a more or less artificial test and real-world projects will vary considerably as to which method is best.</p>
<p>Ultimately, this gives a good demonstration of the capabilities of PyPy and how it compares to multiprocessing. Combining PyPy with multiprocessing may work but, based on readings, it looks like the PyPy community isn't interested in improving performance for parallel processing, so your results will vary.</p>


            </article>

            
        </section>
    </div>
</body>
</html>