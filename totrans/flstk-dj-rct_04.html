<html><head></head><body>
		<div id="_idContainer043">
			<h1 id="_idParaDest-73" class="chapter-number"><a id="_idTextAnchor076"/>4</h1>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor077"/>Adding Comments to Social Media Posts</h1>
			<p>A social media application is more fun if your users can comment on other posts or even like them. In this chapter, we’ll first learn how to add comments to posts. We’ll see how we can use database relationships again to create a comment section for each post and ensure the code quality <span class="No-Break">is maintained.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Writing the <span class="No-Break">Comment model</span></li>
				<li>Writing the <span class="No-Break">comment serializer</span></li>
				<li>Nesting routes for the <span class="No-Break">comment resource</span></li>
				<li>Writing the <span class="No-Break">CommentViewSet class</span></li>
				<li>Updating <span class="No-Break">a comment</span></li>
				<li>Deleting <span class="No-Break">a comment</span></li>
			</ul>
			<p>By the end of this chapter, you will be able to create Django models, write Django serializers and validation, and write nested viewsets and routes, and will have a better understanding of <span class="No-Break">authorization permissions.</span></p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor078"/>Technical requirements</h1>
			<p>For this chapter, you need to have Insomnia installed and some knowledge about models, database relationships, and permissions. You’ll also need to have the Insomnia API client installed on your machine. The code for this chapter can be found <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap4"><span class="No-Break">https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap4</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor079"/>Writing the Comment model</h1>
			<p>A <a id="_idIndexMarker211"/>comment in the context of this project will represent a small text that can be viewed by anyone but only be created or updated by authenticated users. Here’s what the requirements for this feature <span class="No-Break">look like:</span></p>
			<ul>
				<li>Any user can <span class="No-Break">read comments</span></li>
				<li>Authenticated users can create comments <span class="No-Break">under posts</span></li>
				<li>The comment author and post author can <span class="No-Break">delete comments</span></li>
				<li>The comment author can <span class="No-Break">update posts</span></li>
			</ul>
			<p>Looking at these requirements, we can definitely start with writing the model first. But first of all, let’s quickly talk about the structure of the <strong class="bold">Comment</strong> table in <span class="No-Break">the database:</span></p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/Figure_4.01_B18221.jpg" alt="Figure 4.1 – The Comment table structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The Comment table structure</p>
			<p>A comment will mostly have four important fields: the author of the comment, the post on which the comment has been made, the body of the comment, and the edited field to track whether the comment has been edited <span class="No-Break">or not.</span></p>
			<p>As per <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.1</em>, we <a id="_idIndexMarker212"/>have two database relationships in the table: author and post. So, how does this schematize in <span class="No-Break">the database?</span></p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/Figure_4.02_B18221.jpg" alt="﻿Figure 4.2 – Comment, Post, and User relationships"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Comment, Post, and User relationships</p>
			<p>As you can <a id="_idIndexMarker213"/>see in <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.2</em>, the author (<strong class="source-inline">User</strong>) and post (<strong class="source-inline">Post</strong>) fields are <strong class="bold">ForeignKey</strong> types. This relates to <a id="_idIndexMarker214"/>some rules for the <span class="No-Break">comment feature:</span></p>
			<ul>
				<li>A user can have many comments, but a comment is created by <span class="No-Break">one user</span></li>
				<li>A post can have many comments, but a comment is linked to only <span class="No-Break">one post</span></li>
			</ul>
			<p>Now that we have a structure for the table and a better understanding of the requirements, let’s write the model and <span class="No-Break">test it.</span></p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor080"/>Adding the Comment model</h2>
			<p>In <strong class="source-inline">core/comment/models.py</strong>, add <a id="_idIndexMarker215"/>the <span class="No-Break">following content:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/models.py</p>
			<pre class="source-code">
from django.db import models
from core.abstract.models import AbstractModel, AbstractManager
class CommentManager(AbstractManager):
    pass
class Comment(AbstractModel):
    post = models.ForeignKey("core_post.Post",
                              on_delete=models.PROTECT)
    author = models.ForeignKey("core_user.User",
                                on_delete=models.PROTECT)
    body = models.TextField()
    edited = models.BooleanField(default=False)
    objects = CommentManager()
    def __str__(self):
        return self.author.name</pre>
			<p>In the preceding code snippet, we are declaring a class called <strong class="source-inline">CommentManager</strong> which is a subclass of the <strong class="source-inline">AbstractManager</strong> class. Then, we are declaring the <strong class="source-inline">Comment</strong> model class with fields such as the <strong class="source-inline">post</strong> and <strong class="source-inline">author</strong> that are respectively <strong class="source-inline">ForeignKey</strong> fields in relation to the <strong class="source-inline">Post</strong> model and the <strong class="source-inline">User</strong> model. Finally, we are declaring the body and the edited field. The rest of the code is basic formality such as telling Django with Manager class to use to manage the <strong class="source-inline">Comment</strong> model and finally a default <strong class="source-inline">__str__</strong> method to return the name of the author when checking a comment object in the <span class="No-Break">Django shell.</span></p>
			<p>Now that the <strong class="source-inline">Comment</strong> model <a id="_idIndexMarker216"/>is written, let’s play with the model in the <span class="No-Break">Django shell.</span></p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor081"/>Creating a comment in the Django shell</h2>
			<p>Launch<a id="_idIndexMarker217"/> the Django shell with the <span class="No-Break">following comment:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">python manage.py shell</p>
			<pre class="source-code">
Python 3.10.2 (main, Jan 15 2022, 18:02:07) [GCC 9.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
&gt;&gt;&gt; from core.comment.models import Comment
&gt;&gt;&gt; from core.post.models import Post
&gt;&gt;&gt; from core.user.models import User</pre>
			<p>First of all, we are importing the needed models to retrieve and create a comment. Next, we’ll retrieve a user and a post and then write the data needed in a Python dictionary to create a comment <span class="No-Break">like so:</span></p>
			<pre class="source-code">
&gt;&gt;&gt; user = User.objects.first()
&gt;&gt;&gt; post = Post.objects.first()
&gt;&gt;&gt; comment_data = {"post": post, "author": user, "body": "A comment."}</pre>
			<p>Now we can create the comment <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
&gt;&gt;&gt; comment = Comment.objects.create(**comment_data)
&gt;&gt;&gt; comment
&lt;Comment: Dingo Dog&gt;
&gt;&gt;&gt; comment.body
'A comment.'</pre>
			<p>Great, now that <a id="_idIndexMarker218"/>we are sure that the comment is working, we can write the serializer for the <span class="No-Break">comment feature.</span></p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor082"/>Writing the comment serializer</h1>
			<p>The<a id="_idIndexMarker219"/> comment serializer will help with validation and content creation. In the comment application, create a file named <strong class="source-inline">serializers.py</strong>. We’ll write <strong class="source-inline">CommentSerializer</strong> in <span class="No-Break">this file.</span></p>
			<p>First of all, let’s import the classes and tools needed to create <span class="No-Break">a serializer:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/core/comment/serializers.py</p>
			<pre class="source-code">
from rest_framework import serializers
from rest_framework.exceptions import ValidationError
from core.abstract.serializers import AbstractSerializer
from core.user.models import User
from core.user.serializers import UserSerializer
from core.comment.models import Comment
from core.post.models import Post</pre>
			<p>Once it’s done, we can now <span class="No-Break">write </span><span class="No-Break"><strong class="source-inline">CommentSerializer</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/core/comment/serializers.py</p>
			<pre class="source-code">
...
class CommentSerializer(AbstractSerializer):
   author = serializers.SlugRelatedField(
     queryset=User.objects.all(), slug_field='public_id')
   post = serializers.SlugRelatedField(
     queryset=Post.objects.all(), slug_field='public_id')
   def to_representation(self, instance):
       rep = super().to_representation(instance)
       author =
        User.objects.get_object_by_public_id(rep["author"])
       rep["author"] = UserSerializer(author).data
       return rep
   class Meta:
       model = Comment
       # List of all the fields that can be included in a
       # request or a response
       fields = ['id', 'post', 'author', 'body', 'edited',
                 'created', 'updated']
       read_only_fields = ["edited"]</pre>
			<p>Let’s explain the code concerning the <strong class="source-inline">CommentSerializer</strong> class. To create a comment, we need three fields: <strong class="source-inline">public_id</strong> of the author, <strong class="source-inline">public_id</strong> of the post, and finally, the <a id="_idIndexMarker220"/>body. We’ve also added validation methods for the <span class="No-Break"><strong class="source-inline">author</strong></span><span class="No-Break"> field.</span></p>
			<p>In <strong class="source-inline">validate_author</strong>, we are blocking users from creating comments for <span class="No-Break">other users.</span></p>
			<p>And finally, the <strong class="source-inline">to_representation</strong> method modifies the final object by adding information about <span class="No-Break">the author.</span></p>
			<p>The comment serializer is now ready. We can now proceed to write the viewsets concerning the comment feature. But before that, let’s talk about the endpoint of <span class="No-Break">the resource.</span></p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor083"/>Nesting routes for the comment resource</h1>
			<p>To create, update, or delete <a id="_idIndexMarker221"/>comments, we need to add <strong class="source-inline">ViewSet</strong>. In the <strong class="source-inline">comment</strong> directory, create a file called <strong class="source-inline">viewsets.py</strong>. This file will contain the code for the <strong class="source-inline">CommentViewSet</strong> class. We won’t be writing the whole code for this viewset because we need to get some clear ideas on the structure of <span class="No-Break">the endpoint.</span></p>
			<p>So, add the following content for <span class="No-Break">the moment:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/viewsets.py</p>
			<pre class="source-code">
from django.http.response import Http404
from rest_framework.response import Response
from rest_framework import status
from core.abstract.viewsets import AbstractViewSet
from core.comment.models import Comment
from core.comment.serializers import CommentSerializer
from core.auth.permissions import UserPermission
class CommentViewSet(AbstractViewSet):
   http_method_names = ('post', 'get', 'put', 'delete')
   permission_classes = (UserPermission,)
   serializer_class = CommentSerializer
...</pre>
			<p>Great, now let’s<a id="_idIndexMarker222"/> talk about the endpoint architecture. The following table shows the structure of the endpoint concerning the comment. You have the method, the URL of the endpoint, and finally, the result of a call on <span class="No-Break">this endpoint:</span></p>
			<table id="table001-2" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Method</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">URL</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Result</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">GET</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">api/comment/</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Lists all the comments related to <span class="No-Break">a post</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">GET</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">api/comment/comment_pk/</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Retrieves a <span class="No-Break">specific comment</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">POST</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">api/comment/</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Creates <span class="No-Break">a comment</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">PUT</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">api/comment/comment_pk/</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Modifies <span class="No-Break">a comment</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">DELETE</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">api/comment/comment_pk/</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Deletes <span class="No-Break">a comment</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>However, for the comment feature, we are working with posts. And it’s definitely a great idea if comments are directly related to posts. Therefore, a great structure for our endpoints will look <span class="No-Break">like this:</span></p>
			<table id="table002" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Method</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">URL</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Action</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">GET</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">api/post/post_pk/comment/</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Lists all the comments related to <span class="No-Break">a post</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">GET</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">api/post/post_pk/comment/comment_pk/</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Retrieves a <span class="No-Break">specific comment</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">POST</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">api/post/post_pk/comment/</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Creates <span class="No-Break">a comment</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">PUT</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">api/post/post_pk/comment/comment_pk/</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Modifies <span class="No-Break">a comment</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">DELETE</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">api/post/post_pk/comment/comment_pk/</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Deletes <span class="No-Break">a comment</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>In this structure, the<a id="_idIndexMarker223"/> endpoint is nested, meaning that comment resources live under <span class="No-Break">post resources.</span></p>
			<p>But how do we achieve <span class="No-Break">this simply?</span></p>
			<p>The Django ecosystem has a library called <strong class="source-inline">drf-nested-routers</strong>, which helps write routers to create nested resources in a <span class="No-Break">Django project.</span></p>
			<p>You can install this package with the <span class="No-Break">following command:</span></p>
			<pre class="console">
pip install drf-nested-routers</pre>
			<p>Don’t forget to add the dependency in the <span class="No-Break"><strong class="source-inline">requirements.txt</strong></span><span class="No-Break"> file.</span></p>
			<p>Great! No need to register it in the <strong class="source-inline">settings.py</strong> file, as it doesn’t come with signals, models, <span class="No-Break">or applications.</span></p>
			<p>In the next section, let’s configure this library to fit the needs of <span class="No-Break">this project.</span></p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor084"/>Creating nested routes</h2>
			<p>Follow <a id="_idIndexMarker224"/>these steps to configure the <span class="No-Break"><strong class="source-inline">drf-nested-routers</strong></span><span class="No-Break"> library:</span></p>
			<ol>
				<li>The first thing to do is to rewrite the <span class="No-Break"><strong class="source-inline">routers.py</strong></span><span class="No-Break"> file:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/routers.py</p>
			<pre class="source-code">
from rest_framework_nested import routers
...
router = routers.SimpleRouter()
…</pre>
			<p><strong class="source-inline">drf-nested-routers</strong> comes with an extended <strong class="source-inline">SimpleRouter</strong>, which will be useful for creating <span class="No-Break">nested routes.</span></p>
			<ol>
				<li value="2">After that, create<a id="_idIndexMarker225"/> a new nested route <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">POST</strong></span><span class="No-Break">:</span><pre class="source-code">
...</pre><pre class="source-code">
# ##################################################################### #</pre><pre class="source-code">
# ################### POST                       ###################### #</pre><pre class="source-code">
# ##################################################################### #</pre><pre class="source-code">
router.register(r'post', PostViewSet, basename='post')</pre><pre class="source-code">
posts_router = routers.NestedSimpleRouter(router, r'post', lookup='post')</pre><pre class="source-code">
…</pre></li>
			</ol>
			<p><strong class="source-inline">NestedSimpleRouter</strong> is a sub-class of the <strong class="source-inline">SimpleRouter</strong> class, which takes initialization parameters, such as <strong class="source-inline">parent_router</strong> – <strong class="source-inline">router</strong> –<strong class="source-inline">parent_prefix</strong> – <strong class="source-inline">r'post'</strong> – and the lookup – <strong class="source-inline">post</strong>. The lookup is the regex variable that matches an instance of the parent resource – <span class="No-Break"><strong class="source-inline">PostViewSet</strong></span><span class="No-Break">.</span></p>
			<p>In our case, the lookup regex will <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">post_pk</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="3">The next<a id="_idIndexMarker226"/> step is to register the <strong class="source-inline">comment</strong> route <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">post_router</strong></span><span class="No-Break">:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/routers.py</p>
			<pre class="source-code">
...
# ##################################################################### #
# ################### POST                       ###################### #
# ##################################################################### #
router.register(r'post', PostViewSet, basename='post')
posts_router = routers.NestedSimpleRouter(router, r'post', lookup='post')
posts_router.register(r'comment', CommentViewSet, basename='post-comment')
urlpatterns = [
   *router.urls,
   *posts_router.urls
]
...</pre>
			<p>Great! The comment resource is available, but we must rewrite the <strong class="source-inline">create</strong>, <strong class="source-inline">get_object</strong>, and <strong class="source-inline">get_queryset</strong> methods on the <strong class="source-inline">CommentViewSet</strong> class. Let’s see how using nested routes can modify the logic of retrieving objects in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor085"/>Writing the CommentViewSet class</h2>
			<p>We now<a id="_idIndexMarker227"/> have a clear idea of how the endpoint <span class="No-Break">will work.</span></p>
			<p>Follow these steps in the <strong class="source-inline">core/comment/viewsets.py</strong> file to finish writing the <span class="No-Break"><strong class="source-inline">CommentViewSet</strong></span><span class="No-Break"> class:</span></p>
			<ol>
				<li value="1">Rewrite the <strong class="source-inline">get_queryset</strong> method of the <strong class="source-inline">CommentViewSet</strong> class to fit the new architecture of <span class="No-Break">the endpoint:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/viewsets.py</p>
			<pre class="source-code">
...
class CommentViewSet(AbstractViewSet):
...
   def get_queryset(self):
       if self.request.user.is_superuser:
           return Comment.objects.all()
       post_pk = self.kwargs['post_pk']
       if post_pk is None:
           return Http404
       queryset = Comment.objects.filter(
         post__public_id=post_pk)
       return queryset</pre>
			<p>In the preceding code, <strong class="source-inline">get_queryset</strong> is the method called when the user hits the <strong class="source-inline">/api/post/post_pk/comment/</strong> endpoint. The first verification here is to check whether the user is a superuser. If that’s the case, we return all the comment objects in <span class="No-Break">the database.</span></p>
			<p>If the user is not a superuser, then we’ll return the comments concerning a post. With the post nested route, we set the <strong class="source-inline">lookup</strong> attribute to <strong class="source-inline">post</strong>. That means that in <strong class="source-inline">kwargs</strong> (a dictionary containing additional data) of every request, a public id value of the <strong class="source-inline">post</strong> with the dictionary key <strong class="source-inline">post_pk</strong> will be passed in the URL of <span class="No-Break">the endpoint.</span></p>
			<p>If that’s not the case, we just return a 404 Not <span class="No-Break">Found response.</span></p>
			<p>We then <a id="_idIndexMarker228"/>make a query to the database by filtering and retrieving only comments that have the <strong class="source-inline">post.public_id</strong> field equal to <strong class="source-inline">post_pk</strong>. This is done with the filter method provided by the Django ORM. It’s useful to write conditions for retrieving objects from <span class="No-Break">the database.</span></p>
			<ol>
				<li value="2">Next, let’s add the <strong class="source-inline">get_object</strong> method to the same <strong class="source-inline">CommentViewSet</strong> so we can use the <strong class="source-inline">public_id</strong> to retrieve the <span class="No-Break">specific comment:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/viewsets.py</p>
			<pre class="source-code">
...
class CommentViewSet(AbstractViewSet):
...
   def get_object(self):
       obj = Comment.objects.get_object_by_public_id(
         self.kwargs['pk'])
       self.check_object_permissions(self.request,
                                     obj)
       return obj
...</pre>
			<p>Similar to the <strong class="source-inline">UserViewSet</strong> <strong class="source-inline">get_object</strong> method, this method is called on each request made to the <strong class="source-inline">/api/post/post_pk/comment/comment_pk/</strong> endpoint. Here, <strong class="source-inline">pk</strong> is represented <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">comment_pk</strong></span><span class="No-Break">.</span></p>
			<p>Then, we <a id="_idIndexMarker229"/>retrieve the object and check for permissions. If everything is good, we return <span class="No-Break">the object.</span></p>
			<ol>
				<li value="3">And as the last step, let’s write the <span class="No-Break"><strong class="source-inline">create</strong></span><span class="No-Break"> method:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/viewsets.py</p>
			<pre class="source-code">
...
class CommentViewSet(AbstractViewSet):
...
   def create(self, request, *args, **kwargs):
       serializer =
         self.get_serializer(data=request.data)
       serializer.is_valid(raise_exception=True)
       self.perform_create(serializer)
       return Response(serializer.data,
                       status=status.HTTP_201_CREATED)</pre>
			<p>Similar to the <strong class="source-inline">create</strong> method on <strong class="source-inline">PostViewSet</strong>, we pass <strong class="source-inline">request.data</strong> to the <strong class="source-inline">ViewSet</strong> serializer – <strong class="source-inline">CommentSerialier</strong> – and try to validate <span class="No-Break">the serializer.</span></p>
			<p>If everything is good, we move to create a new object – a new comment – based on the serializer <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">CommentSerializer</strong></span><span class="No-Break">.</span></p>
			<p>Great! We now have a fully functional <strong class="source-inline">ViewSet</strong>. Next, let’s test the features <span class="No-Break">with Insomnia.</span></p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor086"/>Testing the comments feature with Insomnia</h2>
			<p>Before trying <a id="_idIndexMarker230"/>to retrieve comments, let’s create some comments with <strong class="source-inline">POST</strong> on the <strong class="source-inline">/api/post/post_id/comment/</strong> URL by following <span class="No-Break">these steps:</span></p>
			<ol>
				<li value="1">Replace <strong class="source-inline">post_id</strong> with <strong class="source-inline">public_id</strong> of a post that you have <span class="No-Break">already created.</span></li>
			</ol>
			<p>Here’s an example of a payload for <span class="No-Break">this request:</span></p>
			<pre class="source-code">
{
    "author": "61c5a1ecb9f5439b810224d2af148a23",
    "body": "Hey! I like your post.",
    "post": "e2401ac4b29243e6913bd2d4e0944862"
}</pre>
			<p>And here’s a screenshot of a request made to create a comment <span class="No-Break">in Insomnia:</span></p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/Figure_4.03_B18221.jpg" alt="Figure 4.3 – Creating a post"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Creating a post</p>
			<ol>
				<li value="2">Great! Now, modify the type of request from <strong class="source-inline">POST</strong> to <strong class="source-inline">GET</strong>. You’ll get all the comments concerning <span class="No-Break">the post:</span></li>
			</ol>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/Figure_4.04_B18221.jpg" alt="Figure 4.4 – Listing all comments"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Listing all comments</p>
			<p>Now that it’s <a id="_idIndexMarker231"/>possible to create a comment without issues, let’s add a feature for updating a comment and deleting <span class="No-Break">a comment.</span></p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor087"/>Updating a comment</h1>
			<p>Updating a <a id="_idIndexMarker232"/>comment is an action that can only be done by the author of the comment. And the user should only be able to update the body field of the comment and can’t modify the author value. Follow these steps to add the <span class="No-Break">update feature:</span></p>
			<ol>
				<li value="1">In <strong class="source-inline">core/comment/viewsets</strong>, make sure that <strong class="source-inline">put</strong> is in the list of <strong class="source-inline">http_method_names</strong> <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">CommentViewSet</strong></span><span class="No-Break">:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/viewsets</p>
			<pre class="source-code">
...
class CommentViewSet(AbstractViewSet):
   http_method_names = ('post', 'get', 'put',
                        'delete')
...</pre>
			<p>After that, let’s write a <strong class="source-inline">validate</strong> method for the <strong class="source-inline">post</strong> field. We want to make sure that this value is not editable on <span class="No-Break"><strong class="source-inline">PUT</strong></span><span class="No-Break"> requests.</span></p>
			<ol>
				<li value="2">Inside <a id="_idIndexMarker233"/>the <strong class="source-inline">core/comment/serializers.py</strong> file, add a new method called <strong class="source-inline">validate_post</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">CommentSerializer</strong></span><span class="No-Break">:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/serializers.py</p>
			<pre class="source-code">
...
def validate_post(self, value):
   if self.instance:
       return self.instance.post
   return value
...</pre>
			<p>Every model serializer provides an <strong class="source-inline">instance</strong> attribute that holds the object that will be modified if there is a <strong class="source-inline">delete</strong>, <strong class="source-inline">put</strong>, or <strong class="source-inline">patch</strong> request. If this is a <strong class="source-inline">GET</strong> or <strong class="source-inline">POST</strong> request, this attribute is set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">None</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="3">Next, let’s rewrite the <strong class="source-inline">update</strong> method on the <strong class="source-inline">CommentSerializer</strong> class. We’ll rewrite this class to pass the edited value <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">True</strong></span><span class="No-Break">:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/serializers.py</p>
			<pre class="source-code">
...
class CommentSerializer(AbstractSerializer):
   ...
   def update(self, instance, validated_data):
       if not instance.edited:
           validated_data['edited'] = True
       instance = super().update(instance,
                                 validated_data)
       return instance
…</pre>
			<ol>
				<li value="4">Great! Now, let’s <a id="_idIndexMarker234"/>try a <strong class="source-inline">PUT</strong> request in Insomnia on the <strong class="source-inline">/api/post/post_pk/comment/comment_pk/</strong> endpoint. Here’s an example of a JSON body for <span class="No-Break">the request:</span><pre class="source-code">
{</pre><pre class="source-code">
    "author": "61c5a1ecb9f5439b810224d2af148a23",</pre><pre class="source-code">
    "body": "A simple comment edited",</pre><pre class="source-code">
    "post": "e2401ac4b29243e6913bd2d4e0944862"</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>And here’s a screenshot of a <strong class="source-inline">PUT</strong> request <span class="No-Break">in Insomnia:</span></p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/Figure_4.05_B18221.jpg" alt="Figure 4.5 – Modifying a post"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Modifying a post</p>
			<p>You will <a id="_idIndexMarker235"/>notice in the response body that the <strong class="source-inline">edited</strong> field is set to <strong class="source-inline">true</strong>, and the body of the comment has changed <span class="No-Break">as well.</span></p>
			<p>Now that it’s possible to modify a comment, let’s add the feature for deleting <span class="No-Break">a comment.</span></p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor088"/>Deleting a comment</h1>
			<p>Deleting a comment <a id="_idIndexMarker236"/>is an action that can only be performed by the author of the post, the author of the comment, and a superuser. To implement this rule, we’ll simply add some permissions in the <strong class="source-inline">UserPermission</strong> class by following <span class="No-Break">these steps:</span></p>
			<ol>
				<li value="1">Make sure that <strong class="source-inline">delete</strong> is in the list of <strong class="source-inline">http_method_names</strong> of the <span class="No-Break"><strong class="source-inline">CommentViewSet</strong></span><span class="No-Break"> class:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/viewsets</p>
			<pre class="source-code">
...
class CommentViewSet(AbstractViewSet):
   http_method_names = ('post', 'get', 'put',
                        'delete')
…</pre>
			<ol>
				<li value="2">Once<a id="_idIndexMarker237"/> it’s done, let’s add more verifications in the <strong class="source-inline">core/auth/permissions</strong> file in the <strong class="source-inline">has_object_permission</strong> method of the <span class="No-Break"><strong class="source-inline">UserPermission</strong></span><span class="No-Break"> class:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/permissions</p>
			<pre class="source-code">
...
def has_object_permission(self, request, view, obj):
...
   if view.basename in ["post-comment"]:
       if request.method in ['DELETE']:
           return bool(request.user.is_superuser or
                       request.user in [obj.author,
                       obj.post.author])
       return bool(request.user and
                   request.user.is_authenticated)
…</pre>
			<p>All requests can be made on the <strong class="source-inline">post-comment</strong> endpoint. However, if the method of the request is <strong class="source-inline">DELETE</strong>, we check whether the user is a superuser, the author of the comment, or the author of <span class="No-Break">the post.</span></p>
			<ol>
				<li value="3">Let’s try to <a id="_idIndexMarker238"/>delete the comment in Insomnia at this endpoint: <strong class="source-inline">/api/post/post_pk/comment/comment_pk/</strong>. Make sure you have the access token of the post author or the <span class="No-Break">comment author.</span></li>
			</ol>
			<p>And here’s a screenshot of a <strong class="source-inline">DELETE</strong> request to delete a comment under <span class="No-Break">a post:</span></p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/Figure_4.06_B18221.jpg" alt="Figure 4.6 – Deleting a post"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Deleting a post</p>
			<p>Great, the feature is working like a charm. And we’ve just learned how to write permissions for a <span class="No-Break"><strong class="source-inline">DELETE</strong></span><span class="No-Break"> request.</span></p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor089"/>Summary</h1>
			<p>In this chapter, we’ve learned how to create a comment feature for the posts in our social media projects. That led us to learn more about how to better structure an endpoint using nested routers but also how to write <span class="No-Break">custom permissions.</span></p>
			<p>We’ve also dived deeper into serializer validations and how they work on different <span class="No-Break">HTTP requests.</span></p>
			<p>In the next chapter, we’ll focus on writing unit and integration tests for every feature added to <span class="No-Break">the project.</span></p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor090"/>Questions</h1>
			<ol>
				<li value="1">What is a <span class="No-Break">nested route?</span></li>
				<li>What <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">drf-nested-routers</strong></span><span class="No-Break">?</span></li>
				<li>Which attribute on a model serializer can help you to know whether the request is a <strong class="source-inline">PUT</strong> or a <span class="No-Break"><strong class="source-inline">DELETE</strong></span><span class="No-Break"> request?</span></li>
			</ol>
		</div>
		<div>
			<div id="_idContainer044" class="IMG---Figure">
			</div>
		</div>
	</body></html>