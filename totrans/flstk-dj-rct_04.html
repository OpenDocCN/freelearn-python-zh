<html><head></head><body>
		<div><h1 id="_idParaDest-73" class="chapter-number"><a id="_idTextAnchor076"/>4</h1>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor077"/>Adding Comments to Social Media Posts</h1>
			<p>A social media application is more fun if your users can comment on other posts or even like them. In this chapter, we’ll first learn how to add comments to posts. We’ll see how we can use database relationships again to create a comment section for each post and ensure the code quality is maintained.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Writing the Comment model</li>
				<li>Writing the comment serializer</li>
				<li>Nesting routes for the comment resource</li>
				<li>Writing the CommentViewSet class</li>
				<li>Updating a comment</li>
				<li>Deleting a comment</li>
			</ul>
			<p>By the end of this chapter, you will be able to create Django models, write Django serializers and validation, and write nested viewsets and routes, and will have a better understanding of authorization permissions.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor078"/>Technical requirements</h1>
			<p>For this chapter, you need to have Insomnia installed and some knowledge about models, database relationships, and permissions. You’ll also need to have the Insomnia API client installed on your machine. The code for this chapter can be found here: <a href="https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap4">https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap4</a>.</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor079"/>Writing the Comment model</h1>
			<p>A <a id="_idIndexMarker211"/>comment in the context of this project will represent a small text that can be viewed by anyone but only be created or updated by authenticated users. Here’s what the requirements for this feature look like:</p>
			<ul>
				<li>Any user can read comments</li>
				<li>Authenticated users can create comments under posts</li>
				<li>The comment author and post author can delete comments</li>
				<li>The comment author can update posts</li>
			</ul>
			<p>Looking at these requirements, we can definitely start with writing the model first. But first of all, let’s quickly talk about the structure of the <strong class="bold">Comment</strong> table in the database:</p>
			<div><div><img src="img/Figure_4.01_B18221.jpg" alt="Figure 4.1 – The Comment table structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The Comment table structure</p>
			<p>A comment will mostly have four important fields: the author of the comment, the post on which the comment has been made, the body of the comment, and the edited field to track whether the comment has been edited or not.</p>
			<p>As per <em class="italic">Figure 4</em><em class="italic">.1</em>, we <a id="_idIndexMarker212"/>have two database relationships in the table: author and post. So, how does this schematize in the database?</p>
			<div><div><img src="img/Figure_4.02_B18221.jpg" alt="﻿Figure 4.2 – Comment, Post, and User relationships"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Comment, Post, and User relationships</p>
			<p>As you can <a id="_idIndexMarker213"/>see in <em class="italic">Figure 4</em><em class="italic">.2</em>, the author (<code>User</code>) and post (<code>Post</code>) fields are <strong class="bold">ForeignKey</strong> types. This relates to <a id="_idIndexMarker214"/>some rules for the comment feature:</p>
			<ul>
				<li>A user can have many comments, but a comment is created by one user</li>
				<li>A post can have many comments, but a comment is linked to only one post</li>
			</ul>
			<p>Now that we have a structure for the table and a better understanding of the requirements, let’s write the model and test it.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor080"/>Adding the Comment model</h2>
			<p>In <code>core/comment/models.py</code>, add <a id="_idIndexMarker215"/>the following content:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/models.py</p>
			<pre class="source-code">
from django.db import models
from core.abstract.models import AbstractModel, AbstractManager
class CommentManager(AbstractManager):
    pass
class Comment(AbstractModel):
    post = models.ForeignKey("core_post.Post",
                              on_delete=models.PROTECT)
    author = models.ForeignKey("core_user.User",
                                on_delete=models.PROTECT)
    body = models.TextField()
    edited = models.BooleanField(default=False)
    objects = CommentManager()
    def __str__(self):
        return self.author.name</pre>
			<p>In the preceding code snippet, we are declaring a class called <code>CommentManager</code> which is a subclass of the <code>AbstractManager</code> class. Then, we are declaring the <code>Comment</code> model class with fields such as the <code>post</code> and <code>author</code> that are respectively <code>ForeignKey</code> fields in relation to the <code>Post</code> model and the <code>User</code> model. Finally, we are declaring the body and the edited field. The rest of the code is basic formality such as telling Django with Manager class to use to manage the <code>Comment</code> model and finally a default <code>__str__</code> method to return the name of the author when checking a comment object in the Django shell.</p>
			<p>Now that the <code>Comment</code> model <a id="_idIndexMarker216"/>is written, let’s play with the model in the Django shell.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor081"/>Creating a comment in the Django shell</h2>
			<p>Launch<a id="_idIndexMarker217"/> the Django shell with the following comment:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">python manage.py shell</p>
			<pre class="source-code">
Python 3.10.2 (main, Jan 15 2022, 18:02:07) [GCC 9.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
&gt;&gt;&gt; from core.comment.models import Comment
&gt;&gt;&gt; from core.post.models import Post
&gt;&gt;&gt; from core.user.models import User</pre>
			<p>First of all, we are importing the needed models to retrieve and create a comment. Next, we’ll retrieve a user and a post and then write the data needed in a Python dictionary to create a comment like so:</p>
			<pre class="source-code">
&gt;&gt;&gt; user = User.objects.first()
&gt;&gt;&gt; post = Post.objects.first()
&gt;&gt;&gt; comment_data = {"post": post, "author": user, "body": "A comment."}</pre>
			<p>Now we can create the comment as follows:</p>
			<pre class="source-code">
&gt;&gt;&gt; comment = Comment.objects.create(**comment_data)
&gt;&gt;&gt; comment
&lt;Comment: Dingo Dog&gt;
&gt;&gt;&gt; comment.body
'A comment.'</pre>
			<p>Great, now that <a id="_idIndexMarker218"/>we are sure that the comment is working, we can write the serializer for the comment feature.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor082"/>Writing the comment serializer</h1>
			<p>The<a id="_idIndexMarker219"/> comment serializer will help with validation and content creation. In the comment application, create a file named <code>serializers.py</code>. We’ll write <code>CommentSerializer</code> in this file.</p>
			<p>First of all, let’s import the classes and tools needed to create a serializer:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/core/comment/serializers.py</p>
			<pre class="source-code">
from rest_framework import serializers
from rest_framework.exceptions import ValidationError
from core.abstract.serializers import AbstractSerializer
from core.user.models import User
from core.user.serializers import UserSerializer
from core.comment.models import Comment
from core.post.models import Post</pre>
			<p>Once it’s done, we can now write <code>CommentSerializer</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">/core/comment/serializers.py</p>
			<pre class="source-code">
...
class CommentSerializer(AbstractSerializer):
   author = serializers.SlugRelatedField(
     queryset=User.objects.all(), slug_field='public_id')
   post = serializers.SlugRelatedField(
     queryset=Post.objects.all(), slug_field='public_id')
   def to_representation(self, instance):
       rep = super().to_representation(instance)
       author =
        User.objects.get_object_by_public_id(rep["author"])
       rep["author"] = UserSerializer(author).data
       return rep
   class Meta:
       model = Comment
       # List of all the fields that can be included in a
       # request or a response
       fields = ['id', 'post', 'author', 'body', 'edited',
                 'created', 'updated']
       read_only_fields = ["edited"]</pre>
			<p>Let’s explain the code concerning the <code>CommentSerializer</code> class. To create a comment, we need three fields: <code>public_id</code> of the author, <code>public_id</code> of the post, and finally, the <a id="_idIndexMarker220"/>body. We’ve also added validation methods for the <code>author</code> field.</p>
			<p>In <code>validate_author</code>, we are blocking users from creating comments for other users.</p>
			<p>And finally, the <code>to_representation</code> method modifies the final object by adding information about the author.</p>
			<p>The comment serializer is now ready. We can now proceed to write the viewsets concerning the comment feature. But before that, let’s talk about the endpoint of the resource.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor083"/>Nesting routes for the comment resource</h1>
			<p>To create, update, or delete <a id="_idIndexMarker221"/>comments, we need to add <code>ViewSet</code>. In the <code>comment</code> directory, create a file called <code>viewsets.py</code>. This file will contain the code for the <code>CommentViewSet</code> class. We won’t be writing the whole code for this viewset because we need to get some clear ideas on the structure of the endpoint.</p>
			<p>So, add the following content for the moment:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/viewsets.py</p>
			<pre class="source-code">
from django.http.response import Http404
from rest_framework.response import Response
from rest_framework import status
from core.abstract.viewsets import AbstractViewSet
from core.comment.models import Comment
from core.comment.serializers import CommentSerializer
from core.auth.permissions import UserPermission
class CommentViewSet(AbstractViewSet):
   http_method_names = ('post', 'get', 'put', 'delete')
   permission_classes = (UserPermission,)
   serializer_class = CommentSerializer
...</pre>
			<p>Great, now let’s<a id="_idIndexMarker222"/> talk about the endpoint architecture. The following table shows the structure of the endpoint concerning the comment. You have the method, the URL of the endpoint, and finally, the result of a call on this endpoint:</p>
			<table id="table001-2" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Method</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">URL</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Result</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>GET</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>/</code><code>api/comment/</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Lists all the comments related to a post</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>GET</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>/</code><code>api/comment/comment_pk/</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Retrieves a specific comment</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>POST</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>/</code><code>api/comment/</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Creates a comment</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>PUT</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>/</code><code>api/comment/comment_pk/</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Modifies a comment</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>DELETE</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>/</code><code>api/comment/comment_pk/</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Deletes a comment</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>However, for the comment feature, we are working with posts. And it’s definitely a great idea if comments are directly related to posts. Therefore, a great structure for our endpoints will look like this:</p>
			<table id="table002" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Method</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">URL</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Action</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>GET</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>/</code><code>api/post/post_pk/comment/</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Lists all the comments related to a post</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>GET</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>/</code><code>api/post/post_pk/comment/comment_pk/</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Retrieves a specific comment</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>POST</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>/</code><code>api/post/post_pk/comment/</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Creates a comment</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>PUT</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>/</code><code>api/post/post_pk/comment/comment_pk/</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Modifies a comment</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>DELETE</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>/</code><code>api/post/post_pk/comment/comment_pk/</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Deletes a comment</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>In this structure, the<a id="_idIndexMarker223"/> endpoint is nested, meaning that comment resources live under post resources.</p>
			<p>But how do we achieve this simply?</p>
			<p>The Django ecosystem has a library called <code>drf-nested-routers</code>, which helps write routers to create nested resources in a Django project.</p>
			<p>You can install this package with the following command:</p>
			<pre class="console">
pip install drf-nested-routers</pre>
			<p>Don’t forget to add the dependency in the <code>requirements.txt</code> file.</p>
			<p>Great! No need to register it in the <code>settings.py</code> file, as it doesn’t come with signals, models, or applications.</p>
			<p>In the next section, let’s configure this library to fit the needs of this project.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor084"/>Creating nested routes</h2>
			<p>Follow <a id="_idIndexMarker224"/>these steps to configure the <code>drf-nested-routers</code> library:</p>
			<ol>
				<li>The first thing to do is to rewrite the <code>routers.py</code> file:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/routers.py</p>
			<pre class="source-code">
from rest_framework_nested import routers
...
router = routers.SimpleRouter()
…</pre>
			<p><code>drf-nested-routers</code> comes with an extended <code>SimpleRouter</code>, which will be useful for creating nested routes.</p>
			<ol>
				<li value="2">After that, create<a id="_idIndexMarker225"/> a new nested route called <code>POST</code>:<pre class="source-code">
...</pre><pre class="source-code">
# ##################################################################### #</pre><pre class="source-code">
# ################### POST                       ###################### #</pre><pre class="source-code">
# ##################################################################### #</pre><pre class="source-code">
router.register(r'post', PostViewSet, basename='post')</pre><pre class="source-code">
posts_router = routers.NestedSimpleRouter(router, r'post', lookup='post')</pre><pre class="source-code">
…</pre></li>
			</ol>
			<p><code>NestedSimpleRouter</code> is a sub-class of the <code>SimpleRouter</code> class, which takes initialization parameters, such as <code>parent_router</code> – <code>router</code> –<code>parent_prefix</code> – <code>r'post'</code> – and the lookup – <code>post</code>. The lookup is the regex variable that matches an instance of the parent resource – <code>PostViewSet</code>.</p>
			<p>In our case, the lookup regex will be <code>post_pk</code>.</p>
			<ol>
				<li value="3">The next<a id="_idIndexMarker226"/> step is to register the <code>comment</code> route on <code>post_router</code>:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/routers.py</p>
			<pre class="source-code">
...
# ##################################################################### #
# ################### POST                       ###################### #
# ##################################################################### #
router.register(r'post', PostViewSet, basename='post')
posts_router = routers.NestedSimpleRouter(router, r'post', lookup='post')
posts_router.register(r'comment', CommentViewSet, basename='post-comment')
urlpatterns = [
   *router.urls,
   *posts_router.urls
]
...</pre>
			<p>Great! The comment resource is available, but we must rewrite the <code>create</code>, <code>get_object</code>, and <code>get_queryset</code> methods on the <code>CommentViewSet</code> class. Let’s see how using nested routes can modify the logic of retrieving objects in the next section.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor085"/>Writing the CommentViewSet class</h2>
			<p>We now<a id="_idIndexMarker227"/> have a clear idea of how the endpoint will work.</p>
			<p>Follow these steps in the <code>core/comment/viewsets.py</code> file to finish writing the <code>CommentViewSet</code> class:</p>
			<ol>
				<li value="1">Rewrite the <code>get_queryset</code> method of the <code>CommentViewSet</code> class to fit the new architecture of the endpoint:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/viewsets.py</p>
			<pre class="source-code">
...
class CommentViewSet(AbstractViewSet):
...
   def get_queryset(self):
       if self.request.user.is_superuser:
           return Comment.objects.all()
       post_pk = self.kwargs['post_pk']
       if post_pk is None:
           return Http404
       queryset = Comment.objects.filter(
         post__public_id=post_pk)
       return queryset</pre>
			<p>In the preceding code, <code>get_queryset</code> is the method called when the user hits the <code>/api/post/post_pk/comment/</code> endpoint. The first verification here is to check whether the user is a superuser. If that’s the case, we return all the comment objects in the database.</p>
			<p>If the user is not a superuser, then we’ll return the comments concerning a post. With the post nested route, we set the <code>lookup</code> attribute to <code>post</code>. That means that in <code>kwargs</code> (a dictionary containing additional data) of every request, a public id value of the <code>post</code> with the dictionary key <code>post_pk</code> will be passed in the URL of the endpoint.</p>
			<p>If that’s not the case, we just return a 404 Not Found response.</p>
			<p>We then <a id="_idIndexMarker228"/>make a query to the database by filtering and retrieving only comments that have the <code>post.public_id</code> field equal to <code>post_pk</code>. This is done with the filter method provided by the Django ORM. It’s useful to write conditions for retrieving objects from the database.</p>
			<ol>
				<li value="2">Next, let’s add the <code>get_object</code> method to the same <code>CommentViewSet</code> so we can use the <code>public_id</code> to retrieve the specific comment:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/viewsets.py</p>
			<pre class="source-code">
...
class CommentViewSet(AbstractViewSet):
...
   def get_object(self):
       obj = Comment.objects.get_object_by_public_id(
         self.kwargs['pk'])
       self.check_object_permissions(self.request,
                                     obj)
       return obj
...</pre>
			<p>Similar to the <code>UserViewSet</code> <code>get_object</code> method, this method is called on each request made to the <code>/api/post/post_pk/comment/comment_pk/</code> endpoint. Here, <code>pk</code> is represented by <code>comment_pk</code>.</p>
			<p>Then, we <a id="_idIndexMarker229"/>retrieve the object and check for permissions. If everything is good, we return the object.</p>
			<ol>
				<li value="3">And as the last step, let’s write the <code>create</code> method:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/viewsets.py</p>
			<pre class="source-code">
...
class CommentViewSet(AbstractViewSet):
...
   def create(self, request, *args, **kwargs):
       serializer =
         self.get_serializer(data=request.data)
       serializer.is_valid(raise_exception=True)
       self.perform_create(serializer)
       return Response(serializer.data,
                       status=status.HTTP_201_CREATED)</pre>
			<p>Similar to the <code>create</code> method on <code>PostViewSet</code>, we pass <code>request.data</code> to the <code>ViewSet</code> serializer – <code>CommentSerialier</code> – and try to validate the serializer.</p>
			<p>If everything is good, we move to create a new object – a new comment – based on the serializer from <code>CommentSerializer</code>.</p>
			<p>Great! We now have a fully functional <code>ViewSet</code>. Next, let’s test the features with Insomnia.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor086"/>Testing the comments feature with Insomnia</h2>
			<p>Before trying <a id="_idIndexMarker230"/>to retrieve comments, let’s create some comments with <code>POST</code> on the <code>/api/post/post_id/comment/</code> URL by following these steps:</p>
			<ol>
				<li value="1">Replace <code>post_id</code> with <code>public_id</code> of a post that you have already created.</li>
			</ol>
			<p>Here’s an example of a payload for this request:</p>
			<pre class="source-code">
{
    "author": "61c5a1ecb9f5439b810224d2af148a23",
    "body": "Hey! I like your post.",
    "post": "e2401ac4b29243e6913bd2d4e0944862"
}</pre>
			<p>And here’s a screenshot of a request made to create a comment in Insomnia:</p>
			<div><div><img src="img/Figure_4.03_B18221.jpg" alt="Figure 4.3 – Creating a post"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Creating a post</p>
			<ol>
				<li value="2">Great! Now, modify the type of request from <code>POST</code> to <code>GET</code>. You’ll get all the comments concerning the post:</li>
			</ol>
			<div><div><img src="img/Figure_4.04_B18221.jpg" alt="Figure 4.4 – Listing all comments"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Listing all comments</p>
			<p>Now that it’s <a id="_idIndexMarker231"/>possible to create a comment without issues, let’s add a feature for updating a comment and deleting a comment.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor087"/>Updating a comment</h1>
			<p>Updating a <a id="_idIndexMarker232"/>comment is an action that can only be done by the author of the comment. And the user should only be able to update the body field of the comment and can’t modify the author value. Follow these steps to add the update feature:</p>
			<ol>
				<li value="1">In <code>core/comment/viewsets</code>, make sure that <code>put</code> is in the list of <code>http_method_names</code> of <code>CommentViewSet</code>:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/viewsets</p>
			<pre class="source-code">
...
class CommentViewSet(AbstractViewSet):
   http_method_names = ('post', 'get', 'put',
                        'delete')
...</pre>
			<p>After that, let’s write a <code>validate</code> method for the <code>post</code> field. We want to make sure that this value is not editable on <code>PUT</code> requests.</p>
			<ol>
				<li value="2">Inside <a id="_idIndexMarker233"/>the <code>core/comment/serializers.py</code> file, add a new method called <code>validate_post</code> to <code>CommentSerializer</code>:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/serializers.py</p>
			<pre class="source-code">
...
def validate_post(self, value):
   if self.instance:
       return self.instance.post
   return value
...</pre>
			<p>Every model serializer provides an <code>instance</code> attribute that holds the object that will be modified if there is a <code>delete</code>, <code>put</code>, or <code>patch</code> request. If this is a <code>GET</code> or <code>POST</code> request, this attribute is set to <code>None</code>.</p>
			<ol>
				<li value="3">Next, let’s rewrite the <code>update</code> method on the <code>CommentSerializer</code> class. We’ll rewrite this class to pass the edited value to <code>True</code>:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/serializers.py</p>
			<pre class="source-code">
...
class CommentSerializer(AbstractSerializer):
   ...
   def update(self, instance, validated_data):
       if not instance.edited:
           validated_data['edited'] = True
       instance = super().update(instance,
                                 validated_data)
       return instance
…</pre>
			<ol>
				<li value="4">Great! Now, let’s <a id="_idIndexMarker234"/>try a <code>PUT</code> request in Insomnia on the <code>/api/post/post_pk/comment/comment_pk/</code> endpoint. Here’s an example of a JSON body for the request:<pre class="source-code">
{</pre><pre class="source-code">
    "author": "61c5a1ecb9f5439b810224d2af148a23",</pre><pre class="source-code">
    "body": "A simple comment edited",</pre><pre class="source-code">
    "post": "e2401ac4b29243e6913bd2d4e0944862"</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>And here’s a screenshot of a <code>PUT</code> request in Insomnia:</p>
			<div><div><img src="img/Figure_4.05_B18221.jpg" alt="Figure 4.5 – Modifying a post"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Modifying a post</p>
			<p>You will <a id="_idIndexMarker235"/>notice in the response body that the <code>edited</code> field is set to <code>true</code>, and the body of the comment has changed as well.</p>
			<p>Now that it’s possible to modify a comment, let’s add the feature for deleting a comment.</p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor088"/>Deleting a comment</h1>
			<p>Deleting a comment <a id="_idIndexMarker236"/>is an action that can only be performed by the author of the post, the author of the comment, and a superuser. To implement this rule, we’ll simply add some permissions in the <code>UserPermission</code> class by following these steps:</p>
			<ol>
				<li value="1">Make sure that <code>delete</code> is in the list of <code>http_method_names</code> of the <code>CommentViewSet</code> class:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/comment/viewsets</p>
			<pre class="source-code">
...
class CommentViewSet(AbstractViewSet):
   http_method_names = ('post', 'get', 'put',
                        'delete')
…</pre>
			<ol>
				<li value="2">Once<a id="_idIndexMarker237"/> it’s done, let’s add more verifications in the <code>core/auth/permissions</code> file in the <code>has_object_permission</code> method of the <code>UserPermission</code> class:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/permissions</p>
			<pre class="source-code">
...
def has_object_permission(self, request, view, obj):
...
   if view.basename in ["post-comment"]:
       if request.method in ['DELETE']:
           return bool(request.user.is_superuser or
                       request.user in [obj.author,
                       obj.post.author])
       return bool(request.user and
                   request.user.is_authenticated)
…</pre>
			<p>All requests can be made on the <code>post-comment</code> endpoint. However, if the method of the request is <code>DELETE</code>, we check whether the user is a superuser, the author of the comment, or the author of the post.</p>
			<ol>
				<li value="3">Let’s try to <a id="_idIndexMarker238"/>delete the comment in Insomnia at this endpoint: <code>/api/post/post_pk/comment/comment_pk/</code>. Make sure you have the access token of the post author or the comment author.</li>
			</ol>
			<p>And here’s a screenshot of a <code>DELETE</code> request to delete a comment under a post:</p>
			<div><div><img src="img/Figure_4.06_B18221.jpg" alt="Figure 4.6 – Deleting a post"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Deleting a post</p>
			<p>Great, the feature is working like a charm. And we’ve just learned how to write permissions for a <code>DELETE</code> request.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor089"/>Summary</h1>
			<p>In this chapter, we’ve learned how to create a comment feature for the posts in our social media projects. That led us to learn more about how to better structure an endpoint using nested routers but also how to write custom permissions.</p>
			<p>We’ve also dived deeper into serializer validations and how they work on different HTTP requests.</p>
			<p>In the next chapter, we’ll focus on writing unit and integration tests for every feature added to the project.</p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor090"/>Questions</h1>
			<ol>
				<li value="1">What is a nested route?</li>
				<li>What is <code>drf-nested-routers</code>?</li>
				<li>Which attribute on a model serializer can help you to know whether the request is a <code>PUT</code> or a <code>DELETE</code> request?</li>
			</ol>
		</div>
		<div><div></div>
		</div>
	</body></html>