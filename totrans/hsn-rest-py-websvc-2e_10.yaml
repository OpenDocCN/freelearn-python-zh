- en: Developing RESTful APIs with Tornado 5.1.1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will work with Tornado 5.1.1 to create a RESTful Web API.
    We will start working with this lightweight web framework. We will look at the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Design a RESTful API to interact with slow sensors and actuators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the tasks performed by each HTTP method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up a virtual environment with Tornado 5.1.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create classes that represent a drone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write request handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map URL patterns to request handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make HTTP requests to the Tornado API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with command-line tools—`curl` and `httpie`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with GUI tools—Postman and others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a RESTful API to interact with slow sensors and actuators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that we have to create a RESTful API to control a drone, also known
    as a **UAV** (short for **Unmanned Aerial Vehicle**). The drone is an IoT device
    that interacts with many sensors and actuators, including digital electronic speed
    controllers linked to engines, propellers, and servomotors.
  prefs: []
  type: TYPE_NORMAL
- en: The IoT device has limited resources, and therefore we have to use a lightweight
    web framework. Our API doesn't need to interact with a database. We don't need
    a heavyweight web framework such as Django, with all its features and its integrated
    ORM. We want to be able to process many requests without blocking the web server.
    We need the web server to provide us with nice scalability ...
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the tasks performed by each HTTP method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's consider that `http://localhost:8888/hexacopters/1` is the URL that identifies
    the hexacopter for our drone.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to compose and send an HTTP request with the HTTP verb (`PATCH`) and
    request URL (`http://localhost:8888/hexacopters/1`) to set the hexacopter''s status
    and motor speed in RPMs. In addition, we have to provide the JSON key-value pairs
    with the necessary field name and the value to specify the desired speed. As a
    result of the request, the server will validate the provided values for the field,
    make sure that it is a valid speed, and make the necessary calls to adjust the
    speed with an asynchronous execution. After the speed for the hexacopter is set,
    the server will return an HTTP `200 OK` status code and a JSON body with the recently
    updated hexacopter values serialized to JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to compose and send an HTTP request with the HTTP verb (`GET`) and
    request URL (`http://localhost:8888/hexacopter/1`) to retrieve the current values
    for the hexacopter. The server will make the necessary calls to retrieve the status
    and the speed for the hexacopter with an asynchronous execution. As a result of
    the request, the server will return an HTTP `200 OK` status code and a JSON body
    with the serialized key-value pairs that specify the status and speed for the
    hexacopter. If a number different than `1` is specified, the server will return
    just an HTTP `404 Not Found` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to compose and send an HTTP request with the HTTP verb (`PATCH`) and
    request URL (`http://localhost:8888/led/{id}`) to set the brightness level for
    a specific LED whose `id` matches the specified numeric value in the place where
    `{id}` is written. For example, if we use the request URL `http://localhost:8888/led/1`,
    the server will set the brightness level for the LED whose `id` matches `1`. In
    addition, we have to provide the JSON key-value pairs with the necessary field
    name and the value to specify the desired brightness level. As a result of the
    request, the server will validate the provided values for the field, making sure
    that it is a valid brightness level and making the necessary calls to adjust the
    brightness level with an asynchronous execution. After the brightness level for
    the LED is set, the server will return a `200 OK` status code and a JSON body
    with the recently updated LED values serialized to JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to compose and send an HTTP request with the HTTP verb (`GET`) and
    request URL (`http://localhost:8888/led/{id}`) to retrieve the current values
    for the LED whose `id` matches the specified numeric value in the place where
    `{id}` is written. For example, if we use the request URL `http://localhost:8888/led/1`,
    the server will retrieve the LED whose `id` matches `1`, that is, the green LED.
    The server will make the necessary calls to retrieve the values for the LED with
    an asynchronous execution. As a result of the request, the server will return
    an HTTP `200 OK` status code and a JSON body with the serialized key-value pairs
    that specify the values for the LED. If no LED matches the specified `id`, the
    server will just return an HTTP `404 Not Found` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to compose and send an HTTP request with the HTTP verb (`GET`) and
    request URL (`http://localhost:8888/altimeter/1?unit=feet`) to retrieve the current
    value for the altimeter in feet. The server will make the necessary calls to retrieve
    the value for the altimeter with an asynchronous execution. As a result of the
    request, the server will return an HTTP `200 OK` status code and a JSON body with
    the serialized key-value pairs that specify the value for the altimeter. If a
    number different than `1` is specified, the server will return just an HTTP `404
    Not Found` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If we want to retrieve the value for the altimeter in meters, we have to compose
    and send an HTTP request with the HTTP verb (`GET`) and request URL (`http://localhost:8888/altimeter/1?unit=meters`).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a virtual environment with Tornado 5.1.1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](dbf75cef-4962-4e40-8192-03873b774c48.xhtml), *Developing RESTful
    APIs and Microservices with Flask 1.0.2*, we learned that throughout this book
    we are going to work with the lightweight virtual environments introduced and
    improved in Python 3.4\. Now, we will follow many steps to create a new lightweight
    virtual environment to work with Tornado 5.1.1\. It is highly recommended to read
    the section named *Working with lightweight virtual environments* in [Chapter
    1](dbf75cef-4962-4e40-8192-03873b774c48.xhtml), *Developing RESTful APIs and Microservices
    with Flask 1.0.2*, if you don't have experience with lightweight virtual environments
    in modern Python. The chapter includes all the detailed explanations about the
    effects of the steps we are going to follow.
  prefs: []
  type: TYPE_NORMAL
- en: The following ...
  prefs: []
  type: TYPE_NORMAL
- en: Creating classes that represent a drone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create the following classes that we will use to represent the different
    components of a drone:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `HexacopterStatus` | This class stores status data for the hexacopter |'
  prefs: []
  type: TYPE_TB
- en: '| `Hexacopter` | This class represents a hexacopter |'
  prefs: []
  type: TYPE_TB
- en: '| `LightEmittingDiode` | This class represents an LED connected to the drone
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Altimeter` | This class represents the altimeter that measures the current
    altitude for the drone |'
  prefs: []
  type: TYPE_TB
- en: '| `Drone` | This class represents the drone with its different sensors and
    actuators |'
  prefs: []
  type: TYPE_TB
- en: In a real-life example, these classes would interact with a library that interacts
    with sensors and actuators. In order to keep our example simple, we will make
    calls to `time.sleep` to simulate interactions that take some time to write values
    to interfaces with sensors and actuators. We will use the same procedure to simulate
    interactions that take some time to retrieve values from interfaces with sensors.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will create the `Hexacopter` class, which we will use to represent
    the hexacopter, and a `HexacopterStatus` class, which we will use to store status
    data for the hexacopter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Python file named `drone.py` in the root folder of the virtual
    environment (`Tornado01`). The following lines show all the necessary imports
    for the classes that we will create and the code that declares the `Hexacopter`
    and `HexacopterStatus` classes in this file. The code file for the sample is included
    in the `restful_python_2_10_01` folder, in the `Django01/drone.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HexacopterStatus` class just declares a constructor, the `__init__` method.
    This method receives many arguments and uses them to initialize the attributes
    with the same names: `motor_speed` and `is_turned_on`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Hexacopter` class declares two class attributes that specify the minimum
    and maximum speed values for its motor: `MIN_MOTOR_SPEED` and `MAX_MOTOR_SPEED`.
    The constructor, the `__init__` method, initializes the `_motor_speed` attribute
    with the `MIN_MOTOR_SPEED` value and sets the `_is_turned_on` attribute to `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `motor_speed` property getter, the `motor_speed` method that has the `@property`
    decorator, returns the value of the `_motor_speed` attribute. The `motor_speed`
    property setter, which is the `motor_speed` method that has the `@motor_speed.setter`
    decorator, checks whether the value for the `value` argument is in the valid range.
    If the validation fails, the method raises a `ValueError` exception. Otherwise,
    the method sets the value of the `_motor_speed` attribute with the received value
    and sets the value for the `_is_turned_on` attribute to `True` if the `motor_speed`
    property is greater than `0`. Finally, the method calls `sleep` to simulate that
    it takes two seconds to complete these operations.
  prefs: []
  type: TYPE_NORMAL
- en: The `is_turned_on` property getter, the `is_turned_on` method that has the `@property`
    decorator, returns the value of the `_is_turned_on` attribute. The `status` property
    getter calls `sleep` to simulate that it takes three seconds to retrieve the hexacopter
    status and then returns a `HexacopterStatus` instance initialized with the `motor_speed`
    and `turned_on` property values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stay in the `drones.py` file in the root folder for the virtual environment
    (`Tornado01`). Add the following lines to declare a `LightEmittingDiode` class
    that we will use to represent each LED. The code file for the sample is included
    in the `restful_python_2_10_01` folder, in the `Django01/drone.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LightEmittingDiode` class declares two class attributes that specify the
    minimum and maximum brightness level values for an LED: `MIN_BRIGHTNESS_LEVEL`
    and `MAX_BRIGHTNESS_LEVEL`. The constructor, the `__init__` method, initializes
    the `_brightness_level` attribute with the `MIN_BRIGHTNESS_LEVEL` and the `id`
    and `description` attributes with the values received in the arguments with the
    same names.'
  prefs: []
  type: TYPE_NORMAL
- en: The `brightness_level` property getter, the `brightness_level` method that has
    the `@property` decorator, calls `sleep` to simulate it taking `1` second to retrieve
    the brightness level for the wired LED, and then returns the value of the `_brightness_level`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The `brightness_level` property setter, the `brightness_level` method that has
    the `@brightness_level.setter` decorator, checks whether the value for the `value`
    argument is in the valid range. If the validation fails, the method raises a `ValueError`
    exception. Otherwise, the method calls `sleep` to simulate it taking two seconds
    to set the new brightness level and finally sets the value of the `_brightness_level`
    attribute with the received value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stay in the `drones.py` file in the root folder for the virtual environment
    (`Tornado01`). Add the following lines to declare an `Altimeter` class that we
    will use to represent the altimeter. The code file for the sample is included
    in the `restful_python_2_10_01` folder, in the `Django01/drone.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `Altimeter` class declares an `altitude` property setter that calls `sleep`
    to simulate it taking one second to retrieve the altitude from the altimeter,
    and finally generates a random integer from `0` to `3000` (inclusive) and returns
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stay in the `drones.py` file in the root folder for the virtual environment
    (`Tornado01`). Add the following lines to declare a `Drone` class, which we will
    use to represent the drone with its sensors and actuators. The code file for the
    sample is included in the `restful_python_2_10_01` folder, in the `Django01/drone.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `Drone` class just declares a constructor, the `__init__` method, which
    creates instances of the previously declared classes that represent the different
    components for the drone. The `leds` attribute saves a dictionary that has a key-value
    pair for each `LightEmittingDiode` instance with its `id` and its instance.
  prefs: []
  type: TYPE_NORMAL
- en: Writing request handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main building blocks for a RESTful API in Tornado are subclasses of the
    `tornado.web.RequestHandler` class, that is, the base class for HTTP request handlers
    in Tornado. We just need to perform the following tasks to build our RESTful API
    that interacts with a drone:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a subclass of the `RequestHandler` class and declare the methods for
    each supported HTTP verb
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the methods to handle HTTP requests
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Map the URL patterns to each subclass of the `RequestHandler` superclass in
    the `tornado.web.Application` instance that represents the Tornado web application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will create the following subclasses of the `RequestHandler` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `HexacopterHandler` | This class processes the HTTP ... |'
  prefs: []
  type: TYPE_TB
- en: Mapping URL patterns to request handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows the method of our previously created HTTP handler
    classes that we want to be executed for each combination of HTTP verb and scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '| HTTP verb | Scope | Class and method |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Altimeter | `AltimeterHandler.get` |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Hexacopter | `HexacopterHandler.get` |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Hexacopter | `HexacopterHandler.patch` |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | LED | `LedHandler.get` |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | LED | `LedHandler.patch` |'
  prefs: []
  type: TYPE_TB
- en: If the request results in the invocation of an HTTP handler class with an unsupported
    HTTP method, Tornado will return a response with the HTTP `405 Method Not Allowed`
    status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we must map URL patterns to our previously coded subclasses of the `RequestHandler`
    superclass. Stay in the `drone_service.py` file in the root folder for the virtual
    environment (`Tornado01`). Add the following lines to declare the `Application`
    class and the `__main__` method. The code file for the sample is included in the
    `restful_python_2_10_01` folder, in the `Django01/drone_service.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The code declares an `Application` class as a subclass of the `tornado.web.Application`
    superclass. This class overrides the inherited constructor, that is, the `__init__`
    method. The constructor declares the `handlers` list that maps URL patterns to
    synchronous request handlers and then calls the inherited constructor with the
    list as one of its arguments. The `handlers` list is composed of a regular expression
    (`regexp`) and a `tornado.web.RequestHandler` subclass (`request_class`).
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `main` method creates an instance of the `Application` class and calls
    the `application.listen` method to build an HTTP server for the application with
    the defined rules on the specified port. In this case, the code specifies `8888`
    as the port, saved in the `port` variable, which is the default port for Tornado
    HTTP servers.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code registers and starts a periodic callback, named `periodic_callback`,
    that will be executed every 500 milliseconds by the `IOLoop` to make it possible
    to use *Ctrl* + *C* to stop the HTTP server. This code will be useful for the
    second version of our API. However, we write it now to avoid editing the code
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code calls the `tornado_ioloop.start` method to start the server. This
    server was created with the previous call to the `application.listen` method.
  prefs: []
  type: TYPE_NORMAL
- en: Making HTTP requests to the Tornado API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can run the `drone_service.py` script, which launches the development
    server for Tornado 5.1.1 to compose and send HTTP requests to our unsecured and
    simple web API. Execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output after we execute the previous command.
    The Tornado HTTP development server is listening on port `8888`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With the previous command, we will start the Tornado HTTP server and it will
    listen on every interface on port `8888`. Thus, if we want to make HTTP requests
    to our API from other computers or devices connected to our LAN, we don't need
    any additional configurations.
  prefs: []
  type: TYPE_NORMAL
- en: If you decide to compose and send HTTP requests from ...
  prefs: []
  type: TYPE_NORMAL
- en: Working with command-line tools - curl and httpie
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start composing and sending HTTP requests with the `curl` and HTTPie
    command-line tools, which we introduced in [Chapter 1](dbf75cef-4962-4e40-8192-03873b774c48.xhtml),
    *Developing RESTful APIs and Microservices with Flask 1.0.2*, in the section named
    *Working with command-line tools - curl and httpie*. Make sure you read this section
    before executing the next examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever we compose HTTP requests with the command line, we will use two versions
    of the same command: the first one with HTTPie and the second one with `curl`.
    This way, you will be able to use the most convenient for you.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you leave the Tornado 5.1.1 development server running. Don''t close
    the Terminal or Command Prompt that is running this development server. Open a
    new Terminal in macOS or Linux, or a Command Prompt in Windows, activate the virtual
    environment we have been using, and run the following command. We will compose
    and send an HTTP `PATCH` request to turn on the hexacopter and set its motor speed
    to `50` RPMs. The code file for the sample is included in the `restful_python_2_10_01`
    folder, in the `Tornado01/cmd/cmd1101.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_10_01` folder, in the `Tornado01/cmd/cmd1102.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the HTTP request `PATCH http://localhost:8888/hexacopters/1`
    with the following JSON key-value pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The request specifies `/hexacopters/1`, and therefore Tornado will iterate over
    the list of tuples with regular expressions and request classes, and will match
    the `'/hexacopters/([0-9]+)'` regular expression. Tornado will create an instance
    of the `HexacopterHandler` class and run the `HexacopterHandler.patch` method
    with `1` as the value for the `id` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the HTTP verb for the request is `PATCH`, Tornado calls the `patch` method.
    If the hexacopter''s speed is successfully set, the method returns an HTTP `200
    OK` status code and the key-value pairs with the speed and status for the recently
    updated hexacopter serialized to JSON in the response body. The following lines
    show an example response for the HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will write a command to compose and send an HTTP `GET` request to retrieve
    the status and the motor speed for the hexacopter. Run the following command.
    The code file for the sample is included in the `restful_python_2_10_01` folder,
    in the `Tornado01/cmd/cmd1103.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_10_01` folder, in the `Tornado01/cmd/cmd1104.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8888/hexacopters/1`. The request specifies `/hexacopters/1`,
    and therefore it will match the `''/hexacopters/([0-9]+)''` regular expression
    and run the `HexacopterHandler.get` method with `1` as the value for the `id`
    argument. As the HTTP verb for the request is `GET`, Tornado calls the `get` method.
    The method retrieves the hexacopter''s status and generates a JSON response with
    the key-value pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines show an example response for the HTTP request. The first
    lines show the HTTP response headers, including the status (`200 OK`) and the
    content type (`application/json`). After the HTTP response headers, we can see
    the details for the hexacopter''s status in the JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After we run the two requests, we will see the following lines in the window
    that is running the Tornado HTTP server. The output shows the results of executing
    the print statements that describe when the code started setting or retrieving
    information, and when it finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The different methods we coded in the request handler classes end up calling
    `time.sleep` to simulate the operations taking some time with the hexacopter.
    In this case, our code is running with a synchronous execution, and therefore
    each time we compose and send a request, the Tornado server is blocked until the
    operation with the hexacopter finishes and the method sends the response. We will
    create a new version of this API that will use an asynchronous execution later,
    and will understand the advantages of Tornado's non-blocking features. However,
    first, we will understand how the synchronous version of the API works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows two Terminal windows side by side on macOS.
    The Terminal window on the left-hand side is running the Tornado HTTP server and
    displays the messages printed in the methods that process the HTTP requests. The
    Terminal window on the right-hand side is running `http` commands to generate
    the HTTP requests. It is a good idea to use a similar configuration to check the
    output while we compose and send the HTTP requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0848a1c-faa5-48a8-b90e-5fcb8a853cff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will write a command to compose and send an HTTP request to retrieve
    a hexacopter that doesn''t exist. Remember that we just have one hexacopter in
    our drone. Run the following command to try to retrieve the status for a hexacopter
    with an invalid `id`. We must make sure that the utilities display the headers
    as part of the response to see the returned status code. The code file for the
    sample is included in the `restful_python_2_10_01` folder, in the `Tornado01/cmd/cmd1105.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_10_01` folder, in the `Tornado01/cmd/cmd1106.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8888/hexacopters/5`. The request is the same as the previous
    one we have analyzed, with a different number for the `id` parameter. The server
    will run the `HexacopterHandler.get` method with `5` as the value for the `id`
    argument. The `id` is not equal to `1`, and therefore the code will return an
    HTTP `404 Not Found` status code. The following lines show an example header response
    for the HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will write a command to compose and send an HTTP `GET` request to retrieve
    the altitude from the altimeter included in the drone, expressed in meters. Run
    the following command. The code file for the sample is included in the `restful_python_2_10_01`
    folder, in the `Tornado01/cmd/cmd1107.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_10_01` folder, in the `Tornado01/cmd/cmd1108.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8888/altimeters/1?unit=meters`. The request specifies `/altimeters/1`,
    and therefore it will match the `''/altimeters/([0-9]+)''` regular expression
    and run the `AltimeterHandler.get` method with `1` as the value for the `id` argument.
    As the HTTP verb for the request is `GET`, Tornado calls the `get` method. The
    method will retrieve the value for the unit query parameter, retrieve the altimeter''s
    altitude in feet, convert it to meters, and generate a JSON response with the
    key-value pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines show an example response for the HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will write a command to compose and send an HTTP `GET` request to retrieve
    the altitude from the altimeter included in the drone, expressed in the default
    unit: feet. Run the following command. The code file for the sample is included
    in the `restful_python_2_10_01` folder, in the `Tornado01/cmd/cmd1109.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_10_01` folder, in the `Tornado01/cmd/cmd1110.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8888/altimeters/1`. The request specifies `/altimeters/1`, and
    therefore it will match the `''/altimeters/([0-9]+)''` regular expression and
    run the `AltimeterHandler.get` method with `1` as the value for the `id` argument.
    As the HTTP verb for the request is `GET`, Tornado calls the `get` method. In
    this case, there is no unit query parameter, and therefore the method will retrieve
    the altimeter''s altitude in feet and generate a JSON response with the key-value
    pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines show an example response for the HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the altitude value is a random number generated each time we require
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Working with GUI tools - Postman and others
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been working with two terminal-based or command-line tools
    to compose and send HTTP requests to our Django development server: cURL and HTTPie.
    Now, we will work with one of the GUI tools we used when composing and sending
    HTTP requests to the Flask development server in [Chapter 1](dbf75cef-4962-4e40-8192-03873b774c48.xhtml),
    *Developing RESTful APIs and Microservices with Flask 1.0.2*. In case you skipped
    this chapter, make sure you check the installation instructions in the section
    named *Working with GUI tools - Postman and others*.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you launch Postman, make sure you close the modal that provides shortcuts
    to common tasks. Select the GET request in the + new drop-down menu in the upper-left
    corner of the Postman main window. ...
  prefs: []
  type: TYPE_NORMAL
- en: Running unit tests with pytest and checking testing coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will use the `pytest` command to run tests and measure their code coverage.
    Make sure you run the command in the Terminal or Command Prompt window in which
    you have activated the virtual environment, and that you are located within its
    root folder (`Tornado01`). Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The test runner will execute all the functions defined in `tests.py` that start
    with the `test_` prefix, and will display the results. We use the `-v` option
    to instruct `pytest` to print the test function names and statuses in verbose
    mode. The `--cov` option turns on test coverage report generation with the use
    of the `pytest-cov` plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines show the sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The output provides details that the test runner discovered and executed one
    test, which passed. The output displays the module and function names for each
    method in the `test_views` module that started with the `test_` prefix and represented
    a test to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: The test code coverage measurement report provided by the `coverage` package,
    in combination with the `pytest-cov` plugin, uses the code analysis tools and
    the tracing hooks included in the Python standard library to determine which lines
    of code are executable and which of these lines have been executed. The report
    provides a table with the columns we examined in [Chapter 4](59ca9314-9d32-4507-b260-7f38c82798f2.xhtml),
    *Testing and Deploying an API in a Microservice with Flask*, in the section named
    *Running unit tests with pytest and checking testing coverage*.
  prefs: []
  type: TYPE_NORMAL
- en: We definitely have a very low coverage for the `async_drone_service.py` and
    `drone.py` modules, based on the measurements shown in the report. In fact, we
    just wrote one test related to LEDs, and therefore it makes sense that the coverage
    has to be improved. We didn't create tests related to other hexacopter resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the `coverage` command with the `-m` command-line option to display
    the line numbers of the missing statements in a new `Missing` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will use the information from the last execution and will display
    the missing statements and the missing branches. The next lines show a sample
    output that corresponds to the previous execution of the unit tests. A dash (`-`)
    is used to indicate a range of lines that were missed. For example, `107-109`
    means that lines `107` and `109` were missing statements. A dash followed by a
    greater than sign (`->`) indicates that the branch from the line before `->` to
    the line after it was missed. For example, `61->62` means that the branch from
    line `61` to line `62` was missed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following command to get annotated HTML listings detailing missed
    lines. The command won''t produce any output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `index.html` HTML file generated in the `htmlcov` folder with your
    web browser. The following screenshot shows an example report coverage generated
    in HTML format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/958a3197-7bfd-4bf5-aa07-81806eb54aa0.png)'
  prefs: []
  type: TYPE_IMG
- en: Click or tap `async_drone_service.py` and the web browser will render a web
    page that displays the statements that were run, the missing ones, the excluded,
    and the partially executed with different colors. We can click or tap on the run,
    missing, excluded, and partial buttons to show or hide the background color that
    represents the status for each line of code. By default, the missing lines of
    code will be displayed with a pink background, and those partially executed will
    be displayed with a yellow background­­[­­]. Thus, we must write unit tests that
    target these lines of code to improve our test coverage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the buttons with the summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63db9824-4440-4190-8a3a-011e7013235d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next screenshot shows the highlighted missing lines and the partially evaluated
    branches for some lines of code in the `async_drone_service.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb9ce674-14ed-4293-9059-b352ddf91fb0.png)'
  prefs: []
  type: TYPE_IMG
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see whether you can answer the following questions correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following methods allows us to set the HTTP status code for a response
    in a subclass of `tornado.web.RequestHandler`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`self.write_status`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`self.__cls__.write_status_code`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`self.set_satus`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following methods allows us to write the response in a subclass
    of `tornado.web.RequestHandler`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`self.write_response`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`self.write`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`self.set_response`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The main building blocks for a RESTful API in Tornado are subclasses of which
    of the following classes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tornado.web.GenericHandler`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tornado.web.RequestHandler`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tornado.web.IncomingHTTPRequestHandler`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If we just want to support the `GET` and `PATCH` methods, we can override the
    `SUPPORTED_METHODS` class ...
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we designed a RESTful API to interact with slow sensors and
    actuators. We defined the requirements for our API and understood the tasks performed
    by each HTTP method. We set up a virtual environment with Tornado.
  prefs: []
  type: TYPE_NORMAL
- en: We created the classes that represent a drone and wrote code to simulate the
    slow I/O operations that are called for each HTTP request method. We wrote classes
    that represent request handlers and process the different HTTP requests, and we
    configured the URL patterns to route URLs to request handlers and their methods.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we started the Tornado development server and we used command-line
    tools to compose and send HTTP requests to our RESTful API, and analyzed how each
    HTTP request was processed in our code. We also worked with GUI tools to compose
    and send HTTP requests. We realized that each HTTP request takes some time to
    provide a response due to the simulation of slow I/O operations.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the basics of Tornado to create RESTful APIs, we will
    take advantage of the non-blocking features, combined with asynchronous operations
    in Tornado, in a new version of the API for which we will write units tests, which
    are the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
