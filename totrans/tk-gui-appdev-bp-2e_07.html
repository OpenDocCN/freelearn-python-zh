<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Piano Tutor</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the last chapter, we explored most of the common options available for the Canvas widget. Let's now see the PhotoImage widget in action.</p>
<p class="mce-root">Let's build a program called <em>Piano Tutor</em>. This program will help new piano players identify musical scales, chords, and chord progressions. It will also help piano learners learn and identify music written on music sheets. People with some musical knowledge will feel right at home, but do not worry if you know nothing about piano or musical terms such as scales, chords, and chord progressions. We will cover the bare minimum of musical know-how as we progress.</p>
<p>In its final form, the program looks as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="255" src="assets/290771f0-61fd-43ba-8210-0d8eb4af6f03.png" width="330"/></div>
<p>The <span class="packt_screen">Piano Tutor</span> will have <em>three broad sections</em> that can be selected from the topmost drop-down menu. They are as follows:</p>
<ul>
<li>Scale Finder</li>
<li>Chord Finder</li>
<li>Chord Progression Builder</li>
</ul>
<p>Some of the key objectives of this chapter are:</p>
<ul>
<li>Getting to understand some important methods defined on the root window</li>
<li> Using the PhotoImage widget class</li>
<li>Practical applications of the Place geometry manager</li>
<li>Understanding grid weights</li>
<li>Learning how to work with seemingly complex ideas such as representing musical knowledge in a fashion that computers can understand</li>
<li>Using JSON to store data</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>Besides Tkinter, we will use a few standard Python libraries. The next import should execute without any error as they are built-in in most Python distributions:</p>
<pre>import json, <span>collections, functools, math</span></pre>
<p>In addition, we use <kbd>simpleaudio</kbd>, which is a module that lets us play notes on the piano.</p>
<p>You can install <kbd>simpleaudio</kbd> using the following command:</p>
<pre><strong>pip3 install simpleaudio</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A brief primer on piano terms</h1>
                </header>
            
            <article>
                
<p>Since this is a piano-related program, a brief understanding of some of the common terms used in this context is required.</p>
<p>In this section, we will use this figure as a reference:</p>
<div class="CDPAlignCenter CDPAlign"><img height="180" src="assets/fe2797e3-e89e-41a2-8618-d7453baef5da.png" width="369"/></div>
<p>The keyboard of a piano comprises a set of 12 keys (seven white and five black keys), which forms what is called a <strong>chromatic scale</strong>. This pattern of 12 keys repeats over and over again totaling up to 88 keys on a standard piano. The pattern repeats twice in the preceding image (<em>C1</em> to <em>B1</em> and then <em>C2</em> to <em>B2</em>).</p>
<p>The distance between any two adjacent keys is called a <strong>semitone</strong>. Please take note of this term as we will define all piano-related rules using semitones—a measure of distance between keys. An interval of two semitones is called a <strong>whole tone</strong>. We will not bother with whole tones as far as our program is concerned.</p>
<p>The white keys of the piano are labeled by note names <em>A</em> to <em>G</em>. However, as per convention the counting of notes begins at <em>C</em>. <em>C</em> is the first white key just before the set of two black keys. <span>The names of white keys are marked on the keys and the names of black keys are marked above them.</span></p>
<p>Since there are multiple sets of 12 keys they are differentiated among themselves by appending a number after them. For example, <em>C1</em> is the first white key, while <em>C2</em> is the key at the same position, but an octave higher. The black key just next to <em>C</em> is called <strong>C sharp</strong> (<strong>C#</strong>). Since it is also just before the key <strong>D</strong> it has another name—<em>D</em> flat ( D♭). We will, however, stick with calling all black keys by using the sharp symbol (#). Since the notes <em>E</em> and <em>B</em> do not have any sharp keys they are not immediately followed by any black key.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning about scales</h1>
                </header>
            
            <article>
                
<p>A <strong>scale</strong> is <span>an organized sequence of notes chosen from the 12 notes in a particular pattern, which gives it a characteristic feel, perhaps a happy, sad, exotic, oriental, enigmatic, or rebellious feel. A scale can start on any note of the 12 notes and follows a definite pattern. The first note of a scale is called its <strong>root note</strong> and the pattern it follows gives it a scale type. </span></p>
<p><span>One particular scale of relevance to us is called the <strong>Major scale</strong>. Starting at any key, the Major scale follows the following pattern:</span></p>
<div class="packt_quote">W W S W W W S</div>
<p>where <em>W</em> stands for whole tone (jump of two keys) and <em>S</em> stands for semitones (jump of one key).</p>
<p><span>For example, if you play the notes</span><span> <em>C1</em>, <em>D1</em>, <em>E1</em>, <em>F1</em>, <em>G1</em>, <em>A1</em>, <em>B1</em>, <em>C2</em>, and back, one-by-one, you have played a <em>C</em> Major scale.  A Major scale sounds uplifting while another scale named minor can sound a bit sad. Don't worry about names—there are hundreds of scales and we just need to know that scales are a <em>sequence</em> of notes played together following a certain set of rules.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning about chords</h1>
                </header>
            
            <article>
                
<p>In contrast, a <strong>chord</strong> is when you play two or more notes simultaneously. For example, if I play three notes C, F, and G altogether; it's a chord. Chords generally provide the bass section to a music.</p>
<p>If you keep playing the same chord over and over again it will sound monotonous—so you jump from one chord—again following a rule. This is called <strong>chord progression</strong>.  More simply, an ordered series of chords is called a chord progression.</p>
<p>The musical notes can be written on a music sheet or <strong>score sheet</strong> that comprises of five lines. The notes are represented by black dots, which can lie on the line or in spaces between them. The names of notes <span>for two octaves </span>are shown on the following score sheet. The icon marked as <strong>treble clef</strong> means that these notes are to be played with the right hand:</p>
<div class="CDPAlignCenter CDPAlign"><img height="86" src="assets/9a5ed504-bde0-4eb3-bcc6-b4a04fd934f0.png" width="304"/></div>
<p>Do not worry, we are not required to memorize the music notation for completing our program. We will, however, use it as a reference when drawing the score sheet.</p>
<p>We are now equipped with all the musical knowledge required to write this program. Let's start coding.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the broad GUI structure</h1>
                </header>
            
            <article>
                
<p>We start as usual by building the root window (<kbd>7.01/view.py</kbd>):</p>
<pre>root = Tk()<br/>SCREEN_WIDTH = root.winfo_screenwidth()<br/>SCREEN_HEIGHT = root.winfo_screenheight()<br/>SCREEN_X_CENTER = (SCREEN_WIDTH - WINDOW_WIDTH) / 2<br/>SCREEN_Y_CENTER = (SCREEN_HEIGHT - WINDOW_HEIGHT) / 2<br/>root.geometry('%dx%d+%d+%d' % (WINDOW_WIDTH, WINDOW_HEIGHT, SCREEN_X_CENTER,  SCREEN_Y_CENTER))<br/>root.resizable(False, False)<br/>PianoTutor(root)<br/>root.mainloop()</pre>
<p><span>We also create a new file named </span><kbd>constants.py</kbd>( <kbd>7.01</kbd>)<span>, which currently holds the height parameters for the window.</span></p>
<p>We use two root window methods,  <kbd>root.winfo_screenwidth()</kbd>and <kbd>root_winfo_screenheight()</kbd>, to obtain the screen width and height, respectively. We define two constants,  <kbd>WINDOW_WIDTH</kbd> and <kbd>WINDOW_HEIGHT</kbd>, and then place the window on the <em>x</em>, <em>y</em> center of the computer screen.</p>
<p><span>Notice the line </span><kbd>root.resizable(False, False)</kbd>. <span>This root window </span><span>method takes two Boolean arguments to decide if the window is resizable in the <em>x</em> and <em>y</em> directions.  Setting both arguments to <kbd>False</kbd> makes our window fixed in size. </span></p>
<p>The root window is then passed as an argument to a new class, <kbd>PianoTutor</kbd>, which takes care of building the internals of the program. This class is defined next.</p>
<p>The GUI for this program is divided into four broad rows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="358" src="assets/8d23c407-3e73-430e-980a-d45939106434.png" width="463"/></div>
<p>The topmost row is built in a <kbd>Frame</kbd> named <kbd>mode_selector_frame</kbd> and has a <kbd>combobox</kbd> that lets the user select from one of three options—scales, chords, and chord progressions.</p>
<p>The second row is a placeholder for placing the music score sheet and is accordingly called the <kbd>score_sheet_frame.</kbd></p>
<p>The third row requires a bit of attention. Depending on what is selected in the topmost <kbd>combobox</kbd>, the contents of this row change.  In our code so far, (<kbd>7.01/view.py</kbd><em>)</em>, it displays three different colored frames for the three different choices one can make using the topmost <kbd>combobox</kbd>. Since we will place controls on this frame, we decided to call it a <kbd>controls_frame</kbd> for want of a better name.</p>
<p>The fourth row shows the piano keyboard and the frame is named <kbd>keyboard_frame</kbd>, the implementation of which will be discussed in the section entitled <em>Making the Piano Keyboard</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Putting up the skeleton structure</h1>
                </header>
            
            <article>
                
<p>To start, we build a class <kbd>PianoTutor</kbd> (<kbd>7.01/view.py</kbd>), the <kbd>__init__</kbd> method of which is defined as follows:</p>
<pre>class PianoTutor:<br/>  <br/>  def __init__(self, root):<br/>    self.root = root<br/>    self.root.title('Piano Tutor')<br/>    self.build_mode_selector_frame()<br/>    self.build_score_sheet_frame()<br/>    self.build_controls_frame()<br/>    self.build_keyboard_frame()<br/>    self.build_chords_frame()<br/>    self.build_progressions_frame()<br/>    self.build_scales_frame()</pre>
<p>In the preceding code, we are simply defining method calls to build multiple Frame widgets of predefined heights.  We won't elaborate much upon the preceding code as we wrote similar code in all of the previous chapters. </p>
<p>Let's look at one example of frame creation. All other frames follow a similar pattern (<kbd>7.01 /view.py</kbd>) and will not be discussed here:</p>
<pre> def build_score_sheet_frame(self):<br/>   self.score_sheet_frame = Frame(self.root, width=WINDOW_WIDTH, height=                    <br/>                      SCORE_DISPLAY_HEIGHT, background='SteelBlue1')<br/>   self.score_sheet_frame.grid_propagate(False)<br/>   Label(self.score_sheet_frame, text='placeholder for score sheet',  <br/>                       background='SteelBlue1').grid(row=1, column=1)<br/>   self.score_sheet_frame.grid(row=1, column=0)</pre>
<p>This is simple <kbd>Frame</kbd> creation using the <kbd>grid</kbd> geometry manager. However, take a note of the line <kbd>self.score_sheet_frame.grid_propagate(False)</kbd>.</p>
<p>In Tkinter, the container window (Frame in the previous example) is designed to <em>shrink to fit</em> around its contents.  </p>
<p>Even though we have explicitly added a  width or height to the frame, if we comment the <kbd>grid_propagate(false)</kbd> line, you will notice that the width and height parameters given by us are simply ignored and the frame will shrink to exactly fit its children—the Label widgets height in our case. We do not want to allow this shrinking of Frames and <kbd>grid_propagate(False)</kbd> lets us achieve that. </p>
<p>If we were using pack manager, we would have used <kbd>frame.pack_propagate(False)</kbd> instead to achieve the same result.</p>
<p>Next, our topmost mode selector <kbd>combobox</kbd> is bound to the following callback (<kbd>7.01/view.py</kbd>):</p>
<pre>self.mode_selector.bind("&lt;&lt;ComboboxSelected&gt;&gt;", self.on_mode_changed)</pre>
<p>Here's how we define the <kbd>on_mode_changed</kbd> method <span>(</span><kbd>7.01<span>/</span>view.py</kbd><span>):</span></p>
<pre>def on_mode_changed(self, event):<br/>  selected_mode = self.mode_selector.get()<br/>  if selected_mode == 'Scales':<br/>    self.show_scales_frame()<br/>  elif selected_mode == 'Chords':<br/>    self.show_chords_frame()<br/>  elif selected_mode == 'Chord Progressions':<br/>    self.show_progressions_frame()<br/><br/>def show_scales_frame(self):<br/>  self.chords_frame.grid_remove()<br/>  self.progressions_frame.grid_remove()<br/>  self.scales_frame.grid()<br/><br/>def show_chords_frame(self):<br/>  self.chords_frame.grid()<br/>  self.progressions_frame.grid_remove()<br/>  self.scales_frame.grid_remove()<br/> <br/>def show_progressions_frame(self):<br/>  self.chords_frame.grid_remove()<br/>  self.progressions_frame.grid()<br/>  self.scales_frame.grid_remove()</pre>
<p>Take a note of the <kbd>grid_remove()</kbd> method mentioned previously. This method removes the widget from the grid manager, thereby making it invisible. You can make it visible again by<span> using </span><kbd>grid()</kbd> on it. So effectively, whenever a user selects one of the three options (<kbd>Scales</kbd>, <kbd>Chords</kbd>, and <kbd>Chord Progression</kbd>) from the topmost <kbd>combobox</kbd>, the other two frames are hidden using <kbd>grid_remove</kbd> and the frame for the selected option is made visible using <kbd>grid.</kbd></p>
<p>This completes the first iteration where we defined the broad GUI structure with the capability to switch between scales, chords, and chord progression frames based on choices made in the topmost combobox. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making the piano keyboard</h1>
                </header>
            
            <article>
                
<p>Let's now build the piano keyboard. All keys on the keyboard will be made using the Label widget. We will superimpose the label widget with an image of black and white keys using Tkinter's <kbd>PhotoImage</kbd> class.</p>
<p>The <kbd>PhotoImage</kbd><span> </span>class is used to display images in label, text, button, and canvas widgets. We used it in <a href="41f1fda5-b3b1-4dfa-8971-2a016274d39a.xhtml">Chapter 2</a>,<em> Making a Text Editor</em> to add icons to buttons.  Since this class can only handle <kbd>.gif</kbd> or <kbd>.bpm</kbd> format images, we add four <kbd>.gif</kbd> images to a folder named <kbd>pictures</kbd>. These four images are <kbd>black_key.gif</kbd>, <kbd>white_key.gif</kbd>, <kbd> black_key_pressed.gif</kbd>, and <kbd>white_key_pressed.gif</kbd>.</p>
<p>Since we will refer to these images over and over again,  we add their reference to <kbd>7.02</kbd> <kbd>constants.py</kbd>: </p>
<pre class="python">WHITE_KEY_IMAGE = '../pictures/white_key.gif'<br/>WHITE_KEY_PRESSED_IMAGE = '../pictures/white_key_pressed.gif'<br/>BLACK_KEY_IMAGE = '../pictures/black_key.gif'<br/>BLACK_KEY_PRESSED_IMAGE = '../pictures/black_key_pressed.gif'</pre>
<div class="packt_tip">The symbol <kbd>../</kbd>  used previously is a way to specify a file path relative to the current working directory. A single <kbd>../</kbd> means—go back one directory, a set of two <kbd>../../</kbd> means go back two directories, and so on.  This system is generally honored by most modern operating systems. However, some very old operating systems might not support it. So a better but a more verbose way is to use the <kbd>os</kbd> module of Python to traverse directories.</div>
<p>Next, we will define a method named <kbd>create_key</kbd> that creates a piano key for us at a given <kbd>x</kbd> location:</p>
<pre> def create_key(self, img, key_name, x_coordinate):<br/>   key_image = PhotoImage(file=img)<br/>   label = Label(self.keyboard_frame, image=key_image, border=0)<br/>   label.image = key_image<br/>   label.place(x=x_coordinate, y=0)<br/>   label.name = key_name<br/>   label.bind('&lt;Button-1&gt;', self.on_key_pressed)<br/>   label.bind('&lt;ButtonRelease-1&gt;', self.on_key_released)<br/>   self.keys.append(label)<br/>   return label</pre>
<p>Here's a brief code description:</p>
<ul>
<li>Note that since we want to place keys at a specific x coordinate we use the <kbd>place</kbd> geometry manager.  We briefly touched upon the place geometry manager in <a href="39a58f50-293e-4ff5-9b65-0d9e0c0cc15e.xhtml">Chapter 1</a>,<em> Meet Tkinter</em>. Now is a good place to see this rarely used geometry in action.</li>
<li>This method also takes an image location as its input and creates a <kbd>PhotoImage</kbd> class, which is then attached to the label widget using the <kbd>image=key_image</kbd> <span>option in the previous example. </span></li>
<li>A third parameter, <kbd>key_name</kbd>, <span>is attached to the creat</span>ed label widg<span>et by using the command <kbd>widget.name = key_name</kbd>. This is needed to later identify which particular key was pressed. For example, to create the first key</span> <em>C1</em><span>, we attach the name</span> <em>C1</em> <span>to t</span>he label widget and th<span>en later this string value can be accessed by calling <kbd>widget.name</kbd></span></li>
<li>We bind the label to two events, <kbd>'&lt;Button-1&gt;'</kbd> and <kbd>'&lt;ButtonRelease-1&gt;'</kbd>, to handle mouse press events.</li>
<li>Finally, we add a reference to the newly created widget into an attribute newly defined here as <kbd>self.keys</kbd>. We keep this reference as we will need to change the image of these widgets to highlight the keys.</li>
</ul>
<p>Now that we have attached events to two callbacks, let's define them next:</p>
<pre>def on_key_pressed(self, event):<br/>  print(event.widget.name + ' pressed') <br/>  self.change_image_to_pressed(event)<br/><br/>def on_key_released(self, event):<br/>  print(event.widget.name + ' released' ) <br/>  self.change_image_to_unpressed(event)</pre>
<p>For now, the previous methods print the name of the key pressed and then call another two methods that change the image of the pressed label to a different colored image on button press and release:</p>
<pre>def change_image_to_pressed(self, event):<br/> if len(event.widget.name) == 2:<br/>   img = WHITE_KEY_PRESSED_IMAGE<br/> elif len(event.widget.name) == 3:<br/>   img = BLACK_KEY_PRESSED_IMAGE<br/> key_img = PhotoImage(file=img)<br/> event.widget.configure(image=key_img)<br/> event.widget.image = key_img<br/><br/>def change_image_to_unpressed(self, event):<br/>  if len(event.widget.name) == 2:<br/>    img = WHITE_KEY_IMAGE<br/>  elif len(event.widget.name) == 3:<br/>    img = BLACK_KEY_IMAGE<br/>  key_img = PhotoImage(file=img)<br/>  event.widget.configure(image=key_img)<br/>  event.widget.image = key_img</pre>
<p>The white key widget will have a name of length <kbd>2</kbd> (for example, <kbd>C1</kbd>, <kbd>D2</kbd>, <kbd>G1</kbd>), while a black key will have an image length of <kbd>3</kbd> (for example, <kbd>C#1</kbd>, <kbd>D#1</kbd>). We utilize this fact to decide if to use a black key image or a white key image. The rest of the preceding code should be self-explanatory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Putting the keyboard together</h1>
                </header>
            
            <article>
                
<p>Now it's finally time to combine all the preceding methods to build our complete keyboard of two octaves. </p>
<p>We begin by defining the exact <kbd>x_coordinates</kbd> for all the keys from <em>C1</em> to <em>B2</em> in the file <kbd>constants.py</kbd> as follows:</p>
<pre>WHITE_KEY_X_COORDINATES = [0,40, 80,120, 160, 200, 240,280, 320, 360, 400, 440, 480,520]<br/>BLACK_KEY_X_COORDINATES = [30,70,150,190, 230, 310, 350, 430,470, 510]</pre>
<p>The preceding <em>x</em> coordinate numbers have been obtained simply by trial and error as to emulate their location on a keyboard.</p>
<p>Then we modify the previously defined <kbd>build_keyboard_frame</kbd> method as follows:</p>
<pre> def build_keyboard_frame(self):<br/>   self.keyboard_frame = Frame(self.root, width=WINDOW_WIDTH, <br/>               height=KEYBOARD_HEIGHT,   background='LavenderBlush2')<br/>   self.keyboard_frame.grid_propagate(False)<br/>   self.keyboard_frame.grid(row=4, column=0, sticky="nsew")<br/>   for index, key in enumerate(WHITE_KEY_NAMES):<br/>     x = WHITE_KEY_X_COORDINATES[index]<br/>     self.create_key(WHITE_KEY_IMAGE, key, x )<br/>   for index, key in enumerate(BLACK_KEY_NAMES):<br/>     x = BLACK_KEY_X_COORDINATES[index]<br/>     self.create_key(BLACK_KEY_IMAGE, key, x)</pre>
<p>The first three lines of the previous method remain as defined in the previous iteration. We then go through all white and black keys creating labels for them at given <em>x</em> coordinates.</p>
<p>That concludes the iteration. If you now run  <kbd>7.02 view.py</kbd>, you should see a two-octave keyboard. When you press any key, the key's image should change to blue and it should print the name of the key pressed or released in the Terminal:</p>
<div class="CDPAlignCenter CDPAlign"><img height="345" src="assets/bf3fe252-9b41-4da9-b598-395ba3097f6e.png" width="533"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Playing audio</h1>
                </header>
            
            <article>
                
<p>To begin with, we have added 24 sound samples in <kbd>.wav</kbd> format in a folder named <kbd>sounds</kbd> in this chapter's code folder. These audio files correspond to the 24 notes on our keyboard. The audio files are named according to the note name it represents.</p>
<p>In order to keep the audio processing separate from the GUI code, we create a new file called <kbd>audio.py</kbd> (<kbd>7.03</kbd>).<em> </em>The code is defined as follows:</p>
<pre>import simpleaudio as sa<br/>from _thread import start_new_thread<br/>import time<br/><br/>def play_note(note_name):<br/> wave_obj = sa.WaveObject.from_wave_file('sounds/' + note_name + '.wav')<br/> wave_obj.play()<br/><br/>def play_scale(scale):<br/> for note in scale:<br/>   play_note(note)<br/>   time.sleep(0.5)<br/><br/>def play_scale_in_new_thread(scale):<br/>  start_new_thread(play_scale,(scale,))<br/><br/>def play_chord(scale):<br/>  for note in scale:<br/>    play_note(note)<br/><br/>def play_chord_in_new_thread(chord):<br/>  start_new_thread(play_chord,(chord,))</pre>
<p>The code description is as follows:</p>
<ul>
<li>The <kbd>play_note</kbd> method follows the API provided by <kbd>simpleaudio</kbd> to play an audio file</li>
<li>The <kbd>play_scale</kbd> method takes in a list of notes and plays them sequentially, giving a time gap between each played note</li>
<li>The <kbd>play_chord</kbd> method takes a list of notes and plays them all together</li>
<li>The last two methods call these methods in new threads as we don't want to block the main GUI thread when playing these notes</li>
</ul>
<p>Next, let's import this file (<kbd>7.03</kbd> <kbd>view.py</kbd>):</p>
<pre>from audio import play_note    </pre>
<p>Next, modify the <kbd>on_key_pressed</kbd> method to play the given note:</p>
<pre>def on_key_pressed(self, event):<br/> play_note(event.widget.name)<br/> self.change_image_to_pressed(event)</pre>
<p>This concludes the iteration. If you now run the code and press any key on the keyboard, it should play the note for that key.</p>
<p>Next, we start with building the actual tutor. The next three sections will develop the scales, chords, and chord progression sections.  We will start by building the scales tutor.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the scales tutor</h1>
                </header>
            
            <article>
                
<p>All the rules for defining which notes to play for a given scale are added in a JSON file named <kbd>scales.json</kbd> within a folder named <kbd>json</kbd>. Let's take a look at the first few lines in the <kbd>scales.json</kbd> file:</p>
<pre>{<br/> "Major": [ 0, 2, 4, 5, 7, 9, 11 ],<br/> "Minor": [ 0, 2, 3, 5, 7, 8, 10 ],<br/> "Harmonic minor": [ 0, 2, 3, 5, 7, 8, 11 ],<br/> "Melodic minor": [ 0, 2, 3, 5, 7, 9, 11 ],<br/> "Major blues": [ 0, 2, 3, 4, 7, 9 ],<br/> "Minor blues": [ 0, 3, 5, 6, 7, 10 ],<br/>...<br/>}</pre>
<p>Recall that a scale is a set of notes played sequentially. The first note of the scale is called its <strong>root</strong> or <strong>key</strong>. So if you play a scale starting at say the note <em>B</em>, you are playing the scale in the key of <em>B</em>.</p>
<p>Let's take the fourth item in the key-value pairs. The key is named <kbd>"Melodic minor"</kbd> and its associated value is <span><kbd>[ 0, 2, 3, 5, 7, 9, 11 ]</kbd>. This means that, to play a melodic minor scale in the key of <em>B</em>, you will take <em>B</em> as the first item—that is represented by <kbd>0</kbd> in the values list. The next key is two semitones above <em>B</em>, the third key is three semitones above <em>B</em>, and the next is 5, followed by 7, 9, and 11 semitones above <em>B</em>. </span></p>
<p>So to summarize—in order to play Melodic minor in the key of <em>B</em> you will play the following keys:</p>
<pre>B, B+2, B+3, B+5, B+7, B+9 and B+11 keys</pre>
<p>Where the preceding numbers represent semitones.</p>
<p>So our task is—given a scale and the key for the scale, our program should highlight the keys and play it out:</p>
<div class="CDPAlignCenter CDPAlign"><img height="181" src="assets/48044a81-d04b-4b28-9354-e0c273aa23b0.png" width="454"/></div>
<p>The first thing is to build two <kbd>combobox</kbd> for the scale and keys as shown previously. This should be easy for you as we have built <kbd>combobox</kbd> several times in the previous chapters.</p>
<p>The second step involves reading the JSON file into our program.</p>
<p>Quoting from json.org (<a href="http://json.org/">http://json.org/</a>):</p>
<div class="packt_quote">JSON<span> (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write. It is easy for machines to parse and generate. These are universal data structures. Virtually all modern programming languages support them in one form or another. It makes sense that a data format that is interchangeable with programming languages is also be based on these structures. Read more about JSON at <a href="https://www.json.org">https://www.json.org</a></span>.<a href="https://www.json.org"/></div>
<p>Python implements a standard module for reading and writing JSON data too. The module is rightfully called <kbd>json</kbd>.</p>
<p>We first import the built-in <kbd>json</kbd> module in our namespace:</p>
<pre>import json</pre>
<p>We next add a new method, <kbd>self.load_json_files()</kbd>, and call it from the class <kbd>__init__</kbd> method:</p>
<pre>def load_json_files(self):<br/>  with open(SCALES_JSON_FILE, 'r') as f:<br/>    self.scales = json.load(f, object_pairs_hook=OrderedDict)</pre>
<p>The <kbd>SCALES_JSON_FILE</kbd> path is defined in the file <kbd>constants.py</kbd><em>.</em> This loads up the scales data as a dictionary in the <kbd>self.scales</kbd> attribute:</p>
<div class="packt_tip">You can read JSON files by using the <kbd>json.load</kbd> command. You can write to a JSON file by using the <kbd>json.dump</kbd> command. However, <kbd>json.load</kbd> methods do not <span>preserve key order from a parsed JSON document. That is to say, <kbd>json.load</kbd> jumbles up the order of the keys. We do not want to jumble up the order of the keys and want them to appear in the order they are mentioned in the file. We therefore use the <kbd>OrderedDict</kbd> class from the <kbd>collections</kbd> module to preserve the key order.  This is achieved by passing the second argument as </span><kbd>object_pairs_hook=OrderedDict</kbd>.<span class="typ"> </span><span>An <kbd>OrderedDict</kbd> is a Python dictionary object that remembers the order that keys were first inserted. </span></div>
<p>Now that we have the scales data available as the <kbd>self.scales</kbd> dictionary, our next task is to figure out the keys to highlight. We start by creating a new attribute in the class <kbd>__init__</kbd> method:</p>
<pre>self.keys_to_highlight = []  </pre>
<p>Next, we define methods to highlight a key and another method to highlight a list of keys:</p>
<pre><span>def highlight_key(self, key_name):</span><br/><span> if len(key_name) == 2:</span><br/><span>   img = WHITE_KEY_PRESSED_IMAGE</span><br/><span> elif len(key_name) == 3:</span><br/><span>   img = BLACK_KEY_PRESSED_IMAGE</span><br/><span> key_img = PhotoImage(file=img)</span><br/><span> for widget in self.keys:</span><br/><span>  if widget.name == key_name:</span><br/><span>    widget.configure(image=key_img)</span><br/><span>    widget.image = key_img<br/><br/></span><span>def highlight_list_of_keys(self, key_names):</span><br/><span>  for key in key_names:</span><br/><span>     self.highlight_key(key)</span></pre>
<p>The preceding code is similar to the previous code we wrote to highlight a key when it is pressed. Next, we also need methods to remove existing highlights:</p>
<pre class="mce-root">def remove_key_highlight(self, key_name):<br/>  if len(key_name) == 2:<br/>    img = WHITE_KEY_IMAGE<br/>  elif len(key_name) == 3:<br/>    img = BLACK_KEY_IMAGE<br/>  key_img = PhotoImage(file=img)<br/>  for widget in self.keys:<br/>   if widget.name == key_name:<br/>    widget.configure(image=key_img)<br/>    widget.image = key_img<br/><br/>def remove_all_key_highlights(self):<br/>  for key in self.keys_to_highlight:<br/>    self.remove_key_highlight(key)<br/>  self.keys_to_highlight = []</pre>
<p>The logic here is exactly similar to the one we applied for highlighting keys.</p>
<p>Now that we have methods to highlight and remove highlights from keys, let's define the callbacks attached to the two combobox for scale and key selection:</p>
<pre>def on_scale_changed(self, event):<br/>  self.remove_all_key_highlights()<br/>  self.find_scale(event)<br/> <br/>def on_scale_key_changed(self, event):<br/>  self.remove_all_key_highlights()<br/>  self.find_scale(event)</pre>
<p>Lastly, here is the logic to select which keys to highlight. Furthermore, once we have the list of keys to be highlighted, we pass it to the previously defined <kbd>play_scale_in_new_thread</kbd> method that plays the actual sound for the scale:</p>
<pre class="mce-root">def find_scale(self, event=None):<br/> self.selected_scale = self.scale_selector.get()<br/> self.scale_selected_key = self.scale_key_selector.get()<br/> <strong>index_of_selected_key = KEYS.index(self.scale_selected_key)</strong><br/><strong> self.keys_to_highlight = [ ALL_KEYS[i+index_of_selected_key] \</strong><br/><strong>   for i in self.scales[self.selected_scale]]</strong><br/> self.highlight_list_of_keys(self.keys_to_highlight)<br/> play_scale_in_new_thread(self.keys_to_highlight)</pre>
<p class="mce-root">Do notice the highlighted part of the code.</p>
<p>So given the index of the selected key, we simply add all items in the list of selected scale to obtain the list of keys to be highlighted. </p>
<p>We also want to call this method as soon as the program runs. So we add a call to <kbd>self.find_scale()</kbd> right in our <kbd>__init__</kbd> method. That ensures that we are greeted by playing of <em>C</em> Major scale (the default selection in <kbd>combobox</kbd>) as soon as the program runs.</p>
<p>This concludes the iteration. Now if you go and run <kbd>7.04 view.py</kbd> and select the appropriate scale and key name, the keyboard will highlight the keys and also play it out for you.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the chord finder section</h1>
                </header>
            
            <article>
                
<p>Now that we have had a glimpse of working with <em>JSON</em> files, this should be easy. Let's take a look at the first few lines of the <kbd>chords.json</kbd> file from the <kbd>json</kbd> directory:</p>
<pre>{<br/> "Major" : [0, 4, 7],<br/> "Minor" : [0, 3, 7],<br/> "Sus4" : [0, 5, 7],<br/> "5" : [0, 4, 6],<br/> "Diminished" : [0, 3, 6],<br/> ...<br/>}</pre>
<p>This is very similar to the scales structure. Let's say we want to figure out what the <em>C</em># major chord would look like. So we start with the <em>C</em># key, which is <kbd>0</kbd>. Then we look at the list of <span>major chords, which read: <kbd>[0, 4, 7]</kbd>. So starting at <em>C</em># the next key to highlight is <kbd>4</kbd> semitones above and the next is <kbd>7</kbd> semitones above <em>C</em>#. So the final chord structure for the C# major chord would be:</span></p>
<pre>C#,    (C# + 4 semitones) ,      (C# + 7 semitones) </pre>
<p>The GUI is also very similar to the scales section:</p>
<div class="CDPAlignCenter CDPAlign"><img height="195" src="assets/9c7f7ed7-1884-4546-8152-6df9af62fcfb.png" width="479"/></div>
<p>We begin by adding a constant for the path to the <kbd>chords.json</kbd> file in  <kbd>7.05 constants.py</kbd>:</p>
<pre>CHORDS_JSON_FILE = '../json/chords.json'</pre>
<p>Next, we read the contents of this file in a new class attribute, <kbd>self.chords</kbd>:</p>
<pre> with open(CHORDS_JSON_FILE, 'r') as f:<br/>   self.chords = json.load(f, object_pairs_hook=OrderedDict)</pre>
<p>We then modify the chords frame GUI to add two <kbd>combobox</kbd> (see the complete GUI in <kbd>7.05 view.py</kbd> <kbd>build_chords_frame</kbd>):</p>
<pre>self.chords_selector = ttk.Combobox(self.chords_frame,  values=[k for k <br/>  in self.chords.keys()])<br/>self.chords_selector.current(0)<br/>self.chords_selector.bind("&lt;&lt;ComboboxSelected&gt;&gt;", <strong>self.on_chord_changed</strong>)<br/>self.chords_selector.grid(row=1, column=1, sticky='e', padx=10, <br/>  pady=10)<br/>self.chords_key_selector = ttk.Combobox(self.chords_frame, values=[k  <br/>  for k in KEYS])<br/>self.chords_key_selector.current(0)<br/>self.chords_key_selector.bind("&lt;&lt;ComboboxSelected&gt;&gt;", self.<strong>on_chords_key_changed</strong>)</pre>
<p>Next, we added the two event callbacks defined previously:</p>
<pre>def on_chord_changed(self, event):<br/>  self.remove_all_key_highlights()<br/>  self.find_chord(event)<br/> <br/>def on_chords_key_changed(self, event):<br/>  self.remove_all_key_highlights()<br/>  self.find_chord(event)</pre>
<p> The <kbd>find_chord</kbd> method queries the <kbd>self.chords</kbd> dict for the keys to be highlighted, adds the key offsets from the root note, and calls it to be highlighted and played:</p>
<pre class="mce-root">def find_chord(self, event=None):<br/>  self.selected_chord = self.chords_selector.get()<br/>  self.chords_selected_key = self.chords_key_selector.get()<br/>  index_of_selected_key = KEYS.index(self.chords_selected_key)<br/>  self.keys_to_highlight = [ ALL_KEYS[i+index_of_selected_key] for \<br/>                         i in self.chords[self.selected_chord]]<br/>  self.highlight_list_of_keys(self.keys_to_highlight)<br/>  play_chord_in_new_thread(self.keys_to_highlight)</pre>
<p><span>The final code in this iteration modifies the <kbd>on_mode_changed</kbd> method to highlight the chord as soon as the chord mode is selected:</span></p>
<pre> def on_mode_changed(self, event):<br/>   self.remove_all_key_highlights()<br/>   selected_mode = self.mode_selector.get()<br/>   if selected_mode == 'Scales':<br/>     self.show_scales_frame()<br/>     self.find_scale()<br/>   elif selected_mode == 'Chords':<br/>     self.show_chords_frame()<br/>     self.find_chord()<br/>   elif selected_mode == 'Chord Progressions':<br/>     self.show_progressions_frame()</pre>
<p>That concludes the iteration. If you now run <kbd>7.05 view.py</kbd>, you will find a functional chords section that lets us find chords of different varieties in different scales.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the chord progression tutor</h1>
                </header>
            
            <article>
                
<p>The GUI component of the chord progression section is slightly more evolved than the previous two sections. Here's how a typical chord progression GUI looks like:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5400163b-8525-4fd4-befe-42f9b4bc53c0.png"/></div>
<p>Notice that this section has the combobox as opposed to two for the earlier sections.  Depending on what progression is chosen in the middle combobox, we need to draw a number of buttons, each button representing one chord in the complete chord progression. </p>
<p>In the preceding screenshot, note that the progression combobox has a value of <span class="packt_screen">I</span>-<span class="packt_screen">V</span>-<span class="packt_screen">vi</span>-<span class="packt_screen">IV</span>. This is a total of four roman numbers separated by a dash. This means that this chord progression is made up of four chords. Also notice that a few of the roman numbers (<span class="packt_screen">I</span>, <span class="packt_screen">V</span>, <span class="packt_screen">IV</span>, and so on) are written in capital letters and others (<span class="packt_screen">vi</span>) are written in small letters.  All capital letters in the series denote major chords, while each small letter represents a minor chord. </p>
<p>Next, let us take a look at the <kbd>progressions.json</kbd> file from the <kbd>json</kbd> folder:</p>
<pre>{<br/> "Major": {<br/> "I-IV-V": [ "0", "5", "7" ],<br/> "ii-V-I": [ "2", "7", "0" ],<br/> "I-V-vi-IV": [ "0", "7", "9", "5" ],<br/>... more here},<br/> "Minor": {<br/> "i-VI-VII": [ "0", "9", "11"],<br/> "i-iv-VII": [ "0", "5", "11"],<br/> "i-iv-v": [ "0", "5", "7" ],<br/>..more here<br/>}<br/> }</pre>
<p>As a first observation, the chord progressions are broadly of two types—major and minor. Each type has a list of chord progressions, which is identified by a set of roman numerals.</p>
<p>Let's see an example of how this would work.</p>
<p>Say we want to display the major chord progression <kbd>ii-V-I</kbd> in the key of <em>C</em>, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fde4c1fc-e1fe-48e0-b565-efbcff470290.png"/></div>
<p>The JSON file lists the progression under the <span class="packt_screen">Major</span> section as:</p>
<pre> "ii-V-I": [ "2", "7", "0" ]</pre>
<p>Let's first lay down the 12 notes in a table starting at the key of the chord progression (C in our example). We need to pick up the 2<sup>nd</sup>,  7<sup>th</sup>, and  0<sup>th</sup> keys for this progression:</p>
<table style="width: 635px;height: 82px">
<tbody>
<tr>
<td><strong>0</strong></td>
<td>1</td>
<td><strong>2</strong></td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td><strong>7</strong></td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td>C#</td>
<td><strong>D</strong></td>
<td>D#</td>
<td>E</td>
<td>F</td>
<td>F#</td>
<td><strong>G</strong></td>
<td>G#</td>
<td>A</td>
<td>A#</td>
<td>B</td>
</tr>
</tbody>
</table>
<p>The keys are D(2<sup>nd</sup>), G(7<sup>th</sup>), and C(0<sup>th</sup>). With the keys in hand—we next need to identify if each of the keys plays a major or minor chord. This is simple. Those roman numbers written in lower case play a minor chord, while those written in capitals play a major chord.</p>
<p>Given this rule, our final chords in the chord progression in the key of <em>C</em> are:</p>
<p>D Minor - G Major - C Major</p>
<p>Having identified these, our program should dynamically create three buttons. Clicking on these buttons should then play the preceding three chords, respectively.</p>
<p>Let's code this feature. We begin by defining the location of the chords progression file in <kbd>7.06 constants.py</kbd>:</p>
<pre>PROGRESSIONS_JSON_FILE = '../json/progressions.json'</pre>
<p>We then load it from the method <kbd>load_json_files()</kbd> into an attribute named <kbd>self.progressions</kbd>:</p>
<pre> with open(PROGRESSIONS_JSON_FILE, 'r') as f:<br/>    self.progressions = json.load(f, object_pairs_hook=OrderedDict)</pre>
<p>Next, we modify the progression frame to add three <kbd>combobox</kbd> elements. See the <span><kbd>build_progressions_frame</kbd> </span> code <kbd>7.06 view.py</kbd>.</p>
<p>The three combobox are attached to the following three callbacks:</p>
<pre>def on_progression_scale_changed(self, event):<br/> selected_progression_scale = self.progression_scale_selector.get()<br/> progressions = [k for k in  <br/>   self.progressions[selected_progression_scale].keys()]<br/> self.progression_selector['values'] = progressions<br/> self.progression_selector.current(0)<br/> self.show_progression_buttons()<br/><br/>def on_progression_key_changed(self,event):<br/> self.show_progression_buttons()<br/><br/>def on_progression_changed(self,event):<br/> self.show_progression_buttons()</pre>
<p>The most complex of the three combobox is the progression scale combobox. It lets you choose between <em>Major</em> and <em>Minor</em> progression scales. Depending on the choice you make there,  it populates the second combobox with the progression values from the JSON file. This is what the first four lines of the <kbd>on_progression_scale_changed</kbd> method do.</p>
<p>Other than that, all three preceding callback methods defined make a call to the <kbd>show_progression_buttons</kbd> method, which is defined as follows:</p>
<pre>def show_progression_buttons(self):<br/> self.destroy_current_progression_buttons()<br/> selected_progression_scale = self.progression_scale_selector.get()<br/> selected_progression = self.progression_selector.get().split('-')<br/> self.progression_buttons = []<br/> for i in range(len(selected_progression)):<br/>   self.progression_buttons.append(Button(self.progressions_frame,                     <br/>         text=selected_progression[i],<br/>         command=partial(self.on_progression_button_clicked, i)))<br/>   sticky = 'W' if i == 0 else 'E' <br/>   col = i if i &gt; 1 else 1<br/>   self.progression_buttons[i].grid(column=col, row=2, sticky=sticky, <br/>     padx=10)</pre>
<p>The preceding code dynamically creates buttons—one for each chord in the chord progression and stores all the buttons in a list named <kbd>self.progression_buttons</kbd>.  We will keep this reference because we will have to destroy the buttons and create fresh ones every time a new chord progression is selected.</p>
<div class="mce-root packt_infobox">Note the use of the <kbd>partial</kbd> method from the <kbd>functools</kbd> module to define the button command callbacks. Since the buttons are being created dynamically, we need to keep track of the button number. We use this handy method <kbd>partials</kbd> that lets us call a method with only a partial number of arguments. Quoting from Python's documentation - <span>The <kbd>partial()</kbd> function </span><span>is used for partial function application, which <em>freezes</em> some portion of a function's arguments and/or keywords resulting in a new object with a simplified signature. You can read more about partials at <a href="https://docs.python.org/3/library/functools.html#functools.partial">https://docs.python.org/3/library/functools.html#functools.partial</a>.</span></div>
<p>The preceding code calls a <kbd>destroy_button</kbd> method whose task is to clear the frame for drawing the next set of buttons, in case a new progression is selected.  The code is as follows:</p>
<pre><span>def destroy_current_progression_buttons(self):</span><br/> <span>for buttons in self.progression_buttons:</span><br/>    <span>buttons.destroy()</span></pre>
<p>Finally, we want to display an individual chord from the chord progression when a button is clicked. This is defined as follows:</p>
<pre>def on_progression_button_clicked(self, i):<br/>  self.remove_all_key_highlights()<br/>  selected_progression = self.progression_selector.get().split('-')[i]<br/>  if any(x.isupper() for x in selected_progression):<br/>     selected_chord = 'Major'<br/>  else: <br/>    selected_chord = 'Minor'<br/>  key_offset = <span>ROMAN_TO_NUMBER</span>[selected_progression]<br/>  selected_key = self.progression_key_selector.get() <br/>  index_of_selected_key = (KEYS.index(selected_key)+ key_offset)% 12<br/>  self.keys_to_highlight = [ ALL_KEYS[j+index_of_selected_key] for j in   <br/>                             self.chords[selected_chord]]<br/>  self.highlight_list_of_keys(self.keys_to_highlight)<br/>  play_chord_in_new_thread(self.keys_to_highlight)</pre>
<p>Here's a brief description of the preceding code:</p>
<ul>
<li>We first split the text, say <kbd>ii-V-I</kbd>, using the dash (<kbd>-</kbd>) delimiter. We then loop through the list and check if it is in uppercase or lowercase. If it is uppercase, the <kbd>selected_chord</kbd> variable is set to <kbd>Major</kbd>, if not it is set to <kbd>Minor</kbd><em>.</em></li>
<li>The index of the keys is calculated by adding the key to the numbers mentioned in the JSON file. We apply modulo operator (<kbd>%</kbd>) to the added value to ensure that the value does not exceed the limits of 12 notes.</li>
<li>Since the numbers are stored as roman numerals (this is the convention used by musicians), we need to convert it to integers. We do that by defining a simple key-value mapping in <kbd>7.05/constants.py</kbd>:</li>
</ul>
<pre class="mce-root" style="padding-left: 90px"><span>ROMAN_TO_NUMBER = { 'I':0, 'II': 2, 'III':4, 'IV':5, 'V': 7, 'VI':9, 'VII': 11, 'i':0, 'ii': 2, 'iii':4, 'iv':5, 'v': 7, 'vi':9, 'vii': 11}</span></pre>
<ul>
<li>Note that we have mapped all numbers starting at 0 and the mapping follows the Major scale pattern (<kbd>W W H W W S</kbd>), where <kbd>W</kbd> stands for whole tone (two keys jump) and <kbd>S</kbd> stands for semitone (one key jump).</li>
<li>Now that we know that if the chord is a major or a minor, the rest of the code is exactly the same as we earlier used to identify the individual chords. We then highlight and play the individual chord.</li>
</ul>
<p>To end, we modify the <kbd>on_mode_changed</kbd>  to add a call to <kbd>show_progression_buttons()</kbd> so that every time we switch to the chord progression section, the first chord progression buttons are laid down for us.</p>
<p>This completes the iteration. Our chord progression section is ready. Run code <kbd>7.06/view.py</kbd>. Inside the chord progression tutor, you can select the chord progression type <span>(major or minor), the progression, and its</span> key from the comboboxes and it will create one button for each of the chords in the chord progression. Press the individual buttons and it will play you the chords in that progression.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the score maker</h1>
                </header>
            
            <article>
                
<p>Let us now build the score maker. This will display whatever is played on the piano in music notation. For the sake of program modularity, we will build the program in a separate file named <kbd>score_maker.py</kbd>.</p>
<p>We start by defining a class <kbd>ScoreMaker</kbd>. Since we will be showing just two octaves of notes, we will define a constant <kbd>NOTES</kbd> listing all the notes (<kbd>7.06/score_maker.py</kbd>):</p>
<pre>class ScoreMaker:<br/><br/>NOTES = ['C1','D1', 'E1', 'F1', 'G1','A1', 'B1', 'C2','D2', 'E2', 'F2', 'G2','A2', 'B2']</pre>
<p>The <kbd>__init__</kbd> method of this class takes the container as an argument. This is the container on which this class will draw the score (<kbd>7.06/score_maker.py</kbd>):</p>
<pre class="mce-root">def __init__(self, container):<br/>   self.canvas = Canvas(container, width=500, height = 110)<br/>   self.canvas.grid(row=0, column = 1)<br/>   container.update_idletasks() <br/>   self.canvas_width = self.canvas.winfo_width()<br/>   self.treble_clef_image = PhotoImage(file='../pictures/treble-clef.gif')<br/>   self.sharp_image = PhotoImage(file='../pictures/sharp.gif')<br/><br/></pre>
<p class="mce-root">Note the use of <kbd>update_idletasks()</kbd> on the <kbd>container</kbd> frame. Calling this method here is necessary because we created a canvas in the previous line of code, which requires a redrawing of widgets. However, the redraw will only take place after the next run of the event loop<span><span>.</span></span> But we want to know the canvas width immediately after it was created. An explicit call to <kbd>update_idletasks</kbd> immediately carries out all pending events including geometry management. This ensures that we get the correct width of the canvas in the very next step. If you comment out the <kbd>update_idletasks</kbd> line and try to print the width of the canvas, it will print <kbd>1</kbd> even though we have explicitly set it to <kbd>500</kbd>.</p>
<p class="mce-root"><span>We also initialize two <kbd>.gif</kbd> images that we will use to draw the score. The <kbd>treble_clef</kbd> image will be used to draw the treble clef to the left of the score, while the <kbd>sharp_image</kbd>  will draw a sharp (#) symbol prior to any sharp note (notes on the black keys).</span></p>
<div class="packt_infobox">Tkinter uses the concept of event loop to handle all events. Here's an excellent article that explains the concept in depth <a href="http://wiki.tcl.tk/1527">http://wiki.tcl.tk/1527</a>.  <kbd>update_idletask</kbd> is an example of the method available on all widgets. Visit <a href="http://effbot.org/tkinterbook/widget.htm">http://effbot.org/tkinterbook/widget.htm</a> to see a list of methods that are available to be called on all widgets.</div>
<p>Our first task is to draw five equally spaced lines on the canvas. We accordingly define a new method to do that:</p>
<pre> def _draw_five_lines(self):<br/>   w = self.canvas_width<br/>   self.canvas.create_line(0,40,w,40, fill="#555")<br/>   self.canvas.create_line(0,50,w,50, fill="#555")<br/>   self.canvas.create_line(0,60,w,60, fill="#555")<br/>   self.canvas.create_line(0,70,w,70, fill="#555")<br/>   self.canvas.create_line(0,80,w,80, fill="#555")</pre>
<p>This creates five parallel lines each 10 pixels apart. The underscore in the method name is an indication that this is to be treated as a private method of the class. While Python does not enforce method privacy, this tells the users not to use this method directly in their program.</p>
<p>Let's then build a method that actually calls the previous method and adds a treble clef to the left, thereby creating an empty staff on which we can draw notes:</p>
<pre> def _create_treble_staff(self):<br/>  self._draw_five_lines()<br/>  self.canvas.create_image(10, 20, image=self.treble_clef_image, anchor=NW)</pre>
<p>At the outset, we need to differentiate between drawing a chord and drawing notes of the scale. Since all the notes of a chord are played together, the notes of a chord are drawn at a single <em>x</em> location. In contrast, the notes in a scale are drawn at regular <em>x</em> offsets, as shown here:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f8dd155a-841b-4dc0-b05a-e2d950d88f17.png"/></div>
<p>Since we need to offset the <em>x</em> value for scales at regular intervals, we use the <kbd>count</kbd> method from the <kbd>itertools</kbd> module to provide an ever-increasing value of <em>x</em>:</p>
<pre>import itertools <br/>self.x_counter = itertools.count(start=50, step=30)</pre>
<p>Now every subsequent call to <kbd>x = next(self.x_counter)</kbd> increments <em>x</em> by <kbd>30</kbd>.</p>
<p>Now here's the code that draws the actual note on the canvas:</p>
<pre> def _draw_single_note(self, note, is_in_chord=False):<br/>   is_sharp = "#" in note <br/>   note = note.replace("#","")<br/>   radius = 9<br/>   if is_in_chord:<br/>     x = 75<br/>   else: <br/>     x = next(self.x_counter)<br/>   i = self.NOTES.index(note)<br/>   y = 85-(5*i)<br/>   self.canvas.create_oval(x,y,x+radius, y+ radius, fill="#555")<br/>   if is_sharp:<br/>     self.canvas.create_image(x-10,y, image=self.sharp_image, anchor=NW)<br/>   if note=="C1":<br/>     self.canvas.create_line(x-5,90,x+15, 90, fill="#555")<br/>   elif note=="G2":<br/>     self.canvas.create_line(x-5,35,x+15, 35, fill="#555")<br/>   elif note=="A2":<br/>     self.canvas.create_line(x-5,35,x+15, 35, fill="#555")<br/>   elif note=="B2":<br/>     self.canvas.create_line(x-5,35,x+15, 35, fill="#555")<br/>     self.canvas.create_line(x-5,25,x+15, 25, fill="#555") </pre>
<p>The description of the preceding code is as follows:</p>
<ul>
<li>The method accepts a note name, for example, <kbd>C1</kbd> or <em>D2</em>#, and draws an oval at an appropriate place.</li>
<li>We need to get the <em>x</em>, <em>y</em> values for drawing an oval.  </li>
<li>We first calculate the <em>x</em> value. If the note is part of a chord, we fix the <em>x</em> value at <kbd>75</kbd> px, whereas if the note is part of a scale, the <em>x</em> value is incremented by <em>30</em> pixels from the previous <em>x</em> value by calling <kbd>next</kbd> on the <kbd>itertool counter</kbd> method.</li>
</ul>
<p>Next, we calculate the <em>y</em> value. The code to do this is as follows:</p>
<pre>i = self.NOTES.index(note)<br/>y = 85-(5*i)</pre>
<p>Basically, the <em>y</em> offset is calculated based on the index of the note in the list and each subsequent note is offset by <kbd>5</kbd> pixels.  The number <kbd>85</kbd> is found by trial and error.</p>
<p>Now that we have the <em>x</em> and <em>y</em> value, we simply draw the oval of given <kbd>radius</kbd>:</p>
<pre>self.canvas.create_oval(x,y,x+radius, y+ radius, fill="#555")</pre>
<p>If the note is a sharp note, that is, if it contains the character <kbd>#</kbd>,  it draws the <kbd>#</kbd> image 10 pixels left of the oval for the note.</p>
<p>The notes C1, G2, A2, and B2 are drawn outside the five lines. So in addition to oval we need to draw a small line crossing horizontally through them. This is what the last 11 lines of <kbd>if…else</kbd> statements achieve.</p>
<p>Finally, we have the <kbd>draw_notes</kbd> method and <kbd>draw_chord</kbd> method that given a list of notes draw out the notes and chords, respectively. These are the only two methods that do not have an underscore before their names. This means we expose the interface of our program only using these two methods:</p>
<pre>def draw_notes(self, notes):<br/>  self._clean_score_sheet()<br/>  self._create_treble_staff()<br/>  for note in notes:<br/>    self._draw_single_note(note)<br/><br/>def draw_chord(self, chord):<br/>  self._clean_score_sheet()<br/>  self._create_treble_staff()<br/>  for note in chord:<br/>    self._draw_single_note(note, is_in_chord=True)</pre>
<p>Now that we have our <kbd>ScoreMaker</kbd> ready, we simply import it into <kbd>7.07/view.py</kbd>:</p>
<pre>from score_maker import ScoreMaker</pre>
<p>We modify <kbd>build_score_sheet_frame</kbd> to instantiate the <kbd>ScoreMaker</kbd>:</p>
<pre>self.score_maker = ScoreMaker(self.score_sheet_frame) </pre>
<p>We then modify <kbd>find_scale</kbd> to add this line (<kbd><span>7.07/view.py</span></kbd>):</p>
<pre>self.score_maker.draw_notes(self.keys_to_highlight)</pre>
<p>We similarly modify <kbd>find_chord</kbd>  and <kbd>on_progression_button_clicked</kbd> to add this line (<span><kbd>7.07/view.py</kbd>)</span><span>:</span></p>
<pre>self.score_maker.draw_chord(self.keys_to_highlight)</pre>
<p>That brings us to the end of this project. If you now run <kbd><span>7.07/view.py</span></kbd>, you should see a functional score maker and a functional <span class="packt_screen">Piano Tutor</span>.</p>
<p>However, let's end this chapter with a brief discussion on window responsiveness.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A note on window responsiveness</h1>
                </header>
            
            <article>
                
<p>We used <kbd>.grid_propagate(False)</kbd> in this program to ensure that our frames did not shrink to fit their contents, but rather stayed at a fixed height and width that we had specified while making the frames.</p>
<p>This served us well for this example, but this made our window and its content fixed in size. This is what you would typically call a non-responsive window.</p>
<p><span>Let us take a look at the program </span><kbd>nonresponsive.py</kbd> <em>a</em>s an example of a non-responsive window. This program simply draws <kbd>10</kbd> buttons in a row:</p>
<pre class="mce-root">from tkinter import Tk, Button<br/>root = Tk()<br/><br/>for x in range(10):<br/> btn = Button(root, text=x )<br/> btn.grid(column=x, row=1, sticky='nsew')<br/><br/>root.mainloop()</pre>
<p><span>Run this program and resize the window. </span><span>These buttons are drawn on the root window and are not responsive. </span><span>The buttons remain fixed in size. </span><span>They do not adapt in size to change in the window size.  </span><span>If the window size is made smaller, some of the buttons even disappear from view.</span></p>
<p>In contrast, let us take a look at the program <kbd>responsive.py</kbd>:</p>
<pre>from tkinter import Tk, Button, Grid<br/><br/>root = Tk()<br/><br/>for x in range(10):<br/> Grid.rowconfigure(root, x, weight=1)<br/> Grid.columnconfigure(root, x, weight=1)<br/> btn = Button(root, text=x )<br/> btn.grid(column=x, row=1, sticky='nsew')<br/><br/>root.mainloop()</pre>
<p>If you run this program and resize the window, you will see that the buttons respond by resizing themselves to fit the container root window. So what's the difference between the two previous pieces of code? We simply added these two lines to the second program:</p>
<pre>Grid.rowconfigure(root, x, weight=1)<br/>Grid.columnconfigure(root, x, weight=1) </pre>
<p><span>These two lines add <strong>non-zero weights</strong> (<kbd>weight=1</kbd>) to the</span> <kbd>x</kbd><span><sup>th</sup> button widget in the container (root in the preceding example).</span></p>
<p>The key here is to understand the importance of weights. If we have two widgets, <kbd>widget1</kbd> and <kbd>widget2</kbd>, and we assign them weights of 3 and 1, respectively. <span>Now when you resize its parent, <kbd>widget1</kbd> will take up 3/4</span><sup>th</sup><span> of the space, while <kbd>widget2</kbd> will take up 1/4</span><sup>th</sup><span> of the space.</span></p>
<div class="packt_infobox">Here's the documentation of <kbd>rowconfigure</kbd> and <kbd>columnconfigure</kbd>:<br/>
<a href="http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/grid-config.html">http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/grid-config.html</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Experimenting with the code</h1>
                </header>
            
            <article>
                
<p>The best way to experience this piece of code is to make the following tweaks one by one, run the program, and resize the window to see the effect of each option.</p>
<p>As a first tweak, change the weights to <kbd>0</kbd>:</p>
<pre> Grid.rowconfigure(root, x, <strong>weight=0</strong>)<br/> Grid.columnconfigure(root, x, <strong>weight=0</strong>)</pre>
<p>This will make the window non-responsive again.</p>
<p>Next, reassign the weights back to 1 and then comment out one of the two lines and see the difference. If you comment out the <kbd>rowconfigure</kbd> line the buttons will be responsive in the <em>y</em> direction, but non-responsive in the <kbd>x</kbd> direction and vice versa for <kbd>columnconfigure</kbd>.</p>
<p>Restore the program to its original state and then assign a different weight in each loop by changing the weight to <kbd>x</kbd>:</p>
<pre> Grid.rowconfigure(root, x, <strong>weight=x</strong>)<br/> Grid.columnconfigure(root, x, <strong>weight=x</strong>)</pre>
<p>So the first button will have a weight of 0, the second button will have a weight of 1, and so on. Now if you run the program and resize the window, the last button with weight=9 will be the most responsive (will take up the largest proportion of the available space), while the first button with a weight of 0 will be completely non-responsive (fixed size), as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6a202f22-393d-4719-ba6d-a39491e116e2.png"/></div>
<p>As the last tweak, restore the program to its original state and change the value of the second argument to a fixed number, say <em>2</em>:</p>
<pre> Grid.rowconfigure(root, <strong>2</strong>, weight=1)<br/> Grid.columnconfigure(root, <strong>2</strong>, weight=1)</pre>
<p>This will assign the weight only to the third button (counting starts with 0), so the third button becomes responsive, while the others stay non-responsive, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d7508541-365c-47ce-970d-599082b1a8b8.png"/></div>
<p>As a matter of fact, in this last case since we are assigning weight only to a single widget, we could have as well assigned it outside the loop.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling widget resize with &lt;Configure&gt;</h1>
                </header>
            
            <article>
                
<p>There might be occasions when you &lt;indexentry content="window responsiveness:widget resize, handling with "&gt;want to do some specific action when a user resizes a window or a widget. Tkinter provides an event named <kbd>&lt;Configure&gt;</kbd>, which can be bound to a callback to react to changes in widget size.</p>
<p>Here is a simple example (see <kbd>handle_widget_resize.py</kbd>):</p>
<pre>from tkinter import Tk, Label, Pack<br/><br/>root= Tk()<br/>label = Label(root, text = 'I am a Frame', bg='red')<br/>label.pack(fill='both', expand=True)<br/><br/>def on_label_resized(event):<br/>  print('New Width', label.winfo_width())<br/>  print('New Height', label.winfo_height())<br/><br/><strong>label.bind("&lt;Configure&gt;", on_label_resized)</strong><br/>root.mainloop()</pre>
<p>The description of the code is as follows:</p>
<ul>
<li>We have a Label widget in a <kbd>root</kbd> window. We set the pack options for the label to <kbd>(fill='both', expand=True)</kbd> as we want it to resize every time the root window resizes.</li>
<li>We attach a callback to the <kbd>&lt;Configure&gt;</kbd> <span>event to listen for any changes in the size of the label widget. As soon as the label widget changes, it triggers a call to the method </span><kbd>on_label_resized</kbd>.</li>
</ul>
<p>Now if you resize the window, the label resizes and that triggers <kbd>on_label_resized</kbd>, which prints the new height and width of the label widget to the console. This can be used for adjusting the placement of items on the screen.</p>
<p>That concludes our brief discussion on window responsiveness.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We worked with several useful standard modules such as <kbd>functools</kbd>, <kbd>itertools</kbd>,  and <kbd>json</kbd>.</p>
<p>We saw how to work with <em>JSON</em> files. JSON helps us present complex rules about our domain and are an easier and more portable alternative to storing the same information in say a database. </p>
<p>We looked at the practical usage of <kbd>widget.grid_propagate(False)</kbd>  along with some of its limitations in terms of non-responsiveness.</p>
<p><span>We saw the usage of <kbd>OrderedDict</kbd> from the <kbd>collections</kbd> module and <kbd>partials</kbd> from the <kbd>functools</kbd> module.</span></p>
<p>We looked at various root window methods such as <span><kbd>root.geometry</kbd></span>, <span><kbd>root.winfo_screenwidth</kbd></span>, and <span><kbd>root.resizable</kbd></span>.</p>
<p><span>We looked at <kbd>widget.update_idletasks</kbd>, which lets us clear all pending updates without having to wait for the next run of mainloop.</span></p>
<p>Finally, we looked at the steps involved in making a window responsive in Tkinter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QA section</h1>
                </header>
            
            <article>
                
<p>Before you proceed to the next chapter, make sure you can answer these questions to your<br/>
satisfaction:</p>
<ul>
<li><span>What is <kbd>partial</kbd> from the <kbd>functools</kbd> module used for?</span></li>
<li>When and why do we need to use <span><kbd>widget.update_idletasks</kbd> in a Tkinter program?</span></li>
<li>If needed, how can we handle resizing of the main window or any other widget in Tkinter?</li>
<li>What are the data structures available in JSON? (read about it here:<span> </span><a href="https://www.json.org/">https://www.json.org/</a>)</li>
<li>How do you make widgets responsive in Tkinter?</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p><span>Read more about JSON data structures. They are popular and are used everywhere. An alternative structure is XML.  Read about XML and JSON and when and why one should be preferred over the other.</span></p>
<p>The collections module of Python provides some very versatile and useful data structures such as <kbd>namedtuple</kbd>, <kbd>deque</kbd>, <kbd>Counter</kbd>, <kbd>dict</kbd>, <kbd>OrderedDict</kbd>, <kbd>defaultdict</kbd>, <kbd>chainMap</kbd>, <kbd>UserDict</kbd>, <kbd>UserList</kbd>, and <kbd>userString</kbd>. These can be suitably used in a wide variety of use cases. More information can be found at:<a href="https://docs.python.org/3/library/collections.html"> https://docs.python.org/3/library/collections.html</a>.</p>
<p>We used external audio files and external images in our program. This means that they need to be bundled with the program if it has to be packaged and distributed. An alternative packaging of audio files and images can be done using what is called <strong>base-64 encoding</strong>.  The audio files and the images can be base-64 encoded in a text file and then read back and decoded by the program to be used as audio files or image files. Read about base-64 encoding and if you feel motivated enough, try to convert all audio files and images used in this program into base-64 encoding. More information on base-64 encoding can be found here: <a href="https://en.wikipedia.org/wiki/Base64">https://en.wikipedia.org/wiki/Base64</a>.</p>
<p>The Python implementation of base-64 encoding can be found here: <a href="https://docs.python.org/3/library/base64.html">https://docs.python.org/3/library/base64.html</a>.</p>


            </article>

            
        </section>
    </body></html>