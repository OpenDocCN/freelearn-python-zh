- en: <st c="0">10</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="3">Creating Test Cases for Flask</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="33">After building the components of Flask, it is essential to create
    test cases to ensure their correctness and to fix their bugs.</st> <st c="162">Among
    the types</st> <st c="178">of testing,</st> **<st c="190">unit testing</st>**
    <st c="202">focuses on testing the effectiveness and performance of components
    independent of other modules or tasks.</st> <st c="309">On the other hand,</st>
    **<st c="328">integration testing</st>** <st c="347">ensures the correctness of
    a Flask</st> <st c="382">component’s functionality and reliability with all its
    dependencies together</st> <st c="460">at runtime.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="471">To implement these test cases, Python has a built-in module called</st>
    `<st c="539">unittest</st>` <st c="547">that can provide a</st> `<st c="567">TestCase</st>`
    <st c="575">superclass and the</st> `<st c="595">setUp()</st>` <st c="602">and</st>
    `<st c="607">tearDown()</st>` <st c="617">methods that build variations of test
    cases and test suites.</st> <st c="679">There is also a third-party module called</st>
    `<st c="721">pytest</st>`<st c="727">, which is simple, easy to use, and non-boilerplate
    and can provide reusable fixtures for setting up a test environment.</st> <st
    c="848">In this chapter, we will highlight how to implement test cases using</st>
    `<st c="917">pytest</st>` <st c="923">for some selected functionalities from our
    projects in</st> *<st c="979">Chapters 1</st>* <st c="989">to</st> *<st c="993">9</st>*<st
    c="994">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="995">The main goal of this chapter is to provide Flask projects with
    the necessary test environments where we can run, study, scrutinize, analyze,
    and improve the Flask components without deploying the application.</st> <st c="1206">Another
    goal of this chapter is to gain the mindset that testing, at least unit testing,
    is an essential part of any enterprise-grade</st> <st c="1340">application development.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1364">Here are the topics covered in</st> <st c="1396">this chapter:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1409">Creating test cases for web views, repository classes, and</st>
    <st c="1469">native services</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1484">Creating test cases for components in application factory</st>
    <st c="1543">and Blueprints</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1557">Creating test cases for</st> <st c="1582">asynchronous components</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1605">Creating test cases for secured API and</st> <st c="1646">web components</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1660">Creating test cases for</st> <st c="1685">MongoDB transactions</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1705">Creating test cases</st> <st c="1726">for WebSockets</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1740">Technical requirements</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1763">All test cases will be from different applications created from</st>
    *<st c="1828">Chapters 1</st>* <st c="1838">to</st> *<st c="1842">9</st>*<st c="1843">.
    All these applications are in this GitHub</st> <st c="1887">repositpry:</st> [<st
    c="1899">https://github.com/PacktPublishing/Mastering-Flask-Web-Development</st>](https://github.com/PacktPublishing/Mastering-Flask-Web-Development)<st
    c="1965">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1966">Creating test cases for web views, repository classes, and native
    services</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2041">The</st> `<st c="2046">pytest</st>` <st c="2052">module supports
    unit</st> <st c="2074">and integration or functional testing.</st> <st c="2113">It
    requires simple syntax to build test cases, which makes it very easy to use, and
    it has a</st> <st c="2205">platform that can automatically run all test files.</st>
    <st c="2258">Moreover,</st> `<st c="2268">pytest</st>` <st c="2274">is a free
    and open-source module, so install it</st> <st c="2323">using the following</st>
    `<st c="2343">pip</st>` <st c="2346">command:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="2374">However,</st> `<st c="2384">pytest</st>` <st c="2390">will only
    work with Flask projects with directory structures managed by Blueprints and</st>
    *<st c="2478">application factories</st>*<st c="2499">. Our</st> *<st c="2505">Online
    Personal Counselling System</st>* <st c="2539">in</st> [*<st c="2543">Chapter
    1</st>*](B19383_01.xhtml#_idTextAnchor014) <st c="2552">does not follow the Flask
    standards on directory structure.</st> <st c="2613">All view modules import the</st>
    `<st c="2641">app</st>` <st c="2644">instance through</st> `<st c="2662">__main__</st>`<st
    c="2670">, which becomes the</st> `<st c="2690">pytest</st>` <st c="2696">module
    and not the</st> `<st c="2716">main.py</st>` <st c="2723">module during testing.</st>
    <st c="2747">Thus, testing our</st> `<st c="2765">ch01</st>` <st c="2769">project
    gives us the following runtime</st> <st c="2809">error message:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <st c="2876">The error means there is no</st> `<st c="2905">app</st>` <st c="2908">object
    to import in the</st> `<st c="2933">pytest</st>` <st c="2939">module.</st> <st
    c="2948">So, a testable and new version of the</st> *<st c="2986">Online Personal
    Counselling System</st>* <st c="3020">is in the</st> `<st c="3031">ch01-testing</st>`
    <st c="3043">project, which places all the view functions inside Python functions
    that the</st> `<st c="3122">main.py</st>` <st c="3129">module will access to pass
    the</st> `<st c="3161">app</st>` <st c="3164">instance.</st> <st c="3175">The
    following</st> `<st c="3189">main.py</st>` <st c="3196">snippet shows these function
    calls replacing the view’s</st> <st c="3253">import statements:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: <st c="3548">The view functions enclosed in each function will</st> <st c="3598">utilize
    the</st> `<st c="3611">app</st>` <st c="3614">instance to implement the</st> `<st
    c="3641">GET</st>` <st c="3644">and</st> `<st c="3649">POST</st>` <st c="3653">routes.</st>
    <st c="3662">Moreover, to</st> <st c="3674">provide a testing environment from
    Flask, set the</st> `<st c="3725">Testing</st>` <st c="3732">environment to</st>
    `<st c="3748">true</st>` <st c="3752">in the</st> <st c="3760">configuration file.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3779">Now, create a</st> `<st c="3794">tests</st>` <st c="3799">folder
    in the main folder of the accurately structured and circular-import-free Flask
    project directory adjacent to</st> `<st c="3916">main.py</st>`<st c="3923">. In
    this folder, implement the test cases in module files with filenames prefixed
    with the</st> `<st c="4015">test_</st>` <st c="4020">keyword.</st> <st c="4030">If
    the number of test cases increases, sub-folders can further organize these files
    according to functionality (e.g., views, repository, services, API, etc.) or type
    of testing (e.g., unit, integration).</st> *<st c="4234">Figure 10</st>**<st c="4243">.1</st>*
    <st c="4245">shows the final directory structure of the</st> `<st c="4289">ch01-testing</st>`
    <st c="4301">project with the</st> `<st c="4319">tests</st>` <st c="4324">folder.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – The tests folder](img/B19383_10_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="4557">Figure 10.1 – The tests folder</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4587">Now, run the</st> `<st c="4601">pytest</st>` <st c="4607">command
    as a module (</st>`<st c="4629">python -m pytest</st>`<st c="4646">) to execute
    all the test methods, and run each</st> <st c="4694">test file through the</st>
    <st c="4717">following command:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: <st c="4778">Or, run an individual test function using the</st> <st c="4824">following
    command:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: <st c="4900">Let us now explore</st> `<st c="4920">pytest</st>` <st c="4926">by
    creating</st> <st c="4938">test cases for</st> `<st c="4954">ch01-testing</st>`<st
    c="4966">’s model classes, repository transactions, native services, and</st>
    <st c="5031">view functions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5046">Testing the model classes</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="5072">One of the test files</st> <st c="5094">that showcases unit testing
    is</st> `<st c="5126">test_models.py</st>`<st c="5140">, which contains the</st>
    <st c="5161">following implementation:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="10970">from config.db import connect_db</st> def test_connection():
    <st c="11027">@connect_db</st> def create_connection(conn): <st c="11068">assert
    conn is not None</st> create_connection()'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: import pytest
  prefs: []
  type: TYPE_NORMAL
- en: from repository.admin import insert_admin <st c="12144">@pytest.mark.parametrize(("id",
    "fname", "lname", "age", "position", "date_employed", "status"),</st> (("8999",
    "Juan", "Luna", 76, "Manager", "2010-10-10", "active"),
  prefs: []
  type: TYPE_NORMAL
- en: ("9999", "Maria", "Clara", 45, "Developer", "2015-08-15", "inactive")
  prefs: []
  type: TYPE_NORMAL
- en: ))
  prefs: []
  type: TYPE_NORMAL
- en: 'def test_insert_admin(<st c="12402">id,</st> <st c="12406">fname, lname, age,
    position, date_employed, status</st>):'
  prefs: []
  type: TYPE_NORMAL
- en: result = insert_admin(<st c="12483">id, fname, lname, age, position, date_employed,
    status</st>)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assert result is True
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: pip install pytest-mock
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: import pytest <st c="15172">from unittest.mock import patch</st> from repository.admin
    import insert_admin
  prefs: []
  type: TYPE_NORMAL
- en: '@pytest.mark.parametrize(("id", "fname", "lname", "age", "position", "date_employed",
    "status"),'
  prefs: []
  type: TYPE_NORMAL
- en: (("8999", "Juan", "Luna", 76, "Manager", "2010-10-10", "active"),
  prefs: []
  type: TYPE_NORMAL
- en: ("9999", "Maria", "Clara", 45, "Developer", "2015-08-15", "inactive")
  prefs: []
  type: TYPE_NORMAL
- en: ')) <st c="15482">@patch("psycopg2.connect")</st> def test_mock_insert_admin(<st
    c="15536">mock_connect</st>, id, fname, lname, age, position, date_employed, status):
    <st c="15608">mocked_conn = mock_connect.return_value</st><st c="15647">mock_cur
    = mocked_conn.cursor.return_value</st> result = insert_admin(id, fname, lname,
    age, position, date_employed, status) <st c="15769">mock_cur.execute.assert_called_once()</st><st
    c="15806">mocked_conn.commit.assert_called_once()</st> assert result is True'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="17578">@patch("psycopg2.connect")</st> def test_mock_select_users(<st
    c="17633">mock_connect</st>):'
  prefs: []
  type: TYPE_NORMAL
- en: expected_rec = [(222, "sjctrags", "sjctrags", "2023-02-26"), ( 567, "owen",
    "owen", "2023-10-22")] <st c="17749">mocked_conn = mock_connect.return_value</st><st
    c="17788">mock_cur = mocked_conn.cursor.return_value</st><st c="17831">mock_cur.fetchall.return_value
    = expected_rec</st> result = select_all_user()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assert result is expect_rec
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: import pytest
  prefs: []
  type: TYPE_NORMAL
- en: from services.patient_monitoring import record_patient_exam
  prefs: []
  type: TYPE_NORMAL
- en: '@pytest.fixture'
  prefs: []
  type: TYPE_NORMAL
- en: 'def exam_details():'
  prefs: []
  type: TYPE_NORMAL
- en: params = dict()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: params['pid'] = 1111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: params['qid'] = 568
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: params['score'] = 87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: params['total'] = 100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: yield params
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'def test_record_patient_exam(exam_details):'
  prefs: []
  type: TYPE_NORMAL
- en: result = record_patient_exam(exam_details)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assert result is True
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: import pytest
  prefs: []
  type: TYPE_NORMAL
- en: 'from main import app as flask_app <st c="19923">@pytest.fixture(autouse=True)</st>
    def client(): <st c="19967">with flask_app.test_client() as client:</st><st c="20006">yield
    client</st> def test_default_page(client): <st c="20113">test_default_page()</st>
    runs the root page using the <st c="20162">Client</st> instance and checks whether
    the rendered Jinja template contains the <st c="20238">"OPCS"</st> substring.
    <st c="20256">res.data</st> is always in bytes, so decoding it will give us the
    string equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: <st c="20462">On the other hand,</st> `<st c="20482">test_home_page()</st>`
    <st c="20498">runs the</st> `<st c="20508">/home GET</st>` <st c="20517">route
    and verifies whether there is a</st> `<st c="20556">"Welcome"</st>` <st c="20565">word
    on its template page.</st> <st c="20593">Also, it checks whether the path of the
    rendered page is still the</st> `<st c="20660">/home</st>` <st c="20665">URL path:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: <st c="20766">It is also ideal to verify the status code of the</st> `<st c="20817">client.get()</st>`<st
    c="20829">’s response.</st> <st c="20843">The given</st> `<st c="20853">test_exam_page()</st>`
    <st c="20869">checks</st> <st c="20877">whether running the</st> `<st c="20897">/exam/assign</st>`
    <st c="20909">URL will result in an HTTP Status</st> <st c="20944">Code 200.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="20953">On the other hand, the</st> `<st c="20977">Client</st>` <st c="20983">instance
    has a</st> `<st c="20999">post()</st>` <st c="21005">method to test and run</st>
    `<st c="21029">POST</st>` <st c="21033">routes.</st> <st c="21042">The following
    implementation shows how to simulate</st> <st c="21093">form-handling transactions:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: <st c="21556">Since form parameters are ideally in a hashtable format, fixtures
    must yield these form parameters with their corresponding values inside a dictionary
    collection, like in our</st> `<st c="21732">form_data()</st>` <st c="21743">fixture.</st>
    <st c="21753">Then, we pass this yielded form data to the data parameter of the</st>
    `<st c="21819">client.post()</st>` <st c="21832">method.</st> <st c="21841">Afterward,
    we perform the necessary assertions to verify the correctness of the view procedure
    and</st> <st c="21940">its response.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="21953">Aside from checking the</st> <st c="21977">rendered URL path,
    content, and status code of a</st> `<st c="22027">GET</st>` <st c="22030">route,
    it is also feasible to test redirections in a view using</st> `<st c="22095">pytest</st>`<st
    c="22101">. The following implementation showcases how to test whether a</st>
    `<st c="22164">POST</st>` <st c="22168">transaction redirected a user to another</st>
    <st c="22210">view page:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'def test_assign_exam_redirect_302(client, form_data):'
  prefs: []
  type: TYPE_NORMAL
- en: res = client.post('/exam/assign', data=form_data) <st c="23622">302</st> because
    there is no <st c="23646">follow_redirects</st> parameter set in <st c="23680">client.post()</st>.
    Also, <st c="23701">res.location</st> is the appropriate attribute to extract
    the URL path because <st c="23775">res.request.path</st> will give the URL path
    of the <st c="23822">POST</st> transaction instead.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="23847">Aside from asserting</st> `<st c="23869">status_code</st>`<st
    c="23880">, verifying the correctness of the redirection includes checking the
    correct redirected path and the content type.</st> <st c="23995">Mocking can also
    be an additional strategy to closely examine the internals of the</st> `<st c="24078">POST</st>`
    <st c="24082">transactions and their redirections if there are any.</st> **<st
    c="24137">Monkey patching</st>** <st c="24152">can help refine the view processes</st>
    <st c="24188">through testing.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="24204">Let’s now learn how to use monkey patching in testing</st> <st
    c="24259">view functions.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="24274">Applying the monkey patching</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="24325">pytest</st>` <st c="24331">feature that involves intercepting
    a function in a view transaction and replacing it with a custom-implemented mock
    function that returns our desired result.</st> <st c="24490">The mock function
    must</st> <st c="24513">have the same parameter list and return type as the original
    one.</st> <st c="24579">Otherwise, monkey patching will not work.</st> <st c="24621">The
    following is a test case for redirection that uses</st> <st c="24676">monkey patching:</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`<st c="25192">monkeypatch</st>` <st c="25204">is an object injected into</st>
    <st c="25232">the fixture function.</st> <st c="25254">It can emit a variety of
    methods for faking attributes and functions of other objects in a package and
    modules.</st> <st c="25366">In the given example, the objective is to test the</st>
    `<st c="25417">/exam/assign</st>` <st c="25429">form transaction with a mocked</st>
    `<st c="25461">insert_question_details()</st>`<st c="25486">. Instead of using
    the</st> `<st c="25509">patch()</st>` <st c="25516">decorator, the</st> `<st c="25532">monkeypatch</st>`
    <st c="25543">object of the fixture replaces the original function with a dummy</st>
    `<st c="25610">insert_question_details()</st>` <st c="25635">using its</st> `<st
    c="25646">setattr()</st>` <st c="25655">method.</st> <st c="25664">The dummy method
    needs to return a</st> `<st c="25699">True</st>` <st c="25703">value because the
    test needs to examine the behavior of the view function whenever the</st> `<st
    c="25791">INSERT</st>` <st c="25797">transaction is successful.</st> <st c="25825">Now,
    to enable monkey patching, you must inject the fixture containing the</st> `<st
    c="25900">monkeypatch</st>` <st c="25911">objects into the test functions like
    a typical fixture that</st> <st c="25972">yields resources.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="25989">Monkey patching does not replace the actual code of the mocked
    function.</st> <st c="26063">In the given</st> `<st c="26076">setattr()</st>`<st
    c="26085">, the</st> `<st c="26091">views.examination.insert_question_details</st>`
    <st c="26132">expression indicates the repository method in the</st> `<st c="26183">/exam/assign</st>`
    <st c="26195">route and not in its actual repository class.</st> <st c="26242">So,
    this is just replacing the state of the method call in the view function and not
    modifying the method’s</st> <st c="26350">actual implementation.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="26372">Testing the repository, service, and view layers requires integration
    testing with or without mocking and</st> `<st c="26479">parametrize()</st>` <st
    c="26492">markers to find all the bugs and inconsistencies in the algorithms.</st>
    <st c="26561">Regardless, it is easier to set up test classes and files in organized
    applications that utilize application factories and Blueprints because those projects
    do not need directory restructuring, such as the one imposed on the</st> `<st
    c="26786">ch01</st>` <st c="26790">application.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="26803">Let us discuss now the benefit of using</st> `<st c="26844">create_app()</st>`
    <st c="26856">and Blueprints in testing</st> <st c="26883">Flask components.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="26900">Creating test cases for components in application factory and
    Blueprints</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="26973">Application factory functions and Blueprints help solve circular
    import problems by managing the context loading and allowing the Flask</st> `<st
    c="27110">app</st>` <st c="27113">instance to be accessible across the application</st>
    <st c="27162">without tapping the</st> `<st c="27183">__main__</st>` <st c="27191">top-level
    module.</st> <st c="27210">Since every component and layer is in its proper place,
    it is easier to set up the</st> <st c="27293">testing environment.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="27313">Our applications in</st> *<st c="27334">Chapters 2</st>* <st c="27344">and</st>
    *<st c="27349">3</st>* <st c="27350">have essential Flask components that need
    testing, such as the repository transaction built by the SQLAlchemy, exceptions,
    and standard API functions.</st> <st c="27502">All these components are built
    by the</st> `<st c="27540">create_app()</st>` <st c="27552">factory</st> <st c="27561">and
    Blueprints.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="27576">Let us start formulating test cases for SQLAlchemy</st> <st c="27628">repository
    transactions.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="27652">Testing ORM transactions</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="27677">The</st> *<st c="27682">Online Shipping</st>* <st c="27697">app
    in</st> [*<st c="27705">Chapter 2</st>*](B19383_02.xhtml#_idTextAnchor047) <st
    c="27714">uses the standard SQLAlchemy ORM to implement the CRUD transactions.</st>
    <st c="27784">Integration</st> <st c="27795">testing can help test the repository
    layer of our application.</st> <st c="27859">Let us examine the following test
    case implementation that runs the</st> `<st c="27927">insert()</st>` <st c="27935">transaction</st>
    <st c="27948">of</st> `<st c="27951">ProductRepository</st>`<st c="27968">:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`<st c="28722">test_mock_add_products()</st>` <st c="28747">focuses on examining
    the flow of the</st> `<st c="28785">INSERT</st>` <st c="28791">transaction in
    adding a new product line to the database.</st> <st c="28850">It mocks the</st>
    `<st c="28863">db_session</st>` <st c="28873">from SQLAlchemy’s</st> `<st c="28892">scoped_session</st>`
    <st c="28906">because the test is on the lines of codes and not with the</st>
    `<st c="28966">db_session</st>`<st c="28976">’s</st> `<st c="28980">add()</st>`
    <st c="28985">method.</st> `<st c="28994">assert_called_once()</st>` <st c="29014">of
    mocked</st> `<st c="29025">add()</st>` <st c="29030">and</st> `<st c="29035">commit()</st>`
    <st c="29043">will verify the execution of these methods during</st> <st c="29094">the
    test.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="29103">Now, the</st> `<st c="29113">ch02-blueprint</st>` <st c="29127">project</st>
    <st c="29136">uses the</st> `<st c="29145">before_request()</st>` <st c="29161">and</st>
    `<st c="29166">after_request()</st>` <st c="29181">events to track down the requests
    of every view and the user who accesses the views.</st> <st c="29267">These two
    application-level events become the core implementation of the application’s custom
    authentication mechanism.</st> <st c="29387">All view pages in the project happen
    to be secured.</st> <st c="29439">So, running and testing the</st> `<st c="29467">/ch02/products/add</st>`
    <st c="29485">view, for instance, without logging in as a valid user, will lead
    to a redirection to the login page, as verified by the following</st> <st c="29617">test
    case:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'def test_add_product_with_login(form_data, login_data, client): <st c="30246">res_login
    = client.post("/ch02/login/auth",</st> <st c="30289">data=login_data)</st><st
    c="30306">with client.session_transaction() as session:</st><st c="30352">assert
    ''admin'' == session["username"]</st> assert res_login.location.split(''?'')[0]
    == url_for(''home_bp.menu'')'
  prefs: []
  type: TYPE_NORMAL
- en: res = client.post("/ch02/products/add", data=form_data)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assert res.status_code == 200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: import pytest
  prefs: []
  type: TYPE_NORMAL
- en: from mock import patch, MagicMock
  prefs: []
  type: TYPE_NORMAL
- en: from main import app as flask_app
  prefs: []
  type: TYPE_NORMAL
- en: import json
  prefs: []
  type: TYPE_NORMAL
- en: '@pytest.fixture'
  prefs: []
  type: TYPE_NORMAL
- en: 'def client():'
  prefs: []
  type: TYPE_NORMAL
- en: 'with flask_app.test_client() as client:'
  prefs: []
  type: TYPE_NORMAL
- en: yield client
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'def test_index(client): <st c="32209">res = client.get(''/index'')</st><st
    c="32235">data = json.loads(res.get_data(as_text=True))</st> assert data["message"]
    == "This is an Online Pizza Ordering System."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: <st c="32831">@pytest.fixture</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="32847">def order_data():</st> order_details = {"date_ordered": "2020-12-10",
    "empid": "EMP-101" , "cid": "CUST-101", "oid": "ORD-910"} <st c="32971">yield
    order_details</st> order_details = None'
  prefs: []
  type: TYPE_NORMAL
- en: 'def test_add_order(client, <st c="33039">order_data</st>): <st c="33053">res
    = client.post("/order/add", json=order_data)</st> assert res.status_code == 201'
  prefs: []
  type: TYPE_NORMAL
- en: assert res.content_type == 'application/json'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'def test_delete_order(client): <st c="33768">res = client.delete("/order/delete/ORD-910")</st>
    assert res.status_code == 201'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: import pytest
  prefs: []
  type: TYPE_NORMAL
- en: from main import app as flask_app <st c="35077">from app.exceptions.db import
    DuplicateRecordException</st> @pytest.fixture
  prefs: []
  type: TYPE_NORMAL
- en: 'def client():'
  prefs: []
  type: TYPE_NORMAL
- en: 'with flask_app.test_client() as client:'
  prefs: []
  type: TYPE_NORMAL
- en: yield client
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@pytest.fixture'
  prefs: []
  type: TYPE_NORMAL
- en: 'def employee_data():'
  prefs: []
  type: TYPE_NORMAL
- en: 'order_details = {"empid": "EMP-101", "fname": "Sherwin John" , "mname": "Calleja",
    "lname": "Tragura", "age": 45 , "role": "clerk", "date_employed": "2011-08-11",
    "status": "active", "salary": 60000.99}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: yield order_details
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: order_details = None
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'def test_add_employee(client, employee_data): <st c="35542">with pytest.raises(DuplicateRecordException)
    as ex:</st> res = client.post(''/employee/add'', json=employee_data)'
  prefs: []
  type: TYPE_NORMAL
- en: assert res.status_code == 200
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: assert str(ex.value) == "insert employee record encountered a problem"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="36399">@pytest.mark.xfail(strict=True, raises=NoRecordException, reason=”No
    existing record.”)</st> def test_update_employee(client, employee_data): <st c="36537">res
    = client.patch(f''/employee/update/</st> <st c="36575">{employee_data["empid"]}'',
    json=employee_data)</st> assert res.status_code == 201'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: import pytest
  prefs: []
  type: TYPE_NORMAL
- en: from main import app as flask_app
  prefs: []
  type: TYPE_NORMAL
- en: '@pytest.fixture(scope="module", autouse=True)'
  prefs: []
  type: TYPE_NORMAL
- en: 'def client():'
  prefs: []
  type: TYPE_NORMAL
- en: 'with flask_app.test_client() as app:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: yield app
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'def test_add_vote_ws_client(client): <st c="38724">ch05-web</st> project has
    an <st c="38748">async</st> WebSocket client, the <st c="38776">add_vote_count_client()</st>
    view function. The given <st c="38825">test_add_vote_ws_client()</st> runs and
    tests the <st c="38870">HTTP GET</st> request transaction using <st c="38905">client.get()</st>.
    So, this is the same when running a standard view function using the test <st
    c="38993">Client</st> class and also with an asynchronous API endpoint function,
    as shown by the following test case implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: <st c="39437">The</st> `<st c="39442">add_login()</st>` <st c="39453">API with
    the</st> `<st c="39467">/ch05/login/add</st>` <st c="39482">URL pattern is an</st>
    `<st c="39501">async</st>` <st c="39506">API endpoint function that adds new login
    details to the database.</st> `<st c="39574">test_add_login()</st>` <st c="39590">performs
    exception testing on the</st> <st c="39625">API to check whether adding existing
    records will throw an error.</st> <st c="39691">So, the</st> <st c="39698">process
    and formulation of the test cases are the same as testing their standard counterparts.</st>
    <st c="39794">But what if the transactions under testing are asynchronous such
    that test functions need to await to execute them?</st> <st c="39910">How can</st>
    `<st c="39918">pytest</st>` <st c="39924">directly call an async method?</st>
    <st c="39956">Let us take a look at testing asynchronous</st> <st c="39999">SQLAlchemy
    transactions.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="40023">Testing the asynchronous repository layer</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="40065">The ORM used in</st> `<st c="40082">ch05-web</st>` <st c="40090">and</st>
    `<st c="40095">ch05-api</st>` <st c="40103">projects is the asynchronous SQLAlchemy.</st>
    <st c="40145">In an</st> `<st c="40151">async</st>` <st c="40156">ORM, all CRUD
    operations run as</st> <st c="40189">coroutines that need the</st> `<st c="40214">await</st>`
    <st c="40219">keyword to execute them.</st> <st c="40245">Likewise, test functions
    need to</st> `<st c="40278">await</st>` <st c="40283">these asynchronous components</st>
    <st c="40314">under test to execute them as coroutines.</st> <st c="40356">However,</st>
    `<st c="40365">pytest</st>` <st c="40371">requires an extension module called</st>
    `<st c="40408">pytest-asyncio</st>` <st c="40422">to add support for implementing
    asynchronous test functions.</st> <st c="40484">So, install the</st> `<st c="40500">pytest-asyncio</st>`
    <st c="40514">module using the following</st> `<st c="40542">pip</st>` <st c="40545">command
    before implementing the</st> <st c="40578">test case:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: <st c="40615">The implementation is the same as the previous ones except for
    the</st> `<st c="40683">pytest_plugins</st>` <st c="40697">component, which imports
    the necessary</st> `<st c="40737">pytest</st>` <st c="40743">extension, such as</st>
    `<st c="40763">pytest-asyncio</st>`<st c="40777">. The</st> `<st c="40783">pytest_plugins</st>`
    <st c="40797">component imports the installed</st> `<st c="40830">pytest</st>`
    <st c="40836">extensions and adds features to the testing</st> <st c="40881">environment
    that</st> `<st c="40898">pytest</st>` <st c="40904">alone cannot perform.</st>
    <st c="40927">With</st> `<st c="40932">pytest-asyncio</st>`<st c="40946">, testing</st>
    <st c="40955">transactions run by coroutines, like in the following snippet, is</st>
    <st c="41022">now feasible:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: <st c="41579">Calling an asynchronous method for testing always requires a test
    function to be</st> `<st c="41661">async</st>` <st c="41666">because it needs
    to await the function under test.</st> <st c="41718">The given</st> `<st c="41728">test_add_login()</st>`
    <st c="41744">is an</st> `<st c="41751">async</st>` <st c="41756">method because
    it needs to call and await an asynchronous</st> `<st c="41815">insert_login()</st>`
    <st c="41829">transaction.</st> <st c="41843">However, for</st> `<st c="41856">pytest</st>`
    <st c="41862">to run an</st> `<st c="41873">async</st>` <st c="41878">test function,
    it will require the test functions to be</st> <st c="41935">decorated by</st>
    `<st c="41948">@pytest.mark.asyncio()</st>` <st c="41970">provided by the</st>
    `<st c="41987">pytest-asyncio</st>` <st c="42001">library.</st> <st c="42011">But</st>
    <st c="42015">what will be the case when Celery background tasks will</st> <st
    c="42071">undergo testing?</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="42087">Testing Celery tasks</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="42108">Pytest</st>` <st c="42115">needs the</st> `<st c="42126">pytest-celery</st>`
    <st c="42139">extension module to run Celery tasks under testing.</st> <st c="42192">Thus,
    the test file needs to</st> <st c="42221">include</st> `<st c="42229">pytest_celery</st>`
    <st c="42242">in its</st> `<st c="42250">pytest_plugins</st>`<st c="42264">. The
    following test function</st> <st c="42293">runs the</st> `<st c="42303">add_vote_task_wrapper()</st>`
    <st c="42326">task to add a candidate’s votes to</st> <st c="42362">the database:</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: import os
  prefs: []
  type: TYPE_NORMAL
- en: 'def test_upload_file(client):'
  prefs: []
  type: TYPE_NORMAL
- en: test_file = os.getcwd() + "/tests/files/2011Q2.xlsx" <st c="45154">data = {</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '<st c="45162">''data_file'': (open(test_file, ''rb''), test_file)</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45210">}</st> response = client.post("/ch06/upload/xlsx/analysis", <st
    c="45266">buffered=True, content_type='multipart/form-data', data=data</st>)
  prefs: []
  type: TYPE_NORMAL
- en: assert response.status_code == 200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assert response.mimetype == "text/html"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: import pytest
  prefs: []
  type: TYPE_NORMAL
- en: from flask import url_for
  prefs: []
  type: TYPE_NORMAL
- en: from main import app as flask_app
  prefs: []
  type: TYPE_NORMAL
- en: '@pytest.fixture'
  prefs: []
  type: TYPE_NORMAL
- en: 'def client(): <st c="47352">flask_app.config["WTF_CSRF_ENABLED"] = False</st>
    with flask_app.test_client() as app:'
  prefs: []
  type: TYPE_NORMAL
- en: yield app
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '@pytest.fixture(scope="module")'
  prefs: []
  type: TYPE_NORMAL
- en: 'def user_credentials():'
  prefs: []
  type: TYPE_NORMAL
- en: params = dict()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: params["username"] = "sjctrags"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: params["password"] = "sjctrags"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return params
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'def test_patient_profile_add_invalid_access(client): <st c="47647">res = client.get("/ch09/patient/profile/add",</st>
    <st c="47692">base_url=''https://localhost'')</st> assert res.status_code == 302
    <st c="47816">pytest</st> to access and run <st c="47841">/ch09/patient/profile/add</st>,
    which is a form view, you must first disable the CSRF protection of the <st c="47940">flask_wtf.csrf</st>
    module using its <st c="47972">WTF_CSRF_ENABLED</st> built-in environment variable
    before extracting the test <st c="48046">Client</st> instance in the <st c="48069">client()</st>
    fixture. Running the given test function with the correct user credentials will
    show a successful result since the access is unauthenticated, causing a redirection
    to the <st c="48249">/ch09/login/auth</st> view. So far, the application uses
    custom authentication but with a database-encrypted username managed by the <st
    c="48377">flask-session</st> extension module.'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48408">This test proves that accessing any view from our</st> *<st c="48459">Online
    Vaccine Registration</st>* <st c="48486">application requires user authentication
    from its</st> `<st c="48537">/ch09/login/auth</st>` <st c="48553">view page.</st>
    <st c="48565">Any unauthenticated attempt to its</st> <st c="48600">view will
    redirect the user to the login page.</st> <st c="48647">The following snippet
    builds the proper access flow to our application’s views with</st> <st c="48731">user
    authentication:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: import pytest
  prefs: []
  type: TYPE_NORMAL
- en: from main import app as flask_app <st c="50399">import base64</st> @pytest.fixture
  prefs: []
  type: TYPE_NORMAL
- en: 'def client():'
  prefs: []
  type: TYPE_NORMAL
- en: 'with flask_app.test_client() as app:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: yield app
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '@pytest.fixture'
  prefs: []
  type: TYPE_NORMAL
- en: 'def vaccine():'
  prefs: []
  type: TYPE_NORMAL
- en: 'vacc = {"vacid": "VAC-899", "vacname": "Narvas", "vacdesc": "For Hypertension",
    "qty": 5000, "price": 1200.5, "status": True}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return vacc
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'def test_add_vaccine_unauth(client, vaccine):'
  prefs: []
  type: TYPE_NORMAL
- en: 'res = client.post("/ch09/vaccine/add", json=vaccine, <st c="50758">headers={''Access-Control-Allow-Origin'':
    "http://localhost:5000"}</st>)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assert res.status_code == 201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '@pytest.fixture <st c="51468">def auth_header():</st><st c="51486">credentials
    = base64.b64encode(b''sjctrags:sjctrags'') .decode(''utf-8'')</st> return credentials'
  prefs: []
  type: TYPE_NORMAL
- en: 'def test_add_vaccine_auth(client, vaccine, <st c="51619">auth_header</st>):'
  prefs: []
  type: TYPE_NORMAL
- en: 'res = client.post("/vaccine/add", json=vaccine, <st c="51682">headers={''Authorization'':
    ''Basic '' + auth_header, ''Access-Control-Allow-Origin'': "http://localhost:5000"}</st>)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assert res.status_code == 201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: import pytest
  prefs: []
  type: TYPE_NORMAL
- en: from flask_login import current_user
  prefs: []
  type: TYPE_NORMAL
- en: from main import app as flask_app
  prefs: []
  type: TYPE_NORMAL
- en: 'def test_add_admin_profile(client, admin_details, user_credentials): <st c="53550">res_login
    = client.post(''/ch09/login/auth'',</st> <st c="53593">data=user_credentials)</st><st
    c="53616">assert res_login.status_code == 200</st><st c="53652">with client.session_transaction()
    as session:</st><st c="53698">assert current_user.username == "sjctrags"</st><st
    c="53741">res = client.post("/ch09/admin/profile/add", data=admin_details)</st>
    assert res.status_code == 200'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '@pytest.fixture'
  prefs: []
  type: TYPE_NORMAL
- en: 'def client(): <st c="54734">flask_app.config["LOGIN_DISABLED"] = True</st>
    with flask_app.test_client() as app:'
  prefs: []
  type: TYPE_NORMAL
- en: yield app
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'def test_add_admin_profile(client, admin_details):'
  prefs: []
  type: TYPE_NORMAL
- en: res = client.post("/admin/profile/add", data=admin_details)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assert res.status_code == 200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: pip install mongomock
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: import pytest <st c="56693">import mongomock</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="56709">from mongoengine import connect, get_connection, disconnect</st>
    from main import app as flask_app
  prefs: []
  type: TYPE_NORMAL
- en: from modules.repository.mongo.tutor_login import TutorLoginRepository
  prefs: []
  type: TYPE_NORMAL
- en: from bcrypt import hashpw, gensalt
  prefs: []
  type: TYPE_NORMAL
- en: '@pytest.fixture'
  prefs: []
  type: TYPE_NORMAL
- en: 'def login_details():'
  prefs: []
  type: TYPE_NORMAL
- en: login = dict()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: login["username"] = "sjctrags"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: login["password"] = "sjctrags"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: login["encpass"] = hashpw(str(login['username']) .encode(), gensalt())
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return login
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@pytest.fixture'
  prefs: []
  type: TYPE_NORMAL
- en: 'def client():'
  prefs: []
  type: TYPE_NORMAL
- en: disconnect()
  prefs: []
  type: TYPE_NORMAL
- en: 'with flask_app.test_client() as client:'
  prefs: []
  type: TYPE_NORMAL
- en: yield client <st c="57203">@pytest.fixture</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="57218">def connect_db():</st><st c="57236">connect</st>(host='localhost',
    port=27017, db='tfs_test', uuidRepresentation='standard', <st c="57322">mongo_client_class=mongomock.MongoClient</st>)
    <st c="57365">conn = get_connection()</st> return conn
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'def test_add_login(client, <st c="58378">connect_db</st>, login_details):'
  prefs: []
  type: TYPE_NORMAL
- en: repo = TutorLoginRepository()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: res = repo.insert_login(login_details)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assert res is True
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: pip install websockets
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Pip install pytest-asyncio
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: <st c="59791">import websockets</st> import pytest
  prefs: []
  type: TYPE_NORMAL
- en: import json <st c="59836">import pytest_asyncio</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59857">pytest_plugins = ('pytest_asyncio',)</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="59894">async</st> def simulated_add_votecount_view(<st c="59934">websocket</st>):
    <st c="59948">async for message in websocket:</st> print("received: ",message)'
  prefs: []
  type: TYPE_NORMAL
- en: Place here the VoteCount repo transactions <st c="60087">simulated_add_votecount_view()</st>
    will serve as the mocked WebSocket endpoint function, which receives and saves
    the tallied votes into the database.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="60234">Next, create a mock server using the</st> `<st c="60272">websockets.serve()</st>`
    <st c="60290">method to run the simulated route</st> <st c="60324">in an</st>
    `<st c="60361">host</st>`<st c="60365">,</st> `<st c="60367">port</st>`<st c="60371">,
    and the simulated view name, such as</st> `<st c="60410">simulated_add_votecount_view</st>`<st
    c="60438">, to operate.</st> <st c="60452">The following is our WebSocket server,
    which</st> <st c="60497">will run at the</st> `<st c="60513">ws://localhost:5001</st>`
    <st c="60532">address:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: <st c="60698">Since</st> `<st c="60705">create_ws_server()</st>` <st c="60723">must
    be</st> `<st c="60732">async</st>`<st c="60737">, decorating it with</st> `<st
    c="60758">@pytest.fixture</st>` <st c="60773">will cause an error.</st> <st c="60795">So,
    use</st> `<st c="60803">@pytest_asyncio.fixture</st>` <st c="60826">to declare
    the asynchronous fixtures</st> <st c="60864">for</st> `<st c="60868">pytest</st>`<st
    c="60874">.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="60875">Finally, we start our test function implementation with the context
    manager that opens the</st> `<st c="60967">websockets</st>` <st c="60977">client
    object for WebSocket endpoint execution and closes it afterward.</st> <st c="61050">The
    following implementation shows a test function for the</st> `<st c="61109">add_vote_count_server()</st>`
    <st c="61132">WebSocket with the</st> `<st c="61152">ws://localhost:5001/ch05/vote/save/ws</st>`
    <st c="61189">URL address:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: import pytest
  prefs: []
  type: TYPE_NORMAL
- en: import websockets
  prefs: []
  type: TYPE_NORMAL
- en: import json
  prefs: []
  type: TYPE_NORMAL
- en: pytest_plugins = ('pytest_asyncio',)
  prefs: []
  type: TYPE_NORMAL
- en: '@pytest.fixture(scope="module", autouse=True)'
  prefs: []
  type: TYPE_NORMAL
- en: 'def vote_tally_details():'
  prefs: []
  type: TYPE_NORMAL
- en: 'tally = {"election_id":"1", "precinct": "111-C", "final_tally": "6000", "approved_date":
    "2024-10-10"}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: yield tally
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tally = None
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@pytest.mark.asyncio'
  prefs: []
  type: TYPE_NORMAL
- en: 'async def test_websocket_actual(vote_tally_details): <st c="62816">async with</st>
    <st c="62826">websockets.connect("ws://localhost:5001/ch05/ vote/save/ws") as
    websocket</st>:'
  prefs: []
  type: TYPE_NORMAL
- en: await websocket.send(json.dumps( vote_tally_details))
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: response = await websocket.recv()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: assert response == "data not added"
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
