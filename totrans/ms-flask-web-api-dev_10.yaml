- en: <st c="0">10</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">10
- en: <st c="3">Creating Test Cases for Flask</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3">为Flask创建测试用例
- en: <st c="33">After building the components of Flask, it is essential to create
    test cases to ensure their correctness and to fix their bugs.</st> <st c="162">Among
    the types</st> <st c="178">of testing,</st> **<st c="190">unit testing</st>**
    <st c="202">focuses on testing the effectiveness and performance of components
    independent of other modules or tasks.</st> <st c="309">On the other hand,</st>
    **<st c="328">integration testing</st>** <st c="347">ensures the correctness of
    a Flask</st> <st c="382">component’s functionality and reliability with all its
    dependencies together</st> <st c="460">at runtime.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Flask组件之后，创建测试用例以确保它们的正确性并修复它们的错误是至关重要的。<st c="33">在测试类型中，</st> **<st c="190">单元测试</st>**
    <st c="202">专注于测试组件在独立于其他模块或任务时的有效性和性能。</st> <st c="309">另一方面，</st> **<st c="328">集成测试</st>**
    <st c="347">确保Flask</st> <st c="382">组件的功能性和可靠性在所有依赖项一起</st> <st c="460">运行时</st>的正确性。
- en: <st c="471">To implement these test cases, Python has a built-in module called</st>
    `<st c="539">unittest</st>` <st c="547">that can provide a</st> `<st c="567">TestCase</st>`
    <st c="575">superclass and the</st> `<st c="595">setUp()</st>` <st c="602">and</st>
    `<st c="607">tearDown()</st>` <st c="617">methods that build variations of test
    cases and test suites.</st> <st c="679">There is also a third-party module called</st>
    `<st c="721">pytest</st>`<st c="727">, which is simple, easy to use, and non-boilerplate
    and can provide reusable fixtures for setting up a test environment.</st> <st
    c="848">In this chapter, we will highlight how to implement test cases using</st>
    `<st c="917">pytest</st>` <st c="923">for some selected functionalities from our
    projects in</st> *<st c="979">Chapters 1</st>* <st c="989">to</st> *<st c="993">9</st>*<st
    c="994">.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些测试用例，Python有一个内置的模块叫做<st c="539">unittest</st>，它可以提供一个<st c="567">TestCase</st>
    <st c="575">超类</st>以及<st c="595">setUp()</st> <st c="602">和</st> <st c="607">tearDown()</st>
    <st c="617">方法，这些方法可以构建测试用例和测试套件的变体。<st c="679">还有一个名为</st> <st c="721">pytest</st><st
    c="727">的第三方模块，它简单易用，非模板化，并且可以提供用于设置测试环境的可重用固定值。<st c="848">在本章中，我们将重点介绍如何使用</st>
    <st c="917">pytest</st> <st c="923">为从第</st> *<st c="979">1</st> <st c="989">章</st>
    到第</st> *<st c="993">9</st> <st c="994">章</st> 的项目中选定的功能实现测试用例。</st>
- en: <st c="995">The main goal of this chapter is to provide Flask projects with
    the necessary test environments where we can run, study, scrutinize, analyze,
    and improve the Flask components without deploying the application.</st> <st c="1206">Another
    goal of this chapter is to gain the mindset that testing, at least unit testing,
    is an essential part of any enterprise-grade</st> <st c="1340">application development.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="995">本章的主要目标是提供Flask项目所需的测试环境，在其中我们可以运行、研究、审查、分析和改进Flask组件，而无需部署应用程序。</st>
    <st c="1206">本章的另一个目标是培养测试（至少是单元测试）是任何企业级</st> <st c="1340">应用程序开发</st>的必要部分的思维方式。
- en: <st c="1364">Here are the topics covered in</st> <st c="1396">this chapter:</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1364">以下是本章涵盖的主题：</st> <st c="1396">：</st>
- en: <st c="1409">Creating test cases for web views, repository classes, and</st>
    <st c="1469">native services</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1409">为Web视图、存储库类和</st> <st c="1469">本地服务</st>创建测试用例
- en: <st c="1484">Creating test cases for components in application factory</st>
    <st c="1543">and Blueprints</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为<st c="1484">应用工厂</st>中的组件和<st c="1543">蓝图</st>创建测试用例
- en: <st c="1557">Creating test cases for</st> <st c="1582">asynchronous components</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为<st c="1557">异步组件</st>创建测试用例
- en: <st c="1605">Creating test cases for secured API and</st> <st c="1646">web components</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1605">为受保护API和</st> <st c="1646">Web组件</st>创建测试用例
- en: <st c="1660">Creating test cases for</st> <st c="1685">MongoDB transactions</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1660">为</st> <st c="1685">MongoDB事务</st>创建测试用例
- en: <st c="1705">Creating test cases</st> <st c="1726">for WebSockets</st>
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1705">为</st> <st c="1726">WebSocket</st>创建测试用例
- en: <st c="1740">Technical requirements</st>
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1740">技术要求
- en: <st c="1763">All test cases will be from different applications created from</st>
    *<st c="1828">Chapters 1</st>* <st c="1838">to</st> *<st c="1842">9</st>*<st c="1843">.
    All these applications are in this GitHub</st> <st c="1887">repositpry:</st> [<st
    c="1899">https://github.com/PacktPublishing/Mastering-Flask-Web-Development</st>](https://github.com/PacktPublishing/Mastering-Flask-Web-Development)<st
    c="1965">.</st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1763">所有测试用例都将来自从</st> *<st c="1828">第1章</st>* <st c="1838">到</st> *<st
    c="1842">第9章</st>* <st c="1843">创建的不同应用程序。</st> <st c="1843">所有这些应用程序都在这个GitHub</st>
    <st c="1887">仓库中：</st> [<st c="1899">https://github.com/PacktPublishing/Mastering-Flask-Web-Development</st>](https://github.com/PacktPublishing/Mastering-Flask-Web-Development)<st
    c="1965">。</st>
- en: <st c="1966">Creating test cases for web views, repository classes, and native
    services</st>
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1966">为Web视图、存储库类和本地服务创建测试用例</st>
- en: <st c="2041">The</st> `<st c="2046">pytest</st>` <st c="2052">module supports
    unit</st> <st c="2074">and integration or functional testing.</st> <st c="2113">It
    requires simple syntax to build test cases, which makes it very easy to use, and
    it has a</st> <st c="2205">platform that can automatically run all test files.</st>
    <st c="2258">Moreover,</st> `<st c="2268">pytest</st>` <st c="2274">is a free
    and open-source module, so install it</st> <st c="2323">using the following</st>
    `<st c="2343">pip</st>` <st c="2346">command:</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2041">`pytest`</st> `<st c="2046">模块</st>` <st c="2052">支持单元</st> `<st
    c="2074">和集成或功能测试。</st> <st c="2113">它需要简单的语法来构建测试用例，这使得它非常容易使用，并且它有一个</st> `<st
    c="2205">平台</st>` <st c="2205">可以自动运行所有测试文件。</st> <st c="2258">此外，</st> `<st c="2268">pytest</st>`
    <st c="2274">是一个免费和开源模块，因此使用以下</st> `<st c="2343">pip</st>` <st c="2346">命令安装：</st>
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="2374">However,</st> `<st c="2384">pytest</st>` <st c="2390">will only
    work with Flask projects with directory structures managed by Blueprints and</st>
    *<st c="2478">application factories</st>*<st c="2499">. Our</st> *<st c="2505">Online
    Personal Counselling System</st>* <st c="2539">in</st> [*<st c="2543">Chapter
    1</st>*](B19383_01.xhtml#_idTextAnchor014) <st c="2552">does not follow the Flask
    standards on directory structure.</st> <st c="2613">All view modules import the</st>
    `<st c="2641">app</st>` <st c="2644">instance through</st> `<st c="2662">__main__</st>`<st
    c="2670">, which becomes the</st> `<st c="2690">pytest</st>` <st c="2696">module
    and not the</st> `<st c="2716">main.py</st>` <st c="2723">module during testing.</st>
    <st c="2747">Thus, testing our</st> `<st c="2765">ch01</st>` <st c="2769">project
    gives us the following runtime</st> <st c="2809">error message:</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2374">然而，</st> `<st c="2384">pytest</st>` <st c="2390">只能与由Blueprints和</st>
    *<st c="2478">应用程序工厂</st>* <st c="2499">管理的目录结构</st> <st c="2505">的Flask项目一起工作。</st>
    <st c="2539">我们的</st> *<st c="2505">在线个人咨询服务</st>* <st c="2539">在</st> [*<st c="2543">第1章</st>*](B19383_01.xhtml#_idTextAnchor014)
    <st c="2552">不遵循Flask的目录结构标准。</st> <st c="2613">所有视图模块都通过</st> `<st c="2641">app</st>`
    <st c="2644">实例通过</st> `<st c="2662">__main__</st>`<st c="2670">导入，这在测试期间成为</st>
    `<st c="2690">pytest</st>` <st c="2696">模块而不是</st> `<st c="2716">main.py</st>`
    <st c="2723">模块。</st> <st c="2747">因此，测试我们的</st> `<st c="2765">ch01</st>` <st
    c="2769">项目给我们以下运行时</st> `<st c="2809">错误信息</st>`:</br>
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="2876">The error means there is no</st> `<st c="2905">app</st>` <st c="2908">object
    to import in the</st> `<st c="2933">pytest</st>` <st c="2939">module.</st> <st
    c="2948">So, a testable and new version of the</st> *<st c="2986">Online Personal
    Counselling System</st>* <st c="3020">is in the</st> `<st c="3031">ch01-testing</st>`
    <st c="3043">project, which places all the view functions inside Python functions
    that the</st> `<st c="3122">main.py</st>` <st c="3129">module will access to pass
    the</st> `<st c="3161">app</st>` <st c="3164">instance.</st> <st c="3175">The
    following</st> `<st c="3189">main.py</st>` <st c="3196">snippet shows these function
    calls replacing the view’s</st> <st c="3253">import statements:</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2876">错误意味着在</st> `<st c="2905">app</st>` <st c="2908">对象中</st> `<st
    c="2933">pytest</st>` <st c="2939">模块</st> <st c="2948">中没有可导入的内容。</st> <st c="2948">因此，一个可测试的新版本</st>
    *<st c="2986">在线个人咨询服务</st>* <st c="3020">位于</st> `<st c="3031">ch01-testing</st>`
    <st c="3043">项目中，该项目将所有视图函数放在Python函数中，这些函数是</st> `<st c="3122">main.py</st>`
    <st c="3129">模块将访问以传递</st> `<st c="3161">app</st>` <st c="3164">实例。</st> <st c="3175">以下</st>
    `<st c="3189">main.py</st>` <st c="3196">代码片段显示了这些函数调用替换了视图的</st> `<st c="3253">import语句</st>`:</br>
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="3548">The view functions enclosed in each function will</st> <st c="3598">utilize
    the</st> `<st c="3611">app</st>` <st c="3614">instance to implement the</st> `<st
    c="3641">GET</st>` <st c="3644">and</st> `<st c="3649">POST</st>` <st c="3653">routes.</st>
    <st c="3662">Moreover, to</st> <st c="3674">provide a testing environment from
    Flask, set the</st> `<st c="3725">Testing</st>` <st c="3732">environment to</st>
    `<st c="3748">true</st>` <st c="3752">in the</st> <st c="3760">configuration file.</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3548">每个函数中封装的视图函数将</st> <st c="3598">使用</st> `<st c="3611">app</st>`
    <st c="3614">实例来实现</st> `<st c="3641">GET</st>` <st c="3644">和</st> `<st c="3649">POST</st>`
    <st c="3653">路由。</st> <st c="3662">此外，为了</st> <st c="3674">提供一个由Flask提供的测试环境，在配置文件中将</st>
    `<st c="3725">Testing</st>` <st c="3732">环境设置为</st> `<st c="3748">true</st>` <st
    c="3752">。</st>
- en: <st c="3779">Now, create a</st> `<st c="3794">tests</st>` <st c="3799">folder
    in the main folder of the accurately structured and circular-import-free Flask
    project directory adjacent to</st> `<st c="3916">main.py</st>`<st c="3923">. In
    this folder, implement the test cases in module files with filenames prefixed
    with the</st> `<st c="4015">test_</st>` <st c="4020">keyword.</st> <st c="4030">If
    the number of test cases increases, sub-folders can further organize these files
    according to functionality (e.g., views, repository, services, API, etc.) or type
    of testing (e.g., unit, integration).</st> *<st c="4234">Figure 10</st>**<st c="4243">.1</st>*
    <st c="4245">shows the final directory structure of the</st> `<st c="4289">ch01-testing</st>`
    <st c="4301">project with the</st> `<st c="4319">tests</st>` <st c="4324">folder.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3779">现在，在结构准确且无循环导入的Flask项目主文件夹中，紧邻</st> `<st c="3916">main.py</st>`<st
    c="3923">的位置创建一个</st> `<st c="3794">tests</st>` <st c="3799">文件夹。在这个文件夹中，使用以</st>
    `<st c="4015">test_</st>` <st c="4020">关键字为前缀的模块文件实现测试用例。</st> <st c="4030">如果测试用例的数量增加，可以通过功能（例如，视图、存储库、服务、API等）或测试类型（例如，单元、集成）进一步组织这些文件到子文件夹中。</st>
    *<st c="4234">图10</st>**<st c="4243">.1</st>* <st c="4245">显示了包含</st> `<st c="4289">ch01-testing</st>`
    <st c="4301">项目的最终目录结构，其中包含</st> `<st c="4319">tests</st>` <st c="4324">文件夹。</st>
- en: '![Figure 10.1 – The tests folder](img/B19383_10_001.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 测试文件夹](img/B19383_10_001.jpg)'
- en: <st c="4557">Figure 10.1 – The tests folder</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4557">图10.1 – 测试文件夹</st>
- en: <st c="4587">Now, run the</st> `<st c="4601">pytest</st>` <st c="4607">command
    as a module (</st>`<st c="4629">python -m pytest</st>`<st c="4646">) to execute
    all the test methods, and run each</st> <st c="4694">test file through the</st>
    <st c="4717">following command:</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4587">现在，以模块（</st>`<st c="4629">python -m pytest</st>`<st c="4646">）的形式运行</st>
    `<st c="4601">pytest</st>` <st c="4607">命令来执行所有测试方法，并使用以下命令运行每个</st> <st c="4694">测试文件：</st>
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="4778">Or, run an individual test function using the</st> <st c="4824">following
    command:</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4778">或者，使用以下命令运行单个测试函数：</st>
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="4900">Let us now explore</st> `<st c="4920">pytest</st>` <st c="4926">by
    creating</st> <st c="4938">test cases for</st> `<st c="4954">ch01-testing</st>`<st
    c="4966">’s model classes, repository transactions, native services, and</st>
    <st c="5031">view functions.</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4900">现在，让我们通过为</st> `<st c="4954">ch01-testing</st>`<st c="4966">的模型类、存储库事务、本地服务和</st>
    <st c="5031">视图函数创建测试用例来探索</st> `<st c="4920">pytest</st>` <st c="4926">。</st>
- en: <st c="5046">Testing the model classes</st>
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="5046">测试模型类</st>
- en: <st c="5072">One of the test files</st> <st c="5094">that showcases unit testing
    is</st> `<st c="5126">test_models.py</st>`<st c="5140">, which contains the</st>
    <st c="5161">following implementation:</st>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5072">展示单元测试的其中一个测试文件是</st> `<st c="5126">test_models.py</st>`<st c="5140">，它包含以下实现：</st>
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<st c="10970">from config.db import connect_db</st> def test_connection():
    <st c="11027">@connect_db</st> def create_connection(conn): <st c="11068">assert
    conn is not None</st> create_connection()'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="10970">from config.db import connect_db</st> def test_connection():
    <st c="11027">@connect_db</st> def create_connection(conn): <st c="11068">assert
    conn is not None</st> create_connection()'
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: import pytest
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest
- en: from repository.admin import insert_admin <st c="12144">@pytest.mark.parametrize(("id",
    "fname", "lname", "age", "position", "date_employed", "status"),</st> (("8999",
    "Juan", "Luna", 76, "Manager", "2010-10-10", "active"),
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: from repository.admin import insert_admin <st c="12144">@pytest.mark.parametrize(("id",
    "fname", "lname", "age", "position", "date_employed", "status"),</st> (("8999",
    "Juan", "Luna", 76, "Manager", "2010-10-10", "active"),
- en: ("9999", "Maria", "Clara", 45, "Developer", "2015-08-15", "inactive")
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ("9999", "Maria", "Clara", 45, "Developer", "2015-08-15", "inactive")
- en: ))
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ))
- en: 'def test_insert_admin(<st c="12402">id,</st> <st c="12406">fname, lname, age,
    position, date_employed, status</st>):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_insert_admin(<st c="12402">id,</st> <st c="12406">fname, lname, age,
    position, date_employed, status</st>):'
- en: result = insert_admin(<st c="12483">id, fname, lname, age, position, date_employed,
    status</st>)
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: result = insert_admin(<st c="12483">id, fname, lname, age, position, date_employed,
    status</st>)
- en: assert result is True
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: assert result is True
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: pip install pytest-mock
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: pip install pytest-mock
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: import pytest <st c="15172">from unittest.mock import patch</st> from repository.admin
    import insert_admin
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest <st c="15172">from unittest.mock import patch</st> from repository.admin
    import insert_admin
- en: '@pytest.mark.parametrize(("id", "fname", "lname", "age", "position", "date_employed",
    "status"),'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.mark.parametrize(("id", "fname", "lname", "age", "position", "date_employed",
    "status"),'
- en: (("8999", "Juan", "Luna", 76, "Manager", "2010-10-10", "active"),
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: (("8999", "Juan", "Luna", 76, "Manager", "2010-10-10", "active"),
- en: ("9999", "Maria", "Clara", 45, "Developer", "2015-08-15", "inactive")
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ("9999", "Maria", "Clara", 45, "Developer", "2015-08-15", "inactive")
- en: ')) <st c="15482">@patch("psycopg2.connect")</st> def test_mock_insert_admin(<st
    c="15536">mock_connect</st>, id, fname, lname, age, position, date_employed, status):
    <st c="15608">mocked_conn = mock_connect.return_value</st><st c="15647">mock_cur
    = mocked_conn.cursor.return_value</st> result = insert_admin(id, fname, lname,
    age, position, date_employed, status) <st c="15769">mock_cur.execute.assert_called_once()</st><st
    c="15806">mocked_conn.commit.assert_called_once()</st> assert result is True'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ')) <st c="15482">@patch("psycopg2.connect")</st> def test_mock_insert_admin(<st
    c="15536">mock_connect</st>, id, fname, lname, age, position, date_employed, status):
    <st c="15608">mocked_conn = mock_connect.return_value</st><st c="15647">mock_cur
    = mocked_conn.cursor.return_value</st> result = insert_admin(id, fname, lname,
    age, position, date_employed, status) <st c="15769">mock_cur.execute.assert_called_once()</st><st
    c="15806">mocked_conn.commit.assert_called_once()</st> assert result is True'
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<st c="17578">@patch("psycopg2.connect")</st> def test_mock_select_users(<st
    c="17633">mock_connect</st>):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="17578">@patch("psycopg2.connect")</st> def test_mock_select_users(<st
    c="17633">mock_connect</st>):'
- en: expected_rec = [(222, "sjctrags", "sjctrags", "2023-02-26"), ( 567, "owen",
    "owen", "2023-10-22")] <st c="17749">mocked_conn = mock_connect.return_value</st><st
    c="17788">mock_cur = mocked_conn.cursor.return_value</st><st c="17831">mock_cur.fetchall.return_value
    = expected_rec</st> result = select_all_user()
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: expected_rec = [(222, "sjctrags", "sjctrags", "2023-02-26"), ( 567, "owen",
    "owen", "2023-10-22")] <st c="17749">mocked_conn = mock_connect.return_value</st><st
    c="17788">mock_cur = mocked_conn.cursor.return_value</st><st c="17831">mock_cur.fetchall.return_value
    = expected_rec</st> result = select_all_user()
- en: assert result is expect_rec
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: assert result is expect_rec
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: import pytest
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest
- en: from services.patient_monitoring import record_patient_exam
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: from services.patient_monitoring import record_patient_exam
- en: '@pytest.fixture'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.fixture'
- en: 'def exam_details():'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 'def exam_details():'
- en: params = dict()
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: params = dict()
- en: params['pid'] = 1111
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: params['pid'] = 1111
- en: params['qid'] = 568
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: params['qid'] = 568
- en: params['score'] = 87
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: params['score'] = 87
- en: params['total'] = 100
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: params['total'] = 100
- en: yield params
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: yield params
- en: 'def test_record_patient_exam(exam_details):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_record_patient_exam(exam_details):'
- en: result = record_patient_exam(exam_details)
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: result = record_patient_exam(exam_details)
- en: assert result is True
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: assert result is True
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: import pytest
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest
- en: 'from main import app as flask_app <st c="19923">@pytest.fixture(autouse=True)</st>
    def client(): <st c="19967">with flask_app.test_client() as client:</st><st c="20006">yield
    client</st> def test_default_page(client): <st c="20113">test_default_page()</st>
    runs the root page using the <st c="20162">Client</st> instance and checks whether
    the rendered Jinja template contains the <st c="20238">"OPCS"</st> substring.
    <st c="20256">res.data</st> is always in bytes, so decoding it will give us the
    string equivalent:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 'from main import app as flask_app <st c="19923">@pytest.fixture(autouse=True)</st>
    def client(): <st c="19967">with flask_app.test_client() as client:</st><st c="20006">yield
    client</st> def test_default_page(client): <st c="20113">test_default_page()</st>
    runs the root page using the <st c="20162">Client</st> instance and checks whether
    the rendered Jinja template contains the <st c="20238">"OPCS"</st> substring.
    <st c="20256">res.data</st> is always in bytes, so decoding it will give us the
    string equivalent:'
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="20462">On the other hand,</st> `<st c="20482">test_home_page()</st>`
    <st c="20498">runs the</st> `<st c="20508">/home GET</st>` <st c="20517">route
    and verifies whether there is a</st> `<st c="20556">"Welcome"</st>` <st c="20565">word
    on its template page.</st> <st c="20593">Also, it checks whether the path of the
    rendered page is still the</st> `<st c="20660">/home</st>` <st c="20665">URL path:</st>
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="20462">On the other hand,</st> `<st c="20482">test_home_page()</st>`
    <st c="20498">runs the</st> `<st c="20508">/home GET</st>` <st c="20517">route
    and verifies whether there is a</st> `<st c="20556">"Welcome"</st>` <st c="20565">word
    on its template page.</st> <st c="20593">Also, it checks whether the path of the
    rendered page is still the</st> `<st c="20660">/home</st>` <st c="20665">URL path:</st>
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="20766">It is also ideal to verify the status code of the</st> `<st c="20817">client.get()</st>`<st
    c="20829">’s response.</st> <st c="20843">The given</st> `<st c="20853">test_exam_page()</st>`
    <st c="20869">checks</st> <st c="20877">whether running the</st> `<st c="20897">/exam/assign</st>`
    <st c="20909">URL will result in an HTTP Status</st> <st c="20944">Code 200.</st>
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="20766">验证</st> `<st c="20817">client.get()</st>`<st c="20829">响应的状态码也是理想的选择。</st>
    <st c="20843">给定的</st> `<st c="20853">test_exam_page()</st>` <st c="20869">检查</st>
    <st c="20877">运行</st> `<st c="20897">/exam/assign</st>` <st c="20909">URL是否会返回HTTP状态</st>
    `<st c="20944">Code 200。</st>`
- en: <st c="20953">On the other hand, the</st> `<st c="20977">Client</st>` <st c="20983">instance
    has a</st> `<st c="20999">post()</st>` <st c="21005">method to test and run</st>
    `<st c="21029">POST</st>` <st c="21033">routes.</st> <st c="21042">The following
    implementation shows how to simulate</st> <st c="21093">form-handling transactions:</st>
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="20953">另一方面，</st> `<st c="20977">Client</st>` <st c="20983">实例有一个</st>
    `<st c="20999">post()</st>` <st c="21005">方法来测试和运行</st> `<st c="21029">POST</st>`
    <st c="21033">路由。</st> <st c="21042">以下实现展示了如何模拟</st> `<st c="21093">表单处理事务：</st>
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="21556">Since form parameters are ideally in a hashtable format, fixtures
    must yield these form parameters with their corresponding values inside a dictionary
    collection, like in our</st> `<st c="21732">form_data()</st>` <st c="21743">fixture.</st>
    <st c="21753">Then, we pass this yielded form data to the data parameter of the</st>
    `<st c="21819">client.post()</st>` <st c="21832">method.</st> <st c="21841">Afterward,
    we perform the necessary assertions to verify the correctness of the view procedure
    and</st> <st c="21940">its response.</st>
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="21556">由于表单参数理想情况下是哈希表格式，因此固定值必须以字典集合的形式提供这些表单参数及其对应的值，就像在我们的</st> `<st
    c="21732">form_data()</st>` <st c="21743">固定值。</st> <st c="21753">然后，我们将生成的表单数据传递给</st>
    `<st c="21819">client.post()</st>` <st c="21832">方法的data参数。</st> <st c="21841">之后，我们执行必要的断言以验证视图过程及其响应的正确性。</st>
- en: <st c="21953">Aside from checking the</st> <st c="21977">rendered URL path,
    content, and status code of a</st> `<st c="22027">GET</st>` <st c="22030">route,
    it is also feasible to test redirections in a view using</st> `<st c="22095">pytest</st>`<st
    c="22101">. The following implementation showcases how to test whether a</st>
    `<st c="22164">POST</st>` <st c="22168">transaction redirected a user to another</st>
    <st c="22210">view page:</st>
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="21953">除了检查</st> <st c="21977">渲染的URL路径、内容和状态码之外，还可以使用</st> `<st c="22095">pytest</st>`<st
    c="22101">来测试视图中的重定向。以下实现展示了如何测试一个</st> `<st c="22164">POST</st>` <st c="22168">事务是否将用户重定向到另一个</st>
    <st c="22210">视图页面：</st>
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'def test_assign_exam_redirect_302(client, form_data):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 'def 测试分配考试重定向_302(client, form_data):'
- en: res = client.post('/exam/assign', data=form_data) <st c="23622">302</st> because
    there is no <st c="23646">follow_redirects</st> parameter set in <st c="23680">client.post()</st>.
    Also, <st c="23701">res.location</st> is the appropriate attribute to extract
    the URL path because <st c="23775">res.request.path</st> will give the URL path
    of the <st c="23822">POST</st> transaction instead.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: res = client.post('/exam/assign', data=form_data) <st c="23622">302</st> 因为在</st>
    `<st c="23680">client.post()</st>`中没有设置</st> `<st c="23646">follow_redirects</st>`参数。此外，<st
    c="23701">res.location</st>是提取URL路径的适当属性，因为<st c="23775">res.request.path</st>将给出</st>
    `<st c="23822">POST</st>`事务的URL路径。
- en: <st c="23847">Aside from asserting</st> `<st c="23869">status_code</st>`<st
    c="23880">, verifying the correctness of the redirection includes checking the
    correct redirected path and the content type.</st> <st c="23995">Mocking can also
    be an additional strategy to closely examine the internals of the</st> `<st c="24078">POST</st>`
    <st c="24082">transactions and their redirections if there are any.</st> **<st
    c="24137">Monkey patching</st>** <st c="24152">can help refine the view processes</st>
    <st c="24188">through testing.</st>
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="23847">除了断言</st> `<st c="23869">status_code</st>`<st c="23880">之外，验证重定向的正确性还包括检查正确的重定向路径和内容类型。</st>
    <st c="23995">如果存在，模拟也可以是检查</st> `<st c="24078">POST</st>` <st c="24082">事务及其重定向的额外策略。</st>
    **<st c="24137">猴子补丁</st>** <st c="24152">可以通过测试来帮助细化视图过程。</st>
- en: <st c="24204">Let’s now learn how to use monkey patching in testing</st> <st
    c="24259">view functions.</st>
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="24204">现在让我们学习如何在测试</st> `<st c="24259">视图函数</st>`中应用猴子补丁。</st>
- en: <st c="24274">Applying the monkey patching</st>
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="24274">应用猴子补丁</st>
- en: '`<st c="24325">pytest</st>` <st c="24331">feature that involves intercepting
    a function in a view transaction and replacing it with a custom-implemented mock
    function that returns our desired result.</st> <st c="24490">The mock function
    must</st> <st c="24513">have the same parameter list and return type as the original
    one.</st> <st c="24579">Otherwise, monkey patching will not work.</st> <st c="24621">The
    following is a test case for redirection that uses</st> <st c="24676">monkey patching:</st>'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="24325">pytest</st>` <st c="24331">功能涉及拦截视图事务中的函数并将其替换为自定义实现的模拟函数，该模拟函数返回我们期望的结果。</st>
    <st c="24490">模拟函数必须</st> <st c="24513">具有与原始函数相同的参数列表和返回类型。</st> <st c="24579">否则，猴子补丁将不会工作。</st>
    <st c="24621">以下是一个使用</st> <st c="24676">猴子补丁</st> <st c="24679">的重定向测试用例：</st>'
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`<st c="25192">monkeypatch</st>` <st c="25204">is an object injected into</st>
    <st c="25232">the fixture function.</st> <st c="25254">It can emit a variety of
    methods for faking attributes and functions of other objects in a package and
    modules.</st> <st c="25366">In the given example, the objective is to test the</st>
    `<st c="25417">/exam/assign</st>` <st c="25429">form transaction with a mocked</st>
    `<st c="25461">insert_question_details()</st>`<st c="25486">. Instead of using
    the</st> `<st c="25509">patch()</st>` <st c="25516">decorator, the</st> `<st c="25532">monkeypatch</st>`
    <st c="25543">object of the fixture replaces the original function with a dummy</st>
    `<st c="25610">insert_question_details()</st>` <st c="25635">using its</st> `<st
    c="25646">setattr()</st>` <st c="25655">method.</st> <st c="25664">The dummy method
    needs to return a</st> `<st c="25699">True</st>` <st c="25703">value because the
    test needs to examine the behavior of the view function whenever the</st> `<st
    c="25791">INSERT</st>` <st c="25797">transaction is successful.</st> <st c="25825">Now,
    to enable monkey patching, you must inject the fixture containing the</st> `<st
    c="25900">monkeypatch</st>` <st c="25911">objects into the test functions like
    a typical fixture that</st> <st c="25972">yields resources.</st>'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="25192">monkeypatch</st>` <st c="25204">是注入到</st> <st c="25232">固定函数中的对象。</st>
    <st c="25254">它可以发出各种方法来伪造包和模块中其他对象的属性和函数。</st> <st c="25366">在给定的示例中，目标是测试使用模拟的</st>
    `<st c="25417">/exam/assign</st>` <st c="25429">表单事务的</st> `<st c="25461">insert_question_details()</st>`<st
    c="25486">。而不是使用</st> `<st c="25509">patch()</st>` <st c="25516">装饰器，固定函数中的</st>
    `<st c="25532">monkeypatch</st>` <st c="25543">对象使用其</st> `<st c="25646">setattr()</st>`
    <st c="25655">方法替换原始函数，使用一个虚拟的</st> `<st c="25610">insert_question_details()</st>`
    <st c="25635">。虚拟方法需要返回一个</st> `<st c="25699">True</st>` <st c="25703">值，因为测试需要检查视图函数在</st>
    `<st c="25791">INSERT</st>` <st c="25797">事务成功时的行为。</st> <st c="25825">现在，为了启用猴子补丁，你必须像典型的固定函数那样将包含</st>
    `<st c="25900">monkeypatch</st>` <st c="25911">对象</st> <st c="25972">的固定函数注入到测试函数中，它提供资源。</st>'
- en: <st c="25989">Monkey patching does not replace the actual code of the mocked
    function.</st> <st c="26063">In the given</st> `<st c="26076">setattr()</st>`<st
    c="26085">, the</st> `<st c="26091">views.examination.insert_question_details</st>`
    <st c="26132">expression indicates the repository method in the</st> `<st c="26183">/exam/assign</st>`
    <st c="26195">route and not in its actual repository class.</st> <st c="26242">So,
    this is just replacing the state of the method call in the view function and not
    modifying the method’s</st> <st c="26350">actual implementation.</st>
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="25989">猴子补丁不会替换被模拟函数的实际代码。</st> <st c="26063">在给定的</st> `<st c="26076">setattr()</st>`<st
    c="26085">中，</st> `<st c="26091">views.examination.insert_question_details</st>`
    <st c="26132">表达式表示的是</st> `<st c="26183">/exam/assign</st>` <st c="26195">路由中的存储库方法，而不是其实际存储库类中的方法。</st>
    <st c="26242">因此，这只是在替换视图函数中方法调用的状态，而不是修改方法的</st> <st c="26350">实际实现。</st>
- en: <st c="26372">Testing the repository, service, and view layers requires integration
    testing with or without mocking and</st> `<st c="26479">parametrize()</st>` <st
    c="26492">markers to find all the bugs and inconsistencies in the algorithms.</st>
    <st c="26561">Regardless, it is easier to set up test classes and files in organized
    applications that utilize application factories and Blueprints because those projects
    do not need directory restructuring, such as the one imposed on the</st> `<st
    c="26786">ch01</st>` <st c="26790">application.</st>
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26372">测试存储库、服务和视图层需要与或无模拟以及</st> `<st c="26479">parametrize()</st>`
    <st c="26492">标记进行集成测试，以找到算法中的所有错误和不一致性。</st> <st c="26561">无论如何，在利用应用程序工厂和蓝图的组织化应用程序中设置测试类和文件更容易，因为这些项目不需要目录重构，例如对</st>
    `<st c="26786">ch01</st>` <st c="26790">应用程序施加的那种重构。</st>
- en: <st c="26803">Let us discuss now the benefit of using</st> `<st c="26844">create_app()</st>`
    <st c="26856">and Blueprints in testing</st> <st c="26883">Flask components.</st>
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们讨论一下在测试 Flask 组件时使用 `<st c="26844">create_app()</st>` `<st c="26856">和蓝图</st>`
    的好处。
- en: <st c="26900">Creating test cases for components in application factory and
    Blueprints</st>
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为应用工厂和蓝图中的组件创建测试用例
- en: <st c="26973">Application factory functions and Blueprints help solve circular
    import problems by managing the context loading and allowing the Flask</st> `<st
    c="27110">app</st>` <st c="27113">instance to be accessible across the application</st>
    <st c="27162">without tapping the</st> `<st c="27183">__main__</st>` <st c="27191">top-level
    module.</st> <st c="27210">Since every component and layer is in its proper place,
    it is easier to set up the</st> <st c="27293">testing environment.</st>
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用工厂函数和蓝图通过管理上下文加载，并允许Flask `<st c="27110">app</st>` `<st c="27113">实例</st>`
    在整个应用中可访问，从而帮助解决循环导入问题，无需调用 `<st c="27183">__main__</st>` `<st c="27191">顶层模块</st>`。由于每个组件和层都处于其适当的位置，因此设置测试环境变得更加容易。
- en: <st c="27313">Our applications in</st> *<st c="27334">Chapters 2</st>* <st c="27344">and</st>
    *<st c="27349">3</st>* <st c="27350">have essential Flask components that need
    testing, such as the repository transaction built by the SQLAlchemy, exceptions,
    and standard API functions.</st> <st c="27502">All these components are built
    by the</st> `<st c="27540">create_app()</st>` <st c="27552">factory</st> <st c="27561">and
    Blueprints.</st>
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在 *<st c="27334">第2章</st>* 和 *<st c="27349">第3章</st>* 的应用中拥有需要测试的基本 Flask
    组件，例如由 SQLAlchemy 构建的存储库事务、异常和标准 API 函数。所有这些组件都是由 `<st c="27540">create_app()</st>`
    `<st c="27552">工厂</st>` `<st c="27561">和蓝图</st>` 构建的。
- en: <st c="27576">Let us start formulating test cases for SQLAlchemy</st> <st c="27628">repository
    transactions.</st>
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们从为 SQLAlchemy 存储库事务制定测试用例开始。
- en: <st c="27652">Testing ORM transactions</st>
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试 ORM 事务
- en: <st c="27677">The</st> *<st c="27682">Online Shipping</st>* <st c="27697">app
    in</st> [*<st c="27705">Chapter 2</st>*](B19383_02.xhtml#_idTextAnchor047) <st
    c="27714">uses the standard SQLAlchemy ORM to implement the CRUD transactions.</st>
    <st c="27784">Integration</st> <st c="27795">testing can help test the repository
    layer of our application.</st> <st c="27859">Let us examine the following test
    case implementation that runs the</st> `<st c="27927">insert()</st>` <st c="27935">transaction</st>
    <st c="27948">of</st> `<st c="27951">ProductRepository</st>`<st c="27968">:</st>
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 [*<st c="27705">第2章</st>*](B19383_02.xhtml#_idTextAnchor047) 中，*<st c="27682">在线发货</st>*
    `<st c="27697">应用</st>` 使用标准的 SQLAlchemy ORM 实现CRUD事务。集成测试可以帮助测试我们应用的存储库层。让我们检查以下测试用例实现，它运行了
    `<st c="27951">ProductRepository</st>` 的 `<st c="27927">insert()</st>` `<st c="27935">事务</st>`。
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`<st c="28722">test_mock_add_products()</st>` <st c="28747">focuses on examining
    the flow of the</st> `<st c="28785">INSERT</st>` <st c="28791">transaction in
    adding a new product line to the database.</st> <st c="28850">It mocks the</st>
    `<st c="28863">db_session</st>` <st c="28873">from SQLAlchemy’s</st> `<st c="28892">scoped_session</st>`
    <st c="28906">because the test is on the lines of codes and not with the</st>
    `<st c="28966">db_session</st>`<st c="28976">’s</st> `<st c="28980">add()</st>`
    <st c="28985">method.</st> `<st c="28994">assert_called_once()</st>` <st c="29014">of
    mocked</st> `<st c="29025">add()</st>` <st c="29030">and</st> `<st c="29035">commit()</st>`
    <st c="29043">will verify the execution of these methods during</st> <st c="29094">the
    test.</st>'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="28722">test_mock_add_products()</st>` `<st c="28747">关注于检查向数据库添加新产品线时`
    `<st c="28785">INSERT</st>` `<st c="28791">事务</st>` 的流程。</st> `<st c="28850">它模拟了
    SQLAlchemy 的 `<st c="28863">db_session</st>` `<st c="28873">from SQLAlchemy’s
    `<st c="28892">scoped_session</st>` `<st c="28906">，因为测试是在代码行上进行的，而不是与` `<st c="28966">db_session</st>`
    `<st c="28976">’s `<st c="28980">add()</st>` `<st c="28985">方法</st>` 进行。</st>
    `<st c="28994">assert_called_once()</st>` `<st c="29014">of mocked `<st c="29025">add()</st>`
    `<st c="29030">和` `<st c="29035">commit()</st>` `<st c="29043">将在测试期间验证这些方法的执行。</st>'
- en: <st c="29103">Now, the</st> `<st c="29113">ch02-blueprint</st>` <st c="29127">project</st>
    <st c="29136">uses the</st> `<st c="29145">before_request()</st>` <st c="29161">and</st>
    `<st c="29166">after_request()</st>` <st c="29181">events to track down the requests
    of every view and the user who accesses the views.</st> <st c="29267">These two
    application-level events become the core implementation of the application’s custom
    authentication mechanism.</st> <st c="29387">All view pages in the project happen
    to be secured.</st> <st c="29439">So, running and testing the</st> `<st c="29467">/ch02/products/add</st>`
    <st c="29485">view, for instance, without logging in as a valid user, will lead
    to a redirection to the login page, as verified by the following</st> <st c="29617">test
    case:</st>
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="29103">现在，</st> `<st c="29113">ch02-blueprint</st>` <st c="29127">项目</st>
    <st c="29136">使用</st> `<st c="29145">before_request()</st>` <st c="29161">和</st>
    `<st c="29166">after_request()</st>` <st c="29181">事件来追踪每个视图的请求以及访问视图的用户。</st>
    <st c="29267">这两个应用级事件成为应用程序自定义认证机制的核心实现。</st> <st c="29387">项目中的所有视图页面都恰好是受保护的。</st>
    <st c="29439">因此，运行和测试</st> `<st c="29467">/ch02/products/add</st>` <st c="29485">视图，例如，不作为有效用户登录，将导致重定向到登录页面，如下面的</st>
    `<st c="29617">测试用例</st>` <st c="29633">所示：</st>
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'def test_add_product_with_login(form_data, login_data, client): <st c="30246">res_login
    = client.post("/ch02/login/auth",</st> <st c="30289">data=login_data)</st><st
    c="30306">with client.session_transaction() as session:</st><st c="30352">assert
    ''admin'' == session["username"]</st> assert res_login.location.split(''?'')[0]
    == url_for(''home_bp.menu'')'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_add_product_with_login(form_data, login_data, client): <st c="30246">res_login
    = client.post("/ch02/login/auth",</st> <st c="30289">data=login_data)</st><st
    c="30306">with client.session_transaction() as session:</st><st c="30352">assert
    ''admin'' == session["username"]</st> assert res_login.location.split(''?'')[0]
    == url_for(''home_bp.menu'')'
- en: res = client.post("/ch02/products/add", data=form_data)
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: res = client.post("/ch02/products/add", data=form_data)
- en: assert res.status_code == 200
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: assert res.status_code == 200
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: import pytest
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest
- en: from mock import patch, MagicMock
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: from mock import patch, MagicMock
- en: from main import app as flask_app
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: from main import app as flask_app
- en: import json
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: import json
- en: '@pytest.fixture'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.fixture'
- en: 'def client():'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 'def client():'
- en: 'with flask_app.test_client() as client:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 'with flask_app.test_client() as client:'
- en: yield client
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: yield client
- en: 'def test_index(client): <st c="32209">res = client.get(''/index'')</st><st
    c="32235">data = json.loads(res.get_data(as_text=True))</st> assert data["message"]
    == "This is an Online Pizza Ordering System."'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_index(client): <st c="32209">res = client.get(''/index'')</st><st
    c="32235">data = json.loads(res.get_data(as_text=True))</st> assert data["message"]
    == "This is an Online Pizza Ordering System."'
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <st c="32831">@pytest.fixture</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32831">@pytest.fixture</st>
- en: '<st c="32847">def order_data():</st> order_details = {"date_ordered": "2020-12-10",
    "empid": "EMP-101" , "cid": "CUST-101", "oid": "ORD-910"} <st c="32971">yield
    order_details</st> order_details = None'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="32847">def order_data():</st> order_details = {"date_ordered": "2020-12-10",
    "empid": "EMP-101" , "cid": "CUST-101", "oid": "ORD-910"} <st c="32971">yield
    order_details</st> order_details = None'
- en: 'def test_add_order(client, <st c="33039">order_data</st>): <st c="33053">res
    = client.post("/order/add", json=order_data)</st> assert res.status_code == 201'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_add_order(client, <st c="33039">order_data</st>): <st c="33053">res
    = client.post("/order/add", json=order_data)</st> assert res.status_code == 201'
- en: assert res.content_type == 'application/json'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: assert res.content_type == 'application/json'
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'def test_delete_order(client): <st c="33768">res = client.delete("/order/delete/ORD-910")</st>
    assert res.status_code == 201'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_delete_order(client): <st c="33768">res = client.delete("/order/delete/ORD-910")</st>
    assert res.status_code == 201'
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: import pytest
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest
- en: from main import app as flask_app <st c="35077">from app.exceptions.db import
    DuplicateRecordException</st> @pytest.fixture
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: from main import app as flask_app <st c="35077">from app.exceptions.db import
    DuplicateRecordException</st> @pytest.fixture
- en: 'def client():'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 'def client():'
- en: 'with flask_app.test_client() as client:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 'with flask_app.test_client() as client:'
- en: yield client
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: yield client
- en: '@pytest.fixture'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.fixture'
- en: 'def employee_data():'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 'def employee_data():'
- en: 'order_details = {"empid": "EMP-101", "fname": "Sherwin John" , "mname": "Calleja",
    "lname": "Tragura", "age": 45 , "role": "clerk", "date_employed": "2011-08-11",
    "status": "active", "salary": 60000.99}'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'order_details = {"empid": "EMP-101", "fname": "Sherwin John" , "mname": "Calleja",
    "lname": "Tragura", "age": 45 , "role": "clerk", "date_employed": "2011-08-11",
    "status": "active", "salary": 60000.99}'
- en: yield order_details
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: yield order_details
- en: order_details = None
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: order_details = None
- en: 'def test_add_employee(client, employee_data): <st c="35542">with pytest.raises(DuplicateRecordException)
    as ex:</st> res = client.post(''/employee/add'', json=employee_data)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_add_employee(client, employee_data): <st c="35542">with pytest.raises(DuplicateRecordException)
    as ex:</st> res = client.post(''/employee/add'', json=employee_data)'
- en: assert res.status_code == 200
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: assert res.status_code == 200
- en: assert str(ex.value) == "insert employee record encountered a problem"
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: assert str(ex.value) == "insert employee record encountered a problem"
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<st c="36399">@pytest.mark.xfail(strict=True, raises=NoRecordException, reason=”No
    existing record.”)</st> def test_update_employee(client, employee_data): <st c="36537">res
    = client.patch(f''/employee/update/</st> <st c="36575">{employee_data["empid"]}'',
    json=employee_data)</st> assert res.status_code == 201'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="36399">@pytest.mark.xfail(strict=True, raises=NoRecordException, reason="No
    existing record.")</st> def test_update_employee(client, employee_data): <st c="36537">res
    = client.patch(f''/employee/update/</st> <st c="36575">{employee_data["empid"]}'',
    json=employee_data)</st> assert res.status_code == 201'
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: import pytest
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 导入pytest
- en: from main import app as flask_app
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: from main import app as flask_app
- en: '@pytest.fixture(scope="module", autouse=True)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.fixture(scope="module", autouse=True)'
- en: 'def client():'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 'def client():'
- en: 'with flask_app.test_client() as app:'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'with flask_app.test_client() as app:'
- en: yield app
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: yield app
- en: 'def test_add_vote_ws_client(client): <st c="38724">ch05-web</st> project has
    an <st c="38748">async</st> WebSocket client, the <st c="38776">add_vote_count_client()</st>
    view function. The given <st c="38825">test_add_vote_ws_client()</st> runs and
    tests the <st c="38870">HTTP GET</st> request transaction using <st c="38905">client.get()</st>.
    So, this is the same when running a standard view function using the test <st
    c="38993">Client</st> class and also with an asynchronous API endpoint function,
    as shown by the following test case implementation:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_add_vote_ws_client(client): <st c="38724">ch05-web</st>项目有一个<st c="38748">异步</st>
    WebSocket客户端，即<st c="38776">add_vote_count_client()</st>视图函数。给定的<st c="38825">test_add_vote_ws_client()</st>运行并测试了使用<st
    c="38870">client.get()</st>的<st c="38870">HTTP GET</st>请求事务。因此，当使用测试<st c="38993">Client</st>类运行标准视图函数，以及异步API端点函数时，情况相同，如下面的测试用例实现所示：'
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: <st c="39437">The</st> `<st c="39442">add_login()</st>` <st c="39453">API with
    the</st> `<st c="39467">/ch05/login/add</st>` <st c="39482">URL pattern is an</st>
    `<st c="39501">async</st>` <st c="39506">API endpoint function that adds new login
    details to the database.</st> `<st c="39574">test_add_login()</st>` <st c="39590">performs
    exception testing on the</st> <st c="39625">API to check whether adding existing
    records will throw an error.</st> <st c="39691">So, the</st> <st c="39698">process
    and formulation of the test cases are the same as testing their standard counterparts.</st>
    <st c="39794">But what if the transactions under testing are asynchronous such
    that test functions need to await to execute them?</st> <st c="39910">How can</st>
    `<st c="39918">pytest</st>` <st c="39924">directly call an async method?</st>
    <st c="39956">Let us take a look at testing asynchronous</st> <st c="39999">SQLAlchemy
    transactions.</st>
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="39437">The</st> `<st c="39442">add_login()</st>` <st c="39453">API with
    the</st> `<st c="39467">/ch05/login/add</st>` <st c="39482">URL pattern is an</st>
    `<st c="39501">async</st>` <st c="39506">API endpoint function that adds new login
    details to the database.</st> `<st c="39574">test_add_login()</st>` <st c="39590">performs
    exception testing on the</st> <st c="39625">API to check whether adding existing
    records will throw an error.</st> <st c="39691">So, the</st> <st c="39698">process
    and formulation of the test cases are the same as testing their standard counterparts.</st>
    <st c="39794">But what if the transactions under testing are asynchronous such
    that test functions need to await to execute them?</st> <st c="39910">How can</st>
    `<st c="39918">pytest</st>` <st c="39924">directly call an async method?</st>
    <st c="39956">Let us take a look at testing asynchronous</st> <st c="39999">SQLAlchemy
    transactions.</st>
- en: <st c="40023">Testing the asynchronous repository layer</st>
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="40023">Testing the asynchronous repository layer</st>
- en: <st c="40065">The ORM used in</st> `<st c="40082">ch05-web</st>` <st c="40090">and</st>
    `<st c="40095">ch05-api</st>` <st c="40103">projects is the asynchronous SQLAlchemy.</st>
    <st c="40145">In an</st> `<st c="40151">async</st>` <st c="40156">ORM, all CRUD
    operations run as</st> <st c="40189">coroutines that need the</st> `<st c="40214">await</st>`
    <st c="40219">keyword to execute them.</st> <st c="40245">Likewise, test functions
    need to</st> `<st c="40278">await</st>` <st c="40283">these asynchronous components</st>
    <st c="40314">under test to execute them as coroutines.</st> <st c="40356">However,</st>
    `<st c="40365">pytest</st>` <st c="40371">requires an extension module called</st>
    `<st c="40408">pytest-asyncio</st>` <st c="40422">to add support for implementing
    asynchronous test functions.</st> <st c="40484">So, install the</st> `<st c="40500">pytest-asyncio</st>`
    <st c="40514">module using the following</st> `<st c="40542">pip</st>` <st c="40545">command
    before implementing the</st> <st c="40578">test case:</st>
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`ch05-web`和`ch05-api`项目中使用的ORM是异步SQLAlchemy。<st c="40145">在异步ORM中，所有CRUD操作都以</st>
    `<st c="40151">async</st>` <st c="40156">协程的形式运行，需要使用</st> `<st c="40189">await</st>`
    <st c="40214">关键字来执行。</st> <st c="40245">同样，测试函数需要</st> `<st c="40278">await</st>`
    <st c="40283">这些待测试的异步组件</st> <st c="40314">以协程的形式执行。</st> <st c="40356">然而，</st>
    `<st c="40365">pytest</st>` <st c="40371">需要名为</st> `<st c="40408">pytest-asyncio</st>`
    <st c="40422">的扩展模块来添加对实现异步测试函数的支持。</st> <st c="40484">因此，在实现测试用例之前，请使用以下</st>
    `<st c="40542">pip</st>` <st c="40545">命令安装</st> `<st c="40500">pytest-asyncio</st>`
    <st c="40514">模块：</st>
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <st c="40615">The implementation is the same as the previous ones except for
    the</st> `<st c="40683">pytest_plugins</st>` <st c="40697">component, which imports
    the necessary</st> `<st c="40737">pytest</st>` <st c="40743">extension, such as</st>
    `<st c="40763">pytest-asyncio</st>`<st c="40777">. The</st> `<st c="40783">pytest_plugins</st>`
    <st c="40797">component imports the installed</st> `<st c="40830">pytest</st>`
    <st c="40836">extensions and adds features to the testing</st> <st c="40881">environment
    that</st> `<st c="40898">pytest</st>` <st c="40904">alone cannot perform.</st>
    <st c="40927">With</st> `<st c="40932">pytest-asyncio</st>`<st c="40946">, testing</st>
    <st c="40955">transactions run by coroutines, like in the following snippet, is</st>
    <st c="41022">now feasible:</st>
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="40615">实现方式与之前的相同，只是</st> `<st c="40683">pytest_plugins</st>` <st c="40697">组件，它导入必要的</st>
    `<st c="40737">pytest</st>` <st c="40743">扩展，例如</st> `<st c="40763">pytest-asyncio</st>`<st
    c="40777">。`<st c="40783">pytest_plugins</st>` <st c="40797">组件导入已安装的</st> `<st
    c="40830">pytest</st>` <st c="40836">扩展，并为测试环境添加了`<st c="40881">pytest</st>` <st
    c="40898">本身无法执行的功能。</st> <st c="40927">使用`<st c="40932">pytest-asyncio</st>`<st
    c="40946">，现在可以实现对由协程运行的交易的测试，如下面的代码片段所示：</st> <st c="41022">现在可行：</st>
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: <st c="41579">Calling an asynchronous method for testing always requires a test
    function to be</st> `<st c="41661">async</st>` <st c="41666">because it needs
    to await the function under test.</st> <st c="41718">The given</st> `<st c="41728">test_add_login()</st>`
    <st c="41744">is an</st> `<st c="41751">async</st>` <st c="41756">method because
    it needs to call and await an asynchronous</st> `<st c="41815">insert_login()</st>`
    <st c="41829">transaction.</st> <st c="41843">However, for</st> `<st c="41856">pytest</st>`
    <st c="41862">to run an</st> `<st c="41873">async</st>` <st c="41878">test function,
    it will require the test functions to be</st> <st c="41935">decorated by</st>
    `<st c="41948">@pytest.mark.asyncio()</st>` <st c="41970">provided by the</st>
    `<st c="41987">pytest-asyncio</st>` <st c="42001">library.</st> <st c="42011">But</st>
    <st c="42015">what will be the case when Celery background tasks will</st> <st
    c="42071">undergo testing?</st>
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="41579">调用异步方法进行测试始终需要一个测试函数是</st> `<st c="41661">async</st>` <st c="41666">的，因为它需要等待被测试的函数。</st>
    <st c="41718">给定的</st> `<st c="41728">test_add_login()</st>` <st c="41744">是一个</st>
    `<st c="41751">async</st>` <st c="41756">方法，因为它需要调用和等待异步</st> `<st c="41815">insert_login()</st>`
    <st c="41829">事务。</st> <st c="41843">然而，对于</st> `<st c="41856">pytest</st>` <st
    c="41862">运行一个</st> `<st c="41873">async</st>` <st c="41878">测试函数，它将需要测试函数被</st>
    <st c="41935">装饰为</st> `<st c="41948">@pytest.mark.asyncio()</st>` <st c="41970">由`<st
    c="41987">pytest-asyncio</st>` <st c="42001">库提供的。</st> <st c="42011">但是，当Celery后台任务将</st>
    `<st c="42071">进行测试时</st>`，情况会怎样呢？
- en: <st c="42087">Testing Celery tasks</st>
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="42087">测试Celery任务</st>
- en: '`<st c="42108">Pytest</st>` <st c="42115">needs the</st> `<st c="42126">pytest-celery</st>`
    <st c="42139">extension module to run Celery tasks under testing.</st> <st c="42192">Thus,
    the test file needs to</st> <st c="42221">include</st> `<st c="42229">pytest_celery</st>`
    <st c="42242">in its</st> `<st c="42250">pytest_plugins</st>`<st c="42264">. The
    following test function</st> <st c="42293">runs the</st> `<st c="42303">add_vote_task_wrapper()</st>`
    <st c="42326">task to add a candidate’s votes to</st> <st c="42362">the database:</st>'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="42108">Pytest</st>` <st c="42115">需要</st> `<st c="42126">pytest-celery</st>`
    <st c="42139">扩展模块来在测试中运行 Celery 任务。</st> <st c="42192">因此，测试文件需要</st> <st c="42221">包含</st>
    `<st c="42229">pytest_celery</st>` <st c="42242">在其</st> `<st c="42250">pytest_plugins</st>`<st
    c="42264">. 以下测试函数</st> <st c="42293">运行</st> `<st c="42303">add_vote_task_wrapper()</st>`
    <st c="42326">任务，将候选人的投票添加到</st> <st c="42362">数据库：</st>'
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: import os
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: import os
- en: 'def test_upload_file(client):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 'def 测试上传文件(client):'
- en: test_file = os.getcwd() + "/tests/files/2011Q2.xlsx" <st c="45154">data = {</st>
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试文件 = os.getcwd() + "/tests/files/2011Q2.xlsx" <st c="45154">数据 = {</st>
- en: '<st c="45162">''data_file'': (open(test_file, ''rb''), test_file)</st>'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="45162">''数据文件'': (open(test_file, ''rb''), test_file)</st>'
- en: <st c="45210">}</st> response = client.post("/ch06/upload/xlsx/analysis", <st
    c="45266">buffered=True, content_type='multipart/form-data', data=data</st>)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45210">}</st> 响应 = client.post("/ch06/upload/xlsx/analysis", <st c="45266">buffered=True,
    content_type='multipart/form-data', data=data</st>)
- en: assert response.status_code == 200
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: assert 响应.status_code == 200
- en: assert response.mimetype == "text/html"
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: assert 响应.mimetype == "text/html"
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: import pytest
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest
- en: from flask import url_for
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: from flask import url_for
- en: from main import app as flask_app
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: from main import app as flask_app
- en: '@pytest.fixture'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.fixture'
- en: 'def client(): <st c="47352">flask_app.config["WTF_CSRF_ENABLED"] = False</st>
    with flask_app.test_client() as app:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 'def client(): <st c="47352">flask_app.config["WTF_CSRF_ENABLED"] = False</st>
    with flask_app.test_client() as app:'
- en: yield app
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: yield app
- en: '@pytest.fixture(scope="module")'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.fixture(scope="module")'
- en: 'def user_credentials():'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 'def 用户凭证():'
- en: params = dict()
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数 = dict()
- en: params["username"] = "sjctrags"
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数["用户名"] = "sjctrags"
- en: params["password"] = "sjctrags"
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数["密码"] = "sjctrags"
- en: return params
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return 参数
- en: 'def test_patient_profile_add_invalid_access(client): <st c="47647">res = client.get("/ch09/patient/profile/add",</st>
    <st c="47692">base_url=''https://localhost'')</st> assert res.status_code == 302
    <st c="47816">pytest</st> to access and run <st c="47841">/ch09/patient/profile/add</st>,
    which is a form view, you must first disable the CSRF protection of the <st c="47940">flask_wtf.csrf</st>
    module using its <st c="47972">WTF_CSRF_ENABLED</st> built-in environment variable
    before extracting the test <st c="48046">Client</st> instance in the <st c="48069">client()</st>
    fixture. Running the given test function with the correct user credentials will
    show a successful result since the access is unauthenticated, causing a redirection
    to the <st c="48249">/ch09/login/auth</st> view. So far, the application uses
    custom authentication but with a database-encrypted username managed by the <st
    c="48377">flask-session</st> extension module.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 'def 测试患者档案添加无效访问(client): <st c="47647">res = client.get("/ch09/patient/profile/add",</st>
    <st c="47692">base_url=''https://localhost'')</st> assert res.status_code == 302
    <st c="47816">pytest</st> 要访问和运行 <st c="47841">/ch09/patient/profile/add</st>，这是一个表单视图，您必须首先使用其
    <st c="47940">flask_wtf.csrf</st> 模块的 <st c="47972">WTF_CSRF_ENABLED</st> 内置环境变量禁用
    CSRF 保护，然后在 <st c="48069">client()</st> 修复件中提取测试 <st c="48046">Client</st> 实例之前。使用正确的用户凭证运行给定的测试函数将显示成功结果，因为访问未经身份验证，导致重定向到
    <st c="48249">/ch09/login/auth</st> 视图。到目前为止，应用程序使用自定义身份验证，但由 <st c="48377">flask-session</st>
    扩展模块管理的数据库加密用户名。'
- en: <st c="48408">This test proves that accessing any view from our</st> *<st c="48459">Online
    Vaccine Registration</st>* <st c="48486">application requires user authentication
    from its</st> `<st c="48537">/ch09/login/auth</st>` <st c="48553">view page.</st>
    <st c="48565">Any unauthenticated attempt to its</st> <st c="48600">view will
    redirect the user to the login page.</st> <st c="48647">The following snippet
    builds the proper access flow to our application’s views with</st> <st c="48731">user
    authentication:</st>
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="48408">此测试证明，访问我们</st> *<st c="48459">在线疫苗注册</st>* <st c="48486">应用程序的任何视图都需要从其</st>
    `<st c="48537">/ch09/login/auth</st>` <st c="48553">视图页面进行用户身份验证。</st> <st c="48565">任何未经身份验证的访问尝试都会将用户重定向到登录页面。</st>
    <st c="48647">以下片段使用用户身份验证构建了访问我们应用程序视图的正确访问流程：</st>
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: import pytest
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest
- en: from main import app as flask_app <st c="50399">import base64</st> @pytest.fixture
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: from main import app as flask_app <st c="50399">import base64</st> @pytest.fixture
- en: 'def client():'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 'def client():'
- en: 'with flask_app.test_client() as app:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'with flask_app.test_client() as app:'
- en: yield app
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: yield app
- en: '@pytest.fixture'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.fixture'
- en: 'def vaccine():'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 'def 疫苗():'
- en: 'vacc = {"vacid": "VAC-899", "vacname": "Narvas", "vacdesc": "For Hypertension",
    "qty": 5000, "price": 1200.5, "status": True}'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'vacc = {"vacid": "VAC-899", "vacname": "Narvas", "vacdesc": "For Hypertension",
    "qty": 5000, "price": 1200.5, "status": True}'
- en: return vacc
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return vacc
- en: 'def test_add_vaccine_unauth(client, vaccine):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_add_vaccine_unauth(client, vaccine):'
- en: 'res = client.post("/ch09/vaccine/add", json=vaccine, <st c="50758">headers={''Access-Control-Allow-Origin'':
    "http://localhost:5000"}</st>)'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'res = client.post("/ch09/vaccine/add", json=vaccine, <st c="50758">headers={''Access-Control-Allow-Origin'':
    "http://localhost:5000"}</st>)'
- en: assert res.status_code == 201
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: assert res.status_code == 201
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '@pytest.fixture <st c="51468">def auth_header():</st><st c="51486">credentials
    = base64.b64encode(b''sjctrags:sjctrags'') .decode(''utf-8'')</st> return credentials'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.fixture <st c="51468">def auth_header():</st><st c="51486">credentials
    = base64.b64encode(b''sjctrags:sjctrags'') .decode(''utf-8'')</st> return credentials'
- en: 'def test_add_vaccine_auth(client, vaccine, <st c="51619">auth_header</st>):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_add_vaccine_auth(client, vaccine, <st c="51619">auth_header</st>):'
- en: 'res = client.post("/vaccine/add", json=vaccine, <st c="51682">headers={''Authorization'':
    ''Basic '' + auth_header, ''Access-Control-Allow-Origin'': "http://localhost:5000"}</st>)'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'res = client.post("/vaccine/add", json=vaccine, <st c="51682">headers={''Authorization'':
    ''Basic '' + auth_header, ''Access-Control-Allow-Origin'': "http://localhost:5000"}</st>)'
- en: assert res.status_code == 201
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: assert res.status_code == 201
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: import pytest
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest
- en: from flask_login import current_user
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: from flask_login import current_user
- en: from main import app as flask_app
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: from main import app as flask_app
- en: 'def test_add_admin_profile(client, admin_details, user_credentials): <st c="53550">res_login
    = client.post(''/ch09/login/auth'',</st> <st c="53593">data=user_credentials)</st><st
    c="53616">assert res_login.status_code == 200</st><st c="53652">with client.session_transaction()
    as session:</st><st c="53698">assert current_user.username == "sjctrags"</st><st
    c="53741">res = client.post("/ch09/admin/profile/add", data=admin_details)</st>
    assert res.status_code == 200'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_add_admin_profile(client, admin_details, user_credentials): <st c="53550">res_login
    = client.post(''/ch09/login/auth'',</st> <st c="53593">data=user_credentials)</st><st
    c="53616">assert res_login.status_code == 200</st><st c="53652">with client.session_transaction()
    as session:</st><st c="53698">assert current_user.username == "sjctrags"</st><st
    c="53741">res = client.post("/ch09/admin/profile/add", data=admin_details)</st>
    assert res.status_code == 200'
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '@pytest.fixture'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.fixture'
- en: 'def client(): <st c="54734">flask_app.config["LOGIN_DISABLED"] = True</st>
    with flask_app.test_client() as app:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 'def client(): <st c="54734">flask_app.config["LOGIN_DISABLED"] = True</st>
    with flask_app.test_client() as app:'
- en: yield app
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: yield app
- en: 'def test_add_admin_profile(client, admin_details):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_add_admin_profile(client, admin_details):'
- en: res = client.post("/admin/profile/add", data=admin_details)
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: res = client.post("/admin/profile/add", data=admin_details)
- en: assert res.status_code == 200
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: assert res.status_code == 200
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: pip install mongomock
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: pip install mongomock
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: import pytest <st c="56693">import mongomock</st>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest <st c="56693">导入 mongomock</st>
- en: <st c="56709">from mongoengine import connect, get_connection, disconnect</st>
    from main import app as flask_app
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56709">从 mongoengine 导入 connect, get_connection, disconnect</st> from
    main 导入 app 作为 flask_app
- en: from modules.repository.mongo.tutor_login import TutorLoginRepository
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: from modules.repository.mongo.tutor_login import TutorLoginRepository
- en: from bcrypt import hashpw, gensalt
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: from bcrypt import hashpw, gensalt
- en: '@pytest.fixture'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.fixture'
- en: 'def login_details():'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 'def login_details():'
- en: login = dict()
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: login = dict()
- en: login["username"] = "sjctrags"
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: login["username"] = "sjctrags"
- en: login["password"] = "sjctrags"
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: login["password"] = "sjctrags"
- en: login["encpass"] = hashpw(str(login['username']) .encode(), gensalt())
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: login["encpass"] = hashpw(str(login['username']) .encode(), gensalt())
- en: return login
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return login
- en: '@pytest.fixture'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.fixture'
- en: 'def client():'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 'def client():'
- en: disconnect()
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: disconnect()
- en: 'with flask_app.test_client() as client:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 'with flask_app.test_client() as client:'
- en: yield client <st c="57203">@pytest.fixture</st>
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: yield client <st c="57203">@pytest.fixture</st>
- en: <st c="57218">def connect_db():</st><st c="57236">connect</st>(host='localhost',
    port=27017, db='tfs_test', uuidRepresentation='standard', <st c="57322">mongo_client_class=mongomock.MongoClient</st>)
    <st c="57365">conn = get_connection()</st> return conn
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="57218">def connect_db():</st><st c="57236">connect</st>(host='localhost',
    port=27017, db='tfs_test', uuidRepresentation='standard', <st c="57322">mongo_client_class=mongomock.MongoClient</st>)
    <st c="57365">conn = get_connection()</st> return conn
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'def test_add_login(client, <st c="58378">connect_db</st>, login_details):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test_add_login(client, <st c="58378">connect_db</st>, login_details):'
- en: repo = TutorLoginRepository()
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: repo = TutorLoginRepository()
- en: res = repo.insert_login(login_details)
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: res = repo.insert_login(login_details)
- en: assert res is True
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: assert res is True
- en: '[PRE37]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: pip install websockets
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: pip install websockets
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Pip install pytest-asyncio
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Pip install pytest-asyncio
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: <st c="59791">import websockets</st> import pytest
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59791">导入 websockets</st> import pytest
- en: import json <st c="59836">import pytest_asyncio</st>
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: import json <st c="59836">import pytest_asyncio</st>
- en: <st c="59857">pytest_plugins = ('pytest_asyncio',)</st>
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59857">pytest_plugins = ('pytest_asyncio',)</st>
- en: '<st c="59894">async</st> def simulated_add_votecount_view(<st c="59934">websocket</st>):
    <st c="59948">async for message in websocket:</st> print("received: ",message)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="59894">异步</st> def simulated_add_votecount_view(<st c="59934">websocket</st>):
    <st c="59948">异步</st> for message in websocket: print("received: ",message)'
- en: Place here the VoteCount repo transactions <st c="60087">simulated_add_votecount_view()</st>
    will serve as the mocked WebSocket endpoint function, which receives and saves
    the tallied votes into the database.
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在此处放置VoteCount仓库事务 <st c="60087">simulated_add_votecount_view()</st>将作为模拟WebSocket端点函数，该函数接收并将计票结果保存到数据库中。
- en: <st c="60234">Next, create a mock server using the</st> `<st c="60272">websockets.serve()</st>`
    <st c="60290">method to run the simulated route</st> <st c="60324">in an</st>
    `<st c="60361">host</st>`<st c="60365">,</st> `<st c="60367">port</st>`<st c="60371">,
    and the simulated view name, such as</st> `<st c="60410">simulated_add_votecount_view</st>`<st
    c="60438">, to operate.</st> <st c="60452">The following is our WebSocket server,
    which</st> <st c="60497">will run at the</st> `<st c="60513">ws://localhost:5001</st>`
    <st c="60532">address:</st>
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="60234">接下来，使用</st> `<st c="60272">websockets.serve()</st>` <st c="60290">方法创建一个模拟服务器来运行模拟路由</st>
    <st c="60324">在</st> `<st c="60361">主机</st>`<st c="60365">,</st> `<st c="60367">端口</st>`<st
    c="60371">，以及模拟视图名称，例如</st> `<st c="60410">simulated_add_votecount_view</st>`<st
    c="60438">，进行操作。</st> <st c="60452">以下是我们WebSocket服务器，它</st> <st c="60497">将在</st>
    `<st c="60513">ws://localhost:5001</st>` <st c="60532">地址上运行：</st>
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: <st c="60698">Since</st> `<st c="60705">create_ws_server()</st>` <st c="60723">must
    be</st> `<st c="60732">async</st>`<st c="60737">, decorating it with</st> `<st
    c="60758">@pytest.fixture</st>` <st c="60773">will cause an error.</st> <st c="60795">So,
    use</st> `<st c="60803">@pytest_asyncio.fixture</st>` <st c="60826">to declare
    the asynchronous fixtures</st> <st c="60864">for</st> `<st c="60868">pytest</st>`<st
    c="60874">.</st>
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="60698">由于</st> `<st c="60705">create_ws_server()</st>` <st c="60723">必须是</st>
    `<st c="60732">异步</st>`<st c="60737">的，用</st> `<st c="60758">@pytest.fixture</st>`
    <st c="60773">装饰它将导致错误。</st> <st c="60795">因此，使用</st> `<st c="60803">@pytest_asyncio.fixture</st>`
    <st c="60826">来声明</st> `<st c="60864">pytest</st>`<st c="60874">的异步固定值。</st>
- en: <st c="60875">Finally, we start our test function implementation with the context
    manager that opens the</st> `<st c="60967">websockets</st>` <st c="60977">client
    object for WebSocket endpoint execution and closes it afterward.</st> <st c="61050">The
    following implementation shows a test function for the</st> `<st c="61109">add_vote_count_server()</st>`
    <st c="61132">WebSocket with the</st> `<st c="61152">ws://localhost:5001/ch05/vote/save/ws</st>`
    <st c="61189">URL address:</st>
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="60875">最后，我们使用上下文管理器开始测试函数的实现，该上下文管理器打开</st> `<st c="60967">websockets</st>`
    <st c="60977">客户端对象以执行WebSocket端点，并在之后关闭它。</st> <st c="61050">以下实现显示了一个针对</st>
    `<st c="61109">add_vote_count_server()</st>` <st c="61132">WebSocket的测试函数，该函数使用</st>
    `<st c="61152">ws://localhost:5001/ch05/vote/save/ws</st>` <st c="61189">URL地址：</st>
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: import pytest
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: import pytest
- en: import websockets
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: import websockets
- en: import json
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: import json
- en: pytest_plugins = ('pytest_asyncio',)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: pytest_plugins = ('pytest_asyncio',)
- en: '@pytest.fixture(scope="module", autouse=True)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.fixture(scope="module", autouse=True)'
- en: 'def vote_tally_details():'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 'def vote_tally_details():'
- en: 'tally = {"election_id":"1", "precinct": "111-C", "final_tally": "6000", "approved_date":
    "2024-10-10"}'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'tally = {"election_id":"1", "precinct": "111-C", "final_tally": "6000", "approved_date":
    "2024-10-10"}'
- en: yield tally
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: yield tally
- en: tally = None
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: tally = None
- en: '@pytest.mark.asyncio'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '@pytest.mark.asyncio'
- en: 'async def test_websocket_actual(vote_tally_details): <st c="62816">async with</st>
    <st c="62826">websockets.connect("ws://localhost:5001/ch05/ vote/save/ws") as
    websocket</st>:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 'async def test_websocket_actual(vote_tally_details): <st c="62816">异步</st>
    with <st c="62826">websockets.connect("ws://localhost:5001/ch05/ vote/save/ws")
    as websocket:</st>'
- en: await websocket.send(json.dumps( vote_tally_details))
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: await websocket.send(json.dumps( vote_tally_details))
- en: response = await websocket.recv()
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: response = await websocket.recv()
- en: assert response == "data not added"
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 断言响应等于"data not added"
- en: '[PRE42]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
