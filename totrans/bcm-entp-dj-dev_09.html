<html><head></head><body>
		<div><h1 id="_idParaDest-192"><em class="italic"><a id="_idTextAnchor214"/>Chapter 7</em>: Working with Messages, Email Notifications, and PDF Reports</h1>
			<p>In this chapter, we will work with the Django messages framework, email notifications and templates, and PDF documents. In order for us to know that emails are actually being sent from our system and that they are rendered correctly in different email clients, we will be using a free third-party service to capture all of our outgoing emails. By capturing all outgoing emails, we can prevent development and test emails from being sent to people who should not be seeing them yet. We will use HTML, CSS, and the Django template language to create email and PDF report templates. Both will use context data just like how we passed context into templates in <a href="B17243_04_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 4</em></a>, <em class="italic">URLs, Views, and Templates</em>. </p>
			<p>In this chapter, we will cover the following:</p>
			<ul>
				<li>Creating a test environment for capturing all emails sent by the app</li>
				<li>Using the Django messages framework to create flash messages and custom message levels</li>
				<li>Creating and sending HTML and/or plain text-formatted emails</li>
				<li>Creating template-based emails using HTML, CSS, and the Django template language</li>
				<li>Generating PDF documents using HTML, CSS, and the Django template language</li>
			</ul>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor215"/>Technical requirements</h1>
			<p>To work with the code in this chapter, the following tools will need to be installed on your local machine:</p>
			<ul>
				<li>Python version 3.9 – used as the underlying programming language for the project</li>
				<li>Django version 4.0 – used as the backend framework of the project</li>
				<li>pip package manager – used to manage third-party Python/Django packages</li>
			</ul>
			<p>We will continue to work with the solution created in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>. However, it is not necessary to use the Visual Studio IDE. The main project itself can be run using another IDE or run independently using a terminal or command-line window from within the project root folder, which is where the <code>manage.py</code> file resides. Whatever editor or IDE you are using, a virtual environment will also be needed to work with the Django project. Instructions for how to create a project and virtual environment can be found in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>. You will need a database to store the data contained in your project. PostgreSQL was chosen for the examples in the previous chapter; however, any database type that you choose for your project can be used to work with the examples in this chapter. </p>
			<p>We will not be using any data found in the <code>chapter_3</code> app data fixture but if that data is already loaded, don't worry! The exercises in this chapter will all use data that is obtained from forms that the user is interacting with and not data coming from within a database.</p>
			<p>All of the code created in this chapter can be found in the GitHub repository for this book: <a href="https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer">https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer</a>. The bulk of the code depicted in this chapter can be found in the <code>/becoming_a_django_entdev/becoming_a_django_entdev/chapter_7/</code> directory.</p>
			<p>Check out the following video to see the <em class="italic">Code in Action</em>: <a href="https://bit.ly/3OzpalD">https://bit.ly/3OzpalD</a>.</p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor216"/>Preparing for this chapter</h1>
			<p>Start by creating a new app in your project called <code>chapter_7</code> by following the steps discussed in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>, in the subsection titled <em class="italic">Creating a Django app</em>. As discussed in that section, don't forget to change the value of the <code>name =</code> variable for your app class found in the <code>/becoming_a_django_entdev/becoming_a_django_entdev/chapter_7/apps.py</code> file to now point to the path where you installed your app. Be sure to also include this app in the <code>INSTALLED_APPS</code> variable found in the <code>settings.py</code> file as well.</p>
			<p>In the main <code>urls.py</code> file of the site, add the following path, which points to the URL patterns of the app that we will be creating in this chapter:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/urls.py</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">urlpatterns = [</pre>
			<pre class="source-code">    <strong class="bold">path(</strong></pre>
			<pre class="source-code">        <strong class="bold">'', </strong></pre>
			<pre class="source-code">        <strong class="bold">include('becoming_a_django_entdev.chapter_7.urls')</strong></pre>
			<pre class="source-code">    <strong class="bold">)</strong>,</pre>
			<pre class="source-code">]</pre>
			<p>Copy the URL patterns, forms, fields, views, templates, CSS, and JavaScript files found in the <code>chapter_5</code> app directly into the newly created <code>chapter_7</code> app. This way, we can keep the exercises of each chapter separated, and the exercises of this chapter will build on the exercises of <a href="B17243_05_ePub.xhtml#_idTextAnchor152"><em class="italic">Chapter 5</em></a>, <em class="italic">Django Forms</em>. In the code that you copied into this chapter's app, make sure you update all file/code references from <code>chapter_5</code>/<code>chapter-5</code> to <code>chapter_7</code>/<code>chapter-7</code> where needed.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor217"/>Creating a Mailtrap account</h2>
			<p>In order to <a id="_idIndexMarker942"/>work with the email examples throughout this chapter, you will need an email testing service that will capture all emails being sent from the system being built, as we run the project locally. There are numerous different third-party services on the market today that all provide this solution. Each service varies in terms of the additional testing tools and features that they provide as well as the cost associated with that service. You are welcome to use a service other than the one chosen for this book. If you choose to do so, you will have to follow the instructions from that service in order to configure the settings for your project instead of the instructions found in this section.</p>
			<p>For the purpose of demonstrating the exercises throughout this chapter, we will be using a completely free service called <strong class="bold">Mailtrap</strong>. No credit card is required to create an account with them and it's free for personal side projects. This is not a trial-based plan; it is free for a lifetime, or at least until Mailtrap changes its policies and procedures. Mailtrap also offers upgraded paid plans, which provide additional tools and support should you and your team decide to use this service, which would be particularly useful in multiple development environments and with large testing teams.</p>
			<p>Follow these steps to <a id="_idIndexMarker943"/>create and set up your Mailtrap account: </p>
			<ol>
				<li>Visit <a href="https://mailtrap.io/register/signup">https://mailtrap.io/register/signup</a> to <a id="_idIndexMarker944"/>create a new account. Follow the steps that they provide on their website. </li>
				<li>To activate your account, you will need to go back to your email inbox and click the <code>Junk</code> folder if you do not see it in your inbox. </li>
				<li>Once that is complete, log into your new account and you will be taken to <strong class="bold">My Inbox</strong>, with the first tab, <strong class="bold">SMTP Settings</strong>, selected. </li>
				<li>Under the <code>settings.py</code> file of your project, as shown:</li>
			</ol>
			<div><div><img src="img/Figure_7.01_B17243.jpg" alt="Figure 7.1 – Mailtrap – SMTP Settings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Mailtrap – SMTP Settings</p>
			<p>Add these variables, along with the credentials that were provided in your account, anywhere inside your <code>settings.py</code> file. </p>
			<ol>
				<li value="5">This step is optional. To <a id="_idIndexMarker945"/>separate these variables in a production environment, use the following conditional statement in your <code>settings.py</code> file. The values of each variable are also being kept within the <code>.env</code> file of a project:<pre><strong class="bold"># /becoming_a_django_entdev/settings.py</strong>
...
<strong class="bold">if DEBUG:</strong>
    EMAIL_HOST = os.getenv('EMAIL_HOST')
    EMAIL_HOST_USER = os.getenv('EMAIL_HOST_USER')
    EMAIL_HOST_PASSWORD = os.getenv('EMAIL_HOST_PASSWORD')
    EMAIL_PORT = os.getenv('EMAIL_PORT')
else:
    # Production Email Connection Settings
    Pass</pre></li>
			</ol>
			<p>Make sure to add the variables to your local <code>.env</code> file before running your project when using the preceding example.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In order for Mailtrap to work with your project on Heroku, make sure you add the four email variables from your local <code>.env</code> file to the config variables of each Heroku app. For instructions on how to do this, refer to <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>, under the subsection titled <em class="italic">Remote variables</em>. You can use the same connection settings for each environment and they will all go to the same inbox.</p>
			<p>That's it. Mailtrap is <a id="_idIndexMarker946"/>now configured and will intercept all emails being sent from your Django project. Let's move on to creating flash messages with the Django messages framework next.</p>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor218"/>Using the Django messages framework</h1>
			<p>Let's begin by<a id="_idIndexMarker947"/> introducing the <strong class="bold">Django Messages Framework</strong>, which is a framework used to provide session-based messages to the user. A <strong class="bold">flash message</strong> is a<a id="_idIndexMarker948"/> one-time notification message displayed directly to the user and is the kind of message that this framework creates. What we can do with this is render messages to the user anywhere we put the code inside our templates, whether that be in a modal popup or a message that drops down from the top of the page or comes up from the bottom of the page. It can even appear above or below a form that the user is submitting. </p>
			<p>The <code>chapter_7</code> <code>FormClassView</code> class will be the primary working class throughout this chapter, as it will be used primarily to trigger the actions we will be writing. We will be writing the methods to perform those actions in the corresponding <code>ContactForm</code> class used by that <code>FormClassView</code> class of the <code>chapter_7</code> app. </p>
			<p>Before we start writing those classes, we will begin by enabling the Django messages framework next.</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor219"/>Enabling the Django messages framework</h2>
			<p>These settings<a id="_idIndexMarker949"/> will enable the Django messages framework. A project does not require this framework to operate. These settings can be removed if desired but are required to work with this chapter. It is likely that when you created your project, these settings were generated for you automatically. Double-check just to make sure.</p>
			<p>In your <code>settings.py</code> file, make sure these settings and values exist:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">INSTALLED_APPS = [</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    <strong class="bold">'django.contrib.sessions'</strong>,</pre>
			<pre class="source-code">    <strong class="bold">'django.contrib.messages'</strong>,</pre>
			<pre class="source-code">]</pre>
			<pre class="source-code">MIDDLEWARE = [</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    <strong class="bold">'django.contrib.sessions.middleware.SessionMiddleware'</strong>,</pre>
			<pre class="source-code">    <strong class="bold">'django.contrib.messages.middleware.MessageMiddleware'</strong>,</pre>
			<pre class="source-code">]</pre>
			<pre class="source-code">TEMPLATES = [</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        'OPTIONS': {</pre>
			<pre class="source-code">            'context_processors': [</pre>
			<pre class="source-code">                ...</pre>
			<pre class="source-code">                <strong class="bold">'django.contrib.messages.context_processors.messages'</strong>,</pre>
			<pre class="source-code">            ],</pre>
			<pre class="source-code">        },</pre>
			<pre class="source-code">    },</pre>
			<pre class="source-code">]</pre>
			<p>One important thing to remember in the preceding settings is that <code>SessionMiddleware</code> always comes before the <code>MessageMiddleware</code> entry in the <code>MIDDLEWARE</code> list. The same applies to the <code>INSTALLED_APPS</code> variable; make sure the <code>django.contrib.sessions</code> app comes before the <code>django.contrib.messages</code> app. The Django messages framework context processor shown under the <code>TEMPLATES</code> configuration is also needed to make your Django messages framework context available from within any of your templates. This means that you<a id="_idIndexMarker950"/> do not have to explicitly define a variable in the context of each page specifically for your messages. Instead, it will be available via the global context of your project automatically.</p>
			<p>Next, we will discuss additional configuring/enabling of the Django messages framework.</p>
			<h3>Message storage backends</h3>
			<p><code>MESSAGE_STORAGE</code> variable in the <code>settings.py</code> file.</p>
			<p>The backend choices available for <code>MESSAGE_STORAGE</code> are listed here:</p>
			<ul>
				<li><code>django.contrib.messages.storage.session.SessionStorage</code> – stores messages in the requests session and will require that the <code>django.contrib.sessions</code> app be included in the <code>INSTALLED_APPS</code> variable.</li>
				<li><code>django.contrib.messages.storage.fallback.FallbackStorage</code> – this option uses the now-legacy <code>CookieStorage</code> first and then, when cookie data exceeds the 2,048-byte threshold, instead of deleting those older cookies, as is the default action of the <code>CookieStorage</code> option, new messages will instead be placed in <code>SessionStorage</code>. <code>CookieStorage</code> is no longer supported in Django 4.0 but is still available in the <code>django.contrib.messages.storage</code> library. It is unknown when this storage method will be removed completely.</li>
				<li><code>django.contrib.messages.storage.base.BaseStorage</code> – Django provides this class as a way for developers to create their own storage systems. By itself, this will not work because this is an abstract class meant to be extended. This is considered an advanced topic beyond the scope of this book.</li>
			</ul>
			<p>Let's go ahead and set this<a id="_idIndexMarker952"/> to use the <code>SessionStorage</code> option for now:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">MESSAGE_STORAGE = '<strong class="bold">django.contrib.messages.storage.session.SessionStorage</strong>'</pre>
			<h3>Message levels</h3>
			<p><strong class="bold">Message levels</strong> indicate<a id="_idIndexMarker953"/> the different severity levels of a message. These levels have a variable name, a lowercase tag name, and a numeric value indicating the severity level, as shown in the following table: </p>
			<div><div><img src="img/Table.jpg" alt=""/>
				</div>
			</div>
			<p>By default, Django sets the <code>MESSAGE_LEVEL</code> variable to <code>INFO</code>; more specifically, Django sets this to a value of <code>20</code>. This means if we try to issue a <code>DEBUG</code>-related message, which has a value of <code>10</code>, it will never be rendered to the page. Some might think this is a bug in the Django framework; however, this is by intentional design. The reason is that in a production setting, we do not want those messages to appear anywhere to the user. Any custom message levels with a value below <code>20</code> would also not appear. Instead, we only want developers, and maybe the testers, to see that message in a development or local environment. </p>
			<p>To enable <code>DEBUG</code>-related <a id="_idIndexMarker954"/>messages in your environment, the best way to do this is by once again utilizing the debug conditional in your <code>settings.py</code> file, as shown:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">from django.contrib.messages </pre>
			<pre class="source-code">import constants as <strong class="bold">messages</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">if DEBUG:</pre>
			<pre class="source-code">    <strong class="bold">MESSAGE_LEVEL = messages.DEBUG</strong></pre>
			<pre class="source-code">else:</pre>
			<pre class="source-code">    pass</pre>
			<p>Here, we are explicitly defining the <code>MESSAGE_LEVEL</code> setting to include <code>DEBUG</code>-related messages while the project's <code>DEBUG</code> variable is set to <code>True</code>. If <code>DEBUG</code> is set to <code>False</code>, as is done in the <code>.env</code> file of the production environment, then it will use the default Django setting of <code>messages.INFO</code> for this variable. We could just leave the <code>else</code> condition out of the equation <a id="_idIndexMarker955"/>altogether; however, it was written as a placeholder for illustrative purposes.</p>
			<h3>Message tags</h3>
			<p><code>/becoming_a_django_entdev/chapter_7/static/chapter_7/css/site.css</code> file provided with the code of this book, there are CSS styles that do just that; they style each message level discussed in this chapter as a different color. Copy and paste these styles into your project to see the same colors depicted in these images within your browser.</p>
			<p>In this example, let's change the tag for the <code>INFO</code> message from the original <code>info</code> to <code>information</code>, using the following example:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">from django.contrib.messages </pre>
			<pre class="source-code">import constants as <strong class="bold">messages</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">MESSAGE_TAGS = {</pre>
			<pre class="source-code">    <strong class="bold">messages.INFO</strong>: <strong class="bold">'information'</strong>,</pre>
			<pre class="source-code">}</pre>
			<p>In the preceding <a id="_idIndexMarker957"/>code, the <code>DEBUG</code>, <code>SUCCESS</code>, <code>WARNING</code>, and <code>ERROR</code> message tags will all continue to use their default message tag values because we did not include them in this list.</p>
			<h3>Custom message levels</h3>
			<p><code>settings.py</code> file, go ahead and add three new variables with numeric values, as shown:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code"><strong class="bold">MINOR = 50</strong></pre>
			<pre class="source-code"><strong class="bold">MAJOR = 60</strong></pre>
			<pre class="source-code"><strong class="bold">CRITICAL = 70</strong></pre>
			<pre class="source-code">MESSAGE_TAGS = {</pre>
			<pre class="source-code">    messages.INFO: 'information',</pre>
			<pre class="source-code">    <strong class="bold">MINOR</strong>: <strong class="bold">'minor'</strong>,</pre>
			<pre class="source-code">    <strong class="bold">MAJOR</strong>: <strong class="bold">'major'</strong>,</pre>
			<pre class="source-code">    <strong class="bold">CRITICAL</strong>: <strong class="bold">'critical'</strong>,</pre>
			<pre class="source-code">}</pre>
			<p>Each new level is defined using those numeric values. They can be named anything that does not conflict with other settings variables. These values can be any number, such as <code>19</code> or <code>199</code>, though it is best not to use any of the default values, such as <code>10</code>, <code>20</code>, <code>25</code>, <code>30</code>, or <code>40</code> because these values are being used by other levels, We also added those variables to the <code>MESSAGE_TAGS</code> variable because when we have events that create a new message, it will also need a message tag to add a CSS class to when <a id="_idIndexMarker959"/>rendering the HTML.</p>
			<p>Now that the settings are configured for the Django messages framework, we can use that framework and create messages next.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor220"/>Creating a message</h2>
			<p>Creating messages <a id="_idIndexMarker960"/>is very simple. For this exercise, let's modify the <code>post()</code> method found in the <code>FormClassView</code> class that we duplicated into the <code>chapter_7</code> app. Here, we will be adding the code that will create the message when the form is submitted. Django provides two ways to write a message, one way using the provided <code>add_message()</code> method and another by explicitly adding that message to one of the five default message levels. </p>
			<p>The following steps demonstrate using both ways. Please use only one or the other:</p>
			<ol>
				<li value="1">In the <code>/chapter_7/views.py</code> file, add the <code>add_message()</code> statement and context highlighted in the following code block to the <code>FormClassView</code> class under the <code>if form.is_valid():</code> condition. Remember to comment out or delete the <code>return</code> statement found in this condition:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_7/views.py</strong>
...
from django.contrib 
import <strong class="bold">messages</strong>
from django.template.response 
import TemplateResponse
from django.views.generic.edit 
import FormView
class <strong class="bold">FormClassView</strong>(FormView):
    ...
    def <strong class="bold">post</strong>(self, request, *args, **kwargs):
        ...
        if form.is_valid():
            <strong class="bold">messages.add_message(</strong>
                request,
                messages.SUCCESS,
                'Your contact form submitted successfully'
            )
            <strong class="bold">context</strong> = {
                'title': 'FormClassView Page',
                'page_id': 'form-class-id',
                'page_class': 'form-class-page',
                'h1_tag': 'This is the FormClassView Page Using ContactForm',
                'form': form,
            }
    ...</pre></li>
				<li>Next, in the <code>/chapter_7/views.py</code> file, add the <code>add_message()</code> statement and context highlighted in the following code block to the <code>FormClassView</code> class under the <code>else:</code> condition. Remember to comment out or delete the <code>return</code> statement found in this condition and add the new <code>return</code><a id="_idIndexMarker961"/> statement shown here:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_7/views.py</strong>
...
class <strong class="bold">FormClassView</strong>(FormView):
    ...
    def <strong class="bold">post</strong>(self, request, *args, **kwargs):
        ...
        if form.is_valid():
            ...
        else:
            <strong class="bold">messages.add_message(</strong>
                request,
                messages.ERROR,
                'There was a problem submitting your contact form.&lt;br /&gt;Please review the highlighted fields below.'
            )
            <strong class="bold">context</strong> = {
                'title': 'FormClassView Page - Please Correct The Errors Below',
                'page_id': 'form-class-id',
                'page_class': 'form-class-page errors-found',
                'h1_tag': 'This is the FormClassView Page Using ContactForm&lt;br /&gt;&lt;small class="error-msg"&gt;Errors Found&lt;/small&gt;',
                'form': form,
            }
        return TemplateResponse(
            request,
            self.template_name,
            context
        )
    ...</pre></li>
				<li>This step is <a id="_idIndexMarker962"/>not required; it just shows an alternative way of writing and using the messages shown previously. Use the <code>Success</code> and <code>Error</code> level statements highlighted in the following code block as alternatives to the ones shown previously. Use only one or the other:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_7/views.py</strong>
...
class <strong class="bold">FormClassView</strong>(FormView):
    ...
    def <strong class="bold">post</strong>(self, request, *args, **kwargs):
        ...
        if form.is_valid():
            <strong class="bold">messages.success(</strong>
                <strong class="bold">request,</strong>
                <strong class="bold">'Your contact form submitted successfully'</strong>
            <strong class="bold">)</strong>
            ...
        else:
            <strong class="bold">messages.error(</strong>
                <strong class="bold">request,</strong>
                <strong class="bold">'There was a problem submitting your contact form.&lt;br /&gt;Please review the highlighted fields below.'</strong>
            <strong class="bold">)</strong>
    ...</pre></li>
			</ol>
			<p>Using either of the <a id="_idIndexMarker963"/>add message examples will perform the same add message action, whereas using both at the same time will result in the same message being added twice to your storage system. In the <code>post()</code> method depicted previously, we commented out the old redirect statement and are now defining a success and failure message on form submission, using the same condition as before to check whether the form is valid. The message itself can accept a string and that string can contain HTML, as depicted in the preceding failure message. If HTML does exist in your string, the message would have to use the <code>|safe</code> filter when working with messages in a template.</p>
			<p>Next, let's go over the extra things we can do when creating a message.</p>
			<h3>Using a custom message level</h3>
			<p>If we want to <a id="_idIndexMarker964"/>use one of the custom message levels<a id="_idIndexMarker965"/> that we created, such as <code>CRITICAL</code>, then we can only use the <code>add_message()</code> method. We also need to import <code>settings</code> to access those variables, as depicted here:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_7/views.py</strong></pre>
			<pre class="source-code">from django.views.generic.edit </pre>
			<pre class="source-code">import FormView</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">from django.conf </pre>
			<pre class="source-code">import <strong class="bold">settings</strong></pre>
			<pre class="source-code">class <strong class="bold">FormClassView</strong>(FormView):</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    def <strong class="bold">post</strong>(self, request, *args, **kwargs):</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        if form.is_valid():</pre>
			<pre class="source-code">            <strong class="bold">messages.add_message(</strong></pre>
			<pre class="source-code">                <strong class="bold">request,</strong></pre>
			<pre class="source-code">                <strong class="bold">settings.CRITICAL,</strong></pre>
			<pre class="source-code">                <strong class="bold">'This is critical!'</strong></pre>
			<pre class="source-code">            <strong class="bold">)</strong></pre>
			<pre class="source-code">            ...</pre>
			<p>Messages<a id="_idIndexMarker966"/> are<a id="_idIndexMarker967"/> created in the same way, except <code>settings.LEVEL</code> is used instead of <code>messages.LEVEL</code>.</p>
			<h3>With extra tags</h3>
			<p>We can<a id="_idIndexMarker968"/> pass additional custom CSS classes for a message<a id="_idIndexMarker969"/> and that message only. This is done by adding that class(es) to the add message operation using the <code>extra_tags</code> attribute. For example, let's render our message with two classes, the <code>success</code> class, which gets added automatically, and an additional class called <code>bold</code> to then bolden the text that is rendered, using the following example:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_7/views.py</strong></pre>
			<pre class="source-code">from django.contrib </pre>
			<pre class="source-code">import messages</pre>
			<pre class="source-code">from django.views.generic.edit </pre>
			<pre class="source-code">import FormView</pre>
			<pre class="source-code">from django.conf </pre>
			<pre class="source-code">import <strong class="bold">settings</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">class <strong class="bold">FormClassView</strong>(FormView):</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    def <strong class="bold">post</strong>(self, request, *args, **kwargs):</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        if form.is_valid():</pre>
			<pre class="source-code">            messages.success(</pre>
			<pre class="source-code">                request,</pre>
			<pre class="source-code">                'Your contact form submitted successfully', </pre>
			<pre class="source-code">                <strong class="bold">extra_tags = 'bold'</strong></pre>
			<pre class="source-code">            )</pre>
			<pre class="source-code">            ...</pre>
			<p>After <a id="_idIndexMarker970"/>completing the section of this chapter titled <em class="italic">Displaying messages</em>, when we load the page and then inspect the message, what we<a id="_idIndexMarker971"/> should see rendered to the screen when inspecting that particular element is both the CSS classes <strong class="bold">bold</strong> and <strong class="bold">success</strong>, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_7.02_B17243.jpg" alt="Figure 7.2 – Django messages framework – extra_tags attribute&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Django messages framework – extra_tags attribute</p>
			<h3>That fails silently</h3>
			<p>Creating a <a id="_idIndexMarker972"/>message that <strong class="bold">fails silently</strong> simply means creating a reusable app using the Django messages framework that does not require other developers using your app in a different project to actually have the Django messages framework enabled within their project. This means if they have disabled this framework or just do not have it enabled yet, the add message operations will not prevent their project from functioning properly.</p>
			<p>To use this option, add the <code>fail_silently</code> attribute to your add message actions, as shown:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_7/views.py</strong></pre>
			<pre class="source-code">from django.contrib </pre>
			<pre class="source-code">import messages</pre>
			<pre class="source-code">from django.views.generic.edit </pre>
			<pre class="source-code">import FormView</pre>
			<pre class="source-code">from django.conf </pre>
			<pre class="source-code">import <strong class="bold">settings</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">class <strong class="bold">FormClassView</strong>(FormView):</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    def <strong class="bold">post</strong>(self, request, *args, **kwargs):</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        if form.is_valid():</pre>
			<pre class="source-code">            messages.success(</pre>
			<pre class="source-code">                request,</pre>
			<pre class="source-code">                'Your contact form submitted successfully', </pre>
			<pre class="source-code">                <strong class="bold">fail_silently=True</strong></pre>
			<pre class="source-code">            )</pre>
			<pre class="source-code">            ...</pre>
			<p>With the <code>fail_silently</code> attribute<a id="_idIndexMarker973"/> set to <code>True</code>, the application will run as normal, without errors that prevent the code from running. If the developer has disabled the Django messages framework and the <code>fail_silently</code> attribute is not included, then when running the application, that should trigger a flash message, where you will see a <strong class="bold">MessageFailure</strong> error, as shown:</p>
			<div><div><img src="img/Figure_7.03_B17243.jpg" alt="Figure 7.3 – Django messages framework – fail_silently attribute&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – Django messages framework – fail_silently attribute</p>
			<p>In the next section, we will render our messages into a template as HTML.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor221"/>Displaying messages</h2>
			<p>In order for messages <a id="_idIndexMarker974"/>to actually be seen by the user, we need to add some code to a Django template. Using the <code>/chapter_7/templates/chapter_7/form-class.html</code> file, which the <code>chapter_7</code> <code>FormClassView</code> class uses as its template, add the following code to the top of the HTML <code>&lt;form&gt;</code> object found inside that template:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_7/templates/chapter_7/form-class.html</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">{% block body_content %}</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    &lt;form method="post"&gt;</pre>
			<pre class="source-code">        {% csrf_token %}</pre>
			<pre class="source-code">        <strong class="bold">{% if messages %}</strong></pre>
			<pre class="source-code">            &lt;ul class="messages"&gt;</pre>
			<pre class="source-code">                <strong class="bold">{% for message in messages %}</strong></pre>
			<pre class="source-code">                    &lt;li{% if message.tags %} class="<strong class="bold">{{ message.tags }}</strong>"{% endif %}&gt;</pre>
			<pre class="source-code">                        <strong class="bold">{{ message|safe }}</strong></pre>
			<pre class="source-code">                    &lt;/li&gt;</pre>
			<pre class="source-code">                {% endfor %}</pre>
			<pre class="source-code">            &lt;/ul&gt;</pre>
			<pre class="source-code">        {% endif %}</pre>
			<pre class="source-code">        ...</pre>
			<p>All other code in this file <a id="_idIndexMarker975"/>can be left as is. Here, we use a simple conditional statement checking whether any messages exist in the storage system for this request. If they do, a <code>&lt;ul&gt;</code> list is created and then iterated through every message that exists, creating each one as a separate <code>&lt;li&gt;</code> item within that list. The message itself is using the <code>|safe</code> filter, allowing it to render HTML that can exist in the message string.</p>
			<p>Visit the URL <code>http://www.localhost:8000/chapter-7/form-class/</code> and submit the form. Either the valid or invalid message will display, depending on whether or not you actually triggered a validation error with that form, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_7.04_B17243.jpg" alt="Figure 7.4 – Django messages framework – displaying messages&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – Django messages framework – displaying messages</p>
			<p>The preceding message is displayed within the browser in green, if you are using the CSS classes provided by <a id="_idIndexMarker976"/>the book.</p>
			<p>Now that we have enabled the Django messages framework and added several messages to one of our view classes, let's practice sending an email notification instead of displaying a flash message next. </p>
			<h1 id="_idParaDest-200"><a id="_idTextAnchor222"/>Configuring email notifications</h1>
			<p>This section will help us to <a id="_idIndexMarker977"/>build actual email notifications instead of flash messages. We will write our logic to trigger the send email action in the same <code>FormClassView</code> class where we added messages inside the <code>post()</code> method. We will be utilizing the Mailtrap account that we created at the beginning of this chapter to capture all emails that are sent by our project. If you have not already done so, please create an account with Mailtrap and configure that connection in your <code>settings.py</code> file. Without doing so, you will have difficulty executing the code throughout this section.</p>
			<p>There are three MIME types that exist for emails, as follows:</p>
			<ul>
				<li><code>text/plain</code></li>
				<li><code>application/rtf</code></li>
				<li><code>text/html</code></li>
			</ul>
			<p>While there are three MIME types, only two are used by Django when sending emails: plain text and HTML. Rich text emails are treated as HTML emails because they contain HTML markup.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor223"/>As plain text emails</h2>
			<p>Plain text emails<a id="_idIndexMarker978"/> are just like they sound; they are just text and nothing else. We will be creating a method that prepares and then actually sends the email inside of the <code>ContactForm</code> class that we are using. The method that triggers the sending of an email can technically be placed in any class or any file. Follow these steps to create yours:</p>
			<ol>
				<li value="1">In the <code>ContactForm</code> class that was duplicated into the <code>/chapter_7/forms.py</code> file, add a new method called <code>send_email()</code> using the following code:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_7/forms.py</strong>
...
from django.core.mail 
import <strong class="bold">EmailMessage</strong>
...
class <strong class="bold">ContactForm</strong>(Form):
    ...
    def <strong class="bold">send_email</strong>(self, request):
        data = self.cleaned_data
        <strong class="bold">msg_body</strong> = <strong class="bold">'Hello World'</strong>
        email = <strong class="bold">EmailMessage</strong>(
            subject = 'New Contact Form Entry',
            body = <strong class="bold">msg_body</strong>,
            from_email = 'no-reply@example.com',
            reply_to = ['no-reply@example.com'],
            cc = [],
            bcc = [],
            to = [<strong class="bold">data['email_1']</strong>],
            attachments = [],
            headers = {<a id="_idTextAnchor224"/>},
        )
        <strong class="bold">email.content_subtype = 'plain'</strong>
        <strong class="bold">email.send()</strong></pre></li>
			</ol>
			<p>This method<a id="_idIndexMarker979"/> will handle all of the busy work involved in actually formatting and sending the email. Of course, this is a basic <code>text/plain</code> email consisting of only the phrase <code>msg_body</code> variable. The <code>email.content_subtype</code> statement is where we are telling Django that we want to format this email as a plain text email. We also imported and used the <code>EmailMessage</code> class from the <code>django.core.mail</code> library, used to structure the email and format headers pertaining to that email. Django also provides simpler method-based functions, such as <code>send_mail()</code> or <code>send_mass_mail()</code>, among a small handful of other methods. We will focus on just the <code>EmailMessage</code> class, as it will encompass every aspect of what we need to achieve in this chapter. To learn more about all of the email methods that Django provides, visit the official documentation, found here: <a href="https://docs.djangoproject.com/en/4.0/topics/email/">https://docs.djangoproject.com/en/4.0/topics/email/</a>. </p>
			<p>Because we are keeping this example extremely basic, we are only defining the <code>subject</code>, <code>body</code>, <code>from_email</code>, <code>reply_to</code>, and <code>to</code> attributes. Data is accessed by using <code>self.cleaned_data</code> and here we assign the value of the field named <code>email_1</code> to be the value of the <code>to</code> attributes list, as in the recipient's email address. If you are sending the email to multiple addresses, separate each email address with a comma in that list with no spaces.</p>
			<ol>
				<li value="2">In the <code>FormClassView</code> class found in the <code>/chapter_7/views.py</code> file, leave everything as is, relating to the sending of messages in that view class. To actually send the email, add the following line of code to the <code>post()</code> method, as depicted here:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_7/views.py</strong>
from django.template.response 
import TemplateResponse
...
class <strong class="bold">FormClassView</strong>(FormView):
    ...
    def <strong class="bold">post</strong>(self, request, *args, **kwargs):
        form = self.form_class(request.POST)
        ...
        <strong class="bold">form.send_email(request)</strong>
        return TemplateResponse(
            request,
            self.template_name,
            context
        )</pre></li>
			</ol>
			<p>Here, we are <a id="_idIndexMarker980"/>placing the send email operation just above the <code>return</code> statement and below the conditional statement that checks whether the form is valid. We are not separating the send operation for valid and invalid form submissions at this time.</p>
			<ol>
				<li value="3">Now, visit the URL <code>http://www.localhost:8000/chapter-7/form-class/</code>and submit the form, in either a valid or invalid state. The page should refresh without programming errors. You should now see your email in the inbox of your Mailtrap account, found at <a href="https://mailtrap.io/inboxes/">https://mailtrap.io/inboxes/</a>, as depicted in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_7.05_B17243.jpg" alt="Figure 7.5 – Mailtrap – plain text email&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – Mailtrap – plain text email</p>
			<p>You will <a id="_idIndexMarker981"/>also notice that the email is displayed under the <code>text/plain</code>.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor225"/>As HTML emails</h2>
			<p>Configuring an <a id="_idIndexMarker982"/>HTML or rich text email is fairly easy. Using the same example from the previous section, <em class="italic">As plain text emails</em>, all that is needed to convert to an HTML email is to change two lines of code. The first line of code is to change the <code>msg_body</code> variable to equal <code>'&lt;b&gt;Hello World&lt;/b&gt;'</code>. This way, we can actually pass in HTML to see whether it is working or not. The second is to change the value of <code>email.content_subtype</code> to equal <code>'html'</code>, and that's it! </p>
			<p>Now, visit the same URL, <code>http://www.localhost:8000/chapter-7/form-class/</code>, and submit the form. This time, when you visit your Mailtrap inbox at <a href="https://mailtrap.io/inboxes/">https://mailtrap.io/inboxes/</a>, you should see the <strong class="bold">Hello World</strong> text in bold, as depicted in the following screenshot:</p>
			<div><div><img src="img/Figure_7.06_B17243.jpg" alt="Figure 7.6 – Mailtrap – HTML email&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6 – Mailtrap – HTML email</p>
			<p>In the preceding screenshot, you will also see that the email is now displayed in the <code>text/html</code> MIME type with no text fallback provided, meaning only HTML is available for this email. Clicking on the <strong class="bold">Tech Info</strong> tab will reveal other detailed information about your email. In this tab, you can verify the actual content type. Check if the value of the Content-Type has a MIME type that equals <strong class="bold">text/html; charset=utf-8</strong>. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The value of <code>'html'</code> is used for both rich text- and HTML-formatted emails. They will both be sent as <code>text/html</code>. This is because we cannot explicitly tell Django to use <code>'application/rtf'</code> for rich text emails. Django just assumes rich text emails are HTML because they contain HTML markup.</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor226"/>As HTML emails with a plain text alternative</h2>
			<p>HTML emails that<a id="_idIndexMarker983"/> have plain text alternatives are used for email clients that have difficulty rendering the HTML-formatted version of the email or or if spam blockers only display text first. We need to use the Django-provided <code>EmailMultiAlternatives</code> class instead of the <code>EmailMessage</code> class to do this. <code>EmailMultiAlternatives</code> is an extension of the <code>EmailMessage</code> class, meaning that all of the methods and attributes available in the <code>EmailMessage</code> class are still available for us to use in this class, plus more. When using this class, what we do is format the email as <code>text/html</code> and then use the new <code>attach_alternative()</code> method available in the <code>EmailMultiAlternatives</code> class with that alternative email formatted as <code>text/plain</code>.</p>
			<p>Use the same code as in the <em class="italic">As HTML emails</em> subsection and make the following highlighted changes:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_7/forms.py</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">from django.core.mail </pre>
			<pre class="source-code">import (</pre>
			<pre class="source-code">    EmailMessage,</pre>
			<pre class="source-code">    <strong class="bold">EmailMultiAlternatives</strong></pre>
			<pre class="source-code">)</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">class <strong class="bold">ContactForm</strong>(Form):</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    def <strong class="bold">send_email</strong>(self, request):</pre>
			<pre class="source-code">        data = self.cleaned_data</pre>
			<pre class="source-code">        msg_body = '&lt;b&gt;Hello World&lt;/b&gt;'</pre>
			<pre class="source-code">        email = <strong class="bold">EmailMultiAlternatives</strong>(</pre>
			<pre class="source-code">            subject = 'New Contact Form Entry',</pre>
			<pre class="source-code">            body = msg_body,</pre>
			<pre class="source-code">            from_email = 'no-reply@example.com',</pre>
			<pre class="source-code">            reply_to = ['no-reply@example.com'],</pre>
			<pre class="source-code">            cc = [],</pre>
			<pre class="source-code">            bcc = [],</pre>
			<pre class="source-code">            to = [data['email_1']],</pre>
			<pre class="source-code">            attachments = [],</pre>
			<pre class="source-code">            headers = {},</pre>
			<pre class="source-code">        )</pre>
			<pre class="source-code">        email.content_subtype = 'html'</pre>
			<pre class="source-code">        <strong class="bold">email.attach_alternative(</strong></pre>
			<pre class="source-code">            <strong class="bold">'Hello World',</strong></pre>
			<pre class="source-code">            <strong class="bold">'text/plain'</strong></pre>
			<pre class="source-code">        <strong class="bold">)</strong></pre>
			<pre class="source-code">        email.send()</pre>
			<p>In the preceding example, we just replaced the <code>EmailMessage</code> class with the new <code>EmailMultiAlternatives</code> class. Then, we added the <code>email.attact_alternative()</code> action statement, which formats a brand-new email as <code>text/plain</code> using the text that we provided, <code>Hello World</code>, and attaches that new plain text-formatted email to the original HTML email. We do this instead of using the <code>attachment</code> attribute of the <code>EmailMessage</code> class because we are actually restructuring the content type of the email to now be a <code>multipart/alternative</code> MIME type instead of either the <code>text/html</code> or <code>text/plain</code> MIME types.</p>
			<p>That's it; you now have an email that is both HTML and plain text. Let's verify this. Visit the same URL, <code>http://www.localhost:8000/chapter-7/form-class/</code>, and submit the form. This time, when you visit your Mailtrap inbox at <a href="https://mailtrap.io/inboxes/">https://mailtrap.io/inboxes/</a>, you should see the <strong class="bold">Hello World</strong> text in bold and also see the <strong class="bold">Text</strong> tab is now highlighted and clickable, as shown:</p>
			<div><div><img src="img/Figure_7.07_B17243.jpg" alt="Figure 7.7 – Mailtrap – HTML and plain text email&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7 – Mailtrap – HTML and plain text email</p>
			<p>Clicking on the <strong class="bold">Text</strong> tab will show you the plain text format that is available. The primary format is HTML <a id="_idIndexMarker984"/>and the fallback will be plain text. The order of the content types can be reversed in this example. When we click on the <strong class="bold">Tech Info</strong> tab, we will now see that <strong class="bold">Content-Type</strong> is displaying <strong class="bold">multipart/alternative</strong>, as shown:</p>
			<div><div><img src="img/Figure_7.08_B17243.jpg" alt="Figure 7.8 – Mailtrap – multipart/alternative&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.8 – Mailtrap – multipart/alternative</p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor227"/>With file attachments</h2>
			<p>Sending an email with a<a id="_idIndexMarker985"/> file attachment is also very easy. Django's <code>EmailMessage</code> class provides a method called <code>attach_file()</code>, which easily lets us attach a file by passing in the two positional arguments of that method, the path of the file and an optional MIME type. For this next exercise, copy the example PDF document that has been provided along with the code of this book in the <code>/becoming_a_django_entdev/chapter_7/static/chapter_7/pdf/</code> directory, called <code>example.pdf</code>. Copy that file into the same directory as your project before following this example, or create a dummy PDF file of your own.</p>
			<p>In this next example, we will continue with the last example we just completed in the <em class="italic">As HTML emails with a plain text alternative</em> section, and attach the <code>example.pdf</code> document to that email. The Django documentation depicts using the <code>attach_file()</code> method with a path written as <code>email.attach_file('static/chapter_7/pdf/example.pdf')</code>. This is how a path will be defined when using this method in many Django projects. However, due to using the <code>whitenoise</code> package, we will have to import the <code>settings.py</code> file and use the <code>STATIC_ROOT</code> variable, as shown: </p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_7/forms.py</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">from django.conf </pre>
			<pre class="source-code">import <strong class="bold">settings</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">class <strong class="bold">ContactForm</strong>(Form):</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    def <strong class="bold">send_email</strong>(self, request):</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        <strong class="bold">email.attach_file(settings.STATIC_ROOT + '/chapter_7/pdf/example.pdf')</strong></pre>
			<pre class="source-code">        email.send()</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">When using the <code>STATIC_ROOT</code> variable in combination with the <code>whitenoise</code> package, we now have to run the <code>collectstatic</code> Django management command for that file to be found when we run the project locally. This doesn't need to be done in every Django project but in ours, it must. To do so, first stop your project from running. In a terminal or command-line window, this can be done by pressing <em class="italic">Ctrl</em> + <em class="italic">C</em> on Windows or <em class="italic">Cmd</em> + <em class="italic">C</em> on a Mac with your keyboard. Then, execute the following commands. When prompted to do so, type the word <code>yes</code> and press <em class="italic">Enter</em> when it asks whether you are sure:</p>
			<p class="callout"><code>(virtual_env) python manage.py collectstatic</code></p>
			<p class="callout"><code>(virtual_env) python manage.py runserver</code></p>
			<p class="callout">This is a built-in<a id="_idIndexMarker986"/> Django command that will collect static files from all apps loaded into your project and place a copy of them into the <code>STATIC_ROOT</code> of your project, which is defined as the <code>/becoming_a_django_entdev/staticfiles/</code> folder that we have ignored in our Git repository.</p>
			<p>That's it. Now, if you visit the same URL, <code>http://www.localhost:8000/chapter-7/form-class/</code>, and submit the form, this time when you visit your Mailtrap inbox at <a href="https://mailtrap.io/inboxes/">https://mailtrap.io/inboxes/</a>, you should see the attached file in the top right-hand corner of that email, as shown:</p>
			<div><div><img src="img/Figure_7.09_B17243.jpg" alt="Figure 7.9 – Mailtrap – PDF attachment&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.9 – Mailtrap – PDF attachment</p>
			<p>Mailtrap will <a id="_idIndexMarker987"/>let you click on this document to open and view it or download it. Open the document to see it working properly.</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor228"/>That fail silently</h2>
			<p>Developers can <a id="_idIndexMarker988"/>write reusable apps containing actions that send emails and have them fail silently just as we did when using the Django messages framework. This means that a project won't error out when a developer has installed your app but has not configured a connection to an email client yet. Django provides this option as an attribute of the <code>send()</code> method of the <code>EmailMessage</code> or <code>EmailMultiAlternatives</code> class.</p>
			<p>To activate the <code>fail_silently</code> option on the send email examples that we just wrote, add the following attribute to the existing <code>send()</code> action, as shown:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_7/forms.py</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">class <strong class="bold">ContactForm</strong>(Form):</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    def <strong class="bold">send_email</strong>(self, request):</pre>
			<pre class="source-code">        ...</pre>
			<pre class="source-code">        email.send(<strong class="bold">fail_silently=True</strong>)</pre>
			<p>This prevents<a id="_idIndexMarker989"/> the <code>email.send()</code> action from displaying an error message when this code is executed.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Django also provides this option when using the <code>send_mail()</code> and <code>send_mass_mail()</code> methods mentioned earlier. To learn more, visit <a href="https://docs.djangoproject.com/en/4.0/topics/email/">https://docs.djangoproject.com/en/4.0/topics/email/</a>.</p>
			<p>Now that we have a better understanding of how emails are being sent in Django, let's go ahead and create our own email templates to let us custom-tailor them for our clients.</p>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor229"/>Writing custom email templates</h1>
			<p>Writing <a id="_idIndexMarker990"/>HTML as a string in Python can get really messy. We can write the body contents, such as <code>'&lt;b&gt;Hello World&lt;/b&gt;'</code>, as a <code>.html</code> template file instead. That will allow us to organize multiple email templates into the <code>/templates/emails/</code> directory of the <code>chapter_7</code> app. Programming work can also be shared among developers in this way. Email templates can also be used for plain text-formatted emails, placing only the text without any HTML code inside of that <code>.html</code> file. While that may not sound appealing for plain text emails, this does have its benefits when working among a large team of developers. Let's begin with the simplest template using only plain text emails.</p>
			<p>Django provides the <code>get_template()</code> method, found in the <code>django.template.loader</code> library. This method will be used for all the email template examples in the following subsections.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor230"/>For plain text emails</h2>
			<p>Follow these steps to create a<a id="_idIndexMarker991"/> template for a plain text email:</p>
			<ol>
				<li value="1">In the <code>ContactForm</code> class that we have been working with, modify the <code>send_email()</code> method to <a id="_idIndexMarker992"/>now be the following code:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_7/forms.py</strong>
...
from django.template.loader 
import <strong class="bold">get_template</strong>
...
class <strong class="bold">ContactForm</strong>(Form):
    ...
    def <strong class="bold">send_email</strong>(self, request):
        data = self.cleaned_data
        <strong class="bold">template = get_template(</strong>
            <strong class="bold">'chapter_7/emails/plain_text_format.html'</strong>
        <strong class="bold">)</strong>
        <strong class="bold">msg_body = template.render()</strong>
        email = EmailMessage(
            subject = 'New Contact Form Entry',
            body = <strong class="bold">msg_body</strong>,
            from_email = 'no-reply@example.com',
            reply_to = ['no-reply@example.com'],
            cc = [],
            bcc = [],
            to = [data['email_1']],
            attachments = [],
            headers = {},
        )
        email.content_subtype = 'plain'
        email.send(fail_silently = True)</pre></li>
			</ol>
			<p>In the preceding code, we imported the <code>get_template()</code> method and used it to construct the template variable, which points to the <code>/chapter_7/emails/plain_text_format.html</code> file. </p>
			<ol>
				<li value="2">Now, go ahead<a id="_idIndexMarker993"/> and create that file in that same directory within your <code>/chapter_7/templates/</code> folder. Inside that file, just add the text <code>Hello World</code> and nothing else. If you place any HTML in this file, it will be rendered as a string within the plain text body content of that email and will not be rendered as HTML. </li>
				<li>Now, visit the same URL, <code>http://www.localhost:8000/chapter-7/form-class/</code>, and submit the form. This time, when you visit your Mailtrap inbox at <a href="https://mailtrap.io/inboxes/">https://mailtrap.io/inboxes/</a>, you should see that the <strong class="bold">HTML</strong> tabs are disabled, leaving only the <strong class="bold">Text</strong> tab to view your email. This also indicates that the process was successful, as shown<a id="_idIndexMarker994"/> in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_7.10_B17243.jpg" alt="Figure 7.10 – Mailtrap – plain text template&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.10 – Mailtrap – plain text template</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor231"/>For HTML emails</h2>
			<p>Writing <a id="_idIndexMarker995"/>HTML templates is done in the same way as how we loaded a template for the plain text example previously. Only the following alterations are needed:</p>
			<ol>
				<li value="1">First, we load a new file called <code>html_format.html</code> and change <code>content_subtype</code> back to <code>'html'</code>, as is highlighted here:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_7/forms.py</strong>
...
from django.template.loader 
import get_template
...
class <strong class="bold">ContactForm</strong>(Form):
    ...
    def <strong class="bold">send_email</strong>(self, request):
        data = self.cleaned_data
        template = get_template(
            <strong class="bold">'chapter_7/emails/html_format.html'</strong>
        )
        msg_body = template.render()
        email = EmailMessage(
            subject = 'New Contact Form Entry',
            body = msg_body,
            from_email = 'no-reply@example.com',
            reply_to = ['no-reply@example.com'],
            cc = [],
            bcc = [],
            to = [data['email_1']],
            attachments = [],
            headers = {},
        )
        email.content_subtype = <strong class="bold">'html'</strong>
        email.send(fail_silently = True)</pre></li>
				<li>Now, create<a id="_idIndexMarker996"/> the <code>html_format.html</code> file in your <code>/chapter_7/templates/chapter_7/emails/</code> directory. Inside this file, place the following code, where we actually have to format the document like an HTML page, in addition to providing the marked-up <code>Hello World</code> text:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_7/templates/chapter_7/emails/html_format.html</strong>
&lt;!DOCTYPE html&gt;
&lt;html lang="en" xmlns="http://www.w3.org/1999/xhtml"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;Hello World&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        <strong class="bold">&lt;b&gt;Hello World&lt;/b&gt;</strong>
    &lt;/body&gt;
&lt;/html&gt;</pre></li>
			</ol>
			<p>In this template, you can format your HTML <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> content as desired. It might even be wise to include responsive email and browser/client-supported syntax within this document to make sure it renders properly on every device. Your email test client will usually provide documentation<a id="_idTextAnchor232"/> to help you with stuff like that.</p>
			<ol>
				<li value="3">Now, visit the same URL, <code>http://www.localhost:8000/chapter-7/form-class/</code>, and submit the form. This time, when you visit your Mailtrap inbox at <a href="https://mailtrap.io/inboxes/">https://mailtrap.io/inboxes/</a>, you should see that the <strong class="bold">HTML</strong> tab is now enabled and the <strong class="bold">Text</strong> tab is disabled. Again, this indicates that the process was successful, as<a id="_idIndexMarker997"/> depicted here:</li>
			</ol>
			<div><div><img src="img/Figure_7.11_B17243.jpg" alt="Figure 7.11 – Mailtrap – HTML template&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.11 – Mailtrap – HTML template</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor233"/>Providing template context</h2>
			<p>Using <a id="_idIndexMarker998"/>template-based emails can become even more useful when we introduce dynamic content into the equation. To do this, we need to send context into the <code>template.render()</code> statement. By doing this, we can even pass the form data that was already defined as the <code>data</code> variable directly into the template, accessing form field values within that template. </p>
			<p>In this next exercise, we will render a template that also displays exactly what the user typed for each field of that form. Follow these steps to do just that:</p>
			<ol>
				<li value="1">In the <code>send_email()</code> method of <code>ContactForm</code>, make the following highlighted<a id="_idIndexMarker999"/> changes:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_7/forms.py</strong>
...
from django.template.loader 
import get_template
...
class <strong class="bold">ContactForm</strong>(Form):
    ...
    def <strong class="bold">send_email</strong>(self, request):
        data = self.cleaned_data
        template = get_template(<strong class="bold">'chapter_7/emails/new_contact_form_entry.html'</strong>)
        <strong class="bold">context = {'data': data}</strong>
        msg_body = template.render(<strong class="bold">context</strong>)
        email = EmailMessage(
            subject = 'New Contact Form Entry',
            body = msg_body,
            from_email = 'no-reply@example.com',
            reply_to = ['no-reply@example.com'],
            cc = [],
            bcc = [],
            to = [data['email_1']],
            attachments = [],
            headers = {},
        )
        email.content_subtype = 'html'
        email.send(fail_silently = True)</pre></li>
				<li>Now, create<a id="_idIndexMarker1000"/> a new file called <code>new_contact_form_entry.html</code> in your <code>/chapter_7/templates/chapter_7/emails/</code> directory and place the following code inside that file:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_7/templates/chapter_7/emails/new_contact_form_entry.html</strong>
{% load <strong class="bold">static</strong> %}
&lt;!DOCTYPE html&gt;
&lt;html lang="en" xmlns="http://www.w3.org/1999/xhtml"&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;title&gt;Contact Form Submitted&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;center&gt;
            &lt;h1&gt;New Contact Form Entry&lt;/h1&gt;
            &lt;h2&gt;The field contents are listed below&lt;/h2&gt;
            &lt;ul&gt;
                &lt;li&gt;Full Name: <strong class="bold">{{ data.full_name }}</strong>&lt;/li&gt;
                &lt;li&gt;Email Field Example 1: <strong class="bold">{{ data.email_1 }}</strong>&lt;/li&gt;
                &lt;li&gt;Email Field Example 2: <strong class="bold">{{ data.email_2 }}</strong>&lt;/li&gt;
                &lt;li&gt;Email Field Example 3: <strong class="bold">{{ data.email_3 }}</strong>&lt;/li&gt;
                &lt;li&gt;Conditionally Required Field: <strong class="bold">{{ data.conditional_required }}</strong>&lt;/li&gt;
                &lt;li&gt;Multiple Emails Field: <strong class="bold">{{ data.multiple_emails }}</strong>&lt;/li&gt;
                &lt;li&gt;Message: <strong class="bold">{{ data.message }}</strong>&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/center&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre></li>
			</ol>
			<p>In this<a id="_idIndexMarker1001"/> template, you can use any of the tags and filters that come standard with the Django template language, such as writing conditional statements to check whether a field value equals a specific value. This means you could write a loop to automatically loop through all of the fields that exist in your <code>data</code> variable and then use the provided field labels instead of those custom labels depicted previously. You can also load <code>static</code> and/or custom <code>templatetags</code> using the load tag depicted previously, as with any other Django template.</p>
			<ol>
				<li value="3">Now, visit the same URL, <code>http://www.localhost:8000/chapter-7/form-class/</code>, and submit the form. This time, when you visit your Mailtrap inbox at <a href="https://mailtrap.io/inboxes/">https://mailtrap.io/inboxes/</a>, you<a id="_idIndexMarker1002"/> should see the values of each field inside the new email, as depicted here:</li>
			</ol>
			<div><div><img src="img/Figure_7.12_B17243.jpg" alt="Figure 7.12 – Mailtrap – template context&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.12 – Mailtrap – template context</p>
			<p>Next, let's add a new action that creates a PDF document in the same spot where we are triggering our send email actions.</p>
			<h1 id="_idParaDest-210"><a id="_idTextAnchor234"/>Generating PDF reports</h1>
			<p>Django <a id="_idIndexMarker1003"/>relies on the support of third-party packages in order to generate PDF documents. Their own documentation even suggests using the <code>reportlab</code> package; however, any third-party package that provides PDF support can be used. When using anything other than <code>reportlab</code>, refer to that package's documentation for instructions on how to use that package. The <code>reportlab</code> package even provides sample PDF invoices, reports, catalogs, and more for developers to get started quickly and easily, that is, if they are using the paid Plus version of the <code>reportlab</code> package. The Plus version requires the <code>rlextra</code> package, which is not available to the public. To learn more about what this service and package can provide, visit their documentation at <a href="https://www.reportlab.com/dev/docs/">https://www.reportlab.com/dev/docs/</a>.</p>
			<p>For the exercises throughout this section, we will be using the <code>xhtml2pdf</code> package instead, which is also free but a bit simpler and easier to use when working with template-based PDFs. We will keep to the same idea of creating a separate <code>.html</code> file for the content of each static or dynamic PDF. </p>
			<p>Add the <code>xhtml2pdf</code> package to your <code>requirements.txt</code> file and install it into your virtual <a id="_idIndexMarker1004"/>environment or run the following command:</p>
			<pre>(virtual_env) pip install xhtml2pdf</pre>
			<p class="callout-heading">Tip</p>
			<p class="callout">In all packages that I have worked with, I found that some have difficulty rendering complex HTML tables consistently. I would recommend avoiding tables altogether, or if you need to structure data as a table, do so with a simple structure to prevent rendering discrepancies and errors during document creation.</p>
			<p>Now that we have installed a tool that generates PDF documents, let's practice using it.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor235"/>As template-based PDFs</h2>
			<p>Here, we will be <a id="_idIndexMarker1005"/>using the same Django template language to build what we will call <strong class="bold">PDF templates</strong>.</p>
			<p>Follow these steps to create your template:</p>
			<ol>
				<li value="1">Create a new method called <code>generate_pdf()</code> in the <code>ContactForm</code> class and include the following code:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_7/forms.py</strong>
...
from django.conf 
import settings
from django.http 
import HttpResponse
from django.template.loader 
import get_template
from xhtml2pdf 
import <strong class="bold">pisa</strong>
...
class <strong class="bold">ContactForm</strong>(Form):
    ...
    def <strong class="bold">generate_pdf</strong>(self, request):
        dest = open(settings.STATIC_ROOT + '/chapter_7/pdf/test.pdf', 'w+b')
        template = get_template('chapter_7/pdfs/pdf_template.html')
        html = template.render()
        result = <strong class="bold">pisa</strong>.CreatePDF(
            html,
            dest = dest,
        )
        return HttpResponse(result.err)</pre></li>
			</ol>
			<p>Here, we import the <code>pisa</code> library from within the <code>xhtml2pdf</code> package and use the <code>CreatePDF()</code> method. We are also using the Python <code>open()</code> method to specify the destination folder and filename of the document that we want to create. We are using the same <code>STATIC_ROOT</code> variable that we used before, most likely due to the <code>whitenoise</code> package in our project stack. The file being <a id="_idIndexMarker1006"/>created will be located in the <code>/becoming_a_django_entdev/staticfiles/chapter_7/pdf/</code> directory. Then, we are setting the <code>result</code> variable to equal the result of running the <code>CreatePDF()</code> method where we pass in the rendered HTML template as the content of that PDF. Additional information is available in the documentation, found here: <a href="https://xhtml2pdf.readthedocs.io/en/latest/format_html.html">https://xhtml2pdf.readthedocs.io/en/latest/format_html.html</a>. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Since we are creating this file, there is no need to run the <code>collectstatic</code> command as we had to before.</p>
			<ol>
				<li value="2">Next, in<a id="_idIndexMarker1007"/> the <code>post()</code> method of the <code>FormClass_View</code> class, where we wrote our <code>send_email()</code> action, let's add the <code>generate_pdf()</code> operation just below that statement, as shown and highlighted here:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_7/views.py</strong>
from django.template.response 
import TemplateResponse
from django.views.generic.edit 
import FormView
...
class <strong class="bold">FormClass_View</strong>(FormView):
    ...
    def <strong class="bold">post</strong>(self, request, *args, **kwargs):
        form = self.form_class(request.POST)
        ...
        form.send_email(request)
        <strong class="bold">form.generate_pdf(request)</strong>
        return TemplateResponse(
            request,
            self.template_name,
            context
        )</pre></li>
				<li>Next, in <a id="_idIndexMarker1008"/>the <code>pdf_template.html</code> file that we are specifying as the template used for the body content of the PDF, add the following code:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_7/templates/chapter_7/pdfs/pdf_template.html</strong>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;&lt;/head&gt;
    &lt;body&gt;
        &lt;div id="header_obj"&gt;&lt;h1&gt;Header&lt;/h1&gt;&lt;/div&gt;
        &lt;div id="footer_obj"&gt;
            &amp;copy;Footer - Page <strong class="bold">&lt;pdf:pagenumber&gt;</strong> of <strong class="bold">&lt;pdf:pagecount&gt;</strong>
        &lt;/div&gt;
        &lt;div class="body-content"&gt;
            &lt;h2&gt;Hello World&lt;/h2&gt;
            {% <strong class="bold">lorem 50 p</strong> %}<strong class="bold">&lt;pdf:pdf-next-page /&gt;</strong>{% <strong class="bold">lorem 50 p</strong> %}
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre></li>
			</ol>
			<p>Here, we are writing standard HTML code to create the content of the PDF. The preceding example creates a reusable and repeatable header and footer on every page of the document. We also use special vendor-specific tags to tell us things such as the current page or the total page count of the document, such as what is used in the footer of the document, <code>&lt;pdf:pagenumber&gt;</code> and <code>&lt;pdf:pagecount&gt;</code>. We also use the Django-provided <code>{% lorem %}</code> template tag, which generates 50 paragraphs worth of Latin text, using the <code>50 p</code> values that we are passing into that function. The Latin text, represented as <strong class="bold">Lorem Ipsum</strong>, is used only to illustrate what happens when there is more than one page worth of content without actually writing that content.</p>
			<ol>
				<li value="4">The <code>size</code> attribute is used to specify the HTML document size that we want to specify the <a id="_idIndexMarker1009"/>physical size and orientation of the PDF document. Next, use the <code>@page</code> and <code>@frame</code> CSS objects to format your PDF document:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_7/templates/chapter_7/pdfs/pdf_template.html</strong>
...
    &lt;head&gt;
        &lt;style&gt;
            <strong class="bold">@page {</strong>
                <strong class="bold">size: a4 portrait;</strong>
                <strong class="bold">@frame</strong> header_frame {
                    <strong class="bold">-pdf-frame-content: header_obj;</strong>
                    top: 50pt; left: 50pt;
                    width: 512pt; height: 40pt;
                }
                <strong class="bold">@frame</strong> content_frame {
                    top: 90pt; left: 50pt;
                    width: 512pt; height: 632pt;
                }
                <strong class="bold">@frame</strong> footer_frame {
                    <strong class="bold">-pdf-frame-content: footer_obj;</strong>
                    top: 772pt; left: 50pt;
                    width: 512pt; height: 20pt;
                }
            }
            #header_obj { color: darkblue; text-align: center; }
            .body-content { color: black; text-align: left; }
            #footer_obj { color: green; text-align: right; }
        &lt;/style&gt;
    &lt;/head&gt;
...</pre></li>
			</ol>
			<p>The <code>-pdf-frame-content</code> attribute is used to map the <code>@frame</code> object to the actual <code>&lt;div&gt;</code> with an ID attribute that matches the value specified. This must be <code>&lt;div&gt;</code> and not a <code>&lt;header&gt;</code> or <code>&lt;footer&gt;</code> HTML object or else your content will not render properly.</p>
			<ol>
				<li value="5">Now, visit the<a id="_idIndexMarker1010"/> same URL, <code>http://www.localhost:8000/chapter-7/form-class/</code>, and submit the form. This time, you should see a new file called <code>test.pdf</code> in your <code>/becoming_a_django_entdev/staticfiles/chapter_7/pdf/</code> directory. When opening that document, you should see about eight pages worth of randomly generated Latin text, and on every page, you should see the same header and footer, as depicted in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_7.13_B17243.jpg" alt="Figure 7.13 – xhmtl2pdf – static PDF&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.13 – xhmtl2pdf – static PDF</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">When opening this document to see what it looks like, particularly on Windows, you must close this document before submitting your form again, triggering it to generate a new document. You may run into permission errors stating that another person or application is already using that file if you don't.</p>
			<p>Let's add context to the PDF templates next.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor236"/>Adding context</h2>
			<p>Let's pass the contents<a id="_idIndexMarker1011"/> of the form field values into that PDF as context. This method does not always need to live in a form class; the same also applies to the <code>send_email()</code> method. They can live in a view or model class or even exist as a standalone utility method that can be used anywhere. </p>
			<p>For now, modify the previous example to pass in context using the following steps:</p>
			<ol>
				<li value="1">In the same <code>generate_pdf()</code> method of the <code>ContactForm</code> class, make the changes highlighted here:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_7/forms.py</strong>
...
from django.conf 
import settings
from django.template.loader 
import get_template
from xhtml2pdf 
import <strong class="bold">pisa</strong>
...
class <strong class="bold">ContactForm</strong>(Form):
    ...
    def <strong class="bold">generate_pdf</strong>(self, request):
        <strong class="bold">data = self.cleaned_data</strong>
        <strong class="bold">context = { 'data': data }</strong>
        dest = open(settings.STATIC_ROOT + <strong class="bold">'/chapter_7/pdf/test_2.pdf'</strong>, 'w+b')
        template = get_template(
            'chapter_7/pdfs/pdf_template.html'
        )
        html = template.render(<strong class="bold">context</strong>)
        result = pisa.CreatePDF(
            html,
            dest = dest,
        )
        return HttpResponse(result.err)</pre></li>
				<li>Next, in the <a id="_idIndexMarker1012"/>same <code>/chapter_7/pdfs/pdf_template.html</code> file, add the following highlighted code between the two existing lines of code, as shown:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_7/templates/chapter_7/pdfs/pdf_template.html</strong>
...
        &lt;div class="body-content"&gt;
            &lt;h2&gt;Hello World&lt;/h2&gt;
            <strong class="bold">&lt;h3&gt;The field contents are listed below&lt;/h3&gt;</strong>
            <strong class="bold">&lt;ul&gt;</strong>
                <strong class="bold">&lt;li&gt;Full Name: {{ data.full_name }}&lt;/li&gt;</strong>
                <strong class="bold">&lt;li&gt;Email Field Example 1: {{ data.email_1 }}&lt;/li&gt;</strong>
                <strong class="bold">&lt;li&gt;Email Field Example 2: {{ data.email_2 }}&lt;/li&gt;</strong>
                <strong class="bold">&lt;li&gt;Email Field Example 3: {{ data.email_3 }}&lt;/li&gt;</strong>
                <strong class="bold">&lt;li&gt;Conditionally Required Field: {{ data.conditional_required }}&lt;/li&gt;</strong>
                <strong class="bold">&lt;li&gt;Multiple Emails Field: {{ data.multiple_emails }}&lt;/li&gt;</strong>
                <strong class="bold">&lt;li&gt;Message: {{ data.message }}&lt;/li&gt;</strong>
            <strong class="bold">&lt;/ul&gt;</strong>
            {% lorem 50 p %}&lt;pdf:pdf-next-page /&gt;{% lorem 50 p %}
        &lt;/div&gt;
...</pre></li>
			</ol>
			<p>The same code written in the <em class="italic">Providing template context</em> subsection of this chapter is used.</p>
			<ol>
				<li value="3">Now, visit the same URL, <code>http://www.localhost:8000/chapter-7/form-class/</code>, and submit the form. You should see a new file called <code>test_2.pdf</code> in the <code>/becoming_a_django_entdev/staticfiles/chapter_7/pdf/</code> directory on your local machine. When you open that file, there should still be eight pages worth of content. On the first page only, there will be a list containing the content of the form that we just passed into that PDF template, as depicted <a id="_idIndexMarker1013"/>here:<div><img src="img/Figure_7.14_B17243.jpg" alt="Figure 7.14 – xhmtl2pdf – dynamic PDF&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 7.14 – xhmtl2pdf – dynamic PDF</p>
			<p>Now that we know how to build PDF templates and generate PDF documents, we can present data in a very clean and structured way that makes using these a valuable reporting tool.</p>
			<h1 id="_idParaDest-213"><a id="_idTextAnchor237"/>Summary</h1>
			<p>With the skills gained after completing the exercises found in this chapter, you can now create and send messages, notifications, and reports of various types. We now know how to use the Django messages framework to serve up flash messages every time a page loads or reloads. We can create and send emails of various content types and even use an email test client account to capture those emails, indicating that they are actually working. We even installed a package and began building our own PDF reports. </p>
			<p>Use any combination of these tools to add value to your project. Flash messages, email notifications, and report generating concepts all help to keep users informed and engaged with your application. Always remember that too much information can overwhelm a user, such as having thousands of email notifications flooding their inbox. Use them wisely!</p>
			<p>The Django messages framework offers a wide range of tools that can create flash messages for users. With a little bit of creativity, the Django messages framework can be used with <strong class="bold">Asynchronous JavaScript and XML</strong> (<strong class="bold">AJAX</strong>) to serve up messages that act more like a <strong class="bold">Single-Page App</strong> (<strong class="bold">SPA</strong>). In the next chapter, <a href="B17243_08_ePub.xhtml#_idTextAnchor239"><em class="italic">Chapter 8</em></a>, <em class="italic">Working with the Django REST Framework</em>, we will discuss what the Django REST framework is and how it can be used to work with AJAX requests.</p>
		</div>
	</body></html>