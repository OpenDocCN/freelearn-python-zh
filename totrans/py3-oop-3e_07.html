<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Python Object-Oriented Shortcuts</h1>
                </header>
            
            <article>
                
<p>There are many aspects of Python that appear more reminiscent of structural or functional programming than object-oriented programming. Although object-oriented programming has been the most visible paradigm of the past two decades, the old models have seen a recent resurgence. As with Python's data structures, most of these tools are syntactic sugar over an underlying object-oriented implementation; we can think of them as a further abstraction layer built on top of the (already abstracted) object-oriented paradigm. In this chapter, we'll be covering a grab bag of Python features that are not strictly object-oriented:</p>
<ul>
<li>Built-in functions that take care of common tasks in one call</li>
<li>File I/O and context managers</li>
<li>An alternative to method overloading</li>
<li>Functions as objects</li>
</ul>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Python built-in functions</h1>
                </header>
            
            <article>
                
<p>There are numerous functions in Python that perform a task or calculate a result on certain types of objects without being methods on the underlying class. They usually abstract common calculations that apply to multiple types of classes. This is duck typing at its best; these functions accept objects that have certain attributes or methods, and are able to perform generic operations using those methods. We've used many of the built-in functions already, but let's quickly go through the important ones and pick up a few neat tricks along the way.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The len() function</h1>
                </header>
            
            <article>
                
<p>The simplest example is the <kbd>len()</kbd> function, which counts the number of items in some kind of container object, such as a dictionary or list. You've seen it before<span>, demonstrated as follows:</span>:</p>
<pre><strong>&gt;&gt;&gt; len([1,2,3,4])</strong>
<strong>4</strong>  </pre>
<p>You may wonder why these objects don't have a length property instead of having to call a function on them. Technically, they do. Most objects that <kbd>len()</kbd> will apply to have a method called <kbd>__len__()</kbd> that returns the same value. So <kbd>len(myobj)</kbd> seems to call <kbd>myobj.__len__()</kbd>.</p>
<p>Why should we use the <kbd>len()</kbd> function instead of the <kbd>__len__</kbd> method? Obviously, <kbd>__len__</kbd> is a special double-underscore method, suggesting that we shouldn't call it directly. There must be an explanation for this. The Python developers don't make such design decisions lightly.</p>
<p>The main reason is efficiency. When we call <kbd>__len__</kbd> on an object, the object has to look the method up in its namespace, and, if the special <kbd>__getattribute__</kbd> method (which is called every time an attribute or method on an object is accessed) is defined on that object, it has to be called as well. Furthermore, the <kbd>__getattribute__</kbd> for that particular method may have been written to do something nasty, such as refusing to give us access to special methods such as <kbd>__len__</kbd>! The <kbd>len()</kbd> function doesn't encounter any of this. It actually calls the <kbd>__len__</kbd> function on the underlying class, so <kbd>len(myobj)</kbd> maps to <kbd>MyObj.__len__(myobj)</kbd>.</p>
<p>Another reason is maintainability. In the future, Python developers may want to change <kbd>len()</kbd> so that it can calculate the length of objects that don't have <kbd>__len__</kbd>, for example, by counting the number of items returned in an iterator. They'll only have to change one function instead of countless <kbd>__len__</kbd> methods in many objects across the board.</p>
<p>There is one other extremely important and often overlooked reason for <kbd>len()</kbd> being an external function: backward compatibility. This is often cited in articles as <em>for historical reasons</em>, which is a mildly dismissive phrase that an author will use to say something is the way it is because a mistake was made long ago and we're stuck with it. Strictly speaking, <kbd>len()</kbd> isn't a mistake, it's a design decision, but that decision was made in a less object-oriented time. It has stood the test of time and has some benefits, so do get used to it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reversed</h1>
                </header>
            
            <article>
                
<p>The <kbd>reversed()</kbd> function takes any sequence as input, and returns a copy of that sequence in reverse order. It is normally used in <kbd>for</kbd> loops when we want to loop over items from back to front.</p>
<p>Similar to <kbd>len</kbd>, <kbd>reversed</kbd> calls the <kbd>__reversed__()</kbd> function on the class for the parameter. If that method does not exist, <kbd>reversed</kbd> builds the reversed sequence itself using calls to <kbd>__len__</kbd> and <kbd>__getitem__</kbd>, which are used to define a sequence. We only need to override <kbd>__reversed__</kbd> if we want to somehow customize or optimize the process<span>, as demonstrated in the following code:</span></p>
<pre>normal_list = [1, 2, 3, 4, 5]<br/><br/><br/>class CustomSequence:<br/>    def __len__(self):<br/>        return 5<br/><br/>    def __getitem__(self, index):<br/>        return f"x{index}"<br/><br/><br/>class FunkyBackwards:<br/><strong>    def __reversed__(self):</strong><br/><strong>        return "BACKWARDS!"</strong><br/><br/><br/>for seq in normal_list, CustomSequence(), FunkyBackwards():<br/>    print(f"\n{seq.__class__.__name__}: ", end="")</pre>
<pre>    for item in reversed(seq):<br/>        print(item, end=", ")</pre>
<p>The <kbd>for</kbd> loops at the end print reversed versions of a normal list, and instances of the two custom sequences. The output shows that <kbd>reversed</kbd> works on all three of them, but has very different results when we define <kbd>__reversed__</kbd> ourselves:</p>
<pre><strong>list: 5, 4, 3, 2, 1,</strong>
<strong>CustomSequence: x4, x3, x2, x1, x0,</strong>
<strong>FunkyBackwards: B, A, C, K, W, A, R, D, S, !,</strong>  </pre>
<p>When we reverse <kbd>CustomSequence</kbd>, the <kbd>__getitem__</kbd> method is called for each item, which just inserts an <kbd>x</kbd> before the index. For <kbd>FunkyBackwards</kbd>, the <kbd>__reversed__</kbd> method returns a string, each character of which is output individually in the <kbd>for</kbd> loop.</p>
<div class="packt_infobox">The preceding two classes aren't very good sequences, as they don't define a proper version of <kbd>__iter__</kbd>, so a forward <kbd>for</kbd> loop over them would never end.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enumerate</h1>
                </header>
            
            <article>
                
<p>Sometimes, when we're looping over a container in a <kbd>for</kbd> loop, we want access to the index (the current position in the list) of the current item being processed. The <kbd>for</kbd> loop doesn't provide us with indexes, but the <kbd>enumerate</kbd> function gives us something better: it creates a sequence of tuples, where the first object in each tuple is the index and the second is the original item.</p>
<p>This is useful if we need to use index numbers directly. Consider some simple code that outputs each of the lines in a file with line numbers:</p>
<pre>import sys<br/><br/>filename = sys.argv[1]<br/><br/>with open(filename) as file:<br/><strong>    for index, line in enumerate(file):</strong><br/>        print(f"{index+1}: {line}", end="")</pre>
<p>Running this code using its own filename as the input file shows how it works:</p>
<pre><strong>1: import sys</strong><br/><strong>2:</strong><br/><strong>3: filename = sys.argv[1]</strong><br/><strong>4:</strong><br/><strong>5: with open(filename) as file:</strong><br/><strong>6:     for index, line in enumerate(file):</strong><br/><strong>7:         print(f"{index+1}: {line}", end="")</strong></pre>
<p>The <kbd>enumerate</kbd> function returns a sequence of tuples, our <kbd>for</kbd> loop splits each tuple into two values, and the <kbd>print</kbd> statement formats them together. It adds one to the index for each line number, since <kbd>enumerate</kbd>, like all sequences, is zero-based.</p>
<p>We've only touched on a few of the more important Python built-in functions. As you can see, many of them call into object-oriented concepts, while others subscribe to purely functional or procedural paradigms. There are numerous others in the standard library; some of the more interesting ones include the following:</p>
<ul>
<li><kbd>all</kbd> and <kbd>any</kbd>, which accept an iterable object and return <kbd>True</kbd> if all, or any, of the items evaluate to true (such as a non-empty string or list, a non-zero number, an object that is not <kbd>None</kbd>, or the literal <kbd>True</kbd>).</li>
<li><kbd>eval</kbd>, <kbd>exec</kbd>, and <kbd>compile</kbd>, which execute string as code inside the interpreter. Be careful with these ones; they are not safe, so don't execute code an unknown user has supplied to you (in general, assume all unknown users are malicious, foolish, or both).</li>
<li><kbd>hasattr</kbd>, <kbd>getattr</kbd>, <kbd>setattr</kbd>, and <kbd>delattr</kbd>, which allow attributes on an object to be manipulated by their string names.</li>
<li><kbd>zip</kbd>, which takes two or more sequences and returns a new sequence of tuples, where each tuple contains a single value from each sequence.</li>
<li>And many more! See the interpreter help documentation for each of the functions listed in <kbd>dir(__builtins__)</kbd>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">File I/O</h1>
                </header>
            
            <article>
                
<p>Our examples so far that have touched the filesystem have operated entirely on text files without much thought as to what is going on under the hood. Operating systems, however, actually represent files as a sequence of bytes, not text. We'll take a deep dive into the relationship between bytes and text in <a href="9a6335a2-1c69-4fa8-a685-02bbeeba23be.xhtml"><span class="ChapterrefPACKT">Chapter 8</span></a>, <em>Strings and Serialization</em>. For now, be aware that reading textual data from a file is a fairly involved process. Python, especially Python 3, takes care of most of this work for us behind the scenes. Aren't we lucky?!</p>
<p>The concept of files has been around since long before anyone coined the term <em>object-oriented programming</em>. However, Python has wrapped the interface that operating systems provide in a sweet abstraction that allows us to work with file (or file-like, vis-à-vis duck typing) objects.</p>
<p>The <kbd>open()</kbd> built-in function is used to open a file and return a file object. For reading text from a file, we only need to pass the name of the file into the function. The file will be opened for reading, and the bytes will be converted to text using the platform default encoding.</p>
<p>Of course, we don't always want to read files; often we want to write data to them! To open a file for writing, we need to pass a <kbd>mode</kbd> argument as the second positional argument, with a value of <kbd>"w"</kbd>:</p>
<pre>contents = "Some file contents" 
file = open("filename", "w") 
file.write(contents) 
file.close() </pre>
<p>We could also supply the value <kbd>"a"</kbd> as a mode argument, to append to the end of the file, rather than completely overwriting existing file content.</p>
<p>These files with built-in wrappers for converting bytes to text are great, but it'd be awfully inconvenient if the file we wanted to open was an image, executable, or other binary file, wouldn't it?</p>
<p>To open a binary file, we modify the mode string to append <kbd>'b'</kbd>. So, <kbd>'wb'</kbd> would open a file for writing bytes, while <kbd>'rb'</kbd> allows us to read them. They will behave like text files, but without the automatic encoding of text to bytes. When we read such a file, it will return <kbd>bytes</kbd> objects instead of <kbd>str</kbd>, and when we write to it, it will fail if we try to pass a text object.</p>
<div class="packt_infobox">These mode strings for controlling how files are opened are rather cryptic and are neither Pythonic nor object-oriented. However, they are consistent with virtually every other programming language out there. File I/O is one of the fundamental jobs an operating system has to handle, and all programming languages have to talk to the <span>operating system</span> using the same system calls. Just be glad that Python returns a file object with useful methods instead of the integer that most major operating systems use to identify a file handle!</div>
<p>Once a file is opened for reading, we can call the <kbd>read</kbd>, <kbd>readline</kbd>, or <kbd>readlines</kbd> methods to get the contents of the file. The <kbd>read</kbd> method returns the entire contents of the file as a <kbd>str</kbd> or <kbd>bytes</kbd> object, depending on whether there is <kbd>'b'</kbd> in the mode. Be careful not to use this method without arguments on huge files. You don't want to find out what happens if you try to load that much data into memory!</p>
<p>It is also possible to read a fixed number of bytes from a file; we pass an integer argument to the <kbd>read</kbd> method, describing how many bytes we want to read. The next call to <kbd>read</kbd> will load the next sequence of bytes, and so on. We can do this inside a <kbd>while</kbd> loop to read the entire file in manageable chunks.</p>
<p>The <kbd>readline</kbd> method returns a single line from the file (where each line ends in a newline, a carriage return, or both, depending on the operating system on which the file was created). We can call it repeatedly to get additional lines. The plural <kbd>readlines</kbd> method returns a list of all the lines in the file. Like the <kbd>read</kbd> method, it's not safe to use on very large files. These two methods even work when the file is open in <kbd>bytes</kbd> mode, but it only makes sense if we are parsing text-like data that has newlines at reasonable positions. An image or audio file, for example, will not have newline characters in it (unless the newline byte happened to represent a certain pixel or sound), so applying <kbd>readline</kbd> wouldn't make sense.</p>
<p>For readability, and to avoid reading a large file into memory at once, it is often better to use a <kbd>for</kbd> loop directly on a file object. For text files, it will read each line, one at a time, and we can process it inside the loop body. For binary files, it's better to read fixed-sized chunks of data using the <kbd>read()</kbd> method, passing a parameter for the maximum number of bytes to read.</p>
<p>Writing to a file is just as easy; the <kbd>write</kbd> method on file objects writes a string (or bytes, for binary data) object to the file. It can be called repeatedly to write multiple strings, one after the other. The <kbd>writelines</kbd> method accepts a sequence of strings and writes each of the iterated values to the file. The <kbd>writelines</kbd> method does <em>not</em> append a new line after each item in the sequence. It is basically a poorly named convenience function to write the contents of a sequence of strings without having to explicitly iterate over it using a <kbd>for</kbd> loop.</p>
<p>Lastly, and I do mean lastly, we come to the <kbd>close</kbd> method. This method should be called when we are finished reading or writing the file, to ensure any buffered writes are written to the disk, that the file has been properly cleaned up, and that all resources associated with the file are released back to the operating system. Technically, this will happen automatically when the script exits, but it's better to be explicit and clean up after ourselves, especially in long-running processes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Placing it in context</h1>
                </header>
            
            <article>
                
<p>The need to close files when we are finished with them can make our code quite ugly. Because an exception may occur at any time during file I/O, we ought to wrap all calls to a file in a <kbd>try</kbd>...<kbd>finally</kbd> clause. The file should be closed in the <kbd>finally</kbd> clause, regardless of whether I/O was successful. This isn't very Pythonic. Of course, there is a more elegant way to do it.</p>
<p>If we run <kbd>dir</kbd> on a file-like object, we see that it has two special methods named <kbd>__enter__</kbd> and <kbd>__exit__</kbd>. These methods turn the file object into what is known as a <strong>context manager</strong>. Basically, if we use a special syntax called the <kbd>with</kbd> statement, these methods will be called before and after nested code is executed. On file objects, the <kbd>__exit__</kbd> method ensures the file is closed, even if an exception is raised. We no longer have to explicitly manage the closing of the file. Here is what the <kbd>with</kbd> statement looks like in practice:</p>
<pre>with open('filename') as file: 
    for line in file: 
        print(line, end='') </pre>
<p>The <kbd>open</kbd> call returns a file object, which has <kbd>__enter__</kbd> and <kbd>__exit__</kbd> methods. The returned object is assigned to the variable named <kbd>file</kbd> by the <kbd>as</kbd> clause. We know the file will be closed when the code returns to the outer indentation level, and that this will happen even if an exception is raised.</p>
<p>The <kbd>with</kbd> statement is used in several places in the standard library, where start up or cleanup code needs to be executed. For example, the <kbd>urlopen</kbd> call returns an object that can be used in a <kbd>with</kbd> statement to clean up the socket when we're done. Locks in the threading module can automatically release the lock when the statement has been executed.</p>
<p>Most interestingly, because the <kbd>with</kbd> statement can apply to any object that has the appropriate special methods, we can use it in our own frameworks. For example, remember that strings are immutable, but sometimes you need to build a string from multiple parts. For efficiency, this is usually done by storing the component strings in a list and joining them at the end. Let's create a simple context manager that allows us to construct a sequence of characters and automatically convert it to a string upon exit:</p>
<pre>class StringJoiner(list): 
<strong>    def __enter__(self):</strong> 
        return self 
 
<strong> def __exit__(self, type, value, tb):</strong> 
        self.result = "".join(self) </pre>
<p>This code adds the two special methods required of a context manager to the <kbd>list</kbd> class it inherits from. The <kbd>__enter__</kbd> method performs any required setup code (in this case, there isn't any) and then returns the object that will be assigned to the variable after <kbd>as</kbd> in the <kbd>with</kbd> statement. Often, as we've done here, this is just the context manager object itself. The <kbd>__exit__</kbd> method accepts three arguments. In a normal situation, these are all given a value of <kbd>None</kbd>. However, if an exception occurs inside the <kbd>with</kbd> block, they will be set to values related to the type, value, and traceback for the exception. This allows the <kbd>__exit__</kbd> method to perform any cleanup code that may be required, even if an exception occurred. In our example, we take the irresponsible path and create a result string by joining the characters in the string, regardless of whether an exception was thrown.</p>
<p>While this is one of the simplest context managers we could write, and its usefulness is dubious, it does work with a <kbd>with</kbd> statement. Have a look at it in action:</p>
<pre>import random, string 
with StringJoiner() as joiner: 
    for i in range(15): 
        joiner.append(random.choice(string.ascii_letters)) 
 
print(joiner.result) </pre>
<p>This code constructs a string of 15 random characters. It appends these to a <kbd>StringJoiner</kbd> using the <kbd>append</kbd> method it inherited from <kbd>list</kbd>. When the <kbd>with</kbd> statement goes out of scope (back to the outer indentation level), the <kbd>__exit__</kbd> method is called, and the <kbd>result</kbd> attribute becomes available on the joiner object. We then print this value to see a random string.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An alternative to method overloading</h1>
                </header>
            
            <article>
                
<p>One prominent feature of many object-oriented programming languages is a tool called <strong>method overloading</strong>. Method overloading simply refers to having multiple methods with the same name that accept different sets of arguments. In statically typed languages, this is useful if we want to have a method that accepts either an integer or a string, for example. In non-object-oriented languages, we might need two functions, called <kbd>add_s</kbd> and <kbd>add_i</kbd>, to accommodate such situations. In statically typed object-oriented languages, we'd need two methods, both called <kbd>add</kbd>, one that accepts strings, and one that accepts integers.</p>
<p>In Python, we've already seen that we only need one method, which accepts any type of object. It may have to do some testing on the object type (for example, if it is a string, convert it to an integer), but only one method is required.</p>
<p>However, method overloading is also useful when we want a method with the same name to accept different numbers or sets of arguments. For example, an email message method might come in two versions, one of which accepts an argument for the <em>from</em> email address. The other method might look up a default <em>from</em> email address instead. Python doesn't permit multiple methods with the same name, but it does provide a different, equally flexible, interface.</p>
<p>We've seen some of the possible ways to send arguments to methods and functions in previous examples, but now we'll cover all the details. The simplest function accepts no arguments. We probably don't need an example, but here's one for completeness:</p>
<pre>def no_args(): 
    pass </pre>
<p>And here's how it's called:</p>
<pre>no_args() </pre>
<p>A function that does accept arguments will provide the names of those arguments in a comma-separated list. Only the name of each argument needs to be supplied.</p>
<p>When calling the function, these positional arguments must be specified in order, and none can be missed or skipped. This is the most common way in which we've specified arguments in our previous examples:</p>
<pre>def mandatory_args(x, y, z): 
    pass </pre>
<p>To call it,<span> type the following:</span>:</p>
<pre>mandatory_args("a string", a_variable, 5) </pre>
<p>Any type of object can be passed as an argument: an object, a container, a primitive, even functions and classes. The preceding call shows a hardcoded string, an unknown variable, and an integer passed into the function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Default arguments</h1>
                </header>
            
            <article>
                
<p>If we want to make an argument optional, rather than creating a second method with a different set of arguments, we can specify a default value in a single method, using an equals sign. If the calling code does not supply this argument, it will be assigned a default value. However, the calling code can still choose to override the default by passing in a different value. Often, a default value of <kbd>None</kbd>, or an empty string or list, is suitable.</p>
<p>Here's a function definition with default arguments:</p>
<pre>def default_arguments(x, y, z, a="Some String", b=False): 
    pass </pre>
<p>The first three arguments are still mandatory and must be passed by the calling code. The last two parameters have default arguments supplied.</p>
<p>There are several ways we can call this function. We can supply all arguments in order, as though all the arguments were positional arguments<span>, as can be seen in the following:</span>:</p>
<pre>default_arguments("a string", variable, 8, "", True) </pre>
<p>Alternatively, we can supply just the mandatory arguments in order, leaving the keyword arguments to be assigned their default values:</p>
<pre>default_arguments("a longer string", some_variable, 14) </pre>
<p>We can also use the equals sign syntax when calling a function to provide values in a different order, or to skip default values that we aren't interested in. For example, we can skip the first keyword arguments and supply the second one:</p>
<pre>default_arguments("a string", variable, 14, b=True) </pre>
<p>Surprisingly, we can even use the equals sign syntax to mix up the order of positional arguments, so long as all of them are supplied:</p>
<pre><strong>&gt;&gt;&gt; default_arguments(y=1,z=2,x=3,a="hi")</strong>
<strong>3 1 2 hi False</strong>  </pre>
<p>You may occasionally find it useful to make a <em>keyword-only</em> argument, that is, an argument that must be supplied as a keyword argument. You can do that by placing a <kbd>*</kbd> before the keyword-only arguments:</p>
<pre>def kw_only(x, y='defaultkw', *, a, b='only'):<br/>    print(x, y, a, b)</pre>
<p>This function has one positional argument, <kbd>x</kbd>, and three keyword arguments, <kbd>y</kbd>, <kbd>a</kbd>, and <kbd>b</kbd>. <kbd>x</kbd> and <kbd>y</kbd> are both mandatory, but <kbd>a</kbd> can only be passed as a keyword argument. <kbd>y</kbd> and <kbd>b</kbd> are both optional with default values, but if <kbd>b</kbd> is supplied, it can only be a keyword argument.</p>
<p>This function fails if you don't pass <kbd>a</kbd>:</p>
<pre><strong>&gt;&gt;&gt; kw_only('x')</strong><br/><strong>Traceback (most recent call last):</strong><br/><strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong><br/><strong>TypeError: kw_only() missing 1 required keyword-only argument: 'a'</strong></pre>
<p>It also fails if you pass <kbd>a</kbd> as a positional argument:</p>
<pre><strong>&gt;&gt;&gt; kw_only('x', 'y', 'a')</strong><br/><strong>Traceback (most recent call last):</strong><br/><strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong><br/><strong>TypeError: kw_only() takes from 1 to 2 positional arguments but 3 were given</strong></pre>
<p>But you can pass <kbd>a</kbd> and <kbd>b</kbd> as keyword arguments:</p>
<pre><strong>&gt;&gt;&gt; kw_only('x', a='a', b='b')</strong><br/><strong>x defaultkw a b</strong></pre>
<p>With so many options, it may seem hard to pick one, but if you think of the positional arguments as an ordered list, and keyword arguments as sort of like a dictionary, you'll find that the correct layout tends to fall into place. If you need to require the caller to specify an argument, make it mandatory; if you have a sensible default, then make it a keyword argument. Choosing how to call the method normally takes care of itself, depending on which values need to be supplied, and which can be left at their defaults.  Keyword-only arguments are relatively rare, but when the use case comes up, they can make for a more elegant API.</p>
<p>One thing to take note of with keyword arguments is that anything we provide as a default argument is evaluated when the function is first interpreted, not when it is called. This means we can't have dynamically generated default values. For example, the following code won't behave quite as expected:</p>
<pre>number = 5 
def funky_function(number=number): 
    print(number) 
 
number=6 
funky_function(8) 
funky_function() 
print(number) </pre>
<p>If we run this code, it outputs the number <kbd>8</kbd> first, but then it outputs the number <kbd>5</kbd> for the call with no arguments. We had set the variable to the number <kbd>6</kbd>, as evidenced by the last line of output, but when the function is called, the number <kbd>5</kbd> is printed; the default value was calculated when the function was defined, not when it was called.</p>
<p>This is tricky with empty containers such as lists, sets, and dictionaries. For example, it is common to ask calling code to supply a list that our function is going to manipulate, but the list is optional. We'd like to make an empty list as a default argument. We can't do this; it will create only one list, when the code is first constructed<span>, demonstrated as follows:</span>:</p>
<pre>//DON'T DO THIS<br/><strong>&gt;&gt;&gt; def hello(b=[]):</strong>
<strong>...     b.append('a')</strong>
<strong>...     print(b)</strong>
<strong>...</strong>
<strong>&gt;&gt;&gt; hello()</strong>
<strong>['a']</strong>
<strong>&gt;&gt;&gt; hello()</strong>
<strong>['a', 'a']</strong>  </pre>
<p>Whoops, that's not quite what we expected! The usual way to get around this is to make the default value <kbd>None</kbd>, and then use the <kbd>iargument = argument if argument else []</kbd> <span>idiom </span>inside the method. Pay close attention!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Variable argument lists</h1>
                </header>
            
            <article>
                
<p>Default values alone do not allow us all the flexible benefits of method overloading. One thing that makes Python really slick is the ability to write methods that accept an arbitrary number of positional or keyword arguments without explicitly naming them. We can also pass arbitrary lists and dictionaries into such functions.</p>
<p>For example, a function to accept a link or list of links and download the web pages could use such variadic arguments, or <strong>varargs</strong>. Instead of accepting a single value that is expected to be a list of links, we can accept an arbitrary number of arguments, where each argument is a different link. We do this by specifying the <kbd>*</kbd> operator in the function definition, as follows:</p>
<pre><strong>def get_pages(*links):</strong> 
    for link in links: 
        #download the link with urllib 
        print(link) </pre>
<p>The <kbd>*links</kbd> parameter says, <em>I'll accept any number of arguments and put them all in a list named</em> <kbd>links</kbd>. If we supply only one argument, it'll be a list with one element; if we supply no arguments, it'll be an empty list. Thus, all these function calls are valid:</p>
<pre>get_pages() 
get_pages('http://www.archlinux.org') 
get_pages('http://www.archlinux.org', 
        'http://ccphillips.net/') </pre>
<p>We can also accept arbitrary keyword arguments. These arrive in the function as a dictionary. They are specified with two asterisks (as in <kbd>**kwargs</kbd>) in the function declaration. This tool is commonly used in configuration setups. The following class allows us to specify a set of options with default values:</p>
<pre>class Options: 
    default_options = { 
            'port': 21, 
            'host': 'localhost', 
            'username': None, 
            'password': None, 
            'debug': False, 
            } 
<strong>    def __init__(self, **kwargs):</strong> 
        self.options = dict(Options.default_options) 
        self.options.update(kwargs) 
 
    def __getitem__(self, key): 
        return self.options[key] </pre>
<p>All the interesting stuff in this class happens in the <kbd>__init__</kbd> method. We have a dictionary of default options and values at the class level. The first thing the <kbd>__init__</kbd> method does is make a copy of this dictionary. We do that instead of modifying the dictionary directly, in case we instantiate two separate sets of options. (Remember, class-level variables are shared between instances of the class.) Then, <kbd>__init__</kbd> uses the <kbd>update</kbd> method on the new dictionary to change any non-default values to those supplied as keyword arguments. The <kbd>__getitem__</kbd> method simply allows us to use the new class using indexing syntax. Here's a session demonstrating the class in action:</p>
<pre><strong>&gt;&gt;&gt; options = Options(username="dusty", password="drowssap",</strong>
<strong>        debug=True)</strong>
<strong>&gt;&gt;&gt; options['debug']</strong>
<strong>True</strong>
<strong>&gt;&gt;&gt; options['port']</strong>
<strong>21</strong>
<strong>&gt;&gt;&gt; options['username']</strong>
<strong>'dusty'</strong>  </pre>
<p>We're able to access our <kbd>options</kbd> instance using dictionary indexing syntax, and the dictionary includes both default values and the ones we set using keyword arguments.</p>
<p>The keyword argument syntax can be dangerous, as it may break the <em>explicit is better than implicit</em> rule. In the preceding example, it's possible to pass arbitrary keyword arguments to the <kbd>Options</kbd> initializer to represent options that don't exist in the default dictionary. This may not be a bad thing, depending on the purpose of the class, but it makes it hard for someone using the class to discover what valid options are available. It also makes it easy to enter a confusing typo (<em>Debug</em> instead of <em>debug</em>, for example) that adds two options where only one should have existed.</p>
<p>Keyword arguments are also very useful when we need to accept arbitrary arguments to pass to a second function, but we don't know what those arguments will be. We saw this in action in <a href="ba7b3eb7-17cc-4f1c-bb74-fb7d5ee7d517.xhtml"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>When Objects Are Alike</em>, when we were building support for multiple inheritance. We can, of course, combine the variable argument and variable keyword argument syntax in one function call, and we can use normal positional and default arguments as well. The following example is somewhat contrived, but demonstrates the four types in action:</p>
<pre>import shutil<br/>import os.path<br/><br/><br/>def augmented_move(<br/>    target_folder, *filenames, verbose=False, **specific<br/>):<br/>    """Move all filenames into the target_folder, allowing<br/>    specific treatment of certain files."""<br/><br/>    def print_verbose(message, filename):<br/>        """print the message only if verbose is enabled"""<br/>        if verbose:<br/>            print(message.format(filename))<br/><br/>    for filename in filenames:<br/>        target_path = os.path.join(target_folder, filename)<br/>        if filename in specific:<br/>            if specific[filename] == "ignore":<br/>                print_verbose("Ignoring {0}", filename)<br/>            elif specific[filename] == "copy":<br/>                print_verbose("Copying {0}", filename)<br/>                shutil.copyfile(filename, target_path)<br/>        else:<br/>            print_verbose("Moving {0}", filename)<br/>            shutil.move(filename, target_path)</pre>
<p>This example processes an arbitrary list of files. The first argument is a target folder, and the default behavior is to move all remaining non-keyword argument files into that folder. Then there is a keyword-only argument, <kbd>verbose</kbd>, which tells us whether to print information on each file processed. Finally, we can supply a dictionary containing actions to perform on specific filenames; the default behavior is to move the file, but if a valid string action has been specified in the keyword arguments, it can be ignored or copied instead. Notice the ordering of the parameters in the function; first, the positional argument is specified, then the <kbd>*filenames</kbd> list, then any specific keyword-only arguments, and finally, a <kbd>**specific</kbd> dictionary to hold remaining keyword arguments.</p>
<p>We create an inner helper function, <kbd>print_verbose</kbd>, which will print messages only if the <kbd>verbose</kbd> key has been set. This function keeps code readable by encapsulating this functionality in a single location.</p>
<p>In common cases, assuming the files in question exist, this function could be called as follows:</p>
<pre><strong>&gt;&gt;&gt; augmented_move("move_here", "one", "two")</strong>  </pre>
<p>This command would move the files <kbd>one</kbd> and <kbd>two</kbd> into the <kbd>move_here</kbd> directory, assuming they exist (there's no error checking or exception handling in the function, so it would fail spectacularly if the files or target directory didn't exist). The move would occur without any output, since <kbd>verbose</kbd> is <kbd>False</kbd> by default.</p>
<p>If we want to see the output, we can call it with the help of the following command:</p>
<pre><strong>&gt;&gt;&gt; augmented_move("move_here", "three", verbose=True)</strong>
<strong>Moving three</strong>  </pre>
<p>This moves one file named <kbd>three</kbd>, and tells us what it's doing. Notice that it is impossible to specify <kbd>verbose</kbd> as a positional argument in this example; we must pass a keyword argument. Otherwise, Python would think it was another filename in the <kbd>*filenames</kbd> list.</p>
<p>If we want to copy or ignore some of the files in the list, instead of moving them, we can pass additional keyword arguments, as follows:</p>
<pre><strong>&gt;&gt;&gt; augmented_move("move_here", "four", "five", "six",</strong>
<strong>        four="copy", five="ignore")</strong>  </pre>
<p>This will move the sixth file and copy the fourth, but won't display any output, since we didn't specify <kbd>verbose</kbd>. Of course, we can do that too, and keyword arguments can be supplied in any order<span>, demonstrated as follows</span>:</p>
<pre><strong>&gt;&gt;&gt; augmented_move("move_here", "seven", "eight", "nine",</strong>
<strong>        seven="copy", verbose=True, eight="ignore")</strong>
<strong>Copying seven</strong>
<strong>Ignoring eight</strong>
<strong>Moving nine</strong>  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unpacking arguments</h1>
                </header>
            
            <article>
                
<p>There's one more nifty trick involving variable arguments and keyword arguments. We've used it in some of our previous examples, but it's never too late for an explanation. Given a list or dictionary of values, we can pass those values into a function as if they were normal positional or keyword arguments. Have a look at this code:</p>
<pre>def show_args(arg1, arg2, arg3="THREE"): 
    print(arg1, arg2, arg3) 
 
some_args = range(3) 
more_args = { 
        "arg1": "ONE", 
        "arg2": "TWO"} 
 
print("Unpacking a sequence:", end=" ") 
 
<strong>show_args(*some_args)</strong> 
print("Unpacking a dict:", end=" ") 
 
<strong>show_args(**more_args)</strong> </pre>
<p>Here's what it looks like when we run it:</p>
<pre><strong>Unpacking a sequence: 0 1 2</strong>
<strong>Unpacking a dict: ONE TWO THREE</strong>  </pre>
<p>The function accepts three arguments, one of which has a default value. But when we have a list of three arguments, we can use the <kbd>*</kbd> operator inside a function call to unpack it into the three arguments. If we have a dictionary of arguments, we can use the <kbd>**</kbd> syntax to unpack it as a collection of keyword arguments.</p>
<p>This is most often useful when mapping information that has been collected from user input or from an outside source (for example, an internet page or a text file) to a function or method call.</p>
<p>Remember our earlier example that used headers and lines in a text file to create a list of dictionaries with contact information? Instead of just adding the dictionaries to a list, we could use keyword unpacking to pass the arguments to the <kbd>__init__</kbd> method on a specially built <kbd>Contact</kbd> object that accepts the same set of arguments. See if you can adapt the example to make this work.</p>
<p>This unpacking syntax can be used in some areas outside of function calls, too. The <kbd>Options</kbd> class earlier had an <kbd>__init__</kbd> method that looked like this:</p>
<pre><strong>    def __init__(self, **kwargs):</strong><br/>        self.options = dict(Options.default_options)<br/>        self.options.update(kwargs)</pre>
<p>An even more succinct way to do this would be to unpack the two dictionaries like this:</p>
<pre>    def __init__(self, **kwargs):<br/>        self.options = {**Options.default_options, **kwargs}</pre>
<p>Because the dictionaries are unpacked in order from left to right, the resulting dictionary will contain all the default options, with any of the kwarg options replacing some of the keys. Here's an example:</p>
<pre><strong>&gt;&gt;&gt; x = {'a': 1, 'b': 2}</strong><br/><strong>&gt;&gt;&gt; y = {'b': 11, 'c': 3}</strong><br/><strong>&gt;&gt;&gt; z = {**x, **y}</strong><br/><strong>&gt;&gt;&gt; z</strong><br/><strong>{'a': 1, 'b': 11, 'c': 3}</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functions are objects too</h1>
                </header>
            
            <article>
                
<p>Programming languages that overemphasize object-oriented principles tend to frown on functions that are not methods. In such languages, you're expected to create an object to sort of wrap the single method involved. There are numerous situations where we'd like to pass around a small object that is simply called to perform an action. This is most frequently done in event-driven programming, such as graphical toolkits or asynchronous servers; we'll see some design patterns that use it in <a href="345fe617-9a90-4c59-9355-e7076759f9a4.xhtml"><span class="ChapterrefPACKT">Chapter 10</span></a>, <em>Design Patterns I</em>, and <a href="8f3d1c0f-4a63-4d06-8fb2-ad4dfe2669a3.xhtml"><span class="ChapterrefPACKT">Chapter 11</span></a>, <em>Design Patterns II</em>.</p>
<p>In Python, we don't need to wrap such methods in an object because functions already are objects! We can set attributes on functions (though this isn't a common activity), and we can pass them around to be called at a later date. They even have a few special properties that can be accessed directly. Here's yet another contrived example:</p>
<pre>def my_function():<br/>    print("The Function Was Called")<br/><br/><br/>my_function.description = "A silly function"<br/><br/><br/>def second_function():<br/>    print("The second was called")<br/><br/><br/>second_function.description = "A sillier function."<br/><br/><br/>def another_function(function):<br/>    print("The description:", end=" ")<br/>    print(function.description)<br/>    print("The name:", end=" ")<br/>    print(function.__name__)<br/>    print("The class:", end=" ")<br/>    print(function.__class__)<br/>    print("Now I'll call the function passed in")<br/>    function()<br/><br/><br/>another_function(my_function)<br/>another_function(second_function)</pre>
<p>If we run this code, we can see that we were able to pass two different functions into our third function, and get different output for each one:</p>
<pre><strong>The description: A silly function 
The name: my_function 
The class: &lt;class 'function'&gt; 
Now I'll call the function passed in 
The Function Was Called 
The description: A sillier function. 
The name: second_function 
The class: &lt;class 'function'&gt; 
Now I'll call the function passed in 
The second was called</strong> </pre>
<p>We set an attribute on the function, named <kbd>description</kbd> (not very good descriptions, admittedly). We were also able to see the function's <kbd>__name__</kbd> attribute, and to access its class, demonstrating that the function really is an object with attributes. Then, we called the function by using the callable syntax (the parentheses).</p>
<p>The fact that functions are top-level objects is most often used to pass them around to be executed at a later date, for example, when a certain condition has been satisfied. Let's build an event-driven timer that does just this:</p>
<pre>import datetime<br/>import time<br/><br/><br/>class TimedEvent:<br/>    def __init__(self, endtime, callback):<br/>        self.endtime = endtime<br/><strong>        self.callback = callback</strong><br/><br/>    def ready(self):<br/>        return self.endtime &lt;= datetime.datetime.now()<br/><br/><br/>class Timer:<br/>    def __init__(self):<br/>        self.events = []<br/><br/>    def call_after(self, delay, callback):<br/>        end_time = datetime.datetime.now() + datetime.timedelta(<br/>            seconds=delay<br/>        )<br/><br/>        self.events.append(TimedEvent(end_time, callback))<br/><br/>    def run(self):<br/>        while True:<br/>            ready_events = (e for e in self.events if e.ready())<br/>            for event in ready_events:<br/><strong>                event.callback(self)</strong><br/>                self.events.remove(event)<br/>            time.sleep(0.5)</pre>
<p>In production, this code should definitely have extra documentation using docstrings! The <kbd>call_after</kbd> method should at least mention that the <kbd>delay</kbd> parameter is in seconds, and that the <kbd>callback</kbd> function should accept one argument: the timer doing the calling.</p>
<p>We have two classes here. The <kbd>TimedEvent</kbd> class is not really meant to be accessed by other classes; all it does is store <kbd>endtime</kbd> and <kbd>callback</kbd>. We could even use a <kbd>tuple</kbd> or <kbd>namedtuple</kbd> here, but as it is convenient to give the object a behavior that tells us whether or not the event is ready to run, we use a class instead.</p>
<p>The <kbd>Timer</kbd> class simply stores a list of upcoming events. It has a <kbd>call_after</kbd> method to add a new event. This method accepts a <kbd>delay</kbd> parameter representing the number of seconds to wait before executing the callback, and the <kbd>callback</kbd> function itself: a function to be executed at the correct time. This <kbd>callback</kbd> function should accept one argument.</p>
<p>The <kbd>run</kbd> method is very simple; it uses a generator expression to filter out any events whose time has come, and executes them in order. The <em>timer</em> loop then continues indefinitely, so it has to be interrupted with a keyboard interrupt (<em><span class="KeyPACKT">Ctrl</span></em> + <span class="KeyPACKT"><em>C</em>,</span> or <em><span class="KeyPACKT">Ctrl</span></em> + <em><span class="KeyPACKT">Break</span></em>). We sleep for half a second after each iteration so as to not grind the system to a halt.</p>
<p>The important things to note here are the lines that touch callback functions. The function is passed around like any other object and the timer never knows or cares what the original name of the function is or where it was defined. When it's time to call the function, the timer simply applies the parenthesis syntax to the stored variable.</p>
<p>Here's a set of callbacks that test the timer:</p>
<pre>def format_time(message, *args):<br/>    now = datetime.datetime.now()<br/>    print(f"{now:%I:%M:%S}: {message}")<br/><br/><br/>def one(timer):<br/>    format_time("Called One")<br/><br/><br/>def two(timer):<br/>    format_time("Called Two")<br/><br/><br/>def three(timer):<br/>    format_time("Called Three")<br/><br/><br/>class Repeater:<br/>    def __init__(self):<br/>        self.count = 0<br/><br/>    def repeater(self, timer):<br/>        format_time(f"repeat {self.count}")<br/>        self.count += 1<br/>        timer.call_after(5, self.repeater)<br/><br/><br/>timer = Timer()<br/>timer.call_after(1, one)<br/>timer.call_after(2, one)<br/>timer.call_after(2, two)<br/>timer.call_after(4, two)<br/>timer.call_after(3, three)<br/>timer.call_after(6, three)<br/>repeater = Repeater()<br/>timer.call_after(5, repeater.repeater)<br/>format_time("Starting")<br/>timer.run()</pre>
<p>This example allows us to see how multiple callbacks interact with the timer. The first function is the <kbd>format_time</kbd> function. It uses the format string syntax to add the current time to the message; we'll read about them in the next chapter. Next, we create three simple callback methods that simply output the current time and a short message telling us which callback has been fired.</p>
<p>The <kbd>Repeater</kbd> class demonstrates that methods can be used as callbacks too, since they are really just functions that happen to be bound to an object. It also shows why the <kbd>timer</kbd> argument to the callback functions is useful: we can add a new timed event to the timer from inside a presently running callback. We then create a timer and add several events to it that are called after different amounts of time. Finally, we start the timer running; the output shows that events are run in the expected order:</p>
<pre><strong>02:53:35: Starting 
02:53:36: Called One 
02:53:37: Called One 
02:53:37: Called Two 
02:53:38: Called Three 
02:53:39: Called Two 
02:53:40: repeat 0 
02:53:41: Called Three 
02:53:45: repeat 1 
02:53:50: repeat 2 
02:53:55: repeat 3 
02:54:00: repeat 4</strong> </pre>
<p>Python 3.4 introduced a generic event loop architecture similar to this. We'll be discussing it later, in <a href="580eef91-bc55-4407-9475-9c31c5c4da80.xhtml"><span class="ChapterrefPACKT">Chapter 13</span></a>, <em>Concurrency</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using functions as attributes</h1>
                </header>
            
            <article>
                
<p>One of the interesting effects of functions being objects is that they can be set as callable attributes on other objects. It is possible to add or change a function to an instantiated <span>object, demonstrated as follows</span>:</p>
<pre>class A: 
    def print(self): 
        print("my class is A") 
 
def fake_print(): 
    print("my class is not A") 
 
a = A() 
a.print() 
<strong>a.print = fake_print</strong> 
a.print() </pre>
<p>This code creates a very simple class with a <kbd>print</kbd> method that doesn't tell us anything we didn't know. Then, we create a new function that tells us something we don't believe.</p>
<p>When we call <kbd>print</kbd> on an instance of the <kbd>A</kbd> class, it behaves as expected. If we then set the <kbd>print</kbd> method to point at a new function, it tells us something different:</p>
<pre><strong>my class is A 
my class is not A</strong> </pre>
<p>It is also possible to replace methods on classes instead of objects, although, in that case, we have to add the <kbd>self</kbd> argument to the parameter list. This will change the method for all instances of that object, even ones that have already been instantiated. Obviously, replacing methods like this can be both dangerous and confusing to maintain. Somebody reading the code will see that a method has been called and look up that method on the original class. But the method on the original class is not the one that was called. Figuring out what really happened can become a tricky, frustrating debugging session.</p>
<p>It does have its uses though. Often, replacing or adding methods at runtime (called <strong>monkey patching</strong>) is used in automated testing. If testing a client-server application, we may not want to actually connect to the server while testing the client; this may result in accidental transfers of funds or embarrassing test emails being sent to real people. Instead, we can set up our test code to replace some of the key methods on the object that sends requests to the server so that it only records that the methods have been called.</p>
<p>Monkey-patching can also be used to fix bugs or add features in third-party code that we are interacting with, and does not behave quite the way we need it to. It should, however, be applied sparingly; it's almost always a <em>messy hack</em>. Sometimes, though, it is the only way to adapt an existing library to suit our needs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Callable objects</h1>
                </header>
            
            <article>
                
<p>Just as functions are objects that can have attributes set on them, it is possible to create an object that can be called as though it were a function.</p>
<p>Any object can be made callable by simply giving it a <kbd>__call__</kbd> method that accepts the required arguments. Let's make our <kbd>Repeater</kbd> class, from the timer example, a little easier to use by making it a callable, as follows:</p>
<pre>class Repeater: 
    def __init__(self): 
        self.count = 0 
 
 
<strong> def __call__(self, timer):</strong> 
        format_time(f"repeat {self.count}") 
        self.count += 1 
 
        timer.call_after(5, self) 
 
timer = Timer() 
 
timer.call_after(5, Repeater()) 
format_time("{now}: Starting") 
timer.run() </pre>
<p>This example isn't much different from the earlier class; all we did was change the name of the <kbd>repeater</kbd> function to <kbd>__call__</kbd> and pass the object itself as a callable. Note that, when we make the <kbd>call_after</kbd> call, we pass the argument <kbd>Repeater()</kbd>. Those two parentheses are creating a new instance of the class; they are not explicitly calling the class. This happens later, inside the timer. If we want to execute the <kbd>__call__</kbd> method on a newly instantiated object, we'd use a rather odd syntax: <kbd>Repeater()()</kbd>. The first set of parentheses constructs the object; the second set executes the <kbd>__call__</kbd> method. If we find ourselves doing this, we may not be using the correct abstraction. Only implement the <kbd>__call__</kbd> function on an object if the object is meant to be treated like a function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case study</h1>
                </header>
            
            <article>
                
<p>To tie together some of the principles presented in this chapter, let's build a mailing list manager. The manager will keep track of email addresses categorized into named groups. When it's time to send a message, we can pick a group and send the message to all email addresses assigned to that group.</p>
<p>Now, before we start working on this project, we ought to have a safe way to test it, without sending emails to a bunch of real people. Luckily, Python has our back here; like the test HTTP server, it has a built-in <strong>Simple Mail Transfer Protocol</strong> (<strong>SMTP</strong>) server that we can instruct to capture any messages we send without actually sending them. We can run the server with the following command:</p>
<pre><strong>$python -m smtpd -n -c DebuggingServer localhost:1025</strong>  </pre>
<p>Running this command at command prompt will start an SMTP server running on port 1025 on the local machine. But we've instructed it to use the <kbd>DebuggingServer</kbd> class (this class comes with the built-in SMTP module), which, instead of sending mails to the intended recipients, simply prints them on the terminal screen as it receives them.</p>
<p>Now, before writing our mailing list, let's write some code that actually sends mail. Of course, Python supports this in the standard library, too, but it's a bit of an odd interface, so we'll write a new function to wrap it all <span>cleanly, as can be seen in the following code snipet</span>:</p>
<pre>import smtplib<br/>from email.mime.text import MIMEText<br/><br/><br/>def send_email(<br/>    subject,<br/>    message,<br/>    from_addr,<br/>    *to_addrs,<br/>    host="localhost",<br/>    port=1025,<br/>    **headers<br/>):<br/><br/>    email = MIMEText(message)<br/>    email["Subject"] = subject<br/>    email["From"] = from_addr<br/>    for header, value in headers.items():<br/>        email[header] = value<br/><br/>    sender = smtplib.SMTP(host, port)<br/>    for addr in to_addrs:<br/>        del email["To"]<br/>        email["To"] = addr<br/>        sender.sendmail(from_addr, addr, email.as_string())<br/>    sender.quit()</pre>
<p>We won't cover the code inside this method too thoroughly; the documentation in the standard library can give you all the information you need to use the <kbd>smtplib</kbd> and <kbd>email</kbd> modules effectively.</p>
<p>We've used both variable argument and keyword argument syntax in the function call. The variable argument list allows us to supply a single string in the default case of having a single <kbd>to</kbd> address, as well as permitting multiple addresses to be supplied if required. Any extra keyword arguments are mapped to email headers. This is an exciting use of variable arguments and keyword arguments, but it's not really a great interface for the person calling the function. In fact, it makes many things the programmer will want to do impossible.</p>
<p>The headers passed into the function represent auxiliary headers that can be attached to a method. Such headers might include <kbd>Reply-To</kbd>, <kbd>Return-Path</kbd>, or <em>X-pretty-much-anything</em>. But in order to be a valid identifier in Python, a name cannot include the <kbd>-</kbd> character. In general, that character represents subtraction. So, it's not possible to call a function with <kbd>Reply-To</kbd><kbd>=</kbd><kbd>my@email.com</kbd>. As often happens, it appears we were too eager to use keyword arguments because they are a shiny new tool we just learned.</p>
<p>We'll have to change the argument to a normal dictionary; this will work because any string can be used as a key in a dictionary. By default, we'd want this dictionary to be empty, but we can't make the default parameter an empty dictionary. So, we'll have to make the default argument <kbd>None</kbd>, and then set up the dictionary at the beginning of the method, as follows:</p>
<pre>def send_email(subject, message, from_addr, *to_addrs, 
        host="localhost", port=1025, headers=None): 
 
    headers = headers if headers else {}</pre>
<p>If we have our debugging SMTP server running in one terminal, we can test this code in a Python interpreter:</p>
<pre><strong>&gt;&gt;&gt; send_email("A model subject", "The message contents",</strong>
<strong> "from@example.com", "to1@example.com", "to2@example.com")</strong>  </pre>
<p>Then, if we check the output from the debugging SMTP server, we get the following:</p>
<pre><strong>---------- MESSAGE FOLLOWS ----------</strong>
<strong>Content-Type: text/plain; charset="us-ascii"</strong>
<strong>MIME-Version: 1.0</strong>
<strong>Content-Transfer-Encoding: 7bit</strong>
<strong>Subject: A model subject</strong>
<strong>From: from@example.com</strong>
<strong>To: to1@example.com</strong>
<strong>X-Peer: 127.0.0.1</strong>

<strong>The message contents</strong>
<strong>------------ END MESSAGE ------------</strong>
<strong>---------- MESSAGE FOLLOWS ----------</strong>
<strong>Content-Type: text/plain; charset="us-ascii"</strong>
<strong>MIME-Version: 1.0</strong>
<strong>Content-Transfer-Encoding: 7bit</strong>
<strong>Subject: A model subject</strong>
<strong>From: from@example.com</strong>
<strong>To: to2@example.com</strong>
<strong>X-Peer: 127.0.0.1</strong>

<strong>The message contents</strong>
<strong>------------ END MESSAGE ------------</strong>  </pre>
<p>Excellent, it has <em>sent</em> our email to the two expected addresses with subject and message contents included. Now that we can send messages, let's work on the email group management system. We'll need an object that somehow matches email addresses with the groups they are in. Since this is a many-to-many relationship (any one email address can be in multiple groups; any one group can be associated with multiple email addresses), none of the data structures we've studied seem ideal. We could try a dictionary of group names matched to a list of associated email addresses, but that would duplicate email addresses. We could also try a dictionary of email addresses matched to groups, resulting in a duplication of groups. Neither seems optimal. For fun, let's try this latter version, even though intuition tells me the groups to email address solution would be more straightforward.</p>
<p>Since the values in our dictionary will always be collections of unique email addresses, we can store them in a <kbd>set</kbd> container. We can use <kbd>defaultdict</kbd> to ensure that there is always a <kbd>set</kbd> container available for each <span>key, demonstrated as follows</span>:</p>
<pre>from collections import defaultdict<br/><br/><br/>class MailingList:<br/>    """Manage groups of e-mail addresses for sending e-mails."""<br/><br/>    def __init__(self):<br/>        self.email_map = defaultdict(set)<br/><br/>    def add_to_group(self, email, group):<br/>        self.email_map[email].add(group)</pre>
<p>Now, let's add a method that allows us to collect all the email addresses in one or more groups. This can be done by converting the list of groups to a set:</p>
<pre>def emails_in_groups(self, *groups): groups = set(groups) emails = set() for e, g in self.email_map.items(): if g &amp; groups: emails.add(e) return emails </pre>
<p>First, look at what we're iterating over: <kbd>self.email_map.items()</kbd>. This method, of course, returns a tuple of key-value pairs for each item in the dictionary. The values are sets of strings representing the groups. We split these into two variables named <kbd>e</kbd> and <kbd>g</kbd>, short for email and groups. We add the email address to the set of return values only if the passed-in groups intersect with the email address groups. The <kbd>g</kbd><kbd>&amp;</kbd><kbd>groups</kbd> syntax is a shortcut for <kbd>g.intersection(groups)</kbd>; the <kbd>set</kbd> class does this by implementing the special <kbd>__and__</kbd> method to call <kbd>intersection</kbd>.</p>
<div class="packt_tip">This code could be made a wee bit more concise using a set comprehension, which we'll discuss in <a href="0abbcae0-eb3f-4237-adda-32765e1cce32.xhtml"><span class="ChapterrefPACKT">Chapter 9</span></a>, <em>The Iterator Pattern</em>.</div>
<p>Now, with these building blocks, we can trivially add a method to our <kbd>MailingList</kbd> class that sends messages to specific groups:</p>
<pre>    def send_mailing(<br/>        self, subject, message, from_addr, *groups, headers=None<br/>    ):<br/>        emails = self.emails_in_groups(*groups)<br/>        send_email(<br/>            subject, message, from_addr, *emails, headers=headers<br/>        )</pre>
<p>This function relies on variable argument lists. As input, it takes a list of groups as variable arguments. It gets the list of emails for the specified groups and passes those as variable arguments into <kbd>send_email</kbd>, along with other arguments that were passed into this method.</p>
<p>The program can be tested by ensuring that the SMTP debugging server is running in one command prompt, and, in a second prompt, loading the code using the following:</p>
<pre><strong>$python -i mailing_list.py</strong>  </pre>
<p>Create a <kbd>MailingList</kbd> object with the help of the following command:</p>
<pre><strong>&gt;&gt;&gt; m = MailingList()</strong>  </pre>
<p>Then, create a few fake email addresses and groups, along the lines of:</p>
<pre><strong>&gt;&gt;&gt; m.add_to_group("friend1@example.com", "friends")</strong>
<strong>&gt;&gt;&gt; m.add_to_group("friend2@example.com", "friends")</strong>
<strong>&gt;&gt;&gt; m.add_to_group("family1@example.com", "family")</strong>
<strong>&gt;&gt;&gt; m.add_to_group("pro1@example.com", "professional")</strong>  </pre>
<p>Finally, use a command like this to send emails to specific groups:</p>
<pre><strong>&gt;&gt;&gt; m.send_mailing("A Party",</strong>
<strong>"Friends and family only: a party", "me@example.com", "friends",</strong>
<strong>"family", headers={"Reply-To": "me2@example.com"})</strong>  </pre>
<p>Emails to each of the addresses in the specified groups should show up in the console on the SMTP server.</p>
<p>The mailing list works fine as it is, but it's kind of useless; as soon as we exit the program, our database of information is lost. Let's modify it to add a couple of methods to load and save the list of email groups from and to a file.</p>
<p>In general, when storing structured data on disk, it is a good idea to put a lot of thought into how it is stored. One of the reasons myriad database systems exist is that if someone else has put this thought into how data is stored, you don't have to. We'll be looking at some data serialization mechanisms in the next chapter, but for this example, let's keep it simple and go with the first solution that could possibly work.</p>
<p>The data format I have in mind is to store each email address followed by a space, followed by a comma-separated list of groups. This format seems reasonable, and we're going to go with it because data formatting isn't the topic of this chapter. However, to illustrate just why you need to think hard about how you format data on disk, let's highlight a few problems with the format.</p>
<p>First, the space character is technically legal in email addresses. Most email providers prohibit it (with good reason), but the specification defining email addresses says an email can contain a space if it is in quotation marks. If we are to use a space as a sentinel in our data format, we should technically be able to differentiate between that space and a space that is part of an email. We're going to pretend this isn't true, for simplicity's sake, but real-life data encoding is full of stupid issues like this.</p>
<p>Second, consider the comma-separated list of groups. What happens if someone decides to put a comma in a group name? If we decide to make commas illegal in group names, we should add validation to enforce such naming in our <kbd>add_to_group</kbd> method. For pedagogical clarity, we'll ignore this problem too. Finally, there are many security implications we need to consider: can someone get themselves into the wrong group by putting a fake comma in their email address? What does the parser do if it encounters an invalid file?</p>
<p>The takeaway from this discussion is to try to use a data storage method that has been field tested, rather than designing our own data serialization protocols. There are a ton of bizarre edge cases you might overlook, and it's better to use code that has already encountered and fixed those edge cases.</p>
<p>But forget that. Let's just write some basic code that uses an unhealthy dose of wishful thinking to pretend this simple data format is safe<span>, demonstrated as follows</span>:</p>
<pre><strong>email1@mydomain.com group1,group2</strong>
<strong>email2@mydomain.com group2,group3</strong>  </pre>
<p>The code to do this is as follows:</p>
<pre>    def save(self):<br/>        with open(self.data_file, "w") as file:<br/>            for email, groups in self.email_map.items():<br/>                file.write("{} {}\n".format(email, ",".join(groups)))<br/><br/>    def load(self):<br/>        self.email_map = defaultdict(set)<br/>        with suppress(IOError):<br/>            with open(self.data_file) as file:<br/>                for line in file:<br/>                    email, groups = line.strip().split(" ")<br/>                    groups = set(groups.split(","))<br/>                    self.email_map[email] = groups</pre>
<p>In the <kbd>save</kbd> method, we open the file in a context manager and write the file as a formatted string. Remember the newline character; Python doesn't add that for us. The <kbd>load</kbd> method first resets the dictionary (in case it contains data from a previous call to <kbd>load</kbd>). It adds a call to the standard library <kbd>suppress</kbd> context manager, available as <kbd>from contextlib import suppress</kbd>. This context manager catches any I/O Errors and ignores them. Not the best error handling, but it's prettier than try...finally...pass.</p>
<p>Then, the load method uses the <kbd>for</kbd>...<kbd>in</kbd> syntax, which loops over each line in the file. Again, the newline character is included in the line variable, so we have to call <kbd>.strip()</kbd> to take it off. We'll learn more about such string manipulation in the next chapter.</p>
<p>Before using these methods, we need to make sure the object has a <kbd>self.data_file</kbd> attribute, which can be done by modifying <kbd>__init__</kbd> as follows:</p>
<pre>    def __init__(self, data_file): 
        self.data_file = data_file 
        self.email_map = defaultdict(set) </pre>
<p>We can test these two methods in the interpreter as follows:</p>
<pre><strong>&gt;&gt;&gt; m = MailingList('addresses.db')</strong>
<strong>&gt;&gt;&gt; m.add_to_group('friend1@example.com', 'friends')</strong>
<strong>&gt;&gt;&gt; m.add_to_group('family1@example.com', 'friends')</strong>
<strong>&gt;&gt;&gt; m.add_to_group('family1@example.com', 'family')</strong>
<strong>&gt;&gt;&gt; m.save()</strong>  </pre>
<p>The resulting <kbd>addresses.db</kbd> file contains the following lines, as expected:</p>
<pre><strong>friend1@example.com friends</strong>
<strong>family1@example.com friends,family</strong>  </pre>
<p>We can also load this data back into a <kbd>MailingList</kbd> object successfully:</p>
<pre><strong>&gt;&gt;&gt; m = MailingList('addresses.db')</strong>
<strong>&gt;&gt;&gt; m.email_map</strong>
<strong>defaultdict(&lt;class 'set'&gt;, {})</strong>
<strong>&gt;&gt;&gt; m.load()</strong>
<strong>&gt;&gt;&gt; m.email_map</strong>
<strong>defaultdict(&lt;class 'set'&gt;, {'friend2@example.com': {'friends\n'}, <br/>'family1@example.com': {'family\n'}, 'friend1@example.com': {'friends\n'}})</strong>  </pre>
<p>As you can see, I forgot to add the <kbd>load</kbd> command, and it might be easy to forget the <kbd>save</kbd> command as well. To make this a little easier for anyone who wants to use our <kbd>MailingList</kbd> API in their own code, let's provide the methods to support a context manager:</p>
<pre>    def __enter__(self): 
        self.load() 
        return self 
 
    def __exit__(self, type, value, tb): 
        self.save() </pre>
<p>These simple methods just delegate their work to load and save, but we can now write code like this in the interactive interpreter and know that all the previously stored addresses were loaded on our behalf, and that the whole list will be saved to the file when we are done:</p>
<pre><strong>&gt;&gt;&gt; with MailingList('addresses.db') as ml:</strong>
<strong>...    ml.add_to_group('friend2@example.com', 'friends')</strong>
<strong>...    ml.send_mailing("What's up", "hey friends, how's it going", 'me@example.com', <br/>       'friends')</strong>  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exercises</h1>
                </header>
            
            <article>
                
<p>If you haven't encountered the <kbd>with</kbd> statements and context managers before, I encourage you, as usual, to go through your old code, find all the places where you were opening files, and make sure they are safely closed using the <kbd>with</kbd> statement. Look for places to write your own context managers as well. Ugly or repetitive <kbd>try</kbd>...<kbd>finally</kbd> clauses are a good place to start, but you may find them useful any time you need to do before and/or after tasks in context.</p>
<p>You've probably used many of the basic built-in functions before now. We covered several of them, but didn't go into a great deal of detail. Play with <kbd>enumerate</kbd>, <kbd>zip</kbd>, <kbd>reversed</kbd>, <kbd>any</kbd>, and <kbd>all</kbd>, until you know you'll remember to use them when they are the right tool for the job. The <kbd>enumerate</kbd> function is especially important, because not using it results in some pretty ugly <kbd>while</kbd> loops.</p>
<p>Also explore some applications that pass functions around as callable objects, as well as using the <kbd>__call__</kbd> method to make your own objects callable. You can get the same effect by attaching attributes to functions or by creating a <kbd>__call__</kbd> method on an object. In which case would you use one syntax, and when would it be more suitable to use the other?</p>
<p>Our mailing list object could overwhelm an email server if there is a massive number of emails to be sent out. Try refactoring it so that you can use different <kbd>send_email</kbd> functions for different purposes. One such function could be the version we used here. A different version might put the emails in a queue to be sent by a server in a different thread or process. A third version could just output the data to the terminal, obviating the need for a dummy SMTP server. Can you construct the mailing list with a callback such that the <kbd>send_mailing</kbd> function uses whatever is passed in? It would default to the current version if no callback is supplied.</p>
<p>The relationship between arguments, keyword arguments, variable arguments, and variable keyword arguments can be a bit confusing. We saw how painfully they can interact when we covered multiple inheritance. Devise some other examples to see how they can work well together, as well as to understand when they don't.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We covered a grab bag of topics in this chapter. Each represented an important non-object-oriented feature that is popular in Python. Just because we can use object-oriented principles does not always mean we should!</p>
<p>However, we also saw that Python typically implements such features by providing a syntax shortcut to traditional object-oriented syntax. Knowing the object-oriented principles underlying these tools allows us to use them more effectively in our own classes.</p>
<p>We discussed a series of built-in functions and file I/O operations. There are a whole bunch of different syntaxes available to us when calling functions with arguments, keyword arguments, and variable argument lists. Context managers are useful for the common pattern of sandwiching a piece of code between two method calls. Even functions are objects, and, conversely, any normal object can be made callable.</p>
<p>In the next chapter, we'll learn more about string and file manipulation, and even spend some time with one of the least object-oriented topics in the standard library: regular expressions.</p>


            </article>

            
        </section>
    </body></html>