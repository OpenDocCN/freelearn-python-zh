# 第五章. 代理模式 – 控制对象访问

在上一章中，我们简要介绍了结构模式，并继续讨论了外观设计模式。我们通过 UML 图理解了外观模式的概念，并借助 Python 实现学习了它在现实世界中的应用。在常见问题解答部分，你了解了外观模式的优缺点。

在本章中，我们向前迈进一步，处理属于结构设计模式范畴下的代理模式。我们将首先了解代理模式作为一个概念，然后讨论设计模式并探讨其在软件开发中的应用。我们将通过一个示例用例并使用 Python 3.5 来实现它。

在本章中，我们将简要介绍以下内容：

+   代理和代理设计模式简介

+   代理模式的 UML 图

+   代理模式的变体

+   使用 Python 3.5 代码实现的现实世界用例

+   代理模式的优点

+   比较 - 外观模式和代理模式

+   常见问题

# 理解代理设计模式

代理，从一般意义上讲，是一个在寻求者和提供者之间进行中介的系统。寻求者是提出请求的一方，而提供者则根据请求提供资源。在互联网世界中，我们可以将此与代理服务器联系起来。当客户端（万维网中的用户）向网站提出请求时，首先连接到代理服务器，请求资源，如网页。代理服务器内部评估这个请求，将其发送到适当的服务器，并获取响应，然后将响应传递给客户端。因此，代理服务器封装了请求，提供了隐私保护，并在分布式架构中运行良好。

在设计模式语境中，`Proxy`是一个充当真实对象接口的类。对象可以是多种类型，如网络连接、内存中的大对象和文件等。简而言之，`Proxy`是一个包装器或代理对象，它包装了真实的服务对象。代理可以为它包装的对象提供额外的功能，而不改变对象的代码。代理模式的主要目的是提供一个替代或占位符对象，以便控制对真实对象的访问。

代理模式在以下多个场景中被使用：

+   它以更简单的方式表示复杂系统。例如，涉及多个复杂计算或程序的系统应该有一个更简单的接口，可以作为代理为客户端提供便利。

+   它为现有的真实对象增加了安全性。在许多情况下，客户端不允许直接访问真实对象。这是因为真实对象可能会受到恶意活动的损害。这样，代理就充当了恶意意图的盾牌，保护了真实对象。

+   它为不同服务器上的远程对象提供了一个本地接口。一个明显的例子是与分布式系统一起使用时，客户端希望在远程系统上运行某些命令，但客户端可能没有直接权限来实现这一点。因此，它联系一个本地对象（代理）来提出请求，然后代理在远程机器上执行该请求。

+   它为高内存消耗的对象提供了一个轻量级的处理方式。有时，你可能不希望在不必要的情况下加载主要对象。这是因为真实对象非常重，可能需要高资源利用率。一个经典的例子是网站上用户的个人资料图片。在列表视图中显示较小的个人资料图片会更好，但当然，你需要加载实际图片来显示用户个人资料的详细视图。

让我们用一个简单的例子来理解这个模式。考虑一个`Actor`和他的`Agent`的例子。当制片厂想要与一个`Actor`合作拍电影时，通常，他们会与`Agent`交谈，而不是直接与`Actor`交谈。根据`Actor`的日程和其他活动，`Agent`会向制片厂反馈`Actor`的可用性和对参与电影工作的兴趣。现在，在这种情况下，制片厂不是直接与`Actor`交谈，而是`Agent`作为`Proxy`来处理所有关于`Actor`的调度和支付。

以下 Python 代码实现了这个场景，其中`Actor`是`Proxy`。使用`Agent`对象来找出`Actor`是否忙碌。如果`Actor`忙碌，则调用`Actor().occupied()`方法；如果`Actor`不忙碌，则返回`Actor().available()`方法。

```py
class Actor(object):
    def __init__(self):
        self.isBusy = False

    def occupied(self):
        self.isBusy = True
        print(type(self).__name__ , "is occupied with current movie")

    def available(self):
        self.isBusy = False
        print(type(self).__name__ , "is free for the movie")

    def getStatus(self):
        return self.isBusy

class Agent(object):
    def __init__(self):
        self.principal = None

    def work(self):
        self.actor = Actor()
        if self.actor.getStatus():
            self.actor.occupied()
        else:
            self.actor.available()

if __name__ == '__main__':
    r = Agent()
    r.work()
```

代理设计模式本质上执行以下操作：

+   它为另一个对象提供了一个替代品，以便你可以控制对原始对象的访问

+   它用作层或接口以支持分布式访问

+   它增加了委派并保护真实组件免受不期望的影响

# 代理模式的 UML 类图

我们现在将借助以下 UML 图来讨论代理模式。正如我们在上一段中讨论的，代理模式有三个主要参与者：制片厂、`Agent`和`Actor`。让我们将这些放入 UML 图中，看看类是如何表现的：

![UML 类图表示代理模式](img/00017.jpeg)

如我们观察 UML 图，你会意识到这个模式有三个主要参与者：

+   `代理`：它维护一个引用，允许`Proxy`访问真实对象。它提供了一个与`Subject`相同的接口，以便`Proxy`可以替代真实主题。代理还负责创建和删除`RealSubject`。

+   `主题`：它为`RealSubject`和`Proxy`都提供了表示。由于`Proxy`和`RealSubject`实现了`Subject`，因此`Proxy`可以在期望`RealSubject`的地方使用。

+   `RealSubject`: 它定义了`Proxy`所代表的真实对象。

从数据结构的角度来看，UML 图可以表示如下：

+   `代理`: 这是一个控制对`RealSubject`类访问的类。它处理客户端的请求，并负责创建或删除`RealSubject`。

+   `Subject`/`RealSubject`: `Subject`是一个接口，定义了`RealSubject`和`Proxy`的外观。`RealSubject`是`Subject`接口的实际实现。它提供了客户端使用的真实功能。

+   `客户端`: 它访问`Proxy`类以完成工作。`Proxy`类内部控制对`RealSubject`的访问，并指导`客户端`请求的工作。

# 理解不同类型的代理

在许多常见情况下使用代理。我们在本章的开头讨论了一些。根据代理的使用方式，我们可以将它们分类为虚拟代理、远程代理、保护代理和智能代理。在本节中，让我们更深入地了解它们。

## 一个虚拟代理

在这里，你将详细了解虚拟代理。它是为那些非常难以实例化的对象提供的占位符。例如，你希望在网站上加载一个大型图像。现在这个请求将需要很长时间才能加载。通常，开发者会在网页上创建一个占位图标，提示有图像存在。然而，图像只有在用户实际点击图标时才会加载，从而节省在内存中加载大型图像的成本。因此，在虚拟代理中，实际对象是在客户端首次请求或访问对象时创建的。

## 一个远程代理

远程代理可以按以下术语定义。它提供了一个位于远程服务器或不同地址空间上的实际对象的本地表示。例如，你想要为你的应用程序构建一个监控系统，该系统具有多个 Web 服务器、数据库服务器、Celery 任务服务器、缓存服务器等。如果我们想要监控这些服务器的 CPU 和磁盘利用率，我们需要一个在监控应用程序运行上下文中可用的对象，但可以执行远程命令以获取实际参数值。在这种情况下，拥有一个远程代理对象，它是远程对象的本地表示，将有所帮助。

## 一个保护代理

你将通过以下要点更深入地了解保护代理。这个代理控制对 `RealSubject` 的敏感对象访问。例如，在当今的分布式系统世界中，Web 应用程序有多个服务协同工作以提供功能。现在，在这样的系统中，一个身份验证服务充当保护代理服务器，负责身份验证和授权。在这种情况下，代理内部帮助保护网站的核心功能，防止未识别或未经授权的代理。因此，代理对象检查调用者是否有转发请求所需的访问权限。

## 一个智能代理。

智能代理在访问对象时执行额外的操作。例如，考虑系统中有一个核心组件，它在集中位置存储状态。通常，这样的组件会被多个不同的服务调用以完成它们的工作，这可能导致共享资源的问题。而不是让服务直接调用核心组件，内置了一个智能代理，在访问之前检查真实对象是否被锁定，以确保没有其他对象可以更改它。

# 代理模式在现实世界中的应用。

我们将采用支付用例来展示代理模式在现实世界中的应用场景。假设你去了商场购物，看中了一件漂亮的牛仔衬衫。你想购买这件衬衫，但你没有足够的现金。

在过去，你会去自动柜员机取钱，然后去商场支付，甚至更早的时候，你有一张银行支票，你必须去银行取款，然后回来支付你的费用。

感谢银行，我们现在有一种叫做借记卡的东西。所以现在，当你想购买某样东西时，你向商家出示你的借记卡。当你输入你的卡信息时，钱就会从商家的账户中扣除以支付你的费用。

让我们在 Python 3.5 中开发一个应用程序并实现上述用例。我们首先从客户端开始。你去了购物中心，现在想买一件漂亮的牛仔衬衫。让我们看看 `Client` 代码是如何编写的：

+   你的行为由 `You` 类（客户端）表示。

+   为了购买衬衫，类提供了 `make_payment()` 方法。

+   特殊的 `__init__()` 方法调用代理并实例化它。

+   `make_payment()` 方法在内部调用代理的方法以完成支付。

+   如果支付成功，`__del__()` 方法会返回。

因此，代码示例如下：

```py
class You:
    def __init__(self):
        print("You:: Lets buy the Denim shirt")
        self.debitCard = DebitCard()
        self.isPurchased = None

    def make_payment(self):
        self.isPurchased = self.debitCard.do_pay()

    def __del__(self):
        if self.isPurchased:
            print("You:: Wow! Denim shirt is Mine :-)")
        else:
            print("You:: I should earn more :(")

you = You()
you.make_payment()
```

现在我们来谈谈 `Subject` 类。众所周知，`Subject` 类是一个接口，由 `Proxy` 和 `RealSubject` 实现。

+   在这个例子中，主题是 `Payment` 类。它是一个抽象基类，代表一个接口。

+   `Payment` 类有一个需要由 `Proxy` 和 `RealSubject` 实现的 `do_pay()` 方法。

让我们看看以下代码中这些方法是如何发挥作用的：

```py
from abc import ABCMeta, abstractmethod

class Payment(metaclass=ABCMeta):

    @abstractmethod
    def do_pay(self):
        pass
```

我们还开发了代表此场景中的`RealSubject`的`Bank`类：

+   `Bank`实际上会从商家的账户中从你的账户中支付。

+   `Bank`有多个方法来处理支付。`Proxy`使用`setCard()`方法将借记卡详情发送到银行。

+   `__getAccount()`方法是`Bank`的私有方法，用于获取借记卡持有人的账户详情。为了简单起见，我们强制借记卡号与账户号相同。

+   `Bank`也有`__hasFunds()`方法来查看账户持有人是否有足够的资金支付衬衫。

+   由`Bank`类（从支付接口）实现的`do_pay()`方法实际上负责根据可用资金向商家支付：

    ```py
    class Bank(Payment):

        def __init__(self):
            self.card = None
            self.account = None

        def __getAccount(self):
            self.account = self.card # Assume card number is account number
            return self.account

        def __hasFunds(self):
            print("Bank:: Checking if Account", self.__getAccount(), "has enough funds")
            return True

        def setCard(self, card):
            self.card = card

        def do_pay(self):
            if self.__hasFunds():
                print("Bank:: Paying the merchant")
                return True
            else:
                print("Bank:: Sorry, not enough funds!")
                return False
    ```

让我们现在来理解最后一部分，即`Proxy`：

+   `DebitCard`类在这里是`Proxy`。当`You`想要进行支付时，它会调用`do_pay()`方法。这是因为`You`不想去银行取款然后支付商家。

+   `DebitCard`类作为`RealSubject`、`Bank`的代理。

+   `payWithCard()`方法内部控制`RealSubject`、`Bank`类对象的创建，并将卡详情展示给`Bank`。

+   `Bank`将执行之前代码片段中描述的内部账户检查和支付：

    ```py
    class DebitCard(Payment):

        def __init__(self):
            self.bank = Bank()

        def do_pay(self):
            card = input("Proxy:: Punch in Card Number: ")
            self.bank.setCard(card)
            return self.bank.do_pay()
    ```

对于一个正面案例，当资金充足时，输出如下：

![现实世界中的代理模式](img/00018.jpeg)

对于一个负面案例——资金不足，输出如下：

![现实世界中的代理模式](img/00019.jpeg)

# 代理模式的优点

如我们所见，代理模式在现实世界中的工作方式，让我们浏览一下代理模式的优点：

+   代理可以通过缓存重对象或通常频繁访问的对象来帮助提高应用程序的性能

+   代理还授权对`RealSubject`的访问；因此，只有当权限正确时，此模式才有助于委托

+   远程代理也便于与远程服务器交互，这些服务器可以作为网络连接和数据库连接使用，并可用于监控系统

# 比较外观模式和代理模式

外观模式和代理模式都是结构型设计模式。它们在某种意义上是相似的，因为它们都在真实对象前面有一个代理/外观对象。不同之处实际上在于模式的意图或目的，如下表所示：

| 代理模式 | 外观模式 |
| --- | --- |
| 它为你提供了一个代理或占位符来控制对另一个对象的访问 | 它为你提供了一个接口，用于访问大型类子系统 |
| 代理对象具有与目标对象相同的接口，并持有对目标对象的引用 | 它最小化了子系统之间的通信和依赖关系 |
| 它充当客户端和被包装对象之间的中介 | 门面（Façade）对象提供了一个单一、简化的接口 |

# 常见问题

Q1. 装饰器模式（Decorator pattern）和代理模式（Proxy pattern）之间的区别是什么？

A: 装饰器在运行时向被装饰的对象添加行为，而代理控制对对象的访问。代理和 `RealSubject` 之间的关系是在编译时而非动态的。

Q2. 代理模式的缺点是什么？

A: 代理模式可以增加响应时间。例如，如果代理架构不佳或存在一些性能问题，它可能会增加 `RealSubject` 的响应时间。通常，这都取决于代理编写的好坏。

Q3. 客户能否独立访问 `RealSubject`？

A: 是的，但代理提供了一些特定的优势，如虚拟、远程等，因此使用代理模式是有利的。

Q4. 代理是否添加了它自己的任何功能？

A: 代理可以在不改变对象代码的情况下为 `RealSubject` 添加额外的功能。代理和 `RealSubject` 将实现相同的接口。

# 概述

我们从理解代理（Proxies）是什么开始本章。我们了解了代理的基本概念以及它在软件架构中的有效使用。然后，你学习了代理设计模式及其使用场景。我们探讨了代理设计模式如何控制对提供所需功能的真实对象的访问。

我们还通过 UML 图和 Python 3.5 的示例代码实现了该模式。

代理模式有四种不同的实现方式：虚拟代理、远程代理、保护代理和智能代理。你通过实际场景学习了这些内容。

我们比较了门面和代理设计模式，以便让你清楚地了解它们的使用场景和意图。

我们还涵盖了一个关于常见问题的部分，这将帮助你获得更多关于该模式和其可能的优势/劣势的灵感。

在本章结束时，我们现在准备在接下来的章节中学习更多的结构化模式。
