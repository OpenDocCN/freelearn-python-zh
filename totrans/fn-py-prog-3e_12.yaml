- en: '12'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '12'
- en: Decorator Design Techniques
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器设计技巧
- en: 'Python offers us many ways to create higher-order functions. In [Chapter 5](Chapter_05.xhtml#x1-1000005),
    [Higher-Order Functions](Chapter_05.xhtml#x1-1000005), we looked at two techniques:
    defining a function that accepts a function as an argument, and defining a subclass
    of `Callable`, which is either initialized with a function or called with a function
    as an argument.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python为我们提供了许多创建高阶函数的方法。在[第5章](Chapter_05.xhtml#x1-1000005)中，[高阶函数](Chapter_05.xhtml#x1-1000005)，我们探讨了两种技术：定义一个接受函数作为参数的函数，以及定义一个`Callable`的子类，它要么用函数初始化，要么用函数作为参数调用。
- en: One of the benefits of decorating functions is that it can create composite
    functions. These are single functions that embody functionality from several sources.
    It’s often helpful to have the decoration syntax as a way to express complex processing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰函数的一个好处是它可以创建复合函数。这些是包含来自多个来源的功能的单个函数。将装饰语法作为表达复杂处理的方式通常很有帮助。
- en: We can also use decorators to identify classes or functions, often building
    a registry—a collection of related definitions. We may not necessarily create
    a composite function when building a registry.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用装饰器来识别类或函数，通常构建一个注册表——相关定义的集合。在构建注册表时，我们不一定需要创建复合函数。
- en: 'In this chapter, we’ll look at the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Using a decorator to build a function based on another function
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用装饰器基于另一个函数构建函数
- en: The `wraps()` function in the `functools` module; this can help us build decorators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`functools` 模块中的 `wraps()` 函数；这可以帮助我们构建装饰器'
- en: The `update_wrapper()` function, which may be helpful in the rare case when
    we want access to the original function as well as the wrapped function
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update_wrapper()` 函数，在罕见的情况下，当我们想要访问原始函数以及包装函数时可能很有帮助'
- en: 12.1 Decorators as higher-order functions
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1 装饰器作为高阶函数
- en: The core idea of a decorator is to transform some original function into a new
    function. Used like this, a decorator creates a composite function based on the
    decorator and the original function being decorated.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器的核心思想是将某个原始函数转换成一个新的函数。这样使用时，装饰器创建了一个基于装饰器和被装饰的原始函数的复合函数。
- en: 'A decorator can be used in one of the two following ways:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器可以用以下两种方式之一使用：
- en: 'As a prefix that creates a new function with the same name as the base function,
    as follows:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为前缀，它创建了一个与基本函数同名的新函数，如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As an explicit operation that returns a new function, possibly with a new name:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一种显式操作，它返回一个新的函数，可能带有新的名称：
- en: '[PRE1]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These are two different syntaxes for the same operation. The prefix notation
    has the advantages of being tidy and succinct. The prefix location is also more
    visible to some readers. The suffix notation is explicit and slightly more flexible.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对同一操作的两种不同语法。前缀表示法具有整洁和简洁的优点。对于某些读者来说，前缀位置也更明显。后缀表示法是明确的，并且稍微灵活一些。
- en: 'While the prefix notation is common, there is one reason for using the suffix
    notation: we may not want the resulting function to replace the original function.
    We may want to execute the following command, which allows us to use both the
    decorated and the undecorated functions:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前缀表示法很常见，但使用后缀表示法也有一个原因：我们可能不希望生成的函数替换原始函数。我们可能希望执行以下命令，这允许我们同时使用装饰过的和未装饰过的函数：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will build a new function, named `new_function()`, from the original function.
    When using the `@decorator` syntax, the original function is no longer available
    for use. Indeed, once the name is reassigned to a new function object, the original
    object may have no remaining references, and the memory it once occupied may be
    eligible for reclamation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从一个原始函数构建一个新的函数，命名为`new_function()`。当使用`@decorator`语法时，原始函数就不再可用。实际上，一旦名称被重新分配给一个新的函数对象，原始对象可能就没有剩余的引用，它曾经占用的内存可能符合回收的条件。
- en: A decorator is a function that accepts a function as an argument and returns
    a function as the result. This basic description is clearly a built-in feature
    of the language. Superficially, it may seem like we can update or adjust the internal
    code structure of a function.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是一个接受函数作为参数并返回函数作为结果的函数。这种基本描述显然是语言的内建特性。表面上，这似乎意味着我们可以更新或调整函数的内部代码结构。
- en: Python doesn’t work by adjusting the internals of a function. Rather than messing
    about with the byte codes, Python uses a cleaner approach of defining a new function
    that wraps the original function. It’s easier to process the argument values or
    the result and leave the original function’s core processing alone.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Python不是通过调整函数的内部结构来工作的。Python不是通过篡改字节码来工作的，而是使用定义一个新函数来包装原始函数的更干净的方法。这样更容易处理参数值或结果，同时保持原始函数的核心处理不变。
- en: 'We have two phases of higher-order functions involved in defining a decorator;
    they are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义装饰器时，涉及两个阶段的高阶函数；它们如下：
- en: At definition time, a decorator function applies a wrapper to a base function
    and returns the new, wrapped function. The decoration process can do some one-time-only
    evaluation as part of building the decorated function. Complex default values
    can be computed, for example.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在定义时间，装饰器函数将包装器应用于基础函数，并返回新的、包装过的函数。装饰过程可以在构建装饰函数的过程中执行一些一次性评估。例如，可以计算复杂的默认值。
- en: At evaluation time, the wrapping function can (and usually does) evaluate the
    base function. The wrapping function can pre-process the argument values or post-process
    the return value (or do both). It’s also possible that the wrapping function may
    avoid calling the base function. In the case of managing a cache, for example,
    the primary reason for wrapping is to avoid expensive calls to the base function.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在评估时间，包装函数可以（并且通常确实）评估基础函数。包装函数可以预先处理参数值或后处理返回值（或者两者都做）。也有可能包装函数可能避免调用基础函数。例如，在管理缓存的情况下，包装的主要原因是避免对基础函数进行昂贵的调用。
- en: 'Here’s an example of a decorator:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个装饰器的示例：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We almost always want to use the `@wraps` decorator when creating our own decorators
    to ensure that the decorated function retains the attributes of the original function.
    Copying the `__name__` and `__doc__` attributes, for example, ensures that the
    resulting decorated function has the name and docstring of the original function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎总是希望在创建自己的装饰器时使用`@wraps`装饰器，以确保装饰的函数保留了原始函数的属性。例如，复制`__name__`和`__doc__`属性，确保生成的装饰函数具有原始函数的名称和文档字符串。
- en: The resulting composite function, defined as the `null_wrapper()` function in
    the definition of the decorator, is also a type of higher-order function that
    combines the original function, the `function` callable object, in an expression
    that preserves the `None` values. Within the resulting `null_wrapper()` function,
    the original `function` callable object is not an explicit argument; it is a free
    variable that will get its value from the context in which the `null_wrapper()`
    function is defined.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的复合函数，定义为装饰器定义中的`null_wrapper()`函数，也是一种高阶函数，它将原始函数、`function`可调用对象组合在一个表达式中，同时保留`None`值。在生成的`null_wrapper()`函数内部，原始的`function`可调用对象不是一个显式的参数；它是一个自由变量，其值将从`null_wrapper()`函数定义的上下文中获取。
- en: 'The `@nullable` decorator’s return value is the newly minted function. It will
    be assigned to the original function’s name. It’s important that decorators only
    return functions and they don’t attempt to process data. Decorators use meta-programming:
    code that creates more code. The resulting `null_wrapper()` function is the function
    intended to process the application’s data.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`@nullable`装饰器的返回值是新铸造的函数。它将被分配给原始函数的名称。重要的是装饰器只返回函数，并且它们不尝试处理数据。装饰器使用元编程：创建更多代码的代码。生成的`null_wrapper()`函数是打算处理应用程序数据的函数。'
- en: The `typing` module makes it particularly easy to describe the types of null-aware
    function and null-aware result, using the `Optional` type definitions or the `|`
    type operator. The definition `float`` |`` None` or `Optional[float]` means `Union[float,`` None]`;
    either a `None` object or a `float` object match the type hint’s description.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing`模块使得使用`Optional`类型定义或`|`类型运算符来描述null感知函数和null感知结果变得特别容易。定义`float|None`或`Optional[float]`意味着`Union[float,
    None]`；要么是一个`None`对象，要么是一个`float`对象，都符合类型提示的描述。'
- en: 'As an example, we’ll assume we have a scaling function that converts input
    data from nautical miles to statute miles. This might be used with geolocation
    data that did calculations in nautical miles. The essential conversion from nautical
    miles, n, to statute miles, s, is a multiplication: s = 1.15078 × n.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们假设我们有一个缩放函数，它将输入数据从海里转换为英里。这可以与在英里中进行计算的地理定位数据一起使用。从海里（n）到英里（s）的基本转换是一个乘法：s
    = 1.15078 × n。
- en: 'We can apply our `@nullable` decorator to create a composite function as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的`@nullable`装饰器应用于创建一个组合函数，如下所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will create a function, `st_miles()`, which is a null-aware version of
    a small mathematical operation. The decoration process returns a version of the
    `null_wrapper()` function that invokes the original `st_miles()` function. This
    result will be named `st_miles()` and will have the composite behavior of both
    the wrapper and the original base function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个函数`st_miles()`，它是小数学运算的空值感知版本。装饰过程返回一个调用原始`st_miles()`函数的`null_wrapper()`函数版本。这个结果将被命名为`st_miles()`，并将具有包装器和原始基本函数的复合行为。
- en: 'We can use this composite `st_miles()` function as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个组合的`st_miles()`函数如下所示：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We’ve applied the function to a collection of data values. The `None` value
    politely leads to a `None` result. There was no exception processing involved.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将函数应用于一组数据值。`None`值礼貌地导致`None`结果。没有涉及异常处理。
- en: 'As a second example, here’s how we can create a null-aware rounding function
    using the same decorator:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二个例子，以下是使用相同的装饰器创建一个空值感知的四舍五入函数的方法：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This function is a partial application of the `round()` function, wrapped to
    be null-aware. We can use this `nround4()` function to create a better test case
    for our `st_miles()` function as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是`round()`函数的部分应用，被包装成空值感知的形式。我们可以使用这个`nround4()`函数来为我们的`st_miles()`函数创建一个更好的测试用例，如下所示：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This rounded result will be independent of any platform considerations. It’s
    very handy for `doctest` testing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个四舍五入的结果将不受任何平台考虑的影响。这对于`doctest`测试来说非常方便。
- en: 'As an alternative implementation, we could also create these null-aware functions
    using the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一种实现方式，我们也可以使用以下代码创建这些空值感知函数：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We didn’t use the `@nullable` decorator in front of the function definition
    `def` statement. Instead, we applied the `nullable()` function to another function
    defined as a lambda form. These expressions have the same effect as a decorator
    in front of a function definition.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有在函数定义`def`语句前使用`@nullable`装饰器。相反，我们将`nullable()`函数应用于另一个定义为lambda形式的函数。这些表达式与函数定义前使用装饰器具有相同的效果。
- en: Note how it is challenging to apply type hints to lambda forms. The variable
    `nround4_2` is given a type hint of `Callable` with an argument list of `float`` |`` None`
    and a return type of `float`` |`` None`. The use of the `Callable` hint is appropriate
    only for positional arguments. In cases where there will be keyword arguments
    or other complexities, see [https://mypy.readthedocs.io/en/stable/additional_features.html?highlight=callable#extended-callable-types](https://mypy.readthedocs.io/en/stable/additional_features.html?highlight=callable#extended-callable-types).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到将类型提示应用于lambda表达式是有挑战性的。变量`nround4_2`被赋予了一个`Callable`类型的提示，其参数列表为`float`或`None`，返回类型为`float`或`None`。`Callable`提示仅适用于位置参数。在存在关键字参数或其他复杂情况时，请参阅[https://mypy.readthedocs.io/en/stable/additional_features.html?highlight=callable#extended-callable-types](https://mypy.readthedocs.io/en/stable/additional_features.html?highlight=callable#extended-callable-types)。
- en: The `@nullable` decorator makes an assumption that the decorated function is
    unary. We would need to revisit this design to create a more general-purpose null-aware
    decorator that works with arbitrary collections of arguments.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`@nullable`装饰器假设被装饰的函数是一元函数。我们需要重新审视这个设计，以创建一个更通用的空值感知装饰器，它可以与任意参数集合一起工作。'
- en: In [Chapter 13](Chapter_13.xhtml#x1-26600013), [The PyMonad Library](Chapter_13.xhtml#x1-26600013),
    we’ll look at an alternative approach to this problem of tolerating the `None`
    values. The PyMonad library defines a `Maybe` class of objects, which may have
    a proper value or may be the `None` value.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](Chapter_13.xhtml#x1-26600013)，[PyMonad库](Chapter_13.xhtml#x1-26600013)中，我们将探讨解决容忍`None`值问题的另一种方法。PyMonad库定义了一个`Maybe`类，其对象可能具有适当的值或可能是`None`值。
- en: 12.1.1 Using the functools update_wrapper() function
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.1 使用`functools.update_wrapper()`函数
- en: The `@wraps` decorator applies the `update_wrapper()` function to preserve a
    few attributes of a wrapped function. In general, this does everything we need
    by default. This function copies a specific list of attributes from the original
    function to the resulting function created by a decorator.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`@wraps`装饰器将`update_wrapper()`函数应用于保留被包装函数的一些属性。通常，默认情况下它就完成了我们所需的所有事情。这个函数从原始函数复制一系列特定的属性到由装饰器创建的结果函数中。'
- en: 'The `update_wrapper()` function relies on a global variable defined in the
    `functools` module to determine what attributes to preserve. The `WRAPPER_ASSIGNMENTS`
    variable defines the attributes that are copied by default. The default value
    is this list of attributes to copy:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`update_wrapper()`函数依赖于在`functools`模块中定义的全局变量来确定要保留哪些属性。`WRAPPER_ASSIGNMENTS`变量定义了默认情况下复制的属性。默认值是以下要复制的属性列表：'
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It’s difficult to make meaningful modifications to this list. The internals
    of the `def` statement aren’t open to simple modification or change. This detail
    is mostly interesting as a piece of reference information.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个列表进行有意义的修改是困难的。`def`语句的内部结构不允许简单的修改或更改。这个细节主要作为参考信息是有趣的。
- en: If we’re going to create callable objects, then we may have a class that provides
    some additional attributes as part of the definition. This could lead to a situation
    where a decorator must copy these additional attributes from the original wrapped
    callable object to the wrapping function being created. However, it seems simpler
    to make these kinds of changes through object-oriented class design, rather than
    exploit tricky decorator techniques.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要创建可调用对象，那么我们可能有一个类，它作为定义的一部分提供一些额外的属性。这可能导致装饰器必须从原始包装的可调用对象复制这些额外的属性到正在创建的包装函数。然而，通过面向对象类设计进行这些类型的更改似乎更简单，而不是利用复杂的装饰器技术。
- en: 12.2 Cross-cutting concerns
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2 横切关注点
- en: One general principle behind decorators is to allow us to build a composite
    function from the decorator and the original function to which the decorator is
    applied. The idea is to have a library of common decorators that can provide implementations
    for common concerns.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器背后的一个基本原则是允许我们通过装饰器和应用装饰器的原始函数来构建一个组合函数。想法是拥有一个常见的装饰器库，它可以提供对常见问题的实现。
- en: We often call these cross-cutting concerns because they apply across several
    functions. These are the sorts of things that we would like to design once through
    a decorator and have them applied in relevant classes throughout an application
    or a framework.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常将这些横切关注点称为跨多个函数应用。这些是我们希望通过装饰器一次性设计，并在整个应用程序或框架中的相关类中应用的事情。
- en: 'Concerns that are often centralized as decorator definitions include the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通常作为装饰器定义集中化的关注点包括以下内容：
- en: Logging
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志
- en: Auditing
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计
- en: Security
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Handling incomplete data
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理不完整数据
- en: A logging decorator, for example, may write standardized messages to the application’s
    log file. An audit decorator may write details surrounding a database update.
    A security decorator may check some runtime context to be sure that the login
    user has the necessary permissions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个日志装饰器可能会将标准消息写入应用程序的日志文件。一个审计装饰器可能会写入数据库更新的详细信息。一个安全装饰器可能会检查一些运行时上下文，以确保登录用户具有必要的权限。
- en: Our example of a null-aware wrapper for a function is a cross-cutting concern.
    In this case, we’d like to have a number of functions handle the `None` values
    by returning the `None` values instead of raising an exception. In applications
    where data is incomplete, we may need to process rows in a simple, uniform way
    without having to write lots of distracting `if` statements to handle missing
    values.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对函数的空值感知包装器的示例是一个横切关注点。在这种情况下，我们希望有多个函数处理`None`值，通过返回`None`值而不是抛出异常。在数据不完整的应用程序中，我们可能需要以简单、统一的方式处理行，而无需编写大量分散注意力的`if`语句来处理缺失值。
- en: 12.3 Composite design
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3 组合设计
- en: 'The common mathematical notation for a composite function looks as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 组合函数的常见数学表示如下：
- en: '![f ∘g(x) = f(g(x)) ](img/file111.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![f ∘g(x) = f(g(x)) ](img/file111.jpg)'
- en: The idea is that we can define a new function, f ∘g(x), that combines two other
    functions, f(y) and g(x).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是我们可以定义一个新的函数，f ∘g(x)，它结合了两个其他函数，f(y)和g(x)。
- en: 'Python’s multiple-line definition of a composition function can be done through
    the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Python可以通过以下代码实现组合函数的多行定义：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The resulting function can be essentially equivalent to f ∘ g(x). The `@f_deco`
    decorator must define and return the composite function by merging an internal
    definition of f(y) with the provided base function, g(x).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 结果函数可以基本上等同于 f ∘ g(x)。`@f_deco`装饰器必须通过合并f(y)的内部定义与提供的基函数g(x)来定义并返回组合函数。
- en: 'The implementation details show that Python actually provides a slightly more
    complex kind of composition. The structure of a wrapper makes it helpful to think
    of Python decorator composition as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 实现细节显示Python实际上提供了一种稍微复杂一点的组合类型。包装器的结构使得将Python装饰器组合视为以下内容是有帮助的：
- en: '![ ( ) w ∘g(x) = (wβ ∘g ∘w α)(x) = w β g(w α(x )) ](img/file112.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![ ( ) w ∘g(x) = (wβ ∘g ∘w α)(x) = w β g(w α(x )) ](img/file112.jpg)'
- en: A decorator applied to some application function, g(x), will include a wrapper
    function, w(y), that has two parts. One portion of the wrapper, w[α](y), applies
    to the arguments of the base function; the other portion, w[β](z), applies to
    the result of the base function.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 应用到某个应用函数g(x)的装饰器将包括一个包装函数w(y)，它有两个部分。包装器的一部分，w[α](y)，应用于基本函数的参数；另一部分，w[β](z)，应用于基本函数的结果。
- en: 'Here’s a slightly more concrete idea, shown as a `@stringify` decorator definition:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个稍微更具体的概念，以`@stringify`装饰器定义的形式展示：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This decorator inserts conversions from string to integer, and integer back
    to string. Concealing the details of string processing may be helpful when working
    with CSV files, where the content is always string data.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器插入从字符串到整数的转换，以及从整数回到字符串的转换。在处理CSV文件时，内容总是字符串数据，隐藏字符串处理的细节可能是有帮助的。
- en: 'We can apply this decorator to a function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个装饰器应用于一个函数：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This shows the two places to inject additional processing before as well as
    after the original function. This emphasizes an important distinction between
    the abstract concept of functional composition and the Python implementation:
    it’s possible that a decorator can create either f(g(x)), or g(f(x)), or a more
    complex f[β]![(](img/file113.jpg)g(f[α](x))![)](img/file114.jpg). The syntax of
    decoration doesn’t describe which kind of composition will be created.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了在原始函数之前以及之后注入额外处理的两处地方。这强调了函数组合的抽象概念与Python实现之间的重要区别：装饰器可以创建f(g(x))、g(f(x))或更复杂的f[β]![(](img/file113.jpg)g(f[α](x))![)](img/file114.jpg)。装饰语的语法没有描述将创建哪种组合。
- en: The real value of decorators stems from the way any Python statement can be
    used in the wrapping function. A decorator can use `if` or `for` statements to
    transform a function into something used conditionally or iteratively. In the
    next section, the examples will leverage the `try:` statement to perform an operation
    with a standard recovery from bad data. There are many things that can be done
    within this general framework.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器的真正价值在于任何Python语句都可以用在包装函数中。装饰器可以使用`if`或`for`语句将一个函数转换成条件或迭代使用的函数。在下一节中，示例将利用`try:`语句执行带有标准错误恢复的操作。在这个通用框架内可以完成很多事情。
- en: A great deal of functional programming follows the essential f ∘ g(x) design
    pattern. Defining a composite from two smaller functions can help to summarize
    complex processing. In other cases, it can be more informative to keep the two
    functions separate.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 大量的函数式编程遵循f ∘ g(x)的基本设计模式。从两个较小的函数定义一个组合可以帮助总结复杂的处理。在其他情况下，保持两个函数分开可能更有信息量。
- en: It’s easy to create composites of the common higher-order functions, such as
    `map()`, `filter()`, and `functools.reduce()`. Because these functions are relatively
    simple, a composite function is often easy to describe, and can help to make the
    code more expressive.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 创建常见的高阶函数的组合，如`map()`、`filter()`和`functools.reduce()`，很容易。因为这些函数相对简单，组合函数通常很容易描述，并且可以帮助使代码更具表达性。
- en: For example, an application may include `map(f,`` map(g,`` x))`. It may be more
    clear to create a composite function and use a `map(f_g,`` x)` expression to describe
    applying a composite to a collection. We can use `f_g`` =`` lambda`` x:`` f(g(x))`
    to help explain a complex application as a composition of simpler functions. To
    make sure the type hints are correct, we’ll almost always want to define individual
    functions with the `def` statement.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，一个应用程序可能包括`map(f, map(g, x))`。创建一个组合函数并使用`map(f_g, x)`表达式来描述将组合应用于集合可能更清晰。我们可以使用`f_g
    = lambda x: f(g(x))`来帮助解释一个复杂的应用作为更简单函数的组合。为了确保类型提示正确，我们几乎总是想使用`def`语句定义单独的函数。'
- en: 'It’s important to note that there’s no real performance advantage to either
    technique. The `map()` function is lazy: with two `map()` functions, one item
    will be taken from the source collection, `x`, processed by the `g()` function,
    and then processed by the `f()` function. With a single `map()` function, an item
    will be taken from the source collection, `x`, and then processed by the `f_g()`
    composite function; the memory use is the same.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这两种技术都没有真正的性能优势。`map()` 函数是惰性的：使用两个 `map()` 函数时，一个项目将从源集合 `x` 中取出，由
    `g()` 函数处理，然后由 `f()` 函数处理。使用单个 `map()` 函数时，一个项目将从源集合 `x` 中取出，然后由 `f_g()` 合成函数处理；内存使用相同。
- en: In [Chapter 13](Chapter_13.xhtml#x1-26600013), [The PyMonad Library](Chapter_13.xhtml#x1-26600013),
    we’ll look at an alternative approach to this problem of creating composite functions
    from individual curried functions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 13 章](Chapter_13.xhtml#x1-26600013) [《PyMonad 库》](Chapter_13.xhtml#x1-26600013)中，我们将探讨从单个柯里化函数创建复合函数的替代方法。
- en: 12.3.1 Preprocessing bad data
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.1 坏数据处理预处理
- en: One cross-cutting concern in some exploratory data analysis applications is
    how to handle numeric values that are missing or cannot be parsed. We often have
    a mixture of `float`, `int`, `datetime.datetime`, and `decimal.Decimal` currency
    values that we’d like to process with some consistency.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些探索性数据分析应用中，一个跨领域的关注点是如何处理缺失或无法解析的数值。我们经常遇到混合了 `float`、`int`、`datetime.datetime`
    和 `decimal.Decimal` 货币值，我们希望以某种一致性对这些值进行处理。
- en: 'In other contexts, we have not applicable or not available placeholders instead
    of data values; these shouldn’t interfere with the main thread of the calculation.
    It’s often handy to allow the not applicable values to pass through an expression
    without raising an exception. We’ll focus on three bad-data conversion functions:
    `bd_int()`, `bd_float()`, and `bd_decimal()`. We’ve left `bd_datetime()` as an
    exercise for the reader.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，我们用不可用或不可用的占位符代替数据值；这些不应该干扰计算的主线。允许不可用值在表达式通过而不引发异常通常是很有用的。我们将重点关注三个不良数据转换函数：`bd_int()`、`bd_float()`
    和 `bd_decimal()`。我们将 `bd_datetime()` 留作读者的练习。
- en: 'The composite feature we’re adding will be defined first. Then we’ll use this
    to wrap a built-in conversion function. Here’s a simple bad-data decorator:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要添加的复合功能将首先定义。然后我们将使用这个功能来包装内置的转换函数。以下是一个简单的坏数据装饰器：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The decorator, `@bad_data`, wraps a given conversion function, with the parameter
    name `function`, to try a second conversion in the event the first conversion
    fails. The `ValueError` and `decimal.InvalidOperation` exceptions are generally
    indicators of data that has an invalid format: bad data. The second conversion
    will be attempted after `","` characters are removed. This wrapper passes the
    `*args` and `**kwargs` parameters into the wrapped function. This ensures that
    the wrapped functions can have additional argument values provided.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器 `@bad_data` 包装了一个给定的转换函数，参数名为 `function`，以便在第一次转换失败时尝试第二次转换。`ValueError`
    和 `decimal.InvalidOperation` 异常通常是数据格式无效的指标：不良数据。在移除 `","` 字符后，将尝试第二次转换。这个包装器将
    `*args` 和 `**kwargs` 参数传递给包装的函数。这确保了包装的函数可以接受额外的参数值。
- en: The type variable `NumT` is bound to the original return type of the base function
    being wrapped, the value of the `function` parameter. The decorator is defined
    to return a function with the same type, `NumT`. This type has an upper bound
    of the union of `float` and `Decimal` types. This boundary permits objects that
    are a subclass of `float` or `Decimal`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 类型变量 `NumT` 绑定到被包装的基本函数的原返回类型，即 `function` 参数的值。装饰器被定义为返回具有相同类型 `NumT` 的函数。此类型有
    `float` 和 `Decimal` 类型的并集作为上限。这个边界允许是 `float` 或 `Decimal` 的子类的对象。
- en: The type hints for complex decorator design are evolving rapidly. In particular,
    PEP 612 ( [https://peps.python.org/pep-0612/](https://peps.python.org/pep-0612/))
    defines some new constructs that can allow even more flexible type hints. For
    decorators that do not make any type changes, we can use generic parameter variables
    like `ParamSpec` to capture the actual parameters of the function being decorated.
    This lets us write generic decorators without having to wrestle with the details
    of the type hints of the functions being decorated. We’ll note where PEP 612’s
    `ParamSpec` and `Concatenate` will come in useful. Be sure to see the PEP 612
    examples when designing generic decorators.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂装饰器设计的类型提示正在迅速演变。特别是，PEP 612 ([https://peps.python.org/pep-0612/](https://peps.python.org/pep-0612/))
    定义了一些新的结构，这些结构可以允许更加灵活的类型提示。对于不进行任何类型更改的装饰器，我们可以使用泛型参数变量，如 `ParamSpec`，来捕获被装饰函数的实际参数。这使得我们能够编写泛型装饰器，而无需与被装饰函数的类型提示细节纠缠。我们将指出PEP
    612的 `ParamSpec` 和 `Concatenate` 将在何处有用。在设计泛型装饰器时，务必查看PEP 612的示例。
- en: 'We can use this wrapper to create bad-data-sensitive functions as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个包装器创建对不良数据敏感的函数，如下所示：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will create a suite of functions that can do conversions of good data as
    well as a limited amount of data cleansing to handle specific kinds of bad data.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一系列函数，可以进行良好数据的转换，以及有限的数据清洗来处理特定类型的不良数据。
- en: It can be difficult to write type hints for some kinds of callable objects.
    For example, the `int()` function has optional keyword arguments, with their own
    complex type hints. Our decorator summarizes these keyword arguments as `**kwargs:`` Any`.
    Ideally, a `ParamSpec` can be used to capture the details of the parameters for
    the function being wrapped. See PEP 612 ( [https://peps.python.org/pep-0612/](https://peps.python.org/pep-0612/))
    for guidance on creating complex type signatures for callable objects.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '为某些类型的可调用对象编写类型提示可能很困难。例如，`int()` 函数有可选的关键字参数，它们有自己的复杂类型提示。我们的装饰器将这些关键字参数总结为
    `**kwargs: Any`。理想情况下，可以使用 `ParamSpec` 来捕获被包装函数的参数细节。有关为可调用对象创建复杂类型签名的指导，请参阅PEP
    612 ([https://peps.python.org/pep-0612/](https://peps.python.org/pep-0612/))).'
- en: 'The following are some examples of using the `bd_int()` function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用 `bd_int()` 函数的一些示例：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We’ve applied the `bd_int()` function to a string that converted neatly and
    a string with the specific type of punctuation that we’ll tolerate. We’ve also
    shown that we can provide additional parameters to each of these conversion functions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将 `bd_int()` 函数应用于转换整洁的字符串以及具有我们所能容忍的特定类型的标点符号的字符串。我们还展示了我们可以为这些转换函数中的每一个提供额外的参数。
- en: We may like to have a more flexible decorator. One feature that we may like
    to add is the ability to handle a variety of data scrubbing alternatives. Simple
    `","` removal isn’t always what we need. We may also need to remove `$` or ° symbols,
    too. We’ll look at more sophisticated, parameterized decorators in the next section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望有一个更灵活的装饰器。我们可能希望添加的一个特性是处理各种数据清理替代方案的能力。简单的 `","` 移除并不总是我们所需要的。我们可能还需要移除
    `$` 或 ° 符号。我们将在下一节中查看更复杂、参数化的装饰器。
- en: 12.4 Adding a parameter to a decorator
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4 向装饰器添加参数
- en: A common requirement is to customize a decorator with additional parameters.
    Rather than simply creating a composite f ∘ g(x), we can do something a bit more
    complex. With parameterized decorators, we can create ![(](img/file115.jpg)f(c)
    ∘ g![)](img/file116.jpg)(x). We’ve applied a parameter, c, as part of creating
    the wrapper, f(c). This parameterized composite function, f(c) ∘ g, can then be
    applied to the actual data, x.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的需求是使用额外的参数自定义装饰器。而不是简单地创建一个复合函数 f ∘ g(x)，我们可以做点更复杂的事情。使用参数化装饰器，我们可以创建 ![(](img/file115.jpg)f(c)
    ∘ g![)](img/file116.jpg)(x)。我们已将参数 c 作为创建包装器 f(c) 的一部分应用。然后，这个参数化复合函数 f(c) ∘ g
    可以应用于实际数据 x。
- en: 'In Python syntax, we can write it as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python语法中，我们可以这样写：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There are two steps to this. The first step applies the parameter to an abstract
    decorator to create a concrete decorator. Then the concrete decorator, the parameterized
    `deco(arg)` function, is applied to the base function definition to create the
    decorated function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这有两个步骤。第一步是将参数应用于一个抽象装饰器以创建一个具体装饰器。然后，将具体的参数化 `deco(arg)` 函数应用于基础函数定义以创建装饰函数。
- en: 'The effect is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 其效果如下：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The parameterized decorator worked by doing the following three things:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化装饰器通过以下三个步骤工作：
- en: Applied the abstract decorator, `deco()`, to its argument, `arg`, to create
    a concrete decorator, `concrete_deco()`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将抽象装饰器 `deco()` 应用于其参数 `arg`，以创建具体的装饰器 `concrete_deco()`。
- en: Defined the base function, `func()`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义了基础函数，`func()`。
- en: Applied the concrete decorator, `concrete_deco()`, to the base function to create
    the decorated version of the function; in effect, it’s `deco(arg)(func)`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将具体的装饰器 `concrete_deco()` 应用于基础函数以创建函数的装饰版本；实际上，它是 `deco(arg)(func)`。
- en: 'A decorator with arguments involves indirect construction of the final function.
    We seem to have moved beyond merely higher-order functions into something even
    more abstract: higher-order functions that create higher-order functions.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 带参数的装饰器涉及到最终函数的间接构造。我们似乎已经超越了仅仅是一阶函数，进入了一个更加抽象的领域：创建更高阶函数的一阶函数。
- en: 'We can expand our bad-data-aware decorator to create a slightly more flexible
    conversion. We’ll define a `@bad_char_remove` decorator that can accept parameters
    of characters to remove. The following is a parameterized decorator:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的 bad-data-aware 装饰器扩展以创建一个稍微更灵活的转换。我们将定义一个 `@bad_char_remove` 装饰器，它可以接受要移除的字符参数。以下是一个参数化的装饰器：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A parameterized decorator has two internal function definitions:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化装饰器有两个内部函数定义：
- en: The concrete decorator; in this example, the `cr_decorator()` function. This
    will have the free variable, `bad_chars`, bound to the function being built. The
    concrete decorator is then returned; it will later be applied to a base function.
    When applied, the decorator will return a new function wrapped inside the `wrap_char_remove()`
    function. This new `wrap_char_remove()` function has type hints with a type variable,
    `T`, that claim the wrapped function’s type will be preserved by the new `wrap_char_remove()`
    function.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体的装饰器；在这个例子中，是 `cr_decorator()` 函数。这将有一个名为 `bad_chars` 的自由变量绑定到正在构建的函数上。具体的装饰器随后被返回；它将被应用于基础函数。当应用时，装饰器将返回一个新函数，该函数被
    `wrap_char_remove()` 函数包装。这个新的 `wrap_char_remove()` 函数具有类型提示，其中包含类型变量 `T`，它声称被包装的函数的类型将被新的
    `wrap_char_remove()` 函数保留。
- en: The decorating wrapper, the `wrap_char_remove()` function in this example, will
    replace the original function with a wrapped version. Because of the `@wraps`
    decorator, the `__name__` (and other attributes) of the new function will be replaced
    with the name of the base function being wrapped.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰包装器，在这个例子中是 `wrap_char_remove()` 函数，将替换原始函数为包装版本。由于 `@wraps` 装饰器，新函数的 `__name__`（和其他属性）将被替换为被包装的基础函数的名称。
- en: The overall decorator, the `@bad_char_remove` function in this example, has
    the job of binding the parameter, named `bad_chars`, to a function and returning
    the concrete decorator. The type hint clarifies the return value is a `Callable`
    object that transforms a `Callable` function into another `Callable` function.
    The language rules will then apply the concrete decorator to the following function
    definition.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 整体装饰器，在这个例子中是 `@bad_char_remove` 函数，其任务是绑定参数 `bad_chars` 到一个函数，并返回具体的装饰器。类型提示澄清了返回值是一个
    `Callable` 对象，它将一个 `Callable` 函数转换成另一个 `Callable` 函数。然后语言规则将具体装饰器应用于以下函数定义。
- en: The internal `clean_list()` function is used by the `@bad_char_remove` decorator
    to remove all characters in a given argument value. This is defined as a recursion
    to keep it very short. It can be optimized into an iteration if necessary. We’ve
    left that optimization as an exercise for the reader.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 内部 `clean_list()` 函数被 `@bad_char_remove` 装饰器用来移除给定参数值中的所有字符。这被定义为递归以保持其非常简短。如果需要，它可以优化为迭代。我们将这个优化留作读者的练习。
- en: 'We can use the `@bad_char_remove` decorator to create conversion functions
    as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `@bad_char_remove` 装饰器创建转换函数，如下所示：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We’ve used our `@bad_char_remove` decorator to wrap a base `currency()` function.
    The essential feature of the `currency()` function is a reference to the `decimal.Decimal`
    constructor.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用我们的 `@bad_char_remove` 装饰器包装了一个基础 `currency()` 函数。`currency()` 函数的基本特征是对
    `decimal.Decimal` 构造函数的引用。
- en: 'This `currency()` function will now handle some variant data formats:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `currency()` 函数现在将处理一些变体数据格式：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can now process input data using a relatively simple `map(currency,`` row)`
    expression to convert source data from strings to usable `Decimal` values. The
    `try:`/`except:` error-handling has been isolated to a function that we’ve used
    to build a composite conversion function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用相对简单的 `map(currency, row)` 表达式来处理输入数据，将源数据从字符串转换为可用的 `Decimal` 值。`try:`/`except:`
    错误处理已被隔离到一个我们用来构建复合转换函数的函数中。
- en: We can use a similar design to create null-tolerant functions. These functions
    would use a similar `try:`/`except:` wrapper, but would return the `None` values.
    This design variant is left as an exercise for the reader.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似的设计来创建容错函数。这些函数将使用类似的 `try:`/`except:` 包装器，但会返回 `None` 值。这种设计变体留给读者作为练习。
- en: This decorator is limited to conversion functions that apply to a single string,
    and have a type hint like `Callable[[str],`` T]`. For generic decorators, it helps
    to follow the examples in PEP-612 and use the `ParamSpec` and `Concatenate` type
    hints to broaden the domain of the decorators. Because we’re interested in applying
    the internal `clean_list()` function to the first argument value, we can look
    at the conversion function as `Callable[Concatenate[str,`` P],` `T]`. We would
    define the first parameter as a string, and use a `ParamSpec`, `P`, to represent
    all other parameters of the conversion function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此装饰器仅限于应用于单个字符串的转换函数，并且具有类似于 `Callable[[str], T]` 的类型提示。对于泛型装饰器，参考 PEP-612 中的示例，并使用
    `ParamSpec` 和 `Concatenate` 类型提示来扩展装饰器的应用范围是有帮助的。因为我们感兴趣的是将内部 `clean_list()` 函数应用于第一个参数值，所以我们可以将转换函数视为
    `Callable[Concatenate[str, P], T]`。我们将定义第一个参数为字符串，并使用 `ParamSpec`，`P` 来表示转换函数的所有其他参数。
- en: 12.5 Implementing more complex decorators
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5 实现更复杂的装饰器
- en: 'To create more complex compositions, Python allows the following kinds of function
    definitions:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建更复杂的组合，Python 允许以下类型的函数定义：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Python permits stacking decorators that modify the results of other decorators.
    This has a meaning somewhat like f ∘g ∘h(x). However, the resulting name will
    be merely h(x), concealing the stack of decorations. Because of this potential
    confusion, we need to be cautious when creating functions that involve deeply
    nested decorators. If our intent is simply to handle some cross-cutting concerns,
    then each decorator should be designed to handle a separate concern while avoiding
    confusion.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许堆叠修改其他装饰器结果的装饰器。这有点像 f ∘g ∘h(x)。然而，结果名称将仅仅是 h(x)，隐藏了装饰器的堆栈。由于这种潜在的混淆，我们在创建涉及深度嵌套装饰器的函数时需要谨慎。如果我们的意图仅仅是处理一些横切关注点，那么每个装饰器都应该设计为处理一个单独的关注点，同时避免混淆。
- en: While many things can be done with decoration, it’s essential to ask if using
    a decorator creates clear, succinct, expressive programming. When working with
    cross-cutting concerns, the features of the decorator are often essentially distinct
    from the function being decorated. This can be a wonderful simplification. Adding
    logging, debugging, or security checks through decoration is a widely followed
    practice.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然装饰器可以做很多事情，但使用装饰器创建清晰、简洁、表达性强的编程是至关重要的。当处理横切关注点时，装饰器的特性通常与被装饰的函数本质上不同。这可能是一种非常好的简化。通过装饰器添加日志记录、调试或安全检查是一种广泛遵循的做法。
- en: One important consequence of an overly complex design is the difficulty in providing
    appropriate type hints. When the type hints devolve to simply using `Callable[...,`` Any]`,
    the design may have become too difficult to reason about clearly.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 过度复杂的设计的一个重要后果是难以提供适当的类型提示。当类型提示退化为简单地使用 `Callable[..., Any]` 时，设计可能已经变得难以清晰地推理。
- en: 12.6 Complicated design considerations
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.6 复杂的设计考虑
- en: 'In the case of our data cleanup, the simplistic removal of stray characters
    may not be sufficient. When working with the geolocation data, we may have a wide
    variety of input formats that include simple degrees (`37.549016197`), degrees
    and minutes (`37`° `32.94097`′), and degrees-minutes-seconds (`37`° `32`′ `56.46`′′).
    Of course, there can be even more subtle cleaning problems: some devices will
    create an output with the Unicode `U+00BA` character, º, the ”masculine ordinal
    indicator,” instead of the similar-looking degree character, °, which is `U+00B0`.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们数据清理的情况下，简单的去除杂散字符可能不足以满足需求。当处理地理位置数据时，我们可能会遇到各种输入格式，包括简单的度数（`37.549016197`）、度分（`37`°
    `32.94097`′）和度分秒（`37`° `32`′ `56.46`′′）。当然，还可能有更微妙的数据清理问题：一些设备会创建带有 Unicode `U+00BA`
    字符，º，即“男性序数指示符”，而不是类似的外观度数字符，°，它是 `U+00B0`。
- en: For this reason, it is often necessary to provide a separate cleansing function
    that’s bundled with the conversion function. This function will handle the more
    sophisticated conversions required by inputs that are as wildly inconsistent in
    format as latitudes and longitudes are.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通常有必要提供一个单独的清洗函数，它与转换函数捆绑在一起。这个函数将处理输入所需的更复杂的转换，这些输入在格式上与经纬度一样不一致。
- en: How can we implement this? We have a number of choices. Simple higher-order
    functions are a good choice. A decorator, on the other hand, doesn’t work out
    terribly well. We’ll look at a decorator-based design to see some limitations
    to what makes sense in a decorator.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何实现这一点？我们有多种选择。简单的更高阶函数是一个不错的选择。另一方面，装饰器并不奏效。我们将研究基于装饰器的设计，以了解装饰器中哪些是有意义的。
- en: 'The requirements have the following two orthogonal design considerations:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 需求有以下两个正交的设计考虑：
- en: The output conversion from `string` to `int`, `float` or `Decimal`, summarized
    as `Callable[str,`` T]`
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `string` 到 `int`、`float` 或 `Decimal` 的输出转换，总结为 `Callable[str, T]`
- en: The input cleaning; removing stray characters, reformatting coordinates; summarized
    as `Callable[str,`` str]`
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入清洗；移除多余的字符，重新格式化坐标；总结为 `Callable[str, str]`
- en: Ideally, one of these aspects could be considered as the essential function
    that gets wrapped, and the other aspect is something that’s included via a decoration.
    The choice of essence versus wrapper isn’t always clear.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，可以将这些方面中的一个视为被封装的基本功能，而另一个方面则是通过装饰添加的。本质与封装的选择并不总是明确的。
- en: 'Considering the previous examples, it appears that this should be seen as a
    three-part composite:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到之前的例子，这似乎应该被视为一个三部分的复合体：
- en: The output conversion from `string` to `int`, `float`, or `decimal`
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `string` 到 `int`、`float` 或 `decimal` 的输出转换
- en: 'The input cleansing: either a simple replace or a more complex multiple-character
    replacement'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入清洗：简单的替换或更复杂的多个字符替换
- en: An overall processing function that first attempts the conversion, then does
    any cleansing as a response to an exception, and then attempts the conversion
    again
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整体处理函数，首先尝试转换，然后作为对异常的响应执行任何清洗，然后再次尝试转换
- en: The third part—attempting the conversion and retrying—is the actual wrapper
    that also forms a part of the composite function. As we noted previously, a wrapper
    contains an argument phase and a return-value phase, which we can call w[α](x)
    and w[β](x), respectively.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分——尝试转换和重试——实际上是封装器，它也构成了复合函数的一部分。正如我们之前提到的，封装器包含一个参数阶段和一个返回值阶段，我们可以分别称之为
    w[α](x) 和 w[β](x)。
- en: 'We want to use this wrapper to create a composite of two additional functions.
    We have two choices for the design. We could include the cleansing function as
    an argument to the decorator on the conversion, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想使用这个封装器来创建两个附加函数的复合体。我们有两个设计选择。我们可以将清洗函数作为转换装饰器的参数包含，如下所示：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This first design claims that the conversion function is central, and the cleansing
    is an ancillary detail that will modify the behavior but preserve the original
    intent of the conversion.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种设计声称转换函数是核心的，清洗是一个辅助细节，它将修改行为但保留转换的原始意图。
- en: 'Or, we could include the conversion function as an argument to the decorator
    for a cleansing function as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以将转换函数作为清洗函数的参数包含在装饰器中，如下所示：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This second design claims that the cleansing is central and the conversion is
    an ancillary detail. This is a bit confusing because the cleansing type is generally
    `Callable[[str],`` str]`, while the conversion’s type of `Callable[[str],`` some`` other`` type]`
    is what is required for the overall wrapped function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种设计声称清洗是核心的，而转换是一个辅助细节。这有点令人困惑，因为清洗的类型通常是 `Callable[[str], str]`，而转换的类型 `Callable[[str],
    some other type]` 是整体封装函数所要求的。
- en: 'While both of these approaches can create a usable composite function, the
    first version has an important advantage: the type signature of the `conversion()`
    function is also the type signature of the resulting composite function. This
    highlights a general design pattern for decorators: the type annotations—the signatures—of
    the function being decorated are the easiest to preserve.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两种方法都可以创建一个可用的复合函数，但第一个版本有一个重要的优点：`conversion()` 函数的类型签名也是结果复合函数的类型签名。这突出了装饰器的一般设计模式：被装饰函数的类型注解——签名——是最容易保留的。
- en: When confronted with several choices for defining a composite function, it is
    generally easiest to preserve the type hints for the function being decorated.
    This helps identify the concept that’s central.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当面对定义复合函数的多个选择时，通常最容易保留被装饰函数的类型提示。这有助于识别核心概念。
- en: 'Consequently, the `@cleanse_before(cleaner)` style decorator is preferred.
    The decorator definition looks like the following example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`@cleanse_before(cleaner)` 风格的装饰器更受欢迎。装饰器定义看起来如下示例：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We’ve defined the following multi-layer decorator:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了以下多层装饰器：
- en: At the heart is the `cc_wrapper()` function that applies the `converter()` function.
    If this fails, then it uses the given `cleanse_function()` function and then tries
    the `converter()` function again.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心是 `cc_wrapper()` 函数，它应用 `converter()` 函数。如果这失败了，它将使用给定的 `cleanse_function()`
    函数，然后再次尝试 `converter()` 函数。
- en: The `cc_wrapper()` function is built around the given `cleanse_function()` and
    a `converter()` function by the `concrete_decorator()` decorator. The `converter()`
    function is the function being decorated.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cc_wrapper()` 函数是由 `concrete_decorator()` 装饰器围绕给定的 `cleanse_function()` 和一个
    `converter()` 函数构建的。`converter()` 函数是被装饰的函数。'
- en: The top-most layer is the `concrete_decorator()` function. This decorator has
    the `cleanse_function()` function as a free variable.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最外层是 `concrete_decorator()` 函数。这个装饰器将 `cleanse_function()` 函数作为一个自由变量。
- en: The concrete decorator is created when the decorator interface, `cleanse_before()`,
    is evaluated. The interface is customized by providing the `cleanse_function`
    as an argument value.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当装饰器接口 `cleanse_before()` 被评估时，创建了具体的装饰器。接口通过提供 `cleanse_function` 作为参数值来定制。
- en: The type hints emphasize the role of the `@cleanse_before` decorator. It expects
    some `Callable` function, named `cleanse_function`, and it creates a function,
    shown as `Callable[[str],`` T]`, which will transform a function into a wrapped
    function. This is a helpful reminder of how parameterized decorators work.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示强调了 `@cleanse_before` 装饰器的角色。它期望一个名为 `cleanse_function` 的 `Callable` 函数，并创建一个函数，显示为
    `Callable[[str], T]`，它将转换一个函数为一个包装函数。这是一个关于参数化装饰器如何工作的有用提醒。
- en: 'We can now build a slightly more flexible cleanse and convert function, `to_int()`,
    as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以构建一个稍微更灵活的净化和转换函数 `to_int()`，如下所示：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The integer conversion is decorated with a cleansing function. In this case,
    the cleansing function removes `$` and `,` characters. The integer conversion
    is wrapped by this cleansing.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 整数转换被装饰了一个净化函数。在这种情况下，净化函数移除了 `$` 和 `,` 字符。整数转换被这个净化所包装。
- en: 'The `to_int()` function defined previously leverages the built-in `int()` function.
    An alternative definition that avoids the `def` statement would be the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的 `to_int()` 函数利用了内置的 `int()` 函数。一个避免使用 `def` 语句的替代定义如下：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This uses `drop_punct2()` to wrap the built-in `int()` conversion function.
    Using the mypy tool’s `reveal_type()` function shows that the type signature for
    `to_int()` matches the type signature for the built-in `int()`. It can be argued
    that this style is less readable than using a decorator.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用 `drop_punct2()` 来包装内置的 `int()` 转换函数。使用 mypy 工具的 `reveal_type()` 函数显示，`to_int()`
    的类型签名与内置 `int()` 的类型签名相匹配。可以争论说，这种风格不如使用装饰器可读。
- en: 'We can use this enhanced integer conversion as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用增强的整数转换：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The type hints for the underlying `int()` function have been rewritten (and
    simplified) for the decorated function, `to_int()`. This is a consequence of trying
    to use decorators to wrap built-in functions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于底层 `int()` 函数的类型提示已经被重写（并简化）以适用于装饰函数 `to_int()`。这是尝试使用装饰器包装内置函数的结果。
- en: Because of the complexity of defining parameterized decorators, it appears that
    this is the edge of the envelope. The decorator model doesn’t seem to be ideal
    for this kind of design. It seems like a definition of a composite function would
    be more clear than the machinery required to build decorators.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于定义参数化装饰器的复杂性，这似乎是极限。装饰器模型似乎不适合这种设计。似乎复合函数的定义比构建装饰器所需的机制更清晰。
- en: 'The alternative is to duplicate a few lines of code that will be the same for
    all of the conversion functions. We could use:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是复制几行代码，这些代码对于所有转换函数都是相同的。我们可以使用：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Each of the data type conversions will repeat the `try-except` block. The use
    of a decorator isolates this design feature in a way that can be applied to any
    number of conversion functions without explicitly restating the code. Later changes
    to the design when using this alternative may require editing a number of similar
    functions instead of changing one decorator.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 每种数据类型转换都会重复 `try-except` 块。装饰器的使用以某种方式隔离了这种设计特性，可以应用于任何数量的转换函数，而无需明确重述代码。当使用这种替代方案进行设计更改时，可能需要编辑多个类似函数，而不是更改一个装饰器。
- en: Generally, decorators work well when we have a number of relatively simple and
    fixed aspects that we want to include with a given function (or a class). Decorators
    are also important when these additional aspects can be looked at as infrastructure
    or as support, and not something essential to the meaning of the application code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们想要在给定的函数（或类）中包含多个相对简单且固定的方面时，装饰器工作得很好。当这些额外的方面可以被视为基础设施或支持，而不是应用程序代码含义的必要部分时，装饰器也非常重要。
- en: For something that involves multiple orthogonal design aspects, we may want
    to result to a callable class definition with various kinds of plugin strategy
    objects. This might have a simpler class definition than the equivalent decorator.
    Another alternative to decorators is to look closely at creating higher-order
    functions. In some cases, partial functions with various combinations of parameters
    may be simpler than a decorator.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于涉及多个正交设计方面的内容，我们可能需要求助于具有各种插件策略对象的调用类定义。这可能比等效装饰器有更简单的类定义。装饰器的另一种替代方案是仔细研究创建高阶函数。在某些情况下，具有各种参数组合的偏函数可能比装饰器更简单。
- en: The typical examples for cross-cutting concerns include logging or security
    testing. These features can be considered as the kind of background processing
    that isn’t specific to the problem domain. When we have processing that is as
    ubiquitous as the air that surrounds us, then a decorator might be an appropriate
    design technique.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 跨切面关注点的典型例子包括日志记录或安全测试。这些功能可以被视为不是特定于问题域的背景处理。当我们拥有的处理像围绕我们的空气一样无处不在时，装饰器可能是一种适当的设计技术。
- en: 12.7 Summary
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.7 概述
- en: 'In this chapter, we’ve looked at two kinds of decorators: simple decorators
    with no arguments and parameterized decorators. We’ve seen how decorators involve
    an indirect composition between functions: the decorator wraps a function (defined
    inside the decorator) around another function.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了两种类型的装饰器：无参数的简单装饰器和参数化装饰器。我们看到了装饰器如何涉及函数之间的间接组合：装饰器将一个函数（在装饰器内部定义）围绕另一个函数包装。
- en: Using the `functools.wraps()` decorator ensures that our decorators will properly
    copy attributes from the function being wrapped. This should be a piece of every
    decorator we write.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `functools.wraps()` 装饰器确保我们的装饰器能够正确地复制被包装函数的属性。这应该是我们编写的每个装饰器的一部分。
- en: In the next chapter, we’ll look at the PyMonad library to express a functional
    programming concept directly in Python. We don’t require monads generally because
    Python is an imperative programming language under the hood.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨PyMonad库，以直接在Python中表达函数式编程概念。通常我们不需要monads，因为Python本质上是一种命令式编程语言。
- en: 12.8 Exercises
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.8 练习
- en: This chapter’s exercises are based on code available from Packt Publishing on
    GitHub. See [https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的练习基于Packt Publishing在GitHub上提供的代码。请参阅[https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition)。
- en: In some cases, the reader will notice that the code provided on GitHub includes
    partial solutions to some of the exercises. These serve as hints, allowing the
    reader to explore alternative solutions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，读者会注意到GitHub上提供的代码包含了一些练习的部分解决方案。这些解决方案作为提示，允许读者探索替代方案。
- en: In many cases, exercises will need unit test cases to confirm they actually
    solve the problem. These are often identical to the unit test cases already provided
    in the GitHub repository. The reader should replace the book’s example function
    name with their own solution to confirm that it works.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，练习需要单元测试用例来确认它们确实解决了问题。这些通常与GitHub仓库中已提供的单元测试用例相同。读者应将书籍中的示例函数名称替换为自己的解决方案，以确认其工作。
- en: 12.8.1 Datetime conversions
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.8.1 日期时间转换
- en: In the [Preprocessing bad data](#x1-2550001) section of this chapter, we introduced
    the concept of data conversion functions that included special not applicable
    or not available data values. These are often called null values; because of this,
    a database may have a universal `NULL` literal. We’ll call them ”bad data” because
    that’s how we often discover them. When examining data for the first time, we
    find bad data that might represent missing, or not applicable, values.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的[预处理坏数据](#x1-2550001)部分，我们介绍了数据转换函数的概念，这些函数包括特殊的不适用或不可用数据值。这些通常被称为空值；因此，数据库可能有一个通用的
    `NULL` 文字面量。我们将它们称为“坏数据”，因为这是我们经常发现它们的方式。在第一次检查数据时，我们发现坏数据可能代表缺失或不适用的值。
- en: 'This kind of data can have any of these possible processing paths:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的数据可能有以下可能的处理路径：
- en: The bad data is silently ignored; it’s excluded from counts and averages. To
    make this work out, we’ll often want to replace bad values with a consistent object.
    The `None` object is a good replacement value.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坏数据会被静默忽略；它们不会被计入总数和平均值。为了使这个过程有效，我们通常会想要用一致的值替换坏值。`None` 对象是一个很好的替换值。
- en: The bad data stops the processing, raising an exception. This is quite easy
    to implement, since Python tends to do this automatically. In some cases, we want
    to retry the conversion using alternative rules. We’ll focus on this approach
    for this exercise.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坏数据会停止处理，引发异常。这相当容易实现，因为 Python 通常会自动这样做。在某些情况下，我们想要使用替代规则重试转换。我们将专注于这种方法进行练习。
- en: 'Bad data is replaced with interpolated or imputed values. This often means
    keeping two versions of a collection of data: the original with bad data present,
    and a more useful version with replacement values. This isn’t a simple computation.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坏数据被替换为插值或估计值。这通常意味着保留数据集合的两个版本：一个包含坏数据，另一个包含替换值，更有用。这不是一个简单的计算。
- en: The idea of our core `bad_data()` function is to try a conversion, replace known
    bad punctuation, and then try again. We might, for example, strip ”,” and ”`$`”
    from numeric values.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的核心 `bad_data()` 函数的想法是尝试转换，替换已知坏标点符号，然后再次尝试。例如，我们可能会从数值中删除“,”和“`$`”。
- en: 'Earlier in this chapter, we described three bad-data conversion functions:
    `bd_int()`, `bd_float()`, and `bd_decimal()`. Each of these performed a relatively
    direct conversion-or-replacement algorithm. We left the `bd_datetime()` function
    as an exercise for the reader. In this case, the alternative date formats can
    lead to a bit more complexity.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面部分，我们描述了三个坏数据转换函数：`bd_int()`、`bd_float()` 和 `bd_decimal()`。每个都执行了一个相对直接的转换或替换算法。我们将
    `bd_datetime()` 函数留作读者的练习。在这种情况下，替代日期格式可能会导致更多的复杂性。
- en: 'We’ll assume that dates must be in one of three formats: ”yyyy-mon-dd”, ”yyyy-mm-dd”,
    or ”mon-dd” without a year. In the first and third formats, the month name is
    spelled out. In the second format, the month name is numeric. These are handled
    by the `datetime.strptime()` function using format strings like `"%Y-%b-%d"`,
    `"%b-%d"`, and `"%Y-%m-%d"`.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设日期必须采用以下三种格式之一：“yyyy-mon-dd”、“yyyy-mm-dd”或没有年份的“mon-dd”。在第一种和第三种格式中，月份名称是完整的。在第二种格式中，月份名称是数字的。这些由
    `datetime.strptime()` 函数使用格式字符串如 `"%Y-%b-%d"`、`"%b-%d"` 和 `"%Y-%m-%d"` 处理。
- en: Write a `bd_datetime()` function to try multiple data format conversions, looking
    for one that produces a valid date. In the case of a missing year, the `datetime.replace()`
    method can be used to build a final date result with the current year.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 `bd_datetime()` 函数，尝试多种数据格式转换，寻找一个能生成有效日期的格式。在缺少年份的情况下，可以使用 `datetime.replace()`
    方法结合当前年份构建最终的日期结果。
- en: Once the basic implementation is complete, create appropriate test cases with
    a mix of valid and invalid dates.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦基本实现完成，创建包含有效和无效日期的适当测试用例。
- en: Be sure to make the design flexible enough that adding another format can be
    done without too much struggle.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 确保设计足够灵活，以便在不费太多力气的情况下添加另一个格式。
- en: 12.8.2 Optimize a decorator
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.8.2 优化装饰器
- en: In the [Adding a parameter to a decorator](#x1-2560004) section of this chapter,
    we defined a decorator to replace ”bad” characters in a given field and retry
    an attempted conversion.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的[向装饰器添加参数](#x1-2560004)部分，我们定义了一个装饰器，用于替换给定字段中的“坏”字符，并重试尝试的转换。
- en: This decorator had an internal function, `clean_list()`, that provided a recursive
    definition for removing bad characters from a string.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器有一个内部函数 `clean_list()`，它提供了一个递归定义，用于从字符串中移除坏字符。
- en: 'Here’s the Python function definition:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Python 函数的定义：
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This recursion has two cases:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个递归有两个情况：
- en: When the `to_replace` argument value is empty, there’s nothing to replace, and
    the value of the `text` parameter is returned unchanged.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `to_replace` 参数值为空时，没有要替换的内容，`text` 参数的值将保持不变。
- en: Otherwise, split the `to_replace` string to separate the first character from
    the remaining characters. Remove any occurrence of the first character from the
    value of the `text` parameter and apply this function again using the remaining
    characters of the `to_replace` string.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，将 `to_replace` 字符串分割，将第一个字符与剩余字符分开。从 `text` 参数的值中删除任何第一个字符的出现，并使用 `to_replace`
    字符串的剩余字符再次应用此函数。
- en: Looking back at [Chapter 6](Chapter_06.xhtml#x1-1260006), [Recursions and Reductions](Chapter_06.xhtml#x1-1260006),
    we recall that this kind of tail-call recursion can be transformed into a `for`
    statement. Rewrite the `clean_list()` function to eliminate the recursion.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾 [第 6 章](Chapter_06.xhtml#x1-1260006)，[递归和归约](Chapter_06.xhtml#x1-1260006)，我们回忆起这种尾递归可以转换为一个
    `for` 语句。重写 `clean_list()` 函数以消除递归。
- en: 12.8.3 None-tolerant functions
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.8.3 无容错函数
- en: In the [Adding a parameter to a decorator](#x1-2560004) section of this chapter,
    we saw a design pattern of using a `try:`/`except:` wrapper to uncover numbers
    with spurious punctuation marks. A similar technique can be used to detect `None`
    values and pass them through a function, unprocessed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的 [向装饰器添加参数](#x1-2560004) 部分，我们看到了使用 `try:`/`except:` 包装器来揭示带有虚假标点的数字的设计模式。类似的技巧可以用来检测
    `None` 值并将它们通过一个函数传递，而不进行任何处理。
- en: Write a decorator that can be used for `Callable[[float],`` float]` functions
    that will handle `None` values gracefully.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个装饰器，可以用于 `Callable[[float], float]` 函数，该函数将优雅地处理 `None` 值。
- en: 'If the none-tolerant decorator is called `@none_tolerant`, here is a test case:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无容错装饰器被命名为 `@none_tolerant`，这里是一个测试用例：
- en: '[PRE30]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 12.8.4 Logging
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.8.4 记录日志
- en: A common requirement for debugging is a consistent collection of logging messages.
    It can become tedious to include a `logger.debug()` line in a number of closely-related
    functions. If the functions have a consistent set of type definitions, it can
    be helpful to define a decorator that can be applied to a number of related functions.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 调试的一个常见需求是一组一致的日志消息。在许多紧密相关的函数中包含 `logger.debug()` 行可能会变得繁琐。如果函数具有一致的类型定义集，定义一个可以应用于多个相关函数的装饰器可能会有所帮助。
- en: 'As example functions, we’ll define a collection of ”models” that compute an
    expected result from sample values. We’ll start with a dataclass to define each
    sample as having an identifier, an observed value, and a time-stamp. It looks
    like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例函数，我们将定义一组“模型”，这些模型从样本值计算期望结果。我们将从一个数据类开始，定义每个样本具有一个标识符、一个观察值和一个时间戳。它看起来像这样：
- en: '[PRE31]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We have three models to compute an expected value, e, from the observed value
    in the sample, s[o]:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个模型来计算期望值 e，从样本中的观察值 s[o] 中得到：
- en: e = 0.7412 × s[o]
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: e = 0.7412 × s[o]
- en: e = 0.9 × s[o] − 90
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: e = 0.9 × s[o] − 90
- en: e = 0.7724 × s[o]^(1.0134)
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: e = 0.7724 × s[o]^(1.0134)
- en: First, define these three functions with appropriate test cases.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义这三个函数以及适当的测试用例。
- en: Second, define a `@logging` decorator to use `logger.info()` to record the sample
    value and the computed expectation.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，定义一个 `@logging` 装饰器，使用 `logger.info()` 记录样本值和计算出的期望值。
- en: Third, add the `@logging` decorator in front of each function definition.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，在每个函数定义前添加 `@logging` 装饰器。
- en: Create an overall application that uses `logging.basicConfig()` to set the logging
    level to `logging.INFO` to ensure that the informational messages are seen. (The
    default logging level only shows warnings and errors.)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个整体应用程序，使用 `logging.basicConfig()` 将日志级别设置为 `logging.INFO`，以确保可以看到信息性消息。（默认日志级别仅显示警告和错误。）
- en: This permits creating a consistent logging setup for the three ”model” functions.
    This reflects a complete separation between the logging aspect of the application
    and the computation of expected values from sample values. Is this separation
    clear and helpful? Are there circumstances where this separation might not be
    desirable?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许为三个“模型”函数创建一个一致的日志设置。这反映了应用程序的日志方面与从样本值计算期望值之间的完全分离。这种分离是否清晰且有助于理解？是否存在这种分离可能不理想的情况？
- en: 'The actual measurements are given here. One of the models is more accurate
    than the others:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 实际测量结果在此给出。其中一个模型比其他模型更准确：
- en: '|'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Sample Number | Observed | Actual |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 样本编号 | 观察 | 实际 |'
- en: '|'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 1 | 1000 | 883 |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1000 | 883 |'
- en: '| 2 | 1500 | 1242 |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1500 | 1242 |'
- en: '| 3 | 1500 | 1217 |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1500 | 1217 |'
- en: '| 4 | 1600 | 1306 |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 1600 | 1306 |'
- en: '| 5 | 1750 | 1534 |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 1750 | 1534 |'
- en: '| 6 | 2000 | 1805 |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 2000 | 1805 |'
- en: '| 7 | 2000 | 1720 |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 2000 | 1720 |'
- en: '|'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  |  |  |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |'
- en: 12.8.5 Dry-run check
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.8.5 干运行检查
- en: Applications that can modify the file system require extensive unit testing
    as well as integration testing. To mitigate risk even further, these applications
    will often have a ”dry-run” mode where file system modifications are logged but
    not carried out; files are not moved, directories are not deleted, and so on.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 可以修改文件系统的应用程序需要广泛的单元测试以及集成测试。为了进一步降低风险，这些应用程序通常会有一个“干运行”模式，其中文件系统修改被记录但不会执行；文件不会被移动，目录不会被删除，等等。
- en: The idea here is to write small functions for file system state changes. Each
    function can then be decorated with a `@dry_run_check` decorator. This decorator
    can examine a global variable, `DRY_RUN`. The decorator writes a log message.
    If the `DRY_RUN` value is `True`, nothing else is done. If the `DRY_RUN` value
    is `False`, the base function is evaluated to make the underlying state changes,
    such as removing files, or removing directories.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是为文件系统状态变化编写小的函数。然后，每个函数都可以用 `@dry_run_check` 装饰器装饰。这个装饰器可以检查一个全局变量，`DRY_RUN`。装饰器会写入一条日志消息。如果
    `DRY_RUN` 的值是 `True`，则不会执行其他操作。如果 `DRY_RUN` 的值是 `False`，则评估基础函数以执行底层状态变化，例如删除文件或删除目录。
- en: 'First, define a number of functions to copy a directory. The following state
    changes need separate functions:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义多个函数来复制目录。以下状态变化需要单独的函数：
- en: Create a new, empty, directory.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的空目录。
- en: Copy a file from somewhere in the source directory to the target directory.
    We can use an expression like `offset`` =`` source_path.relative_to(source_dir)`
    to compute the relative location of a file in the source directory. We can use
    `target_dir`` /`` offset` to compute the new location in a target directory. The
    `pathlib.Path` objects provide all of the features required.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从源目录的某个位置复制一个文件到目标目录。我们可以使用表达式 `offset = source_path.relative_to(source_dir)`
    来计算文件在源目录中的相对位置。我们可以使用 `target_dir / offset` 来计算目标目录中的新位置。`pathlib.Path` 对象提供了所有必需的功能。
- en: The `pathlib.Path.glob()` method provides a useful view of a directory’s content.
    This can be used by an overall function that calls the other two functions to
    create subdirectories and copy files into them.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`pathlib.Path.glob()` 方法提供了一个有用的目录内容的视图。这可以由一个总函数使用，该函数调用其他两个函数来创建子目录并将文件复制到其中。'
- en: Second, define a decorator to block the action if this is a dry run. Apply the
    decorator to the directory creation function and the file copy function. Note
    that these two function signatures are different. One function uses a single path,
    the other function uses two paths.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，定义一个装饰器来在干运行时阻止操作。将装饰器应用于目录创建函数和文件复制函数。请注意，这两个函数的签名不同。一个函数使用单个路径，另一个函数使用两个路径。
- en: Third, create a suitable unit test to confirm that dry-run mode goes through
    the motions, but doesn’t alter the underlying file system. The `pytest.tmp_path`
    fixture provides a temporary working directory; using this prevents endlessly
    having to drop and recreate output directories while debugging.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，创建一个合适的单元测试来确认干运行模式只是走形式，但不会改变底层文件系统。`pytest.tmp_path` 修复提供了一个临时工作目录；使用这个可以防止在调试时不断需要删除和重新创建输出目录。
