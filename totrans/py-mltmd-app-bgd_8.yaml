- en: Chapter 8. GUI-based Media Players Using QT Phonon
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。使用QT Phonon的基于GUI的媒体播放器
- en: The earlier chapters had focused on developing audio and video processing tools.
    The involvement of **Graphical User Interface** (GUI) was intentionally kept aside
    so that we could learn 'pure' multimedia-processing techniques using the GStreamer
    framework. However, to just 'play' an audio or a video, we would always prefer
    a media player with a user interface that provides an easy way to control the
    playback, adjust the volume, and so on.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 早期章节主要关注开发音频和视频处理工具。我们故意将**图形用户界面**（GUI）放在一边，以便我们可以使用GStreamer框架学习“纯”多媒体处理技术。然而，仅仅“播放”音频或视频，我们总是更喜欢具有用户界面、提供简单控制播放、调整音量等功能的应用程序。
- en: 'In this chapter, we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Develop a GUI for audio and video players using QT
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用QT开发音频和视频播放器的GUI
- en: Learn fundamental components of the Phonon framework, such as `MediaObject,
    MediaSource, AudioOutput`, and so on to build a media graph
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Phonon框架的基本组件，例如`MediaObject, MediaSource, AudioOutput`等，以构建媒体图
- en: Learn how to use QT Phonon framework to create media players with graphical
    user interface
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用QT Phonon框架创建具有图形用户界面的媒体播放器
- en: So let's get on with it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Installation prerequisites
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装先决条件
- en: We will cover the prerequisites for the installation of QT Python in this section.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中介绍安装QT Python的先决条件。
- en: PyQt4
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyQt4
- en: 'This package provides Python bindings for QT libraries. We will use PyQt4 to
    generate GUI for the image processing application to be developed later in this
    chapter. The GPL version is available at:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此软件包为QT库提供Python绑定。我们将使用PyQt4为本章稍后开发的图像处理应用程序生成GUI。GPL版本可在以下位置获取：
- en: '[http://www.riverbankcomputing.co.uk/software/pyqt/download](http://www.riverbankcomputing.co.uk/software/pyqt/download)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.riverbankcomputing.co.uk/software/pyqt/download](http://www.riverbankcomputing.co.uk/software/pyqt/download)'
- en: Note that you should install PyQt4 binary for Python version 2.6\. The PyQt4
    for Python version 2.5 or earlier may not support the Phonon module. Check the
    PyQt4 documentation to know more. The installation instructions for PyQt4 were
    already discussed in [Chapter 2](ch02.html "Chapter 2. Working with Images"),
    *Working with Images*. Refer to that chapter for further details. The following
    table summarizes the installation prerequisites.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您应该为Python 2.6版本安装PyQt4二进制文件。对于Python 2.5或更早版本，PyQt4可能不支持Phonon模块。请查阅PyQt4文档以获取更多信息。PyQt4的安装说明已在[第2章](ch02.html
    "第2章。处理图像")“处理图像”中讨论。请参阅该章节以获取更多详细信息。以下表格总结了安装先决条件。
- en: Summary of installation prerequisites
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装先决条件总结
- en: '| Package | Download location | Version | Windows platform | Linux/Unix/OS
    X platforms |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 软件包 | 下载位置 | 版本 | Windows平台 | Linux/Unix/OS X平台 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Python | [http://python.org/download/releases/](http://python.org/download/releases/)
    | 2.6.4 (or any 2.6.x) | Install using binary distribution | Install from binary.
    Also install additional developer packages (for example, with python-devel in
    the package name for rpm-based linux distributions).Build and install from the
    source tarball. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| Python | [http://python.org/download/releases/](http://python.org/download/releases/)
    | 2.6.4（或任何2.6.x版本） | 使用二进制发行版进行安装 | 从二进制文件安装。还必须安装额外的开发包（例如，对于基于rpm的Linux发行版，在软件包名称中包含python-devel）。从源tarball构建和安装。
    |'
- en: '| PyQt4 | [http://www.riverbankcomputing.co.uk/software/pyqt/download](http://www.riverbankcomputing.co.uk/software/pyqt/download)
    | 4.6.2 or later | Install using binary pertaining to Python2.6 | First install
    SIP 4.9 or later.Then install PyQt4. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| PyQt4 | [http://www.riverbankcomputing.co.uk/software/pyqt/download](http://www.riverbankcomputing.co.uk/software/pyqt/download)
    | 4.6.2或更高版本 | 使用针对Python2.6的二进制文件进行安装 | 首先安装SIP 4.9或更高版本。然后安装PyQt4。 |'
- en: Introduction to QT Phonon
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QT Phonon简介
- en: In earlier chapters on audio and video processing, we extensively used GStreamer
    multimedia framework. **Phonon** is a multimedia framework used by QT to provide
    audio/video playback. With the GStreamer API knowledge under our belt, it should
    be very easy to grasp the fundamental concepts behind the Phonon multimedia framework.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期关于音频和视频处理的章节中，我们广泛使用了GStreamer多媒体框架。**Phonon**是QT用于提供音频/视频播放的多媒体框架。在掌握GStreamer
    API知识的基础上，应该很容易理解Phonon多媒体框架背后的基本概念。
- en: Main components
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要组件
- en: Let's briefly discuss some of the fundamental components and concepts behind
    the Phonon architecture.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要讨论Phonon架构背后的基本组件和概念。
- en: Media graph
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 媒体图
- en: This is analogous to a GStreamer `pipeline`. The media graph specifies various
    *nodes* (analogous to GStreamer elements) for processing the media stream. For
    example, the *sink* node gives the media data as output. To begin streaming the
    media data within the `Graph`, we call the `play()method` of the `MediaObject`
    module.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于 GStreamer 的 `pipeline`。媒体图指定了处理媒体流的各个 *节点*（类似于 GStreamer 元素）。例如，*输出端* 节点提供媒体数据作为输出。要在
    `Graph` 中开始流式传输媒体数据，我们调用 `MediaObject` 模块的 `play()` 方法。
- en: Media object
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 媒体对象
- en: This object is used for the media playback. It is analogous to the portion of
    a GStreamer pipeline that handles the input media data. The instance of `MediaObject`
    class is used for this purpose. It provides methods to control the playback, such
    as playing, pausing, and stopping the streaming media.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象用于媒体播放。它类似于 GStreamer 管道中处理输入媒体数据的部分。用于此目的的 `MediaObject` 类实例。它提供了控制播放的方法，例如播放、暂停和停止流媒体。
- en: Sink
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出端
- en: Just like in GStreamer, Phonon has a media `Sink`. For example, an audio sink
    is used to output the audio through an audio output device.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 GStreamer 中一样，Phonon 有一个媒体 `Sink`。例如，音频输出设备用于输出音频。
- en: Path
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路径
- en: The `Path` object is used to connect nodes within a media graph in Phonon. For
    example, a `MediaObject` node is linked to an `AudioOutput` node to stream an
    audio.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path` 对象用于在 Phonon 的媒体图中连接节点。例如，`MediaObject` 节点连接到 `AudioOutput` 节点以流式传输音频。'
- en: Effects
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 效果
- en: To manipulate the streaming media, we need to insert `Effects` nodes within
    the `Graph`, between the source (MediaObject) and the `Sink` nodes. These nodes
    are also called processors. The `Effect` class of the Phonon framework facilitates
    adding various effects to the streaming media.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要操作流媒体，我们需要在 `Graph` 中插入 `Effects` 节点，在源（MediaObject）和 `Sink` 节点之间。这些节点也称为处理器。Phonon
    框架的 `Effect` 类简化了向流媒体添加各种效果的过程。
- en: Backends
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后端
- en: It is a `backend` that does the heavy lifting, which is, processing a media
    stream in Phonon. On Windows platform the backend framework is *DirectShow*. If
    you are using Linux, the backend framework for Phonon is GStreamer and, it is
    *QuickTime* in case you use Mac OS X. The supported functionality (for example,
    the media formats supported) may vary depending on the platform.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 `backend`，在 Phonon 中执行繁重的工作，即处理媒体流。在 Windows 平台上，后端框架是 *DirectShow*。如果您使用
    Linux，Phonon 的后端框架是 GStreamer，如果您使用 Mac OS X，则是 *QuickTime*。支持的功能（例如，支持的媒体格式）可能因平台而异。
- en: The namespace, `Phonon.BackendCapabilities`, includes functions that provide
    information about what the Phonon backend is capable of doing. For example, the
    function `BackendCapabilities.availableMimeTypes()` returns a list of all the
    mime types that the backend is capable of decoding. Additionally, it provides
    information about the available audio output devices and available effects.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间 `Phonon.BackendCapabilities` 包含提供有关 Phonon 后端能够做什么的信息的函数。例如，函数 `BackendCapabilities.availableMimeTypes()`
    返回后端能够解码的所有 MIME 类型的列表。此外，它还提供了有关可用音频输出设备和可用效果的信息。
- en: Modules
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: Qt Phonon includes several modules that help to quickly develop applications
    for audio and video playback. We will briefly discuss a few of the important modules.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Phonon 包含几个模块，有助于快速开发音频和视频播放的应用程序。我们将简要讨论几个重要的模块。
- en: MediaNode
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 媒体节点
- en: This is the superclass for all the nodes within a Phonon media graph. Therefore,
    it is inherited by modules such as `MediaObject, Effect`, and `AudioOutput`, which
    will be discussed next.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Phonon 媒体图中所有节点的超类。因此，它被 `MediaObject`、`Effect` 和 `AudioOutput` 等模块继承，这些模块将在下面讨论。
- en: MediaSource
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 媒体源
- en: As the name indicates, this is used to the input the media source. The `MediaObject`
    uses the media data it provides. The following line of code shows how this is
    accomplished.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，这是用于输入媒体源。`MediaObject` 使用它提供的媒体数据。以下代码行显示了这是如何实现的。
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The API method, `setCurrentSouce` of class `MediaObject`, is used to specify
    the `MediaSource` object from which to obtain the media data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`MediaObject` 类的 API 方法 `setCurrentSource` 用于指定从其中获取媒体数据的 `MediaSource` 对象。'
- en: MediaObject
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MediaObject
- en: As mentioned earlier, the `MediaObject` module defines an API to manage the
    playback. The methods such as `play(), pause()`, and `stop()` provide playback
    controls.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`MediaObject` 模块定义了一个用于管理播放的 API。`play()`、`pause()` 和 `stop()` 等方法提供了播放控制。
- en: Path
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路径
- en: 'The `Path` class links the nodes within a graph. It can be created using an
    API method, `Phonon.createPath`. The following code snippet shows an example usage:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`类将图中的节点链接起来。它可以使用API方法`Phonon.createPath`创建。以下代码片段显示了示例用法：'
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `self.audioPath` is an instance of `Path` class. It links the instance
    of class `MediaObject` with `self.audioSink`, which is an instance of class `AudioOutPut`.
    More nodes can be added to the graph by using `Path.insertEffect`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`self.audioPath`是`Path`类的实例。它将`MediaObject`的实例与`self.audioSink`（`AudioOutPut`类的实例）链接起来。可以通过使用`Path.insertEffect`添加更多节点到图中。
- en: AudioOutput
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AudioOutput
- en: The instance of this class provides an audio output node in the Phonon media
    graph. The output device is typically the sound card. `AudioOutput` is connected
    to the `MediaObject` (and `Effect` instances) using the `Path` object we just
    discussed. The property `AudioOutput.outputDevice()` contains information about
    the output device.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的实例在Phonon媒体图中提供了一个音频输出节点。输出设备通常是声卡。`AudioOutput`通过我们刚才讨论的`Path`对象连接到`MediaObject`（以及`Effect`实例）。属性`AudioOutput.outputDevice()`包含有关输出设备的信息。
- en: Effect
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Effect
- en: The instance of class `Effect` can be inserted as a node into the media graph.
    The `Path.insertEffect` can bring about this effect whereas `Path.removeEffect`
    facilitates removal of that node from the graph. This object modifies the streaming
    media data. For example, an echo effect will add an echo to the audio. Use `BackendCapabilities.availableAudioEffects`
    to find out which effects are supported by the Phonon backend.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 类`Effect`的实例可以作为节点插入到媒体图中。`Path.insertEffect`可以实现这种效果，而`Path.removeEffect`则有助于从图中移除该节点。此对象修改流媒体数据。例如，回声效果将为音频添加回声。使用`BackendCapabilities.availableAudioEffects`可以找出Phonon后端支持哪些效果。
- en: VideoPlayer
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: VideoPlayer
- en: This class provides an important functionality. It has several built-in features
    that eliminate the need of explicitly creating nodes such as `MediaObject`. We
    will discuss this in detail while developing the video player application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类提供了一种重要的功能。它具有几个内置特性，可以消除显式创建节点（如`MediaObject`）的需求。我们将在开发视频播放器应用程序时详细讨论这一点。
- en: SeekSlider
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SeekSlider
- en: '`SeekSlider` is a GUI widget. This class provides a slider to seek a specific
    position in the streaming media. It handles all the necessary updates and signal
    connections internally. All it needs is the media object instance.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`SeekSlider`是一个GUI小部件。这个类提供了一个滑块来定位流媒体中的特定位置。它内部处理所有必要的更新和信号连接。它只需要媒体对象实例。'
- en: volumeSlider
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: volumeSlider
- en: This class provides a widget for controlling the volume. It makes a programmer's
    job easy by internally connecting signals. The following line of code sets the
    audio output device for a volume slider.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类提供了一个用于控制音量的小部件。它通过内部连接信号使程序员的任务变得简单。以下代码行设置了音量滑块的音频输出设备。
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, the `volumeSlider` will control the volume for the audio output device
    of `self.audioSink`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`volumeSlider`将控制`self.audioSink`的音频输出设备的音量。
- en: 'Project: GUI-based music player'
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目：基于GUI的音乐播放器
- en: Let's get straight to the business. We will develop a simple GUI-based music
    player using QT Phonon. The goal of this project is to learn how to put together
    important components of the Phonon framework discussed earlier. It will help us
    get familiar with the overall Phonon framework. In the second project, we will
    learn an even simpler way to accomplish the same task.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入正题。我们将使用QT Phonon开发一个简单的基于GUI的音乐播放器。这个项目的目标是学习如何组合之前讨论过的Phonon框架的重要组件。这将帮助我们熟悉整个Phonon框架。在第二个项目中，我们将学习一种更简单的方法来完成同样的任务。
- en: 'The application to be developed here will play an opened audio file. It will
    have GUI widgets to control the playback and add various effects to the streaming
    audio. The screenshot of the music player application is shown in the following
    illustration of its graphical user interface:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里开发的应用程序将播放打开的音频文件。它将具有GUI小部件来控制播放并添加各种效果到流媒体音频。音乐播放器应用程序的截图如下所示，展示了其图形用户界面：
- en: '![Project: GUI-based music player](img/0165_8_1.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![项目：基于GUI的音乐播放器](img/0165_8_1.jpg)'
- en: GUI elements in the music player
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音乐播放器中的GUI元素
- en: The illustrated music player application uses the following QT widgets.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 所示的音乐播放器应用程序使用了以下QT小部件。
- en: '`QMainWindow:` This class provides the main application window. In this window,
    other elements such as buttons and menus are added in a layout.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QMainWindow`：这个类提供了主应用程序窗口。在这个窗口中，其他元素（如按钮和菜单）被添加到布局中。'
- en: '`QToolButton:` The play, pause, and stop buttons are created using the `QToolButton`
    class. The appearance of these `QToolButtons` can be tweaked using a number of
    properties; for example, calling `QToolButtoon.setAutoRaise(True):` Removes the
    raised button effect. On mouse hover, the button will be highlighted and appear
    raised above the surface.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QToolButton:` 使用`QToolButton`类创建播放、暂停和停止按钮。这些`QToolButton`的外观可以通过多个属性进行调整；例如，调用`QToolButtoon.setAutoRaise(True):`移除凸起按钮效果。在鼠标悬停时，按钮将被突出显示并出现在表面之上。'
- en: '`VolumeSlider:` As discussed earlier, the volume slider widget is used for
    controlling the volume of the output audio device.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VolumeSlider:` 如前所述，音量滑块小部件用于控制输出音频设备的音量。'
- en: '`SeekSlider:` Used to seek a position within the streaming media. While the
    music is being played, its position is automatically updated. You can drag the
    slider using mouse to jump to a different position on the track.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SeekSlider:` 用于在流媒体中定位位置。当音乐播放时，其位置会自动更新。您可以使用鼠标拖动滑块来跳转到曲目上的不同位置。'
- en: '`QLineEdit:` This widget is used to display the full path of the media file
    currently being played.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QLineEdit:` 此小部件用于显示当前正在播放的媒体文件的完整路径。'
- en: '`QMenubar:` This is the menu bar above the `QLineEdit`. Here, we add different
    menus such as **File** and **Effects**.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QMenubar:` 这是位于`QLineEdit`上方的菜单栏。在这里，我们添加了不同的菜单，如**文件**和**效果**。'
- en: '`QAction:` Various audio effect options are added to the **Effects** menu as
    `QAction` instances.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QAction:` 将各种音频效果选项添加到**效果**菜单中，作为`QAction`实例。'
- en: 'Some of these QT elements just discussed are pointed out in the following illustration
    of a music player application displaying various QT widgets used:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对音乐播放器应用程序显示的各种 QT 小部件的说明图中指出了一些刚才讨论的这些 QT 元素：
- en: '![GUI elements in the music player](img/0165_8_2.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![音乐播放器中的 GUI 元素](img/0165_8_2.jpg)'
- en: Generating the UI code
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成 UI 代码
- en: The required GUI is built using the QT Designer application. This should be
    included in the binary installer of PyQT4\. QT Designer provides a quick way to
    design and develop the user interface code. It supports a number of commonly used
    QT widgets. One can interactively add these widgets to a layout. This tool is
    also very useful to enhance the aesthetic appeal of the application. For example,
    the widget colors and other properties can easily be changed using various features
    available in QT Designer.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 QT Designer 应用程序构建所需的 GUI。这应包含在 PyQT4 的二进制安装程序中。QT Designer 提供了一种快速设计和发展用户界面代码的方法。它支持许多常用
    QT 小部件。可以将这些小部件交互式地添加到布局中。此工具也非常有用，可以增强应用程序的美观。例如，可以使用 QT Designer 中提供的各种功能轻松更改小部件颜色和其他属性。
- en: Time for action - generating the UI code
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成 UI 代码的时间
- en: The UI file necessary for this application is already created for you. The purpose
    of this section is not to show you how to generate the UI from scratch. It will
    just illustrate some of the important aspects of developing GUI using QT Designer
    for this application. You can then experiment with it further to add new widgets
    to the music player application. We used QT Designer while developing the 'Thumbnail
    Maker' application in [Chapter 2](ch02.html "Chapter 2. Working with Images"),
    *Working with Images*. We will cover some of those things here as well.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序所需的 UI 文件已经为您创建。本节的目的不是向您展示如何从头开始生成 UI。它只是将说明使用 QT Designer 开发此应用程序的一些重要方面。然后您可以进一步实验，向音乐播放器应用程序添加新小部件。我们在[第
    2 章](ch02.html "第 2 章。处理图像")“处理图像”中开发“缩略图制作器”应用程序时使用了 QT Designer。我们将在本节中也介绍一些这些内容。
- en: Download the file `Ui_AudioPlayerDialog.ui` from the Packt website.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Packt 网站下载文件`Ui_AudioPlayerDialog.ui`。
- en: Start the QT Designer application that comes with the PyQt4 installation.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 PyQt4 安装中包含的 QT Designer 应用程序。
- en: Open this file in QT Designer. Click on each widget element within this audio
    player dialog. The QT class associated with the selected widget will be displayed
    in the **Property Editor** panel of the QT Designer.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 QT Designer 中打开此文件。点击此音频播放器对话框中的每个小部件元素。与所选小部件关联的 QT 类将在 QT Designer 的**属性编辑器**面板中显示。
- en: Notice the red-colored borders around various UI widgets within the dialog.
    These borders indicate a 'layout' in which the widgets are arranged. The layouts
    are created using the `QLayout` class and its various subclasses. It is a critical
    component of the user interface design using QT. Without a layout in place, the
    UI elements may appear distorted when you run the application and, for instance,
    resize the dialog.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意对话框中各种UI小部件周围的红色边界。这些边界指示了一个“布局”，其中小部件被排列。布局是通过`QLayout`类及其各种子类创建的。它是使用QT进行用户界面设计的临界组件。如果没有布局，当运行应用程序并例如调整对话框大小时，UI元素可能会出现扭曲。
- en: The following illustration shows how the dialog appears when opened in QT Designer
    the music player dialog (.ui file) in QT Designer.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下插图显示了在QT Designer中打开时的对话框外观，即音乐播放器对话框（.ui文件）。
- en: '![Time for action - generating the UI code](img/0165_8_3.jpg)'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![执行动作 - 生成UI代码](img/0165_8_3.jpg)'
- en: Closely observe the borders around the widgets that indicate the presence of
    a layout. You will notice that there are multiple borders. This implies that we
    have placed the widgets in multiple layouts. For example, the buttons Play, Pause,
    and Stop are arranged in a horizontal layout, QHBoxLayout. These are further arranged
    in another horizontal layout with the volumeSlider element. Refer to QT4 and QT
    Designer documentation to know how to arrange widgets in a layout.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细观察围绕小部件的边界，这些边界指示了布局的存在。你会注意到有多个边界。这表明我们已经在多个布局中放置了小部件。例如，播放、暂停和停止按钮被排列在水平布局QHBoxLayout中。这些按钮进一步排列在另一个包含volumeSlider元素的横向布局中。有关如何在布局中排列小部件的信息，请参阅QT4和QT
    Designer文档。
- en: 'If you click on the **Type Here** placeholder in the menu bar, it becomes editable.
    With this, you can add a new menu to the menu bar. Similarly, you can add menu
    items to the **File** and **Effects** menus by opening those menus and clicking
    on **Type Here** menu item. The **File** menu has two menu items: **Open** and
    **Exit**. Note that the **Effects** menu is empty. We will add menu items to this
    menu later. In the following few steps, we will make minor changes to this dialog
    just to get a feel of QT Designer.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你点击菜单栏中的**在此处输入**占位符，它就会变为可编辑状态。有了这个，你可以在菜单栏中添加一个新的菜单。同样，你可以通过打开这些菜单并点击**在此处输入**菜单项来向**文件**和**效果**菜单添加菜单项。**文件**菜单有两个菜单项：**打开**和**退出**。请注意，**效果**菜单是空的。我们将在稍后向此菜单添加菜单项。在接下来的几个步骤中，我们将对这个对话框进行一些小的修改，以便了解QT
    Designer。
- en: We will now add a widget that can display digits. This widget can be used to
    update the playtime information of the streaming media. The left panel shows a
    bunch of widgets that can be mouse dragged and dropped inside the Audio Player
    dialog window. This is illustrated by the following screenshot:![Time for action
    - generating the UI code](img/0165_8_4.jpg)![Time for action - generating the
    UI code](img/0165_8_5.jpg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将添加一个可以显示数字的小部件。这个小部件可以用来更新流媒体播放时间信息。左侧面板显示了一组可以鼠标拖放到音频播放器对话框窗口内部的小部件。以下截图说明了这一点：![执行动作
    - 生成UI代码](img/0165_8_4.jpg)![执行动作 - 生成UI代码](img/0165_8_5.jpg)
- en: You can see the Display widget panel of QT Designer and the LCD number widget
    inserted into the dialog.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以看到QT Designer的显示小部件面板和插入到对话框中的LCD数字小部件。
- en: The inserted LCD number widget is shown selected in the screenshot on the right-hand
    side. It is inserted in a layout that arranges QToolButtons and the volumeSlider
    widgets in a horizontal fashion. Also, notice that the inserted LCD number widget
    has a default size. This size needs to be adjusted so that other widgets get their
    share of the space. Various parameters can be adjusted using the property editor
    panel within QT Designer for this widget. Here, we adjust the maximum size values
    as illustrated in the following screenshot.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 右侧的截图显示了插入的LCD数字小部件被选中。它被插入到一个布局中，该布局以横向方式排列QToolButtons和volumeSlider小部件。此外，请注意插入的LCD数字小部件有一个默认大小。这个大小需要调整，以便其他小部件能够获得它们的空间份额。可以使用QT
    Designer中的属性编辑面板调整此小部件的各种参数。在这里，我们调整了最大尺寸值，如下面的截图所示。
- en: '![Time for action - generating the UI code](img/0165_8_6.jpg)![Time for action
    - generating the UI code](img/0165_8_7.jpg)'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![执行动作 - 生成UI代码](img/0165_8_6.jpg)![执行动作 - 生成UI代码](img/0165_8_7.jpg)'
- en: The Property Editor for LCD number widget the screenshot on the right-hand side
    shows the edited size parameters.
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: LCD数字小部件的属性编辑器，右侧的截图显示了编辑后的尺寸参数。
- en: Once the maximum width and height parameters are adjusted, the LCD number widget
    fits in nicely within the horizontal layout. The resultant dialog is shown in
    the next illustration.
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦调整了最大宽度和高度参数，LCD 数字小部件就可以很好地适应水平布局。下一个插图显示了结果对话框。
- en: '![Time for action - generating the UI code](img/0165_8_8.jpg)'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 - 生成 UI 代码](img/0165_8_8.jpg)'
- en: That's it! You can keep this LCD number widget in the dialog for now. After
    completion of this project, you can use it to add a feature that displays the
    time information for the streaming media. Note that LCD Number widget is not the
    only option to display the play time. You can even use a QTextLabel and update
    the label string with the time.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就这样！你可以暂时将这个 LCD 数字小部件保留在对话框中。项目完成后，你可以使用它来添加显示流媒体时间信息的功能。请注意，LCD 数字小部件不是显示播放时间的唯一选项。你甚至可以使用
    QTextLabel 并更新标签字符串来显示时间。
- en: 'As mentioned in the chapter, [Chapter 2](ch02.html "Chapter 2. Working with
    Images"), *Working with Images*, the QT Designer saves the user interface file
    with an extension `.ui`. To convert this into Python source code, PyQt4 provides
    a conversion utility called `pyuic4`. On Windows XP, for standard Python installation,
    the path for this utility is `C:\Python26\Lib\site-packages\PyQt4\pyuic4.bat`.
    Add the path to the environment variable. Alternatively, specify the whole path
    each time you want to convert `.ui` file to Python source file. The conversion
    utility can be run from the command prompt as:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如章节中所述，[第二章](ch02.html "第二章. 处理图像")，*处理图像*，QT 设计器使用扩展名 `.ui` 保存用户界面文件。要将此转换为
    Python 源代码，PyQt4 提供了一个名为 `pyuic4` 的转换工具。在 Windows XP 上，对于标准的 Python 安装，此工具的路径为
    `C:\Python26\Lib\site-packages\PyQt4\pyuic4.bat`。将此路径添加到环境变量中。或者，每次你想将 `.ui` 文件转换为
    Python 源文件时，指定整个路径。可以从命令提示符运行转换工具，如下所示：
- en: '[PRE3]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This script will create a Python source file, Ui_AudioPlayerDialog.py from the
    input .ui file. You can further review this file to understand how the UI code
    is set up. We will use this file 'as-is' for the further discussion.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此脚本将从输入的 .ui 文件创建一个 Python 源文件，名为 `Ui_AudioPlayerDialog.py`。你可以进一步审查此文件以了解 UI
    代码是如何设置的。我们将直接使用此文件进行后续讨论。
- en: Tip
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is *not* a good idea to modify the autogenerated Python source file, `Ui_AudioPlayerDialog.py`;
    if you make any changes to the corresponding `.ui` file of the QT Designer and
    run the `pyuic4` script again, it will *overwrite* the previous Python source
    file, `Ui_AudioPlayerDialog.py`, provided we use the same filename. Instead, you
    can use the autogenerated file as a base class and create a subclass to add custom
    UI elements programmatically.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 修改自动生成的 Python 源文件 `Ui_AudioPlayerDialog.py` 并不是一个好主意；如果你对 QT 设计器的相应 `.ui` 文件进行了更改并再次运行
    `pyuic4` 脚本，它将 *覆盖* 之前的 Python 源文件 `Ui_AudioPlayerDialog.py`，前提是我们使用相同的文件名。相反，你可以使用自动生成的文件作为基类，并创建一个子类来以编程方式添加自定义
    UI 元素。
- en: What just happened?
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: This section gave us a working knowledge of tweaking a user interface using
    QT Designer. Just to get the feel of user interface editing, we added a LCD number
    widget to the Audio Player dialog. We learned how to autogenerate the Python source
    code from a `.ui` file created with the help of QT Designer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本节让我们对使用 QT 设计器调整用户界面有了实际了解。为了体验用户界面编辑，我们在音频播放器对话框中添加了一个 LCD 数字小部件。我们学习了如何从使用
    QT 设计器创建的 `.ui` 文件自动生成 Python 源代码。
- en: Connecting the widgets
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接小部件
- en: The command-line utility `pyuic4` (pyuic4.bat for Windows users) enabled conversion
    of the user interface created by the QT-Designer into a Python source file. However,
    various widgets in this UI need to respond to the user actions. For example, when
    the **Play** button is clicked, it must start streaming the media file. Thus,
    we need to add necessary code that will instruct these widgets what they should
    do when a certain event occurs. This is accomplished using the slots and signals.
    A `signal` is emitted when a particular GUI `event` occurs. For example, when
    a user clicks on the **Pause** button, a `"clicked()" signal` is emitted. A `slot`
    is a method that is called for this `signal`. This is very similar to the how
    we connected `pad-added` signal by a `decodebin` element to a method `decodebin_pad_added`
    in earlier chapter. Refer to the PyQt4/ QT4 documentation that has a comprehensive
    list of available `signals` for various widgets.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行工具`pyuic4`（Windows用户的pyuic4.bat）可以将QT-Designer创建的用户界面转换为Python源文件。然而，这个UI中的各种小部件需要响应用户操作。例如，当**播放**按钮被点击时，它必须开始流式传输媒体文件。因此，我们需要添加必要的代码来指示这些小部件在特定事件发生时应该做什么。这是通过槽和信号实现的。当特定的GUI`事件`发生时，会发出一个`signal`。例如，当用户点击**暂停**按钮时，会发出一个`"clicked()"`信号。`slot`是调用此`signal`的方法。这与我们在早期章节中将`pad-added`信号通过`decodebin`元素连接到`decodebin_pad_added`方法的方式非常相似。请参阅PyQt4/QT4文档，其中包含各种小部件可用的`signals`的完整列表。
- en: Time for action - connecting the widgets
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 连接小部件
- en: Let's learn how to make widgets respond to a particular user action, such as
    a button click.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何使小部件对特定的用户操作做出响应，例如按钮点击。
- en: Download the file `AudioPlayerDialog.py` from the Packt website. It defines
    the class `AudioPlayerDialog`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Packt网站下载文件`AudioPlayerDialog.py`。它定义了`AudioPlayerDialog`类。
- en: We will now review the method that connects class methods to the emitted signals.
    These signals are generated whenever a particular 'event' occurs.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将回顾将类方法与发出的信号连接的方法。这些信号在特定“事件”发生时生成。
- en: '[PRE4]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the self._dialog is an instance of class Ui_AudioPlayerDialog. Note that,
    the self.connect is an inherited method of the QT class QMainWindow. It takes
    the following arguments (QObject, SIGNAL, callable). The QObject is any widget
    type; SIGNAL is generated when a specific event occurs. The callable is a method
    that handles this event. The AudioPlayer._connect method connects all the necessary
    signals with class methods.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，self._dialog是`Ui_AudioPlayerDialog`类的一个实例。请注意，self.connect是QT类QMainWindow继承的方法。它接受以下参数（QObject，SIGNAL，callable）。QObject是任何小部件类型；SIGNAL是在特定事件发生时生成的。Callable是处理此事件的方法。AudioPlayer._connect方法将所有必要的信号与类方法连接起来。
- en: The File menu in the Audio Player dialog contains two `QActions`, namely, `fileOpenAction`
    and `fileExitAction`. When File->Open is selected, a signal "triggered" is generated
    for the `QAction`. We need to watch out for this signal and then call a method
    that will do the job of opening a file. This signal is connected by the code between
    lines 5-7\. Thus, when "triggered()" signal is emitted, for `fileopenAction`,
    a method `AudioPlayer._openFileDialog` is called that has necessary code to open
    an audio file.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 音频播放器对话框中的文件菜单包含两个`QActions`，即`fileOpenAction`和`fileExitAction`。当选择文件->打开时，为`QAction`生成一个“触发”信号。我们需要注意这个信号，然后调用一个将执行打开文件任务的方法。这个信号通过第5-7行之间的代码连接。因此，当“triggered()”信号被发出时，对于`fileopenAction`，会调用一个名为`AudioPlayer._openFileDialog`的方法，该方法包含打开音频文件所需的代码。
- en: Let's review the code on line 9-12\. This code connects all the `QActions` within
    a `QMenu` to a method of class `AudioPlayer`. The first argument, `self._dialog.menuAudioEffects`,
    is the Effects menu in the menu bar. This is a `QMenu`. The second argument `SIGNAL("triggered(QAction*)")`
    tells QT that we want to capture the triggered signal for any of the `QActions`
    within the **Effects** menu. This is best explained with an example. Imagine that
    the audio **Effects** menu has menu items (QActions) such as Echo and Distortion.
    When a user selects **Effects** | **Echo** or **Effects** | **Distortion**, the
    `triggered(QAction*)` signal is emitted. The argument `QAction*` is just a pointer
    to that `QAction`. The third argument is the receiver method, `self._changeAudioEffects`
    that is called when this signal is emitted.![Time for action - connecting the
    widgets](img/0165_8_9.jpg)
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回顾第 9-12 行的代码。这段代码将 `QMenu` 内的所有 `QActions` 连接到 `AudioPlayer` 类的方法。第一个参数
    `self._dialog.menuAudioEffects` 是菜单栏中的效果菜单。这是一个 `QMenu`。第二个参数 `SIGNAL("triggered(QAction*)")`
    告诉 QT 我们想要捕获 **效果** 菜单内任何 `QActions` 的触发信号。这最好用一个例子来解释。想象一下音频 **效果** 菜单有菜单项（`QActions`），如回声和失真。当用户选择
    **效果** | **回声** 或 **效果** | **失真** 时，会发出 `triggered(QAction*)` 信号。`QAction*` 参数只是一个指向该
    `QAction` 的指针。第三个参数是接收方法，`self._changeAudioEffects`，当此信号发出时会被调用。![操作时间 - 连接小部件](img/0165_8_9.jpg)
- en: The clicked() signal emitted when a QToolButton, such as, Play, Pause, or Stop
    is clicked. This signal is connected to appropriate methods of class AudioPlayer
    by the code block 13-23.
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当点击 QToolButton，例如播放、暂停或停止按钮时，会发出 clicked() 信号。此信号通过代码块 13-23 连接到 AudioPlayer
    类的适当方法。
- en: Notice that we didn't connect the `SeekSlider` and `VolumeSlider`. The signals
    for these widgets are connected internally. All you need to do is set `MediaObject`
    and `AudioOutput` for these widgets respectively. We will learn how that's done
    in the next section.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意我们没有连接 `SeekSlider` 和 `VolumeSlider`。这些小部件的信号是内部连接的。您需要做的只是分别为这些小部件设置 `MediaObject`
    和 `AudioOutput`。我们将在下一节中学习如何做到这一点。
- en: What just happened?
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We reviewed `AudioPlayerDialog._connect()` method to learn how various widgets
    within the Audio Player dialog are connected to internal methods. This helped
    us learn some preliminary concepts of GUI programming using QT.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾了 `AudioPlayerDialog._connect()` 方法，以了解 Audio Player 对话框内各种小部件是如何连接到内部方法的。这帮助我们学习了使用
    QT 进行 GUI 编程的一些初步概念。
- en: Developing the audio player code
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发音频播放器代码
- en: The discussion so far has been focused on the graphical user interface. We learned
    how to use QT Designer to create user interface and then generate a Python source
    file representing this UI. We also reviewed the code that connects the frontend
    of our application with the backend (the class methods). Now, it is time to review
    the workhorse audio processing code responsible for playing the audio, controlling
    the playback, and operations like adding audio effects.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的讨论一直集中在图形用户界面。我们学习了如何使用 QT Designer 创建用户界面，然后生成代表此 UI 的 Python 源文件。我们还回顾了将应用程序的前端与后端（类方法）连接的代码。现在，是时候回顾负责播放音频、控制播放和添加音频效果等操作的音频处理代码了。
- en: Time for action - developing the audio player code
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作时间 - 开发音频播放器代码
- en: The source file, `AudioPlayerDialog.py`, used in the earlier section will be
    used here as well. The class `AudioPlayerDialog` inherits `QMainWindow`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中使用的源文件 `AudioPlayerDialog.py` 也将在这里使用。`AudioPlayerDialog` 类继承自 `QMainWindow`。
- en: If you have not done so already, download the Python source file `AudioPlayerDialog.py`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请下载 Python 源文件 `AudioPlayerDialog.py`。
- en: Let's start with the constructor of the class, `AudioPlayerDialog`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从类的构造函数 `AudioPlayerDialog` 开始。
- en: '[PRE5]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code block from lines 2 to 6 initializes some instance variables to be used
    later. The dictionary object self.effectsDict will be used to store information
    about the available audio effects. Whereas, self.addedEffects is used to check
    if an audio effect is already added to the streaming media.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从第 2 行到第 6 行的代码块初始化了一些实例变量，这些变量将在以后使用。字典对象 self.effectsDict 将用于存储有关可用音频效果的信息。而
    self.addedEffects 用于检查音频效果是否已添加到流媒体中。
- en: On line 13, the instance of Phonon.MediaObject is created. It will be used for
    controlling the playback of a MediaSource.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第 13 行，创建了 Phonon.MediaObject 的实例。它将被用于控制 MediaSource 的播放。
- en: An audio output node in the Phonon media graph is created by the code on lines
    14-16\. We will call it as self.audioSink, the terminology used in earlier chapter.
    The first argument for AudioOutput is used to specify the category. It is an object
    of class Phonon.Category. Since this is a music player application, we define
    the category as Phonon.MusicCategory. Review QT documentation to know more about
    the categories. The second argument is used as a parent for this audio sink.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Phonon媒体图中，通过第14-16行的代码创建了一个音频输出节点。我们将称之为self.audioSink，这是在早期章节中使用的术语。AudioOutput的第一个参数用于指定类别。它是一个Phonon.Category类的对象。由于这是一个音乐播放器应用程序，我们定义类别为Phonon.MusicCategory。查看QT文档以了解更多关于类别的信息。第二个参数用作此音频接收器的父级。
- en: The Phonon.Path class links the nodes within a media graph. This object is created
    using an API method, Phonon.createPath. On line 17, the Path self.audioPath links
    the media object self.mediaObject with the audio output self.audioSink.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Phonon.Path类将媒体图中的节点链接起来。此对象是通过API方法Phonon.createPath创建的。在第17行，Path self.audioPath将媒体对象self.mediaObject与音频输出self.audioSink链接起来。
- en: The call to the _createUI method handles the defining of the user interface.
    We already learned how the frontend communicates with the backend using the connections
    set up in the _connect method.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`_createUI`方法的调用处理用户界面的定义。我们已经学习了前端如何通过在`_connect`方法中设置的联系与后端通信。'
- en: Finally, on line 28, the API method QMainWindow.show()displays the audio player.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，在第28行，API方法QMainWindow.show()显示音频播放器。
- en: The method `_createUI` delegates most of the GUI creation to the class `UI_AudioPlayerDialog`.
    The method also has the code that further modifies the GUI.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_createUI`方法将大部分GUI创建委托给`UI_AudioPlayerDialog`类。该方法还包括进一步修改GUI的代码。'
- en: '[PRE6]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The instance of class UI_AudioPlayerDialog is created on line 4\. setupUI and
    retranslateUI are the automatically generated methods. These are generated when
    the QT Designer file with the UI is converted into a Python source file. The AudioPlayerDialog
    instance is passed as an argument to these two methods.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第4行创建了`UI_AudioPlayerDialog`类的实例。`setupUI`和`retranslateUI`是自动生成的方法。这些方法是在将包含UI的QT
    Designer文件转换为Python源文件时生成的。AudioPlayerDialog实例作为参数传递给这两个方法。
- en: The code block 7 to 14 sets up the icons for the three QToolButton instances.
    The setIcon API method takes QIcon instance as an argument. The music player icon
    in the caption (on top-left corner of the dialog) is created by the code on line
    15\. As mentioned earlier, the Phonon.SeekSlider signals are internally connected.
    We only need to tell which MediaObject it will handle. This is done on line 17\.
    Similarly, on line 18, the setAudioOutput method of volumeSlider sets up the self.audiosink
    as the audio output for this volumeSlider. While setting up the UI design, we
    did not add any menu items to the Effects menu. This is done now, by calling the
    _setupEffectsMenu method on line 16.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码块7到14设置了三个QToolButton实例的图标。setIcon API方法接受QIcon实例作为参数。音乐播放器图标在标题（对话框的左上角）是通过第15行的代码创建的。如前所述，Phonon.SeekSlider信号是内部连接的。我们只需要告诉它将处理哪个MediaObject。这是在第17行完成的。同样，在第18行，volumeSlider的setAudioOutput方法设置了self.audiosink作为此volumeSlider的音频输出。在设置UI设计时，我们没有向效果菜单中添加任何菜单项。现在，通过在第16行调用`_setupEffectsMenu`方法来完成这项工作。
- en: Let's review the method `_setupEffectsMenu`. It adds various available audio
    effects in the Phonon framework as menu items to the **Effects** menu.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回顾一下`_setupEffectsMenu`方法。它将Phonon框架中可用的各种音频效果作为菜单项添加到**效果**菜单中。
- en: '[PRE7]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The namespace, Phonon.BackendCapabilities includes functions that provide information
    about the capability of the Phonon backend. BackendCapabilities.availableAudioeffects()
    returns a list of all audio effects supported by Phonon on a given platform. The
    list, availableEffects, contains objects of the class Phonon.EffectDescription.
    self.effectsDict stores the name of the effect and the EffectDescription object
    as key-value pairs. This dictionary will be used later. The Effects menu, menuAudioEffects,
    is populated with the QAction instances corresponding to each of the available
    audio effects. QAction is created on line 6\. The setCheckable property of QAction
    toggles the checked state of the action on mouse click. The following screenshot
    shows the Effects menu items on Windows XP.![Time for action - developing the
    audio player code](img/0165_8_10.jpg)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名空间 Phonon.BackendCapabilities 包含提供有关 Phonon 后端功能信息的函数。`BackendCapabilities.availableAudioeffects()`
    返回一个列表，其中包含在特定平台上由 Phonon 支持的所有音频效果。列表 `availableEffects` 包含 `Phonon.EffectDescription`
    类的对象。`self.effectsDict` 存储了效果名称和 `EffectDescription` 对象作为键值对。这个字典将在以后使用。效果菜单 `menuAudioEffects`
    用对应于每个可用音频效果的 `QAction` 实例填充。`QAction` 在第 6 行创建。`QAction` 的 `setCheckable` 属性通过鼠标点击切换动作的选中状态。以下截图显示了
    Windows XP 上的效果菜单项![执行动作 - 开发音频播放器代码](img/0165_8_10.jpg)
- en: The method `_openFileDialog` is called when **File** | **Open** is clicked from
    the music player.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当从音乐播放器点击**文件** | **打开**时，会调用 `_openFileDialog` 方法。
- en: '[PRE8]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This pops up a QFileDialog with the file type filters as specified on line 10\.
    To know about the supported media formats, you can use the Phonon.BackEndCapabilities
    as illustrated by the following line of code.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这会弹出一个 `QFileDialog`，其文件类型过滤器与第 10 行指定的过滤器相同。要了解支持的媒体格式，可以使用以下代码行中的 `Phonon.BackEndCapabilities`。
- en: '[PRE9]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Where, types is a list of available mime types.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其中，`types` 是可用 MIME 类型的列表。
- en: The path of the file specified by the user is then stored in the variable self._filePath.
    This path is displayed in the fileLineEdit field of the dialog. On line 15, the
    method _loadNewMedia is called. We will review that next.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后将用户指定的文件路径存储在变量 `self._filePath` 中。此路径在对话框的文件 `LineEdit` 字段中显示。在第 15 行，调用了
    `_loadNewMedia` 方法。我们将在下一节中回顾它。
- en: The method `_loadNewMedia` sets up the media source for the `MediaObject`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_loadNewMedia` 方法为 `MediaObject` 设置媒体源。'
- en: '[PRE10]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The if block on line 4 ensures that the current streaming audio (if any) is
    stopped by the media object before setting the new media source to a playing state.
    Although it is not necessary, the memory occupied by the MediaSource object is
    cleared up by the code on line 6\. Line 8 creates a new instance of class MediaSource.
    The API method, setCurrentSouce of the class MediaObject is used to specify the
    MediaSource that provides the media data. With this, our media player is all set
    to stream the audio file.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第 4 行的 `if` 块确保在将新媒体源设置为播放状态之前，由媒体对象停止当前流式传输的音频（如果有的话）。尽管这不是必需的，但第 6 行的代码会清理
    `MediaSource` 对象占用的内存。第 8 行创建 `MediaSource` 类的新实例。使用该类的 `MediaObject` 的 `setCurrentSource`
    API 方法指定提供媒体数据的 `MediaSource`。这样，我们的媒体播放器就设置好了以流式传输音频文件。
- en: When you click on the **Play** button in the music player, the `AudioPlayerDialog._playMedia`
    method is called.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在音乐播放器中点击**播放**按钮时，会调用 `AudioPlayerDialog._playMedia` 方法。
- en: '[PRE11]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First the program carries out some primary checks to ensure that the media is
    playable and then calls the play() method of Phonon.MediaObject, which begins
    streaming the audio. The methods _pauseMedia and _stopMedia of class AudioPlayerDialog
    contain similar code.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，程序执行一些基本检查以确保媒体可播放，然后调用 `Phonon.MediaObject` 的 `play()` 方法，开始流式传输音频。`AudioPlayerDialog`
    类的 `_pauseMedia` 和 `_stopMedia` 方法包含类似的代码。
- en: 'We just learned how to set up the media graph, stream the media, and control
    its playback. Now let''s see how to add audio effects to this streaming media.
    If any of the items in the Effects menu are clicked, the AudioPlayerDialog._changeAudioEffects
    method is called:'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们刚刚学习了如何设置媒体图、流式传输媒体和控制其播放。现在让我们看看如何向这个流式媒体添加音频效果。如果效果菜单中的任何项被点击，会调用 `AudioPlayerDialog._changeAudioEffects`
    方法：
- en: '[PRE12]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The if and else blocks in the preceding code snippet add and remove effects
    nodes from the media graph respectively. The if block is executed when an action
    in the Effects menu is checked. When an already checked action is toggled, the
    program executes the else block. In the if block, an instance of Phonon.Effect
    is created on line 6\. This takes an EffectDescription object as an argument.
    As seen in the _setupEffectsMenu method, self.effectsDict stores the EffectDescription
    objects as the dictionary values. On line 8, this effect is inserted as a node
    in the media graph. The self.audioPath links all the nodes within the media graph.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的代码片段中的if和else块分别向媒体图中添加和删除效果节点。当Effects菜单中的动作被选中时执行if块。当已选中的动作被切换时，程序执行else块。在if块中，在第6行创建了一个Phonon.Effect实例。这个实例需要一个EffectDescription对象作为参数。如_setupEffectsMenu方法中所示，self.effectsDict将EffectDescription对象存储为字典值。在第8行，此效果被插入为媒体图中的一个节点。self.audioPath将媒体图中的所有节点链接起来。
- en: The dictionary, self.addedEffects keeps track of all the audio effects inserted
    within the media graph. The else block removes an already added effect.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 字典self.addedEffects跟踪媒体图中插入的所有音频效果。else块移除已添加的效果。
- en: On line 11, an added effect is removed by calling the removeEffect API method
    of Phonon.Path. The corresponding key-value pair of self.addedEffects is also
    deleted on line 12\. This also ensures that there is no memory leak.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第11行，通过调用Phonon.Path的removeEffect API方法移除了一个附加效果。在第12行，也删除了self.addedEffects中对应的键值对。这也确保了没有内存泄漏。
- en: Tip
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: QT Phonon allows adding the same audio effect multiple times. For example, you
    can create multiple 'Chorus' effect nodes within the media graph using `Path.insertEffect`.
    Each of the added effects will have its own contribution. However, in our application,
    we support adding an effect only once. You can extend this to support adding the
    same effect multiple times. For this, you will need to tweak the **Effects** menu
    UI and make some other changes in the code to keep track of the added effects.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: QT Phonon允许多次添加相同的音频效果。例如，您可以使用`Path.insertEffect`在媒体图中创建多个“合唱”效果节点。每个添加的效果都将有自己的贡献。然而，在我们的应用程序中，我们只支持添加一个效果。您可以扩展此功能以支持多次添加相同的效果。为此，您需要调整**效果**菜单UI，并在代码中进行一些其他更改以跟踪添加的效果。
- en: The application will not terminate properly if you close the GUI window while
    an audio file is being played. To safely terminate the application without any
    memory leaks, `AudioPlayerDialog` overrides the `QMainWindow.closeEvent`. Before
    closing the window, we do the necessary cleanup to avoid memory leaks. The code
    is illustrated below.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在播放音频文件时关闭GUI窗口，应用程序将无法正确终止。为了安全地终止应用程序而不产生内存泄漏，`AudioPlayerDialog`重写了`QMainWindow.closeEvent`。在关闭窗口之前，我们进行必要的清理以避免内存泄漏。下面的代码展示了这一过程。
- en: '[PRE13]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The streaming media, if any, is first stopped. The call to _clearEffectsObject
    deletes all the Phonon.Effect and Phonon.EffectDescription objects (if present).
    The method _clearEffectsObject is self-explanatory.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有流媒体，首先会停止。调用_clearEffectsObject会删除所有Phonon.Effect和Phonon.EffectDescription对象（如果存在）。_clearEffectsObject方法名本身就说明了其功能。
- en: The following code creates an instance of `QApplication` and executes this program.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码创建了一个`QApplication`实例并执行此程序。
- en: '[PRE14]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Review the rest of the code from the file `AudioPlayerDialog.py` and then run
    the music player as:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查文件`AudioPlayerDialog.py`中的其余代码，然后按照以下方式运行音乐播放器：
- en: '[PRE15]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This should display the music player GUI window. Use File | Open to specify
    a music file and then click on the Play button to enjoy the music!
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这应该会显示音乐播放器GUI窗口。使用文件 | 打开来指定音乐文件，然后点击播放按钮来享受音乐！
- en: What just happened?
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We just created our own music player! We developed a frontend for this music
    player using QT Phonon multimedia framework. Use of various modules in QT Phonon
    was thoroughly discussed. We learned how to set up audio controls and effects
    in a media graph by using modules such as `MediaObject, AudioOutput, Path`, and
    so on. We also gained some higher-level understanding of GUI programming aspects
    using QT.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了自己的音乐播放器！我们使用QT Phonon多媒体框架开发了此音乐播放器的前端。我们详细讨论了QT Phonon中各种模块的使用。我们学习了如何通过使用`MediaObject,
    AudioOutput, Path`等模块在媒体图中设置音频控制和效果。我们还通过QT获得了对GUI编程方面的一些高级理解。
- en: Have a go hero add more features to the audio player
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试为音频播放器添加更多功能
- en: In the *Generating the UI code* section, we added a widget to the music player
    GUI window. This is an LCD number widget that can display the frame numbers. Connect
    this widget to the Audio Player backend, so that it can display the current media
    time. The next illustration shows this LCD number widget in action for a streaming
    audio file.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在**生成UI代码**部分，我们向音乐播放器GUI窗口添加了一个小部件。这是一个可以显示帧数的LCD数字小部件。将其连接到音频播放器后端，以便它可以显示当前媒体时间。以下插图显示了用于流式音频文件的此LCD数字小部件的工作情况。
- en: Extend this music player application so that it can play all the songs from
    a directory or CD one after the other. There are a number of ways to create a
    user interface to display the files. For example, you can try using widgets such
    as `QDirectoryView` , `QTreeView`, or `QTableWidget`.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展这个音乐播放器应用程序，使其能够依次播放目录或CD中的所有歌曲。创建用于显示文件的用户界面有多种方法。例如，你可以尝试使用`QDirectoryView`、`QTreeView`或`QTableWidget`等小部件。
- en: 'Music player displaying the frame number (time) in the LCD number widget:'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 音乐播放器在LCD数字小部件中显示帧数（时间）：
- en: '![Have a go hero add more features to the audio player](img/0165_8_11.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![尝试为音频播放器添加更多功能](img/0165_8_11.jpg)'
- en: 'Project: GUI-based video player'
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目：基于GUI的视频播放器
- en: In the first project, we learned the fundamentals of the QT Phonon framework.
    In this project, we will extend that knowledge further by developing a video player.
    The Audio player was developed by building a media graph. Various nodes such as
    `MediaObject, AudioOutput`, and `Effects` were linked together by creating a `Phonon.Path`.
    If the goal is just to develop a simple audio or video player, the job is even
    simpler. Phonon has a module `VideoPlayer` that provides an abstract way to play
    an audio or a video without the need to explicitly create `MediaObject, AudioOutput`,
    and some other objects. All it needs is a `MediaSource`. It is also possible to
    create a custom media graph by adding various audio-effect nodes. We will see
    how to do it later. For now, let's write a simple video player application using
    QT Phonon. The following illustration shows the video player in action.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个项目中，我们学习了QT Phonon框架的基础知识。在本项目中，我们将通过开发视频播放器来进一步扩展这些知识。音频播放器是通过构建媒体图来开发的。通过创建`Phonon.Path`，将各种节点如`MediaObject`、`AudioOutput`和`Effects`链接在一起。如果目标仅仅是开发一个简单的音频或视频播放器，那么工作会更加简单。Phonon有一个名为`VideoPlayer`的模块，它提供了一种抽象的方式来播放音频或视频，无需显式创建`MediaObject`、`AudioOutput`和其他一些对象。它只需要一个`MediaSource`。也可以通过添加各种音频效果节点来创建自定义媒体图。我们将在稍后看到如何做到这一点。现在，让我们使用QT
    Phonon编写一个简单的视频播放器应用程序。以下插图显示了视频播放器的工作情况。
- en: '![Project: GUI-based video player](img/0165_8_12.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![项目：基于GUI的视频播放器](img/0165_8_12.jpg)'
- en: Generating the UI code
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成UI代码
- en: QT Designer is an excellent resource for generating user interface interactively.
    As we have seen, most of the user interface for this project is built using QT
    Designer. In addition, some important points about the user interface design using
    QT were covered. This section will just walk you through the user interface generation
    for this application using QT Designer and `pyuic4`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: QT Designer是一个交互式生成用户界面的优秀资源。正如我们所见，本项目的大部分用户界面都是使用QT Designer构建的。此外，还介绍了使用QT进行用户界面设计的一些重要要点。本节将指导您使用QT
    Designer和`pyuic4`生成此应用程序的用户界面。
- en: Time for action - generating the UI code
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践 - 生成UI代码
- en: The `.ui` file is already created. In the following discussion, we will simply
    use this file and go through some of the GUI elements needed for this application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`.ui`文件已经创建。在以下讨论中，我们将简单地使用此文件，并介绍一些此应用程序所需的GUI元素。'
- en: Download the file `Ui_VideoPlayerDialog.ui` from the Packt website.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Packt网站下载文件`Ui_VideoPlayerDialog.ui`。
- en: Open this file in QT Designer. Click on each widget element. The QT class associated
    with the selected widget will be displayed in the **Property Editor** panel on
    the right-hand side. Most of the widgets used here are same as the ones used in
    the earlier project. The only widget that is different is the `Phonon.VideoPlayer`.
    The following illustration shows how the dialog appears when opened in QT Designer.
    It also points out various Phonon widgets used in the dialog.![Time for action
    - generating the UI code](img/0165_8_13.jpg)
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在QT Designer中打开此文件。点击每个小部件元素。与所选小部件关联的QT类将在右侧的**属性编辑器**面板中显示。这里使用的多数小部件与早期项目中使用的相同。唯一不同的小部件是`Phonon.VideoPlayer`。以下插图显示了在QT
    Designer中打开时的对话框外观。它还指出了对话框中使用的各种Phonon小部件。![动手实践 - 生成UI代码](img/0165_8_13.jpg)
- en: The video player widget in QT Designer appears as shown in the preceding screenshot.
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: QT Designer中的视频播放器小部件看起来如前一张截图所示。
- en: Click on the `VideoPlayer` widget shown in the preceding illustration. The **Property
    Editor** will display its properties. Pay attention to how the size of this widget
    is defined. This Video Player will support an option to view the video in 'Full
    Screen' mode. Therefore, the maximum size parameters for the `VideoPlayer` widget
    are set to high values as shown in the next screenshot. In fact, we are using
    the QT default values for the maximum size property. The only property modified
    is the minimum size of the widget. This minimum size will be the default size
    of the video player widget.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击前面插图所示的`VideoPlayer`小部件。**属性编辑器**将显示其属性。请注意这个小部件的大小是如何定义的。此视频播放器将支持在`全屏`模式下查看视频的功能。因此，`VideoPlayer`小部件的最大尺寸参数被设置为较高的值，如下一张截图所示。实际上，我们正在使用QT默认值作为最大尺寸属性。唯一修改的属性是小部件的最小尺寸。这个最小尺寸将是视频播放器小部件的默认尺寸。
- en: 'The Property editor for Video Player widget:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 视频播放器小部件的属性编辑器：
- en: '![Time for action - generating the UI code](img/0165_8_14.jpg)'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 - 生成UI代码](img/0165_8_14.jpg)'
- en: The rest of the widgets are the same as the one used in an earlier project.
    You can add the LCD **Number** widget or a simple text label that displays the
    current time for the streaming media. Refer to the last project for instructions
    on adding such widgets.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其余的小部件与之前项目中使用的相同。您可以添加LCD **数字**小部件或一个简单的文本标签来显示流媒体当前时间。有关添加此类小部件的说明，请参阅最后一个项目。
- en: 'Next, convert the `.ui` file into `.py` using the `pyuic4` conversion utility.
    The conversion utility can be run from the command prompt as:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`pyuic4`转换工具将`.ui`文件转换为`.py`。转换工具可以从命令提示符运行，如下所示：
- en: '[PRE16]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This script will create a Python source file, Ui_VideoPlayerDialog.py, from
    the input .ui file. We will use this file 'as-is' for the further discussion.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此脚本将从输入的.ui文件创建一个Python源文件，名为Ui_VideoPlayerDialog.py。我们将直接使用此文件进行后续讨论。
- en: What just happened?
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The previous discussion served as a refresher on use of QT Designer to generate
    most of the user interface elements needed for this project. The `pyuic4` conversion
    utility was used to convert the `.ui` file to a Python source file.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的讨论作为使用QT Designer生成此项目所需的大部分用户界面元素的复习。使用了`pyuic4`转换工具将`.ui`文件转换为Python源文件。
- en: Connecting the widgets
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接小部件
- en: 'Most of the widgets used in the previous project are re-used here. Therefore,
    this is going to be a short discussion. In this project, we have not included
    an **Effects** menu. Thus, the `VideoPlayerDialog._connect` method has minor changes.
    This method is illustrated as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的项目中使用的多数小部件在此处被重新使用。因此，这将是一个简短的讨论。在这个项目中，我们没有包含**效果**菜单。因此，`VideoPlayerDialog._connect`方法有细微的变化。此方法如下所示：
- en: '[PRE17]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The highlighted lines of code are a new widget connection. The rest of the connections
    are the same as the ones discussed in the previous project. When **View** | **Full
    Screen** is selected, the `toggled(bool)` signal of `fullScreenAction` is emitted.
    When this happens the `slot` method `self._toggleFullScreen` is called. The next
    section will have more details about this method.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码行是一个新的小部件连接。其余的连接与之前项目中讨论的相同。当选择**视图** | **全屏**时，`fullScreenAction`的`toggled(bool)`信号被触发。当发生这种情况时，会调用`slot`方法`self._toggleFullScreen`。下一节将详细介绍此方法。
- en: Developing the video player code
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发视频播放器代码
- en: The generated frontend is connected to the backend for processing the media.
    In this section, we will review the video player backend that actually streams
    the media and controls the playback and volume. Our job is easier here. Most of
    the good work we did in the earlier project will be re-used here. There will be
    some minor modifications because we will be using `Phonon.VideoPlayer` for video
    processing instead of explicitly creating the objects such as `MediaObject`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的前端连接到后端以处理媒体。在本节中，我们将回顾实际流式传输媒体和控制播放和音量的视频播放器后端。在这里我们的工作会更容易。我们在早期项目中做的许多好工作将在此处重新使用。将有一些小的修改，因为我们将使用`Phonon.VideoPlayer`进行视频处理，而不是显式创建如`MediaObject`之类的对象。
- en: Time for action - developing the video player code
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 开发视频播放器代码
- en: Let's develop the rest of the video player backend. We will re-use several methods
    from the `AudioPlayerDialog` class with a few minor changes. Only the important
    methods will be covered in this section.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开发视频播放器后端的其余部分。我们将从 `AudioPlayerDialog` 类中重用几个方法，并进行一些小的修改。本节将只涵盖重要的方法。
- en: Download the file `VideoPlayerDialog.py` from the Packt website.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Packt 网站下载文件 `VideoPlayerDialog.py`。
- en: The constructor of the class is shown below.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类的构造函数如下所示。
- en: '[PRE18]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The self._dialog creates an instance of class Phonon.VideoPlayer. Once a media
    source is specified, self._dialog.videoPlayer is able to stream the media. Thus,
    for the media streaming itself, we don't need to create the nodes MediaObject
    and AudioOutput explicitly; the Phonon.VideoPlayer internally builds the media
    graph. However, MediaObject and AudioOutput are required for seekSlider and volumeControl
    widgets respectively. On lines 14 and 15, these objects are obtained from self._dialog.videoPlayer.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: self._dialog 创建了 Phonon.VideoPlayer 类的实例。一旦指定了媒体源，self._dialog.videoPlayer 就能够流式传输媒体。因此，对于媒体流本身，我们不需要显式创建
    MediaObject 和 AudioOutput 节点；Phonon.VideoPlayer 内部构建媒体图。然而，MediaObject 和 AudioOutput
    分别需要用于 seekSlider 和 volumeControl 小部件。在第 14 和 15 行，这些对象从 self._dialog.videoPlayer
    获取。
- en: The `_createUI` method is almost identical to the corresponding method in `AudioPlayerDialog`,
    except that it doesn't have the **Effects** menu-related code.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_createUI` 方法几乎与 `AudioPlayerDialog` 中的相应方法相同，只是没有与 **效果** 菜单相关的代码。'
- en: Following that, the method to review is `_playMedia:`
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着，要审查的方法是 `_playMedia:`
- en: '[PRE19]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code is self-explanatory. The self.mediaSource is set in VideoPlayerDialog._loadNewMedia.
    This MediaSource instance is passed as an argument to the API method VideoPlayer.play.
    The videoPlayer then builds the media graph internally and plays the given media
    file.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码是自我解释的。在 `VideoPlayerDialog._loadNewMedia` 中设置了 self.mediaSource。这个 MediaSource
    实例作为参数传递给 API 方法 VideoPlayer.play。然后视频播放器内部构建媒体图并播放指定的媒体文件。
- en: This simple video player supports an option to view the streaming video in full
    screen mode. `QMainWindow` class provides an easy way to change the view between
    full screen and normal viewing mode. This is done by the method `_toggleFullScreen`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个简单的视频播放器支持全屏模式查看流媒体视频的选项。`QMainWindow` 类提供了一个简单的方法来在全屏和正常观看模式之间切换视图。这是通过 `_toggleFullScreen`
    方法实现的。
- en: '[PRE20]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The method, self.showFullScreen() is inherited from class QMainWindow. If the
    QAction in the View menu (View | Full Screen) is checked, the video player window
    is set to full screen. QMainWindow.showNormal() changes the video player back
    to the normal viewing mode. The following screenshot shows the video player in
    the full screen mode. Notice that the window caption bar is hidden in the full
    screen mode.
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法 self.showFullScreen() 是从 QMainWindow 类继承的。如果视图菜单（视图 | 全屏）中的 QAction 被选中，视频播放器窗口将设置为全屏。QMainWindow.showNormal()
    将视频播放器切换回正常观看模式。以下截图显示了全屏模式下的视频播放器。注意，在全屏模式下，窗口标题栏被隐藏。
- en: 'Video player in full screen mode is illustrated as shown in the next image:'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一个图像展示了全屏模式下的视频播放器：
- en: '![Time for action - developing the video player code](img/0165_8_15.jpg)'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 - 开发视频播放器代码](img/0165_8_15.jpg)'
- en: 'Review the rest of the code from file `VideoPlayerDialog.py`. Keep this file
    in the same directory as `Ui_VideoPlayerDialog.py` and then run the program from
    the command line as:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查来自文件 `VideoPlayerDialog.py` 的其余代码。将此文件与 `Ui_VideoPlayerDialog.py` 放在同一目录下，然后从命令行运行程序，如下所示：
- en: The video player GUI window will appear. Open any supported audio or video file
    and click on the **Play** button to begin the playback.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视频播放器 GUI 窗口将出现。打开任何支持的音频或视频文件，然后点击 **播放** 按钮开始播放。
- en: '[PRE22]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: What just happened?
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We wrote our own video player. This video player is capable of playing video
    as well as audio files of supported formats. The module `Phonon.VideoPlayer` that
    enables media playback and control was used here. We also learned how to toggle
    view between full screen and normal viewing mode using the API methods of class
    `QMainWindow`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了自己的视频播放器。这个视频播放器能够播放支持格式的视频和音频文件。在这里使用了 `Phonon.VideoPlayer` 模块，它使媒体播放和控制成为可能。我们还学习了如何使用
    QMainWindow 类的 API 方法在全屏和正常观看模式之间切换视图。
- en: Have a go hero do more with the video player
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试使用视频播放器做更多的事情
- en: Here is a simple enhancement. The full screen mode shows widgets such as playback
    control buttons, seek, and volume sliders. Hide these widgets when the **View**
    | **Full Screen** action is checked. Also, add a keyboard shortcut to toggle between
    normal and full screen view mode.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有一个简单的增强。全屏模式显示播放控制按钮、快进和音量滑块等小部件。当检查 **视图** | **全屏** 动作时，隐藏这些小部件。此外，添加一个键盘快捷键来在正常和全屏视图模式之间切换。
- en: Add audio effects to the video player GUI. We already learned how to add audio
    effects to the media graph in the first project. You can re-use that code here.
    However, you will need an appropriate `Phonon.Path` object to which the `effects`
    node needs to be added. In the last project, we used `Phonon.createPath` we can't
    create a new path as it is created internally by the VideoPlayer. Instead, the
    path can be obtained using API method `MediaObject.outputPaths()`. This method
    returns a list containing output (audio and video) paths. The line of code is
    shown as an example.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向视频播放器 GUI 添加音频效果。我们已经在第一个项目中学习了如何向媒体图添加音频效果。你可以在这里重用那段代码。然而，你需要一个合适的 `Phonon.Path`
    对象，`effects` 节点需要添加到这个对象中。在上一个项目中，我们使用了 `Phonon.createPath`，但我们不能创建一个新的路径，因为它是由
    VideoPlayer 内部创建的。相反，你可以使用 API 方法 `MediaObject.outputPaths()` 来获取路径。下面是一个示例代码行。
- en: '[PRE23]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: However, be careful with the memory leaks. If you add audio effects, and then
    exit the application, the program may freeze. This could be because the effect
    nodes are not deleted from the original audio path. Alternatively, you can build
    the video player from basic principles. That is, don't use Phonon.VideoPlayer.
    Instead, build a custom media graph just like how we did for the audio player
    project. In this case, you will need to use modules such as Phonon.VideoWidget.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，要注意内存泄漏问题。如果你添加了音频效果，然后退出应用程序，程序可能会冻结。这可能是因为效果节点没有被从原始音频路径中删除。或者，你可以从基本原理构建视频播放器。也就是说，不要使用
    Phonon.VideoPlayer。相反，构建一个自定义的媒体图，就像我们在音频播放器项目中做的那样。在这种情况下，你需要使用诸如 Phonon.VideoWidget
    这样的模块。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter taught us several things about GUI multimedia application development
    using QT. We worked on two exciting projects where audio and video players using
    QT Phonon framework were developed. To accomplish these tasks, we:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 本章教会了我们关于使用 QT 开发 GUI 多媒体应用程序的几个要点。我们完成了两个令人兴奋的项目，其中开发了使用 QT Phonon 框架的音频和视频播放器。为了完成这些任务，我们：
- en: Used QT Designer to generate the UI source code
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 QT Designer 生成 UI 源代码
- en: Handled the QT generated events by connecting slots (class methods) with signals
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将槽（类方法）与信号连接来处理 QT 生成的事件
- en: Used Phonon framework to set up media graphs for streaming of audio and video
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Phonon 框架设置音频和视频流媒体图的媒体图
