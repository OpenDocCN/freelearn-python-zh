- en: Chapter 8. GUI-based Media Players Using QT Phonon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The earlier chapters had focused on developing audio and video processing tools.
    The involvement of **Graphical User Interface** (GUI) was intentionally kept aside
    so that we could learn 'pure' multimedia-processing techniques using the GStreamer
    framework. However, to just 'play' an audio or a video, we would always prefer
    a media player with a user interface that provides an easy way to control the
    playback, adjust the volume, and so on.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Develop a GUI for audio and video players using QT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn fundamental components of the Phonon framework, such as `MediaObject,
    MediaSource, AudioOutput`, and so on to build a media graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use QT Phonon framework to create media players with graphical
    user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let's get on with it.
  prefs: []
  type: TYPE_NORMAL
- en: Installation prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will cover the prerequisites for the installation of QT Python in this section.
  prefs: []
  type: TYPE_NORMAL
- en: PyQt4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This package provides Python bindings for QT libraries. We will use PyQt4 to
    generate GUI for the image processing application to be developed later in this
    chapter. The GPL version is available at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.riverbankcomputing.co.uk/software/pyqt/download](http://www.riverbankcomputing.co.uk/software/pyqt/download)'
  prefs: []
  type: TYPE_NORMAL
- en: Note that you should install PyQt4 binary for Python version 2.6\. The PyQt4
    for Python version 2.5 or earlier may not support the Phonon module. Check the
    PyQt4 documentation to know more. The installation instructions for PyQt4 were
    already discussed in [Chapter 2](ch02.html "Chapter 2. Working with Images"),
    *Working with Images*. Refer to that chapter for further details. The following
    table summarizes the installation prerequisites.
  prefs: []
  type: TYPE_NORMAL
- en: Summary of installation prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Package | Download location | Version | Windows platform | Linux/Unix/OS
    X platforms |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Python | [http://python.org/download/releases/](http://python.org/download/releases/)
    | 2.6.4 (or any 2.6.x) | Install using binary distribution | Install from binary.
    Also install additional developer packages (for example, with python-devel in
    the package name for rpm-based linux distributions).Build and install from the
    source tarball. |'
  prefs: []
  type: TYPE_TB
- en: '| PyQt4 | [http://www.riverbankcomputing.co.uk/software/pyqt/download](http://www.riverbankcomputing.co.uk/software/pyqt/download)
    | 4.6.2 or later | Install using binary pertaining to Python2.6 | First install
    SIP 4.9 or later.Then install PyQt4. |'
  prefs: []
  type: TYPE_TB
- en: Introduction to QT Phonon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In earlier chapters on audio and video processing, we extensively used GStreamer
    multimedia framework. **Phonon** is a multimedia framework used by QT to provide
    audio/video playback. With the GStreamer API knowledge under our belt, it should
    be very easy to grasp the fundamental concepts behind the Phonon multimedia framework.
  prefs: []
  type: TYPE_NORMAL
- en: Main components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's briefly discuss some of the fundamental components and concepts behind
    the Phonon architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Media graph
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is analogous to a GStreamer `pipeline`. The media graph specifies various
    *nodes* (analogous to GStreamer elements) for processing the media stream. For
    example, the *sink* node gives the media data as output. To begin streaming the
    media data within the `Graph`, we call the `play()method` of the `MediaObject`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Media object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This object is used for the media playback. It is analogous to the portion of
    a GStreamer pipeline that handles the input media data. The instance of `MediaObject`
    class is used for this purpose. It provides methods to control the playback, such
    as playing, pausing, and stopping the streaming media.
  prefs: []
  type: TYPE_NORMAL
- en: Sink
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just like in GStreamer, Phonon has a media `Sink`. For example, an audio sink
    is used to output the audio through an audio output device.
  prefs: []
  type: TYPE_NORMAL
- en: Path
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Path` object is used to connect nodes within a media graph in Phonon. For
    example, a `MediaObject` node is linked to an `AudioOutput` node to stream an
    audio.
  prefs: []
  type: TYPE_NORMAL
- en: Effects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To manipulate the streaming media, we need to insert `Effects` nodes within
    the `Graph`, between the source (MediaObject) and the `Sink` nodes. These nodes
    are also called processors. The `Effect` class of the Phonon framework facilitates
    adding various effects to the streaming media.
  prefs: []
  type: TYPE_NORMAL
- en: Backends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is a `backend` that does the heavy lifting, which is, processing a media
    stream in Phonon. On Windows platform the backend framework is *DirectShow*. If
    you are using Linux, the backend framework for Phonon is GStreamer and, it is
    *QuickTime* in case you use Mac OS X. The supported functionality (for example,
    the media formats supported) may vary depending on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: The namespace, `Phonon.BackendCapabilities`, includes functions that provide
    information about what the Phonon backend is capable of doing. For example, the
    function `BackendCapabilities.availableMimeTypes()` returns a list of all the
    mime types that the backend is capable of decoding. Additionally, it provides
    information about the available audio output devices and available effects.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qt Phonon includes several modules that help to quickly develop applications
    for audio and video playback. We will briefly discuss a few of the important modules.
  prefs: []
  type: TYPE_NORMAL
- en: MediaNode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the superclass for all the nodes within a Phonon media graph. Therefore,
    it is inherited by modules such as `MediaObject, Effect`, and `AudioOutput`, which
    will be discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: MediaSource
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the name indicates, this is used to the input the media source. The `MediaObject`
    uses the media data it provides. The following line of code shows how this is
    accomplished.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The API method, `setCurrentSouce` of class `MediaObject`, is used to specify
    the `MediaSource` object from which to obtain the media data.
  prefs: []
  type: TYPE_NORMAL
- en: MediaObject
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned earlier, the `MediaObject` module defines an API to manage the
    playback. The methods such as `play(), pause()`, and `stop()` provide playback
    controls.
  prefs: []
  type: TYPE_NORMAL
- en: Path
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Path` class links the nodes within a graph. It can be created using an
    API method, `Phonon.createPath`. The following code snippet shows an example usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, `self.audioPath` is an instance of `Path` class. It links the instance
    of class `MediaObject` with `self.audioSink`, which is an instance of class `AudioOutPut`.
    More nodes can be added to the graph by using `Path.insertEffect`.
  prefs: []
  type: TYPE_NORMAL
- en: AudioOutput
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The instance of this class provides an audio output node in the Phonon media
    graph. The output device is typically the sound card. `AudioOutput` is connected
    to the `MediaObject` (and `Effect` instances) using the `Path` object we just
    discussed. The property `AudioOutput.outputDevice()` contains information about
    the output device.
  prefs: []
  type: TYPE_NORMAL
- en: Effect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The instance of class `Effect` can be inserted as a node into the media graph.
    The `Path.insertEffect` can bring about this effect whereas `Path.removeEffect`
    facilitates removal of that node from the graph. This object modifies the streaming
    media data. For example, an echo effect will add an echo to the audio. Use `BackendCapabilities.availableAudioEffects`
    to find out which effects are supported by the Phonon backend.
  prefs: []
  type: TYPE_NORMAL
- en: VideoPlayer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This class provides an important functionality. It has several built-in features
    that eliminate the need of explicitly creating nodes such as `MediaObject`. We
    will discuss this in detail while developing the video player application.
  prefs: []
  type: TYPE_NORMAL
- en: SeekSlider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`SeekSlider` is a GUI widget. This class provides a slider to seek a specific
    position in the streaming media. It handles all the necessary updates and signal
    connections internally. All it needs is the media object instance.'
  prefs: []
  type: TYPE_NORMAL
- en: volumeSlider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This class provides a widget for controlling the volume. It makes a programmer's
    job easy by internally connecting signals. The following line of code sets the
    audio output device for a volume slider.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `volumeSlider` will control the volume for the audio output device
    of `self.audioSink`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project: GUI-based music player'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get straight to the business. We will develop a simple GUI-based music
    player using QT Phonon. The goal of this project is to learn how to put together
    important components of the Phonon framework discussed earlier. It will help us
    get familiar with the overall Phonon framework. In the second project, we will
    learn an even simpler way to accomplish the same task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application to be developed here will play an opened audio file. It will
    have GUI widgets to control the playback and add various effects to the streaming
    audio. The screenshot of the music player application is shown in the following
    illustration of its graphical user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project: GUI-based music player](img/0165_8_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: GUI elements in the music player
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The illustrated music player application uses the following QT widgets.
  prefs: []
  type: TYPE_NORMAL
- en: '`QMainWindow:` This class provides the main application window. In this window,
    other elements such as buttons and menus are added in a layout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QToolButton:` The play, pause, and stop buttons are created using the `QToolButton`
    class. The appearance of these `QToolButtons` can be tweaked using a number of
    properties; for example, calling `QToolButtoon.setAutoRaise(True):` Removes the
    raised button effect. On mouse hover, the button will be highlighted and appear
    raised above the surface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VolumeSlider:` As discussed earlier, the volume slider widget is used for
    controlling the volume of the output audio device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SeekSlider:` Used to seek a position within the streaming media. While the
    music is being played, its position is automatically updated. You can drag the
    slider using mouse to jump to a different position on the track.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QLineEdit:` This widget is used to display the full path of the media file
    currently being played.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QMenubar:` This is the menu bar above the `QLineEdit`. Here, we add different
    menus such as **File** and **Effects**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QAction:` Various audio effect options are added to the **Effects** menu as
    `QAction` instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of these QT elements just discussed are pointed out in the following illustration
    of a music player application displaying various QT widgets used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![GUI elements in the music player](img/0165_8_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Generating the UI code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The required GUI is built using the QT Designer application. This should be
    included in the binary installer of PyQT4\. QT Designer provides a quick way to
    design and develop the user interface code. It supports a number of commonly used
    QT widgets. One can interactively add these widgets to a layout. This tool is
    also very useful to enhance the aesthetic appeal of the application. For example,
    the widget colors and other properties can easily be changed using various features
    available in QT Designer.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - generating the UI code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The UI file necessary for this application is already created for you. The purpose
    of this section is not to show you how to generate the UI from scratch. It will
    just illustrate some of the important aspects of developing GUI using QT Designer
    for this application. You can then experiment with it further to add new widgets
    to the music player application. We used QT Designer while developing the 'Thumbnail
    Maker' application in [Chapter 2](ch02.html "Chapter 2. Working with Images"),
    *Working with Images*. We will cover some of those things here as well.
  prefs: []
  type: TYPE_NORMAL
- en: Download the file `Ui_AudioPlayerDialog.ui` from the Packt website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the QT Designer application that comes with the PyQt4 installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open this file in QT Designer. Click on each widget element within this audio
    player dialog. The QT class associated with the selected widget will be displayed
    in the **Property Editor** panel of the QT Designer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice the red-colored borders around various UI widgets within the dialog.
    These borders indicate a 'layout' in which the widgets are arranged. The layouts
    are created using the `QLayout` class and its various subclasses. It is a critical
    component of the user interface design using QT. Without a layout in place, the
    UI elements may appear distorted when you run the application and, for instance,
    resize the dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following illustration shows how the dialog appears when opened in QT Designer
    the music player dialog (.ui file) in QT Designer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action - generating the UI code](img/0165_8_3.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Closely observe the borders around the widgets that indicate the presence of
    a layout. You will notice that there are multiple borders. This implies that we
    have placed the widgets in multiple layouts. For example, the buttons Play, Pause,
    and Stop are arranged in a horizontal layout, QHBoxLayout. These are further arranged
    in another horizontal layout with the volumeSlider element. Refer to QT4 and QT
    Designer documentation to know how to arrange widgets in a layout.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you click on the **Type Here** placeholder in the menu bar, it becomes editable.
    With this, you can add a new menu to the menu bar. Similarly, you can add menu
    items to the **File** and **Effects** menus by opening those menus and clicking
    on **Type Here** menu item. The **File** menu has two menu items: **Open** and
    **Exit**. Note that the **Effects** menu is empty. We will add menu items to this
    menu later. In the following few steps, we will make minor changes to this dialog
    just to get a feel of QT Designer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will now add a widget that can display digits. This widget can be used to
    update the playtime information of the streaming media. The left panel shows a
    bunch of widgets that can be mouse dragged and dropped inside the Audio Player
    dialog window. This is illustrated by the following screenshot:![Time for action
    - generating the UI code](img/0165_8_4.jpg)![Time for action - generating the
    UI code](img/0165_8_5.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can see the Display widget panel of QT Designer and the LCD number widget
    inserted into the dialog.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The inserted LCD number widget is shown selected in the screenshot on the right-hand
    side. It is inserted in a layout that arranges QToolButtons and the volumeSlider
    widgets in a horizontal fashion. Also, notice that the inserted LCD number widget
    has a default size. This size needs to be adjusted so that other widgets get their
    share of the space. Various parameters can be adjusted using the property editor
    panel within QT Designer for this widget. Here, we adjust the maximum size values
    as illustrated in the following screenshot.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action - generating the UI code](img/0165_8_6.jpg)![Time for action
    - generating the UI code](img/0165_8_7.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The Property Editor for LCD number widget the screenshot on the right-hand side
    shows the edited size parameters.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the maximum width and height parameters are adjusted, the LCD number widget
    fits in nicely within the horizontal layout. The resultant dialog is shown in
    the next illustration.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action - generating the UI code](img/0165_8_8.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: That's it! You can keep this LCD number widget in the dialog for now. After
    completion of this project, you can use it to add a feature that displays the
    time information for the streaming media. Note that LCD Number widget is not the
    only option to display the play time. You can even use a QTextLabel and update
    the label string with the time.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As mentioned in the chapter, [Chapter 2](ch02.html "Chapter 2. Working with
    Images"), *Working with Images*, the QT Designer saves the user interface file
    with an extension `.ui`. To convert this into Python source code, PyQt4 provides
    a conversion utility called `pyuic4`. On Windows XP, for standard Python installation,
    the path for this utility is `C:\Python26\Lib\site-packages\PyQt4\pyuic4.bat`.
    Add the path to the environment variable. Alternatively, specify the whole path
    each time you want to convert `.ui` file to Python source file. The conversion
    utility can be run from the command prompt as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This script will create a Python source file, Ui_AudioPlayerDialog.py from the
    input .ui file. You can further review this file to understand how the UI code
    is set up. We will use this file 'as-is' for the further discussion.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: It is *not* a good idea to modify the autogenerated Python source file, `Ui_AudioPlayerDialog.py`;
    if you make any changes to the corresponding `.ui` file of the QT Designer and
    run the `pyuic4` script again, it will *overwrite* the previous Python source
    file, `Ui_AudioPlayerDialog.py`, provided we use the same filename. Instead, you
    can use the autogenerated file as a base class and create a subclass to add custom
    UI elements programmatically.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section gave us a working knowledge of tweaking a user interface using
    QT Designer. Just to get the feel of user interface editing, we added a LCD number
    widget to the Audio Player dialog. We learned how to autogenerate the Python source
    code from a `.ui` file created with the help of QT Designer.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The command-line utility `pyuic4` (pyuic4.bat for Windows users) enabled conversion
    of the user interface created by the QT-Designer into a Python source file. However,
    various widgets in this UI need to respond to the user actions. For example, when
    the **Play** button is clicked, it must start streaming the media file. Thus,
    we need to add necessary code that will instruct these widgets what they should
    do when a certain event occurs. This is accomplished using the slots and signals.
    A `signal` is emitted when a particular GUI `event` occurs. For example, when
    a user clicks on the **Pause** button, a `"clicked()" signal` is emitted. A `slot`
    is a method that is called for this `signal`. This is very similar to the how
    we connected `pad-added` signal by a `decodebin` element to a method `decodebin_pad_added`
    in earlier chapter. Refer to the PyQt4/ QT4 documentation that has a comprehensive
    list of available `signals` for various widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - connecting the widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's learn how to make widgets respond to a particular user action, such as
    a button click.
  prefs: []
  type: TYPE_NORMAL
- en: Download the file `AudioPlayerDialog.py` from the Packt website. It defines
    the class `AudioPlayerDialog`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will now review the method that connects class methods to the emitted signals.
    These signals are generated whenever a particular 'event' occurs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the self._dialog is an instance of class Ui_AudioPlayerDialog. Note that,
    the self.connect is an inherited method of the QT class QMainWindow. It takes
    the following arguments (QObject, SIGNAL, callable). The QObject is any widget
    type; SIGNAL is generated when a specific event occurs. The callable is a method
    that handles this event. The AudioPlayer._connect method connects all the necessary
    signals with class methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The File menu in the Audio Player dialog contains two `QActions`, namely, `fileOpenAction`
    and `fileExitAction`. When File->Open is selected, a signal "triggered" is generated
    for the `QAction`. We need to watch out for this signal and then call a method
    that will do the job of opening a file. This signal is connected by the code between
    lines 5-7\. Thus, when "triggered()" signal is emitted, for `fileopenAction`,
    a method `AudioPlayer._openFileDialog` is called that has necessary code to open
    an audio file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's review the code on line 9-12\. This code connects all the `QActions` within
    a `QMenu` to a method of class `AudioPlayer`. The first argument, `self._dialog.menuAudioEffects`,
    is the Effects menu in the menu bar. This is a `QMenu`. The second argument `SIGNAL("triggered(QAction*)")`
    tells QT that we want to capture the triggered signal for any of the `QActions`
    within the **Effects** menu. This is best explained with an example. Imagine that
    the audio **Effects** menu has menu items (QActions) such as Echo and Distortion.
    When a user selects **Effects** | **Echo** or **Effects** | **Distortion**, the
    `triggered(QAction*)` signal is emitted. The argument `QAction*` is just a pointer
    to that `QAction`. The third argument is the receiver method, `self._changeAudioEffects`
    that is called when this signal is emitted.![Time for action - connecting the
    widgets](img/0165_8_9.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The clicked() signal emitted when a QToolButton, such as, Play, Pause, or Stop
    is clicked. This signal is connected to appropriate methods of class AudioPlayer
    by the code block 13-23.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that we didn't connect the `SeekSlider` and `VolumeSlider`. The signals
    for these widgets are connected internally. All you need to do is set `MediaObject`
    and `AudioOutput` for these widgets respectively. We will learn how that's done
    in the next section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We reviewed `AudioPlayerDialog._connect()` method to learn how various widgets
    within the Audio Player dialog are connected to internal methods. This helped
    us learn some preliminary concepts of GUI programming using QT.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the audio player code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The discussion so far has been focused on the graphical user interface. We learned
    how to use QT Designer to create user interface and then generate a Python source
    file representing this UI. We also reviewed the code that connects the frontend
    of our application with the backend (the class methods). Now, it is time to review
    the workhorse audio processing code responsible for playing the audio, controlling
    the playback, and operations like adding audio effects.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - developing the audio player code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source file, `AudioPlayerDialog.py`, used in the earlier section will be
    used here as well. The class `AudioPlayerDialog` inherits `QMainWindow`.
  prefs: []
  type: TYPE_NORMAL
- en: If you have not done so already, download the Python source file `AudioPlayerDialog.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's start with the constructor of the class, `AudioPlayerDialog`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code block from lines 2 to 6 initializes some instance variables to be used
    later. The dictionary object self.effectsDict will be used to store information
    about the available audio effects. Whereas, self.addedEffects is used to check
    if an audio effect is already added to the streaming media.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On line 13, the instance of Phonon.MediaObject is created. It will be used for
    controlling the playback of a MediaSource.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: An audio output node in the Phonon media graph is created by the code on lines
    14-16\. We will call it as self.audioSink, the terminology used in earlier chapter.
    The first argument for AudioOutput is used to specify the category. It is an object
    of class Phonon.Category. Since this is a music player application, we define
    the category as Phonon.MusicCategory. Review QT documentation to know more about
    the categories. The second argument is used as a parent for this audio sink.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Phonon.Path class links the nodes within a media graph. This object is created
    using an API method, Phonon.createPath. On line 17, the Path self.audioPath links
    the media object self.mediaObject with the audio output self.audioSink.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The call to the _createUI method handles the defining of the user interface.
    We already learned how the frontend communicates with the backend using the connections
    set up in the _connect method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, on line 28, the API method QMainWindow.show()displays the audio player.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The method `_createUI` delegates most of the GUI creation to the class `UI_AudioPlayerDialog`.
    The method also has the code that further modifies the GUI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The instance of class UI_AudioPlayerDialog is created on line 4\. setupUI and
    retranslateUI are the automatically generated methods. These are generated when
    the QT Designer file with the UI is converted into a Python source file. The AudioPlayerDialog
    instance is passed as an argument to these two methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code block 7 to 14 sets up the icons for the three QToolButton instances.
    The setIcon API method takes QIcon instance as an argument. The music player icon
    in the caption (on top-left corner of the dialog) is created by the code on line
    15\. As mentioned earlier, the Phonon.SeekSlider signals are internally connected.
    We only need to tell which MediaObject it will handle. This is done on line 17\.
    Similarly, on line 18, the setAudioOutput method of volumeSlider sets up the self.audiosink
    as the audio output for this volumeSlider. While setting up the UI design, we
    did not add any menu items to the Effects menu. This is done now, by calling the
    _setupEffectsMenu method on line 16.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's review the method `_setupEffectsMenu`. It adds various available audio
    effects in the Phonon framework as menu items to the **Effects** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The namespace, Phonon.BackendCapabilities includes functions that provide information
    about the capability of the Phonon backend. BackendCapabilities.availableAudioeffects()
    returns a list of all audio effects supported by Phonon on a given platform. The
    list, availableEffects, contains objects of the class Phonon.EffectDescription.
    self.effectsDict stores the name of the effect and the EffectDescription object
    as key-value pairs. This dictionary will be used later. The Effects menu, menuAudioEffects,
    is populated with the QAction instances corresponding to each of the available
    audio effects. QAction is created on line 6\. The setCheckable property of QAction
    toggles the checked state of the action on mouse click. The following screenshot
    shows the Effects menu items on Windows XP.![Time for action - developing the
    audio player code](img/0165_8_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method `_openFileDialog` is called when **File** | **Open** is clicked from
    the music player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This pops up a QFileDialog with the file type filters as specified on line 10\.
    To know about the supported media formats, you can use the Phonon.BackEndCapabilities
    as illustrated by the following line of code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where, types is a list of available mime types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The path of the file specified by the user is then stored in the variable self._filePath.
    This path is displayed in the fileLineEdit field of the dialog. On line 15, the
    method _loadNewMedia is called. We will review that next.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The method `_loadNewMedia` sets up the media source for the `MediaObject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The if block on line 4 ensures that the current streaming audio (if any) is
    stopped by the media object before setting the new media source to a playing state.
    Although it is not necessary, the memory occupied by the MediaSource object is
    cleared up by the code on line 6\. Line 8 creates a new instance of class MediaSource.
    The API method, setCurrentSouce of the class MediaObject is used to specify the
    MediaSource that provides the media data. With this, our media player is all set
    to stream the audio file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you click on the **Play** button in the music player, the `AudioPlayerDialog._playMedia`
    method is called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First the program carries out some primary checks to ensure that the media is
    playable and then calls the play() method of Phonon.MediaObject, which begins
    streaming the audio. The methods _pauseMedia and _stopMedia of class AudioPlayerDialog
    contain similar code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We just learned how to set up the media graph, stream the media, and control
    its playback. Now let''s see how to add audio effects to this streaming media.
    If any of the items in the Effects menu are clicked, the AudioPlayerDialog._changeAudioEffects
    method is called:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The if and else blocks in the preceding code snippet add and remove effects
    nodes from the media graph respectively. The if block is executed when an action
    in the Effects menu is checked. When an already checked action is toggled, the
    program executes the else block. In the if block, an instance of Phonon.Effect
    is created on line 6\. This takes an EffectDescription object as an argument.
    As seen in the _setupEffectsMenu method, self.effectsDict stores the EffectDescription
    objects as the dictionary values. On line 8, this effect is inserted as a node
    in the media graph. The self.audioPath links all the nodes within the media graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The dictionary, self.addedEffects keeps track of all the audio effects inserted
    within the media graph. The else block removes an already added effect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On line 11, an added effect is removed by calling the removeEffect API method
    of Phonon.Path. The corresponding key-value pair of self.addedEffects is also
    deleted on line 12\. This also ensures that there is no memory leak.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: QT Phonon allows adding the same audio effect multiple times. For example, you
    can create multiple 'Chorus' effect nodes within the media graph using `Path.insertEffect`.
    Each of the added effects will have its own contribution. However, in our application,
    we support adding an effect only once. You can extend this to support adding the
    same effect multiple times. For this, you will need to tweak the **Effects** menu
    UI and make some other changes in the code to keep track of the added effects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The application will not terminate properly if you close the GUI window while
    an audio file is being played. To safely terminate the application without any
    memory leaks, `AudioPlayerDialog` overrides the `QMainWindow.closeEvent`. Before
    closing the window, we do the necessary cleanup to avoid memory leaks. The code
    is illustrated below.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The streaming media, if any, is first stopped. The call to _clearEffectsObject
    deletes all the Phonon.Effect and Phonon.EffectDescription objects (if present).
    The method _clearEffectsObject is self-explanatory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following code creates an instance of `QApplication` and executes this program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Review the rest of the code from the file `AudioPlayerDialog.py` and then run
    the music player as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should display the music player GUI window. Use File | Open to specify
    a music file and then click on the Play button to enjoy the music!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just created our own music player! We developed a frontend for this music
    player using QT Phonon multimedia framework. Use of various modules in QT Phonon
    was thoroughly discussed. We learned how to set up audio controls and effects
    in a media graph by using modules such as `MediaObject, AudioOutput, Path`, and
    so on. We also gained some higher-level understanding of GUI programming aspects
    using QT.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero add more features to the audio player
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Generating the UI code* section, we added a widget to the music player
    GUI window. This is an LCD number widget that can display the frame numbers. Connect
    this widget to the Audio Player backend, so that it can display the current media
    time. The next illustration shows this LCD number widget in action for a streaming
    audio file.
  prefs: []
  type: TYPE_NORMAL
- en: Extend this music player application so that it can play all the songs from
    a directory or CD one after the other. There are a number of ways to create a
    user interface to display the files. For example, you can try using widgets such
    as `QDirectoryView` , `QTreeView`, or `QTableWidget`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Music player displaying the frame number (time) in the LCD number widget:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Have a go hero add more features to the audio player](img/0165_8_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Project: GUI-based video player'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first project, we learned the fundamentals of the QT Phonon framework.
    In this project, we will extend that knowledge further by developing a video player.
    The Audio player was developed by building a media graph. Various nodes such as
    `MediaObject, AudioOutput`, and `Effects` were linked together by creating a `Phonon.Path`.
    If the goal is just to develop a simple audio or video player, the job is even
    simpler. Phonon has a module `VideoPlayer` that provides an abstract way to play
    an audio or a video without the need to explicitly create `MediaObject, AudioOutput`,
    and some other objects. All it needs is a `MediaSource`. It is also possible to
    create a custom media graph by adding various audio-effect nodes. We will see
    how to do it later. For now, let's write a simple video player application using
    QT Phonon. The following illustration shows the video player in action.
  prefs: []
  type: TYPE_NORMAL
- en: '![Project: GUI-based video player](img/0165_8_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Generating the UI code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: QT Designer is an excellent resource for generating user interface interactively.
    As we have seen, most of the user interface for this project is built using QT
    Designer. In addition, some important points about the user interface design using
    QT were covered. This section will just walk you through the user interface generation
    for this application using QT Designer and `pyuic4`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - generating the UI code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `.ui` file is already created. In the following discussion, we will simply
    use this file and go through some of the GUI elements needed for this application.
  prefs: []
  type: TYPE_NORMAL
- en: Download the file `Ui_VideoPlayerDialog.ui` from the Packt website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open this file in QT Designer. Click on each widget element. The QT class associated
    with the selected widget will be displayed in the **Property Editor** panel on
    the right-hand side. Most of the widgets used here are same as the ones used in
    the earlier project. The only widget that is different is the `Phonon.VideoPlayer`.
    The following illustration shows how the dialog appears when opened in QT Designer.
    It also points out various Phonon widgets used in the dialog.![Time for action
    - generating the UI code](img/0165_8_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The video player widget in QT Designer appears as shown in the preceding screenshot.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on the `VideoPlayer` widget shown in the preceding illustration. The **Property
    Editor** will display its properties. Pay attention to how the size of this widget
    is defined. This Video Player will support an option to view the video in 'Full
    Screen' mode. Therefore, the maximum size parameters for the `VideoPlayer` widget
    are set to high values as shown in the next screenshot. In fact, we are using
    the QT default values for the maximum size property. The only property modified
    is the minimum size of the widget. This minimum size will be the default size
    of the video player widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Property editor for Video Player widget:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action - generating the UI code](img/0165_8_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The rest of the widgets are the same as the one used in an earlier project.
    You can add the LCD **Number** widget or a simple text label that displays the
    current time for the streaming media. Refer to the last project for instructions
    on adding such widgets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, convert the `.ui` file into `.py` using the `pyuic4` conversion utility.
    The conversion utility can be run from the command prompt as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This script will create a Python source file, Ui_VideoPlayerDialog.py, from
    the input .ui file. We will use this file 'as-is' for the further discussion.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous discussion served as a refresher on use of QT Designer to generate
    most of the user interface elements needed for this project. The `pyuic4` conversion
    utility was used to convert the `.ui` file to a Python source file.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the widgets used in the previous project are re-used here. Therefore,
    this is going to be a short discussion. In this project, we have not included
    an **Effects** menu. Thus, the `VideoPlayerDialog._connect` method has minor changes.
    This method is illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines of code are a new widget connection. The rest of the connections
    are the same as the ones discussed in the previous project. When **View** | **Full
    Screen** is selected, the `toggled(bool)` signal of `fullScreenAction` is emitted.
    When this happens the `slot` method `self._toggleFullScreen` is called. The next
    section will have more details about this method.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the video player code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The generated frontend is connected to the backend for processing the media.
    In this section, we will review the video player backend that actually streams
    the media and controls the playback and volume. Our job is easier here. Most of
    the good work we did in the earlier project will be re-used here. There will be
    some minor modifications because we will be using `Phonon.VideoPlayer` for video
    processing instead of explicitly creating the objects such as `MediaObject`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action - developing the video player code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's develop the rest of the video player backend. We will re-use several methods
    from the `AudioPlayerDialog` class with a few minor changes. Only the important
    methods will be covered in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Download the file `VideoPlayerDialog.py` from the Packt website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The constructor of the class is shown below.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The self._dialog creates an instance of class Phonon.VideoPlayer. Once a media
    source is specified, self._dialog.videoPlayer is able to stream the media. Thus,
    for the media streaming itself, we don't need to create the nodes MediaObject
    and AudioOutput explicitly; the Phonon.VideoPlayer internally builds the media
    graph. However, MediaObject and AudioOutput are required for seekSlider and volumeControl
    widgets respectively. On lines 14 and 15, these objects are obtained from self._dialog.videoPlayer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `_createUI` method is almost identical to the corresponding method in `AudioPlayerDialog`,
    except that it doesn't have the **Effects** menu-related code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Following that, the method to review is `_playMedia:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code is self-explanatory. The self.mediaSource is set in VideoPlayerDialog._loadNewMedia.
    This MediaSource instance is passed as an argument to the API method VideoPlayer.play.
    The videoPlayer then builds the media graph internally and plays the given media
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This simple video player supports an option to view the streaming video in full
    screen mode. `QMainWindow` class provides an easy way to change the view between
    full screen and normal viewing mode. This is done by the method `_toggleFullScreen`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The method, self.showFullScreen() is inherited from class QMainWindow. If the
    QAction in the View menu (View | Full Screen) is checked, the video player window
    is set to full screen. QMainWindow.showNormal() changes the video player back
    to the normal viewing mode. The following screenshot shows the video player in
    the full screen mode. Notice that the window caption bar is hidden in the full
    screen mode.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Video player in full screen mode is illustrated as shown in the next image:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action - developing the video player code](img/0165_8_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Review the rest of the code from file `VideoPlayerDialog.py`. Keep this file
    in the same directory as `Ui_VideoPlayerDialog.py` and then run the program from
    the command line as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The video player GUI window will appear. Open any supported audio or video file
    and click on the **Play** button to begin the playback.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We wrote our own video player. This video player is capable of playing video
    as well as audio files of supported formats. The module `Phonon.VideoPlayer` that
    enables media playback and control was used here. We also learned how to toggle
    view between full screen and normal viewing mode using the API methods of class
    `QMainWindow`.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero do more with the video player
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is a simple enhancement. The full screen mode shows widgets such as playback
    control buttons, seek, and volume sliders. Hide these widgets when the **View**
    | **Full Screen** action is checked. Also, add a keyboard shortcut to toggle between
    normal and full screen view mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add audio effects to the video player GUI. We already learned how to add audio
    effects to the media graph in the first project. You can re-use that code here.
    However, you will need an appropriate `Phonon.Path` object to which the `effects`
    node needs to be added. In the last project, we used `Phonon.createPath` we can't
    create a new path as it is created internally by the VideoPlayer. Instead, the
    path can be obtained using API method `MediaObject.outputPaths()`. This method
    returns a list containing output (audio and video) paths. The line of code is
    shown as an example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, be careful with the memory leaks. If you add audio effects, and then
    exit the application, the program may freeze. This could be because the effect
    nodes are not deleted from the original audio path. Alternatively, you can build
    the video player from basic principles. That is, don't use Phonon.VideoPlayer.
    Instead, build a custom media graph just like how we did for the audio player
    project. In this case, you will need to use modules such as Phonon.VideoWidget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter taught us several things about GUI multimedia application development
    using QT. We worked on two exciting projects where audio and video players using
    QT Phonon framework were developed. To accomplish these tasks, we:'
  prefs: []
  type: TYPE_NORMAL
- en: Used QT Designer to generate the UI source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handled the QT generated events by connecting slots (class methods) with signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used Phonon framework to set up media graphs for streaming of audio and video
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
