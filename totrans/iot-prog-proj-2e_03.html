<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer075">
<h1 class="chapter-number" id="_idParaDest-48"><a id="_idTextAnchor048"/>3</h1>
<h1 id="_idParaDest-49"><a id="_idTextAnchor049"/>Building an IoT Weather Indicator</h1>
<p>In this chapter, we will learn about servo motors and LEDs and then use this knowledge, along with our understanding of the Raspberry Pi and web services, to create a practical project: an IoT <span class="No-Break">weather indicator.</span></p>
<p>The weather indicator will draw weather information from a web service and then use a pointer attached to the servo motor to indicate suitable attire based on the current outdoor conditions. It will include an LED that turns on when it’s raining and blinks on and off if there is a thunderstorm. The configuration that you’ll use to create this application may be used for other applications, such as a water quality monitor or a traffic <span class="No-Break">density monitor.</span></p>
<p>We’ll start by looking at servo motors, which will help us understand what they are and how we may use them in our IoT applications. Then, we’ll focus <span class="No-Break">on LEDs.</span></p>
<p>Following that, we’ll begin constructing a physical stand to house the components for our application. This will be the second specially designed stand for the Raspberry Pi that we will build for this book and the first one that features <span class="No-Break">a motor.</span></p>
<p>While the usage of the SenseHAT case, as discussed in <em class="italic">Chapters 1</em> and <em class="italic">2</em>, was optional, it is recommended to build this stand for the weather indicator. This construction will represent our first foray into creating a tangible, physical entity, or more specifically, an Internet of Things (<span class="No-Break">IoT) </span><span class="No-Break"><em class="italic">thing</em></span><span class="No-Break">.</span></p>
<p>Once our stand has been assembled, we’ll dive into coding. Our goal will be to extract information from <a id="_idIndexMarker222"/>the <strong class="bold">OpenWeatherMap</strong> web service and utilize it to dictate the position of the needle affixed to our servo motor based on the temperature and wind speed. We will also adjust the LED’s behavior according to certain weather conditions. By implementing these processes, we will illustrate how real-world data can be transformed into physical movements, bridging the gap between the digital and <span class="No-Break">mechanical worlds:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<img alt="Figure 3.1 – Connecting our weather indicator to a web service" height="413" src="image/B21282_03_1.jpg" width="1013"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Connecting our weather indicator to a web service</p>
<p>In this chapter, we will explore the <span class="No-Break">following topics:</span></p>
<ul>
<li>Looking into <span class="No-Break">servo motors</span></li>
<li><span class="No-Break">Exploring LEDs</span></li>
<li>Controlling servo motors and LEDs <span class="No-Break">using Python</span></li>
<li>Building the weather <span class="No-Break">indicator stand</span></li>
<li>Developing code for <span class="No-Break">our application</span></li>
</ul>
<p><span class="No-Break">Let’s begin!</span></p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor050"/>Technical requirements</h1>
<p>You’ll need the following to complete <span class="No-Break">this chapter:</span></p>
<ul>
<li>The Raspberry Pi 5 4/8 GB model is preferred, but the Raspberry Pi 4B with either 4 GB or 8 GB may be used (the figures in this book show the Raspberry Pi <span class="No-Break">4B model).</span></li>
<li>The latest Raspberry Pi operating system with <span class="No-Break">Thonny pre-installed.</span></li>
<li>A keyboard, mouse, <span class="No-Break">and monitor.</span></li>
<li>1x SG90 <span class="No-Break">servo motor.</span></li>
<li>1x LED (<span class="No-Break">single color).</span></li>
<li>1x 220 <span class="No-Break">Ohm resistor.</span></li>
<li>½ inch <span class="No-Break">PVC pipe.</span></li>
<li>Jumper wires with connectors for the Raspberry Pi’s <strong class="bold">general-purpose input/output</strong> (<span class="No-Break"><strong class="bold">GPIO</strong></span><span class="No-Break">) port.</span></li>
<li>Access to a 3D printer or 3D printing service for the <span class="No-Break">custom stand.</span></li>
<li>A general knowledge of programming. We will be using the Python programming language in <span class="No-Break">this book.</span></li>
</ul>
<p>The GitHub repository for this chapter is located <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter3"><span class="No-Break">https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter3</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor051"/>Looking into servo motors</h1>
<p><strong class="bold">Servo motors</strong> are <a id="_idIndexMarker223"/>widely used in robotics, automation, and other applications where precise control of angular movement is required. Hooking up servo motors to the Raspberry Pi is a straightforward process that offers exciting possibilities for various projects. The Raspberry Pi provides a suitable platform to interface and control servo motors. In this section, we will investigate servo motors in <span class="No-Break">more detail.</span></p>
<p class="callout-heading">Exploring the GPIO port</p>
<p class="callout">The GPIO port on the Raspberry<a id="_idIndexMarker224"/> Pi allows for direct hardware interaction, making it a key tool for hands-on projects. It allows us to connect devices, sensors, and circuits, allowing for real-world applications such as robotics or alarm systems to be created. By utilizing these pins, we can design and build projects that interact with the physical world. We will cover the GPIO port in more depth in <a href="B21282_05.xhtml#_idTextAnchor080"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>. For now, it is enough to know that we can simply connect devices such as servo motors and LEDs to the GPIO port using female <span class="No-Break">jumper connectors.</span></p>
<p>We will start by hooking up an SG90 servo motor to our Raspberry Pi 5 using the <span class="No-Break">GPIO port.</span></p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor052"/>Connecting the SG90 servo motor to our Raspberry Pi</h2>
<p>The SG90 servo motor <a id="_idIndexMarker225"/>is a popular and widely used micro-servo motor due to its compact size, versatility, precise control, and ease of use. When connecting the SG90 servo motor to our Raspberry Pi, it is necessary to modify the wire alignment within the female 3-prong connector. This <a id="_idIndexMarker226"/>connector is commonly known as the <strong class="bold">JR-style servo connector</strong> or simply <strong class="bold">servo connector</strong> and is initially wired with the power (+5V) and GND wires in reverse order from what is required for our <span class="No-Break">Raspberry Pi.</span></p>
<p>Referring to <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.2</em>, we<a id="_idIndexMarker227"/> can adjust the wiring by performing <a id="_idIndexMarker228"/>the <span class="No-Break">following steps:</span></p>
<ol>
<li>First, identify the three wires in the connector – red (power), brown (ground), and <span class="No-Break">orange (signal).</span></li>
<li>Next, gently pull the wires from the connector while holding the plastic housing up using a sharp object such as an <span class="No-Break">Xacto knife.</span></li>
<li>Then, rearrange them so that the red (power) wire is at one end, the brown (GND) wire is in the middle, and the orange (signal) wire is at the opposite end of the <span class="No-Break">red wire:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer053">
<img alt="Figure 3.2 – Changing the wiring order for the SG90 servo" height="637" src="image/B21282_03_2.jpg" width="849"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Changing the wiring order for the SG90 servo</p>
<ol>
<li value="4">With the <a id="_idIndexMarker229"/>wiring in the correct order, we <a id="_idIndexMarker230"/>can connect the servo motor directly to our Raspberry Pi. Using the diagram in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.3</em> as a reference, connect the female 3-prong connector to the +5V, GND, and GPIO 14 pins of the <span class="No-Break">Raspberry Pi:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer054">
<img alt="Figure 3.3 – Connecting our servo to the Raspberry Pi" height="754" src="image/B21282_03_3.jpg" width="980"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Connecting our servo to the Raspberry Pi</p>
<p class="callout-heading">An alternate method for connecting our servo</p>
<p class="callout">For those of us who would rather not modify the existing connector of the servo, we may use three male-to-female jumper wires instead, with the male end inserted into the connector and the female end inserted into the GPIO port on the <span class="No-Break">Raspberry Pi.</span></p>
<p>With our servo motor connected to our Raspberry Pi, let’s investigate what servo motors are and how we may <span class="No-Break">use them.</span></p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor053"/>Understanding servo motors</h2>
<p>Servo motors <a id="_idIndexMarker231"/>consist of <a id="_idIndexMarker232"/>a <strong class="bold">direct current</strong> (<strong class="bold">DC</strong>) motor, a control circuit, and a feedback mechanism for maintaining the angular position of the output shaft. Robotics, toys, and radio-controlled cars are some of the applications where servos are <span class="No-Break">predominantly used.</span></p>
<p>Servo motors stand out for their exceptional precision in controlling the position of the motor thanks to their closed-loop feedback mechanism. This mechanism constantly monitors the motor’s actual position and adjusts it so that it matches the desired position, ensuring accurate and reliable performance. <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.4</em> shows the popular SG90 <span class="No-Break">servo motor:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<img alt="Figure 3.4 – SG90 servo motor" height="435" src="image/B21282_03_4.jpg" width="476"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – SG90 servo motor</p>
<p>The range of<a id="_idIndexMarker233"/> movement for servo motors can vary, depending on the model. Some servos are designed for 180-degree movement, making them ideal for limited-range applications such as controlling robot joints or stabilizing camera gimbals. Other servos are capable of full 360-degree rotation, which makes them suitable for continuous motion applications, such as steering mechanisms or pan-tilt <span class="No-Break">camera systems.</span></p>
<p>The angle control of servos is achieved <a id="_idIndexMarker234"/>through <strong class="bold">pulse-width modulation</strong> (<strong class="bold">PWM</strong>). PWM involves sending varying pulse widths to the servo, akin to adjusting a volume knob to control sound level; in servos, these pulses dictate the arm’s position. Different brands of servo have different maximum and minimum values to determine the angle of the servo needle. <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.5</em> demonstrates the relationship between PWM and the position of a <span class="No-Break">180-degree servo:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<img alt="Figure 3.5 – PWM and servo position" height="405" src="image/B21282_03_5.jpg" width="772"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – PWM and servo position</p>
<p>Armed with our knowledge of the essentials of servo motors<a id="_idIndexMarker235"/> and their connection to the Raspberry Pi 5, we’ll turn our attention to LEDs. Our exploration will cover how they function and the steps to incorporate them into our project, providing an additional layer of <span class="No-Break">visual feedback.</span></p>
<h1 id="_idParaDest-54"><a id="_idTextAnchor054"/>Exploring LEDs</h1>
<p>LEDs were <a id="_idIndexMarker236"/>first developed in the early 1960s. The first LEDs were red and were first used as indicators in seven-segment displays. Today, LEDs are virtually everywhere – from indicator lights on our electronic devices and home appliances to the screens of our televisions <span class="No-Break">and smartphones.</span></p>
<p>An LED is a simple semiconductor device. It has two leads – an anode (positive) and a cathode (negative). When a forward current passes through the diode from the anode to the cathode, it emits light. The color of the light depends on the materials that are used to make the diode and can range from infrared to ultraviolet, including all the colors of the <span class="No-Break">visible spectrum.</span></p>
<p>LEDs come in various types, including single-color LEDs, RGB LEDs, which are capable of producing a multitude of colors, infrared LEDs, which are used in remote controls and night-vision systems, and bi-color LEDs, which can emit two different colors. <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.6</em> shows an array of LEDs ranging from a single-colored red to a seven-colored flash LED (second from left) to an RGB (second from right) LED capable of displaying any color. For our weather indicator, we will be using a single-colored LED. The color <span class="No-Break">doesn’t matter:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<img alt="Figure 3.6 – LEDs in various formats" height="384" src="image/B21282_03_6.jpg" width="619"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – LEDs in various formats</p>
<p>Now that we have a basic understanding of <a id="_idIndexMarker237"/>LEDs, it’s time to connect an LED to our <span class="No-Break">Raspberry Pi.</span></p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor055"/>Connecting an LED to our Raspberry Pi</h2>
<p>Connecting an LED to a <a id="_idIndexMarker238"/>Raspberry Pi<a id="_idIndexMarker239"/> requires us to carefully consider voltage requirements –  exceeding the voltage can cause the LED to burn out. To do this, we must solder a resistor to one end of the LED before connecting it to the GPIO port with jumper wires. Since the Raspberry Pi’s GPIO pins output at a higher voltage than most LEDs can handle directly, the inclusion of the resistor is essential to regulate the voltage, ensuring that the LED <span class="No-Break">operates correctly.</span></p>
<p><span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.7</em> shows the materials that we need to connect our LED to the GPIO port on the Raspberry Pi – an LED, two jumper wires with female ends (brown and red), shrink tubing, and a 220 <span class="No-Break">Ohm resistor:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<img alt="Figure 3.7 – The parts that are required to connect our LED to the Raspberry Pi" height="580" src="image/B21282_03_7.jpg" width="705"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – The parts that are required to connect our LED to the Raspberry Pi</p>
<p>To connect <a id="_idIndexMarker240"/>our LED to our Raspberry Pi, we must do <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker241"/></span><span class="No-Break"> following:</span></p>
<ol>
<li>Start by soldering the resistor to the anode (positive) or longer leg of the LED (see <em class="italic">A</em> in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">):</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer059">
<img alt="Figure 3.8 – Soldering a resistor and jumper wires to our LED" height="931" src="image/B21282_03_8.jpg" width="746"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – Soldering a resistor and jumper wires to our LED</p>
<ol>
<li value="2">Then, splice <a id="_idIndexMarker242"/>and solder the brown jumper wire onto <a id="_idIndexMarker243"/>the cathode (negative) leg of the LED (see <em class="italic">B</em> in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">).</span></li>
<li>Next, splice and solder the red jumper wire onto the other end of the resistor. We may consider the extra length created by the resistor and shorten the red wire accordingly (see <em class="italic">B</em> in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">).</span></li>
<li>To strengthen the new connections and provide additional electrical insulation, apply heat shrink tubing over the soldered wires and resistor (see <em class="italic">C</em> in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">).</span></li>
<li>Using<a id="_idIndexMarker244"/> the jumper wires, attach the brown<a id="_idIndexMarker245"/> wire to GPIO GND on the Raspberry Pi and the red wire to GPIO 25 (see <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">):</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer060">
<img alt="Figure 3.9 – Wiring up our servo and LED to the Raspberry Pi" height="760" src="image/B21282_03_9.jpg" width="1100"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Wiring up our servo and LED to the Raspberry Pi</p>
<p>Now that we’ve wired up our servo and LED components, let’s write some code so that we can control our components <span class="No-Break">through Python.</span></p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor056"/>Controlling servo motors and LEDs using Python</h1>
<p>Having successfully connected the servo motor and LED to our Raspberry Pi, we’ll start writing the Python control code. To facilitate this, we will be using the <strong class="bold">GPIO Zero Python library</strong>, a <a id="_idIndexMarker246"/>powerful tool for Raspberry Pi GPIO programming. Our first step in this process will be to set up a Python virtual environment so that we can develop <span class="No-Break">our code.</span></p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor057"/>Setting up our development environment</h2>
<p>Just like we did in <a href="B21282_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, we will use a Python virtual environment for our development. As there are libraries that<a id="_idIndexMarker247"/> only work with the root installation of Python, we will use system packages in our Python virtual environment. To do this, follow <span class="No-Break">these steps:</span></p>
<ol>
<li>On our Raspberry Pi 5, open a <span class="No-Break">Terminal application.</span></li>
<li>To store our project files, create a new directory by running the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">mkdir Chapter3</strong></pre></li> <li>Then, navigate to the <span class="No-Break">new directory:</span><pre class="source-code">
<strong class="bold">cd Chapter3</strong></pre></li> <li>Create a new Python virtual environment for <span class="No-Break">our project:</span><pre class="source-code">
<strong class="bold">python -m venv ch3-env --system-site-packages</strong></pre></li> <li>With this command, we’ve created a new Python virtual environment called <strong class="source-inline">ch3-env</strong> and enabled access to the system site packages. With our new Python virtual environment created, we can source into it with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">source ch3-env/bin/activate</strong></pre></li> <li>Install the extra packages that are required for our code with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">pip install requests</strong></pre></li> <li>The <strong class="source-inline">requests</strong> library in Python simplifies making HTTP requests to web servers. We will use the <strong class="source-inline">requests</strong> library when we pull weather data from the web. With the <strong class="source-inline">requests</strong> library installed, we may close the Terminal by running the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">exit</strong></pre></li> </ol>
<p>With our project folder created, our Python virtual environment set up and activated, and the <strong class="source-inline">requests</strong> package installed, we may now start writing code. We will start by controlling the servo motor through Python code using <span class="No-Break">the Terminal.</span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor058"/>Using GPIO Zero to control a servo</h2>
<p>GPIO Zero<a id="_idIndexMarker248"/> is a Python library for controlling the GPIO pins on the Raspberry Pi. It was created in 2016 by Ben Nuttall and Dave Jones of the Raspberry Pi Foundation. GPIO Zero provides a user-friendly and high-level interface, making it easier to work with GPIO, including controlling LEDs, buttons, servos, and more. It comes pre-installed with the latest Raspberry Pi <span class="No-Break">operating system.</span></p>
<p>The <strong class="source-inline">Servo</strong> class is <a id="_idIndexMarker249"/>a part of GPIO Zero and provides a way to control a servo motor. To test our servo motor’s connection to our Raspberry Pi, follow <span class="No-Break">these steps:</span></p>
<ol>
<li>Open a Terminal window and navigate to our project folder by running the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">cd Chapter3</strong></pre></li> <li>Source our <strong class="source-inline">ch3-env</strong> virtual environment with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">source ch3-env/bin/activate</strong></pre></li> <li>Open a Terminal window in our <strong class="source-inline">ch3-env</strong> virtual environment and launch Python with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">python</strong></pre></li> <li>Then, enter the following code to import the <strong class="source-inline">Servo</strong> class and create an object called <strong class="source-inline">servo</strong>. After that, initialize it with the PIN we connected our Servo to in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">from gpiozero import Servo</strong>
<strong class="bold">servo = Servo(14)</strong></pre></li> <li>The <strong class="source-inline">Servo</strong> class provides several useful methods to control a servo motor. To set the servo to the minimum position, run the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">servo.min()</strong></pre></li> <li>After executing this command, we should notice that our servo motor has pivoted completely to one side. To move our servo motor to the middle position, we can use the following <span class="No-Break">Python command:</span><pre class="source-code">
<strong class="bold">servo.mid()</strong></pre></li> <li>After executing this command, we should observe that our servo motor has moved to the mid position. For the final test, we’ll move our servo motor to the <span class="No-Break">maximum position:</span><pre class="source-code">
<strong class="bold">servo.max()</strong></pre></li> <li>We should observe that our servo motor moves to the maximum position (we shouldn’t be alarmed if the motor doesn’t move as far to the maximum position as it does to the minimum position as we will calibrate the motor later in this chapter). To close our <a id="_idIndexMarker250"/>servo connection, run the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">servo.close()</strong></pre></li> </ol>
<p class="callout-heading">Why is the servo motor jittering?</p>
<p class="callout">We may observe jittering<a id="_idIndexMarker251"/> from our SG90 servo motor when it’s controlled through GPIO Zero. A multitude of factors may contribute to this issue, ranging from the power provided to the servo via the GPIO port, to potential mechanical problems with the servo, or even software-related issues within the library. Although an investigation into these causes falls outside the scope of this project, we must acknowledge the potential for motor jittering. A straightforward solution involves closing the connection to the servo using the <strong class="source-inline">servo.close()</strong> command after setting <span class="No-Break">its position.</span></p>
<p>With our servo motor tested, we can focus on the LED. In the next section, we will write some code to control the status of our LED using the <span class="No-Break">GPIO library.</span></p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor059"/>Using GPIO Zero to control an LED</h2>
<p>The <strong class="source-inline">LED</strong> class is a part of the GPIO<a id="_idIndexMarker252"/> Zero library and provides a simple interface to control <a id="_idIndexMarker253"/>an LED. We can use this class to control our LED. To test the connection of our LED, follow <span class="No-Break">these steps:</span></p>
<ol>
<li>First, open a new Terminal window and navigate to our project folder with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">cd Chapter3</strong></pre></li> <li>Then, source our <strong class="source-inline">ch3-env</strong> virtual environment with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">source ch3-env/bin/activate</strong></pre></li> <li>Launch Python by running the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">python</strong></pre></li> <li>Enter the following code to import the <strong class="source-inline">LED</strong> class and create an object called <strong class="source-inline">led</strong>. Once you’ve done this, initialize it with the PIN we connected our LED to in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">from gpiozero import LED</strong>
<strong class="bold">led = LED(25)</strong></pre></li> <li>The <strong class="source-inline">LED</strong> class provides several useful methods to control an LED. To turn on the LED, type <span class="No-Break">the following:</span><pre class="source-code">
<strong class="bold">led.on()</strong></pre></li> <li>After executing this command, we should notice that our LED has turned on. For the next test, we’ll turn our LED off by running the following <span class="No-Break">Python command:</span><pre class="source-code">
<strong class="bold">led.off()</strong></pre></li> <li>After executing this command, we should observe that our LED has turned off. For the final test, we’ll blink <span class="No-Break">our LED:</span><pre class="source-code">
<strong class="bold">led.blink()</strong></pre></li> <li>We<a id="_idIndexMarker254"/> should observe that our LED starts blinking. To <a id="_idIndexMarker255"/>stop this and turn the LED off, run the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">led.off()</strong></pre></li> </ol>
<p>Should we encounter issues during testing, there could be several <span class="No-Break">potential causes:</span></p>
<ul>
<li><strong class="bold">Incorrect wiring</strong>: Incorrect wiring is among the most common problems. It’s crucial to verify our connections and ensure we’ve wired the correct GPIO pin according to our <span class="No-Break">Python script.</span></li>
<li><strong class="bold">Issues with the power supply</strong>: Power supply inadequacies might also lead to issues. While the Raspberry Pi’s GPIO pins may not supply adequate power for certain servos, especially under load, causing the servo to act unpredictably, our SG90 servo and LED shouldn’t face this issue, given they have a lower <span class="No-Break">power demand.</span></li>
<li><strong class="bold">Software</strong>: Software-related issues could also pose problems. Keeping the Raspberry Pi OS and GPIO Zero library up to date is an essential <span class="No-Break">preventative measure.</span></li>
<li><strong class="bold">Components</strong>: Issues could lie within the components themselves. By testing them with a known, functioning device, we can either confirm or rule out <span class="No-Break">this possibility.</span></li>
</ul>
<p>Now that we’ve tested our servo and LED components alongside the corresponding code, we can construct the stand that will house <span class="No-Break">our project.</span></p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor060"/>Building the weather indicator stand</h1>
<p>In this section, our focus will shift to <a id="_idIndexMarker256"/>assembling the stand for our weather indicator. While it’s not imperative for running the code, building the stand is highly recommended as it adds a tangible, real-world aspect to our project, bringing the <em class="italic">thing</em> in IoT <span class="No-Break">to life.</span></p>
<p>While this book does not provide a comprehensive guide on 3D printing, we will briefly outline the key steps involved in fabricating the stand. We’ll be using a<a id="_idIndexMarker257"/> standard <strong class="bold">fused deposition modeling</strong> (<strong class="bold">FDM</strong>) printer, ideally one with a print size such as the “Ender-3” (220mm x 220mm x 250mm). Our material of choice for this exercise<a id="_idIndexMarker258"/> is <strong class="bold">polylactic acid</strong> (<strong class="bold">PLA</strong>) since it’s known for its ease of use and suitability for beginners. Alternatively, <strong class="bold">polyethylene terephthalate glycol-modified</strong> (<strong class="bold">PETG</strong>) is <a id="_idIndexMarker259"/>also a great option, offering enhanced strength and flexibility. We’ll go through the basics of printing and assembling the stand <span class="No-Break">components here.</span></p>
<p class="callout-heading">Should I print in PLA or PETG?</p>
<p class="callout">When deciding whether to print in <a id="_idIndexMarker260"/>PLA or PETG, there are several factors for us to consider. PLA is known for its ease of use, making it a popular choice for beginners. It prints at lower temperatures, doesn’t warp as easily as other materials, and generally provides more precise details. PETG is known for its strength and flexibility, which surpasses that of PLA. PETG<a id="_idIndexMarker261"/> prints at a higher temperature than PLA and has excellent layer adhesion, resulting in more robust prints. However, PETG can be more challenging to print with due to its tendency to string or ooze. For the weather indicator stand we built for this chapter, PLA was used. This was because printing was done directly on a glass plate and PETG tends to stick too well to glass, potentially resulting in damage being done to the build plate upon removing <span class="No-Break">the print.</span></p>
<p>For those of us who do not have access to a 3D printer or prefer not to print the parts ourselves, using a 3D printing service such as<a id="_idIndexMarker262"/> Shapeways (<a href="https://www.shapeways.com">https://www.shapeways.com</a>) is a <span class="No-Break">convenient alternative.</span></p>
<p>Now that we’ve covered the options for obtaining our 3D-printed parts, either by printing them ourselves or using a service, let’s move on to the next crucial phase of our project – assembling the weather <span class="No-Break">indicator stand.</span></p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor061"/>Assembling the weather indicator stand</h2>
<p>As mentioned previously, the <a id="_idIndexMarker263"/>weather indicator stand has been engineered to be composed of components produced via an FDM 3D printer. Unlike the SenseHAT case and stand from <em class="italic">Chapters 1</em> and <em class="italic">2</em>, the design approach for this weather indicator stand is built with a <em class="italic">plate-like</em> configuration. This method effectively eliminates thin horizontal walls, a structural vulnerability that’s frequently found <a id="_idIndexMarker264"/>in parts created with <span class="No-Break">FDM technology.</span></p>
<p class="callout-heading">Finding the files for 3D printing</p>
<p class="callout">The 3D model files for the parts, which have been specifically designed for 3D printing, can be downloaded from the <strong class="source-inline">Build Files</strong> directory in this chapter’s GitHub repository. Please note that these files are provided in the .stl format only, not in other 3D model <span class="No-Break">file formats.</span></p>
<p>Before we start constructing our stand, let’s look at <span class="No-Break">the parts.</span></p>
<h3>Identifying the parts</h3>
<p><span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.10</em> shows the <a id="_idIndexMarker265"/>parts that make up the weather indicator stand. All the parts, except for the base, were printed on an FDM 3D printer. Two additional parts – a half-inch PVC pipe and the front sticker – <span class="No-Break">aren’t shown:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer061">
<img alt="Figure 3.10 – Parts of the weather indicator stand" height="751" src="image/B21282_03_10.jpg" width="888"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – Parts of the weather indicator stand</p>
<p>Let’s take a<a id="_idIndexMarker266"/> closer look at <span class="No-Break">each part:</span></p>
<ul>
<li><strong class="bold">Base</strong>: The <a id="_idIndexMarker267"/>base serves as the foundation for our stand. It’s the component where the <strong class="bold">pipe base</strong> is fastened. While the base is an integral part of the design, it can be considered optional, depending on the specific installation. For instance, the stand could be attached directly to a table, wall, or even a ceiling, offering flexible positioning based on individual preferences and requirements. The base displayed in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.10</em> was created out of 20mm pine wood using a CNC router (a computer-controlled cutting machine that’s used for cutting various hard materials, such as wood), although a 3D printer may be used to make this part <span class="No-Break">as well.</span></li>
<li><strong class="bold">Back plate and front plate</strong>: These<a id="_idIndexMarker268"/> halves, when glued together, form the stand’s plate. The division into halves aligns with the need for a flat surface <a id="_idIndexMarker269"/>in 3D printing, given the plate’s lack of an inherent flat side. The plate is the main component of our stand as it holds the servo motor, arrow, and Raspberry Pi, which is attached to the back. The plate has been designed to hold either a Raspberry Pi, a Raspberry Pi Zero, or a Raspberry Pi <span class="No-Break">Pico W.</span></li>
<li><strong class="bold">Plate hook</strong>: Designed <a id="_idIndexMarker270"/>to be compatible with GoPro series stands, the hook provides the main connection of the plate on the stand. Of note here is the deliberate printing orientation and built-in support of the plate hook to eliminate line adhesion issues that would cause the plate hook to break apart if printed in the traditional flat side down (see <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.11</em></span><span class="No-Break">):</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer062">
<img alt="Figure 3.11 – Plate hook print orientation" height="528" src="image/B21282_03_11.jpg" width="439"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – Plate hook print orientation</p>
<ul>
<li><strong class="bold">Pipe base and plate bracket</strong>: These <a id="_idIndexMarker271"/>two<a id="_idIndexMarker272"/> components hold the ½ inch PVC pipe (not shown). The pipe base attaches the PVC pipe to the base and the plate bracket attaches the PVC pipe to the <span class="No-Break">plate hook.</span></li>
<li><strong class="bold">8mm LED holder</strong>: We <a id="_idIndexMarker273"/>utilize the LED holder to fasten the LED onto the front of the main <span class="No-Break">plate face.</span></li>
<li><strong class="bold">Arrow</strong>: The<a id="_idIndexMarker274"/> arrow is connected to the servo motor and acts as the analog needle for our weather <span class="No-Break">indicator application.</span></li>
<li><strong class="bold">Alignment tool</strong>: This<a id="_idIndexMarker275"/> tool acts as a guide that aligns the back plate and front plate correctly during gluing, ensuring they are properly aligned to avoid any issues when installing the <span class="No-Break">servo motor.</span></li>
<li><strong class="bold">PVC pipe (not shown)</strong>: The<a id="_idIndexMarker276"/> stand features a half-inch PVC pipe serving as its stem or central support. This design offers the flexibility to adjust the stand’s height according to our needs. In situations where the base is unnecessary, such as when securing it to a table, wall, or ceiling, we can easily set the stand’s height to the <span class="No-Break">desired level.</span></li>
<li><strong class="bold">Face sticker (not shown)</strong>: The <a id="_idIndexMarker277"/>weather indicator’s face is created using a sticker printed on sticker paper with an inkjet printer. To ensure precise placement on the main plate, a vinyl cutter such as the <strong class="bold">Silhouette Cameo</strong> can be <a id="_idIndexMarker278"/>utilized to cut out the sticker. For convenience, we have included both a <strong class="source-inline">Silhouette</strong> file and a <strong class="source-inline">.svg</strong> file with the cut lines in the <strong class="source-inline">Build Files</strong> folder of our <span class="No-Break">GitHub repository.</span></li>
<li><strong class="bold">M5 20mm bolt and M5 nut (not shown)</strong>: To <a id="_idIndexMarker279"/>fasten the<a id="_idIndexMarker280"/> plate to the pedestal portion of the stand, we use a 20mm M5 bolt and corresponding <span class="No-Break">M5 nut.</span></li>
</ul>
<p>With the parts identified, let’s start by creating the main plate for <span class="No-Break">our stand.</span></p>
<h3>Assembling the plate</h3>
<p>The<a id="_idIndexMarker281"/> plate or face of the weather indicator stand is created by gluing the front plate and back plate together. To assemble the plate, follow <span class="No-Break">these steps:</span></p>
<ol>
<li>First, apply <a id="_idIndexMarker282"/>epoxy glue to the flat side of one of the plates (see <em class="italic">A</em> in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.12</em>). When applying glue, it’s crucial to avoid spreading glue near the servo or LED openings. It’s recommended to apply glue right to the boundaries of <span class="No-Break">the plate:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer063">
<img alt="Figure 3.12 – Assembling the plate" height="692" src="image/B21282_03_12.jpg" width="1020"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – Assembling the plate</p>
<ol>
<li value="2">After applying glue, put the flat sides of the plates together. Using the alignment tool, ensure that the plates are aligned with each other (see <em class="italic">B</em> in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.12</em></span><span class="No-Break">).</span></li>
<li>Once the plates have been aligned, remove the <span class="No-Break">alignment tool.</span></li>
<li>Should it be needed, use clamps on the plates to prevent any space from forming between them. Let the glue dry before proceeding (see <em class="italic">C</em> in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.12</em></span><span class="No-Break">).</span></li>
<li>After the <a id="_idIndexMarker283"/>plates have dried, apply epoxy glue to the flat part of the hook and place it in the groove on the back of the plate (see <em class="italic">D</em> in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.12</em></span><span class="No-Break">).</span></li>
<li>After the glue has dried, paint the plate if <span class="No-Break">you wish.</span></li>
<li>To finish off the assembly, print and cut out the face sticker and apply it to the front of the plate inside the ridges (see <em class="italic">A</em> and <em class="italic">B</em> in <span class="No-Break"><em class="italic">Figure </em></span><span class="No-Break"><em class="italic">3</em></span><span class="No-Break"><em class="italic">.13</em></span><span class="No-Break">, respectively):</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer064">
<img alt="Figure 3.13 – Plate face sticker" height="843" src="image/B21282_03_13.jpg" width="625"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13 – Plate face sticker</p>
<p>With the main <a id="_idIndexMarker284"/>plate constructed, it is now time to build the pedestal, which will hold the <span class="No-Break">main plate.</span></p>
<h3>Assembling the pedestal</h3>
<p>The<a id="_idIndexMarker285"/> pedestal portion of our stand includes the base, the pipe base, the PVC pipe, and the plate bracket. To assemble the pedestal, follow <span class="No-Break">these steps:</span></p>
<ol>
<li>Start by inserting the PVC pipe (cut to a desired length) into the pipe base (see <em class="italic">A</em> in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.14</em></span><span class="No-Break">):</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer065">
<img alt="Figure 3.14 – Assembling the pedestal" height="730" src="image/B21282_03_14.jpg" width="1107"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14 – Assembling the pedestal</p>
<ol>
<li value="2">Then, secure the pipe base to the base, table, wall, or ceiling as desired (see <em class="italic">B</em> in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.14</em></span><span class="No-Break">).</span></li>
<li>To finish assembling the pedestal, insert the plate bracket into the top of the PVC pipe (see <em class="italic">C</em> in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.14</em></span><span class="No-Break">).</span></li>
</ol>
<p>Pay attention when assembling the pedestal as variations in the manufacturer’s PVC pipe could result in an improper fit or difficulty when inserting it into the pedestal parts. If the pipe fits too loosely, it is recommended to apply epoxy glue to securely attach the pipe. Conversely, if the pipe is too thick to fit properly, we have two options: either sand down the insides of the pipe base or plate bracket or sand the outside of the pipe to achieve a proper and <span class="No-Break">snug fit.</span></p>
<p>It’s important to be aware that in our example, the components of the pedestal were coated with flat black spray paint, so any additional thickness resulting from the paint should <span class="No-Break">be considered.</span></p>
<p>With the <a id="_idIndexMarker286"/>pedestal components constructed, we’re ready to integrate our electronic components into our weather <span class="No-Break">indicator stand.</span></p>
<h3>Installing the Raspberry Pi, servo, and LED</h3>
<p>With our plate and pedestal constructed, the last thing we must do before putting the stand together is install our Raspberry Pi, servo motor, and LED onto the plate and wire all these <span class="No-Break">components together.</span></p>
<p>To do this, follow <a id="_idIndexMarker287"/><span class="No-Break">these steps:</span></p>
<ol>
<li>Utilizing 10mm M2.5 bolts, fasten our Raspberry Pi to the base of the plate, ensuring it aligns correctly with the appropriate stand-offs (see <em class="italic">A</em> in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.15</em></span><span class="No-Break">).</span></li>
<li>With the aid of a hot glue gun (preferred) or epoxy glue, secure our SG90 servo to the rear side of the plate. To do this, align the front structure of the SG90 with the hole present in the plate (see <em class="italic">B</em> in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.15</em></span><span class="No-Break">):</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer066">
<img alt="Figure 3.15 – Installing the Raspberry Pi, servo, and LED" height="1054" src="image/B21282_03_15.jpg" width="847"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.15 – Installing the Raspberry Pi, servo, and LED</p>
<ol>
<li value="3">Referring to<a id="_idIndexMarker288"/> the wiring diagrams in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.3</em> and <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.9</em>, wire up our servo motor and LED to the GPIO port<a id="_idIndexMarker289"/> of the Raspberry Pi (see <em class="italic">C</em> in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.15</em></span><span class="No-Break">).</span></li>
<li>With our Raspberry Pi wired up, it’s time to put the LED in place. Start by threading the LED through the LED hole in the plate (see <em class="italic">A</em> in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.16</em></span><span class="No-Break">):</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer067">
<img alt="Figure 3.16 – Putting our LED in place" height="917" src="image/B21282_03_16.jpg" width="723"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.16 – Putting our LED in place</p>
<ol>
<li value="5">Then, thread the LED<a id="_idIndexMarker290"/> through the LED holder and push the holder into the LED hole in the front of the plate (see <em class="italic">B</em> in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.16</em></span><span class="No-Break">).</span></li>
</ol>
<p>With our plate fully wired and all the components securely fastened, we can attach the plate to <span class="No-Break">the pedestal.</span></p>
<h3>Connecting the plate to the pedestal</h3>
<p>By attaching the plate to the<a id="_idIndexMarker291"/> pedestal, we will have finished constructing our weather <span class="No-Break">indicator stand.</span></p>
<p>To complete our stand, follow <span class="No-Break">these steps:</span></p>
<ol>
<li>Start <a id="_idIndexMarker292"/>by aligning the hook on the back of the plate with the plate bracket on the pedestal (<em class="italic">A</em> in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.17</em></span><span class="No-Break">):</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer068">
<img alt="Figure 3.17 – Attaching the plate to the pedestal" height="780" src="image/B21282_03_17.jpg" width="599"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.17 – Attaching the plate to the pedestal</p>
<ol>
<li value="2">Then, insert a 20mm M5 bolt and fasten it with an M5 nut (see the red rectangle in <em class="italic">A</em> in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.17</em></span><span class="No-Break">).</span></li>
<li>Finally, make any final adjustments to the angle of the plate before tightening the bolt fully (see <em class="italic">B</em> in <span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.17</em></span><span class="No-Break">).</span></li>
</ol>
<p>With that, we’ve finished assembling our weather indicator stand. This setup could be repurposed for many other IoT applications, including monitoring traffic conditions or tracking fluid levels in <span class="No-Break">industrial environments.</span></p>
<p>Our next step is to write the code that will retrieve weather data from a web service and use it to control the servo motor and LED. Now is also the best time to introduce the arrow into our setup as it needs to be calibrated before it can be used in <span class="No-Break">our code.</span></p>
<h1 id="_idParaDest-62"><a id="_idTextAnchor062"/>Developing code for our application</h1>
<p>In this section, we will connect our Raspberry Pi to the <strong class="source-inline">OpenWeatherMap.org</strong> web service and use the data to control the position of the needle on our weather indicator. For this, we need to use the API key we received from <strong class="source-inline">OpenWeatherMap.org</strong> when we set up an account in <a href="B21282_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic">Chapter 2</em></span></a><span class="No-Break">.</span></p>
<p>Throughout this section, our Raspberry Pi, once mounted, will remain connected to a monitor, keyboard, and mouse. When the moment arrives to set up our weather indicator independently, all we’ll need is a power source and a means to remotely access the Raspberry Pi via SSH. Discussing how to configure a Raspberry Pi so that it can operate in <em class="italic">headless</em> mode falls outside the scope of this chapter. However, detailed instructions for this setup can easily be found through various online resources. Helpful starting points include the official Raspberry Pi documentation, technology-focused forums such as Stack Overflow, and dedicated Raspberry Pi community websites <span class="No-Break">and blogs.</span></p>
<p>We will follow the software architecture<a id="_idIndexMarker293"/> laid out in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.18</em> for our code. At the heart of our architecture is the <strong class="source-inline">WeatherData</strong> class. We will use this class to connect to the <a id="_idIndexMarker294"/>OpenWeatherMap <span class="No-Break">web service:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer069">
<img alt="Figure 3.18 – Software architecture for our weather indicator" height="400" src="image/B21282_03_18.jpg" width="1003"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.18 – Software architecture for our weather indicator</p>
<p>The <strong class="source-inline">WeatherData</strong> class fetches and processes weather data from the OpenWeatherMap API, while the <strong class="source-inline">WeatherDashboard</strong> class controls the display mechanisms: a needle indicator controlled by a servo motor and an LED that changes state based on the <span class="No-Break">weather conditions.</span></p>
<p>These two classes work together, with <strong class="source-inline">WeatherData</strong> fetching and processing data, which is then used by <strong class="source-inline">WeatherDashboard</strong> to adjust the display. To keep the data current, the <strong class="source-inline">update_dashboard()</strong> function is set to run in an infinite loop, refreshing weather data and updating the display every <span class="No-Break">30 minutes.</span></p>
<p>To address the unique hardware constraint of the servo motor – that is, its tendency to jitter if the connection is not closed after a move – we’ll create a fresh instance of <strong class="source-inline">WeatherDashboard</strong> (and consequently, a new <strong class="source-inline">Servo</strong> instance) with every cycle of the loop. While this approach may not be the most common in software design, it’s a practical solution that successfully solves the servo jitter issue by <em class="italic">reopening</em> the connection with each <a id="_idIndexMarker295"/><span class="No-Break">new instance.</span></p>
<p>We’ll begin by calibrating the arrow’s (or needle’s) position for optimal application performance before we create our <strong class="source-inline">WeatherData</strong> and <span class="No-Break"><strong class="source-inline">WeatherDashboard</strong></span><span class="No-Break"> classes.</span></p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor063"/>Calibrating the needle</h2>
<p>Before we can use <a id="_idIndexMarker296"/>our weather indicator application, we must calibrate the needle (or the position of the arrow). To do so, follow <span class="No-Break">these steps:</span></p>
<ol>
<li>Close any open Terminals, open a new Terminal window, and navigate to our project folder by running the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">cd Chapter3</strong></pre></li> <li>Then, source our <strong class="source-inline">ch3-env</strong> virtual environment with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">source ch3-env/bin/activate</strong></pre></li> <li>Launch Python with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">python</strong></pre></li> <li>Now, enter the following code to import the <strong class="source-inline">Servo</strong> class and create an object <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">servo</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">from gpiozero import Servo</strong>
<strong class="bold">servo = Servo(14)</strong></pre></li> <li>Next, set the servo to the mid position with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">servo.mid()</strong></pre></li> <li>Using the picture of the face of our weather indicator, install the arrow into the servo in the <span class="No-Break">mid position.</span></li>
<li>With the needle (arrow) in place, let’s do some testing. We will start by moving the needle to the minimum position with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">servo.min()</strong></pre></li> <li>We should notice that the needle swings to the right. This is not the behavior we want as the right-hand side should represent the maximum value, not the minimum value. We should also note that the needle did not swing 90 degrees as we were expecting. We will <a id="_idIndexMarker297"/>address both issues in the <strong class="source-inline">WeatherData</strong> and <strong class="source-inline">WeatherDashboard</strong> <span class="No-Break">classes, respectively.</span></li>
</ol>
<p>We are now ready to write code to control the needle and LED on our weather indicator. We will start with the <span class="No-Break"><strong class="source-inline">WeatherData</strong></span><span class="No-Break"> class.</span></p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor064"/>Creating the WeatherData class</h2>
<p>The <strong class="source-inline">WeatherData</strong> class is designed <a id="_idIndexMarker298"/>to pull weather information for a given city using the OpenWeatherMap API, after which it will process this data to calculate servo and LED values based on the temperature, wind speed, and weather conditions. When initialized with a city name, the class fetches the weather data for that city and stores the temperature, weather conditions, and wind speed. It also provides methods, <strong class="source-inline">getServoValue()</strong> and <strong class="source-inline">getLEDValue()</strong>, to determine the output for the servo motor and LED, respectively, based on the retrieved <span class="No-Break">weather data.</span></p>
<p>Let’s <span class="No-Break">get started:</span></p>
<ol>
<li>Launch Thonny by clicking on the <strong class="bold">Menu</strong> icon in the Raspberry Pi taskbar, navigating to the <strong class="bold">Programming</strong> category, and selecting <strong class="bold">Thonny</strong> (<span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.19</em></span><span class="No-Break">):</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer070">
<img alt="Figure 3.19 – Opening Thonny from the main menu" height="402" src="image/B21282_03_19.jpg" width="528"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.19 – Opening Thonny from the main menu</p>
<ol>
<li value="2">By default, Thonny<a id="_idIndexMarker299"/> uses the Raspberry Pi’s built-in version of Python. For our project, we will use the Python virtual environment we just created. To start, we need to view the project files by clicking on <strong class="bold">View</strong> and selecting <strong class="bold">Files</strong> if it isn’t <span class="No-Break">already selected.</span></li>
<li>In the <strong class="bold">Files</strong> section, locate the <span class="No-Break"><strong class="source-inline">ch3-env</strong></span><span class="No-Break"> directory.</span></li>
<li>Then, right-click on the folder and select <strong class="bold">Activate </strong><span class="No-Break"><strong class="bold">virtual environment</strong></span><span class="No-Break">.</span></li>
<li>Once inside Thonny, create a new tab by selecting <strong class="bold">File</strong> and then <strong class="bold">New</strong> or by hitting <em class="italic">Ctrl</em> + <em class="italic">N</em> on <span class="No-Break">your keyboard.</span></li>
<li>Let’s start our code by entering <span class="No-Break">our imports:</span><pre class="source-code">
import requests</pre><p class="list-inset">Here, <strong class="source-inline">import requests</strong> imports the <strong class="source-inline">requests</strong> library from Python, which is used to send HTTP requests, such as GET and POST requests, to interact with APIs or web services (refer to <a href="B21282_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, for clarification on <span class="No-Break">HTTP requests).</span></p></li> <li>Then, define our class name, <strong class="source-inline">WeatherData</strong>, and our <span class="No-Break">class variables:</span><pre class="source-code">
class WeatherData:
    temperature = 0
    weather_conditions = ''
    wind_speed = 0
    city = ''</pre></li> <li>Our constructor<a id="_idIndexMarker300"/> takes one parameter, <strong class="source-inline">city</strong>. Make the call to the OpenWeatherMap web service in the constructor (when an instance of the <strong class="source-inline">WeatherData</strong> class <span class="No-Break">is created):</span><pre class="source-code">
    def __init__(self, city):
        self.city = city
        api_key = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'
        base_url = "http://api.openweathermap.org/data/2.5/weather"
        complete_url = f"{base_url}?q={self.city}&amp;appid={api_key}&amp;units=metric"
        response = requests.get(complete_url)
        data = response.json()
        if data["cod"] != "404":
            main = data["main"]
            wind = data["wind"]
            weather = data["weather"]
            self.temperature = main["temp"]
            self.weather_conditions = weather[0]["main"]
            self.wind_speed = wind["speed"]</pre><p class="list-inset">Let’s take a <a id="_idIndexMarker301"/>closer look at <span class="No-Break">our code:</span></p><ul><li><strong class="source-inline">self.city = city</strong>: saves the city name to the <span class="No-Break">object’s property</span></li><li><strong class="source-inline">api_key = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'</strong>: Sets the OpenWeatherMap <span class="No-Break">API key</span></li><li><strong class="source-inline">base_url = "http://api.openweathermap.org/data/2.5/weather"</strong>: Sets the base URL for the <span class="No-Break">OpenWeatherMap API</span></li><li><strong class="source-inline">complete_url = f"{base_url}?q={self.city}&amp;appid={api_key}&amp;units=metric"</strong>: Formats the full API URL with the city and <span class="No-Break">API key</span></li><li><strong class="source-inline">response = requests.get(complete_url)</strong>: Sends a GET request to the API and saves <span class="No-Break">the response</span></li><li><strong class="source-inline">data = response.json()</strong>: Converts the API response from JSON format into a <span class="No-Break">Python dictionary</span></li><li><strong class="source-inline">if data["cod"] != "404"</strong>: Checks whether the API response is not a 404 error, which would indicate that the city was <span class="No-Break">not found</span></li><li><strong class="source-inline">self.temperature = main["temp"]</strong>: Saves the current temperature in the city to the <span class="No-Break">object’s property</span></li><li><strong class="source-inline">self.weather_conditions = weather[0]["main"]</strong>: Saves the current weather conditions in the city to the <span class="No-Break">object’s property</span></li><li><strong class="source-inline">self.wind_speed = wind["speed"]</strong>: Saves the current wind speed in the city to the <span class="No-Break">object’s property</span></li></ul></li> <li>By making the <a id="_idIndexMarker302"/>call to the OpenWeatherMap web service and setting the instance variables, all that’s left for our code to do is convert weather data into values for our servo motor and LED. We’ll start with the servo motor value and the <span class="No-Break"><strong class="source-inline">getServoValue()</strong></span><span class="No-Break"> method:</span><pre class="source-code">
    def getServoValue(self):
        if self.temperature &lt; 0:
            temp_factor = 0
        elif self.temperature &gt; 30:
            temp_factor = 1
        else:
            temp_factor = self.temperature / 30
        wind_factor = self.wind_speed / 20
        servo_value = -((temp_factor - (wind_factor/20)) * 2-1)
        return servo_value</pre><p class="list-inset">Here’s a breakdown of <span class="No-Break">our code:</span></p><ol><li class="upper-roman">First, the method checks whether the temperature (<strong class="source-inline">self.temperature</strong>) is less than <strong class="source-inline">0</strong>. If the temperature is below zero, <strong class="source-inline">temp_factor</strong> is set to <strong class="source-inline">0</strong>. This means that if the temperature is negative, there will be no contribution to the final <span class="No-Break">servo value.</span></li><li class="upper-roman">Then, we check whether the temperature is greater than <strong class="source-inline">30</strong>. If this is true, then <strong class="source-inline">temp_factor</strong> is set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">.</span></li><li class="upper-roman">If the temperature falls between 0 and 30 degrees Celsius, then we normalize the temperature data. Normalization is the process of bringing or converting values into a common range. In this case, the temperature data is being scaled to a range of 0 to 1, assuming the temperature is within the range of 0 to 30 degrees Celsius. By dividing the temperature by 30, any temperature<a id="_idIndexMarker303"/> value within this range is proportionally scaled down to a fraction between 0 and 1. For example, if the temperature is 15 degrees Celsius, <strong class="source-inline">temp_factor</strong> will be 0.5. This normalization allows the method to process temperatures consistently, irrespective of their <span class="No-Break">actual value.</span></li><li class="upper-roman"><strong class="source-inline">wind_factor = self.wind_speed / 20</strong> calculates the wind factor by normalizing the wind speed. Like the temperature normalization process, this line of code is used to convert the wind speed into a value within a range of 0 to 1. The wind speed is assumed to be within a range of 0 to 20 kilometers per hour. For example, if the wind speed is 10 kilometers per hour, <strong class="source-inline">wind_factor</strong> will be 0.5. Normalization is particularly useful when combining or comparing different types of data, such as wind speed and temperature in <span class="No-Break">this case.</span></li><li class="upper-roman">The next step is to calculate <strong class="source-inline">servo_value</strong> using both the temperature and wind factors. Specifically, it creates a dampening effect on temperature due to wind speed, representing a wind chill factor. The formula reduces the temperature factor (<strong class="source-inline">temp_factor</strong>) by one-twentieth of the wind factor (<strong class="source-inline">wind_factor</strong>), thereby signifying that for every 5% increase in wind speed, the temperature’s impact decreases by 1%. This is based on our discretionary assumption that wind speed has a cooling effect. After this adjustment for wind chill, the resulting value is transformed to fit into the range of -1 to 1, which is suitable for the servo’s operation. It multiplies the value by 2, shifting the range from 0 to 1 to 0 to 2, and subtracts one to adjust the range to -1 to 1. Finally, the result is negated to account for the servo’s directionality (as we discovered when calibrating the needle). The calculated <strong class="source-inline">servo_value</strong> represents the position of the servo as per the adjusted temperature and wind <span class="No-Break">speed readings.</span></li><li class="upper-roman">Finally, our method returns <strong class="source-inline">servo_value</strong>, which is a value between -1 and 1 based on temperature, and then adjusted for wind speed. This value is ready to be used as input to the servo’s value property in the GPIO <span class="No-Break">Zero library.</span></li></ol></li> <li>The second <a id="_idIndexMarker304"/>method within the <strong class="source-inline">WeatherData</strong> class is utilized to determine the operational state of the LED, which varies based on the current weather conditions. More specifically, the LED is programmed to flash during a thunderstorm, remain solidly illuminated in the event of rain, and be switched off when the weather conditions are neither a thunderstorm nor rain. We call this <span class="No-Break">method </span><span class="No-Break"><strong class="source-inline">getLEDValue()</strong></span><span class="No-Break">:</span><pre class="source-code">
    def getLEDValue(self):
        if (self.weather_conditions=='Thunderstorm'):
            return 2;
        elif(self.weather_conditions=='Rain'):
            return 1
        else:
            return 0</pre><p class="list-inset">Here, the <strong class="source-inline">getLEDValue()</strong> method designates specific values to different weather conditions: it returns <strong class="source-inline">2</strong> for thunderstorms, <strong class="source-inline">1</strong> for rain, and <strong class="source-inline">0</strong> for other conditions. These values are then utilized to control the LED’s behavior – blinking for thunderstorms (<strong class="source-inline">2</strong>), a steady one for rain (<strong class="source-inline">1</strong>), and off for clear <span class="No-Break">weather (</span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">).</span></p></li> <li>To test out <a id="_idIndexMarker305"/>our program directly, include the <span class="No-Break">following code:</span><pre class="source-code">
    if __name__=="__main__":
        weather = WeatherData('Toronto')
        print(weather.getServoValue())
        print(weather.getLEDValue())</pre><p class="list-inset">Let’s take a <span class="No-Break">closer look:</span></p><ul><li><strong class="source-inline">if __name__=="__main__"</strong>: This is the entry point for the program. It is only executed when the script is run directly, not when it is imported as a module in <span class="No-Break">another script:</span><ul><li><strong class="source-inline">weather = WeatherData('Toronto')</strong>: This creates an object of the <strong class="source-inline">WeatherData</strong> class, initializing it with the <strong class="source-inline">'Toronto'</strong> string. We may enter a city of our choice. To verify whether the city we are interested in has data available, we can enter it into the search box on the OpenWeatherMap <span class="No-Break">website (</span><a href="https://openweathermap.org/"><span class="No-Break">https://openweathermap.org/</span></a><span class="No-Break">).</span></li><li><strong class="source-inline">print(weather.getServoValue())</strong>: This is a function call to the <strong class="source-inline">getServoValue()</strong> method of the <strong class="source-inline">weather</strong> object. This method calculates a value based on the temperature and wind speed data for Toronto and then prints this value to <span class="No-Break">the console.</span></li><li><strong class="source-inline">print(weather.getLEDValue())</strong>: This calls the <strong class="source-inline">getLEDValue()</strong> method of the weather object, which sets a flag based on the weather conditions (thunderstorm, rain, or other) for Toronto. This flag determines the state of an LED (flashing, on, or off or 2, 1, or 0, respectively) and the method returns this state. The state is then printed to <span class="No-Break">the console.</span></li></ul></li></ul></li> <li>Save the <a id="_idIndexMarker306"/>code and name the file <strong class="source-inline">WeatherData.py</strong>. Run the code by clicking the green run button, hitting <em class="italic">F5</em> on your keyboard, or clicking on the <strong class="bold">Run</strong> menu option at the top and then <strong class="bold">Run current script</strong> (<span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.20</em></span><span class="No-Break">):</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer071">
<img alt="  Figure 3.20 – Running a script in Thonny" height="537" src="image/B21282_03_20.jpg" width="568"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">  Figure 3.20 – Running a script in Thonny</p>
<ol>
<li value="13">You should see a response similar to <span class="No-Break">the following:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer072">
<img alt="Figure 3.21 – Output from running WeatherData.py" height="161" src="image/B21282_03_21.jpg" width="612"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.21 – Output from running WeatherData.py</p>
<p>With the <strong class="source-inline">WeatherData</strong> class <a id="_idIndexMarker307"/>written and tested, it’s time to move on to the code that controls the weather indicator: the <span class="No-Break"><strong class="source-inline">WeatherDashboard</strong></span><span class="No-Break"> class.</span></p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor065"/>Creating the WeatherDashboard class</h2>
<p>The <strong class="source-inline">WeatherDashboard</strong> class is<a id="_idIndexMarker308"/> integral to the operation of the weather indicator as it’s responsible for controlling the position of the needle and the state of the LED. This class utilizes the <strong class="source-inline">WeatherData</strong> class to gather and interpret weather data, which is then utilized to guide the operation of the physical display. The position of the servo, which dictates the position of the needle, is determined by the temperature and wind speed, while the LED state is indicative of specific weather conditions, such as rain <span class="No-Break">or thunderstorms.</span></p>
<p>To create this class, follow <span class="No-Break">these steps:</span></p>
<ol>
<li>Inside Thonny, activate the <strong class="source-inline">ch3-env</strong> virtual environment if it hasn’t <span class="No-Break">been already.</span></li>
<li>Then, create a new tab by selecting <strong class="bold">File</strong> and then <strong class="bold">New</strong> or by hitting <em class="italic">Ctrl</em> + <em class="italic">N</em> on your keyboard (<span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.22</em></span><span class="No-Break">):</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer073">
<img alt="Figure 3.22 – Creating a new file in Thonny" height="352" src="image/B21282_03_22.jpg" width="273"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.22 – Creating a new file in Thonny</p>
<ol>
<li value="3">We’ll start <a id="_idIndexMarker309"/>with <span class="No-Break">our imports:</span><pre class="source-code">
from gpiozero import Servo
from gpiozero import LED
from time import sleep
from WeatherData import WeatherData</pre><p class="list-inset">Here, we do <span class="No-Break">the following:</span></p><ol><li class="upper-roman">We start by importing the <strong class="source-inline">Servo</strong> and <strong class="source-inline">LED</strong> classes from the <span class="No-Break"><strong class="source-inline">gpiozero</strong></span><span class="No-Break"> library.</span></li><li class="upper-roman">Then, we import the <strong class="source-inline">sleep</strong> function from the <span class="No-Break"><strong class="source-inline">time</strong></span><span class="No-Break"> module.</span></li><li class="upper-roman">Finally, we import the <strong class="source-inline">WeatherData</strong> class to fetch weather condition data and derive the control values for the servo motor and the <span class="No-Break">LED accordingly.</span></li></ol></li> <li>With the imports added, define the class and the <span class="No-Break">class variables:</span><pre class="source-code">
class WeatherDashboard:
    servoCorrection = 0.5
    maxPW = (2.0 + servoCorrection) / 1000
    minPW = (1.0 - servoCorrection) / 1000</pre><p class="list-inset">Here, we have <span class="No-Break">the following:</span></p><ul><li><strong class="source-inline">servoCorrection = 0.5</strong>: This line declares a class-level variable called <strong class="source-inline">servoCorrection</strong> and assigns it a value of <strong class="source-inline">0.5</strong>. This is used to adjust the minimum and maximum pulse widths for the <span class="No-Break">servo motor.</span></li><li><strong class="source-inline">maxPW = (2.0 + servoCorrection) / 1000</strong>: This line calculates and sets the maximum pulse width (<strong class="source-inline">maxPW</strong>) that can be provided to the servo motor. It’s computed by adding <strong class="source-inline">2.0</strong> to the <strong class="source-inline">servoCorrection</strong> variable and then dividing the result by <strong class="source-inline">1000</strong> to convert it into seconds – the servo motor expects pulse widths <span class="No-Break">in seconds.</span></li><li><strong class="source-inline">minPW = (1.0 - servoCorrection) / 1000</strong>: Like the previous line, this line <a id="_idIndexMarker310"/>calculates and sets the minimum pulse width (<strong class="source-inline">minPW</strong>) for the servo motor. It subtracts <strong class="source-inline">servoCorrection</strong> from <strong class="source-inline">1.0</strong> and then divides the result by <strong class="source-inline">1000</strong> for the same reason <span class="No-Break">as before.</span></li></ul></li> <li>Create our <strong class="source-inline">Servo</strong> and <strong class="source-inline">LED</strong> instance objects while initializing the <span class="No-Break"><strong class="source-inline">WeatherDashboard</strong></span><span class="No-Break"> class:</span><pre class="source-code">
    def __init__(self, city, servo_pin, led_pin):
        self.city = city
        self.servo = Servo(servo_pin,
                           min_pulse_width=self.minPW,
                           max_pulse_width=self.maxPW)
        self.led = LED(led_pin)</pre><p class="list-inset">Let’s take a closer look at <span class="No-Break">the code:</span></p><ul><li><strong class="source-inline">self.city = city</strong>: This line sets an instance variable, <strong class="source-inline">city</strong>, equal to the <strong class="source-inline">city</strong> argument that’s passed when the instance of the class is created. This variable represents the city for which weather data will <span class="No-Break">be fetched.</span></li><li><strong class="source-inline">self.servo = Servo(servo_pin, min_pulse_width=self.minPW, max_pulse_width=self.maxPW)</strong>: This line creates a <strong class="source-inline">Servo</strong> object from the GPIO Zero library. The <strong class="source-inline">servo_pin</strong> argument specifies the GPIO pin that the servo is connected to. <strong class="source-inline">min_pulse_width=self.minPW</strong> and <strong class="source-inline">max_pulse_width=self.maxPW</strong> set the minimum and maximum pulse widths for the servo using <span class="No-Break">class variables.</span></li><li><strong class="source-inline">self.led = LED(led_pin)</strong>: This line creates an <strong class="source-inline">LED</strong> object from the GPIO Zero library. The <strong class="source-inline">led_pin</strong> argument indicates the GPIO pin the LED is connected to. This LED will be controlled based on the weather conditions that have been fetched for the <span class="No-Break">specified city.</span></li></ul></li> <li>The <strong class="source-inline">update_status()</strong> method<a id="_idIndexMarker311"/> of the <strong class="source-inline">WeatherDashboard</strong> class grabs the latest weather information and updates the status of the needle and <span class="No-Break">LED accordingly:</span><pre class="source-code">
  def update_status(self):
        weather_data = WeatherData(self.city)
        self.servo.value = weather_data.getServoValue()
        led_status = weather_data.getLEDValue()
        if led_status == 0:
            self.led.off()
        elif led_status == 1:
            self.led.on()
        else:
            self.led.blink()</pre><p class="list-inset">Here’s what’s going on in <span class="No-Break">our code:</span></p><ul><li><strong class="source-inline">weather_data = WeatherData(self.city)</strong>: This creates an instance of the <strong class="source-inline">WeatherData</strong> class using the city that was specified when <strong class="source-inline">WeatherDashboard</strong> was instantiated. This object is used to fetch weather data <a id="_idIndexMarker312"/>for <span class="No-Break">the city.</span></li><li><strong class="source-inline">self.servo.value = weather_data.getServoValue()</strong>: This calls the <strong class="source-inline">getServoValue()</strong> method on the <strong class="source-inline">weather_data</strong> object to get the value for the servo, based on the weather conditions. This value is then set as the new position for the <span class="No-Break">servo motor.</span></li><li><strong class="source-inline">led_status = weather_data.getLEDValue()</strong>: This calls the <strong class="source-inline">getLEDValue()</strong> method on the <strong class="source-inline">weather_data</strong> object to get the value for the LED status, based on the <span class="No-Break">weather conditions.</span></li><li>The conditional block sets the LED’s status based on the <strong class="source-inline">led_status</strong> value. If <strong class="source-inline">led_status</strong> is <strong class="source-inline">0</strong>, it signifies calm weather conditions without any rainfall or thunderstorms, so the LED is turned off (<strong class="source-inline">self.led.off()</strong>). If <strong class="source-inline">led_status</strong> is <strong class="source-inline">1</strong>, this indicates rain, resulting in the LED being turned on (<strong class="source-inline">self.led.on()</strong>). For an <strong class="source-inline">led_status</strong> value of <strong class="source-inline">2</strong>, which is specific to thunderstorm conditions, the LED will blink (<strong class="source-inline">self.led.blink()</strong>), representing the intermittent nature of thunder and lightning. This value is returned by the <strong class="source-inline">getLEDValue()</strong> method in the <strong class="source-inline">WeatherData</strong> class when it detects <span class="No-Break">thunderstorm conditions.</span></li></ul></li> <li>The final method in our <strong class="source-inline">WeatherDashboard</strong> class, <strong class="source-inline">closeServo(),</strong> simply closes the <strong class="source-inline">Servo</strong> instance that we created in our class. This is done to keep the servo motor <span class="No-Break">from jittering:</span><pre class="source-code">
    def closeServo(self):
        self.servo.close()</pre></li> <li>Finally, save<a id="_idIndexMarker313"/> the code and call <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">WeatherDashboard.py</strong></span><span class="No-Break">.</span></li>
</ol>
<p>We won’t run our code just yet, as we need to add a new method to the file (but not the class). We will use this method to create a new <strong class="source-inline">WeatherDashboard</strong> object and update the position of the needle and the state of <span class="No-Break">the LED.</span></p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor066"/>Adding the updateDashboard() function and main methods</h2>
<p>The <strong class="source-inline">update_dashboard()</strong> function<a id="_idIndexMarker314"/> is a standalone function that is defined in the same Python file (<strong class="source-inline">WeatherDashboard.py</strong>) as the <strong class="source-inline">WeatherDashboard</strong> class, yet<a id="_idIndexMarker315"/> sits outside of it. It serves as an interface to encapsulate the process of updating the state of the weather dashboard. The reason for creating the <strong class="source-inline">update_dashboard()</strong> function is to help in overcoming issues related to servo motor jittering as it provides a controlled way to frequently create a fresh instance of the <strong class="source-inline">WeatherDashboard</strong> class, thereby <em class="italic">reopening</em> the <strong class="source-inline">Servo</strong> object connection each time an update to the dashboard <span class="No-Break">is made.</span></p>
<p>Let’s take <span class="No-Break">a look:</span></p>
<ol>
<li>In Thonny, open the <strong class="source-inline">WeatherDashboard.py</strong> file and add the following method to <span class="No-Break">the bottom:</span><pre class="source-code">
def update_dashboard(city, servo_pin, led_pin):
    weather_dashboard = WeatherDashboard(city,
                                         servo_pin,
                                         led_pin)
    weather_dashboard.update_status()
    sleep(2)
    weather_dashboard.closeServo()</pre><p class="list-inset">Let’s take a <span class="No-Break">closer look:</span></p><ol><li class="upper-roman">First, we define the <strong class="source-inline">update_dashboard(city, servo_pin, led_pin)</strong> function to take three arguments: the city for which the weather data is required, the PIN for the servo motor, and the PIN for <span class="No-Break">the LED.</span></li><li class="upper-roman">Within this function, an instance of the <strong class="source-inline">WeatherDashboard</strong> class, named <strong class="source-inline">weather_dashboard</strong>, is created using the given city, servo PIN, and LED PIN <span class="No-Break">as inputs.</span></li><li class="upper-roman">Next, the <strong class="source-inline">update_status()</strong> method of the <strong class="source-inline">WeatherDashboard</strong> instance is <a id="_idIndexMarker316"/>called. This method<a id="_idIndexMarker317"/> fetches the current weather data for the specified city, determines the servo and LED values based on this data, sets the servo’s position, and sets the LED’s state (off, on, or <span class="No-Break">blinking) accordingly.</span></li><li class="upper-roman">The program then pauses for 2 seconds using the <strong class="source-inline">sleep(2)</strong> statement. This pause ensures that the servo has enough time to move to its new position and that the LED displays its new state before any further actions <span class="No-Break">are taken.</span></li><li class="upper-roman">Finally, the <strong class="source-inline">closeServo()</strong> method of the <strong class="source-inline">WeatherDashboard</strong> instance is called. This method is responsible for closing the connection to the servo motor, which is done to avoid potential issues with the servo, such <span class="No-Break">as jittering.</span></li></ol></li> <li>Next, we will add code that only runs when the <strong class="source-inline">WeatherDashboard.py</strong> file is executed in Python. We will use this code to run our weather <span class="No-Break">indicator continuously:</span><pre class="source-code">
if __name__ == "__main__":
    city = 'Toronto'
    servo_pin = 14
    led_pin = 25
    while True:
        update_dashboard(city, servo_pin, led_pin)
        sleep(1800)  # sleep for 30 minutes</pre><p class="list-inset">Let’s take a <a id="_idIndexMarker318"/><span class="No-Break">closer look:</span></p><ol><li class="upper-roman">This block of code will only run when this script (<strong class="source-inline">WeatherDashboard.py</strong>) is executed directly based on <strong class="source-inline">if __name__ == "</strong><span class="No-Break"><strong class="source-inline">__main__":</strong></span><span class="No-Break">.</span></li><li class="upper-roman">First, we set the <strong class="source-inline">city</strong>, <strong class="source-inline">servo_pin</strong>, and <strong class="source-inline">led_pin</strong> variables to <strong class="source-inline">Toronto</strong>, <strong class="source-inline">14</strong>, and <strong class="source-inline">25</strong>, respectively. Each reader may put in the city of <span class="No-Break">their choice.</span></li><li class="upper-roman">The <strong class="source-inline">while True:</strong> loop <a id="_idIndexMarker319"/>will continuously execute the code inside it, essentially making the script run forever, or until it is <span class="No-Break">stopped manually.</span></li><li class="upper-roman">Inside the loop, the <strong class="source-inline">update_dashboard()</strong> function is called with the <strong class="source-inline">city</strong>, <strong class="source-inline">servo_pin</strong>, and <strong class="source-inline">led_pin</strong> values as arguments. This function updates the weather dashboard, effectively getting the new weather data and controlling the servo and <span class="No-Break">LED accordingly.</span></li><li class="upper-roman">After updating the dashboard, the script goes into sleep mode for 1,800 seconds, or 30 minutes (<strong class="source-inline">sleep(1800)</strong>). This means that the weather dashboard updates every <span class="No-Break">30 minutes.</span></li><li class="upper-roman">After the sleep period, the loop starts over, updating the <span class="No-Break">dashboard again.</span></li></ol></li> <li>Resave the code and call <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">WeatherData.py</strong></span><span class="No-Break">.</span></li>
<li>Run our code by clicking the green run button, hitting <em class="italic">F5</em> on your keyboard, or clicking on the <strong class="bold">Run</strong> menu option at the top and then <strong class="bold">Run </strong><span class="No-Break"><strong class="bold">current script</strong></span><span class="No-Break">.</span></li>
<li>Once the script is up and running, we’ll see that the position of the needle and the state of the LED reflect the current temperature, wind speed, and weather <span class="No-Break">conditions accurately.</span></li>
</ol>
<p>We may operate <a id="_idIndexMarker320"/>our weather indicator<a id="_idIndexMarker321"/> application independently, without the need for a keyboard, mouse, or monitor to be connected. <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.23</em> shows a practical example of how our application advises us on what to wear based on the weather in Toronto at the time the photo was taken, also indicating that there’s no need for <span class="No-Break">an umbrella:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer074">
<img alt="Figure 3.23 – It looks like T-shirt weather in Toronto today" height="1006" src="image/B21282_03_23.jpg" width="919"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.23 – It looks like T-shirt weather in Toronto today</p>
<p>From the position of the needle on our weather indicator in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.23</em>, we can conclude that it is T-shirt weather in <span class="No-Break">Toronto today.</span></p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor067"/>Summary</h1>
<p>In this chapter, we developed a weather indicator application, a tool that’s designed to provide advice on clothing choices based on current weather conditions. This innovative project combined coding expertise with physical component design, manifesting not just on a computer screen, but in a real-world, tangible form. Central to this was the creation of a custom stand for our weather indicator, made from 3D-printed parts. This stand, which was designed to house the LED and the servo motor, contributed both practical functionality and aesthetic appeal to our project, successfully bridging the gap between the digital and <span class="No-Break">physical worlds.</span></p>
<p>The lessons learned and the skills gained on this journey have wide-ranging applications. To illustrate, envision a new undertaking: a project that utilizes environmental sensors to track indoor climate conditions such as temperature, humidity, and air quality. The core principles we’ve mastered – from acquiring and interpreting data to interacting with hardware components – can be directly employed in such <span class="No-Break">a scenario.</span></p>
<p>Also, it is easy to imagine adding more functionality to our weather indicator. For example, imagine replacing our LED with an RGB LED capable of a myriad of colors. We could use these different colors and various flashing patterns to indicate other types of weather conditions <span class="No-Break">or warnings.</span></p>
<p>In this chapter, we added to our expertise in Python programming by focusing on interfacing with web services for data acquisition and analysis. In parallel, we ventured into the world of hardware interfaces, creating a tangible, physical component: our custom weather <span class="No-Break">indicator stand.</span></p>
<p>With our newly acquired skills, we are poised to tackle a variety of complex problems. As demonstrated in our weather indicator project, being able to integrate web services, Python programming, and physical components can result in practical applications that significantly impact daily life. Whether advising on clothing choices based on weather conditions or envisaging new applications such as indoor climate monitoring, our abilities have proven versatile <span class="No-Break">and invaluable.</span></p>
<p>In the next chapter, we’ll construct an IoT display with a Raspberry Pi 7-inch touchscreen that presents real-time weather and traffic. This will involve exploring various screen types and creating a multifunctional dashboard, enhancing our skills in Raspberry Pi applications and IoT <span class="No-Break">project development.</span></p>
</div>
</div></body></html>