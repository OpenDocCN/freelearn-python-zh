<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-86"><a id="_idTextAnchor113"/>6</h1>
<h1 id="_idParaDest-87"><a id="_idTextAnchor114"/>Working with React Router and Forms</h1>
<p><strong class="bold">React Router</strong> is a <a id="_idIndexMarker312"/>library for client- and server-side routing. Imagine the usual way websites work; when you click on a link, your browser sends a request to the web server, receives a bunch of data, and then takes time to process everything before finally displaying the content of the new page.</p>
<p>You will get the same experience every time you request a new page from the website. With client-side routing, things get way smoother! Instead of going through that whole process every time you click a link, your web app can update the URL instantly without bothering the server for a new document. This means your web app can quickly show you a new part of the app without any delays. This and more is what React Router offers.</p>
<p>In this chapter, we will explore React Router v6 as a magical tool to handle navigation. You can also use React Router for data fetching but we will limit our scope to component navigation in this book. You will implement simple and complex nested routes in React. You will also work with the <code>useParams</code> and <code>useNavigate</code> hooks for dynamic and programmatic routing.</p>
<p>Next, we will delve into form handling in React applications. Forms are vital components in any web application. You can’t have a complete soup of web applications without forms. Interestingly, we use forms for a variety of purposes that depend on the business or project requirements.</p>
<p>In React, forms are used in components to allow activities such as user login, registration, search, contact forms, shopping checkout page, event attendees’ forms, and a host of others. Forms provide a medium for browser-database server interactions.</p>
<p>We collect data from users of our applications through a form; sometimes, we send users’ data to a database or send/save it to other platforms such as email and third-party applications. It all depends on how we intend to handle form data<a id="_idTextAnchor115"/>.</p>
<p>In a nutshell, you will learn how to use form elements to facilitate user interaction in your React applications. You will also understand how to leverage React Router, a popular routing library for client-side routing.</p>
<p>By the end of this chapter, you will understand how routing works in React applications by working with the React Router library to navigate your different application endpoints. Finally, you will be able to develop elegant React forms and handle users’ information in a React way.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Routing with React Router</li>
<li>Adding React Router in React</li>
<li>Handling dynamic routes</li>
<li>Using forms in React</li>
<li>Controlled and uncontrolled form components</li>
<li>Handling user input – <code>Input field</code>, <code>TextArea</code>, and <code>Select</code></li>
<li>Validating and sanitizing users’ data in React</li>
</ul>
<h1 id="_idParaDest-88"><a id="_idTextAnchor116"/>Technical requirements</h1>
<p>The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter06">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter06</a>.</p>
<p>Due to page constraints, some of the code blocks have been snipped. Please refer to GitHub for the complete code.</p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor117"/>Routing with React Router</h1>
<p><strong class="bold">Routing</strong> in a React <a id="_idIndexMarker313"/>web application is the ability to navigate<a id="_idIndexMarker314"/> seamlessly to and from multiple application components, URLs, pages, and resources, both internal and external. By default, React doesn’t include page routing in its library. And as a matter of fact, React’s main goal is to allow developers to design the display of the view of a single-page web application.</p>
<p>We all know web applications require multiple views, hence the need for an external library such as React Router to allow for component navigation. Working with a large application would require multiple specialized views. This means we have to solve the problem of navigation left untreated with the React library, but this is where React Router comes in.</p>
<p><strong class="bold">React Router</strong> is an open source package that’s used for component-based routing in React applications. It is popular among React developers and widely used in various React projects. Interestingly, you can use React Router anywhere you intend to run React applications: client side with browsers, on a web server with NodeJS, and even via mobile applications with React Native.</p>
<p>So far, we have kind of taken the <em class="italic">Bizza</em> application bit by bit, cherry-picking the components and their interaction. Now, we are going to move through the pages of our projects and link them up with React Router.</p>
<p>React Router is composed of some routing features. These features are the nuts and bolts of the inner working of React Router. Knowing them will help us with our understanding of React Router. In the following sections, we will explain some of the commonly used <a id="_idIndexMarker315"/>features <a id="_idIndexMarker316"/>of React Router.</p>
<p>Let’s start with Router, a component that enables navigation and routing within a React application.</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor118"/>Routers</h2>
<p>React Router provides different types of routers that allow you to handle routing and navigation in React applications. Each router has its specific use case and benefits. We will briefly discuss some of the commonly used React Router routers:</p>
<ul>
<li><code>CreateBrowserRouter</code>: This is a specialized function in React Router v6 that serves as the preferred <a id="_idIndexMarker317"/>method for generating a browser router in web projects. By utilizing the DOM History API, it efficiently updates the URL and maintains the history stack. Moreover, it unlocks access to the v6.4 data APIs, encompassing loaders, actions, fetchers, and other React Router functionalities.</li>
<li><code>RouterProvider</code>: This <a id="_idIndexMarker318"/>component in React Router is designed to supply the router instance to all components rendered within its scope. This ensures that the router can be utilized for efficient management of the application’s navigation and routing needs.<p class="list-inset">The <code>RouterProvider</code> component requires a <code>router</code> prop as an argument, and this prop serves as the router instance that will be distributed to the components rendered within <code>RouterProvider</code>. It is essential to position <code>RouterProvider</code> at the highest level in the component tree to ensure that all application components can access the router instance effectively.</p></li>
<li><code>NativeRouter</code>: This is <a id="_idIndexMarker319"/>an interface that is required to run React Router in React Native, a routing solution for mobile applications. This is outside the scope of this book.</li>
</ul>
<p>Next, we will discuss components in React Router. Components in React Router allow you to render the user interface for a specific route within a single-page application.</p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor119"/>Components</h2>
<p>Components in React Router enable you to create a flexible and dynamic routing system within your React applications, making it easier to manage navigation and the state as users interact with your UI. We will briefly discuss some of the commonly used components.</p>
<ul>
<li><code>Link</code>: <code>Link</code> is a <a id="_idIndexMarker320"/>component element that allows users to navigate to another component page upon it being clicked. Under the hood, <code>react-router-dom</code> renders a <code>&lt;Link&gt;</code> tag to an anchor element, <code>&lt;a&gt;</code>, with a real <code>href</code> that directs users to the resources it is pointing to.</li>
<li><code>NavLink</code>: This <a id="_idIndexMarker321"/>works as a <code>&lt;Link&gt;</code> tag but with the added feature of indicating an active element in a menu. This is commonly used when you are building a tabbed menu and you want to show which part of the menu is currently selected.</li>
<li><code>Route</code>: This is <a id="_idIndexMarker322"/>used to render the UI in React Router based on the current location. <code>Route</code> has a path and an element as props. This is how it works: whenever the path <code>Route</code> component matches the current URL, based on the user click operation, it renders its element. This element could be any component in the application. We will see a live example shortly.</li>
<li><code>Routes</code>: This has <code>Route</code> as<a id="_idIndexMarker323"/> its children. <code>Routes</code> works logically in a simple way, like <code>Route</code>, except that <code>Route</code> or a series of <code>Route</code> are children of <code>Routes</code>. So, whenever the path of the UI component changes, <code>Routes</code> checks all its children <code>Route</code> elements to determine the best match for the user request or click path and renders that specific UI.</li>
</ul>
<p>Next, we will discuss hooks in React Router. Hooks provide a mechanism for interacting with the router’s state and executing navigation actions directly within your components. We will discuss hooks such as <code>useLocation</code>, <code>useParams</code>, and <code>useNavigate</code>.</p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor120"/>Hooks</h2>
<p>React Router offers a range of hooks that empower developers with efficient ways to manage routing, the state, and navigation within their components. We will briefly discuss some of the commonly used hooks:</p>
<ul>
<li><code>useLocation</code>: You <a id="_idIndexMarker324"/>can use this hook to perform some side effects whenever you need to track changes in the current location. The <code>useLocation</code> hook usually returns the current location object.</li>
<li><code>UseParams</code>: You <a id="_idIndexMarker325"/>can use this hook to get the parameter from the browser through the current URL matching <code>&lt;Route path&gt;</code>. The <code>useParams</code> hook returns an object of the key-value pairs of the dynamic params.</li>
<li><code>UseNavigate</code>: You<a id="_idIndexMarker326"/> can use this hook to programmatically navigate between different routes in your React application without the need for a <code>history</code> object or the <code>Link</code> component.</li>
</ul>
<p>Now, it is time to add React Router to our root app and connect our pages.</p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor121"/>Adding React Router in React</h1>
<p>You need to <a id="_idIndexMarker327"/>install React Router to use it in your project. We are going to build the navigation features for the <em class="italic">Bizza</em> project to connect different components. The navigation tabs will consist of the home, about, speakers, events, sponsors, and contact pages. Let’s start coding by entering this command in the project directory’s Terminal:</p>
<pre class="console">npm install react-router-dom@latest</pre>
<p>Once we have the package installed in the root directory of our project, we can create the home, about, speakers, news, and contact pages components.</p>
<p>Now, we will add content to each of these components:</p>
<ul>
<li>Inside <code>src/pages/HomePage/HomePage.js</code>, add the following code snippet:<pre class="source-code">import React from 'react';const HomePage = () =&gt; {    return &lt;div&gt; Home page &lt;/div&gt;;};export default HomePage;</pre></li>
<li>Inside <code>src/pages/AboutPage/AboutPage.js</code>, add the following:<pre class="source-code">import React from 'react';const AboutPage = () =&gt; {    return &lt;div&gt; About page &lt;/div&gt;}export default AboutPage;</pre></li>
<li>Inside <code>src/pages/SpeakersPage/SpeakersPage.js</code>, add the following:<pre class="source-code">import React from 'react';const SpeakersPage = () =&gt; {    return &lt;div&gt;Speakers &lt;/div&gt;}export default SpeakersPage;</pre></li>
<li>Inside <code>src/pages/EventsPage/EventsPage.js</code>, add <a id="_idIndexMarker328"/>the following:<pre class="source-code">import React from 'react';const EventsPage = () =&gt; {    return &lt;div&gt;Events page &lt;/div&gt;}export default EventsPage;</pre></li>
<li>Inside <code>src/pages/SponsorsPage/SponsorsPage.js</code>, add the following:<pre class="source-code">import React from 'react'const SponsorsPage = () =&gt; {    return &lt;div&gt;Sponsors Page&lt;/div&gt;}export default SponsorsPage</pre></li>
<li>Inside <code>src/pages/ContactPage/ContactPage.js</code>, add the following:<pre class="source-code">import React from 'react'const ContactPage = () =&gt; {    return &lt;div&gt;Contact Page&lt;/div&gt;}export default ContactPage</pre></li>
</ul>
<p>Now that these<a id="_idIndexMarker329"/> components have been set, let’s start implementing the React Router functionalities in our application:</p>
<ol>
<li>Inside <code>src/index.js</code>, add the following code:<pre class="source-code">import React from 'react';import { createRoot } from 'react-dom/client';import {    createBrowserRouter,    RouterProvider,} from 'react-router-dom';
import</strong> statements required for the client-side routing using React Router:</pre><ul><li><code>createRoot</code>: Imports the function to create a root React component for rendering</li>
<li><code>createBrowserRouter</code> and <code>RouterProvider</code>: Import components and functions related to React Router, which provides routing functionality</li>
</ul></li>
<li>We also need to<a id="_idIndexMarker330"/> import all the various components we created earlier. Still inside <code>index.js</code>, add the following component imports:<pre class="source-code">import HomePage from './pages/HomePage/HomePage';import AboutPage from './pages/AboutPage/AboutPage'import<a id="_idTextAnchor122"/> SpeakersPage from './pages/SpeakersPage/SpeakersPage';import EventsPage from './pages/EventsPage/EventsPage';import SponsorsPage from './pages/SponsorsPage/SponsorsPage';import<a id="_idTextAnchor123"/> SponsorsPage from './pages/SponsorsPage/SponsorsPage';</pre><p class="list-inset">The preceding imports are the various files and components that will be used in the application.</p></li>
</ol>
<p>Please note that all future components that we might want React Router to be aware of can be added as<a id="_idIndexMarker331"/> part of the imported files and components of the application. Next, we will set up the routing configuration.</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor124"/>Setting up the routing configuration</h2>
<p>In the context of<a id="_idIndexMarker332"/> web application development and libraries such as React Router, routing configuration refers to the process of setting up rules or mappings that define how different URLs (or routes) in a web application should be handled. It involves specifying which components or views should be rendered for specific URLs, allowing users to navigate through different parts of the application seamlessly.</p>
<p>With React Router, you can define a list of routes and associate each route with a corresponding component to be displayed when the route is matched. These routes can be static, dynamic (with placeholders), or nested to create a hierarchical structure.</p>
<p>Let’s put this to practical use. Add the following code to the <code>index.js</code> file:</p>
<pre class="source-code">const router = createBrowserRouter([  {
    path: "/",
    element: &lt;HomePage /&gt;,
  },
  {
    path: "/about",
    element: &lt;AboutPage/&gt;,
  },
  {
    path: "/speakers",
    element: &lt;SpeakersPage/&gt;,
  },
  {
    path: "/events",
    element: &lt;EventsPage/&gt;,
  },
{
    path: "/sponsors",
    element: &lt;SponsorsPage/&gt;,
  },
{
    path: "/contact",
    element: &lt;ContactPage/&gt;,
  },
    ],
);
createRoot(document.getElementById("root")).render(
  &lt;RouterProvider router={router} /&gt;
);</pre>
<p>The preceding code<a id="_idIndexMarker333"/> shows the created <code>router</code> object using the <code>createBrowserRouter</code> function, which defines the routing configuration for the application. This <code>router</code> object sets up different paths and their corresponding React components to be rendered when those paths are matched.</p>
<p>What this means is that when a user navigates to different URLs in the application, the corresponding components will be rendered based on the defined routes; for instance:</p>
<ul>
<li>Navigating to <code>/</code> will render the <code>HomePage</code> component</li>
<li>Navigating to <code>/about</code> will render the <code>AboutPage</code> component</li>
</ul>
<p>Likewise, the rest of the components are rendered and displayed based on the routes and their corresponding components. The <code>createRoot()</code> function from the <code>react-dom</code> library, <code>'react-dom/client'</code>, is used to create a <code>root</code> component for intended rendering. It is a newer and more efficient alternative to <code>ReactDOM.render()</code>. The <code>createRoot()</code> function takes the target DOM element as an argument and returns a <code>root</code> component that can be used to render React elements into that target element.</p>
<p>In this case, <code>createRoot(document.getElementById("root"))</code> creates a <code>root</code> React component that will render its content inside the <code>&lt;div&gt;</code> element with the <code>"root"</code> ID. In essence, the <code>createRoot</code> function is used to create a <code>Root</code> object and render the <code>RouterProvider</code> component into the <code>root</code> DOM element.</p>
<p>The <code>RouterProvider</code> component then renders the <code>HomePage</code> component, which is the default route for the application. <code>&lt;RouterProvider router={router} /&gt;</code> uses the <code>RouterProvider</code> component from React Router. <code>RouterProvider</code> takes a prop called <code>router</code>, and the value of this prop is the previously defined router object, which contains the preceding routing configuration. This makes <code>router</code> available to<a id="_idIndexMarker334"/> the entire application, enabling navigation based on the defined routes.</p>
<p>We’ll add links to routes in the next section.</p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor125"/>Adding links</h2>
<p>Let’s improve the <a id="_idIndexMarker335"/>navigation menu by adding links to the elements. To add a link to an element, use <code>&lt;Link to="" &gt;elementName &lt;/Link&gt;</code>. <code>to=""</code> allows us to insert the navigation path we intend to go to. Let’s see the details of a typical link definition:</p>
<pre class="source-code">&lt;nav className="nav"&gt;  &lt;ul&gt;
    &lt;li&gt;
      &lt;Link to="/" className='navlink'&gt;Home&lt;/Link&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;Link to="/about" className='navlink'&gt;About&lt;/Link&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;Link to="/speakers" className='active
        navlink'&gt;Speakers&lt;/Link&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;Link to="/events" className='navlink'&gt;Events&lt;/Link&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;Link to="/sponsors" className='navlink'&gt;
        Sponsors&lt;/Link&gt;
    &lt;/li&gt;
      &lt;li&gt;&lt;Link to="/contact" className='navlink'&gt;
        Contact&lt;/Link&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;</pre>
<p>Check the<a id="_idIndexMarker336"/> GitHub <code>src/components/Header/Header.jsx</code> file to learn more about the <code>Link</code> definition.</p>
<p>The following screenshot shows <code>HomePage</code> with a menu and links:</p>
<div><div><img alt="Figure 6.1 – Screenshot showing routes and links" src="img/Figure_6.1_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Screenshot showing routes and links</p>
<p>Next, let’s learn how to embed a route into another route so that we have what we call a nested route.</p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor126"/>Adding a nested route</h2>
<p><strong class="bold">Nested routes</strong> in React <a id="_idIndexMarker337"/>Router provide a structured <a id="_idIndexMarker338"/>approach to organizing routes within your application. They facilitate grouping related routes, streamlining navigation between different sections. To implement nested routes, you must utilize the children prop on a Route component.</p>
<p>This prop accepts an array of Route components as its value, defining the child routes that will be rendered when the parent route is matched. For instance, consider the following code snippet, which demonstrates the creation of a nested route for speakers.</p>
<p>Inside <a id="_idTextAnchor127"/><code>src/index.js</code>, update the <code>/speakers</code> route, as follows:</p>
<pre class="source-code">const router = createBrowserRouter([  {
    path: "/speakers",
    children: [
      {
        index: true,
        element: &lt;SpeakersPage /&gt;,
      },
      {
        path: "/speakers/:speakerId",
        element: &lt;SpeakerDetail /&gt;
      },
    ],
  },
]);</pre>
<p>In the preceding code, we have a parent route called <code>speakers</code> with the <code>/speakers</code> path. The child route for <code>SpeakerDetail</code> has the <code>/speakers/:speakerId</code> path. The <code>:speakerId</code> placeholder in the path is a dynamic parameter that will be replaced with the <code>:speakerId</code> value<a id="_idIndexMarker339"/> of the speaker when the user navigates to the route.</p>
<p>The <code>SpeakerDetail</code> component will be rendered with the detailed information of <code>speakerId</code> in the URL. Inside <code>src/pages</code>, create <code>SpeakerDetail/SpeakerDetail.js</code>; then, add the following code:</p>
<pre class="source-code">const SpeakerDetail = () =&gt; {    return (
        &lt;div className='page-wrapper'&gt;
            &lt;h1&gt;This is SpeakerDetail with the ID: &lt;/h1&gt;
        &lt;/div&gt;
    )
}
export default SpeakerDetail</pre>
<p>The following screenshot shows the nested route with <code>http://localhost:3000/speakers/234</code>:</p>
<div><div><img alt="Figure 6.2 – Screenshot showing the nested route" src="img/Figure_6.2_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Screenshot showing the nested route</p>
<p>Essentially, nested routes can be used to organize your routes in a way that makes sense for your<a id="_idIndexMarker340"/> application. They can also be used to make it easier to navigate between related routes.</p>
<p>Next, we will explore how to handle dynamic and programmatic routes with <code>useParams</code> and <code>useNavigate</code>.</p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor128"/>Handling dynamic routes</h1>
<p>In web application <a id="_idIndexMarker341"/>development, a <code>speakerId</code>, <code>productId</code>, <code>postId</code>, and so on to represent the changing value.</p>
<p>For instance, let’s consider the <a id="_idIndexMarker342"/>preceding speakers route we updated with <code>/speakers/:speakerId</code>. It is conventional to add a colon in front of a dynamic route, like so: <code>:speakerId</code>. So, how can we retrieve this value of <code>speakerId</code> from the URL? This is where the <code>useParams</code> hook comes in.</p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor129"/>Using useParams</h2>
<p>The <code>useParams</code> hook in React<a id="_idIndexMarker343"/> Router provides access to the<a id="_idIndexMarker344"/> dynamic parameters extracted from a route. These parameters are the values that correspond to the placeholders in the path of a dynamic route.</p>
<p>For instance, in the following code snippet, the <code>useParams</code> hook is used to retrieve <code>SpeakerId</code> from the <code>/speakers/:speakerId</code> route. The following code shows the code implementation.</p>
<p>Update the <code>SpeakerDetail</code> component in <code>src/pages/</code>, as follows:</p>
<pre class="source-code">import React from 'react'import { useParams } from 'react-router-dom'
const SpeakerDetail = () =&gt; {
    const {speakerId} = useParams()
    return (
        &lt;div className='page-wrapper'&gt;
            &lt;h1&gt;This is SpeakerDetail with the ID:
                {speakerId} &lt;/h1&gt;
        &lt;/div&gt;
    )
}
export default SpeakerDetail</pre>
<p>In the preceding<a id="_idIndexMarker345"/> code snippet, we have the <code>SpeakerDetail</code> component, which<a id="_idIndexMarker346"/> is used to display the details of a speaker based on the <code>speakerId</code> dynamic parameter that was extracted from the URL. The <code>useParams</code> hook will return an object that contains the dynamic parameters from the route. In this case, the <code>speakerId</code> property of the object will contain the Speaker ID in the URL.</p>
<p>The following screenshot shows the extracted <code>speakerId</code> from the URL:</p>
<div><div><img alt="Figure 6.3 – Screenshot showing the extracted ﻿speakerId" src="img/Figure_6.3_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Screenshot showing the extracted speakerId</p>
<p>The <code>useParams</code> hook is a powerful tool that can be used to access the dynamic parameters of any<a id="_idIndexMarker347"/> route. Next, we will briefly discuss the <code>useNavigate</code> hook<a id="_idIndexMarker348"/> for programmatic navigation.</p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor130"/>Using useNavigate</h2>
<p><code>useNavigate</code> is a new<a id="_idIndexMarker349"/> hook that was introduced in React<a id="_idIndexMarker350"/> Router v6. It provides a way to programmatically navigate or redirect users to different routes within a React application. Unlike the <code>useHistory</code> hook from previous versions of React Router that provided access to the history object, <code>useNavigate</code> provides a more straightforward and explicit way to navigate between routes.</p>
<p>With <code>useNavigate</code>, you can initiate navigation in response to certain events, such as a button click, form submission, or any other user action. Instead of modifying the URL directly like in React Router v5, you can now use the navigate function returned by <code>useNavigate</code> to achieve navigation.</p>
<p>For instance, inside the <code>src/components/Header/Header.jsx</code> file, we have the following code to show how <code>useNavigate</code> is implemented:</p>
<pre class="source-code">import React from 'react';import {Link, useNavigate } from 'react-router-dom';
const Header = () =&gt; {
  const navigate = useNavigate();
  const handleLoginButtonClick = () =&gt; {
    navigate('/auth/login');
  }
  return (
    &lt;header className="header"&gt;
      ...
      &lt;div className="auth"&gt;
        &lt;button onClick={handleLoginButtonClick}
          className="btn"&gt;Login&lt;/button&gt;
      &lt;/div&gt;
    &lt;/header&gt;
  );
}
export default Header;</pre>
<p>In the preceding snippet, the <code>useNavigate</code> hook is called to get the <code>navigate</code> function. When the button is clicked, the <code>handleLoginButtonClick</code> function is executed, which, in turn, calls <code>navigate('/auth/login')</code>. This will navigate the user to the <code>'/auth/login'</code> route programmatically.</p>
<p><code>useNavigate</code> provides a more declarative and concise way to handle navigation compared to directly manipulating the history object. It improves the overall readability and maintainability<a id="_idIndexMarker351"/> of the code when working with React <a id="_idIndexMarker352"/>Router v6.</p>
<p>This section wraps up routing with React Router. The subsequent section shifts its focus to the realm of managing forms within the React library.</p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor131"/>Using forms in React</h1>
<p>Conventionally, forms<a id="_idIndexMarker353"/> are used to collect user inputs. There is no serious <a id="_idIndexMarker354"/>production-grade web application without forms. Using forms in React is slightly different from using HTML form elements. If you have developed React applications for a while, this might not be new to you.</p>
<p>The subtle difference between the elements of React forms and those of normal HTML forms is due to the unique way React handles the internal state of forms. The HTML DOM manages the internal states of native HTML form elements in a browser DOM way. On the other hand, React handles form elements through its components’ state.</p>
<p>So, what is this state all about? The state we are talking about is an object that holds user inputs before form submission. Form elements have an internal state that prevents data loss before you submit user input across the processing channel.</p>
<p>Having laid down the background for the internal state management of form elements, let’s quickly move on to how React enhances the user experience through its component-based approach, enhanced with the VDOM mechanism of React. We are going to develop forms in React without the use of any external library; instead, we will focus on pure React and leverage its controlled component-based approach in managing form state. Right now, we are going to design a simple sign-up form component.</p>
<p>The following snippet shows a <code>SignUp</code> form component to help you understand how to create a simple<a id="_idIndexMarker355"/> form<a id="_idIndexMarker356"/> in React.</p>
<p>Create <code>SignUp</code> inside <code>src/pages/Auth/SignUp.js/</code> in your project directory:</p>
<pre class="source-code">import React from 'react';const SignUp = () =&gt; {
  return (
    &lt;&gt;
    &lt;div className="signUpContainer"&gt;
    &lt;form&gt;
    &lt;h2&gt;Create an account&lt;/h2&gt;
      &lt;div className="signUpForm"&gt;
        &lt;label htmlFor="name"&gt;Name&lt;/label&gt;
        &lt;input
          id="name"
          type="text"
          name="name"
        /&gt;
      &lt;label htmlFor="email"&gt;Email Address&lt;/label&gt;
        &lt;input
          id="email"
          type="email"
          name="email"
        /&gt;
      &lt;label htmlFor="password"&gt;Password&lt;/label&gt;
        &lt;input
          id="password"
          type="password"
          name="password"
        /&gt;
            &lt;button&gt;Register&lt;/button&gt;
      &lt;/div&gt;
    &lt;/form&gt;
    &lt;/div&gt;
&lt;/&gt;
  );
};
export default SignUp;</pre>
<p>The preceding <a id="_idIndexMarker357"/>snippet<a id="_idIndexMarker358"/> should look familiar – there’s nothing special here except for the <code>&lt;label&gt;</code> attribute, <code>htmlFor</code>. This is the React way of adding the <code>for</code> attributes to the form label. The <code>htmlFor</code> prop is used to match the corresponding ID with input form elements.</p>
<p>Moving forward, let’s update the router configuration inside <code>index.js</code> and add the <code>signup</code> route. Inside <code>src/index.js</code>, add the sign-up path and its associated component:</p>
<pre class="source-code">{    path: "/auth/signup",
    element: &lt;SignUp/&gt;,
  },
};</pre>
<p>The following figure shows the output of the signup form code snippet:</p>
<div><div><img alt="Figure 6.4 – Screenshot showing the rendered signup form" src="img/Figure_6.4_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Screenshot showing the rendered signup form</p>
<p>When you navigate to <code>http://localhost:3000/auth/signup</code>, you will see that the <code>SignUp</code> form component has been rendered. With this, React is just rendering the form elements and allowing native browser DOM to carry on as usual with the page reload at every form submission. If you fill in the form and click <strong class="bold">REGISTER</strong>, you will see the page reload effect.</p>
<p>This is certainly <a id="_idIndexMarker359"/>an<a id="_idIndexMarker360"/> anti-React design pattern, which means this is not a React way of designing form elements. So, what is the React design expectation in building an intuitive user form experience? The answer to this is what we will focus on in the next section. There, you will learn how you can build engaging and reusable forms with all the ingredients of the React sauce.</p>
<p>In React, there are two approaches to form components: controlled and uncontrolled form components. In the next section, we will dive into this and learn how to design form components that enhance smooth interaction with the form elements in a React web application project.</p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor132"/>Controlled and uncontrolled form components</h1>
<p>So far in this<a id="_idIndexMarker361"/> book, we have become familiar with components and <a id="_idIndexMarker362"/>how they are the building blocks of any React application. When you blend pieces of independently designed components, you get either a UI component or a full-fledged React web application, depending on what you are working on.</p>
<p>The component-driven approach of React is not going to change anytime soon. Building quality UIs for applications is what React does best. You are going to need a high-performant form one way or the other in your career as a developer, and React has you covered with two approaches to building air-tight form components that prevent data loss and improve user experience regarding form interaction.</p>
<p>These two approaches are controlled and uncontrolled form components. Let’s start with controlled form components so that we have a sufficient understanding of how they are implemented and why they are the React-recommended approach to form handling.</p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor133"/>Controlled form</h2>
<p>In terms of a <a id="_idIndexMarker363"/>controlled form, a React component maintains the internal state of user inputs in the form elements. What do we mean? Essentially, React has an in-built event wrapper known as <code>SyntheticEvent</code>, a key component of the React event system.</p>
<p>We spoke a lot about <code>SyntheticEvent</code> in <a href="B18554_05.xhtml#_idTextAnchor095"><em class="italic">Chapter 5</em></a>, <em class="italic">JSX and Displaying Lists in React</em>, in the <em class="italic">Event handling in React</em> section. In the controlled form approach, the event handler function in controlled form components accepts an instance of <code>SyntheticEvent</code>, such as <code>onChange</code>, <code>onInput</code>, <code>onInvalid</code>, <code>onReset</code>, and <code>onSubmit</code>, to control the state of form data.</p>
<p>For instance, the <code>onChange</code> event listens to the change in the state value of the component form: this change could be either a user typing something in the form input or trying to replace the value of the form input. The <code>onChange</code> event is triggered and the state data value is changed appropriately.</p>
<p>Let’s explore how event handlers allow us to have controlled form components. The following snippet demonstrates a controlled form in React with the relevant event handlers to manage <code>onChange</code> and <code>onSubmit</code> events. Update the <code>SignUp.js</code> file code to demonstrate the use of event handlers in the form component inside <code>src/pages/Auth/SignUp.js</code>:</p>
<pre class="source-code">import React,{ useState } from 'react';const SignUp = () =&gt; {
  const[name, setName ] = useState("");
  const [ email, setEmail ] = useState("" );
  const [password, setPassword] = useState("");
  const nameHandler = (e) =&gt; {
    setName(e.target.value);
  };
  const onSubmitHandler = (e) =&gt; {
    e.preventDefault();
    alert(`Name: ${name}: Email: ${email} Password:
      ${password}`);
  };
  return (
    &lt;&gt;
      &lt;div className="signUpContainer"&gt;
        &lt;form onSubmit={onSubmitHandler}&gt;
          &lt;h2&gt;Create an account&lt;/h2&gt;
          &lt;div className="signUpForm"&gt;
            &lt;label htmlFor="name"&gt;Name&lt;/label&gt;
            &lt;input
              id="name"
              type="text"
              name="name"
              value={name}
              onChange={nameHandler}
            /&gt;
            &lt;button&gt;Register&lt;/button&gt;
          &lt;/div&gt;
        &lt;/form&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
};
export default SignUp;</pre>
<p>Please refer to GitHub for the full source code. In the preceding snippet, we have updated our default form by adding some input attributes to it – that is, the <code>value</code> and <code>onChange</code> events, and set the stage for a controlled form. The form input uses <code>value</code> to accept the current value as a prop and <code>onChange</code> as a callback to update the state of the value.</p>
<p>As you already know, user <a id="_idIndexMarker364"/>actions such as tapping the keyboard, clicking a button on a web page, or mousing over on an HTML element with browsers elicit events. But React has what we call Synthetic Events with a couple of instance methods and properties to listen for user interactions and emit certain events.</p>
<p>Popular among these instances in React are <code>onChange</code> and <code>onClick</code>. We will use more of these. The <code>onChange</code> event is triggered whenever there is a change in the form’s input element. The <code>event.target</code> property of the Web API is used to access the value of this change.</p>
<p>Furthermore, the <code>onClick</code> event gets activated every time an HTML element is clicked; for example, when a button is clicked. In our snippet, event handlers are specified in the body of the component function: <code>nameHandler</code>, <code>emailHandler</code>, and <code>passwordHandler</code>. These event handlers listen to the corresponding value changes in the form inputs and control the operation of the form.</p>
<p>In the case of <code>nameHandler</code>, it listens to what the users type in, accesses the value with the use of the <code>e.target</code> property, and updates its state with <code>setName()</code>:</p>
<pre class="source-code">const nameHandler = (e) =&gt; {          setName(e.target.value);
};</pre>
<p>In the form input with the <code>Name</code> label, the following was added:</p>
<pre class="source-code">        &lt;input              …
              value={name}
          onChange={nameHandler}
        /&gt;</pre>
<p class="callout-heading">Note</p>
<p class="callout">The <code>input</code> elements for email and password were equally updated with appropriate values and <code>onChange</code> event handlers.</p>
<p><code>onSubmitHandler()</code> handles<a id="_idIndexMarker365"/> the <code>onSubmit</code> event of the form element:</p>
<pre class="source-code">&lt;form onSubmit={onSubmitHandler}&gt;  const onSubmitHandler = (e) =&gt; {
        e.preventDefault();
        alert(`Name: ${name}: Email: ${email} Password:
          ${password}`);
  };</pre>
<p><code>e.preventDefault()</code> prevents the default reloading behavior of the browser. We also output the submitted form data with <code>alert()</code>. What are the benefits of the controlled form component?</p>
<p>There are a few reasons why you would want to use controlled form components:</p>
<ul>
<li>React recommends it. It is React’s best-practice way of handling user inputs in React.</li>
<li>The components tightly control the behavior of the form, thereby ensuring a reactive user and developer experience.</li>
<li>We get instant feedback from forms since the event handlers listen to form elements and emit events appropriately.</li>
</ul>
<p>The controlled form component improves the experience with form interaction in React applications and it is<a id="_idIndexMarker366"/> widely used in the React community. Next, we will learn what the uncontrolled form components provide for the React developer community and how we can use them.</p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor134"/>Uncontrolled form</h2>
<p>In an uncontrolled <a id="_idIndexMarker367"/>form, native DOM maintains and stores the state of user input directly. It does this by storing the values of the form elements in the DOM with a reference to the form elements. This is the conventional way HTML form elements maintain their internal states.</p>
<p>React components simply interact with uncontrolled form elements by maintaining references to the underlying form element in the DOM. Let’s replicate our earlier signup form and refactor the snippet to use uncontrolled form components.</p>
<p>This snippet uses the <code>useRef</code> hook to reference the values of the form elements in the DOM:</p>
<pre class="source-code">import React,{ useRef } from 'react';const SignUp = () =&gt; {
  const onSubmitHandler = (e) =&gt; {
    e.preventDefault();
    console.log("Name value: " + name.current.value);
    console.log("Email value: " + email.current.value);
    console.log("Password value: " +
      password.current.value);
  };
  return (    &lt;&gt;
    &lt;div className="signUpContainer"&gt;
    &lt;form onSubmit={onSubmitHandler}&gt;
    &lt;h2&gt;Create an account&lt;/h2&gt;
      &lt;div className="signUpForm"&gt;
        &lt;label htmlFor="name"&gt;Name&lt;/label&gt;
        &lt;input
          id="name"
          type="text"
          name="name"
          ref={name}
        /&gt;
      &lt;button&gt;Register&lt;/button&gt;
      &lt;/div&gt;
    &lt;/form&gt;
    &lt;/div&gt;
&lt;/&gt;
  );
};
export default SignUp;</pre>
<p>Please refer to GitHub for the full source code. Let’s briefly explain the preceding snippet.</p>
<p>In using the uncontrolled form React component, we needed the <code>useRef</code> hook to access the form elements in the DOM. <code>import React, { useRef } from 'react';</code> brings React and the <code>useRef()</code> hook into scope.</p>
<p>Then, we created a reference variable to hold the reference of the form element in the DOM:</p>
<pre class="source-code">const name = useRef();const email = useRef();
const password = useRef();</pre>
<p>In the <code>input</code> tag, we<a id="_idIndexMarker368"/> bound the reference variable to the <code>ref</code> attribute of the input element:</p>
<pre class="source-code">&lt;label htmlFor="name"&gt;Name&lt;/label&gt;        &lt;input
          id="name"
          type="text"
          name="name"
          ref={name}
        /&gt;</pre>
<p>The same steps were taken for the email and password input elements.</p>
<p>To extract the current value of the form fields, we must use the <code>current.value</code> property of <code>useRef</code> in <code>onSubmitHandler()</code>:</p>
<pre class="source-code">  const onSubmitHandler = (e) =&gt; {    e.preventDefault();
    console.log("Name value: " + name.current.value);
    console.log("Email value: " + email.current.value);
    console.log("Password value: " +
      password.current.value);
  };</pre>
<p>The following figure shows the console logs of the uncontrolled form component in React:</p>
<div><div><img alt="Figure 6.5 – Console log of the uncontrolled form component" src="img/Figure_6.5_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Console log of the uncontrolled form component</p>
<p>What are the benefits of the uncontrolled form component?</p>
<p>Interestingly, there <a id="_idIndexMarker369"/>are few benefits to using uncontrolled form components, even though React recommends the controlled approach. Here are a few benefits for consideration in your React project:</p>
<ul>
<li>In complex React form applications, where re-rendering the form UI with every user input could be an expensive DOM operation on the performance of the application. Using uncontrolled form components prevents the performance bottlenecks associated with component re-rendering of form elements.</li>
<li>The uncontrolled form is more appropriate when you need to work with a form input of the <code>file</code> type in your React application, such as when doing a file upload.</li>
<li>The uncontrolled form is quick to use when you are migrating from a legacy non-React code base project. Since DOM maintains the state of the form, working with form<a id="_idIndexMarker370"/> fields from the legacy code base is easier.</li>
</ul>
<p>Now that we have sufficiently examined what an uncontrolled form in React project is all about and covered a few of the benefits of using an uncontrolled form, let’s dive into a few of the commonly used input elements: <code>Input</code>, <code>TextArea</code>, and <code>Select</code>.</p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor135"/>Handling user input – Input, TextArea, and Select</h1>
<p>Handling React form <a id="_idIndexMarker371"/>elements is slightly different from the way non-React applications handle user inputs. In this section, we will look at common form elements that are used in handling user input while following React best practices.</p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor136"/>Input</h2>
<p><strong class="bold">Input</strong> fields in the <a id="_idIndexMarker372"/>form are <a id="_idIndexMarker373"/>the most widely used tags in any web application. An input field allows the collection of user data. Input fields have different types depending on their purpose in a form. In the controlled input form element, the component state is always set using a value or checked attribute on the form input field. You also have a callback that listens to the change in value as a result of user input.</p>
<p>With the input type radio and checkbox, we use the checked attributes. To access the value of the input field, we can use <code>event.target.checked</code>.</p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor137"/>TextArea</h2>
<p><code>Textarea</code> is a tag that<a id="_idIndexMarker374"/> allows users to write multi-line characters of text. <code>Textarea</code> is usually used to<a id="_idIndexMarker375"/> collect user data such as comments or review sections in web applications. The <code>Textarea</code> element in React works differently. The state is set using a value or checked attribute in the form input field, similar to a single input field. <code>textarea</code> doesn’t have children, which is typical of HTML.</p>
<p>You can use a callback to retrieve the change in the state value of the form element:</p>
<pre class="source-code">&lt;textarea value={textarea} onChange={onChangeCallback} /&gt;</pre>
<h2 id="_idParaDest-107"><a id="_idTextAnchor138"/>Select</h2>
<p>The <code>select</code> form element<a id="_idIndexMarker376"/> is <a id="_idIndexMarker377"/>used in designing a drop-down list. React has its unique way of working with <code>select</code>. The selected value is set with a value attribute on the <code>select</code> form element. In React, there is no selected attribute.</p>
<p>This selection is determined by the set value property on the <code>select</code> form element. You can use a callback when handling the selected value in the form element:</p>
<pre class="source-code">&lt;select value={user} onChange={onChangeCallback}&gt;&lt;option value="user"&gt;User&lt;/option&gt;
&lt;option value="admin"&gt;Admin&lt;/option&gt;
&lt;/select&gt;</pre>
<p>Next, we will discuss how React applications handle user data validation and how you can sanitize your users’ data when they’re filling in a form element.</p>
<h1 id="_idParaDest-108"><a id="_idTextAnchor139"/>Validating and sanitizing users’ data in React</h1>
<p><strong class="bold">Validation</strong> is a process <a id="_idIndexMarker378"/>that ensures user data quality, integrity, and an appropriate <a id="_idIndexMarker379"/>format that’s expected for a system. You can <a id="_idIndexMarker380"/>never trust data provided by users of your application blindly. While we expect them to trust our code, we can’t reciprocate that trust by not guiding them on how our forms and form data should be treated.</p>
<p>Starting as a junior developer, the phrase <em class="italic">Don’t ever believe a user would always do the right thing with your form</em> will forever ring true. You can never trust user data as is. Data that comes from users has to be thoroughly scrutinized and cleaned and ensured it is in the desired format.</p>
<p>Forms fields are the open window into everything you might call the backend in web development. So, trusting user input without some rules in place could be detrimental to your sanity as a developer and to the healthy condition of your web application.</p>
<p>There are always standard-practice validation rules you can adhere to as a React developer. These validation rules guide you and your application against bad actors of your application.</p>
<p>Let’s take a look at a <a id="_idIndexMarker381"/>few validation rules you might want to check<a id="_idIndexMarker382"/> off before user input data is deposited in your database or any of your backend infrastructure:</p>
<ul>
<li><strong class="bold">Data type</strong>: You need to<a id="_idIndexMarker383"/> ascertain the user is putting in the right data type for a form field. Are they even filling in anything at all? You need to check. For example, in a form field where you are expecting string characters, ensure you are not getting numeric data.</li>
<li><strong class="bold">Consistency</strong>: You need to ensure data consistency of user input, and one of the ways to be sure you get consistent data is by enforcing validation rules. For instance, you might add a regular expression to check that the length of the password is not less than 8 characters and that it is mixed with symbols.<p class="list-inset">Alternatively, you might just allow users to select a country they’d like to visit from a drop-down list of options rather than asking them to type the name of countries they would like to visit. If you do the latter, you will be rudely shocked regarding what you will get in return for your benevolence.</p></li>
<li><strong class="bold">Data format</strong>: You probably want the date of birth of your application users to be in <em class="italic">YYYY-MM-DD</em> or <em class="italic">DD-MM-YYYY</em> format. You and I know we can’t leave this at the discretion of users!</li>
<li><strong class="bold">Range and constraint</strong>: You may also want to check data against a certain range of parameters or if some data falls within a certain constraint intended. So, you need to enforce this with some mechanisms – a regular expression is an example of such a mechanism. You should always remember that users are prone to making genuine errors as well, even though they don’t mean to act badly.</li>
</ul>
<p>That being said, there are two major instances when you will want to enforce validation rules in React form design:</p>
<ul>
<li><strong class="bold">On user input</strong>: As users<a id="_idIndexMarker384"/> are interacting <a id="_idIndexMarker385"/>with your form elements, you are checking for compliance and giving instant feedback. React shines best here with a controlled form component that uses a callback to harvest user values and relay them to event handlers with the ability to check for errors. We will implement this in our sign-up form shortly.</li>
<li><strong class="bold">On user submission</strong>: Form data is subjected to validation when the user clicks on the submit button in this instance. This used to be the gold standard in the past. However, nowadays, this seems to be happening less in enterprise application development due to the arrays of frontend technologies that make instant feedback a cool breeze to implement.</li>
</ul>
<h2 id="_idParaDest-109"><a id="_idTextAnchor140"/>Implementing form validation</h2>
<p>Let’s examine the implementation<a id="_idIndexMarker386"/> of form data validation using the React-controlled form component.</p>
<p>We will start by importing the <code>useState</code> and <code>useEffect</code> hooks and bringing them into scope to manage state and side effects, respectively:</p>
<pre class="source-code">import React,{ useState,useEffect } from 'react';</pre>
<p>Then, we must set the state variables as <code>initialValues</code>, <code>formValues</code>, <code>formErrors</code>, and <code>isSubmit</code>:</p>
<pre class="source-code">const SignUp = () =&gt; {const initialValues = { name: "", email: "", password: "" };
const [formValues, setFormValues] = useState(initialValues);
const [formErrors, setFormErrors] = useState({});
const [isSubmit, setIsSubmit] = useState(false);</pre>
<p><code>initialValues</code> is declared as an object to hold the initial form input state, which is set to empty strings. <code>useState</code> takes the <code>initialValues</code> variable values as the initial state and assigns it to <code>formValues</code> so that from the onset, all the form input values are empty strings. The initial state of <code>formErrors</code> is set to an empty object as well and the initial state of <code>isSubmit</code> is set to <code>false</code>. This means no form has been submitted yet.</p>
<p>We need an <code>onChange</code> function to track changes to form input values. We must set <code>onChangeHandler()</code>, which takes <code>e</code> as a parameter of the event object and destructures the <code>e.target</code> object, which returns two properties – <code>name</code> and <code>value</code>. The <code>setFormValues</code> function accepts all the current <code>formValues</code> with the <code>...formValues</code> spread operator and updates them to the new values:</p>
<pre class="source-code">const onChangeHandler = (e) =&gt; {const { name, value } = e.target;
setFormValues({ ...formValues, [name]: value });  };</pre>
<p><code>useEffect()</code> is used to log successfully submitted<a id="_idIndexMarker387"/> values if there are no form errors:</p>
<pre class="source-code">useEffect(() =&gt; {    if (Object.keys(formErrors).length === 0 &amp;&amp; isSubmit) {
      console.log(formValues);
    }
  }, [formErrors]);</pre>
<p>Next, the rules for form data validation are set with the <code>validateForm</code> function. This is a simple validation rule that checks whether the <code>name</code>, <code>email</code>, and <code>password</code> form inputs are filled in. It also checks whether the right format is being used for email using <code>regex.test()</code>.</p>
<p>For the password, we must check whether the password is more than 8 characters but does not exceed more than 12 characters:</p>
<pre class="source-code">const validateForm = (values) =&gt; {    const errors = {};
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]{2,}$/i;
    if (!values.name) {
      errors.name = "Name is required!";
    }
      ...(This ... represents omitted code which can be
          found on GitHub)
    return errors;
  };</pre>
<p>Then, <code>onSubmitHandler()</code> is invoked, which ensures the <code>setFormErrors()</code> function is run, which takes <code>validateForm()</code> as a parameter. If there are no errors in the form, <code>setIsSubmit</code> is set to <code>true</code>, allowing the form to be submitted:</p>
<pre class="source-code">  const onSubmitHandler = € =&gt; {    e.preventDefault();
    setFormErrors(validateForm(formValues));
    setIsSubmit(true);
  };</pre>
<p>Here’s the JSX <a id="_idIndexMarker388"/>that’s returned from the form component with <code>onSubmitHandler</code> and each of the errors displayed by the <code>formErrors</code> object:</p>
<pre class="source-code">return (  &lt;div className="signUpContainer"&gt;
    &lt;form onSubmit={onSubmitHandler}&gt;
      &lt;h2&gt;Create an account&lt;/h2&gt;
      &lt;div className="signUpForm"&gt;
        &lt;label htmlFor="name"&gt;Name&lt;/label&gt;
        &lt;p style={{color:'red', fontWeight:'bold'}}&gt;
          {formErrors.name}&lt;/p&gt;
        &lt;input
          id="name"
          type="text"
          name="name"
          value={formValues.name}
          onChange={onChangeHandler}
        /&gt;
  ...(This ... represents omitted code which can be found
      on GitHub)
        &lt;button&gt;Register&lt;/button&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  &lt;/div&gt;
);
};
export default SignUp;</pre>
<p>The following figure shows the output for form<a id="_idIndexMarker389"/> entries when form fields are filled before being submitted:</p>
<div><div><img alt="Figure 6.6 – Screenshot of a form with validation rules" src="img/Figure_6.6_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – Screenshot of a form with validation rules</p>
<p>We added the <code>formErrors</code> property to every form element to output an error message if an error exists. For instance, <code>{formErrors.name}</code> displays an error for <code>name</code> if a name is not filled in the form.</p>
<p>The full code for this validation rule can be found in this book’s GitHub repository: https://github.com/PacktPublishing/Full-Stack-Flask-Web-Development-with-React/blob/main/Chapter-06/.</p>
<p>This wraps up how you can add validation to your <a id="_idIndexMarker390"/>React application without the use of an external library, thus minimizing the number of potential dependencies your application might rely on.</p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor141"/>Summary</h1>
<p>In this chapter, we discussed two vital concepts in React: forms and routing. We highlighted the subtle difference in the forms that are set up in non-React and React applications. React provides tons of improvement in how it handles form elements through the use of controlled and uncontrolled form components to enhance the user experience.</p>
<p>Then, we delved into validation concepts and how you can implement validation rules in React. We then spoke about React Router. We demonstrated how React Router, a third-party library, enables us to navigate complex React applications. We discussed the use of <code>Route</code>, <code>Links</code>, and nested <code>Routes</code> and explored how they are used in a React project.</p>
<p>In the next chapter, we will learn about and understand how to implement testing in React applications. Testing is an essential part of software development as it ensures the components of an application work as they should and that the relevant best practices are observed in development.</p>
</div>
</body></html>