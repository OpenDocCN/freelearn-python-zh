- en: Sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever data is collected, there comes a time when it becomes necessary to
    sort the data. The sorting operation is common to all datasets, be it a collection
    of names, telephone numbers, or items on a simple to-do list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll study a few sorting techniques, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Bubble sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insertion sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selection sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our treatment of these sorting algorithms, we will take into consideration
    their asymptotic behavior. Some of the algorithms are relatively easy to develop
    but may perform poorly. Other algorithms that are a little complex to write will
    show impressive performance.
  prefs: []
  type: TYPE_NORMAL
- en: After sorting, it becomes much easier to conduct search operations on a collection
    of items. We'll start with the simplest of all sorting algorithms--the bubble
    sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will go through a number of sorting algorithms that have
    varying levels of difficulty of implementation. Sorting algorithms are categorized
    by their memory usage, complexity, recursion, whether they are comparison-based
    among other considerations.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the algorithms use more CPU cycles and as such have bad asymptotic values.
    Others chew on more memory and other computing resources as they sort a number
    of values. Another consideration is how sorting algorithms lend themselves to
    being expressed recursively or iteratively or both. There are algorithms that
    use comparison as the basis for sorting elements. An example of this is the bubble
    sort algorithm. Examples of a non-comparison sorting algorithm are the buck sort
    and pigeonhole sort.
  prefs: []
  type: TYPE_NORMAL
- en: Bubble sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea behind a bubble sort algorithm is very simple. Given an unordered list,
    we compare adjacent elements in the list, each time, putting in the right order
    of magnitude, only two elements. The algorithm hinges on a swap procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a list with only two elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To sort this list, simply swap them into the right position with **2** occupying
    index **0** and **5** occupying index **1**. To effectively swap these elements,
    we need to have a temporary storage area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Implementation of the bubble sort algorithm starts with the swap method, illustrated
    in the preceding image. First, element **5** will be copied to a temporary location,
    `temp`. Then element **2** will be moved to index **0**. Finally, **5** will be
    moved from temp to index **1**. At the end of it all, the elements will have been
    swapped. The list will now contain the element: `[2, 5]`. The following code will
    swap the elements of `unordered_list[j]` with `unordered_list[j+1]` if they are
    not in the right order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have been able to swap a two-element array, it should be simple
    to use this same idea to sort a whole list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll run this swap operation in a double-nested loop. The inner loop is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Knowing how many times to swap is important when implementing a bubble sort
    algorithm. To sort a list of numbers such as `[3, 2, 1]`, we need to swap the
    elements a maximum of twice. This is equal to the length of the list minus 1,
    `iteration_number = len(unordered_list)-1`. We subtract `1` because it gives us
    exactly the maximum number of iterations to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By swapping the adjacent elements in exactly two iterations, the largest number
    ends up at the last position on the list.
  prefs: []
  type: TYPE_NORMAL
- en: The `if` statement makes sure that no needless swaps occur if two adjacent elements
    are already in the right order. The inner `for` loop only causes the swapping
    of adjacent elements to occur exactly twice in our list.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you''ll realize that the running of the `for` loop for the first time
    does not entirely sort our list. How many times does this swapping operation have
    to occur in order for the entire list to be sorted? If we repeat the whole process
    of swapping the adjacent elements a number of times, the list will be sorted.
    An outer loop is used to make this happen. The swapping of elements in the list
    results in the following dynamics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We recognize that a total of four comparisons at most were needed to get our
    list sorted. Therefore, both inner and outer loops have to run `len(unordered_list)-1`
    times for all elements to be sorted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The same principle is used even if the list contains many elements. There are
    a lot of variations of the bubble sort too that minimize the number of iterations
    and comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: The bubble sort is a highly inefficient sorting algorithm with a time complexity
    of `O(n2)` and best case of `O(n)`. Generally, the bubble sort algorithm should
    not be used to sort large lists. However, on relatively small lists, it performs
    fairly well.
  prefs: []
  type: TYPE_NORMAL
- en: There is a variant of the bubble sort algorithm where if there is no comparison
    within the inner loop, we simply quit the entire sorting process. The absence
    of the need to swap elements in the inner loop suggests the list has already been
    sorted. In a way, this can help speed up the generally considered slow algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Insertion sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of swapping adjacent elements to sort a list of items can also be used
    to implement the insertion sort. In the insertion sort algorithm, we assume that
    a certain portion of the list has already been sorted, while the other portion
    remains unsorted. With this assumption, we move through the unsorted portion of
    the list, picking one element at a time. With this element, we go through the
    sorted portion of the list and insert it in the right order so that the sorted
    portion of the list remains sorted. That is a lot of grammar. Let's walk through
    the explanation with an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The algorithm starts by using a `for` loop to run between the indexes **1**
    and **4**. We start from index **1** because we assume the sub-array with index
    **0** to already be in the sorted order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At the start of the execution of the loop, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'At the beginning of the execution of each run of the `for` loop, the element
    at `unsorted_list[index]` is stored in the `insert_value` variable. Later, when
    we find the appropriate position in the sorted portion of the list, `insert_value`
    will be stored at that index or location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `search_index` is used to provide information to the `while` loop--exactly
    where to find the next element that needs to be inserted in the sorted portion
    of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `while` loop traverses the list backwards, guided by two conditions: first,
    if `search_index > 0`, then it means that there are more elements in the sorted
    portion of the list; second, for the `while` loop to run, `unsorted_list[search_index-1]`
    must be greater than the `insert_value`. The `unsorted_list[search_index-1]` array
    will do either of the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Point to the element just before the `unsorted_list[search_index]` before the
    `while` loop is executed the first time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Point to one element before `unsorted_list[search_index-1]` after the `while`
    loop has been run the first time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our list example, the `while` loop will be executed because `5 > 1`. In the
    body of the while loop, the element at `unsorted_list[search_index-1]` is stored
    at `unsorted_list[search_index]`. `search_index -= 1` moves the list traversal
    backwards till it bears the value `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our list now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After the `while` loop exits, the last known position of `search_index` (which
    in this case is `0`) now helps us to know where to insert `insert_value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the second iteration of the `for` loop, `search_index` will have the value
    **2**, which is the index of the third element in the array. At this point, we
    start our comparison in the direction to the left (towards index **0**). **100**
    will be compared with **5** but because **100** is greater than **5**, the while
    loop will not be executed. **100** will be replaced by itself because the `search_index` variable
    never got decremented. As such, `unsorted_list[search_index] = insert_value` will
    have no effect.
  prefs: []
  type: TYPE_NORMAL
- en: When `search_index` is pointing at index **3**, we compare **2** with **100**
    and move **100** to where **2** is stored. We then compare **2** with **5** and
    move **5** to where **100** was initially stored. At this point, the `while` loop
    will break and **2** will be stored in index **1**. The array will be partially
    sorted with the values `[1, 2, 5, 100, 10]`.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding step will occur one last time for the list to be sorted.
  prefs: []
  type: TYPE_NORMAL
- en: The insertion sort algorithm is considered stable in that it does not change
    the relative order of elements that have equal keys. It also only requires no
    more memory than what is consumed by the list because it does the swapping in-place.
  prefs: []
  type: TYPE_NORMAL
- en: Its worst case value is **O**(n²) and its best case is **O**(n).
  prefs: []
  type: TYPE_NORMAL
- en: Selection sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another popular sorting algorithm is the selection sort. This sorting algorithm
    is simple to understand, yet also inefficient, with its worst and best asymptotic
    values being **O**(*n²*). It begins by finding the smallest element in an array
    and interchanging it with data at, for instance, array index [**0**]. The same
    operation is done a second time; however, the smallest element in the remainder
    of the list after finding the first smallest element is interchanged with the
    data at index [**1**].
  prefs: []
  type: TYPE_NORMAL
- en: 'In a bid to throw more light on how the algorithm works, lets sort a list of
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Starting at index **0**, we search for the smallest item in the list that exists
    between index **1** and the index of the last element. When this element has been
    found, it is exchanged with the data found at index **0**. We simply repeat this
    process until the list becomes sorted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Searching for the smallest item within the list is an incremental process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A comparison of elements **2** and **5** selects **2** as the lesser of the
    two. The two elements are swapped.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the swap operation, the array looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Still at index **0**, we compare **2** with **65**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since **65** is greater than **2**, the two elements are not swapped. A further
    comparison is made between the element at index **0**, which is **2**, with element
    at index **3**, which is **10**. No swap takes place. When we get to the last
    element in the list, we will have the smallest element occupying index **0**.
  prefs: []
  type: TYPE_NORMAL
- en: A new set of comparisons will begin, but this time, from index **1**. We repeat
    the whole process of comparing the element stored there with all the elements
    between index **2** through to the last index.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step of the second iteration will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is an implementation of the selection sort algorithm. The argument
    to the function is the unsorted list of items we want to put in ascending order
    of magnitude:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The algorithm begins by using the outer `for` loop to go through the list, `size_of_list`,
    a number of times. Because we pass `size_of_list` to the `range` method, it will
    produce a sequence from **0** through to `size_of_list-1`. It is a subtle note.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inner loop is responsible for going through the list and making the necessary
    swap any time that we encounter an element less than the element pointed to by
    `unsorted_list[i]`. Notice that the inner loop begins from `i+1` up to `size_of_list-1`.
    The inner loop begins its search for the smallest element between `i+1` but uses
    the `j` index:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows the direction in which the algorithm searches for
    the next smallest item.
  prefs: []
  type: TYPE_NORMAL
- en: Quick sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The quick sort algorithm falls under the divide and conquer class of algorithms,
    where we break (divide) a problem into smaller chunks that are much simpler to
    solve (conquer). In this case, an unsorted array is broken into sub-arrays that
    are partially sorted, until all elements in the list are in the right position,
    by which time our unsorted list will have become sorted.
  prefs: []
  type: TYPE_NORMAL
- en: List partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we divide the list into smaller chunks, we have to partition it. This
    is the heart of the quick sort algorithm. To partition the array, we must first
    select a pivot. All the elements in the array will be compared with this pivot.
    At the end of the partitioning process, all elements that are less than the pivot
    will be to the left of the pivot, while all elements greater than the pivot will
    lie to the right of the pivot in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Pivot selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the sake of simplicity, we'll take the first element in any array as the
    pivot. This kind of pivot selection degrades in performance, especially when sorting
    an already sorted list. Randomly picking the middle or last element in the array
    as the pivot does not improve the situation any further. In the next chapter,
    we will adopt a better approach to selecting the pivot in order to help us find
    the smallest element in a list.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we delve into the code, let's run through the sorting of a list using
    the quick sort algorithm. The partitioning step is very important to understand
    so we'll tackle that operation first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following list of integers. We shall partition this list using
    the partition function below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The partition function receives the array that we need to partition as its
    parameters: the index of its first element and the index of its last element.'
  prefs: []
  type: TYPE_NORMAL
- en: The value of the pivot is stored in the `pivot` variable, while its index is
    stored in `pivot_index`. We are not using `unsorted_array[0]` because when the
    unsorted array parameter is called with a segment of an array, index `0` will
    not necessarily point to the first element in that array. The index of the next
    element to the pivot, `first_index + 1`, marks the position where we begin to
    look for the element in the array that is greater than the `pivot`, `greater_than_pivot_index
    = first_index + 1`.
  prefs: []
  type: TYPE_NORMAL
- en: '`less_than_pivot_index = index_of_last_element` marks the position of the last
    element in the list which is, where we begin the search for the element that is
    less than the pivot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'At the beginning of the execution of the main `while` loop the array looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first inner `while` loop moves one index to the right until it lands on
    index **2**, because the value at that index is greater than **43**. At this point,
    the first `while` loop breaks and does not continue. At each test of the condition
    in the first `while` loop, `greater_than_pivot_index += 1` is evaluated only if
    the `while` loop's test condition evaluates to `True`. This makes the search for
    the element greater than the pivot progress to the next element on the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second inner `while` loop moves one index at a time to the left, until
    it lands on index **5**, whose value, **20**, is less than **43**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, neither inner `while` loop can be executed any further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since `greater_than_pivot_index < less_than_pivot_index`, the body of the if
    statement swaps the element at those indexes. The else condition breaks the infinite
    loop any time `greater_than_pivot_index` becomes greater than `less_than_pivot_index`.
    In such a condition, it means that `greater_than_pivot_index` and `less_than_pivot_index`
    have crossed over each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our array now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The break statement is executed when `less_than_pivot_index` is equal to `3`
    and `greater_than_pivot_index` is equal to `4`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as we exit the `while` loop, we interchange the element at `unsorted_array[less_than_pivot_index]`
    with that of `less_than_pivot_index`, which is returned as the index of the pivot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The image below shows how the code interchanges 4 with 43 as the last step
    in the partitioning process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To recap, the first time the quick sort function was called, it was partitioned
    about the element at index **0**. After the return of the partitioning function,
    we obtain the array `[4, 3, 20, 43, 89, 77]`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, all elements to the right of element **43** are greater, while
    those to the left are smaller. The partitioning is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Using the split point 43 with index 3, we will recursively sort the two sub-arrays
    `[4, 30, 20]` and `[89, 77]` using the same process we just went through.
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of the main `quick sort` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `quick sort` function is a very simple method, no more than 6 lines of code.
    The heavy lifting is done by the `partition` function. When the `partition` method
    is called it returns the partition point. This is the point in the `unsorted_array`
    where all elements to the left are less than the pivot and all elements to its
    right are greater than it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we print the state of `unsorted_array` immediately after the partition
    progress, we see clearly how the partitioning is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Taking a step back, let's sort the first sub array after the first partition
    has happened. The partitioning of the `[4, 3, 20]` sub array will stop when `greater_than_pivot_index`
    is at index `2` and `less_than_pivot_index` is at index `1`. At that point, the
    two markers are said to have crossed. Because `greater_than_pivot_index` is greater
    than `less_than_pivot_index`, further execution of the `while` loop will cease.
    Pivot 4 will be exchanged with `3`, while index `1` is returned as the partition
    point.
  prefs: []
  type: TYPE_NORMAL
- en: The quick sort algorithm has a **O**(*n²*) worst case complexity, but it is
    efficient when sorting large amounts of data.
  prefs: []
  type: TYPE_NORMAL
- en: Heap sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 8](3119407a-e9f1-4aab-8a06-8eea85b17c33.xhtml), *Graphs and Other
    Algorithms*, we implemented the (binary) heap data structure. Our implementation
    always made sure that after an element has been removed or added to a heap, the
    heap order property is maintained by using the sink and float helper methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The heap data structure can be used to implement the sorting algorithm called
    the heap sort. As a recap, let''s create a simple heap with the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The heap, `h`, is created and the elements in the `unsorted_list` are inserted.
    After each method call to `insert`, the heap order property is restored by the
    subsequent call to the `float` method. After loop has terminated, at the top of
    our heap will be element `4`.
  prefs: []
  type: TYPE_NORMAL
- en: The number of elements in our heap is `10`. If we call the `pop` method on the
    heap object `h`, 10 times and store the actual elements being popped, we end up
    with a sorted list. After each `pop` operation, the heap is readjusted to maintain
    the heap order property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `heap_sort` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `for` loop simply calls the `pop` method `self.size` number of times. `sorted_list`
    will contain a sorted list of items after the loop terminates.
  prefs: []
  type: TYPE_NORMAL
- en: The `insert` method is called *n* number of times. Together with the `float`
    method, the `insert` operation takes a worst case runtime of **O**(*n log n*),
    as does the `pop` method. As such, this sorting algorithm incurs a worst case
    runtime of **O**(*n log n*).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored a number of sorting algorithms. Quick sort
    performs much better than the other sorting algorithms. Of all the algorithms
    discussed, quick sort preserves the index of the list that it sorts. We'll use
    this property in the next chapter as we explore the selection algorithms.
  prefs: []
  type: TYPE_NORMAL
