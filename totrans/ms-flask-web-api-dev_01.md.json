["```py\n pip install virtualenv\n```", "```py\n<st c=\"7975\">from flask import Flask</st>\n<st c=\"7999\">app = Flask(__name__)</st> @app.route('/', methods = ['GET'])\ndef index():\n    return \"This is an online … counseling system (OPCS)\" <st c=\"8233\">main.py</st> file:\n\n\t\t\t\t*   <st c=\"8246\">An imported</st> `<st c=\"8259\">Flask</st>` <st c=\"8264\">class from the</st> `<st c=\"8280\">flask</st>` <st c=\"8285\">package plays a considerable role in building the application.</st> <st c=\"8349\">This class provides all the utilities that implement the</st> `<st c=\"8708\">Flask</st>` <st c=\"8713\">instance is the main element in building a</st> **<st c=\"8757\">Web Server Gateway Interface</st>** <st c=\"8785\">(</st>**<st c=\"8787\">WSGI</st>**<st c=\"8791\">)-compliant</st> <st c=\"8804\">application.</st>\n\n\t\t\t<st c=\"8816\">Werkzeug</st>\n\t\t\t`<st c=\"8825\">Werkzeug</st>` <st c=\"8834\">is a WSGI-based library</st> <st c=\"8859\">or module that provides Flask with the necessary utilities, including a built-in server, for running</st> <st c=\"8960\">WSGI-based applications.</st>\n\n\t\t\t\t*   <st c=\"8984\">The imported</st> `<st c=\"8998\">Flask</st>` <st c=\"9003\">instance must be instantiated once per application.</st> <st c=\"9056\">The</st> `<st c=\"9060\">__name__</st>` <st c=\"9068\">argument must be passed to its constructor to provide</st> `<st c=\"9123\">Flask</st>` <st c=\"9128\">with a reference to the main module without explicitly setting its actual package.</st> <st c=\"9212\">Its purpose is to provide Flask with the reach it needs in providing the utilities across the application and to register the components of the project to</st> <st c=\"9367\">the framework.</st>\n\t\t\t\t*   <st c=\"9381\">The</st> `<st c=\"9386\">if</st>` <st c=\"9388\">statement tells the Python interpreter to run Werkzeug’s built-in development server if the module is</st> `<st c=\"9491\">main.py</st>`<st c=\"9498\">. This line validates the</st> `<st c=\"9524\">main.py</st>` <st c=\"9531\">module as the top-level module of</st> <st c=\"9566\">the project.</st>\n\t\t\t\t*   `<st c=\"9578\">app.run()</st>` <st c=\"9588\">calls and starts the built-in development server of Werkzeug.</st> <st c=\"9651\">Setting its</st> `<st c=\"9663\">debug</st>` <st c=\"9668\">parameter to</st> `<st c=\"9682\">True</st>` <st c=\"9686\">sets development or debug mode and enables Werkzeug’s debugger tool and automatic reloading.</st> <st c=\"9780\">Another way is to create a configuration file that will set</st> `<st c=\"9840\">FLASK_DEBUG</st>` <st c=\"9851\">to</st> `<st c=\"9855\">True</st>`<st c=\"9859\">. We can also set development mode by running</st> `<st c=\"9905\">main.py</st>` <st c=\"9912\">using the</st> `<st c=\"9923\">flask run</st>` <st c=\"9932\">command with the</st> `<st c=\"9950\">--debug</st>` <st c=\"9957\">option.</st> <st c=\"9966\">Other configuration approaches before Flask 3.0, such as using</st> `<st c=\"10029\">FLASK_ENV</st>`<st c=\"10038\">, are</st> <st c=\"10044\">already deprecated.</st>\n\n\t\t\t<st c=\"10063\">Running the</st> `<st c=\"10076\">python main.py</st>` <st c=\"10090\">command on the VS Code terminal will start the built-in development server and run our application.</st> <st c=\"10191\">A server log will be displayed on the console with details that include the development mode, the debugger ID, and the</st> `<st c=\"10343\">5000</st>`<st c=\"10347\">, while the host</st> <st c=\"10364\">is</st> `<st c=\"10367\">localhost</st>`<st c=\"10376\">.</st>\n\t\t\t<st c=\"10377\">Now, it is time to explore the view functions of our Flask application.</st> <st c=\"10450\">These are the components that manage</st> <st c=\"10487\">the incoming requests and</st> <st c=\"10513\">outgoing responses.</st>\n\t\t\t<st c=\"10532\">Creating routes and navigations</st>\n\t\t\t**<st c=\"10564\">Routing</st>** <st c=\"10572\">is a mapping of</st> <st c=\"10588\">URL pattern(s) and other related details to a view function that’s done using Flask’s route decorators.</st> <st c=\"10693\">On the other hand, the view function is a transaction that processes an incoming request from the clients and, at the same time, returns the necessary response to them.</st> <st c=\"10862\">It follows a life cycle and returns an HTTP status as part of</st> <st c=\"10924\">its response.</st>\n\t\t\t<st c=\"10937\">There are different approaches to assigning URL patterns to view functions.</st> <st c=\"11014\">These include creating static and dynamic URL patterns, mapping URLs externally, and mapping multiple URLs to a</st> <st c=\"11126\">view function.</st>\n\t\t\t<st c=\"11140\">Creating static URLs</st>\n\t\t\t<st c=\"11161\">Flask has several built-in route</st> <st c=\"11194\">decorators that implement some of its components, and</st> `<st c=\"11249\">@route</st>` <st c=\"11255\">decorator is one of these.</st> `<st c=\"11283\">@route</st>` <st c=\"11289\">directly maps the URL address to the view function seamlessly.</st> <st c=\"11353\">For instance,</st> `<st c=\"11367\">@route</st>` <st c=\"11373\">maps the</st> `<st c=\"11383\">index()</st>` <st c=\"11390\">view function presented in the project’s</st> `<st c=\"11432\">main.py</st>` <st c=\"11439\">file to the root URL or</st> `<st c=\"11464\">/</st>`<st c=\"11465\">, which makes</st> `<st c=\"11479\">index()</st>` <st c=\"11486\">the view function of the</st> <st c=\"11512\">root URL.</st>\n\t\t\t<st c=\"11521\">But</st> `<st c=\"11526\">@route</st>` <st c=\"11532\">can map any valid URL pattern to any view function.</st> <st c=\"11585\">A URL pattern is accepted if it follows the following</st> <st c=\"11639\">best practices:</st>\n\n\t\t\t\t*   <st c=\"11654\">All characters must be</st> <st c=\"11678\">in lowercase.</st>\n\t\t\t\t*   <st c=\"11691\">Use only forward slashes to establish</st> <st c=\"11730\">site hierarchy.</st>\n\t\t\t\t*   <st c=\"11745\">URL names must be concise, clear, and within the</st> <st c=\"11795\">business context.</st>\n\t\t\t\t*   <st c=\"11812\">Avoid spaces and special symbols and characters as much</st> <st c=\"11869\">as possible.</st>\n\n\t\t\t<st c=\"11881\">The following</st> `<st c=\"11896\">home()</st>` <st c=\"11902\">view function renders an introductory page of our</st> `<st c=\"11953\">ch01</st>` <st c=\"11957\">application and uses the URL pattern of</st> `<st c=\"11998\">/home</st>` <st c=\"12003\">for</st> <st c=\"12008\">its access:</st>\n\n```", "```py\n\n\t\t\t<st c=\"12282\">Now, Flask accepts simple URLs such as</st> `<st c=\"12322\">/home</st>` <st c=\"12327\">or complex ones with slashes and path-like hierarchy, including</st> <st c=\"12391\">these</st> <st c=\"12398\">multiple URLs.</st>\n\t\t\t<st c=\"12412\">Assigning multiple URLs</st>\n\t\t\t<st c=\"12436\">A view function can have a</st> <st c=\"12464\">stack of</st> `<st c=\"12473\">@route</st>` <st c=\"12479\">decorators annotated on it.</st> <st c=\"12508\">Flask allows us to map these valid multiple URLs if there is no conflict with other view functions and within that stack of</st> `<st c=\"12632\">@route</st>` <st c=\"12638\">mappings.</st> <st c=\"12649\">The following version of the</st> `<st c=\"12678\">home()</st>` <st c=\"12684\">view function now has three URLs, which means any of these addresses can render the</st> <st c=\"12769\">home page:</st>\n\n```", "```py\n\n\t\t\t<st c=\"13015\">Aside from complex URLs, Flask is</st> <st c=\"13050\">also capable of creating</st> *<st c=\"13075\">dynamic routes</st>*<st c=\"13089\">.</st>\n\t\t\t<st c=\"13090\">Applying path variables</st>\n\t\t\t<st c=\"13114\">Adding path variables makes a URL</st> <st c=\"13149\">dynamic and changeable depending on the variations of the values passed to it.</st> <st c=\"13228\">Although some SEO experts may disagree with having dynamic URLs, the Flask framework can allow view functions with changeable URL patterns to</st> <st c=\"13370\">be implemented.</st>\n\t\t\t<st c=\"13385\">In Flask, a path variable is declared inside a diamond operator (</st>`<st c=\"13451\"><></st>`<st c=\"13454\">) and placed within the URL path.</st> <st c=\"13489\">The following view function has a dynamic URL with several</st> <st c=\"13548\">path variables:</st>\n\n```", "```py\n\n\t\t\t<st c=\"13844\">As we can see, path variables are identified with data types inside the diamond operator (</st>`<st c=\"13935\"><></st>`<st c=\"13938\">) using the</st> `<st c=\"13951\"><type:variable></st>` <st c=\"13966\">pattern.</st> <st c=\"13976\">These parameters are set to</st> `<st c=\"14004\">None</st>` <st c=\"14008\">if the path variables are optional.</st> <st c=\"14045\">The path variable is considered a string type by default if it has no associated type hint.</st> *<st c=\"14137\">Flask 3.x</st>* <st c=\"14146\">offers these built-in data types for</st> <st c=\"14184\">path variables:</st>\n\n\t\t\t\t*   **<st c=\"14199\">string</st>**<st c=\"14206\">: Allows all valid characters except</st> <st c=\"14244\">for slashes.</st>\n\t\t\t\t*   **<st c=\"14256\">int</st>**<st c=\"14260\">: Takes</st> <st c=\"14269\">integer values.</st>\n\t\t\t\t*   **<st c=\"14284\">float</st>**<st c=\"14290\">: Accepts</st> <st c=\"14301\">real numbers.</st>\n\t\t\t\t*   **<st c=\"14314\">uuid</st>**<st c=\"14319\">: Takes unique 32 hexadecimal digits that are used to identify or represent records, documents, hardware gadgets, software licenses, and</st> <st c=\"14457\">other information.</st>\n\t\t\t\t*   **<st c=\"14475\">path</st>**<st c=\"14480\">: Fetches characters,</st> <st c=\"14503\">including slashes.</st>\n\n\t\t\t<st c=\"14521\">These path variables can’t function</st> <st c=\"14558\">without the corresponding parameters of the same name and type declared in the view function’s parameter list.</st> <st c=\"14669\">In the previous</st> `<st c=\"14685\">report_exam_passers()</st>` <st c=\"14706\">view function, the local</st> `<st c=\"14732\">rating</st>` <st c=\"14738\">and</st> `<st c=\"14743\">docId</st>` <st c=\"14748\">parameters are the variables that will hold the values of the path</st> <st c=\"14816\">variables, respectively.</st>\n\t\t\t<st c=\"14840\">But there are particular or rare cases where path variables should be of a type different than the supported ones.</st> <st c=\"14956\">View functions with path variables declared as</st> `<st c=\"15003\">list</st>`<st c=\"15007\">,</st> `<st c=\"15009\">set</st>`<st c=\"15012\">,</st> `<st c=\"15014\">date</st>`<st c=\"15018\">, or</st> `<st c=\"15023\">time</st>` <st c=\"15027\">will throw</st> `<st c=\"15039\">Status Code 500</st>` <st c=\"15054\">in Flask.</st> <st c=\"15065\">As a workaround, the Werkzeug bundle of libraries offers a</st> `<st c=\"15124\">BaseConverter</st>` <st c=\"15137\">utility class that can help customize a variable type for paths that allows other types to be part of the type hints.</st> <st c=\"15256\">The following view function requires a</st> `<st c=\"15295\">date</st>` <st c=\"15299\">type hint to generate a certificate in</st> <st c=\"15339\">HTML format:</st>\n\n```", "```py\n\n\t\t\t`<st c=\"15918\">accomplished_date</st>` <st c=\"15936\">in</st> `<st c=\"15940\">show_certification()</st>` <st c=\"15960\">is a</st> `<st c=\"15966\">date</st>` <st c=\"15970\">hint type and will not be valid until the following tasks</st> <st c=\"16029\">are implemented:</st>\n\n\t\t\t\t*   <st c=\"16045\">First, subclass</st> `<st c=\"16062\">BaseConverter</st>` <st c=\"16075\">from the</st> `<st c=\"16085\">werkzeug.routing</st>` <st c=\"16101\">module.</st> <st c=\"16110\">In the</st> `<st c=\"16117\">/converter</st>` <st c=\"16127\">package of this project, there is a module called</st> `<st c=\"16178\">date_converter.py</st>` <st c=\"16195\">that implements our</st> `<st c=\"16216\">date</st>` <st c=\"16220\">hint type, as shown in the</st> <st c=\"16248\">following code:</st>\n\n    ```", "```py\n\n    <st c=\"16470\">The given</st> `<st c=\"16481\">DateConverter</st>` <st c=\"16494\">will custom-handle date variables within our</st> <st c=\"16540\">Flask application.</st>\n\n    \t\t\t\t*   `<st c=\"16558\">BaseConverter</st>` <st c=\"16572\">has a</st> `<st c=\"16579\">to_python()</st>` <st c=\"16590\">method that must be overridden to implement the necessary conversion</st> <st c=\"16659\">process.</st> <st c=\"16669\">In the case of</st> `<st c=\"16684\">DateConverter</st>`<st c=\"16697\">, we need</st> `<st c=\"16707\">strptime()</st>` <st c=\"16717\">so that we can convert the path variable value in the</st> `<st c=\"16772\">yyyy-mm-dd</st>` <st c=\"16782\">format into the</st> <st c=\"16799\">datetime type.</st>\n\t\t\t\t*   <st c=\"16813\">Lastly, declare our new custom converter in the Flask instance of the</st> `<st c=\"16884\">main.py</st>` <st c=\"16891\">module.</st> <st c=\"16900\">The following snippet registers</st> `<st c=\"16932\">DateConverter</st>` <st c=\"16945\">to</st> `<st c=\"16949\">app</st>`<st c=\"16952\">:</st>\n\n    ```", "```py\n\n\t\t\t<st c=\"17023\">After following all these steps, the custom path variable type – for instance,</st> `<st c=\"17103\">date</st>` <st c=\"17107\">– can now be utilized across</st> <st c=\"17137\">the application.</st>\n\t\t\t<st c=\"17153\">Assigning URLs externally</st>\n\t\t\t<st c=\"17179\">There is also a way to</st> <st c=\"17202\">implement a routing mechanism without using the</st> `<st c=\"17251\">@route</st>` <st c=\"17257\">decorator, and that’s by utilizing Flask’s</st> `<st c=\"17301\">add_url_rule()</st>` <st c=\"17315\">method to register views.</st> <st c=\"17342\">This approach binds a valid request handler to a unique URL pattern for every call to</st> `<st c=\"17428\">add_url_rule()</st>` <st c=\"17442\">of the</st> `<st c=\"17450\">app</st>` <st c=\"17453\">instance in the</st> `<st c=\"17470\">main.py</st>` <st c=\"17477\">module, not in the handler’s module scripts, thus making this approach an external way of building routes.</st> <st c=\"17585\">The following arguments are needed by the</st> `<st c=\"17627\">add_url_rule()</st>` <st c=\"17641\">method to</st> <st c=\"17652\">perform mapping:</st>\n\n\t\t\t\t*   <st c=\"17668\">The URL pattern with or without the</st> <st c=\"17705\">path variables.</st>\n\t\t\t\t*   <st c=\"17720\">The URL name and, usually, the exact name of the</st> <st c=\"17770\">view function.</st>\n\t\t\t\t*   <st c=\"17784\">The view</st> <st c=\"17794\">function itself.</st>\n\n\t\t\t<st c=\"17810\">The invocation of this method must be in the</st> `<st c=\"17856\">main.py</st>` <st c=\"17863\">file, anywhere after its</st> `<st c=\"17889\">@route</st>` <st c=\"17895\">implementations and view imports.</st> <st c=\"17930\">The following</st> `<st c=\"17944\">main.py</st>` <st c=\"17951\">snippet shows the external route mapping of the</st> `<st c=\"18000\">show_honor_dismissal()</st>` <st c=\"18022\">view function to its dynamic URL pattern.</st> <st c=\"18065\">This view function generates a termination letter for the counseling and consultation agreement between a clinic and</st> <st c=\"18182\">a patient:</st>\n\n```", "```py\n<st c=\"19676\">from flask.views import View</st>\n<st c=\"19705\">class ListUnpaidContractView(View):</st><st c=\"19741\">def dispatch_request(self):</st> contracts = select_all_unpaid_patient()\n        return render_template(\"contract/ list_patient_contract.html\", contracts=contracts)\n```", "```py\n app.<st c=\"20636\">View</st> subclass needs an HTTP <st c=\"20664\">POST</st> transaction, it has a built-class class attribute called <st c=\"20726\">methods</st> that accepts a list of HTTP methods the class needs to support. Without it, the default is the <st c=\"20829\">[ \"GET\" ]</st> value. Here is another custom <st c=\"20869\">View</st> class of our *<st c=\"20887\">Online Personal Counselling System</st>* app that deletes existing patient contracts of the clinic:\n\n```", "```py\n\n\t\t\t`<st c=\"21523\">DeleteContractByPIDView</st>` <st c=\"21547\">handles a typical form-handling transaction, which has both a</st> `<st c=\"21610\">GET</st>` <st c=\"21613\">operation for loading the form page and a</st> `<st c=\"21656\">POST</st>` <st c=\"21660\">operation to manage the submitted form data.</st> <st c=\"21706\">The</st> `<st c=\"21710\">POST</st>` <st c=\"21714\">operation will verify if the patient ID submitted by the form page exists, and it will eventually delete the contract(s) of the patient using the patient ID and render an updated list</st> <st c=\"21899\">of contracts.</st>\n\t\t\t<st c=\"21912\">Other than the</st> `<st c=\"21928\">View</st>` <st c=\"21932\">class, an alternative API that</st> <st c=\"21963\">can also build view transactions is the</st> `<st c=\"22004\">MethodView</st>` <st c=\"22014\">class.</st> <st c=\"22022\">This class is suitable for web forms since it has the built-in</st> `<st c=\"22085\">GET</st>` <st c=\"22088\">and</st> `<st c=\"22093\">POST</st>` <st c=\"22097\">hints or templates that subclasses need to define but without the need to identify the</st> `<st c=\"22185\">GET</st>` <st c=\"22188\">transactions from</st> `<st c=\"22207\">POST</st>`<st c=\"22211\">, like in a view function.</st> <st c=\"22238\">Here is a view that uses</st> `<st c=\"22263\">MethodView</st>` <st c=\"22273\">to manage the contracts of the patients in</st> <st c=\"22317\">the clinic:</st>\n\n```", "```py\n\n\t\t\t<st c=\"22977\">The</st> `<st c=\"22982\">MethodView</st>` <st c=\"22992\">class does not have a</st> `<st c=\"23015\">methods</st>` <st c=\"23022\">class variable to indicate the HTTP methods supported by the view.</st> <st c=\"23090\">Instead, the subclass can select the appropriate HTTP hints from</st> `<st c=\"23155\">MethodView</st>`<st c=\"23165\">, which will then implement the required HTTP transactions of the custom</st> <st c=\"23238\">view class.</st>\n\t\t\t<st c=\"23249\">Since</st> `<st c=\"23256\">MethodView</st>` <st c=\"23266\">is a subclass of the</st> `<st c=\"23288\">View</st>` <st c=\"23292\">class, it also has an</st> `<st c=\"23315\">as_view()</st>` <st c=\"23324\">class method that creates a</st> `<st c=\"23353\">view_func</st>` <st c=\"23362\">name of the view.</st> <st c=\"23381\">This is also necessary for</st> `<st c=\"23408\">add_url_rule()</st>` <st c=\"23422\">registration.</st>\n\t\t\t<st c=\"23436\">Aside from</st> `<st c=\"23448\">GET</st>` <st c=\"23451\">and</st> `<st c=\"23456\">POST</st>`<st c=\"23460\">, the</st> `<st c=\"23466\">MethodView</st>` <st c=\"23476\">class also provides the</st> `<st c=\"23501\">PUT</st>`<st c=\"23504\">,</st> `<st c=\"23506\">PATCH</st>`<st c=\"23511\">, and</st> `<st c=\"23517\">DELETE</st>` <st c=\"23523\">method hints for API-based</st> <st c=\"23550\">applications.</st> `<st c=\"23565\">MethodView</st>` <st c=\"23575\">is better than the</st> `<st c=\"23595\">View</st>` <st c=\"23599\">API because it organizes the transactions according to HTTP methods and checks and executes these HTTP methods by itself at runtime.</st> <st c=\"23733\">In general, between the decorated view function and the class-based ones, the latter approach provides a complete Flask view component because of the attributes and built-in methods inherited by the view implementation from these API classes.</st> <st c=\"23976\">Although the decorated view function can support a flexible and open-ended strategy for scalable applications, it cannot provide an organized base functionality that can supply baseline view features to other related views, unlike in a class-based approach.</st> <st c=\"24234\">However, the choice still depends on the scope and requirements of</st> <st c=\"24301\">the application.</st>\n\t\t\t<st c=\"24317\">Now that we’ve created and registered the routes, let’s scrutinize these view implementations and identify the</st> <st c=\"24428\">essential Flask components that</st> <st c=\"24461\">compose them.</st>\n\t\t\t<st c=\"24474\">Managing request and response data</st>\n\t\t\t<st c=\"24509\">At this point, we already know that routing is a mechanism for mapping view functions to their URLs.</st> <st c=\"24611\">But besides that, routing declares any valid functions to be view implementations that can manage the incoming request and</st> <st c=\"24734\">outgoing response.</st>\n\t\t\t<st c=\"24752\">Retrieving the request object</st>\n\t\t\t<st c=\"24782\">Flask uses its</st> `<st c=\"24798\">request</st>` <st c=\"24805\">object to carry</st> <st c=\"24822\">cookies, headers, parameters, form data, form objects, authorization data, and other request-related details.</st> <st c=\"24932\">But the view function doesn’t need to declare a variable to auto-wire the request instance, just like in Django, because Flask has a built-in proxy object for it, the</st> `<st c=\"25099\">request</st>` <st c=\"25106\">object, which is part of the</st> `<st c=\"25136\">flask</st>` <st c=\"25141\">package.</st> <st c=\"25151\">The following view function takes the</st> `<st c=\"25189\">username</st>` <st c=\"25197\">and</st> `<st c=\"25202\">password</st>` <st c=\"25210\">request parameters and checks if the credentials are in</st> <st c=\"25267\">the database:</st>\n\n```", "```py\n\n\t\t\t<st c=\"25728\">For instance, running the URL pattern of the given view function,</st> `<st c=\"25795\">http://localhost:5000/login/params?username=sjctrags&password=sjctrags2255</st>`<st c=\"25869\">, will provide us with</st> `<st c=\"25892\">sjctrags</st>` <st c=\"25900\">and</st> `<st c=\"25905\">sjctrags2255</st>` <st c=\"25917\">as values when</st> `<st c=\"25933\">request.args['username']</st>` <st c=\"25957\">and</st> `<st c=\"25962\">request.args['password']</st>` <st c=\"25986\">are</st> <st c=\"25991\">accessed, respectively.</st>\n\t\t\t<st c=\"26014\">Here is the complete list of objects</st> <st c=\"26052\">and details that we can retrieve from the</st> `<st c=\"26094\">Request</st>` <st c=\"26101\">object through its request</st> <st c=\"26129\">instance proxy:</st>\n\n\t\t\t\t*   `<st c=\"26144\">request.args</st>`<st c=\"26157\">: Returns a</st> `<st c=\"26170\">MultiDict</st>` <st c=\"26179\">class that carries URL arguments or request parameters from the</st> <st c=\"26244\">query string.</st>\n\t\t\t\t*   `<st c=\"26257\">request.form</st>`<st c=\"26270\">: Returns a</st> `<st c=\"26283\">MultiDict</st>` <st c=\"26292\">class that contains parameters from an HTML form or JavaScript’s</st> `<st c=\"26358\">FormData</st>` <st c=\"26366\">object.</st>\n\t\t\t\t*   `<st c=\"26374\">request.data</st>`<st c=\"26387\">: Returns request data in a byte stream that Flask couldn’t parse to form parameters and values due to an unrecognizable</st> <st c=\"26509\">mime type.</st>\n\t\t\t\t*   `<st c=\"26519\">request.files</st>`<st c=\"26533\">: Returns a</st> `<st c=\"26546\">MultiDict</st>` <st c=\"26555\">class containing all file objects from a form</st> <st c=\"26602\">with</st> `<st c=\"26607\">enctype=multipart/form-data</st>`<st c=\"26634\">.</st>\n\t\t\t\t*   `<st c=\"26635\">request.get_data()</st>`<st c=\"26654\">: This function returns the request data in byte streams before</st> <st c=\"26719\">calling</st> `<st c=\"26727\">request.data</st>`<st c=\"26739\">.</st>\n\t\t\t\t*   `<st c=\"26740\">request.json</st>`<st c=\"26753\">: Returns parsed JSON data when the incoming request has a</st> `<st c=\"26813\">Content-Type</st>` <st c=\"26825\">header</st> <st c=\"26833\">of</st> `<st c=\"26836\">application/json</st>`<st c=\"26852\">.</st>\n\t\t\t\t*   `<st c=\"26853\">request.method</st>`<st c=\"26868\">: Returns the HTTP</st> <st c=\"26888\">method name.</st>\n\t\t\t\t*   `<st c=\"26900\">request.values</st>`<st c=\"26915\">: Returns the combined parameters of</st> `<st c=\"26953\">args</st>` <st c=\"26957\">and</st> `<st c=\"26962\">form</st>` <st c=\"26966\">and encounters collision problems when both</st> `<st c=\"27011\">args</st>` <st c=\"27015\">and</st> `<st c=\"27020\">form</st>` <st c=\"27024\">carry the same</st> <st c=\"27040\">parameter name.</st>\n\t\t\t\t*   `<st c=\"27055\">request.headers</st>`<st c=\"27071\">: Returns request headers included in the</st> <st c=\"27114\">incoming request.</st>\n\t\t\t\t*   `<st c=\"27131\">request.cookies</st>`<st c=\"27147\">: Returns all the cookies that are part of</st> <st c=\"27191\">the request.</st>\n\n\t\t\t<st c=\"27203\">The following view function utilizes some of the given request objects to perform an HTTP</st> `<st c=\"27294\">GET</st>` <st c=\"27297\">operation to fetch a user login</st> <st c=\"27330\">application through an</st> `<st c=\"27353\">ID</st>` <st c=\"27355\">value and an HTTP</st> `<st c=\"27374\">POST</st>` <st c=\"27378\">operation to retrieve the user details, approve its preferred user role, and save the login details as new, valid</st> <st c=\"27493\">user credentials:</st>\n\n```", "```py\n\n\t\t\t<st c=\"28545\">Our application has a listing view that renders hyperlinks that can redirect users to this</st> `<st c=\"28637\">signup_approve()</st>` <st c=\"28653\">form page with a context variable</st> `<st c=\"28688\">id</st>`<st c=\"28690\">, a code for a user type.</st> <st c=\"28716\">The view function retrieves the variable</st> `<st c=\"28757\">id</st>` <st c=\"28759\">through</st> `<st c=\"28768\">request.args</st>`<st c=\"28780\">, checks what the user type</st> `<st c=\"28808\">id</st>` <st c=\"28810\">is, and renders the appropriate page based on the user type detected.</st> <st c=\"28881\">The function also uses</st> `<st c=\"28904\">request.method</st>` <st c=\"28918\">to check if the user request will pursue either the</st> `<st c=\"28971\">GET</st>` <st c=\"28974\">or</st> `<st c=\"28978\">POST</st>` <st c=\"28982\">transaction since the given view function caters to both HTTP methods, as defined in its</st> *<st c=\"29072\">dual</st>* <st c=\"29076\">route</st> <st c=\"29083\">declaration.</st> <st c=\"29096\">When clicking the</st> `<st c=\"29150\">POST</st>` <st c=\"29154\">transaction retrieves all the form parameters and values in a byte stream type via</st> `<st c=\"29238\">request.get_data()</st>`<st c=\"29256\">. It is decoded to a query string object and converted into a dictionary by</st> `<st c=\"29332\">parse_sql</st>` <st c=\"29341\">from the</st> `<st c=\"29351\">urllib.parse</st>` <st c=\"29363\">module.</st>\n\t\t\t<st c=\"29371\">Now, if Flask can handle the request, it can also manage the outgoing response from the</st> <st c=\"29460\">view functions.</st>\n\t\t\t<st c=\"29475\">Creating the response object</st>\n\t\t\t<st c=\"29504\">Flask uses</st> `<st c=\"29516\">Response</st>` <st c=\"29524\">to generate a</st> <st c=\"29538\">client response for every request.</st> <st c=\"29574\">The following view function renders a form page using the</st> `<st c=\"29632\">Response</st>` <st c=\"29640\">object:</st>\n\n```", "```py\n @app.route('/signup/form', methods= ['GET'])\ndef signup_users_form():\n    resp = Response(  response=<st c=\"31089\">render_template('add_signup.html')</st>, status=200, content_type=\"text/html\")\n    return resp\n```", "```py\n @app.route('/signup/list', methods = ['GET'])\ndef signup_list_users(): <st c=\"31845\">render_template()</st> can accept and pass context data to the template page. The <st c=\"31922\">candidates</st> variable in this snippet handles an extracted list of records from the database needed by the template for content generation using the <st c=\"32069\">Jinja2</st> engine.\n\t\t\t<st c=\"32083\">Jinja2</st>\n\t\t\t<st c=\"32090\">Jinja2 is Python’s fast, flexible, robust, expressive, and extensive templating engine for creating HTML, XML, LaTeX, and other supported formats for Flask’s</st> <st c=\"32249\">rendition purposes.</st>\n\t\t\t<st c=\"32268\">On the other hand, Flask has a utility called</st> `<st c=\"32315\">make_response()</st>` <st c=\"32330\">that can modify the response by changing headers and cookies before sending them to the client.</st> <st c=\"32427\">This method is suitable when the base response frequently undergoes some changes in its response headers and cookies.</st> <st c=\"32545\">The following code modifies the content type of the original response to XLS with a</st> <st c=\"32628\">given filename – in this</st> <st c=\"32654\">case,</st> `<st c=\"32660\">question.xls</st>`<st c=\"32672\">:</st>\n\n```", "```py\n\n\t\t\t<st c=\"33026\">Flask will require additional Python extensions when serializing and yielding PDF, XLSX, DOCX, RTF, and other complex content types.</st> <st c=\"33160\">But for old and simple mime type values such as</st> `<st c=\"33208\">application/msword</st>` <st c=\"33226\">and</st> `<st c=\"33231\">application/vnd.ms-excel</st>`<st c=\"33255\">, Flask can easily and seamlessly serialize the content since Python has a built-in serializer for them.</st> <st c=\"33360\">Other than mime types, Flask also supports adding web cookies for route functions.</st> <st c=\"33443\">The following</st> `<st c=\"33457\">assign_exam()</st>` <st c=\"33470\">route shows how to add cookies to the</st> `<st c=\"33509\">response</st>` <st c=\"33517\">value that renders a form for scheduling and assigning counseling exams for patients with their</st> <st c=\"33614\">respective counselors:</st>\n\n```", "```py\n\n\t\t\t<st c=\"34431\">The</st> `<st c=\"34436\">Response</st>` <st c=\"34444\">instance has a</st> `<st c=\"34460\">set_cookie()</st>` <st c=\"34472\">method that creates cookies before the view dispatches the</st> <st c=\"34531\">response to the client.</st> <st c=\"34556\">It also has</st> `<st c=\"34568\">delete_cookie()</st>`<st c=\"34583\">, which deletes a particular cookie before yielding the response.</st> <st c=\"34649\">To retrieve the cookies,</st> `<st c=\"34674\">request.cookies</st>` <st c=\"34689\">has a</st> `<st c=\"34696\">get()</st>` <st c=\"34701\">method that can retrieve the cookie value through its cookie name.</st> <st c=\"34769\">The given</st> `<st c=\"34779\">assign_exam()</st>` <st c=\"34792\">route shows how the</st> `<st c=\"34813\">get()</st>` <st c=\"34818\">method</st> <st c=\"34825\">retrieves</st> `<st c=\"34836\">exam_cookie</st>` <st c=\"34847\">in its</st> `<st c=\"34855\">POST</st>` <st c=\"34859\">transaction.</st>\n\t\t\t<st c=\"34872\">Implementing page redirection</st>\n\t\t\t<st c=\"34902\">Sometimes, it is ideal for the route transaction to redirect the user to another view page using the</st> `<st c=\"35004\">redirect()</st>` <st c=\"35014\">utility</st> <st c=\"35022\">method instead of building its own</st> `<st c=\"35058\">Response</st>` <st c=\"35066\">instance.</st> <st c=\"35077\">Flask redirection requires a URL pattern of the destination to where the view function will redirect.</st> <st c=\"35179\">For instance, in the previous</st> `<st c=\"35209\">assign_exam()</st>` <st c=\"35222\">route, the output of its</st> `<st c=\"35248\">POST</st>` <st c=\"35252\">transaction is not a</st> `<st c=\"35274\">Response</st>` <st c=\"35282\">instance but a</st> `<st c=\"35298\">redirect()</st>` <st c=\"35308\">method:</st>\n\n```", "```py\n @app.route('/exam/success', methods=['GET'])\ndef <st c=\"36037\">redirect_success_exam</st>(): <st c=\"36063\">message = request.args['message']</st> return render_template('exam/redirect_success_view.html', message=message)\n```", "```py\n from flask import Flask\napp = Flask(__name__, <st c=\"38049\">pages</st> directory when calling the template files through the <st c=\"38109\">render_template()</st> method.\n\t\t\t<st c=\"38134\">When it comes to syntax, Jinja2 has a placeholder (</st>`<st c=\"38186\">{{ }}</st>`<st c=\"38192\">) that renders dynamic content passed by the view functions to its template file.</st> <st c=\"38275\">It also has a Jinja block (</st>`<st c=\"38302\">{% %}</st>`<st c=\"38308\">) that supports control structures such as loops, conditional statements, macros, and template inheritance.</st> <st c=\"38417\">In the previous route function,</st> `<st c=\"38449\">assign_exam()</st>`<st c=\"38462\">, the</st> `<st c=\"38468\">GET</st>` <st c=\"38471\">transaction retrieves a list of counselor IDs (</st>`<st c=\"38519\">cids</st>`<st c=\"38524\">) and patient IDs (</st>`<st c=\"38544\">pids</st>`<st c=\"38549\">) from the database and passes them to the</st> `<st c=\"38593\">assign_exam_form.html</st>` <st c=\"38614\">template found in the</st> `<st c=\"38637\">exam</st>` <st c=\"38641\">subfolder</st> <st c=\"38651\">of the</st> `<st c=\"38659\">pages</st>` <st c=\"38664\">directory.</st> <st c=\"38676\">The following snippet shows the implementation of the</st> `<st c=\"38730\">assign_exam_form.html</st>` <st c=\"38751\">view template:</st>\n\n```", "```py\n\n\t\t\t<st c=\"39311\">This template uses the Jinja block to iterate all the IDs and embed each in the</st> `<st c=\"39392\"><option></st>` <st c=\"39400\">tag of the</st> `<st c=\"39412\"><select></st>` <st c=\"39420\">component with the</st> <st c=\"39440\">placeholder operator.</st>\n\t\t\t<st c=\"39461\">More about Jinja2 and Flask 3.x will be</st> <st c=\"39502\">covered in</st> [*<st c=\"39513\">Chapter 2</st>*](B19383_02.xhtml#_idTextAnchor047)<st c=\"39522\">, but for now, let’s delve into how Flask can implement the most common type of web-based transaction – that is, by capturing form data from</st> <st c=\"39663\">the client.</st>\n\t\t\t<st c=\"39674\">Creating web forms</st>\n\t\t\t<st c=\"39693\">In Flask, we can</st> <st c=\"39710\">choose from the following two approaches when implementing view functions for form</st> <st c=\"39794\">data processing:</st>\n\n\t\t\t\t*   <st c=\"39810\">Creating two separate routes, one for the</st> `<st c=\"39853\">GET</st>` <st c=\"39856\">operation and the other for the</st> `<st c=\"39889\">POST</st>` <st c=\"39893\">transaction, as shown for the following user</st> <st c=\"39939\">signup transaction:</st>\n\n    ```", "```py\n\n    \t\t\t\t*   <st c=\"40606\">Utilizing only one view function for both the</st> `<st c=\"40653\">GET</st>` <st c=\"40656\">and</st> `<st c=\"40661\">POST</st>` <st c=\"40665\">transactions, as shown in the</st> <st c=\"40696\">previous</st> `<st c=\"40705\">signup_approve()</st>` <st c=\"40721\">route and in the following</st> `<st c=\"40749\">assign_exam()</st>` <st c=\"40762\">view:</st>\n\n    ```", "```py\n\n\t\t\t<st c=\"41415\">Compared to the first, the second approach needs</st> `<st c=\"41465\">request.method</st>` <st c=\"41479\">to separate</st> `<st c=\"41492\">GET</st>` <st c=\"41495\">from the</st> `<st c=\"41505\">POST</st>` <st c=\"41509\">transaction.</st>\n\t\t\t<st c=\"41522\">In setting up the form template, binding context data to the form components through</st> `<st c=\"41608\">render_template()</st>` <st c=\"41625\">is a fast way to provide the form with parameters with default values.</st> <st c=\"41697\">The form model must derive the names of its attributes from the form parameters to establish a</st> <st c=\"41792\">successful mapping, such as in the</st> `<st c=\"41827\">signup_approve()</st>` <st c=\"41843\">route.</st> <st c=\"41851\">When it comes to retrieving the form data, the</st> `<st c=\"41898\">request</st>` <st c=\"41905\">proxy has a</st> `<st c=\"41918\">form</st>` <st c=\"41922\">dictionary object that can store form parameters and their data while its</st> `<st c=\"41997\">get_data()</st>` <st c=\"42007\">function can access the entire query string in byte stream type.</st> <st c=\"42073\">After a successful</st> `<st c=\"42092\">POST</st>` <st c=\"42096\">transaction, the view function can use</st> `<st c=\"42136\">render_template()</st>` <st c=\"42153\">to load a success page or go back to the form page.</st> <st c=\"42206\">It may also apply redirection to bring the client to</st> <st c=\"42259\">another view.</st>\n\t\t\t<st c=\"42272\">But what happens to the form data after form submission?</st> <st c=\"42330\">Usually, form parameter values are rendered as request attributes, stored as values of the session scope, or saved into a data store using a data persistency mechanism.</st> <st c=\"42499\">Let’s explore how Flask can manage data from user requests using a relational database such</st> <st c=\"42591\">as PostgreSQL.</st>\n\t\t\t<st c=\"42605\">Building the data layer with PostgreSQL</st>\n\t\t\t`<st c=\"42795\">psycopg2-binary</st>` <st c=\"42810\">extension module.</st> <st c=\"42829\">To install this extension module into the</st> `<st c=\"42871\">venv</st>`<st c=\"42875\">, run the</st> <st c=\"42884\">following command:</st>\n\n```", "```py\n\n\t\t\t<st c=\"42931\">Now, we can write an approach to establish a connection to the</st> <st c=\"42995\">PostgreSQL database.</st>\n\t\t\t<st c=\"43015\">Setting up database connectivity</st>\n\t\t\t<st c=\"43048\">There are multiple ways to create a connection to a database, but this chapter will showcase a Pythonic way to</st> <st c=\"43160\">extract that connection using a custom decorator.</st> <st c=\"43210\">In the project’s</st> `<st c=\"43227\">/config</st>` <st c=\"43234\">directory, there is a</st> `<st c=\"43257\">connect_db</st>` <st c=\"43267\">decorator that uses</st> `<st c=\"43288\">psycopgy2.connect()</st>` <st c=\"43307\">to establish connectivity to the</st> `<st c=\"43341\">opcs</st>` <st c=\"43345\">database of our prototype.</st> <st c=\"43373\">Here is the implementation of this</st> <st c=\"43408\">custom decorator:</st>\n\n```", "```py\n pip install python-dotenv\n```", "```py\n from config.db import connect_db\nfrom typing import Dict, Any, List <st c=\"45101\">@connect_db</st> def insert_signup(<st c=\"45131\">conn</st>, user:str, passw:str, utype:str, fname:str, lname:str, cid:str) -> bool:\n    try: <st c=\"45215\">cur = conn.cursor()</st> sql = 'INSERT INTO signup (username, password, user_type, firstname, lastname, cid) VALUES (%s, %s, %s, %s, %s, %s)'\n        values = (user, passw, utype, fname, lname, cid) <st c=\"45401\">cur.execute(sql, values)</st><st c=\"45425\">cur.close()</st> return True\n    except Exception as e:\n        cur.close()\n        print(e)\n    return False\n```", "```py\n<st c=\"45738\">@connect_db</st> def update_signup(<st c=\"45769\">conn</st>, id:int, details:Dict[str, Any]) -> bool:\n    try: <st c=\"45822\">cur = conn.cursor()</st> params = ['{} = %s'.format(key) for key in details.keys()]\n        values = tuple(details.values())\n        sql = 'UPDATE signup SET {} where id = {}'.format(', '.join(params), id); <st c=\"46008\">cur.execute(sql, values)</st><st c=\"46032\">cur.close()</st> return True\n    except Exception as e:\n        cur.close()\n        print(e)\n    return False\n```", "```py\n<st c=\"46220\">@connect_db</st> def delete_signup(conn, id) -> bool:\n    try: <st c=\"46275\">cur = conn.cursor()</st> sql = 'DELETE FROM signup WHERE id = %s'\n        values = (id, ) <st c=\"46352\">cur.execute(sql, values)</st><st c=\"46376\">cur.close()</st> return True\n    except Exception as e:\n        cur.close()\n        print(e)\n    return False\n```", "```py\n<st c=\"47363\">def record_patient_exam(formdata:Dict[str, Any]) -> bool:</st> try:\n        pct = round((<st c=\"47440\">formdata['score']</st> / <st c=\"47461\">formdata['total']</st>) * 100, 2)\n        status = None\n        if (pct >= 70):\n            status = 'passed'\n        elif (pct < 70) and (pct >= 55):\n            status = 'conditional'\n        else:\n            status = 'failed' <st c=\"47619\">insert_patient_score(pid=formdata['pid'],</st> <st c=\"47660\">qid=formdata['qid'], score=formdata['score'],</st> <st c=\"47706\">total=formdata['total'], status=status,</st> <st c=\"47746\">percentage=pct)</st> return True\n    except Exception as e:\n        print(e)\n    return False\n```", "```py\n<st c=\"48284\">@app.route('/exam/score', methods=['GET', 'POST'])</st>\n<st c=\"48335\">def record_score():</st> if request.method == 'GET': <st c=\"48384\">pids = list_pid()</st><st c=\"48401\">qids = list_qid()</st> return render_template( 'exam/add_patient_score_form.html', pids=pids, qids=qids), 200\n    else:\n        params = dict()\n        params['pid'] = int(request.form['pid'])\n        params['qid'] = int(request.form['qid'])\n        params['score'] = float(request.form['score'])\n        params['total'] = float(request.form['total']) <st c=\"48705\">result = record_patient_exam(params)</st> … … … … … … …\n        else:\n            return redirect('/exam/task/error')\n```", "```py\n from flask import Flask\nfrom converter.date_converter import DateConverter <st c=\"52322\">app = Flask(__name__, template_folder='pages')</st>\n<st c=\"52368\">app.url_map.converters['date'] = DateConverter</st> @app.route('/', methods = ['GET'])\ndef index():\n    return \"This is an online … counseling system (OPCS)\" <st c=\"52518\">import views.index</st>\n<st c=\"52536\">import views.certificates</st>\n<st c=\"52562\">import views.signup</st>\n<st c=\"52582\">import views.examination</st>\n<st c=\"52607\">import views.reports</st>\n<st c=\"52628\">import views.admin</st>\n<st c=\"52647\">import views.login</st>\n<st c=\"52666\">import views.profile</st> app.add_url_rule('/certificate/terminate/<string:counselor>/<date:effective_date>/<string:patient>', 'show_honor_dissmisal', views.certificates.show_honor_dissmisal) <st c=\"53086\">app</st> instance of the main module while the main module has the imports to the views declared at the beginning. This occurrence is called a circular dependency between two modules importing components from each other, which leads to some circular import issues. To avoid this problem with the main and view modules, the area below the Flask instantiation is where we place these view imports. The <st c=\"53481\">if</st> statement at the bottom of <st c=\"53511\">main.py</st>, on the other hand, verifies that only the main module can run the Flask server through the <st c=\"53611\">app.run()</st> command.\n\t\t\t<st c=\"53629\">The main module usually sets the configuration settings through its</st> `<st c=\"53698\">app</st>` <st c=\"53701\">instance to build the sessions and other context-based objects or integrate other custom components, such as the security and database modules.</st> <st c=\"53846\">But the ideal setup doesn’t recommend including them there; instead, you should place them separately from the code, say using a configuration file, to seamlessly manage the environment variables when configuration blunders arise, to avoid performance degradation or congestion when the Flask</st> `<st c=\"54139\">app</st>` <st c=\"54142\">instance has several variables to load at server startup, and to replicate and back up the environment settings with less effort during project migration</st> <st c=\"54297\">or replication.</st>\n\t\t\t<st c=\"54312\">Creating environment variables</st>\n\t\t\t<st c=\"54343\">Configuration variables will always be part of any project setup, and how the frameworks or platforms</st> <st c=\"54446\">manage them gives an impression of the kind of framework they are.</st> <st c=\"54513\">A good framework should be able to decouple both built-in and custom configuration variables from the implementation area while maintaining their easy access across the application.</st> <st c=\"54695\">It can support having a configuration file that can do</st> <st c=\"54750\">the following:</st>\n\n\t\t\t\t*   <st c=\"54764\">Contain the variables in a structured and</st> <st c=\"54807\">readable manner.</st>\n\t\t\t\t*   <st c=\"54823\">Easily integrate with</st> <st c=\"54846\">the application.</st>\n\t\t\t\t*   <st c=\"54862\">Allow comments to be part of</st> <st c=\"54892\">its content.</st>\n\t\t\t\t*   <st c=\"54904\">Work even when deployed to other servers</st> <st c=\"54946\">or containers.</st>\n\t\t\t\t*   <st c=\"54960\">Decouple the variables from the</st> <st c=\"54993\">implementation area.</st>\n\n\t\t\t<st c=\"55013\">Aside from the</st> `<st c=\"55029\">.env</st>` <st c=\"55033\">file, Flask can also support configuration files in JSON, Python, and</st> `<st c=\"55284\">config.json</st>` <st c=\"55295\">file, which contains the database and Flask development</st> <st c=\"55352\">environment settings:</st>\n\n```", "```py\n\n\t\t\t<st c=\"55527\">This next is a Python</st> `<st c=\"55550\">config.py</st>` <st c=\"55559\">file with the same variable settings</st> <st c=\"55597\">in</st> `<st c=\"55600\">config.json</st>`<st c=\"55611\">:</st>\n\n```", "```py\n\n\t\t\t<st c=\"55744\">The</st> `<st c=\"55749\">app</st>` <st c=\"55752\">instance has the</st> `<st c=\"55770\">config</st>` <st c=\"55776\">attribute with a</st> `<st c=\"55794\">from_file()</st>` <st c=\"55805\">method that can load the JSON  file, as shown in the</st> <st c=\"55858\">following snippet:</st>\n\n```", "```py\n\n\t\t\t<st c=\"55928\">On the other hand,</st> `<st c=\"55948\">config</st>` <st c=\"55954\">has a</st> `<st c=\"55961\">from_pyfile()</st>` <st c=\"55974\">method that can manage the Python config file when invoked, as shown in</st> <st c=\"56047\">this snippet:</st>\n\n```", "```py\n\n\t\t\t<st c=\"56098\">The recent addition to the supported type,</st> `<st c=\"56178\">toml</st>` <st c=\"56182\">extension module before</st> <st c=\"56206\">loading the</st> `<st c=\"56219\">.toml</st>` <st c=\"56224\">file into the platform.</st> <st c=\"56249\">After running the</st> `<st c=\"56267\">pip install toml</st>` <st c=\"56283\">command, the</st> `<st c=\"56297\">config</st>` <st c=\"56303\">attribute’s</st> `<st c=\"56316\">from_file()</st>` <st c=\"56327\">method can now load the following settings of the</st> `<st c=\"56378\">config.toml</st>` <st c=\"56389\">file:</st>\n\n```", "```py\n\n\t\t\t<st c=\"56526\">TOML, like JSON and Python, has data types.</st> <st c=\"56571\">It supports arrays and tables and has structural patterns that may seem more complex than the JSON and Python configuration syntax.</st> <st c=\"56703\">A TOML file will have the</st> `<st c=\"56729\">.</st>``<st c=\"56730\">toml</st>` <st c=\"56735\">extension.</st>\n\t\t\t<st c=\"56746\">When accessing variables from these file types, the Flask instance uses its</st> `<st c=\"56823\">config</st>` <st c=\"56829\">object to access each variable.</st> <st c=\"56862\">This can be seen in the following version of our</st> `<st c=\"56911\">db.py</st>` <st c=\"56916\">module for database connectivity, which uses the</st> `<st c=\"56966\">config.toml</st>` <st c=\"56977\">file:</st>\n\n```", "```py\n\n\t\t\t<st c=\"57390\">Summary</st>\n\t\t\t<st c=\"57398\">This chapter has presented the initial requirements to set up a development environment for a single-structured Flask project.</st> <st c=\"57526\">It provided the basic elements that are essential to creating a simple Flask prototype, such as the</st> `<st c=\"57626\">main.py</st>` <st c=\"57633\">module, routes, database connectivity, repository, services, and configuration files.</st> <st c=\"57720\">The nuts and bolts of every procedure in building every aspect of the project describe Flask as a web framework.</st> <st c=\"57833\">The many ways to store the configuration settings, the possibility of using custom decorators for database connectivity, and the many options to capture the form data are indicators of Flask being so flexible, extensible, handy, and Pythonic in many ways.</st> <st c=\"58089\">The next chapter will focus on the core components and advanced features that Flask can provide in building a more</st> <st c=\"58204\">scalable application.</st>\n\n```", "```py\n\n```", "```py\n\n```", "```py\n\n```", "```py\n\n```"]