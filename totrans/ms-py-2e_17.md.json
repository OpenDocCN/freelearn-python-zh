["```py\n$ xcode-select --install \n```", "```py\n$ /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" \n```", "```py\n$ brew doctor \n```", "```py\n$ brew install python3\n$ python3 --version\nPython 3.9.7\nwhich python3\n/usr/local/bin/python3 \n```", "```py\n$ sudo yum install yum-utils\n$ sudo yum-builddep python3 \n```", "```py\n$ sudo apt-get build-dep python3.10 \n```", "```py\n>>> import ctypes\n\n>>> ctypes.cdll\n<ctypes.LibraryLoader object at 0x...>\n>>> libc = ctypes.cdll.msvcrt\n>>> libc\n<CDLL 'msvcrt', handle ... at ...>\n>>> libc.printf\n<_FuncPtr object at 0x...> \n```", "```py\n>>> import ctypes\n\n>>> ctypes.cdll\n<ctypes.LibraryLoader object at 0x...>\n>>> libc = ctypes.cdll.LoadLibrary('libc.so.6')\n>>> libc\n<CDLL 'libc.so.6', handle ... at ...>\n>>> libc.printf\n<_FuncPtr object at 0x...> \n```", "```py\n>>> import ctypes\n>>> libc = ctypes.cdll.LoadLibrary('libc.dylib')\n>>> libc\n<CDLL 'libc.dylib', handle ... at 0x...>\n>>> libc.printf\n<_FuncPtr object at 0x...> \n```", "```py\n# OS X\n>>> from ctypes import util\n>>> from ctypes import cdll\n\n>>> library = util.find_library('libc')\n>>> library\n'/usr/lib/libc.dylib'\n\n# Load the library\n>>> libc = cdll.LoadLibrary(library)\n>>> libc\n<CDLL '/usr/lib/libc.dylib', handle ... at 0x...> \n```", "```py\n>>> c_string = ctypes.create_string_buffer(b'some bytes')\n>>> ctypes.sizeof(c_string)\n11\n>>> c_string.raw\nb'some bytes\\x00'\n>>> c_string.value\nb'some bytes'\n>>> libc.printf(c_string)\n10\nsome bytes>>> \n```", "```py\n>>> libc.printf(123)\nsegmentation fault (core dumped)  python3 \n```", "```py\n>>> format_string = b'Number: %d\\n'\n>>> libc.printf(format_string, 123)\nNumber: 123\n12\n\n>>> x = ctypes.c_int(123)\n>>> libc.printf(format_string, x)\nNumber: 123\n12 \n```", "```py\n>>> format_string = b'Number: %.3f\\n'\n>>> libc.printf(format_string, 123.45)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nctypes.ArgumentError: argument 2: <class 'TypeError'>: Don't know how to convert parameter 2\n\n>>> x = ctypes.c_double(123.45)\n>>> libc.printf(format_string, x)\nNumber: 123.450\n16 \n```", "```py\n>>> x = ctypes.c_double(123.45)\n>>> x.value\n123.45\n>>> x.value = 456\n>>> x\nc_double(456.0) \n```", "```py\n>>> from _libc import libc\n>>> import ctypes\n\n>>> class ComplexStructure(ctypes.Structure):\n...     _fields_ = [\n...         ('some_int', ctypes.c_int),\n...         ('some_double', ctypes.c_double),\n...         ('some_char', ctypes.c_char),\n...         ('some_string', ctypes.c_char_p),\n...     ]\n... \n>>> structure = ComplexStructure(123, 456.789, b'x', b'abc')\n>>> structure.some_int\n123\n>>> structure.some_double\n456.789\n>>> structure.some_char\nb'x'\n>>> structure.some_string\nb'abc' \n```", "```py\n>>> TenNumbers = 10 * ctypes.c_double\n>>> numbers = TenNumbers()\n>>> numbers[0]\n0.0 \n```", "```py\n>>> GrossComplexStructures = 144 * ComplexStructure \n>>> complex_structures = GrossComplexStructures()\n\n>>> complex_structures[10].some_double = 123\n>>> complex_structures[10]\n<__main__.ComplexStructure object at ...>\n>>> complex_structures\n<__main__.ComplexStructure_Array_144 object at ...> \n```", "```py\n>>> TenNumbers = 10 * ctypes.c_double\n>>> numbers = TenNumbers()\n\n>>> ctypes.resize(numbers, 11 * ctypes.sizeof(ctypes.c_double))\n>>> ctypes.resize(numbers, 10 * ctypes.sizeof(ctypes.c_double))\n>>> ctypes.resize(numbers, 9 * ctypes.sizeof(ctypes.c_double))\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: minimum size is 80\n\n>>> numbers[:5] = range(5)\n>>> numbers[:]\n[0.0, 1.0, 2.0, 3.0, 4.0, 0.0, 0.0, 0.0, 0.0, 0.0] \n```", "```py\n>>> import ctypes\n\n>>> class Point(ctypes.Structure):\n...     _fields_ = ('x', ctypes.c_int), ('y', ctypes.c_int)\n\n>>> class Vertex(ctypes.Structure):\n...     _fields_ = ('c', Point), ('d', Point)\n\n>>> a = Point(0, 1)\n>>> b = Point(2, 3)\n>>> a.x, a.y, b.x, b.y\n(0, 1, 2, 3)\n\n# Swap points a and b\n>>> a, b = b, a\n>>> a.x, a.y, b.x, b.y\n(2, 3, 0, 1)\n\n>>> v = Vertex()\n>>> v.c = Point(0, 1)\n>>> v.d = Point(2, 3)\n>>> v.c.x, v.c.y, v.d.x, v.d.y\n(0, 1, 2, 3)\n\n# Swap points c and d\n>>> v.c, v.d = v.d, v.c\n>>> v.c.x, v.c.y, v.d.x, v.d.y\n(2, 3, 2, 3) \n```", "```py\n>>> import cffi\n\n>>> ffi = cffi.FFI()\n>>> ffi.cdef('int printf(const char* format, ...);')\n>>> libc = ffi.dlopen(None)\n>>> arg = ffi.new('char[]', b'Printing using CFFI\\n')\n>>> libc.printf(arg)\n20\nPrinting using CFFI \n```", "```py\n>>> from ctypes import util\n>>> import cffi\n\n# Initialize the FFI builder\n>>> ffi = cffi.FFI()\n\n# Find the libc library on OS X. Look back at the ctypes examples\n# for other platforms.\n>>> library = util.find_library('libc.dylib')\n>>> library\n'/usr/lib/libc.dylib'\n\n# Load the library\n>>> libc = ffi.dlopen(library)\n>>> libc\n<cffi.api._make_ffi_library.<locals>.FFILibrary object at ...>\n\n# We do have printf available, but CFFI requires a signature\n>>> libc.printf\nTraceback (most recent call last):\n  ...\nAttributeError: printf\n\n# Define the printf signature and call printf\n>>> ffi.cdef('int printf(const char* format, ...);')\n>>> libc.printf\n<cdata 'int(*)(char*, ...)' ...> \n```", "```py\n>>> import cffi\n\n>>> ffi = cffi.FFI()\n\n# Create the structures as C structs\n>>> ffi.cdef('''\n... typedef struct {\n...     int x;\n...     int y;\n... } point;\n...\n... typedef struct {\n...     point a;\n...     point b;\n... } vertex;\n... ''')\n\n# Create a vertex and return the pointer\n>>> v = ffi.new('vertex*')\n\n# Set the data\n>>> v.a.x, v.a.y, v.b.x, v.b.y = (0, 1, 2, 3)\n\n# Print before change\n>>> v.a.x, v.a.y, v.b.x, v.b.y\n(0, 1, 2, 3)\n\n>>> v.a, v.b = v.b, v.a\n\n# Print after change\n>>> v.a.x, v.a.y, v.b.x, v.b.y\n(2, 3, 2, 3) \n```", "```py\nint a = 123; // Variable a contains integer 123\nint* b = &a; // Variable b contains the memory address of a\nint c = *b;  // Variable c contains 123, the value at memory address c \n```", "```py\n>>> import cffi\n\n>>> ffi = cffi.FFI()\n\n# Create arrays of size 10:\n>>> x = ffi.new('int[10]')\n>>> y = ffi.new('int[]', 10)\n\n>>> x\n<cdata 'int[10]' owning 40 bytes>\n>>> y\n<cdata 'int[]' owning 40 bytes>\n\n>>> x[0:10] = range(10)\n>>> list(x)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n>>> x[:] = range(10)\nTraceback (most recent call last):\n    ...\nIndexError: slice start must be specified\n\n>>> x[0:100] = range(100)\nTraceback (most recent call last):\n    ...\nIndexError: index too large (expected 100 <= 10) \n```", "```py\n>>> import cffi\n\n>>> ffi = cffi.FFI()\n\n# In API mode, we can in-line the actual C code\n>>> ffi.set_source('_sum', '''\n... int sum(int* input, int n){\n...     int result = 0;\n...     while(n--)result += input[n];\n...     return result;\n... }\n... ''')\n>>> ffi.cdef('int sum(int*, int);')\n\n>>> library = ffi.compile() \n```", "```py\n# Now we can import the library\n>>> import _sum\n\n# Or use 'ffi.dlopen()' with the results from the compile step\n>>> _sum_lib = ffi.dlopen(library)\n\n# Create an array with 5 items\n>>> N = 5\n>>> array = ffi.new('int[]', N)\n>>> array[0:N] = range(N)\n\n# Call our C function from either the import or the dlopen\n>>> _sum.lib.sum(array, N)\n10\n\n>>> _sum_lib.sum(array, N)\n10 \n```", "```py\nimport pathlib\nimport setuptools\n\n# Get the current directory\nPROJECT_PATH = pathlib.Path(__file__).parent\n\nsum_of_squares = setuptools.Extension('sum_of_squares', sources=[\n    # Get the relative path to sum_of_squares.c\n    str(PROJECT_PATH / 'sum_of_squares.c'),\n])\n\nif __name__ == '__main__':\n    setuptools.setup(\n        name='SumOfSquares',\n        version='1.0',\n        ext_modules=[sum_of_squares],\n    ) \n```", "```py\ndef sum_of_squares(n):\n    total = 0\n    for i in range(n):\n        if i * i < n:\n            total += i * i\n        else:\n            break\n\n    return total \n```", "```py\nlong sum_of_squares(long n){\n    long total = 0;\n    /* The actual summing code */\n    for(int i=0; i<n; i++){\n        if((i * i) < n){\n            total += i * i;\n        }else{\n            break;\n        }\n    }\n\n    return total;\n} \n```", "```py\n#include <Python.h>\n\nstatic PyObject* sum_of_squares(PyObject *self, PyObject\n        *args){\n    /* Declare the variables */\n    int n;\n    int total = 0;\n\n    /* Parse the arguments */\n    if(!PyArg_ParseTuple(args, \"i\", &n)){\n        return NULL;\n    }\n\n    /* The actual summing code */\n    for(int i=0; i<n; i++){\n        if((i * i) < n){\n            total += i * i;\n        }else{\n            break;\n        }\n    }\n\n    /* Return the number but convert it to a Python object first */\n    return PyLong_FromLong(total);\n}\n\nstatic PyMethodDef methods[] = {\n    /* Register the function */\n    {\"sum_of_squares\", sum_of_squares, METH_VARARGS,\n     \"Sum the perfect squares below n\"},\n    /* Indicate the end of the list */\n    {NULL, NULL, 0, NULL},\n};\n\nstatic struct PyModuleDef module = {\n    PyModuleDef_HEAD_INIT,\n    \"sum_of_squares\", /* Module name */\n    NULL, /* Module documentation */\n    -1, /* Module state, -1 means global. This parameter is\n           for sub-interpreters */\n    methods,\n};\n\n/* Initialize the module */\nPyMODINIT_FUNC PyInit_sum_of_squares(void){\n    return PyModule_Create(&module);\n} \n```", "```py\n$ python3 T_09_native/setup.py build install\nrunning build\nrunning build_ext\nbuilding 'sum_of_squares' extension ...\n...\nProcessing dependencies for SumOfSquares==1.0\nFinished processing dependencies for SumOfSquares==1.0 \n```", "```py\nimport sys\nimport timeit\nimport argparse\nimport functools\n\nfrom sum_of_squares_py import sum_of_squares as sum_py\n\ntry:\n    from sum_of_squares import sum_of_squares as sum_c\nexcept ImportError:\n    print('Please run \"python setup.py build install\" first')\n    sys.exit(1) \n```", "```py\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    parser.add_argument('repetitions', type=int)\n    parser.add_argument('maximum', type=int)\n    args = parser.parse_args()\n\n    timer = functools.partial(\n        timeit.timeit, number=args.repetitions, globals=globals())\n\n    print(f'Testing {args.repetitions} repetitions with maximum: '\n          f'{args.maximum}')\n\n    result = sum_c(args.maximum)\n    duration_c = timer('sum_c(args.maximum)')\n    print(f'C: {result} took {duration_c:.3f} seconds')\n\n    result = sum_py(args.maximum)\n    duration_py = timer('sum_py(args.maximum)')\n    print(f'Py: {result} took {duration_py:.3f} seconds')\n\n    print(f'C was {duration_py / duration_c:.1f} times faster') \n```", "```py\n$ python3 T_09_native/test.py 10000 1000000\nTesting 10000 repetitions with maximum: 1000000\nC: 332833500 took 0.009 seconds\nPy: 332833500 took 1.264 seconds\nC was 148.2 times faster \n```", "```py\n$ python3 T_09_native/test.py 1000 10000000\nTesting 1000 repetitions with maximum: 10000000\nC sum of squares: 1953214233 took 0.003 seconds\nPython sum of squares: 10543148825 took 0.407 seconds\nC was 145.6 times faster \n```", "```py\ntypedef unsigned long long int bigint;\n\nstatic PyObject* sum_of_large_squares(PyObject *self, PyObject *args){\n    /* Declare the variables */\n    bigint n;\n    bigint total = 0;\n\n    /* Parse the arguments */\n    if(!PyArg_ParseTuple(args, \"K\", &n)){\n        return NULL;\n    }\n\n    /* The actual summing code */\n    for(bigint i=0; i<n; i++){\n        if((i * i) < n){\n            total += i * i;\n        }else{\n            break;\n        }\n    }\n\n    /* Return the number but convert it to a Python object first */\n    return PyLong_FromUnsignedLongLong(total);\n} \n```", "```py\n$ python3 T_10_size_matters/test.py 1000 10000000\nTesting 1000 repetitions with maximum: 10000000\nC: 10543148825 took 0.001 seconds\nPy: 10543148825 took 0.405 seconds\nC was 270.3 times faster \n```", "```py\n$ python3 T_10_size_matters/test.py 1 100000000000000\nTesting 1 repetitions with maximum: 100000000000000\nC: 1291890006563070912 took 0.004 seconds\nPy: 333333283333335000000 took 1.270 seconds\nC was 293.7 times faster \n```", "```py\nstatic unsigned long long int get_number_from_object(int* overflow, \n        PyObject* some_very_large_number){\n    return PyLong_AsLongLongAndOverflow(sum, overflow);\n} \n```", "```py\nstatic PyObject* sum_of_squares(PyObject *self, PyObject *args); \n```", "```py\nif(!PyArg_ParseTuple(args, \"i\", &n)){\n    return NULL;\n} \n```", "```py\nPyObject* callback;\nint n;\n\n/* Parse the arguments */\nif(!PyArg_ParseTuple(args, \"Oi\", &callback, &n)){\n    return NULL;\n} \n```", "```py\nstatic PyObject* function(\n        PyObject *self,\n        PyObject *args,\n        PyObject *kwargs){\n    /* Declare the variables */\n    PyObject* callback;\n    int n;\n\n    static char* keywords[] = {\"callback\", \"n\", NULL};\n\n    /* Parse the arguments */\n    if(!PyArg_ParseTupleAndKeywords(args, kwargs, \"Oi\", keywords,\n                &callback, &n)){\n        return NULL;\n    }\n\n    Py_RETURN_NONE;\n}\n\nstatic PyMethodDef methods[] = {\n    /* Register the function with kwargs */\n    {\"function\", function, METH_VARARGS | METH_KEYWORDS,\n     \"Some kwargs function\"},\n    /* Indicate the end of the list */\n    {NULL, NULL, 0, NULL},\n}; \n```", "```py\n$ python3 -c '1/0'\nTraceback (most recent call last):\n  File \"<string>\", line 1, in <module>\nZeroDivisionError: division by zero \n```", "```py\nstatic PyObject* count_eggs(PyObject *self, PyObject *args){\n    PyErr_SetString(PyExc_RuntimeError, \"Too many eggs!\");\n    return NULL;\n} \n```", "```py\n#include <Python.h>\n\nstatic PyObject* custom_sum(PyObject* self, PyObject* args){\n    long long int total = 0;\n    int overflow = 0;\n    PyObject* iterator;\n    PyObject* iterable;\n    PyObject* callback = NULL;\n    PyObject* value;\n    PyObject* item; \n```", "```py\n if(!PyArg_ParseTuple(args, \"O|OL\", &iterable, &callback, &total)){\n        return NULL;\n    } \n```", "```py\n iterator = PyObject_GetIter(iterable);\n    if(iterator == NULL){\n        PyErr_SetString(PyExc_TypeError,\n                \"Argument is not iterable\");\n        return NULL;\n    } \n```", "```py\n if(callback != NULL && !PyCallable_Check(callback)){\n        PyErr_SetString(PyExc_TypeError, \"Callback is not callable\");\n        return NULL;\n    } \n```", "```py\n while((item = PyIter_Next(iterator))){\n        if(callback == NULL){\n            value = item;\n        }else{\n            value = PyObject_CallFunction(callback, \"O\", item);\n        } \n```", "```py\n total += PyLong_AsLongLongAndOverflow(value, &overflow);\n        if(overflow > 0){\n            PyErr_SetString(PyExc_RuntimeError, \"Integer overflow\");\n            return NULL;\n        }else if(overflow < 0){\n            PyErr_SetString(PyExc_RuntimeError, \"Integer underflow\");\n            return NULL;\n        } \n```", "```py\n if(callback != NULL){\n            Py_DECREF(value);\n        }\n        Py_DECREF(item);\n    }\n    Py_DECREF(iterator); \n```", "```py\n return PyLong_FromLongLong(total);\n} \n```", "```py\n>>> x = range(10)\n>>> custom_sum(x)\n45\n>>> custom_sum(x, lambda y: y + 5)\n95\n>>> custom_sum(x, lambda y: y + 5, 5)\n100 \n```", "```py\n>>> import spam\n\n>>> n = (2 ** 63) - 1\n>>> x = n,\n>>> spam.sum(x)\n9223372036854775807\n>>> x = n, n\n>>> spam.sum(x)\n-2 \n```"]