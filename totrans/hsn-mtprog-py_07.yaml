- en: '*Chapter 5*: Understanding Introspection'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at introspection in Python 3 and understand how
    it is useful in metaprogramming. **Introspection** is a concept where we can learn
    about the properties or attributes of objects in Python during runtime using a
    suite of Python’s built-in methods.
  prefs: []
  type: TYPE_NORMAL
- en: Why introspection? Introspection is an information-gathering process for Python
    objects, and the information thus gathered can help in utilizing the objects to
    perform generic operations by manipulating them externally and, in turn, can help
    us in writing metaprograms.
  prefs: []
  type: TYPE_NORMAL
- en: Before we understand how to implement introspection, we will have a look at
    the built-in functions of Python that help in performing introspection. Throughout
    this chapter, we will look at each function that helps us introspect and understand
    the objects we use in our programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be taking a look at the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing built-in functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the built-in `id` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging unintentional assignments using `id`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding out whether an object is callable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking whether an object has an attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking whether an object is an instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking whether an object is a subclass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the usage of property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using property as a decorator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to apply built-in functions to
    introspect Python objects, apply them to examples, and use them to debug code.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code examples shared in this chapter are available on GitHub under the
    code for this chapter here: [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter05](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing built-in functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand introspection and the usage of Python’s built-in functions to
    perform introspection, we will continue making use of our core example of *ABC
    Megamart* throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the usage of the following built-in functions to introspect
    Python objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eval()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callable()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hastattr()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getattr()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isinstance()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`issubclass()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`property()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introspecting Python objects helps in understanding the properties of objects,
    which in turn, helps in metaprogramming these objects and using them to debug
    the objects, which we will be looking at in further chapters as well.
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding, let’s look further into the concept of how to use these
    built-in functions and introspect objects.
  prefs: []
  type: TYPE_NORMAL
- en: Using the built-in id function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the characteristics of a Python object helps in writing metaprograms
    on the object. The memory address of an object is one of its characteristics or
    properties that can be manipulated using metaprogramming. The `id` function in
    Python 3 can be called to identify an object using the object’s memory address.
    Identifying an object through its memory address helps in analyzing objects to
    find out whether there are multiple assignments or copies of an object created
    unintentionally during the process of code development.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this further, here is how we will work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be creating a class named `Billing`, which calculates and prints a
    simple bill for any product that is provided as input. Refer to the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now create an object for the `Billing` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now call the `generate_bill` method to print the bill:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This code gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next step, let’s create a separate `generate_bill` function that performs
    the same set of operations as the `generate_bill` method that was created inside
    the `Billing` class. The function will take in four parameters (`product_name`,
    `unit_price`, `quantity`, and `tax`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the next step, we will be copying the `Billing` class into another variable
    named `Invoicing`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So far, we have three objects:'
  prefs: []
  type: TYPE_NORMAL
- en: A class named `Billing`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function named `generate_bill`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A variable that assigned the `Billing` class to a variable called `Invoicing`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s apply Python’s built-in `id` function to get the memory address
    of each of these objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding output, we can notice that both `Billing` and `Invoicing`
    have the same memory address since `Invoicing` is a copy of the `Billing` class.
    The following figure is a simple representation of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The Billing class copied to Invoicing ](img/Figure_5.1_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – The Billing class copied to Invoicing
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding, we can further look into how we can use the `id` function
    in implementing metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging unintentional assignments using id
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will be discussing what happens when we make unintentional
    references or assignments to an object while defining an attribute, a method,
    or a function, and how to resolve such incorrect assignments using the built-in
    `id` function. When a reference is made unintentionally, the memory address of
    the object is shared between the actual object and the reference object. In this
    example, we will be making use of `id` to debug the Python objects created in
    the preceding section and identify duplicate assignments or references of an object
    that might have been created unintentionally while developing an application.
    Here is how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, let’s create a dictionary item, `class_id_count`, to capture
    the number of occurrences of the memory address of each class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the next step, we will be creating the following four lists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we capture duplicate memory addresses with `duplicates`, capture results
    of the `id` function with `ids`, capture the class details with `classes`, and
    capture the names of classes with `classnames`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this step, we will be iterating over the directory of Python objects and
    checking whether the type of the object is `type` since the type of class is `type`
    in Python. This step helps in identifying all the objects that are classes and
    then updating the lists created with `ids`, `classes`, and `classnames`. Refer
    to the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now iterate over the `ids` list and check that the `id` is not in `class_id_count`,
    and then add it; if it is already in `class_id_count`, we will add it to the `duplicates`
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will further iterate over the `classes` and `classnames` lists and check
    whether there are duplicates. Then, we will print the classes that have duplicates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the preceding code results in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding output, we can see that both the `Billing` and `Invoicing`
    classes have the same memory address and they are duplicates. There can be scenarios
    where we might have intentionally referenced a class, and there can also be scenarios
    where multiple variable assignments to the same memory address might have happened
    by mistake. In such intentional scenarios, `id` can be used to check duplicate
    assignments to a memory address.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure is a simple representation of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Two classes with one memory address ](img/Figure_5.2_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Two classes with one memory address
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding, we will look further into another built-in function,
    `callable`.
  prefs: []
  type: TYPE_NORMAL
- en: Finding out whether an object is callable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at another built-in function named `callable`.
    As the name implies, this function helps in identifying whether a Python object
    can be called. Functions and methods can be called to enable various operations
    to be performed on the input parameters. Not all Python objects are callable.
    For example, a string variable or a numeric variable stores information but will
    not perform any action when executed. The `callable` function helps in verifying
    such objects that can be called and those that cannot be called in a function.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need to check whether an object is callable? Python is an object-oriented
    programming language where we can write libraries and write classes within the
    libraries that are encapsulated. The end user of classes or libraries need not
    always have access to the class definition or method definitions. While importing
    the Python libraries, we might sometimes want to know whether the imported object
    is just a variable that stores a value or whether it is a function that can be
    reused. The simplest way of checking this is to see whether the object is callable,
    as functions or methods are usually callable. This comes in handy, especially
    when the developer of a library did not provide any documentation for its methods
    and attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make use of `callable` in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new Python file and save it as `product.py`. Go to [https://github.com/PacktPublishing/Metaprogramming-with-Python/blob/main/Chapter05/product.py](https://github.com/PacktPublishing/Metaprogramming-with-Python/blob/main/Chapter05/product.py)
    and add the following code, which creates a class named `Product`. Add the following
    four attributes to it: `Product ID`, `Product Name`, `Product Category`, and `Unit
    Price`. We will now assign values to these four attributes, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s add a method named `get_product` within the `Product` class. This
    method would simply return the four attributes created in the preceding step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this step, we will import the `Product` class from `product.py` and create
    an object for it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now check whether the class is callable by using the built-in `callable`
    function. The class is callable and so the function returns `True`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this step, we can also check whether a class object is callable. The object
    is not callable since we did not overwrite the `__call__` method of the class
    to make it callable, and so the function returns `False`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now check whether a Python object is callable and then get its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, we can also check whether a Python object is callable and then print
    the details of the object if it returns `True`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this example, we can look further into the next function, `hasattr`.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether an object has an attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While using a method or a function object defined in a framework or library
    by importing the library into another program, we might not always know all the
    attributes of the object. In such cases, we have a built-in `hasattr` function
    that can be used to introspect if a Python object has a specific attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function checks whether a given object has attributes. To test this function,
    we will create a class for the inventory of *ABC Megamart*, add the required attributes
    for the products stored in the inventory, and also include the price of the products
    along with the tax component. The price will be calculated both before and after
    tax for the products stored in the inventory. The following are the steps for
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a class called `Inventory` and initiate it with the variables
    required for an inventory, such as `product_id`, `product_name`, `date` (of purchase),
    `unit_price`, `quantity`, `unit_discount`, and `tax`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this step, we will add a method to `Inventory` to calculate the amount before
    tax and, in this method, we will have three input parameters: `quantity`, `unit_price`,
    and `unit_discount`. If these three variables are `None`, then this method will
    use the same variables initiated during the instantiation of the `Inventory` class
    to calculate the amount before tax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also add another method to the `Inventory` class to calculate the amount
    after tax. This method is also defined in a similar pattern as `calc_amount_before_tax`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now create the last method for this class, which returns the consolidated
    inventory details, creates a DataFrame, and returns the DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create an object for the `Inventory` class and initialize its attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether the object returns the attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – The output – Inventory details  ](img/Figure_5.3_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – The output – Inventory details
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s make use of `dir` to list down all the names of arguments in the
    `Inventory` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s make use of `hasattr` to check whether the class has attributes.
    If the type of attribute is a method, then use `getattr` to get the attributes.
    Executing the following loop results in the list of all the attributes of `Inventory`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this understanding, we can further look into another built-in function,
    `isinstance`.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether an object is an instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at another function named `isinstance`, which
    can be used to check whether an object is an instance of a particular class. As
    we are covering introspection in this chapter, we are more focused on what functions
    are available to introspect an object rather than how these functions can be used
    further to manipulate or debug a piece of code. [*Chapter 6*](B13426_06_Final_PG_epub.xhtml#_idTextAnchor080),
    will cover the usage of these functions on metaprogramming along with examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding section, we created a class named `Inventory`. In this section,
    we can continue using the same class and create another object for the class.
    This is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The output – Inventory details of inventory_fmcg ](img/Figure_5.4_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – The output – Inventory details of inventory_fmcg
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s check whether `inventory_fmcg` is an object of the `Inventory` class
    using `isinstance`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can also check whether the previously created `inventory` object
    is still an instance of the `Inventory` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s consider a scenario where we have reallocated the object inventory to
    another value by mistake while writing the code, and we might still need to make
    use of the object and call its methods to return the inventory details. To test
    this scenario using `isinstance`, we can look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check whether an object is an instance of the `Inventory` class and call a
    method of the function. If the object is not an instance of the class, check the
    type of variable to which it has been reallocated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code results in the following output since `inventory` is still
    an object of the `Inventory` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.5 – The output – Inventory details ](img/Figure_5.5_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – The output – Inventory details
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s reallocate the `inventory` variable to some other string value and
    call the `return_inventory` method on it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calling the `return_inventory` method for the `inventory` object will result
    in the following error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Error on calling the return_inventory method on a reallocated
    object ](img/Figure_5.6_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Error on calling the return_inventory method on a reallocated object
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid the preceding error and to let the code handle this error gracefully
    and, at the same time, provide more information to the developer, we can modify
    the code as follows using the `isinstance` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: With this understanding, we can look further into another in-built function,
    `issubclass`.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether an object is a subclass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at the `issubclass` function. This function is
    used to check whether a given input class is actually a child class or a subclass
    of a specific parent class. To introspect a class using this function, let’s look
    at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `FMCG` class by initializing variables for supplier information such
    as `supplier_name`, `supplier_code`, `supplier_address`, `supplier_contract_start_date`,
    `supplier_contract_end_date`, and `supplier_quality_code`, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a method in the class to simply get the supplier details initialized in
    the class and return it as a dictionary object with a key and a value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an object for the `FMCG` class and initialize the variables with supplier
    data and then display the supplier details by calling the preceding method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we can then create another class for condiments that covers both inventory
    details and FMCG supplier details by inheriting this class from both the `FMCG`
    class and the `Inventory` class. This class will be initialized with all the product-level
    inventory variables and the supplier-level variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let’s add a method to simply return all the variables initialized in
    the `Condiments` class by storing them as a DataFrame or table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now create an object for this class and call its method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Executing the preceding code results in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.7 – The output – Condiment inventory details ](img/Figure_5.7_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – The output – Condiment inventory details
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s check whether the `FMCG` class is a subclass of `Inventory`. It will
    return as `False` since FMCG is not a subclass of `Inventory`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this step, we will check whether `Condiments` is a subclass of `FMCG` and
    also whether it is a subclass of `Inventory`. Both should return as `True` since
    `Condiments` is inherited from both of these classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will be creating an object for a class by, first, checking whether
    a class is a subclass of a specific parent class, then creating an object accordingly,
    and then calling a method on the newly created object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Executing the preceding code results in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this understanding, we can look further into the last topic of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the usage of property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at the last built-in function covered in this
    chapter, `property`. This function is used to initialize, set, get, or delete
    methods of attributes in Python. These values are called the properties of an
    object. Let’s first understand how `property` works on Python objects by creating
    an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a property by simply calling the `property` function and storing
    it as a variable. Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We still did not answer the question of how this function creates a property.
    The `property` function takes in four variables to get, set, delete, and document
    the properties of an attribute. To examine it further, let’s look at it in a little
    more detail. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `TestPropertyClass`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize it with a `test` attribute and set it as `None`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will then add three methods to perform the functions of getting, setting,
    and deleting the initialized `test` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will then create another variable within the class named `test_attr` and
    assign the `property` function to it with the `get`, `set`, and `delete` methods
    created in this class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code for this example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `get_test_attr` simply returns the `test` attribute,
    `set_test_attr` sets a value to the `test` attribute, and `del_test_attr` deletes
    the `test` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now create an object for this class and check how `property` works on
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, calling the `test` attribute has, in turn, invoked the
    `get_test_attr` method since it is provided as the `get` method to the `property`
    function. Let’s confirm this understanding further by setting a value to `test_attr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Assigning a value to the `test_attr` variable has now invoked the `set_test_attr`
    method since it is provided as a `set` method to the `property` function. Calling
    the `test_attr` attribute again returns the value set in the preceding step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, deleting the attribute, in turn, invokes the `del_test_attr` method
    since it is provided as a `delete` method to the `property` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the attribute is deleted, the `get` method will still be invoked while
    calling the attribute, but it will not return the value previously assigned since
    it is deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code would now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – The get method invoked on a deleted attribute ](img/Figure_5.8_B13426.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – The get method invoked on a deleted attribute
  prefs: []
  type: TYPE_NORMAL
- en: By modifying the behavior of the `getter`, `setter`, or `deleter` methods, we
    can modify the properties of the attribute itself. We will look at this statement
    in detail in [*Chapter 6*](B13426_06_Final_PG_epub.xhtml#_idTextAnchor080).
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding of assigning the `property` function to a variable and
    then invoking its `getter`, `setter`, and `deleter` methods, we will further look
    into another variation of implementing `property`.
  prefs: []
  type: TYPE_NORMAL
- en: Using property as a decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding section, we looked at how to use `property` as a function
    to modify the properties of an attribute in a class. In this section, we will
    look at how to use `property` as a decorator. Let’s consider the same `TestPropertyClass`
    as in the preceding example and modify the class definition to use the `@property`
    decorator statement instead of the `property()` function statement. Refer to the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have added `@property` as the decorator for `test_attr`,
    and we have also added `@test_attr.setter` for the `set` method, `@test_attr.getter`
    for the `get` method, and `@test_attr.deleter` for the `delete` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s proceed with executing the code further to check whether `getter`, `setter`,
    and `deleter` are working as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, calling the attribute invoked the `getter` method. Similarly,
    `setter` and `deleter` also invoked the `set` and `delete` methods, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: These are some of the examples of how introspection can be applied to Python
    objects using Python’s built-in functions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to introspect Python objects using built-in
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: We then saw how to use the `id` function, and how to debug code using `id`.
    We also looked at how to check whether an object is callable, how to check whether
    an object has an attribute, how to check whether an object is an instance, how
    to check whether an object is a subclass, and finally, we looked at how to get,
    set, and delete properties on attributes. From all of these concepts, we learned
    how to inspect Python objects such as classes, methods, and functions. From the
    examples covered under each topic, we also learned how to apply introspection
    in practical use cases.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be extending the learning from introspection and
    applying it further to understand reflection on Python objects.
  prefs: []
  type: TYPE_NORMAL
