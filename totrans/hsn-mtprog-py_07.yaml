- en: '*Chapter 5*: Understanding Introspection'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：理解内省'
- en: In this chapter, we will look at introspection in Python 3 and understand how
    it is useful in metaprogramming. **Introspection** is a concept where we can learn
    about the properties or attributes of objects in Python during runtime using a
    suite of Python’s built-in methods.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Python 3中的内省，并了解它在元编程中的有用性。**内省**是一个概念，我们可以在Python运行时使用一系列Python内置方法来了解对象的属性或属性。
- en: Why introspection? Introspection is an information-gathering process for Python
    objects, and the information thus gathered can help in utilizing the objects to
    perform generic operations by manipulating them externally and, in turn, can help
    us in writing metaprograms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要内省？内省是针对Python对象的信息收集过程，收集到的信息可以帮助我们通过外部操作来利用对象执行通用操作，从而有助于我们编写元程序。
- en: Before we understand how to implement introspection, we will have a look at
    the built-in functions of Python that help in performing introspection. Throughout
    this chapter, we will look at each function that helps us introspect and understand
    the objects we use in our programs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们理解如何实现内省之前，我们将查看Python中帮助执行内省的内置函数。在本章中，我们将查看每个帮助我们内省并理解我们在程序中使用对象的函数。
- en: 'In this chapter, we will be taking a look at the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主要主题：
- en: Introducing built-in functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍内置函数
- en: Using the built-in `id` function
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置的`id`函数
- en: Debugging unintentional assignments using `id`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`id`调试意外的赋值
- en: Finding out whether an object is callable
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查对象是否可调用
- en: Checking whether an object has an attribute
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查对象是否有属性
- en: Checking whether an object is an instance
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查对象是否为实例
- en: Checking whether an object is a subclass
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查对象是否为子类
- en: Understanding the usage of property
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解属性的使用
- en: Using property as a decorator
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将属性用作装饰器
- en: By the end of this chapter, you should be able to apply built-in functions to
    introspect Python objects, apply them to examples, and use them to debug code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够应用内置函数来内省Python对象，将它们应用于示例，并使用它们来调试代码。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code examples shared in this chapter are available on GitHub under the
    code for this chapter here: [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter05](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter05).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中分享的代码示例可在GitHub上找到，具体位置为[https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter05](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter05)。
- en: Introducing built-in functions
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍内置函数
- en: To understand introspection and the usage of Python’s built-in functions to
    perform introspection, we will continue making use of our core example of *ABC
    Megamart* throughout this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解内省以及如何使用Python的内置函数进行内省，我们将继续在本章中使用我们的核心示例*ABC Megamart*。
- en: 'We will be covering the usage of the following built-in functions to introspect
    Python objects:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍以下内置函数的用法，以用于内省Python对象：
- en: '`id()`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id()`'
- en: '`eval()`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eval()`'
- en: '`callable()`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callable()`'
- en: '`hastattr()`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hastattr()`'
- en: '`getattr()`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getattr()`'
- en: '`isinstance()`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isinstance()`'
- en: '`issubclass()`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`issubclass()`'
- en: '`property()`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`property()`'
- en: Introspecting Python objects helps in understanding the properties of objects,
    which in turn, helps in metaprogramming these objects and using them to debug
    the objects, which we will be looking at in further chapters as well.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 内省Python对象有助于理解对象的属性，这反过来又有助于对这些对象进行元编程，并使用它们来调试对象，我们将在后续章节中进一步探讨。
- en: With this understanding, let’s look further into the concept of how to use these
    built-in functions and introspect objects.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种理解，让我们进一步探讨如何使用这些内置函数以及如何内省对象。
- en: Using the built-in id function
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内置的`id`函数
- en: Understanding the characteristics of a Python object helps in writing metaprograms
    on the object. The memory address of an object is one of its characteristics or
    properties that can be manipulated using metaprogramming. The `id` function in
    Python 3 can be called to identify an object using the object’s memory address.
    Identifying an object through its memory address helps in analyzing objects to
    find out whether there are multiple assignments or copies of an object created
    unintentionally during the process of code development.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 Python 对象的特征有助于编写针对该对象的元程序。对象的内存地址是其特征或属性之一，可以使用元编程进行操作。Python 3 中的 `id`
    函数可以调用以使用对象的内存地址来识别对象。通过对象的内存地址来识别对象有助于分析对象，以找出在代码开发过程中是否无意中创建了多个对象的赋值或副本。
- en: 'To understand this further, here is how we will work:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步理解，以下是我们的工作方式：
- en: 'We will be creating a class named `Billing`, which calculates and prints a
    simple bill for any product that is provided as input. Refer to the following
    code:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `Billing` 的类，该类计算并打印任何作为输入提供的产品的简单账单。请参阅以下代码：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s now create an object for the `Billing` class:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为 `Billing` 类创建一个对象：
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s now call the `generate_bill` method to print the bill:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们调用 `generate_bill` 方法来打印账单：
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code gives the following output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将产生以下输出：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the next step, let’s create a separate `generate_bill` function that performs
    the same set of operations as the `generate_bill` method that was created inside
    the `Billing` class. The function will take in four parameters (`product_name`,
    `unit_price`, `quantity`, and `tax`):'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，让我们创建一个单独的 `generate_bill` 函数，该函数执行与 `Billing` 类内部创建的 `generate_bill`
    方法相同的操作集。该函数将接受四个参数（`product_name`、`unit_price`、`quantity` 和 `tax`）：
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the next step, we will be copying the `Billing` class into another variable
    named `Invoicing`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，我们将把 `Billing` 类复制到另一个名为 `Invoicing` 的变量中：
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'So far, we have three objects:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有三个对象：
- en: A class named `Billing`
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `Billing` 的类
- en: A function named `generate_bill`
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `generate_bill` 的函数
- en: A variable that assigned the `Billing` class to a variable called `Invoicing`
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `Billing` 类赋值给名为 `Invoicing` 的变量的变量
- en: 'Now, let’s apply Python’s built-in `id` function to get the memory address
    of each of these objects:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用 Python 的内置 `id` 函数来获取这些对象的内存地址：
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding output, we can notice that both `Billing` and `Invoicing`
    have the same memory address since `Invoicing` is a copy of the `Billing` class.
    The following figure is a simple representation of this example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以注意到 `Billing` 和 `Invoicing` 具有相同的内存地址，因为 `Invoicing` 是 `Billing`
    类的副本。以下图是此例的简单表示：
- en: '![Figure 5.1 – The Billing class copied to Invoicing ](img/Figure_5.1_B13426.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 将 Billing 类复制到 Invoicing](img/Figure_5.1_B13426.jpg)'
- en: Figure 5.1 – The Billing class copied to Invoicing
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 将 Billing 类复制到 Invoicing
- en: With this understanding, we can further look into how we can use the `id` function
    in implementing metaprogramming.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种理解，我们可以进一步探讨如何在实现元编程时使用 `id` 函数。
- en: Debugging unintentional assignments using id
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 id 调试无意中的赋值
- en: 'In this section, we will be discussing what happens when we make unintentional
    references or assignments to an object while defining an attribute, a method,
    or a function, and how to resolve such incorrect assignments using the built-in
    `id` function. When a reference is made unintentionally, the memory address of
    the object is shared between the actual object and the reference object. In this
    example, we will be making use of `id` to debug the Python objects created in
    the preceding section and identify duplicate assignments or references of an object
    that might have been created unintentionally while developing an application.
    Here is how it works:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论当我们定义属性、方法或函数时对对象进行无意引用或赋值会发生什么，以及如何使用内置的 `id` 函数解决此类错误赋值。当无意中创建引用时，实际对象和引用对象的内存地址是共享的。在本例中，我们将使用
    `id` 来调试前面章节中创建的 Python 对象，并识别在开发应用程序时可能无意中创建的对象的重复赋值或引用。以下是它是如何工作的：
- en: 'To begin with, let’s create a dictionary item, `class_id_count`, to capture
    the number of occurrences of the memory address of each class:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个字典项，`class_id_count`，以捕获每个类内存地址出现的次数：
- en: '[PRE7]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the next step, we will be creating the following four lists:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，我们将创建以下四个列表：
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we capture duplicate memory addresses with `duplicates`, capture results
    of the `id` function with `ids`, capture the class details with `classes`, and
    capture the names of classes with `classnames`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `duplicates` 捕获重复的内存地址，使用 `ids` 捕获 `id` 函数的结果，使用 `classes` 捕获类详细信息，使用
    `classnames` 捕获类的名称。
- en: 'In this step, we will be iterating over the directory of Python objects and
    checking whether the type of the object is `type` since the type of class is `type`
    in Python. This step helps in identifying all the objects that are classes and
    then updating the lists created with `ids`, `classes`, and `classnames`. Refer
    to the following code block:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此步骤中，我们将遍历 Python 对象的目录，并检查对象的类型是否为 `type`，因为在 Python 中类的类型是 `type`。这一步骤有助于识别所有类对象，然后使用
    `ids`、`classes` 和 `classnames` 创建的列表进行更新。请参考以下代码块：
- en: '[PRE9]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will now iterate over the `ids` list and check that the `id` is not in `class_id_count`,
    and then add it; if it is already in `class_id_count`, we will add it to the `duplicates`
    list:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将遍历 `ids` 列表，检查 `id` 是否不在 `class_id_count` 中，然后添加它；如果它已经在 `class_id_count`
    中，我们将将其添加到 `duplicates` 列表中：
- en: '[PRE10]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will further iterate over the `classes` and `classnames` lists and check
    whether there are duplicates. Then, we will print the classes that have duplicates:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将进一步遍历 `classes` 和 `classnames` 列表，检查是否存在重复项。然后，我们将打印出具有重复项的类：
- en: '[PRE11]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Executing the preceding code results in the following output:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行前面的代码会产生以下输出：
- en: '[PRE13]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding output, we can see that both the `Billing` and `Invoicing`
    classes have the same memory address and they are duplicates. There can be scenarios
    where we might have intentionally referenced a class, and there can also be scenarios
    where multiple variable assignments to the same memory address might have happened
    by mistake. In such intentional scenarios, `id` can be used to check duplicate
    assignments to a memory address.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到 `Billing` 和 `Invoicing` 两个类具有相同的内存地址，它们是重复的。可能存在我们有意引用一个类的情况，也可能存在由于错误地将多个变量分配到同一内存地址而导致的场景。在这种情况下，可以使用
    `id` 来检查对内存地址的重复分配。
- en: 'The following figure is a simple representation of this example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下图是本例的简单表示：
- en: '![Figure 5.2 – Two classes with one memory address ](img/Figure_5.2_B13426.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 具有单个内存地址的两个类](img/Figure_5.2_B13426.jpg)'
- en: Figure 5.2 – Two classes with one memory address
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 具有单个内存地址的两个类
- en: With this understanding, we will look further into another built-in function,
    `callable`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种理解，我们将进一步探讨另一个内置函数，`callable`。
- en: Finding out whether an object is callable
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找对象是否可调用
- en: In this section, we will look at another built-in function named `callable`.
    As the name implies, this function helps in identifying whether a Python object
    can be called. Functions and methods can be called to enable various operations
    to be performed on the input parameters. Not all Python objects are callable.
    For example, a string variable or a numeric variable stores information but will
    not perform any action when executed. The `callable` function helps in verifying
    such objects that can be called and those that cannot be called in a function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨另一个内置函数，名为 `callable`。正如其名所示，此函数有助于识别 Python 对象是否可被调用。函数和方法可以被调用以执行对输入参数的各种操作。并非所有
    Python 对象都是可调用的。例如，字符串变量或数值变量存储信息，但在执行时不会执行任何操作。`callable` 函数有助于验证哪些对象可以被调用，哪些不能在函数中被调用。
- en: Why do we need to check whether an object is callable? Python is an object-oriented
    programming language where we can write libraries and write classes within the
    libraries that are encapsulated. The end user of classes or libraries need not
    always have access to the class definition or method definitions. While importing
    the Python libraries, we might sometimes want to know whether the imported object
    is just a variable that stores a value or whether it is a function that can be
    reused. The simplest way of checking this is to see whether the object is callable,
    as functions or methods are usually callable. This comes in handy, especially
    when the developer of a library did not provide any documentation for its methods
    and attributes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要检查一个对象是否可调用？Python是一种面向对象的编程语言，在其中我们可以在库中编写类，这些类被封装起来。类的最终用户或库的用户不一定总是需要访问类定义或方法定义。在导入Python库时，我们有时可能想知道导入的对象只是一个存储值的变量，还是一个可以被重用的函数。检查这一点最简单的方法是看对象是否可调用，因为函数或方法通常是可调用的。这在某些情况下非常有用，尤其是当库的开发者没有为其方法和属性提供任何文档时。
- en: 'Let’s make use of `callable` in the following example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以下面的例子来使用`callable`：
- en: 'Let’s create a new Python file and save it as `product.py`. Go to [https://github.com/PacktPublishing/Metaprogramming-with-Python/blob/main/Chapter05/product.py](https://github.com/PacktPublishing/Metaprogramming-with-Python/blob/main/Chapter05/product.py)
    and add the following code, which creates a class named `Product`. Add the following
    four attributes to it: `Product ID`, `Product Name`, `Product Category`, and `Unit
    Price`. We will now assign values to these four attributes, as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的Python文件，并将其保存为`product.py`。转到[https://github.com/PacktPublishing/Metaprogramming-with-Python/blob/main/Chapter05/product.py](https://github.com/PacktPublishing/Metaprogramming-with-Python/blob/main/Chapter05/product.py)并添加以下代码，该代码创建一个名为`Product`的类。向其中添加以下四个属性：`Product
    ID`（产品ID）、`Product Name`（产品名称）、`Product Category`（产品类别）和`Unit Price`（单价）。我们现在将为这四个属性分配值，如下所示：
- en: '[PRE14]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let’s add a method named `get_product` within the `Product` class. This
    method would simply return the four attributes created in the preceding step:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`Product`类中添加一个名为`get_product`的方法。这个方法将简单地返回前面步骤中创建的四个属性：
- en: '[PRE15]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this step, we will import the `Product` class from `product.py` and create
    an object for it:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们将从`product.py`导入`Product`类并为其创建一个对象：
- en: '[PRE16]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s now check whether the class is callable by using the built-in `callable`
    function. The class is callable and so the function returns `True`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在使用内置的`callable`函数来检查类是否可调用。该类是可调用的，因此函数返回`True`：
- en: '[PRE17]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this step, we can also check whether a class object is callable. The object
    is not callable since we did not overwrite the `__call__` method of the class
    to make it callable, and so the function returns `False`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们还可以检查类对象是否可调用。该对象不可调用，因为我们没有重写类的`__call__`方法使其可调用，因此函数返回`False`：
- en: '[PRE18]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can now check whether a Python object is callable and then get its attributes:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以检查一个Python对象是否可调用，然后获取其属性：
- en: '[PRE19]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Similarly, we can also check whether a Python object is callable and then print
    the details of the object if it returns `True`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们也可以检查一个Python对象是否可调用，如果返回`True`，则打印该对象详情：
- en: '[PRE20]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With this example, we can look further into the next function, `hasattr`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，我们可以进一步了解下一个函数，`hasattr`。
- en: Checking whether an object has an attribute
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查对象是否有属性
- en: While using a method or a function object defined in a framework or library
    by importing the library into another program, we might not always know all the
    attributes of the object. In such cases, we have a built-in `hasattr` function
    that can be used to introspect if a Python object has a specific attribute.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过将库导入另一个程序中来使用框架或库中定义的方法或函数对象时，我们可能并不总是知道对象的所有属性。在这种情况下，我们有一个内置的`hasattr`函数，可以用来检查Python对象是否有特定的属性。
- en: 'This function checks whether a given object has attributes. To test this function,
    we will create a class for the inventory of *ABC Megamart*, add the required attributes
    for the products stored in the inventory, and also include the price of the products
    along with the tax component. The price will be calculated both before and after
    tax for the products stored in the inventory. The following are the steps for
    it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数检查给定对象是否有属性。为了测试这个函数，我们将为*ABC Megamart*的库存创建一个类，为库存中存储的产品添加所需的属性，包括产品的价格和税费成分。库存中的产品的价格将在税前和税后计算。以下是步骤：
- en: 'We will create a class called `Inventory` and initiate it with the variables
    required for an inventory, such as `product_id`, `product_name`, `date` (of purchase),
    `unit_price`, `quantity`, `unit_discount`, and `tax`, as shown in the following
    code:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`Inventory`的类，并用库存所需的变量来初始化它，例如`product_id`（产品ID）、`product_name`（产品名称）、`date`（购买日期）、`unit_price`（单价）、`quantity`（数量）、`unit_discount`（折扣）和`tax`（税），如下面的代码所示：
- en: '[PRE21]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this step, we will add a method to `Inventory` to calculate the amount before
    tax and, in this method, we will have three input parameters: `quantity`, `unit_price`,
    and `unit_discount`. If these three variables are `None`, then this method will
    use the same variables initiated during the instantiation of the `Inventory` class
    to calculate the amount before tax:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步中，我们将向`Inventory`类添加一个方法来计算不含税金额，在这个方法中，我们将有三个输入参数：`quantity`（数量）、`unit_price`（单价）和`unit_discount`（折扣）。如果这三个变量都是`None`，则此方法将使用在`Inventory`类实例化期间初始化的相同变量来计算不含税金额：
- en: '[PRE22]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will also add another method to the `Inventory` class to calculate the amount
    after tax. This method is also defined in a similar pattern as `calc_amount_before_tax`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将为`Inventory`类添加另一个方法来计算含税金额。此方法与`calc_amount_before_tax`定义的格式类似：
- en: '[PRE23]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will now create the last method for this class, which returns the consolidated
    inventory details, creates a DataFrame, and returns the DataFrame:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将为这个类创建最后一个方法，该方法返回合并的库存详情，创建一个DataFrame，并返回该DataFrame：
- en: '[PRE24]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, create an object for the `Inventory` class and initialize its attributes:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为`Inventory`类创建一个对象并初始化其属性：
- en: '[PRE25]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Check whether the object returns the attributes:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查对象是否返回属性：
- en: '[PRE26]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '![Figure 5.3 – The output – Inventory details  ](img/Figure_5.3_B13426.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – 输出 – 库存详情](img/Figure_5.3_B13426.jpg)'
- en: Figure 5.3 – The output – Inventory details
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 输出 – 库存详情
- en: 'Next, let’s make use of `dir` to list down all the names of arguments in the
    `Inventory` class:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用`dir`列出`Inventory`类中所有参数的名称：
- en: '[PRE27]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let’s make use of `hasattr` to check whether the class has attributes.
    If the type of attribute is a method, then use `getattr` to get the attributes.
    Executing the following loop results in the list of all the attributes of `Inventory`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用`hasattr`来检查类是否有属性。如果属性的类型是方法，则使用`getattr`来获取属性。执行以下循环将得到`Inventory`的所有属性列表：
- en: '[PRE28]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With this understanding, we can further look into another built-in function,
    `isinstance`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种理解，我们可以进一步了解另一个内置函数，`isinstance`。
- en: Checking whether an object is an instance
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查对象是否是实例
- en: In this section, we will look at another function named `isinstance`, which
    can be used to check whether an object is an instance of a particular class. As
    we are covering introspection in this chapter, we are more focused on what functions
    are available to introspect an object rather than how these functions can be used
    further to manipulate or debug a piece of code. [*Chapter 6*](B13426_06_Final_PG_epub.xhtml#_idTextAnchor080),
    will cover the usage of these functions on metaprogramming along with examples.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨另一个名为`isinstance`的函数，它可以用来检查一个对象是否是特定类的实例。由于我们在本章中讨论的是内省，我们更关注可用于内省对象的函数，而不是如何进一步使用这些函数来操作或调试代码。[*第6章*](B13426_06_Final_PG_epub.xhtml#_idTextAnchor080)将涵盖这些函数在元编程中的使用，并附带示例。
- en: 'In the preceding section, we created a class named `Inventory`. In this section,
    we can continue using the same class and create another object for the class.
    This is shown as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们创建了一个名为`Inventory`的类。在本节中，我们可以继续使用相同的类并为该类创建另一个对象。如下所示：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '![Figure 5.4 – The output – Inventory details of inventory_fmcg ](img/Figure_5.4_B13426.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – 输出 – `inventory_fmcg`的库存详情](img/Figure_5.4_B13426.jpg)'
- en: Figure 5.4 – The output – Inventory details of inventory_fmcg
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 输出 – `inventory_fmcg`的库存详情
- en: 'Now, let’s check whether `inventory_fmcg` is an object of the `Inventory` class
    using `isinstance`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`isinstance`检查`inventory_fmcg`是否是`Inventory`类的对象：
- en: '[PRE43]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Similarly, we can also check whether the previously created `inventory` object
    is still an instance of the `Inventory` class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们也可以检查之前创建的`inventory`对象是否仍然是`Inventory`类的实例：
- en: '[PRE44]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let’s consider a scenario where we have reallocated the object inventory to
    another value by mistake while writing the code, and we might still need to make
    use of the object and call its methods to return the inventory details. To test
    this scenario using `isinstance`, we can look at the following steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个场景，在编写代码时错误地将对象库存重新分配给另一个值，我们可能仍然需要使用该对象并调用其方法来返回库存详情。为了使用`isinstance`测试这个场景，我们可以查看以下步骤：
- en: 'Check whether an object is an instance of the `Inventory` class and call a
    method of the function. If the object is not an instance of the class, check the
    type of variable to which it has been reallocated:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查一个对象是否是`Inventory`类的实例，并调用该函数的方法。如果对象不是类的实例，检查它被重新分配到的变量类型：
- en: '[PRE45]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The preceding code results in the following output since `inventory` is still
    an object of the `Inventory` class:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`inventory`仍然是`Inventory`类的对象，前面的代码会产生以下输出：
- en: '![Figure 5.5 – The output – Inventory details ](img/Figure_5.5_B13426.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5 – 输出 – 库存详情](img/Figure_5.5_B13426.jpg)'
- en: Figure 5.5 – The output – Inventory details
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 输出 – 库存详情
- en: 'Now, let’s reallocate the `inventory` variable to some other string value and
    call the `return_inventory` method on it:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将`inventory`变量重新分配给某个其他的字符串值，并在其上调用`return_inventory`方法：
- en: '[PRE46]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Calling the `return_inventory` method for the `inventory` object will result
    in the following error:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`inventory`对象的`return_inventory`方法将产生以下错误：
- en: '![Figure 5.6 – Error on calling the return_inventory method on a reallocated
    object ](img/Figure_5.6_B13426.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图5.6 – 在重新分配的对象上调用return_inventory方法时的错误](img/Figure_5.6_B13426.jpg)'
- en: Figure 5.6 – Error on calling the return_inventory method on a reallocated object
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – 在重新分配的对象上调用return_inventory方法时的错误
- en: 'To avoid the preceding error and to let the code handle this error gracefully
    and, at the same time, provide more information to the developer, we can modify
    the code as follows using the `isinstance` method:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免前面的错误，并让代码优雅地处理这个错误，同时向开发者提供更多信息，我们可以使用`isinstance`方法修改代码如下：
- en: '[PRE47]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE48]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: With this understanding, we can look further into another in-built function,
    `issubclass`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种理解，我们可以进一步了解另一个内置函数`issubclass`。
- en: Checking whether an object is a subclass
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查一个对象是否是子类
- en: 'In this section, we will look at the `issubclass` function. This function is
    used to check whether a given input class is actually a child class or a subclass
    of a specific parent class. To introspect a class using this function, let’s look
    at the following steps:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看`issubclass`函数。此函数用于检查给定的输入类是否实际上是特定父类的子类或子类。要使用此函数进行类内省，让我们查看以下步骤：
- en: 'Create an `FMCG` class by initializing variables for supplier information such
    as `supplier_name`, `supplier_code`, `supplier_address`, `supplier_contract_start_date`,
    `supplier_contract_end_date`, and `supplier_quality_code`, shown as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过初始化供应商信息变量（如`supplier_name`、`supplier_code`、`supplier_address`、`supplier_contract_start_date`、`supplier_contract_end_date`和`supplier_quality_code`）创建一个`FMCG`类，如下所示：
- en: '[PRE49]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Add a method in the class to simply get the supplier details initialized in
    the class and return it as a dictionary object with a key and a value:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加一个方法，简单地获取类中初始化的供应商详情，并将其作为包含键和值的字典对象返回：
- en: '[PRE50]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create an object for the `FMCG` class and initialize the variables with supplier
    data and then display the supplier details by calling the preceding method:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`FMCG`类的对象，用供应商数据初始化变量，然后通过调用前面的方法显示供应商详情：
- en: '[PRE51]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here, we can then create another class for condiments that covers both inventory
    details and FMCG supplier details by inheriting this class from both the `FMCG`
    class and the `Inventory` class. This class will be initialized with all the product-level
    inventory variables and the supplier-level variables:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以创建另一个用于香料的类，该类通过从`FMCG`类和`Inventory`类继承来覆盖库存详情和FMCG供应商详情。这个类将初始化所有产品级别的库存变量和供应商级别的变量：
- en: '[PRE52]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, let’s add a method to simply return all the variables initialized in
    the `Condiments` class by storing them as a DataFrame or table:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们添加一个方法，简单地返回在`Condiments`类中初始化的所有变量，通过将它们存储为DataFrame或表格：
- en: '[PRE53]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can now create an object for this class and call its method:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以创建这个类的对象并调用其方法：
- en: '[PRE54]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Executing the preceding code results in the following output:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行前面的代码会产生以下输出：
- en: '![Figure 5.7 – The output – Condiment inventory details ](img/Figure_5.7_B13426.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 输出 – 调味品库存详情](img/Figure_5.7_B13426.jpg)'
- en: Figure 5.7 – The output – Condiment inventory details
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 输出 – 调味品库存详情
- en: 'Now let’s check whether the `FMCG` class is a subclass of `Inventory`. It will
    return as `False` since FMCG is not a subclass of `Inventory`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们检查 `FMCG` 类是否是 `Inventory` 类的子类。它将返回 `False`，因为 FMCG 不是 `Inventory` 的子类：
- en: '[PRE55]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In this step, we will check whether `Condiments` is a subclass of `FMCG` and
    also whether it is a subclass of `Inventory`. Both should return as `True` since
    `Condiments` is inherited from both of these classes:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步中，我们将检查 `Condiments` 是否是 `FMCG` 的子类，以及它是否是 `Inventory` 的子类。两者都应该返回 `True`，因为
    `Condiments` 从这两个类中继承而来：
- en: '[PRE56]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, we will be creating an object for a class by, first, checking whether
    a class is a subclass of a specific parent class, then creating an object accordingly,
    and then calling a method on the newly created object:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过首先检查一个类是否是特定父类的子类，然后相应地创建一个对象，最后在新建的对象上调用一个方法来创建一个类的对象：
- en: '[PRE57]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Executing the preceding code results in the following output:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行前面的代码会产生以下输出：
- en: '[PRE58]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: With this understanding, we can look further into the last topic of this chapter.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个理解，我们可以进一步探讨本章的最后一个主题。
- en: Understanding the usage of property
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 `property` 的用法
- en: In this section, we will look at the last built-in function covered in this
    chapter, `property`. This function is used to initialize, set, get, or delete
    methods of attributes in Python. These values are called the properties of an
    object. Let’s first understand how `property` works on Python objects by creating
    an example.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看本章最后介绍的最后一个内置函数，即 `property`。这个函数用于在 Python 中初始化、设置、获取或删除属性的属性。这些值被称为对象的属性。让我们首先通过创建一个示例来理解
    `property` 在 Python 对象上的工作方式。
- en: 'We can create a property by simply calling the `property` function and storing
    it as a variable. Refer to the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过简单地调用 `property` 函数并将其存储为变量来创建一个属性。参考以下代码：
- en: '[PRE59]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We still did not answer the question of how this function creates a property.
    The `property` function takes in four variables to get, set, delete, and document
    the properties of an attribute. To examine it further, let’s look at it in a little
    more detail. The steps are as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍未回答这个函数是如何创建属性的问题。`property` 函数接收四个变量以获取、设置、删除和记录属性的属性。为了进一步检查它，让我们更详细地看看它。步骤如下：
- en: Create a class named `TestPropertyClass`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `TestPropertyClass` 的类。
- en: Initialize it with a `test` attribute and set it as `None`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `test` 属性初始化它，并将其设置为 `None`。
- en: We will then add three methods to perform the functions of getting, setting,
    and deleting the initialized `test` attribute.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加三个方法来执行初始化 `test` 属性的获取、设置和删除功能。
- en: We will then create another variable within the class named `test_attr` and
    assign the `property` function to it with the `get`, `set`, and `delete` methods
    created in this class.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将在类内部创建另一个名为 `test_attr` 的变量，并将 `property` 函数分配给它，使用在这个类中创建的 `get`、`set`
    和 `delete` 方法。
- en: 'The code for this example is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的代码如下：
- en: '[PRE62]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In the preceding code, `get_test_attr` simply returns the `test` attribute,
    `set_test_attr` sets a value to the `test` attribute, and `del_test_attr` deletes
    the `test` attribute.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`get_test_attr` 简单地返回 `test` 属性，`set_test_attr` 将值设置到 `test` 属性，而 `del_test_attr`
    删除 `test` 属性。
- en: 'Let’s now create an object for this class and check how `property` works on
    it:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建这个类的对象，并检查 `property` 在其上的工作方式：
- en: '[PRE76]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In the preceding code, calling the `test` attribute has, in turn, invoked the
    `get_test_attr` method since it is provided as the `get` method to the `property`
    function. Let’s confirm this understanding further by setting a value to `test_attr`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，调用 `test` 属性，反过来，调用了 `get_test_attr` 方法，因为它被作为 `get` 方法提供给 `property`
    函数。让我们进一步确认这一理解，通过设置 `test_attr` 的值：
- en: '[PRE79]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Assigning a value to the `test_attr` variable has now invoked the `set_test_attr`
    method since it is provided as a `set` method to the `property` function. Calling
    the `test_attr` attribute again returns the value set in the preceding step:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将值赋给 `test_attr` 变量现在调用了 `set_test_attr` 方法，因为它被作为 `set` 方法提供给 `property` 函数。再次调用
    `test_attr` 属性将返回前面步骤中设置的值：
- en: '[PRE81]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Similarly, deleting the attribute, in turn, invokes the `del_test_attr` method
    since it is provided as a `delete` method to the `property` function:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，删除属性，反过来，会调用 `del_test_attr` 方法，因为它被作为 `delete` 方法提供给 `property` 函数：
- en: '[PRE84]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Once the attribute is deleted, the `get` method will still be invoked while
    calling the attribute, but it will not return the value previously assigned since
    it is deleted:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦属性被删除，在调用属性时`get`方法仍然会被调用，但由于它已被删除，因此不会返回之前分配的值：
- en: '[PRE86]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The output of the preceding code would now look as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出现在将如下所示：
- en: '![Figure 5.8 – The get method invoked on a deleted attribute ](img/Figure_5.8_B13426.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8 – 在已删除属性上调用get方法](img/Figure_5.8_B13426.jpg)'
- en: Figure 5.8 – The get method invoked on a deleted attribute
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 在已删除属性上调用get方法
- en: By modifying the behavior of the `getter`, `setter`, or `deleter` methods, we
    can modify the properties of the attribute itself. We will look at this statement
    in detail in [*Chapter 6*](B13426_06_Final_PG_epub.xhtml#_idTextAnchor080).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修改`getter`、`setter`或`deleter`方法的行为，我们可以修改属性本身的属性。我们将在[*第6章*](B13426_06_Final_PG_epub.xhtml#_idTextAnchor080)中详细探讨这个说法。
- en: With this understanding of assigning the `property` function to a variable and
    then invoking its `getter`, `setter`, and `deleter` methods, we will further look
    into another variation of implementing `property`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解将`property`函数分配给变量然后调用其`getter`、`setter`和`deleter`方法，我们将进一步探讨实现`property`的另一种变体。
- en: Using property as a decorator
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用property作为装饰器
- en: 'In the preceding section, we looked at how to use `property` as a function
    to modify the properties of an attribute in a class. In this section, we will
    look at how to use `property` as a decorator. Let’s consider the same `TestPropertyClass`
    as in the preceding example and modify the class definition to use the `@property`
    decorator statement instead of the `property()` function statement. Refer to the
    following code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，我们探讨了如何使用`property`函数来修改类中属性的属性。在本节中，我们将探讨如何使用`property`作为装饰器。让我们考虑与前面示例相同的`TestPropertyClass`，并将类定义修改为使用`@property`装饰器语句而不是`property()`函数语句。参考以下代码：
- en: '[PRE87]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: In the preceding code, we have added `@property` as the decorator for `test_attr`,
    and we have also added `@test_attr.setter` for the `set` method, `@test_attr.getter`
    for the `get` method, and `@test_attr.deleter` for the `delete` method.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们为`test_attr`添加了`@property`作为装饰器，并且我们也为`set`方法添加了`@test_attr.setter`，为`get`方法添加了`@test_attr.getter`，为`delete`方法添加了`@test_attr.deleter`。
- en: 'Let’s proceed with executing the code further to check whether `getter`, `setter`,
    and `deleter` are working as expected:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续执行代码以检查`getter`、`setter`和`deleter`是否按预期工作：
- en: '[PRE105]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'In the preceding code, calling the attribute invoked the `getter` method. Similarly,
    `setter` and `deleter` also invoked the `set` and `delete` methods, respectively:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，调用属性调用了`getter`方法。同样，`setter`和`deleter`也分别调用了`set`和`delete`方法：
- en: '[PRE108]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: These are some of the examples of how introspection can be applied to Python
    objects using Python’s built-in functions.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些如何使用Python内置函数将内省应用于Python对象的例子。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to introspect Python objects using built-in
    functions.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用内置函数内省Python对象。
- en: We then saw how to use the `id` function, and how to debug code using `id`.
    We also looked at how to check whether an object is callable, how to check whether
    an object has an attribute, how to check whether an object is an instance, how
    to check whether an object is a subclass, and finally, we looked at how to get,
    set, and delete properties on attributes. From all of these concepts, we learned
    how to inspect Python objects such as classes, methods, and functions. From the
    examples covered under each topic, we also learned how to apply introspection
    in practical use cases.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '我们然后看到了如何使用`id`函数，以及如何使用`id`进行代码调试。我们还探讨了如何检查一个对象是否可调用，如何检查一个对象是否有属性，如何检查一个对象是否是实例，如何检查一个对象是否是子类，最后，我们探讨了如何在属性上获取、设置和删除属性。从所有这些概念中，我们学习了如何检查Python对象，如类、方法和函数。从每个主题下的示例中，我们也学习了如何在实际用例中应用内省。 '
- en: In the next chapter, we will be extending the learning from introspection and
    applying it further to understand reflection on Python objects.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将扩展从内省中学到的知识，并将其进一步应用于理解Python对象的反射。
