<html><head></head><body><div><h1 class="header-title">Making Your Own Area Scanner</h1>
                
            
            
                
<p>Motors are amazing things; they come in all shapes and sizes. Primarily, they can be considered the backbone of most robots. However, nothing is perfect in this world. There must be some drawbacks to these motors as well. By now, you might have figured out some by yourself. In the previous chapter, when we made the car turn, you might have seen that the angle of turn was never really the same. Also when the vehicle was given the command to go straight, it really would not do so. Rather it would try to run slight, toward one side. </p>
<p class="mce-root CDPAlignLeft CDPAlign">Say hello to the first problem—precision. The motors are exceptionally simple to control, but the problem with these motors come when we have to rotate the motors only till a specific angle. If you need to rotate the motor of your robotic vehicle only by 90 degrees, then how would you do it? The first and foremost thing that might come to your mind would be to fiddle with the timings of the motors. You might be right here. But still, it would be impossible to make sure that it is exactly 90 degrees every single time. </p>
<p class="mce-root CDPAlignLeft CDPAlign">But when we talk about robots, accuracy of even 1 degree may not be enough. Roboticists these days are looking forward to accuracy within the magnitude of two decimal digits. So, the precision we are talking about is close to 0.01 degrees. What do you think now? How do we achieve this level of accuracy with motors?</p>
<p class="mce-root CDPAlignLeft CDPAlign">The answers to all these questions will be answered in this chapter through the following topics:</p>
<ul>
<li>Servo motor</li>
<li>Lists</li>
<li>LIDAR</li>
</ul>


            

            
        
    </div>
<div><h1 class="header-title">Servo motor</h1>
                
            
            
                
<p class="mce-root CDPAlignLeft CDPAlign">So, let me introduce you to <em>servo motor</em>. Servo motor is basically a motor with a few added components. Now to understand what those added components, let's first go through this example. Let's say that you want to go to London. Now to see how you have to go there and what would be the route to reach London, the first thing you need to know is that where exactly you are now. If you don't know where you are currently, it is impossible to calculate a route. Similarly, if we want to reach a certain position of motor, we need to know where the shaft of the motor is standing right now. To do this, we use a <strong>potentiometer</strong>. A potentiometer is basically a variable resistor that essentially has a shaft that when rotated changes the value of resistance. A variable resistor looks like this:</p>
<div><img src="img/dfd5853e-ae1a-4d4d-8a54-506bc0b3c030.png" style="width:22.33em;height:28.58em;"/></div>
<p>When the value of resistor change, then the output voltage from the resistor will also change. The interesting thing is that if the input voltage to the potentiometer is well known, then the output voltage from it can be used to infer where the shaft is. Let's see how: </p>
<div><img src="img/1f403a4d-2dcb-4f32-a0e6-1604a0ed5b5f.png" style="width:38.50em;height:19.33em;"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">Now, let's say at a position of 0 degrees, the output voltage for the potentiometer is 4.8V; when we move it up to 90 degrees, the value changes to around 3.2V, and upon turning entirely 180 degrees, the voltage reduces to a mere 2V due to the change in resistance. </p>
<p class="mce-root CDPAlignLeft CDPAlign">Without really looking at the shaft of the potentiometer, we can easily derive that if the voltage output from the resistor is 4.8V, then the shaft must be at a position of 0 degrees. Similarly, we can say that it is at 90 degrees if the voltage is 3.2V and at 180 degrees when the voltage is 2V. </p>
<p class="mce-root CDPAlignLeft CDPAlign">Here, we have just plotted three points, but for any given point on the potentiometer, there would be a very specific resistance corresponding to it. Through this we can precisely calculate where the shaft of the potentiometer would be. Now, let's put it in an interesting combination:</p>
<div><img src="img/fbdce339-30f1-4811-96eb-d28b6b6a73eb.png" style="width:36.17em;height:20.75em;"/></div>
<p>Now what we have is a motor coupled with potentiometer through multiple reducing gears that will reduce the speed of the motor and increase the torque. Further at the final gear, a shaft is mounted outward to the body coupled with a potentiometer.</p>
<p>So as you learned, the potentiometer will be able to sense at which angle the output shaft is pointing. The potentiometer is then connected to a control circuit that takes the reading from the potentiometer and further guides the motor on how much more to move to reach the goal position. Due to this closed loop arrangement in which the control circuit knows where the shaft is, it could calculate how much it has to move the motor to reach the goal position. Hence, this arrangement is able to turn the output shaft to any given position precisely.</p>
<p>This arrangement is typically known as a <strong>servo motor</strong>. Throughout the robotics industry, it is one of the most widely used hardware to control precise movements. Essentially, there are three wires going into the control circuit—VCC, ground, and signal. The signal line will receive the data from our Raspberry Pi, and upon receiving, it will do the necessary motor movement to make the shaft reach the desired position. An image of a servo motor is as follows:</p>
<div><img src="img/4d75bf50-43af-4b4a-9b3f-3153e8a11956.jpg" style="width:21.00em;height:16.25em;"/></div>
<p>These can start from being extremely inexpensive, around $4 to $5, but they can go up to thousands of dollars. But what really decides the pricing of these servo motors? There are several factors that we need to keep in mind while choosing a servo motor, but the most important of it is <strong>torque</strong>.</p>
<p>Torque is a basically a turning force by which a motor can turn the output shaft. This is measured usually in kg·cm or N·m. Now what does this actually mean?  Let's see the following diagram:</p>
<div><img src="img/485ed3d9-7dc5-4e3b-8437-c2efdd4944f2.png" style="width:31.08em;height:23.00em;"/></div>
<p>Let's say in the preceding diagram, we have a motor that has a torque of 10 kg·cm and the rotor attached to it is of 1 cm. So, it should be able to pull up a weight of 10 kg perpendicularly up from the ground. However, when we change the radius of the rotor to 2 cm, then the weight that can be lifted gets halved. Similarly, if the radius increases to 10 cm, then the weight that can be lifted would only reduce to 1 kg. So basically, the weight that can be lifted would be torque/radius.</p>
<p>But for most of our purposes, we would not be using a mechanism as shown previously, so let's look at the next diagram to see how the calculations can be made:</p>
<div><img src="img/c817a2bd-454a-4520-bcdd-2862d22b0067.png" style="width:39.00em;height:14.67em;"/></div>
<p>Now, let's say we have a shaft of length <strong>L</strong> and a load at the extreme edge of the shaft. For ease of calculation purposes, we would consider the weight of shaft to be negligible. Now if the servo is having a torque of 100 kg·cm and the length of shaft (<strong>L</strong>) is 10 cm, then by simple calculation, the load that we can pick up would be 100/10 = 10 kg. Similarly, if the length increases to 100 cm, the load that can be lifted would reduce to a mere 1 kg. </p>
<p>OK then; we have had a good amount of exposure to servo motors. Now the question is how do we control a servo motor? As I mentioned, there are different types of servo motors that are available that can be addressed by various means. However, the most common one used for hobby purposes is a digital servo motor. These servo motors require <strong>PWM</strong>, and based on the duty cycle of PWM, the angle of the shaft changes. So, let's see how it happens.</p>
<p>Typically, most of these servos have a frequency of 50 Hz. So basically the length of every pulse would be 1/50 = 0.02 seconds or in other words 20 ms. Further, the duty cycle that can be given to theses servo motors can be 2.5% to 12.5%, which basically means pulse width of 0.5 ms to 2.5 ms. Now let's see how it works: </p>
<div><img src="img/c1917712-bee6-4280-9311-2d5b5624cb46.png"/></div>
<p class="mce-root CDPAlignLeft CDPAlign">As you can see, when given a duty cycle of 2.5%, the shaft gets down to the minimum position of 0 degrees, and when the duty cycle is increased to 7.5%, the shaft goes to the middle position of 90 degrees. Finally, when the duty cycle is increased to 12.5%, the shaft goes to the maximum position of 180 degrees. If you want any position in between, then you can simply choose the PWM corresponding to it, and it will change the position of servo to the desired angle.</p>
<p class="mce-root CDPAlignLeft CDPAlign">But you may be thinking what if we want to take it beyond 180 degrees? Well, good question, but most of the digital servos only come with a range of 180 degrees of rotation. There are servos that can rotate completely its axis, that is, 360 degrees; however, their addressing is slightly different. After this chapter, you can pretty much go ahead check out any digital servo motor's data sheet and control it the way you want.</p>
<p class="mce-root CDPAlignLeft CDPAlign">All right, enough of theory; it's time to do some fun. So, let's go ahead and set up the hardware and control a servo by our bare hands! Connect the servo to Raspberry Pi as follows:</p>
<div><img src="img/e1b5626d-641a-4f72-bdde-fb0f92e6279c.png" style="width:28.58em;height:44.42em;"/></div>
<p>The color coding of the wires is as follows:</p>
<div><img src="img/8b5740f1-e81a-4cbc-98d1-da2b7bd9c7b2.png" style="width:20.17em;height:29.75em;"/></div>
<p>Next, we need to upload the following code and see what happens:</p>
<pre>import RPi.GPIO as GPIO<br/>import time<br/><br/>GPIO.setmode(GPIO.BCM)<br/>GPIO.setup(14,GPIO.OUT)<br/><br/>pwm = GPIO.PWM(14, 50)<br/>pwm.start(0)<br/><br/>while 1:<br/><br/>        pwm.ChangeDutyCycle(2.5)<br/>        time.sleep(2)<br/><br/>        pwm.ChangeDutyCycle(5)<br/>        time.sleep(2)<br/><br/>        pwm.ChangeDutyCycle(7.5)<br/>        time.sleep(2)<br/><br/>        pwm.ChangeDutyCycle(10)<br/>        time.sleep(2)<br/><br/>        pwm.ChangeDutyCycle(12.5)<br/>        time.sleep(2)</pre>
<p>As soon as you run this program, you will see the shaft of the servo moving from left to right, making steps at 0 degrees, 45 degrees, 90 degrees, 135 degrees, and finally 180 degrees. </p>
<p>Let's see what we have done in the program to achieve it:</p>
<pre>pwm = GPIO.PWM(14, 50)<br/>pwm.start(0)</pre>
<p>With the line <kbd>pwm = GPIO.PWM(14, 50)</kbd>, we have defined that GPIO pin number <kbd>14</kbd> will be used for PWM and the frequency of PWM will be <kbd>50</kbd>. We have used the line <kbd>pwm.start(0)</kbd> in earlier chapters as well. It basically sets the PWM pin to <kbd>0</kbd> that is no duty cycle:</p>
<pre>        pwm.ChangeDutyCycle(2.5)<br/>        time.sleep(2)<br/><br/>        pwm.ChangeDutyCycle(5)<br/>        time.sleep(2)<br/><br/>        pwm.ChangeDutyCycle(7.5)<br/>        time.sleep(2)<br/><br/>        pwm.ChangeDutyCycle(10)<br/>        time.sleep(2)<br/><br/>        pwm.ChangeDutyCycle(12.5)<br/>        time.sleep(2)</pre>
<p>No all the earlier program is in the <kbd>while</kbd> loop, that is, it will be executed over and over until the program is forced to quit. Now the line <kbd>pwm.ChangeDutyCycle(2.5)</kbd> sends a PWM of 2.5% duty cycle to the servo motor. This will simply turn the servo motor to 0 degree angle. Next, we use the good old <kbd>time.sleep(2)</kbd>, which we all know would halt the program that line for two seconds.</p>
<p>The same cycle is being repeated with different PWM values of 5%, which would turn the shaft to 45 degrees, 7.5% for 90 degrees, 10% for 135 degrees, 12.5 % for 180 degrees. It's a very simple program that would clear out our basics of the servo motor. </p>
<p>So by now, you have learned how to control servo motor and move it in the direction in which we want. Now, let's go a step ahead and change the code slightly to make the servo run smoothly:</p>
<pre>import RPi.GPIO as GPIO<br/>import time<br/><br/>GPIO.setmode(GPIO.BCM)<br/>GPIO.setup(14,GPIO.OUT)<br/><br/>pwm = GPIO.PWM(14, 50)<br/>pwm.start(0)<br/><br/>i=2.5<br/>j=12.5<br/><br/>while 1:<br/>        while i&lt;=12.5:<br/>                pwm.ChangeDutyCycle(i)<br/>                time.sleep(0.1)<br/>                i = i + 0.1<br/><br/>        while j&gt;=2.5:<br/>                pwm.ChangeDutyCycle(j)<br/>                time.sleep(0.1)<br/>                j = j - 0.1</pre>
<p>What happened when you uploaded this code in your Pi? You would have noted that the servo is swiping from left to right very smoothly and then right to left. We have done a very simple trick; let's see what it is:</p>
<pre>        while i&lt;=12.5:<br/>                pwm.ChangeDutyCycle(i)<br/>                time.sleep(0.1)<br/>                i = i + 0.1</pre>
<p>Here, we are running a loop that will run till the time the value of <kbd>i&lt;=12.5</kbd>, as we have defined earlier in the program the value of <kbd>i</kbd> has been set to <kbd>2.5</kbd> as default in the starting of the program. Thereafter every time the code runs, the duty cycle is set to the value of <kbd>I</kbd> , the program halts for 0.1 seconds and then the value of <kbd>i</kbd> is incremented by a value of <kbd>0.1</kbd>. This is increasing the duty cycle of the PWM. Once the value reaches 12.5, the loop exits.</p>
<p>The entire PWM range we have is 2.5% to 12.5%, so we have a space of 10% to play with. Now if we map it to the angular rotation of the servo motor, then every percent of PWM corresponds to a change of 180/10 = 18 degrees. Similarly, every 0.1% of the change would result in a change of 180/100 = 1.8 degrees. Hence, with every 0.1 seconds, we are adding duty cycle by 0.1%, or in other words, we are increasing the angle by 1.8 degrees. Hence, we find this action extremely smooth. </p>
<p>We are doing the similar thing in the next portion of the program; however, we are doing it for the reverse motion. </p>


            

            
        
    </div>
<div><h1 class="header-title">Lists</h1>
                
            
            
                
<p>All right then, we are quite sure on how to use the servo and have a controlled motion as per our needs. Now it's time to move forward and understand another concept that we would be using greatly. It's named <strong>arrays</strong>. If you have programmed in any other language, you must be familiar with it. But we need to understand a few basics concepts of it, which will make our lives a lot easier. So, let's get started.</p>
<p>First things, first. Arrays in Python are not named arrays, rather it is named as <strong>lists</strong>. List is basically a data structure that can store multiple elements at the same time. The only limitation being is that the elements must be of the same data type. Such as if you are storing integers, then all the values should be <kbd>int</kbd>. Similarly, if you are storing a character, then every element of the list should be <kbd>char</kbd>. To define a list, all you need to do is name the list such as we have done by doing <kbd>myList</kbd>; the name of the list could be anything next we need to tell the compiler that it is actually a list. To do that, we need to put values inside square brackets. It would look like:</p>
<pre>myList = [14,35,108,64,9]</pre>
<p>One thing to keep in mind is that every value should be separated with commas. Whenever we want to address any single element of the list, we can simply use it by calling their index number. This is based on the position of the element in the list. The index value in Python list starts from 0. So as per the preceding declaration at the index 0, the value would be <kbd>14</kbd>, and at the address 4, the value would be <kbd>9</kbd>. Now when we need to print these elements in between our program, we need to write the following code:</p>
<pre>print myList[2] </pre>
<p>Once we write this, the program will print the value of the second value in the list. In our case, it would be <kbd>35</kbd>. </p>
<p>Now, this is one way to access the elements of the list; we can however access it in reverse order as well. So, let's say you want to access the last item of the array. Then, we can write the following code: </p>
<pre>print myList[-1] </pre>
<p>This code will return the value of the last element of the array. Now whenever we use the negative values in the lists, then it would start the indexing in the reverse order. So, let's say if we type in <kbd>print myList[-2]</kbd>, this will give us the value of the second last value in the array. One thing to remember in this whole schematic is that the numbering would start from 0, whereas when we start it in the reverse order, then the numbering would start from -1.</p>
<p>Python is really interesting and quite simple if you know the right tools. The developers of Python have included some really helpful functions that can be used over lists. So, let's go and explore them a bit. </p>
<p>The first one is to add elements to the array. For this, we use a function named <kbd>append()</kbd>. What the <kbd>append()</kbd> function does is that it adds the value, which would want at the end of the array. So, write the following: </p>
<pre>myList.append(45)</pre>
<p>What this would do is that it would add the element <kbd>45</kbd> at the end of <kbd>myList</kbd>. So now the list would be as follows: </p>
<pre>myList = [14,35,108,64,9, 45]</pre>
<p>Easy, isn't it ? But what if you want to add an element in between the list? Obviously, the developer won't leave you dry. They have included a function for that as well; it's named <kbd>insert(index, element)</kbd>. Now whenever you are using this function, you need to make sure that you mention the index where you want this element to be and second, the element that you want to put. So it looks something like this: </p>
<pre>myList.insert(3,23)</pre>
<p>When you have used this function, the array will look as follows: </p>
<pre>myList = [14,35,108,23,64,9,45]</pre>
<p>Obviously, whenever the developer has given the function to add an element, then they would have certainly given a function to remove the elements as well. But the trick is that you can do it two ways. First, the common way. We simply select the index number and delete it. We are going to do it now:</p>
<pre>del myList[2]</pre>
<p>Now what this will do is that it would delete the second element of the array, so after doing this operation, the array will look like this:</p>
<pre>myList = [14,35,108,64,9,45]</pre>
<p>But now here comes the real trick; you can also delete the element by simply specifying the element. This is how it's done:</p>
<pre>myList.remove(9)</pre>
<p>Now the moment you do this, it will find wherever the element <kbd>9</kbd> is in your list and delete it from the positions. So you don't have to care about where the element is; this function will say, I will find you and I will kill you! </p>


            

            
        
    </div>
<div><h1 class="header-title">Looking around </h1>
                
            
            
                
<p>Okay then enough of movie quotes. We can talk about many other functions that we can use over lists, but what we have done is enough for now. We will see the rest of them as the need arise. But for now let's take the things a step further in robotics. You might have seen a rotating object on top of many autonomous cars. The production cars generally don't tend to have primarily due to its high price, but research purpose cars are always loaded with it.</p>
<p>So what is this device? It's named <strong>LIDAR</strong>; it is an acronym for <strong>Light Detection and Ranging</strong>. I know bad acronym. There is a reason for LIDAR to be very common. It gives distance reading of the areas around it in a very precise way. However, buying it for our projects would slightly overkill as a good one would cost you close $500 to $10,000. If you still think that it's in your budget, then you would be very lucky! But for those who don't want to buy it. I have a good news for you. Today, we are going to build our own LIDAR scanner. So to make an area scanner, we need a servo over which we will mount our IR proximity sensor. Now to do this, we would need a slight makeshift arrangement. You can take a cardboard and fix it like we have done in the picture here, or otherwise, you can also use a right-angled aluminum and drill it to fix the components if you want it to do the pro way. The one thing to remember that the sensor must be facing exactly parallel to the ground and not up or down. </p>
<p>Once the mounting is done, then it's time to connect the rest of the hardware. So go ahead and connect the hardware, as shown in the following diagram:</p>
<div><img src="img/c1c4d876-6972-43ca-9098-099e3572fbfd.png" style="width:41.83em;height:47.00em;"/></div>
<p>OK, so let's see what this thing can do, so get ready and upload this code: </p>
<pre>import RPi.GPIO as GPIO<br/>import time<br/>import Adafruit_ADS1x15<br/><br/>adc = Adafruit_ADS1x15.ADS1115()<br/>GAIN = 1<br/><br/>adc.start_adc(0, gain=GAIN)<br/>GPIO.setmode(GPIO.BCM)<br/>GPIO.setup(14,GPIO.OUT)<br/>GPIO.setwarnings(False)<br/><br/>servo = GPIO.PWM(14, 50)<br/><br/>servo.start(0)<br/><br/>Def Distance():<br/>    D_value = adc0.get_last_result()<br/>    D =    (1.0 / (F_value / 13.15)) - 0.35<br/>    Return D<br/><br/>j=12.5<br/>k=2.5<br/>i=0<br/><br/>distLR=[] <br/>distRL=[]<br/><br/>while True:<br/>        while k&lt;=12.5:<br/>                servo.ChangeDutyCycle(k)<br/>                time.sleep(.1)<br/>                distLR.insert(i,Distance())<br/>                k = k + 2.5<br/>                i = i + 1<br/>        print distLR<br/><br/>        i=0<br/>        k=0<br/><br/>        del distLR[:]<br/><br/>        while j&gt;=2.5:<br/>                servo.ChangeDutyCycle(j)<br/>                time.sleep(.1)<br/>                j = j - 2.5<br/>                distRL.insert(i,Distance())<br/>                i = i + 1<br/><br/>        print distRL<br/><br/>        i=0<br/>        k=2.5<br/>        j=12.5<br/><br/>       del distRL[:]</pre>
<p>What did the code do? If it ran fine, then it should return you the scanned readings entire 180 degree broken down into 10 even steps. Go ahead—try it out and then return to see what actually is happening.</p>
<p>Now most of the code is elementary, and you must have also got an idea of what this code is actually doing. However, let's get deeper into it and see the specifics:</p>
<pre>Def Distance():<br/>    D_value = adc0.get_last_result()<br/>    D =    (1.0 / (F_value / 13.15)) - 0.35<br/>    Return D</pre>
<p>In this part of the program, we have defined a function named <kbd>Distance()</kbd>. As you can see, it is simply getting the reading from the ADC in the step <kbd>D_value = adc0.get_last_result()</kbd>; thereafter, this is the value procured that is stored in a variable <kbd>D</kbd> is then computed in the line <kbd>D = (1.0/F-value/13.15)) - 0.35</kbd> to get the metric reading from the ADC reading. Finally, using the line <kbd>Return D</kbd>, we are returning the value <kbd>D</kbd> from the function:</p>
<pre>distLR=[] <br/>distRL=[]</pre>
<p>We have declared two lists: <kbd>distLR</kbd>, namely for distance for left to right swipe of the servo and <kbd>distRL</kbd> for the distance received in right to left swipe of the servo. You might be wondering how is it that there is nothing inside these brackets. It is completely normal to have an empty array declared. There is no need for them to have value initially:</p>
<pre><br/>        while k&lt;=12.5:<br/>                servo.ChangeDutyCycle(k)<br/>                time.sleep(.1)<br/>                distLR.insert(i,Distance())<br/>                k = k + 1<br/>                i = i + 1<br/>        print distLR</pre>
<p>Now this is where the real action is happening. The <kbd>while</kbd> loop will be executed only till the time the value of <kbd>k</kbd> is less than or equal to <kbd>12.5</kbd>. In the next line <kbd>servo.ChangeDutyCycle(k)</kbd>, the value of the duty cycle will be whatever the value of <kbd>k</kbd> would be. Initially, the value of <kbd>k</kbd> would be <kbd>2.5</kbd> as we have already defined in the beginning of the program. Now we add another line <kbd>time sleep(.1)</kbd>, which will make the program halt for <kbd>.1</kbd> second. This is necessary; otherwise, the program would parse through this loop within milliseconds and the servo would not be able to cope up with it. Hence, this is a short delay. In the next line, we have <kbd>distLR.insert(I,Distance())</kbd>. This line of program is doing a lot of things. First, as we have named a <kbd>Distance()</kbd> function inside this line. As we defined, it would calculate the distance using the ADC and the IR proximity sensor. Thereafter, it would insert that distance value inside an the list <kbd>distLR</kbd> at the position <kbd>I</kbd>. Previously in our program, we have already assigned the value <kbd>i = 0</kbd>; hence, the distance value would be put up in the first position in the array. Once this entire process is done, then we move forward and increment the value by one in this line <kbd>k = k + 1</kbd>; thereafter, we do the same thing in <kbd>I = I + 1</kbd>. Now finally, once this loop's executed, the values of the list is printed using the line <kbd>print distLR</kbd>:</p>
<pre>        i=0<br/>        k=0</pre>
<p>In this line, we are simply resetting the values of <kbd>i = 0</kbd> and <kbd>k = 0</kbd> for the next loop: </p>
<pre>        del distLR[:]</pre>
<p>This may be slightly new for you.  Whenever we use a colon inside a bracket, that basically means that the entire elements of the array would be deleted: </p>
<pre> while j&gt;=2.5:<br/>                servo.ChangeDutyCycle(j)<br/>                time.sleep(.1)<br/>                j = j - 2.5<br/>                distRL.insert(i,Distance())<br/>                i = i + 1<br/><br/>        print distRL</pre>
<p>In this code, the same thing is happening that we did for the left to right swipe; the only difference being is that we are saving it a new list named <kbd>distRL</kbd>, and the swipe starts from 12.5% duty cycle and ends at 2.5%:</p>
<pre>   i=0<br/>        k=2.5<br/>        j=12.5<br/><br/>       del distRL[:]</pre>
<p>When we have printed all the values, we again reset the values of <kbd>i = 1</kbd>, <kbd>k = 2.5</kbd>, and <kbd>j = 12.5</kbd> so that our first loop can start seamlessly further to it we are also making sure that there is nothing left inside the list <kbd>distRL</kbd>.</p>
<p>So this is how our code was working, straight and simple!</p>


            

            
        
    </div>
<div><h1 class="header-title">LIDAR on an autonomous vehicle </h1>
                
            
            
                
<p>Remember the last time we made autonomous car. It was cool, and surely it might be something you can show off to your friends. However, now what we are about to make is surely cooler than anything we have ever done till now.</p>
<p>We are going to put this area scanner over our robotic vehicle. But wait, didn't we scan the area earlier using the same sensor and turning the car to other sides. We did it and it worked fine, almost fine. I bet sometimes it wasn't as accurate as you thought it would be. But that's not the real problem. The main problem is that it was not seamless. It has to stop in between check for spaces and then move in either direction. What we are going to do now is something that is a step ahead. So before doing any more explanation, let's go ahead and make this new robotic vehicle and then you be the judge to decide whether it is cooler. </p>
<p>So, to make it, you need to mount the area scanner on the vehicle. It's advisable that you set it up at the frontend of the vehicle and make sure that the arm of the servo is able to rotate 180 degrees. You can use the similar method that we did to fix the IR sensor on top of the servo. While you are doing all of this, try using cable ties to make sure the cables are not messy and also make sure to leave some slack for the movement of the shaft and the sensor on top of it. These cable ties can make your life really simple. Once we are all set up, you should connect the IR proximity using an ADS1115 to the Raspberry Pi and then connect the motor driver, as shown in the following diagram: </p>
<div><img src="img/3d96558c-f411-475b-90df-2aa078cc3fae.png" style="width:51.42em;height:55.33em;"/></div>
<p>Once we are done go ahead and upload the following code:</p>
<pre>import RPi.GPIO as GPIO<br/>import time<br/>import Adafruit_ADS1x15<br/><br/>adc0 = Adafruit_ADS1x15.ADS1115()<br/>GAIN = 1<br/>adc0.start_adc(0, gain=GAIN)<br/><br/>GPIO.setmode(GPIO.BCM)<br/>GPIO.setup(14,GPIO.OUT)<br/><br/>servo = GPIO.PWM(14, 50)<br/>servo.start(0)<br/><br/>def Distance():<br/>    D_value = adc0.get_last_result()<br/>    D =    (1.0 / (F_value / 13.15)) - 0.35<br/>    Return D<br/><br/>GPIO.setup(20,GPIO.OUT)<br/>GPIO.setup(21,GPIO.OUT)<br/>GPIO.setup(23,GPIO.OUT)<br/>GPIO.setup(24,GPIO.OUT)<br/><br/>LForward = GPIO.PWM(20, 50)<br/>LReverse = GPIO.PWM(21, 50)<br/>RForward = GPIO.PWM(23,50)<br/>RReverse = GPIO.PWM(24,50)<br/><br/>def stop():<br/>    LForward.changeDutyCycle(0)<br/>    LReverse.changeDutyCycle(0)<br/>    RForward.changeDutyCycle(0)<br/>    RReverse.changeDutyCycle(0)<br/><br/><br/>def direction(index):<br/><br/> if index == 0 :<br/>    LForward.changeDutyCycle(0)<br/>    LReverse.changeDutyCycle(30)<br/>    RForward.changeDutyCycle(30)<br/>    RReverse.changeDutyCycle(0)<br/><br/>elif index == 1<br/><br/>    LForward.changeDutyCycle(20)<br/>    LReverse.changeDutyCycle(0)<br/>    RForward.changeDutyCycle(50)<br/>    RReverse.changeDutyCycle(0)<br/><br/> elif index == 2 :<br/><br/>    LForward.changeDutyCycle(50)<br/>    LReverse.changeDutyCycle(0)<br/>    RForward.changeDutyCycle(50)<br/>    RReverse.changeDutyCycle(0)<br/><br/>elif index == 3 :<br/><br/>    LForward.changeDutyCycle(50)<br/>    LReverse.changeDutyCycle(0)<br/>    RForward.changeDutyCycle(20)<br/>    RReverse.changeDutyCycle(0)<br/><br/><br/> elif index == 4 :<br/><br/>    LForward.changeDutyCycle(20)<br/>    LReverse.changeDutyCycle(0)<br/>    RForward.changeDutyCycle(0)<br/>    RReverse.changeDutyCycle(20)<br/><br/> else:<br/> stop()<br/><br/>j=12.5<br/>k=2.5<br/>i=0<br/><br/>dist1=[]<br/>dist2=[]<br/><br/>while True:<br/><br/>    while k&lt;=12.5:<br/>    servo.ChangeDutyCycle(k)<br/>    time.sleep(.2)<br/>    dist1.insert(i,Distance())<br/>    k = k + 2.5<br/>    i = i + 1<br/><br/> print dist1<br/><br/> i=0<br/> k=2<br/><br/> max_dist1 = max(dist1)<br/> max_dist1_index = dist1.index(max_dist1)<br/><br/> direction(max_dist1_index)<br/><br/> del dist1[:]<br/><br/> print max_dist1<br/> print max_dist1_index<br/><br/> while j&gt;=2.5:<br/>    servo.ChangeDutyCycle(j)<br/>    time.sleep(.2)<br/>     j = j - 2.5<br/>     dist2.insert(i,Distance())<br/>    i = i + 1<br/> <br/>print dist2<br/><br/>i=0<br/>j=12<br/><br/> max_dist2 = max(dist2)<br/> max_dist2_index = dist2.index(max_dist2)<br/><br/> direction(max_dist2_index)<br/><br/> del dist2[:]<br/><br/> print max_dist2<br/> print max_dist2_index</pre>
<p>Phew! That was long wasn't it? But trust me it might be long, but not tough. So let's see what this code is doing: </p>
<pre>LForward = GPIO.PWM(20, 50)<br/>LReverse = GPIO.PWM(21, 50)<br/>RForward = GPIO.PWM(23,50)<br/>RReverse = GPIO.PWM(24,50)</pre>
<p>This stuff might look pretty new to you. Though it isn't. What we are doing is that we are defining which pin number will be operating at what PWM frequency. Also, we have named every GPIO pins that is being used for motor control. OK then, it is fine that we are doing all this, but why have we suddenly started to give PWM to motor drivers. Were we not happy giving a simple high pulse?</p>
<p>The answer is very straightforward. With the use of PWM, we were able to change the brightness of an LED in previous chapters. Similarly, by changing the PWM output to the control pins of the motor driver, you cannot only define which direction to spin in. But also the speed at which it can spin. This is all done with PWM. So let's say pin number <kbd>20</kbd> is getting a PWM at 50% duty cycle. So it basically means that the motor which is attached to it will get half the input voltage that the motor driver is receiving. So now we can not only control which direction we want the motor to spin but also at what speed we can do so:</p>
<pre>def direction(index):<br/><br/> if index == 0 :<br/>    LForward.changeDutyCycle(0)<br/>    LReverse.changeDutyCycle(30)<br/>    RForward.changeDutyCycle(30)<br/>    RReverse.changeDutyCycle(0)<br/><br/>elif index == 1<br/>    LForward.changeDutyCycle(20)<br/>    LReverse.changeDutyCycle(0)<br/>    RForward.changeDutyCycle(50)<br/>    RReverse.changeDutyCycle(0)</pre>
<p>In this statement, we have defined a function <kbd>direction(index)</kbd>. What this does is that it compares the value of index and based on it. The power will be given to the motors. So lets say that the index is 0. In this case the wheel on the left side would move in reverse direction whereas the right wheel would move in the reverse direction this will turn the robot on its axis. </p>
<p>In the next statement, we have written an <kbd>elif</kbd> statement, so if the <kbd>else</kbd> statement is not true, then it will check for the rest <kbd>else if</kbd> statement in the body. There are four <kbd>elif</kbd> statements in the entire definition of <kbd>direction(index)</kbd>, which basically means that it will check for each one of it and do either of the activities based on the value of the argument. In this case, it is the index. Further, there is a final <kbd>else</kbd> statement, which would be done if none of the cases are true. So according to the statement, it will call a function of stop. That would stop the vehicle:</p>
<pre>max_dist1 = max(dist1)</pre>
<p>This line is pretty interesting as we are using another fun part of the lists that we have used. So, with the <kbd>max()</kbd> method, we can find the largest value inside a list. So, in this line, we are simply finding the max value and putting it in a variable named <kbd>max_dist1</kbd>:</p>
<pre>max_dist1_index = dist1.index(max_dist1)</pre>
<p>The beauty of lists just doesn't seem to end. In this line, we are using another method named <kbd>index()</kbd>; this method gives us the index of the value inside the list. So, we can know where the value exists in the list. Hence, in this line, we are proving the value of <kbd>max_dist1</kbd>. The method <kbd>index()</kbd> searches the index number and stores that value down into a variable named <kbd>max_dist1_index</kbd>:</p>
<pre> direction(max_dist1_index)</pre>
<p>As we have already defined the function <kbd>Direction()</kbd>, now all we are doing is calling the function to decide which direction to go in. Prefect then, power up your vehicles and see how well they are driving and do not forget to shoot a video and post it online.</p>
<p>Have fun!</p>


            

            
        
    </div>
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>Professional laser scanners are super expensive, so, in this chapter, we went on to build an alternative by ourselves and mounted it on our vehicle. In the next chapter, we will cover topics such as vision processing, and object detection, object tracking, which will enable us to do basic vision processing and to make the car move in the direction of a specific object such as a ball.</p>
<p> </p>


            

            
        
    </div></body></html>