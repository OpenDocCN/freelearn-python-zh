- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Social Media Post Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced models, serializers, viewsets, and routes
    to create our first endpoints. In this chapter, we will be working with the same
    concepts for creating posts for our social media project. This will be done by
    dividing the project into concepts such as database relations, filtering, and
    permissions. By the end of this chapter, you’ll be able to work with database
    relations with Django models, write custom filters and permissions, and delete
    and update objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Post model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the Post model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the Post serializer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing Post viewsets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding permissions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting and updating posts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the Like feature
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you need to have Insomnia installed on your machine to make
    HTTP requests.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter here: [https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap3](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap3).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Post model
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A post in this project is a long or short piece of text that can be viewed
    by anyone, irrespective of whether a user is linked or associated to that post.
    Here are the requirements for the post feature:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Authenticated users should be able to create a post
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticated users should be able to like the post
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All users should be able to read the post, even if they aren’t authenticated
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The author of the post should be able to modify the post
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The author of the post should be able to delete the post
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at these requirements from a backend perspective, we can understand
    that we’ll be dealing with a database, a model, and permissions. First, let’s
    start by writing the structure of the `Post` model in the database.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Designing the Post model
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A post consists of content made up of characters written by an author (here,
    a user). How does that schematize itself into our database?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating the `Post` model, let’s draw a quick figure of the structure
    of the model in the database:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Post table](img/Figure_3.1_B18221.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Post table
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 3**.1*, there is an `author` field, which is a `User`
    table. Each time a post is created, a foreign key will need to be passed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The foreign key is one of the characteristics of the **one-to-many** (or **many-to-one**)
    relationship. In this relationship, a row in table A can have many matching rows
    in table B (*one-to-many*) but a row in table B can only have one matching row
    in table A.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, a user (from the `User` table) can have many posts (in the `Post`
    table) but a post can only have one user (*Figure 3**.2*):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – User and Post relationship](img/Figure_3.2_B18221.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – User and Post relationship
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also two other types of database relationships:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'One-to-one: In this type of relationship, a row in table A can only have one
    matching row in table B, and vice versa. An example of this can be worker C having
    one and only one desk D. And this desk D can only be used by this worker C (*Figure
    3**.3*):'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.3 – One-to-one relationship between a worker and a desk](img/Figure_3.3_B18221.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – One-to-one relationship between a worker and a desk
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Many-to-many: In this type of database relationship, a row in table A can have
    many matching rows in table B, and vice versa. For example, in an e-commerce application,
    an order can have many items, and an item can also appear in many different orders
    (*Figure 3**.4*):'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Many-to-many relationship between an order and an item](img/Figure_3.4_B18221.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Many-to-many relationship between an order and an item
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The *many-to-many* relationship will be used when writing the *like* feature
    for the posts.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Great, now that we have a better idea of database relationships, we can begin
    to write the post feature, starting from the `Post` model. But before that, let’s
    quickly refactor the code to make development easier.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next models that we’ll create will also have the `public_id`, `created`,
    and `updated` fields. For the sake of the **don’t repeat yourself** (**DRY**)
    principle, we will use abstract model classes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: An **abstract class** can be considered a blueprint for other classes. It usually
    contains a set of methods or attributes that must be created within any child
    classes built from the abstract class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `core` directory, create a new Python package called `abstract`.
    Once it’s done, create a `models.py` file. In this file, we will write two classes:
    `AbstractModel` and `AbstractManager`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AbstractModel` class will contain fields such as `public_id`, `created`,
    and `updated`. On the other side, the `AbstractManager` class will contain the
    function used to retrieve an object by its `public_id` field:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: core/abstract/models.py
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see in the `Meta` class for `AbstractModel`, the `abstract` attribute
    is set to `True`. Django will ignore this class model and won’t generate migrations
    for this.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have this class, let’s make a quick refactor on the `User` model:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s remove the `get_object_by_public_id` method to retrieve an object
    via `public_id`, and let’s subclass `UserManager`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: core/user/models.py
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On the `User` model, remove the `public_id`, `updated`, and `created` fields,
    and also, subclass the `User` model with the `AbstractModel` class. This will
    normally cause no changes to the database, hence, there is no need to run `makemigrations`
    again unless you’ve changed an attribute of a field.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Let’s also add `AbstractSerializer`, which will be used by all the serializers
    we’ll be creating on this project.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Writing the AbstractSerializer
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the objects sent back as a response in our API will contain the `id`, `created`,
    and `updated` fields. It’ll be repetitive to write these fields all over again
    on every `ModelSerializer`, so let’s just create an `AbstractSerializer` class.
    In the `abstract` directory, create a file called `serializers.py` and add the
    following content:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: core/abstract/serializers.py
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once it’s done, you can go and subclass the `UserSerializer` class with the
    `AbstractSerializer` class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: core/user/serializers.py
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once it’s done, remove the field declaration of `id`, `created`, and `updated`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Let’s perform one last abstraction for `ViewSets`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Writing the AbstractViewSet
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: But why write an abstract `ViewSet`? Well, there will be repeated declarations
    as to the ordering and the filtering. Let’s create a class that will contain the
    default values.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `abstract` directory, create a file called `viewsets.py` and add the
    following content:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: core/abstract/viewsets.py
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, we have the following attributes:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '`filter_backends`: This sets the default filter backend.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ordering_fields`: This list contains the fields that can be used as ordering
    parameters when making a request.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ordering`: This will tell Django REST in which order to send many objects
    as a response. In this case, all the responses will be ordered by the most recently
    updated.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next step is to add the `AbstractViewSet` class to the code where `ModelViewSets`
    is actually called. Go to `core/user/viewsets.py` and subclass `UserViewSet` with
    the `AbstractViewSet` class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: core/user/viewsets.py
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Great, now we have all the things needed to write better and less code; let’s
    write the `Post` model.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Post model
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already established the structure of the `Post` model. Let’s write
    the code and the features:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new application called `post`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Rewrite `apps.py` of the new create package so it can be called easily in the
    project:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: core/post/apps.py
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once it’s done, we can now write the `Post` model. Open the `models.py` file
    and enter the following content:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: core/post/models.py
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see here how we created the `ForeignKey` relationship. Django models
    actually provide tools to handle this kind of relationship, and it’s also symmetrical,
    meaning that not only can we use the `Post.author` syntax to access the user object
    but we can also access posts created by a user using the `User.post_set` syntax.
    The latter syntax will return a `queryset` object containing the posts created
    by the user because we are in a `ForeignKey` relationship, which is also a one-to-many
    relationship. You will also notice the `on_delete` attribute with the `models.CASCADE`
    value. Using `CASCADE`, if a user is deleted from the database, Django will also
    delete all records of posts in relation to this user.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from `CASCADE` as a value for the `on_delete` attribute on a `ForeignKey`
    relationship, you can also have the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '`SET_NULL`: This will set the child object foreign key to null on delete. For
    example, if a user is deleted from the database, the value of the `author` field
    of the posts in relation to this user is set to **None**.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SET_NULL`：这将在删除时将子对象的外键设置为null。例如，如果从数据库中删除用户，则与该用户相关的帖子的`author`字段值设置为**None**。'
- en: '`SET_DEFAULT`: This will set the child object to the default value given while
    writing the model. It works if you are sure that the default value won’t be deleted.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SET_DEFAULT`：这将在写入模型时将子对象设置为给定的默认值。如果你确定默认值不会被删除，则它将工作。'
- en: '`RESTRICT`: This raises `RestrictedError` under certain conditions.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RESTRICT`：在特定条件下会引发`RestrictedError`。'
- en: '`PROTECT`: This prevents the foreign key object from being deleted as long
    as there are objects linked to the foreign key object.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROTECT`：这会阻止外键对象被删除，只要还有对象与外键对象相关联。'
- en: 'Let’s test the newly added model by creating an object and saving it in the
    database:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个对象并将其保存到数据库中来测试新添加的模型：
- en: 'Add the newly created application to the `INSTALLED_APPS` list:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的应用程序添加到`INSTALLED_APPS`列表中：
- en: CoreRoot/settings.py
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: CoreRoot/settings.py
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s create the migrations for the newly added application:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为新增的应用程序创建迁移：
- en: '[PRE10]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, let’s play with the `python manage.py` `shell` command:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们使用`python manage.py` `shell`命令进行操作：
- en: '[PRE11]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Important note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'You can use the **django_shell_plus** package to speed up work with Django
    shell. You won’t need to type all imports yourself as all your models will be
    imported by default. You can find more information on how to install it from the
    following website: [https://django-extensions.readthedocs.io/en/latest/shell_plus.html](https://django-extensions.readthedocs.io/en/latest/shell_plus.html).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用**django_shell_plus**包来加速与Django shell的工作。你不需要自己输入所有导入，因为默认情况下所有模型都会被导入。你可以在以下网站上找到有关如何安装它的更多信息：[https://django-extensions.readthedocs.io/en/latest/shell_plus.html](https://django-extensions.readthedocs.io/en/latest/shell_plus.html)。
- en: 'Let’s import a user. This will be the author of the post we’ll be creating:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入一个用户。这将是我们将要创建的帖子的作者：
- en: '[PRE16]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, let’s create a dictionary that will contain all the fields needed to
    create a post:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个字典，它将包含创建帖子所需的所有字段：
- en: '[PRE20]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And now, let’s create a post:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个帖子：
- en: '[PRE21]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, the author is in fact the user we’ve retrieved from the database.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，作者实际上是我们在数据库中检索到的用户。
- en: 'Let’s also try the inverse relationship:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也尝试反向关系：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, the `post_set` attribute contains all the instructions needed
    to interact with all the posts linked to this user.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`post_set`属性包含了与该用户相关联的所有帖子所需的所有交互指令。
- en: Now that you have a better understanding of how database relationships work
    in Django, we can move on to writing the serializer of the `Post` object.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经更好地理解了Django中数据库关系的工作方式，我们可以继续编写`Post`对象的序列化器。
- en: Writing the Post serializer
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Post序列化器
- en: The `Post` serializer will contain the fields needed to create a post when making
    a request on the endpoint. Let’s add the feature for the post creation first.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Post`序列化器将包含在端点请求时创建帖子所需的字段。让我们首先添加帖子创建的功能。'
- en: 'In the `post` directory, create a file called `serializers.py`. Inside this
    file, add the following content:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在`post`目录下，创建一个名为`serializers.py`的文件。在这个文件中，添加以下内容：
- en: core/post/serializers.py
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: core/post/serializers.py
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We’ve added a new serializer field type, `SlugRelatedField`. As we are working
    with the `ModelSerializer` class, Django automatically handles the fields and
    relationship generation for us. Defining the type of relationship field we want
    to use can also be crucial to tell Django exactly what to do.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新的序列化器字段类型，`SlugRelatedField`。由于我们正在使用`ModelSerializer`类，Django会自动为我们处理字段和关系生成。定义我们想要使用的关联字段类型对于告诉Django确切要做什么也非常关键。
- en: And that’s where `SlugRelatedField` comes in. It is used to represent the target
    of the relationship using a field on the target. Thus, when creating a post, `public_id`
    of the author will be passed in the body of the request so that the user can be
    identified and linked to the post.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正是`SlugRelatedField`在这里发挥作用。它用于使用目标上的字段来表示关系的目标。因此，在创建帖子时，作者的`public_id`将通过请求体传递，以便用户可以被识别并关联到帖子。
- en: The `validate_author` method checks validation for the `author` field. Here,
    we want to make sure that the user creating the post is the same user as in the
    `author` field. A context dictionary is available in every serializer. It usually
    contains the request object that we can use to make some checks.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no hard limitation here so we can easily move to the next part of
    this feature: writing the `Post` viewsets.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Writing Post viewsets
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the following endpoint, we’ll only be allowing the `POST` and `GET` methods.
    This will help us have the basic features working first.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'The code should follow these rules:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Only authenticated users can create posts
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only authenticated users can read posts
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only `GET` and `POST` methods are allowed
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the `post` directory, create a file called `viewsets.py`. Into the file,
    add the following content:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: core/post/viewsets.py
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the preceding code, we defined three interesting methods:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The `get_queryset` method returns all the posts. We don’t actually have particular
    requirements for fetching posts, so we can return all posts in the database.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `get_object` method returns a `post` object using `public_id` that will
    be present in the URL. We retrieve this parameter from the `self.kwargs` directory.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `create` method, which is the `ViewSet` action executed on `POST` requests
    on the endpoint linked to `ViewSet`. We simply pass the data to the serializer
    declared on `ViewSet`, validate the data, and then call the `perform_create` method
    to create a `post` object. This method will automatically handle the creation
    of a `post` object by calling the `Serializer.create` method, which will trigger
    the creation of a `post` object in the database. Finally, we return a response
    with the newly created post.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And right here, you have the code for `ViewSet`. The next step is to add an
    endpoint and start testing the API.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Post route
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `routers.py` file, add the following content:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: core/routers.py
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once it’s done, you’ll have a new endpoint available on `/post/`. Let’s play
    with Insomnia to test the API.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: First of all, try to make a request directly to the `/post/` endpoint. You’ll
    receive a `/auth/login/` endpoint with a registered user and copy the token.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Bearer** tab in Insomnia, select **Bearer Token**:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Adding Bearer Token to Insomnia request](img/Figure_3.5_B18221.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Adding Bearer Token to Insomnia request
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Now, fire the endpoint again with a `GET` request. You’ll see no results, great!
    Let’s create the first post in the database.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the type of request to `POST` and the following to the JSON body:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Please note that we will have a different `public_id` so make sure to use `public_id`
    of the user you’ve just logged in as and send the request again:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Creating a post](img/Figure_3.6_B18221.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Creating a post
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, the post is created! Let’s see whether it’s available when making a
    `GET` request:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Getting all posts](img/Figure_3.7_B18221.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Getting all posts
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The DRF provides a way to paginate responses and a default pagination limit
    size globally in the `settings.py` file. With time, a lot of objects will be shown
    and the size of the payload will vary.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this, let’s add a default size and a class to paginate our results.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `settings.py` file of the project, add new settings to the `REST_FRAMEWORK`
    dictionary:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: CoreRoot/settings.py
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Basically here, all results are limited to 15 per page but we can also increase
    this size with the `limit` parameter when making a request and also use the `offset`
    parameter to precisely where we want the result to start from:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Great, now make a `GET` request again and you’ll see that the results are better
    structured.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Also, it’ll be more practical to have the name of the author in the response
    as well. Let’s rewrite a serializer method that can help modify the response object.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting the Post serialized object
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Actually, the `author` field accepts `public_id` and returns `public_id`. While
    it does the work, it can be a little bit difficult to identify the user. This
    will cause it to make a request again with `public_id` of the user to get the
    pieces of information about the user.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The `to_representation()` method takes the object instance that requires serialization
    and returns a primitive representation. This usually means returning a structure
    of built-in Python data types. The exact types that can be handled depend on the
    render classes you configure for your API.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `post/serializers.py`, add a new method called `to_represenation()`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: core/post/serializers.py
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, we are using the `public_id` field to retrieve the user and
    then serialize the `User` object with `UserSerializer`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get all the posts again and you’ll see all the users:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Getting all posts](img/Figure_3.8_B18221.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Getting all posts
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: We have a working `Post` feature but it also has some issues. Let’s explore
    this further when writing permissions for our feature.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Adding permissions
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If authentication is the action of verifying the identity of a user, authorization
    is simply the action of checking whether the user has the rights or privileges
    to perform an action.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'In our project, we have three types of users:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '**The anonymous user**: This user has no account on the API and can’t really
    be identified'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The registered and active user**: This user has an account on the API and
    can easily perform some actions'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The admin user**: This user has all rights and privileges'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want anonymous users to be able to read the posts on the API without necessarily
    being authenticated. While it’s true that there is the `AllowAny` permission,
    it’ll surely conflict with the `IsAuthenticated` permission.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we need to write a custom permission.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `authentication` directory, create a file called `permissions`,
    and add the following content:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: core/post/viewsets.py
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Django permissions usually work on two levels: on the overall endpoint (`has_permission`)
    and on an object level (`has_object_permission`).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: A great way to write permissions is to always deny by default; that is why we
    always return `False` at the end of each permission method. And then you can start
    adding the conditions. Here, in all the methods, we are checking that anonymous
    users can only make the `SAFE_METHODS` requests — `GET`, `OPTIONS`, and `HEAD`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: And for other users, we are making sure that they are always authenticated before
    continuing. Another important feature is to allow users to delete or update posts.
    Let’s see how we can add this with Django.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Deleting and updating posts
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deleting and updating articles are also part of the features of posts. To add
    these functionalities, we don’t need to write a serializer or a viewset, as the
    methods for deletion (`destroy()`), and updating (`update()`) are already available
    by default in the `ViewSet` class. We will just rewrite the `update` method on
    `PostSerializer` to ensure that the `edited` field is set to `True` when modifying
    a post.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the `PUT` and `DELETE` methods to `http_methods` of `PostViewSet`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: core/post/viewsets.py
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Before going in, let’s rewrite the `update` method in `PostSerializer`. We
    actually have a field called `edited` in the `Post` model. This field will tell
    us whether the post has been edited:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: core/post/serializers.py
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And let’s try the `PUT` and `DELETE` requests in Insomnia. Here’s an example
    of the body for the `PUT` request:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![Figure 3.9 – Modifying a post](img/Figure_3.9_B18221.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Modifying a post
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `edited` field in the response is set to `true`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to delete the post and see whether it works:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Deleting a post](img/Figure_3.10_B18221.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Deleting a post
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: There is a way to delete records without necessarily deleting them from the
    database. It’s usually called a soft delete. The record just won’t be accessible
    to the user, but it will always be present in the database. You can learn more
    about this at [https://dev.to/bikramjeetsingh/soft-deletes-in-django-a9j](https://dev.to/bikramjeetsingh/soft-deletes-in-django-a9j).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Like feature
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A nice feature to have in a social media application is favoriting. Like Facebook,
    Instagram, or Twitter, we’ll allow users here to like a post.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Plus, we’ll also add data to count the number of likes a post has received and
    check whether a current user making the request has liked a post.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll do this in four steps:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Add a new `posts_liked` field to the `User` model.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write methods on the `User` model to like and remove a like from a post. We’ll
    also add a method to check whether the user has liked a post.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `likes_count` and `has_liked` to `PostSerializer`.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add endpoints to like and dislike a post.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Great! Let’s start by adding the new fields to the `User` model.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Adding the posts_liked field to the User model
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `posts_liked` field will contain all the posts liked by a user. The relationship
    between the `User` model and the `Post` model concerning the Like feature can
    be described as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: A user can like many posts
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A post can be liked by many users
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This kind of relationship sounds familiar? It is a *many-to-many* relationship.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this change, here’s the updated structure of the table – we are also
    anticipating the methods we’ll add to the model:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – New User table structure](img/Figure_3.11_B18221.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – New User table structure
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! Let’s add the `posts_liked` field to the `User` model. Open the `/core/user/models.py`
    file and add a new field to the `User` model:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After that, run the following commands to create a new migrations file and
    apply this migration to the database:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The next step is to add the new methods shown in *Figure 3**.11* to the `User`
    model.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Adding the like, remove_like, and has_liked methods
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before writing these methods, let’s describe the purpose of each new method:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'The `like()` method: This is used for liking a post if it hasn’t been done
    yet. For this, we’ll use the `add()` method from the models. We’ll use `ManyToManyField`
    to link a post to a user.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `remove_like()` method: This is used for removing a like from a post. For
    this, we’ll use the `remove` method from the models. We’ll use `ManyToManyField`
    to unlink a post from a user.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `has_liked()` method: This is used for returning `True` if the user has
    liked a post, else `False`.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s move on to the coding:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Great! Next, let’s add the `likes_count` and `has_liked` fields to `PostSerializer`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Adding the likes_count and has_liked fields to PostSerializer
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of adding fields such as `likes_count` in the `Post` model and generating
    more fields in the database, we can directly manage it on `PostSerializer`. The
    `Serializer` class in Django provides ways to create the `write_only` values that
    will be sent on the response.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `core/post/serializers.py` file, add new fields to `PostSerializer`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Core/post/serializers.py
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding code, we are using the `serializers.SerializerMethodField()`
    field, which allows us to write a custom function that will return a value we
    want to attribute to this field. The syntax of the method will be `get_field`,
    where `field` is the name of the field declared on the serializer.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: That is why for `liked`, we have the `get_liked` method, and for `likes_count`,
    we have the `get_likes_count` method.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: With the new fields on `PostSerializer`, we can now add the endpoints needed
    to `PostViewSet` to like or dislike an article.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Adding like and dislike actions to PostViewSet
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'DRF provides a decorator called `action`. This decorator helps make methods
    on a `ViewSet` class routable. The `action` decorator takes two arguments:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '`detail`: If this argument is set to `True`, the route to this action will
    require a resource lookup field; in most cases, this will be the ID of the resource'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`methods`: This is a list of the methods accepted by the action'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s write the actions on `PostViewSets`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: core/post/viewsets.py
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For each action added, we are writing the logic following these steps:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: First, we retrieve the concerned post on which we want to call the like or remove
    the like action. The `self.get_object()` method will automatically return the
    concerned post using the ID passed to the URL request, thanks to the `detail`
    attribute being set to `True`.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Second, we also retrieve the user making the request from the `self.request`
    object. This is done so that we can call the `remove_like` or `like` method added
    to the `User` model.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And finally, we serialize the post using the `Serializer` class defined on `self.serializer_class`
    and we return a response.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With this added to `PostViewSets`, the Django Rest Framework routers will automatically
    create new routes for this resource, and then, you can do the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Like a post with the following endpoint: `api/post/post_pk/like/`.'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the like from a post with the following endpoint: `api/post/post_pk/remove_like/`.'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Great, the feature is working like a charm. In the next chapter, we’ll be adding
    the *comments* feature to the project.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve learned how to use database relationships and write permissions.
    We also learned how to surcharge updates and create methods on viewsets and serializers.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: We performed quick refactoring on our code by creating an `Abstract` class to
    follow the *DRY* rule. In the next chapter, we’ll be adding the Comments feature
    on the posts. Users will be able to create comments under posts as well as delete
    and update them.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are some database relationships?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are Django permissions?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you paginate the results of an API response?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you use Django shell?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
