- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Social Media Post Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we introduced models, serializers, viewsets, and routes
    to create our first endpoints. In this chapter, we will be working with the same
    concepts for creating posts for our social media project. This will be done by
    dividing the project into concepts such as database relations, filtering, and
    permissions. By the end of this chapter, you’ll be able to work with database
    relations with Django models, write custom filters and permissions, and delete
    and update objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Post model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the Post model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the Post serializer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing Post viewsets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting and updating posts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the Like feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you need to have Insomnia installed on your machine to make
    HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter here: [https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap3](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap3).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Post model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A post in this project is a long or short piece of text that can be viewed
    by anyone, irrespective of whether a user is linked or associated to that post.
    Here are the requirements for the post feature:'
  prefs: []
  type: TYPE_NORMAL
- en: Authenticated users should be able to create a post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticated users should be able to like the post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All users should be able to read the post, even if they aren’t authenticated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The author of the post should be able to modify the post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The author of the post should be able to delete the post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at these requirements from a backend perspective, we can understand
    that we’ll be dealing with a database, a model, and permissions. First, let’s
    start by writing the structure of the `Post` model in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the Post model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A post consists of content made up of characters written by an author (here,
    a user). How does that schematize itself into our database?
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating the `Post` model, let’s draw a quick figure of the structure
    of the model in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Post table](img/Figure_3.1_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Post table
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 3**.1*, there is an `author` field, which is a `User`
    table. Each time a post is created, a foreign key will need to be passed.
  prefs: []
  type: TYPE_NORMAL
- en: The foreign key is one of the characteristics of the **one-to-many** (or **many-to-one**)
    relationship. In this relationship, a row in table A can have many matching rows
    in table B (*one-to-many*) but a row in table B can only have one matching row
    in table A.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, a user (from the `User` table) can have many posts (in the `Post`
    table) but a post can only have one user (*Figure 3**.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – User and Post relationship](img/Figure_3.2_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – User and Post relationship
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also two other types of database relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: 'One-to-one: In this type of relationship, a row in table A can only have one
    matching row in table B, and vice versa. An example of this can be worker C having
    one and only one desk D. And this desk D can only be used by this worker C (*Figure
    3**.3*):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.3 – One-to-one relationship between a worker and a desk](img/Figure_3.3_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – One-to-one relationship between a worker and a desk
  prefs: []
  type: TYPE_NORMAL
- en: 'Many-to-many: In this type of database relationship, a row in table A can have
    many matching rows in table B, and vice versa. For example, in an e-commerce application,
    an order can have many items, and an item can also appear in many different orders
    (*Figure 3**.4*):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Many-to-many relationship between an order and an item](img/Figure_3.4_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Many-to-many relationship between an order and an item
  prefs: []
  type: TYPE_NORMAL
- en: The *many-to-many* relationship will be used when writing the *like* feature
    for the posts.
  prefs: []
  type: TYPE_NORMAL
- en: Great, now that we have a better idea of database relationships, we can begin
    to write the post feature, starting from the `Post` model. But before that, let’s
    quickly refactor the code to make development easier.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next models that we’ll create will also have the `public_id`, `created`,
    and `updated` fields. For the sake of the **don’t repeat yourself** (**DRY**)
    principle, we will use abstract model classes.
  prefs: []
  type: TYPE_NORMAL
- en: An **abstract class** can be considered a blueprint for other classes. It usually
    contains a set of methods or attributes that must be created within any child
    classes built from the abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `core` directory, create a new Python package called `abstract`.
    Once it’s done, create a `models.py` file. In this file, we will write two classes:
    `AbstractModel` and `AbstractManager`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AbstractModel` class will contain fields such as `public_id`, `created`,
    and `updated`. On the other side, the `AbstractManager` class will contain the
    function used to retrieve an object by its `public_id` field:'
  prefs: []
  type: TYPE_NORMAL
- en: core/abstract/models.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the `Meta` class for `AbstractModel`, the `abstract` attribute
    is set to `True`. Django will ignore this class model and won’t generate migrations
    for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have this class, let’s make a quick refactor on the `User` model:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s remove the `get_object_by_public_id` method to retrieve an object
    via `public_id`, and let’s subclass `UserManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: core/user/models.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: On the `User` model, remove the `public_id`, `updated`, and `created` fields,
    and also, subclass the `User` model with the `AbstractModel` class. This will
    normally cause no changes to the database, hence, there is no need to run `makemigrations`
    again unless you’ve changed an attribute of a field.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s also add `AbstractSerializer`, which will be used by all the serializers
    we’ll be creating on this project.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the AbstractSerializer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the objects sent back as a response in our API will contain the `id`, `created`,
    and `updated` fields. It’ll be repetitive to write these fields all over again
    on every `ModelSerializer`, so let’s just create an `AbstractSerializer` class.
    In the `abstract` directory, create a file called `serializers.py` and add the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: core/abstract/serializers.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it’s done, you can go and subclass the `UserSerializer` class with the
    `AbstractSerializer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: core/user/serializers.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once it’s done, remove the field declaration of `id`, `created`, and `updated`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s perform one last abstraction for `ViewSets`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the AbstractViewSet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: But why write an abstract `ViewSet`? Well, there will be repeated declarations
    as to the ordering and the filtering. Let’s create a class that will contain the
    default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `abstract` directory, create a file called `viewsets.py` and add the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: core/abstract/viewsets.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filter_backends`: This sets the default filter backend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ordering_fields`: This list contains the fields that can be used as ordering
    parameters when making a request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ordering`: This will tell Django REST in which order to send many objects
    as a response. In this case, all the responses will be ordered by the most recently
    updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next step is to add the `AbstractViewSet` class to the code where `ModelViewSets`
    is actually called. Go to `core/user/viewsets.py` and subclass `UserViewSet` with
    the `AbstractViewSet` class:'
  prefs: []
  type: TYPE_NORMAL
- en: core/user/viewsets.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Great, now we have all the things needed to write better and less code; let’s
    write the `Post` model.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Post model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already established the structure of the `Post` model. Let’s write
    the code and the features:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new application called `post`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rewrite `apps.py` of the new create package so it can be called easily in the
    project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: core/post/apps.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it’s done, we can now write the `Post` model. Open the `models.py` file
    and enter the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: core/post/models.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can see here how we created the `ForeignKey` relationship. Django models
    actually provide tools to handle this kind of relationship, and it’s also symmetrical,
    meaning that not only can we use the `Post.author` syntax to access the user object
    but we can also access posts created by a user using the `User.post_set` syntax.
    The latter syntax will return a `queryset` object containing the posts created
    by the user because we are in a `ForeignKey` relationship, which is also a one-to-many
    relationship. You will also notice the `on_delete` attribute with the `models.CASCADE`
    value. Using `CASCADE`, if a user is deleted from the database, Django will also
    delete all records of posts in relation to this user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from `CASCADE` as a value for the `on_delete` attribute on a `ForeignKey`
    relationship, you can also have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SET_NULL`: This will set the child object foreign key to null on delete. For
    example, if a user is deleted from the database, the value of the `author` field
    of the posts in relation to this user is set to **None**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SET_DEFAULT`: This will set the child object to the default value given while
    writing the model. It works if you are sure that the default value won’t be deleted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RESTRICT`: This raises `RestrictedError` under certain conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PROTECT`: This prevents the foreign key object from being deleted as long
    as there are objects linked to the foreign key object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s test the newly added model by creating an object and saving it in the
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the newly created application to the `INSTALLED_APPS` list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CoreRoot/settings.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s create the migrations for the newly added application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let’s play with the `python manage.py` `shell` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the **django_shell_plus** package to speed up work with Django
    shell. You won’t need to type all imports yourself as all your models will be
    imported by default. You can find more information on how to install it from the
    following website: [https://django-extensions.readthedocs.io/en/latest/shell_plus.html](https://django-extensions.readthedocs.io/en/latest/shell_plus.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s import a user. This will be the author of the post we’ll be creating:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s create a dictionary that will contain all the fields needed to
    create a post:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And now, let’s create a post:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the author is in fact the user we’ve retrieved from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s also try the inverse relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `post_set` attribute contains all the instructions needed
    to interact with all the posts linked to this user.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a better understanding of how database relationships work
    in Django, we can move on to writing the serializer of the `Post` object.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Post serializer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Post` serializer will contain the fields needed to create a post when making
    a request on the endpoint. Let’s add the feature for the post creation first.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `post` directory, create a file called `serializers.py`. Inside this
    file, add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: core/post/serializers.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We’ve added a new serializer field type, `SlugRelatedField`. As we are working
    with the `ModelSerializer` class, Django automatically handles the fields and
    relationship generation for us. Defining the type of relationship field we want
    to use can also be crucial to tell Django exactly what to do.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s where `SlugRelatedField` comes in. It is used to represent the target
    of the relationship using a field on the target. Thus, when creating a post, `public_id`
    of the author will be passed in the body of the request so that the user can be
    identified and linked to the post.
  prefs: []
  type: TYPE_NORMAL
- en: The `validate_author` method checks validation for the `author` field. Here,
    we want to make sure that the user creating the post is the same user as in the
    `author` field. A context dictionary is available in every serializer. It usually
    contains the request object that we can use to make some checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no hard limitation here so we can easily move to the next part of
    this feature: writing the `Post` viewsets.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing Post viewsets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the following endpoint, we’ll only be allowing the `POST` and `GET` methods.
    This will help us have the basic features working first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code should follow these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Only authenticated users can create posts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only authenticated users can read posts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only `GET` and `POST` methods are allowed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the `post` directory, create a file called `viewsets.py`. Into the file,
    add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: core/post/viewsets.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we defined three interesting methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The `get_queryset` method returns all the posts. We don’t actually have particular
    requirements for fetching posts, so we can return all posts in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `get_object` method returns a `post` object using `public_id` that will
    be present in the URL. We retrieve this parameter from the `self.kwargs` directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `create` method, which is the `ViewSet` action executed on `POST` requests
    on the endpoint linked to `ViewSet`. We simply pass the data to the serializer
    declared on `ViewSet`, validate the data, and then call the `perform_create` method
    to create a `post` object. This method will automatically handle the creation
    of a `post` object by calling the `Serializer.create` method, which will trigger
    the creation of a `post` object in the database. Finally, we return a response
    with the newly created post.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And right here, you have the code for `ViewSet`. The next step is to add an
    endpoint and start testing the API.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Post route
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `routers.py` file, add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: core/routers.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Once it’s done, you’ll have a new endpoint available on `/post/`. Let’s play
    with Insomnia to test the API.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, try to make a request directly to the `/post/` endpoint. You’ll
    receive a `/auth/login/` endpoint with a registered user and copy the token.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Bearer** tab in Insomnia, select **Bearer Token**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Adding Bearer Token to Insomnia request](img/Figure_3.5_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Adding Bearer Token to Insomnia request
  prefs: []
  type: TYPE_NORMAL
- en: Now, fire the endpoint again with a `GET` request. You’ll see no results, great!
    Let’s create the first post in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the type of request to `POST` and the following to the JSON body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that we will have a different `public_id` so make sure to use `public_id`
    of the user you’ve just logged in as and send the request again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Creating a post](img/Figure_3.6_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Creating a post
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, the post is created! Let’s see whether it’s available when making a
    `GET` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Getting all posts](img/Figure_3.7_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Getting all posts
  prefs: []
  type: TYPE_NORMAL
- en: The DRF provides a way to paginate responses and a default pagination limit
    size globally in the `settings.py` file. With time, a lot of objects will be shown
    and the size of the payload will vary.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this, let’s add a default size and a class to paginate our results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `settings.py` file of the project, add new settings to the `REST_FRAMEWORK`
    dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: CoreRoot/settings.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically here, all results are limited to 15 per page but we can also increase
    this size with the `limit` parameter when making a request and also use the `offset`
    parameter to precisely where we want the result to start from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Great, now make a `GET` request again and you’ll see that the results are better
    structured.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it’ll be more practical to have the name of the author in the response
    as well. Let’s rewrite a serializer method that can help modify the response object.
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting the Post serialized object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Actually, the `author` field accepts `public_id` and returns `public_id`. While
    it does the work, it can be a little bit difficult to identify the user. This
    will cause it to make a request again with `public_id` of the user to get the
    pieces of information about the user.
  prefs: []
  type: TYPE_NORMAL
- en: The `to_representation()` method takes the object instance that requires serialization
    and returns a primitive representation. This usually means returning a structure
    of built-in Python data types. The exact types that can be handled depend on the
    render classes you configure for your API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `post/serializers.py`, add a new method called `to_represenation()`:'
  prefs: []
  type: TYPE_NORMAL
- en: core/post/serializers.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are using the `public_id` field to retrieve the user and
    then serialize the `User` object with `UserSerializer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get all the posts again and you’ll see all the users:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Getting all posts](img/Figure_3.8_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Getting all posts
  prefs: []
  type: TYPE_NORMAL
- en: We have a working `Post` feature but it also has some issues. Let’s explore
    this further when writing permissions for our feature.
  prefs: []
  type: TYPE_NORMAL
- en: Adding permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If authentication is the action of verifying the identity of a user, authorization
    is simply the action of checking whether the user has the rights or privileges
    to perform an action.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our project, we have three types of users:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The anonymous user**: This user has no account on the API and can’t really
    be identified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The registered and active user**: This user has an account on the API and
    can easily perform some actions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The admin user**: This user has all rights and privileges'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want anonymous users to be able to read the posts on the API without necessarily
    being authenticated. While it’s true that there is the `AllowAny` permission,
    it’ll surely conflict with the `IsAuthenticated` permission.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we need to write a custom permission.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `authentication` directory, create a file called `permissions`,
    and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: core/post/viewsets.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Django permissions usually work on two levels: on the overall endpoint (`has_permission`)
    and on an object level (`has_object_permission`).'
  prefs: []
  type: TYPE_NORMAL
- en: A great way to write permissions is to always deny by default; that is why we
    always return `False` at the end of each permission method. And then you can start
    adding the conditions. Here, in all the methods, we are checking that anonymous
    users can only make the `SAFE_METHODS` requests — `GET`, `OPTIONS`, and `HEAD`.
  prefs: []
  type: TYPE_NORMAL
- en: And for other users, we are making sure that they are always authenticated before
    continuing. Another important feature is to allow users to delete or update posts.
    Let’s see how we can add this with Django.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting and updating posts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deleting and updating articles are also part of the features of posts. To add
    these functionalities, we don’t need to write a serializer or a viewset, as the
    methods for deletion (`destroy()`), and updating (`update()`) are already available
    by default in the `ViewSet` class. We will just rewrite the `update` method on
    `PostSerializer` to ensure that the `edited` field is set to `True` when modifying
    a post.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the `PUT` and `DELETE` methods to `http_methods` of `PostViewSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: core/post/viewsets.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Before going in, let’s rewrite the `update` method in `PostSerializer`. We
    actually have a field called `edited` in the `Post` model. This field will tell
    us whether the post has been edited:'
  prefs: []
  type: TYPE_NORMAL
- en: core/post/serializers.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And let’s try the `PUT` and `DELETE` requests in Insomnia. Here’s an example
    of the body for the `PUT` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 3.9 – Modifying a post](img/Figure_3.9_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Modifying a post
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `edited` field in the response is set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to delete the post and see whether it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Deleting a post](img/Figure_3.10_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Deleting a post
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: There is a way to delete records without necessarily deleting them from the
    database. It’s usually called a soft delete. The record just won’t be accessible
    to the user, but it will always be present in the database. You can learn more
    about this at [https://dev.to/bikramjeetsingh/soft-deletes-in-django-a9j](https://dev.to/bikramjeetsingh/soft-deletes-in-django-a9j).
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Like feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A nice feature to have in a social media application is favoriting. Like Facebook,
    Instagram, or Twitter, we’ll allow users here to like a post.
  prefs: []
  type: TYPE_NORMAL
- en: Plus, we’ll also add data to count the number of likes a post has received and
    check whether a current user making the request has liked a post.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll do this in four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new `posts_liked` field to the `User` model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write methods on the `User` model to like and remove a like from a post. We’ll
    also add a method to check whether the user has liked a post.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `likes_count` and `has_liked` to `PostSerializer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add endpoints to like and dislike a post.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Great! Let’s start by adding the new fields to the `User` model.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the posts_liked field to the User model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `posts_liked` field will contain all the posts liked by a user. The relationship
    between the `User` model and the `Post` model concerning the Like feature can
    be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A user can like many posts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A post can be liked by many users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This kind of relationship sounds familiar? It is a *many-to-many* relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this change, here’s the updated structure of the table – we are also
    anticipating the methods we’ll add to the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – New User table structure](img/Figure_3.11_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – New User table structure
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! Let’s add the `posts_liked` field to the `User` model. Open the `/core/user/models.py`
    file and add a new field to the `User` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, run the following commands to create a new migrations file and
    apply this migration to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to add the new methods shown in *Figure 3**.11* to the `User`
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the like, remove_like, and has_liked methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before writing these methods, let’s describe the purpose of each new method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `like()` method: This is used for liking a post if it hasn’t been done
    yet. For this, we’ll use the `add()` method from the models. We’ll use `ManyToManyField`
    to link a post to a user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `remove_like()` method: This is used for removing a like from a post. For
    this, we’ll use the `remove` method from the models. We’ll use `ManyToManyField`
    to unlink a post from a user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `has_liked()` method: This is used for returning `True` if the user has
    liked a post, else `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s move on to the coding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Great! Next, let’s add the `likes_count` and `has_liked` fields to `PostSerializer`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the likes_count and has_liked fields to PostSerializer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of adding fields such as `likes_count` in the `Post` model and generating
    more fields in the database, we can directly manage it on `PostSerializer`. The
    `Serializer` class in Django provides ways to create the `write_only` values that
    will be sent on the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `core/post/serializers.py` file, add new fields to `PostSerializer`:'
  prefs: []
  type: TYPE_NORMAL
- en: Core/post/serializers.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are using the `serializers.SerializerMethodField()`
    field, which allows us to write a custom function that will return a value we
    want to attribute to this field. The syntax of the method will be `get_field`,
    where `field` is the name of the field declared on the serializer.
  prefs: []
  type: TYPE_NORMAL
- en: That is why for `liked`, we have the `get_liked` method, and for `likes_count`,
    we have the `get_likes_count` method.
  prefs: []
  type: TYPE_NORMAL
- en: With the new fields on `PostSerializer`, we can now add the endpoints needed
    to `PostViewSet` to like or dislike an article.
  prefs: []
  type: TYPE_NORMAL
- en: Adding like and dislike actions to PostViewSet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'DRF provides a decorator called `action`. This decorator helps make methods
    on a `ViewSet` class routable. The `action` decorator takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`detail`: If this argument is set to `True`, the route to this action will
    require a resource lookup field; in most cases, this will be the ID of the resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`methods`: This is a list of the methods accepted by the action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s write the actions on `PostViewSets`:'
  prefs: []
  type: TYPE_NORMAL
- en: core/post/viewsets.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'For each action added, we are writing the logic following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we retrieve the concerned post on which we want to call the like or remove
    the like action. The `self.get_object()` method will automatically return the
    concerned post using the ID passed to the URL request, thanks to the `detail`
    attribute being set to `True`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Second, we also retrieve the user making the request from the `self.request`
    object. This is done so that we can call the `remove_like` or `like` method added
    to the `User` model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And finally, we serialize the post using the `Serializer` class defined on `self.serializer_class`
    and we return a response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With this added to `PostViewSets`, the Django Rest Framework routers will automatically
    create new routes for this resource, and then, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like a post with the following endpoint: `api/post/post_pk/like/`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the like from a post with the following endpoint: `api/post/post_pk/remove_like/`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Great, the feature is working like a charm. In the next chapter, we’ll be adding
    the *comments* feature to the project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve learned how to use database relationships and write permissions.
    We also learned how to surcharge updates and create methods on viewsets and serializers.
  prefs: []
  type: TYPE_NORMAL
- en: We performed quick refactoring on our code by creating an `Abstract` class to
    follow the *DRY* rule. In the next chapter, we’ll be adding the Comments feature
    on the posts. Users will be able to create comments under posts as well as delete
    and update them.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are some database relationships?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are Django permissions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you paginate the results of an API response?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you use Django shell?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
