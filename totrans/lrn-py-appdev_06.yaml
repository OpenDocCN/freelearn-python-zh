- en: Chapter 6. Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will introduce you to some commonly used design patterns. Here
    is how the chapter is organized:'
  prefs: []
  type: TYPE_NORMAL
- en: We will start with a quick introduction to design patterns, followed by a discussion
    on some Python language features that help to simplify their implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, with the help of a fantasy game theme, we will discuss the following
    design patterns:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategy pattern
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple and abstract factory pattern
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapter pattern
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For each pattern, a simple game scenario will demonstrate a practical problem.
    We will see how the design pattern can help solve this problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also implement each of these patterns using a Pythonic approach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are several known design patterns out there. As outlined earlier, we will
    discuss only a few. The idea is not to present a new cookbook on patterns, but
    just to show you how design patterns help solve some commonly encountered problems,
    and how to implement them in Python. Beyond this book, you can explore other traditional
    design patterns and try adding a Pythonic flavor to them.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, you are about to get introduced to some new game characters. So
    get ready to learn design patterns with Sir Foo and friends!
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say that during application development, you stumble upon a problem that
    pops up again and again. Frustrated, you ask your co-developers or a community
    for help. Guess what, you are not alone. Many have encountered a similar problem
    in their code. Luckily, you get a response from someone who has found a solution.
    This solution seemed to have worked reliably on similar problems. You change your
    problematic code so that it conforms to the suggested design, and voila! Your
    problem is resolved!
  prefs: []
  type: TYPE_NORMAL
- en: What we just discussed is a software design pattern. A software design pattern
    is a tried and tested solution or a strategy that helps us solve a commonly encountered
    problem in the code. Let's start with the broad categories of design patterns
    followed by some important design principles.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The Gang of Four book**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before beginning any discussion on the design patterns in Python, it is worth
    noting that there is an excellent book you may want on your bookshelf, *Design
    Patterns: Elements of Reusable Object-Oriented Software*, by Erich Gamma, Richard
    Helm, Ralph Johnson, and John Vlissides. These four authors are commonly referred
    to as the **Gang of Four** (**GoF**). Their book illustrates design patterns using
    C++ and Smalltalk examples. If you have a background in programming languages
    such as C++ or Java, this might be of more interest to you. As you will see in
    this chapter, some high-level language features in Python make many design patterns
    much simpler to implement. The GoF book is still a great reference, and will help
    you understand the core concepts behind the design patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: Classification of patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Software design patterns can be broadly classified into four categories, namely
    behavioral patterns, creational patterns, structural patterns, and concurrency
    patterns. In this book, we will limit our discussion to just three design patterns.
    We will see one example each of behavioral, creational, and structural patterns.
    The concurrency patterns are not covered here, as it is an advanced topic, beyond
    the scope of this book. For an in-depth understanding of other design patterns,
    you can grab a book on design patterns, such as the GoF book mentioned earlier.
    With this in mind, let's briefly talk about each of these categories next.
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The behavioral design patterns try to simplify how different objects communicate
    with each other. While doing so, these patterns help keep these objects loosely
    coupled or less dependent on each other. The following is a partial list of behavioral
    design patterns: chain of responsibility, command, strategy, observer, iterator,
    visitor pattern, and many more. In this chapter, we will see how to implement
    the strategy pattern in Python.'
  prefs: []
  type: TYPE_NORMAL
- en: Creational patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These patterns are all about instance creation mechanisms. These design patterns
    show a better way to create objects depending on the situation you are dealing
    with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of the major creational design patterns: abstract factory, factory
    method, builder, prototype, and singleton pattern. We will discuss the abstract
    factory pattern in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Structural patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The structural design patterns typically deal with the relationship between
    the components, such as objects or classes, so that it is easier to make these
    entities work together in a larger and more complex system. Some examples of structural
    design patterns include adapter, composite, decorator, facade, flyweight, proxy
    pattern, and so on. In this chapter, we will see a Pythonic implementation of
    the adapter pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a nutshell, concurrency means simultaneously performing multiple things.
    Concurrency enables your application to execute one task (for example, updating
    a database) while it is also working on something else (such as responding to
    a user query). Concurrency design patterns, in general, deal with the multi-threaded
    programming paradigm. The following is a partial list of concurrency patterns:
    active object, balking, monitor object, double-checked locking, and so on. As
    mentioned before, we will not talk about any of the concurrency patterns in this
    book. That said, [Chapter 9](ch09.html "Chapter 9. Improving Performance – Part
    Two, NumPy and Parallelization"), *Improving Performance – Part two, NumPy and
    Parallelization* will introduce you to some aspects of multi-threaded programming
    in Python. Visit the wiki for more information at [https://en.wikipedia.org/wiki/Concurrency_pattern](https://en.wikipedia.org/wiki/Concurrency_pattern).'
  prefs: []
  type: TYPE_NORMAL
- en: Python language and design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks to the high-level built-in language features in Python, many of the formal
    design patterns are easy to implement. In some cases, the patterns appear so natural
    to the language that it becomes tough to realize them as formal design patterns.
    For example, an iterator pattern can be realized by using any iterable object,
    such as lists, dictionaries, and so on. Let's quickly review such language features
    or paradigms in this section. It is not an exhaustive list, but we will cover
    some important aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The idioms that you are about to read (first-class functions, closures, and
    so on) might sound onerous. But do not get overwhelmed by these terms! If you
    are a Python programmer, it is very likely that you have already used many of
    these features knowingly or unknowingly. If these idioms mean nothing to you at
    the moment, skip ahead to the next section where we fast forward to an imaginary
    game scenario. In the upcoming discussion, we will use some of these language
    features. You can then come back to this section whenever you need a handy reference.
  prefs: []
  type: TYPE_NORMAL
- en: First-class functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a programming idiom called **first-class citizens**. In Python, any
    function, a class, a class method, or an object, all qualify as first-class citizens.
    On each of these entities, you can freely perform operations that are typically
    supported on other entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can assign a function to a variable as if you are assigning
    a value to that variable. Likewise, you can pass this function as an argument,
    or get it as a return value of some other function. Any programming language that
    supports such operations on functions is said to have first-class functions. The
    following is a simple piece of code that illustrates what we can accomplish with
    a first-class function in Python. In this example, a function, `test`, is assigned
    to a variable, `x`. After the assignment, the function can be called either `x()`
    or as `test()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example that illustrates the first-class function feature.
    It shows how we can pass the same function, `test`, as an argument to another
    function, called `some_function`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's see what we can do with the other first-class entity, Python classes.
  prefs: []
  type: TYPE_NORMAL
- en: Classes as first-class objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like functions, Python classes are first-class citizens. They can be passed
    around as an argument, assigned to variables, or returned from a function. Here
    is an example where a class, `Foo`, is assigned to a variable `bar`. After this
    assignment, you can use `bar` to create an instance of `Foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will not be using closures in this chapter. It is a bit of an advanced topic
    that is included for completeness. You can optionally skip the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Take any function in Python that defines some local variables. You can use these
    variables inside the function, but those can not be accessed by the outside world
    (unless you return it from the function). In some sense, the functions can be
    considered as closed. When the function executes, it uses these local variables;
    when the function is done, the local variables go out of scope. Their job is done,
    that's the end of the story. Now what if you want a function that keeps its local
    environment at the time it was created?
  prefs: []
  type: TYPE_NORMAL
- en: 'We want some way to wrap this function along with its local environment. It
    could be better explained with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Closures](img/B05034_06_46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`modified_number` is a nested function within the function `initial_number`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This nested function uses a local variable, `x`, which is in the scope of the
    top-level function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the main program, we create `foo`, which is the return value of `initial_number`.
    But look at the return value of the `initial_number` function. It returns the
    nested function, `modified_number`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What this means is that the `foo` variable becomes the nested function, `modified_number`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What did we achieve here? We accomplished two things—first, it enabled access
    to a nested function from the main program, and second, the nested function still
    has the original working environment we used while instantiating `initial_number`.
    In this example, the working environment refers to the `x` argument with a value
    of `100`, passed to this function. The following is the program output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Observe that the value of `x` remains unchanged. Any subsequent calls to `foo`
    retain this original local environment, which is used by the nested function `modified_number`.
    Likewise, you can create another instance of `initial_number` with a different
    value of `x`. This is called a closure in Python. Closures can be used to realize
    design patterns such as the observer pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's review some built-in functions and decorators that would come in handy
    while implementing some design patterns. Again, it is not a complete list, but
    enough to aid us in the upcoming discussion on design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Class method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A class method (`@classmethod`) is something that you can call without the need
    to create an instance of that class. Unlike a regular instance method, which takes
    the instance of the class (`self`) as its first argument, a class method takes
    the class as its first argument. The decorator `@classmethod` is just one convenient
    way to create a class method. We will see how to use a class method in the discussion
    on simple factory.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `@abstractmethod` decorator is used to indicate that the given method is
    abstract and must be reimplemented in subclasses. Recall that we have already
    used this to implement `AbstractGameUnit.info()` as an abstract method using this
    decorator. See the *Abstract base classes in Python* section in [Chapter 1](ch01.html
    "Chapter 1. Developing Simple Applications"), *Developing Simple Applications*
    for further details. In this chapter, we won't be using this decorator.
  prefs: []
  type: TYPE_NORMAL
- en: The __getattr__ method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python automatically calls the `__getattr__` method when you try to access an
    instance attribute that is not already defined in your class. You can implement
    `__getattr__` in your class, and use it to add special handling code for all such
    undefined attributes. The use of this method will be later illustrated in the
    adapter pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Duck typing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The term **duck typing** is often exemplified as, *if it swims and quacks like
    a duck, then we will treat that object as a duck*. Let''s see what this means
    with a simple example. We have a class, `Knight`, with the methods `move` and
    `attack`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A function takes an instance of `Knight` as an argument, and calls these methods
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: However, the function does not check whether the input argument is really an
    instance of the `Knight` class. As long as the object has the `move` and `attack`
    methods, it will not complain. Thus, in duck typing, the language does not make
    any verification of the object. The only thing it cares about is whether or not
    it can call certain attributes using that object. One advantage of duck typing
    is code reusability. You can reuse the `do_something` function in some other code
    by passing an object of a different class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine a `Lion` class that implements the `move` and `attack`
    methods. You would like to reuse the aforementioned `do_something` function in
    some other project that is already using this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `do_something` function will work just fine as long as the input object
    has the `move` and `attack` methods defined. How does this all translate to a
    design pattern discussion? Other programming languages, such as Java, define a
    formal interface in the code to implement certain design patterns, such as the
    abstract factory pattern. In C++, an abstract base class is defined with pure
    virtual functions. In Python, we have an option to use duck typing instead of
    implementing an interface or an abstract base class. For clarity on the design
    pattern itself, you may still want to document such an abstract base class or
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Python, we could still use Java-style interfaces. The **Zope** web framework
    (not covered in this book) is a good example. Visit the following link for more
    information: [https://docs.zope.org/zope.interface/README.html](https://docs.zope.org/zope.interface/README.html).
    Also, see a note in the abstract factory discussion later that shows how to enforce
    an interface in Python.'
  prefs: []
  type: TYPE_NORMAL
- en: Duck typing offers a lot of freedom to programmers, so much freedom that it
    has the potential to introduce bugs that are difficult to notice just by looking
    at the code. But such errors can be detected with extensive unit testing. Another
    way to reduce such problems is to enforce strict coding standards and documentation.
    For example, you can create some custom coding standards that can avoid confusion
    arising due to duck typing.
  prefs: []
  type: TYPE_NORMAL
- en: With this basic introduction to some key language features, let's move on and
    discuss how to implement some design patterns, and what problems they address.
  prefs: []
  type: TYPE_NORMAL
- en: Structure of the rest of the chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before diving into the discussion on design patterns and their implementation,
    let''s first lay out a strategy for the rest of the discussion. As mentioned before,
    we will review the strategy pattern, the simple and abstract factory patterns,
    and the adapter pattern. The discussion on design patterns will be roughly structured
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with a formal definition of the pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Present an imaginary scenario where a new feature is requested
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Talk about the problem encountered in introducing this new feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make an attempt to solve this problem, quickly realizing that we need to rethink
    the design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The solution(s) to the problem using the design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a few design patterns, we will discuss two approaches to solving the problem.
    A traditional approach that resembles the one followed in languages like C++,
    and the other, the Pythonic approach.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Skip the traditional solution if you are interested only in the Pythonic approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of files from the supporting code bundle that will
    be reviewed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Structure of the rest of the chapter](img/B05034_06_47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is also worth noting that we will not be developing a full-fledged game application.
    The idea is to use this game theme as an aid to understanding some design patterns.
    The code used in this chapter is quite simple. While most of the code is illustrated
    in the upcoming discussion, you can also download and review the source from the
    supplementary code bundle for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Fast forward – Attack of the Orcs v6.0.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's fast forward to a future imaginary version of the game!
  prefs: []
  type: TYPE_NORMAL
- en: '| *This imaginary version is one of the most downloaded open source Python
    applications. Now you have a team of developers helping you with application development.
    The game has evolved quite a bit. It is no longer a simple application where you
    gain control of a hut by defeating the enemy. It is now a turn-based fantasy game,
    where the player and the enemy take turns attacking each other, or use that turn
    to move towards or away from the opponent.**You have introduced several new game
    missions, and have redesigned and refactored the code to accommodate the new requirements.
    In the most recent version, you have the following game characters: Knight, Orc
    Rider, and Elf Rider.* |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An **Elf** is an imaginary supernatural mythical being. Read the *The theme
    of the book* section in [Chapter 1](ch01.html "Chapter 1. Developing Simple Applications"),
    *Developing Simple Applications* for some references on Elves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each game character in this version has an ability to attack the enemy, move
    towards or away from the enemy, or get healed inside a hut. Let''s not worry about
    the actual logic that implements these features in the application. We shall rather
    focus on the high-level design of the application. The following pseudo-UML diagram
    shows various classes and a few of their public methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fast forward – Attack of the Orcs v6.0.0](img/B05034_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As indicated in [Chapter 1](ch01.html "Chapter 1. Developing Simple Applications"),
    *Developing Simple Applications*, we will loosely follow the UML representation.
    We referred to it as a pseudo-UML schematic. An explanation for the convention
    used here is in order. Each class in the schematics is represented by a rounded
    rectangle. It shows the class name followed by its attributes. The plus sign (`+`)
    before the attribute indicates it is public. A protected or private method is
    generally represented with a negative sign (`-`). For ease of illustration, only
    a few relevant public attributes will be listed.
  prefs: []
  type: TYPE_NORMAL
- en: As illustrated in the class diagram, all the game characters inherit from a
    common superclass, `AbstractGameUnit`. Each of the subclasses has its own implementation
    of `info()` and `attack()`. In other words, each subclass has its own way of attacking
    the enemy. Further assume that in the aforementioned version, all the subclasses
    use a common `move()` method defined in the superclass. This could be better imagined
    if you see the game instructions in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following screenshot that shows how the player will be prompted to
    perform a move:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fast forward – Attack of the Orcs v6.0.0](img/B05034_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Cool! I want to play this new game scenario. Where is the source code?**'
  prefs: []
  type: TYPE_NORMAL
- en: The intention here is not to develop the full game logic. This is an imaginary
    scenario that is used just to highlight some commonly encountered problems in
    application development. With this scenario, we will see how design patterns could
    help tackle such problems. No code has been provided to actually "play" this new
    game. The supporting code illustrates how to implement various design patterns
    discussed here.
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen from the command-line output, it gives the player a choice to
    move in one of four directions. It also indicates what lies ahead in each direction.
    In this particular case, the player decides to go South, but this movement is
    restricted by a fence.
  prefs: []
  type: TYPE_NORMAL
- en: Strategy pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A strategy design pattern is a behavioral pattern that is used to represent
    a family of algorithms. An algorithm within such a family is represented as a
    strategy object. The pattern enables easy switching between different strategies
    (algorithms) of a particular family. This is generally useful when you want to
    switch to a different strategy at runtime. We will revisit this definition towards
    the end of the discussion on strategy pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Strategy scenario – The jump feature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| *There is a high priority* *feature request. Rather, it is a complaint. The
    users just hate the movement restriction imposed by the fence. Now even Sir Foo
    has joined the protest...* |'
  prefs: []
  type: TYPE_TB
- en: '![Strategy scenario – The jump feature](img/B05034_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| *Rather than removing the fence from the scenario, how about a new feature
    that enables units to jump over the fence or any similar obstacle?* |'
  prefs: []
  type: TYPE_TB
- en: 'You have introduced a new method, `jump()`, in the superclass `AbstractGameUnit`.
    All the classes inherit this method, as shown in the following class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategy scenario – The jump feature](img/B05034_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The fence no longer prevents the player from moving around. The new jump option
    enables crossing the fence without any problem. That was easy, wasn't it? Everyone
    is happy (especially Sir Foo)!
  prefs: []
  type: TYPE_NORMAL
- en: Strategy – The problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's fast forward to a few more major releases of the application.
  prefs: []
  type: TYPE_NORMAL
- en: '| *You have introduced two new imaginary characters to the game, a Dwarf and
    a Fairy, offering unique skills. For example, the Fairy has powers to heal nearby
    injured units in your army, and the Dwarf units offer a solid line of defense
    against enemy attack. With this, the number of application downloads per week
    has now reached a new high. However, there is a new problem that the users have
    reported. Let''s hear it from The Great Dwarf:* |'
  prefs: []
  type: TYPE_TB
- en: '![Strategy – The problem](img/B05034_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Do you see the problem here? The jump feature has an unwanted side effect.
    It allows even a Fairy or a Dwarf to jump over the fence. The Knight, ElfRider,
    and OrcRider are all mounted units. It is easier to imagine these units jumping
    over the fence. However, it is not intuitive to think this way for a game character
    like a Dwarf. We encounter this issue because all the classes use the default
    implementation of the `AbstractGameUnit.jump` method. This is shown in the following
    class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategy – The problem](img/B05034_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Strategy – Attempted solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Dwarf and Fairy game units should not have the jump feature. So what can
    we do here? The Fairy has something to say:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategy – Attempted solution](img/B05034_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using inheritance is certainly one approach. You can override the `jump` method
    and make it a no operation inside the new classes. However, in the next release,
    you are planning to introduce a number of new characters that are not supposed
    to jump, or need to jump differently. Some of the new classes are represented
    in the following class diagram. All of these need to override and implement their
    own logic.
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategy – Attempted solution](img/B05034_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The jump feature is just one of the many things where you will see this problem.
    We don't even need to look beyond what we already have. In the preceding diagram,
    look at the `move` and `attack` methods. Do you see the same problem brewing?
  prefs: []
  type: TYPE_NORMAL
- en: The game characters are evolving. They have their own rules to move. For example,
    a `Knight` riding a horse may cross a river in two turns, whereas a `DwarfFighter`
    would need 10 turns for the same task.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, each unit has its signature style for attacking the enemy. An old
    `Wizard` in your army can cast magical spells on the enemy. The `ElfRider` character
    attacks twice in a single turn using a bow and arrows. The `DwarfFighter` character
    uses a hammer to attack, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: If we continue to use the inheritance principle here, it would soon become a
    maintenance nightmare. Why so? This is because each class that you write is responsible
    for implementing and maintaining its own logic for its move, jump, and attack
    abilities. Initially, you may see this as a trivial issue, where overriding the
    functionality in the subclasses just works. But with a growing number of character
    types and their ever-growing set of abilities (move, jump, swim, defend, hide,
    regenerate, and so on), this will turn out to be a daunting task. The code might
    also get repeated across classes.
  prefs: []
  type: TYPE_NORMAL
- en: Every small change to the logic will require you to update the corresponding
    methods in all the classes. It could also invite new bugs if you miss out a few
    methods during the update process. We need to rethink the design to accommodate
    future requirements easily. Let's do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Strategy – Rethinking the design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What can we do in such situations? Observe that the implementation code defining
    these abilities varies across subclasses. In this example, the `DwarfFighter`
    cannot jump whereas a `Knight` jumps using a horse.
  prefs: []
  type: TYPE_NORMAL
- en: The first question to ask is why do these classes carry the burden of defining
    abilities? Can this be outsourced to a different class or a function? We will
    redesign the `AbstractGameUnit` class (and its subclasses) so that the various
    abilities are now handled by objects dedicated to those tasks. In other words,
    we will use object composition to take this load off `AbstractGameUnit` and its
    subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recall that in [Chapter 1](ch01.html "Chapter 1. Developing Simple Applications"),
    *Developing Simple Applications*, we used object composition in the `Hut` class
    where its `occupant` was represented by a different object. Object composition
    allows you to represent a complex object by putting together simple objects. Just
    say it out loud, a Knight has-the ability to move, a Knight has the ability to
    jump, and so on. Each of these abilities will be represented by separate objects.
  prefs: []
  type: TYPE_NORMAL
- en: How do we implement this new design? We will discuss two approaches to solving
    this problem. The first one is more of a classical approach that resembles the
    one typically followed in other languages, such as C++. If you have such a development
    background, this approach will look more familiar. The second approach is more
    Pythonic. It uses first-class functions, a language feature in Python. This second
    approach will make the whole problem appear trivial. If you are not interested
    in the traditional approach, skip ahead to the Pythonic solution for the strategy
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Strategy solution 1 – Traditional approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding section, we decided to create dedicated objects to represent
    abilities such as jump. Let''s draw a class diagram that explains this better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategy solution 1 – Traditional approach](img/B05034_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is a more verbose description of what is represented in the preceding
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: Three new classes, `AttackStrategy`, `MoveStrategy`, and `JumpStrategy`, now
    handle the logic for the `attack`, `move`, and `jump` methods respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class `AbstractGameUnit` is now composed of the instances of these classes,
    namely `attack_strategy`, `move_strategy`, and `jump_strategy`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `AbstractGameUnit.jump` method just calls `jump_strategy.jump()`. A similar
    implementation for the `move` and `attack` methods is followed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As the game characters need their on-jump implementation, we will create subclasses
    of `JumpStrategy`. For example, a subclass `CanNotJump` can be used for game units
    that are unable to jump. This is illustrated in the following class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategy solution 1 – Traditional approach](img/B05034_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Revisiting the strategy pattern definition**:'
  prefs: []
  type: TYPE_NORMAL
- en: We started the discussion on strategy pattern with a definition. This design
    pattern represents a family of algorithms. Take a closer look at the preceding
    class diagram. The `JumpStrategy` and its subclasses represent a family of algorithms.
    Functionality defined in each of these classes is equivalent to an algorithm or
    a strategy. These classes are part of the same family, because the execution of
    any of the algorithms is related to a jump. As an example, the `PowerJump` class
    defines an algorithm different from the `HorseJump` class. Likewise, `MoveStrategy`
    defines a family of algorithms for movement, and `AttackStrategy` for attacking
    the enemy. There is one last missing piece to complete the strategy pattern. We
    need a way to dynamically switch between algorithm families. Let's see how to
    implement this next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the new class, `JumpStrategy`. It now defines the jump behavior
    that was earlier defined in `AbstractGameUnit`. The overall logic is represented
    by the following schematic diagram and the code fragments. For easier understanding,
    we will only discuss the methods related to the jump ability:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategy solution 1 – Traditional approach](img/B05034_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Thus, we have a family of algorithms represented by `JumpStrategy` and its
    subclasses. Here is the related code fragment that shows the classes `AbstractGameUnit`
    and `DwarfFighter`. The supporting file, `strategypattern_traditional.py`, contains
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategy solution 1 – Traditional approach](img/B05034_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The instance variable `self.jump_strategy` is used to represent a strategy or
    an algorithm for the jump behavior. The subclasses of `AbstractGameUnit` get to
    choose any jump strategy from the family of algorithms defined by the `JumpStrategy`
    class and its subclasses. For example, the `DwarfFighter` subclass can use the
    algorithm defined in the `CanNotJump` class as its jump strategy, and so on. The
    `AbstractGameUnit.jump` method is now an API method for the calling code. This
    method relies on the strategy object for the actual jump implementation. It simply
    calls the corresponding method of that strategy object, as shown in the preceding
    class diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'The subclass `DwarfFighter` in this simple example just overrides the abstract
    method info. You may include some additional customization to this class. Now
    let''s look at the family of algorithms for the jump feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategy solution 1 – Traditional approach](img/B05034_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As mentioned earlier, the purpose is not to develop a full-fledged game application,
    but just to understand the important concepts in application development. In this
    trivial example, we just print an informative message to illustrate the concept.
    In a practical implementation, these are the classes where your algorithms need
    to be defined. Finally, let''s review the calling code that instantiates a game
    character, and dynamically sets up different jump strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategy solution 1 – Traditional approach](img/B05034_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We start by creating `jump_strategy`, an object that defines how the unit should
    jump. In this case, it is passed as an argument to the `__init__` method for `DwarfFighter`.
    Alternatively, you could also define a default strategy object in this class,
    as we know the default behavior for this class (the unit cannot jump). You can
    then call `set_jump_strategy` to switch to a different jump algorithm, as illustrated
    in the code fragment. Here is the output of this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategy solution 1 – Traditional approach](img/B05034_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Strategy solution 2 – Pythonic approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What we discussed in the last section was more of a traditional approach, typically
    followed in programming languages such as C++. Given the flexibility that the
    Python language offers, there is no real need to define the various strategy classes
    as illustrated in the previous solution. We will exploit first-class functions,
    the language feature discussed earlier. Let''s look at the revised code. You can
    also find this code in the `strategypattern_pythonic.py` file in the code bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategy solution 2 – Pythonic approach](img/B05034_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding code, we have used the Python language feature that supports
    assigning a function (`jump_strategy`) to a variable (`self.jump`). Why do we
    do this? It will become clear when we review the next code fragment. Before that,
    let's quickly discuss the preceding code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What exactly do we accomplish with the following assert statement?**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This statement is from `AbstractGameUnit.__init__` method in the earlier code
    snippet. Before assigning the function to a variable, we need to make sure that
    it is indeed a function. The assertion prevents further execution of the code
    if this condition is not met. The idea is simple. You want to make sure that `jump_strategy`
    is a callable object. Any callable object defines a built-in `__call__()` method.
    The `collections.abc.Callable` class is an abstract base class for all the classes
    that provide a built-in `__call__()` method. In the `assert` statement, we check
    whether `jump_strategy` is an instance of this `Callable` class. For Python 2.7.9,
    this class should be imported directly as `collections.Callable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, let''s review the code fragment that instantiates a game character
    (`dwarf`), and dynamically sets up different jump strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategy solution 2 – Pythonic approach](img/B05034_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Compare this code with the first approach discussed earlier. There is a difference.
    In the previous solution, while instantiating `DwarfFighter`, we passed an instance
    of the class `CanNotJump` that deals with the jump behavior. Here, we pass the
    function `can_not_jump` as an argument, just like any simple variable. To dynamically
    change the `jump` algorithm, we just assign `dwarf.jump` to `power_jump`, as shown.
    Now when we call `dwarf.jump()`, it actually executes the code in the `power_jump()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Remarks on the Pythonic way**:'
  prefs: []
  type: TYPE_NORMAL
- en: What we just saw was a cool Pythonic way that made things very easy. If you
    are coming from a C++ or Java programming background, at first you might feel
    uncomfortable with the freedom that Python offers. For example, there could be
    situations where a programmer mistakenly treats a function argument as a simple
    variable, leading to potential bugs. But this should not stop you from using this
    excellent language feature. To avoid such problems, you should document the code
    well so that the purpose of each input argument is clear.
  prefs: []
  type: TYPE_NORMAL
- en: Simple factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A simple factory is generally not viewed as a formal design pattern, but you
    will find it quite useful in your day-to-day programming. The understanding we
    gain at the end of this section will be helpful in the discussion on a more formal
    pattern called abstract factory design pattern. Let's start with the definition
    of a simple factory.
  prefs: []
  type: TYPE_NORMAL
- en: A factory encapsulates the instance creation piece. The client code doesn't
    need to know the logic of instance creation. It just knows that whenever it needs
    an object of a specific type, the factory is the go-to place. Any class, or function,
    or class method that is used to construct such objects is often referred to as
    a factory. A simple factory is something you will use quite often. It is typically
    considered a better object-oriented technique than a formal design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Simple factory scenario – The recruit feature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| *Recall that we had fast-forwarded the game to an imaginary future version
    called Attack of the Orcs v6.0.0\. This version introduced another much-anticipated
    feature that enabled recruiting new units to fight against the enemy.* |'
  prefs: []
  type: TYPE_TB
- en: 'Here is the initial version of the `recruit` method of a new class, `Kingdom`.
    Other methods are not shown. Let''s assume those exist. Further assume that the
    player or the enemy is allowed to recruit any of the following game characters:
    `ElfRider`, `Knight`, `DwarfFighter`, `OrcRider`, and `OrcKnight`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple factory scenario – The recruit feature](img/B05034_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `recruit` method has the logic to create a game unit based on user input
    (the `if..else` block). Once the character is created, `Kingdom` pays for the
    hiring fees (`pay_gold`), and a central database is updated to reflect the new
    addition to the army (`update_records`).
  prefs: []
  type: TYPE_NORMAL
- en: Simple factory – The problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| *As expected, users liked this* *feature, and now want the ability to recruit
    even more unit types. Let''s see what Sir Foo has to say:* |'
  prefs: []
  type: TYPE_TB
- en: '![Simple factory – The problem](img/B05034_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s add new recruit types, and to avoid Sir Foo''s wrath, remove `OrcKnight`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple factory – The problem](img/B05034_06_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As can be seen in the preceding code snippet, this is already becoming difficult
    to maintain. Tomorrow, you may decide to support even more units, or remove some
    of the existing ones. How do we handle this problem? Let's see that next.
  prefs: []
  type: TYPE_NORMAL
- en: Simple factory – Rethinking the design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What can we say about that big `if..else` block in the `recruit` method? It
    is subject to change. The rest of the code in the method is just the bookkeeping
    (for example, updating records) and remains unchanged. What if we take out the
    variable piece of code and give it a new home? It will take the load off the `recruit`
    method so that you don't need to open it for editing every time there is a change
    in the requirements. The next question to ask is where do we put this code?
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple factory – Rethinking the design](img/B05034_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Yes Fairy, that is an option. You can create a new method in the `Kingdom` class,
    and dump all this object creation code in there.
  prefs: []
  type: TYPE_NORMAL
- en: But imagine a game scenario where there is a grand galactic army, represented
    by a `GalacticArmy` class. This class needs a way to recruit or get various game
    characters. It is not at all related to the `Kingdom` class. Thus, we won't be
    able to reuse the object creation code in `Kingdom.recruit`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's free the `Kingdom` class of the responsibility for creating new units.
    Once again, we will use the object composition principle. Let there be a new class
    (or even a function) that encapsulates the instance creation piece. We will call
    this a simple factory. The client code (the `Kingdom` or `GalacticArmy` class
    in this discussion) can now use this factory to get specific types of objects.
  prefs: []
  type: TYPE_NORMAL
- en: Simple factory solution 1 – Traditional approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is now time to implement the simple factory. Let's review a traditional approach
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the bare minimum code, without any exception handling. The purpose is
    just to illustrate a simple factory using a style that somewhat resembles a C++
    implementation. You can make it more robust as an exercise. The code can be found
    in the `simplefactory_traditional.py` file. This example is written as a single
    module for ease of understanding. Ideally, you should refactor this, and put classes
    in their own modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following reworked code. We start with the new class, `UnitFactory`,
    which encapsulates the object creation piece:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple factory solution 1 – Traditional approach](img/B05034_06_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding code, we have refactored out the big `if..else` clause in
    the `Kingdom.recruit` method discussed earlier, and put it in the `create_unit`
    method of the `UnitFactory` class. The `create_unit` method only has a single
    responsibility to create and return an instance of a game character for the given
    input argument (`unit_type`). The following is the `Kingdom` class after this
    refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple factory solution 1 – Traditional approach](img/B05034_06_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `self.factory` instance represents `UnitFactory`. In the `recruit` method,
    the responsibility for creating game characters is delegated to this factory object.
    The `pay_gold` and `update_records` methods are just shown for completeness. Let''s
    not worry about the logic inside these two methods. They remain unchanged. Finally,
    the following is one way to use the factory. The code is self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple factory solution 1 – Traditional approach](img/B05034_06_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What we have not shown in this example is the actual implementation of the concrete
    product classes that our factory uses to create products, such as `ElfRider`,
    `Knight`, and so on. These classes are going to be similar to the ones we have
    discussed so far. For example, all these concrete classes can be subclasses of
    `AbstractGameUnit`. These details were not shown in the example we just covered.
    However, this is not the only way to implement a simple factory. In Python, we
    can deal with this problem in other ways as well. One such approach will be discussed
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Simple factory solution 2 – Pythonic approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is one problem with the solution presented in the previous section. You
    still need to maintain the `if..else` block in `create_unit`. Another thing to
    ask is, do we really need to instantiate `UnitFactory`? Depending on your application,
    the answer could be yes or no. In this example, the `create_unit` code would be
    identical for each instance of the factory you create. So, we do not really need
    an instance of `UnitFactory`. Let's discuss how to implement a simple factory
    without actually instantiating it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What is illustrated here is not the only way to implement a simple factory.
    The source code is available in the supporting material as `simplefactory_pythonic.py`.
    Depending on the type of problem you are dealing with, you can tweak this approach
    further, and come up with a different solution. For example, you can choose a
    factory instance, and access its methods as normal instance methods. This approach
    is illustrated in the `simplefactory_pythonic_alternatesolution.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the reworked `UnitFactory` class from the file `simplefactory_pythonic.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple factory solution 2 – Pythonic approach](img/B05034_06_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Earlier in the chapter, we reviewed some Python language features that come
    in handy for design patterns. Let''s see how first-class classes and class methods
    can be used in a simple factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`units_dict` is a Python dictionary object declared as a class variable (for
    the class `UnitFactory`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python classes are first-class objects. So we can simply put them as values
    of the dictionary, `units_dict`. The dictionary keys can be unique strings of
    your choice. Just make sure that the calling code knows which key corresponds
    to which class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method `create_unit` is defined as a class method using the decorator `@classmethod`.
    What this means is that the first argument passed to this method is the class
    itself (denoted by `cls`) instead of being self (an instance of the class).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now look at the `return` statement of the `create_unit` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we access `units_dict`, a class variable, as `cls.units_dict`, and get
    the value for a particular key given as an input argument. This can be better
    explained with an example. Assume that the given key is `elfrider`. The corresponding
    value in the dictionary is the `ElfRider` class. So, the `create_unit` method
    will return `ElfRider()`, which is an instance of the `ElfRider` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compare this code with the one we saw in the previous heading, *Simple factory
    solution 1 – Traditional approach*. As can be noticed, the number of lines of
    code has not been reduced significantly. But the code clarity is much better here.
    You still need to maintain the dictionary object (`units_dict`) for all future
    requirements, which is relatively easy compared to maintaining the `if..else`
    clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now observe the `Kingdom` class. It has just a few changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple factory solution 2 – Pythonic approach](img/B05034_06_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's review the preceding code snippet
  prefs: []
  type: TYPE_NORMAL
- en: First, we assign the `UnitFactory` class to a class variable, `factory`. Again,
    we can do this because Python classes are first-class objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `recruit` method is just a normal instance method of `Kingdom`. The class
    variable `factory` is accessed as `type(self).factory`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, `type(self).factory.create_unit` is equivalent to `UnitFactory.create_unit`.
    We could have directly written it that way, but if a subclass of `Kingdom` defines
    its `factory` as a different class, say `DwarfUnitFactory`, then it will require
    you to write some extra code, such as overriding the `recruit` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, here is the calling code. Notice that we are not creating any `factory`
    instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple factory solution 2 – Pythonic approach](img/B05034_06_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The discussion on the simple factory has set the stage for the formal design
    pattern called the abstract factory pattern. Let's review that next.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract factory pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just learned how to create and use a simple factory in a program. Let's
    go a little further and study a formal pattern known as the abstract factory pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine we have a master factory and some follower factories. Further assume
    that each follower factory is responsible for producing its own trademark products
    (objects). The follower factories are related in some sense. They create products
    that share a common theme. For example, each follower factory produces its own
    version of tomato ketchup. The factories have their own ordering form for their
    product.
  prefs: []
  type: TYPE_NORMAL
- en: 'The customers have a hard time in keeping up with so many forms for ordering
    a tomato ketchup. For example, one factory says you should call it MyRedTomatoKetchup,
    otherwise it won''t understand. So, the master factory says:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *We make products that are like a part of an extended family. Our customers
    would benefit if we can simplify and standardize the procedure to order these
    products from our group of factories. From now on, every follower factory is required
    to implement a common ordering form.* |'
  prefs: []
  type: TYPE_TB
- en: 'The customers benefit, as they just need to know the high-level name tomato
    ketchup and the factory that can supply this product. Let''s put this into programming
    terminology:'
  prefs: []
  type: TYPE_NORMAL
- en: The master factory is an abstract factory, and the follower factories are concrete
    factories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tomato ketchup is an abstract class. Every concrete factory creates its
    custom version of tomato ketchup; we will call this a concrete object (an instance
    of a concrete class).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standardization procedure referenced earlier is called an interface. The
    abstract factory declares such an interface (or in Python terms, a set of abstract
    methods) that is required to be implemented by the concrete factories for creating
    families of concrete objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The customer is the client code. It doesn't need to know the details of the
    concrete object received from a concrete factory. It just needs to have knowledge
    of the abstract class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Java programming language has a provision to create an abstract type called
    interface. If a class implements an interface, it must implement all the methods
    described by that interface. For more information on interface in the Java language,
    visit the wiki page: [https://en.wikipedia.org/wiki/Interface_(Java)](https://en.wikipedia.org/wiki/Interface_(Java)).
    In Python, there is no such formal provision to create and implement an interface.
    Instead, we can use inheritance, where concrete factories inherit from the abstract
    factory. Instead, we can use the first-class features offered by Python, as discussed
    earlier. Let''s see these next.'
  prefs: []
  type: TYPE_NORMAL
- en: Quite a mouthful? Let's dig deeper into the abstract factory pattern with a
    game scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract factory scenario – An accessory store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| *Imagine* *you have implemented a new feature that enables buying accessories
    for your army. At the moment, you can buy an armored jacket or a gold locket,
    as shown in the following code fragment:* |'
  prefs: []
  type: TYPE_TB
- en: '![Abstract factory scenario – An accessory store](img/B05034_06_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'More choices for armor and lockets were added as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory scenario – An accessory store](img/B05034_06_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| *You reworked the preceding piece of code, and implemented a simple factory
    instead. This factory would produce all the accessories for the game characters.
    In this example, it would return armor and locket objects.* |'
  prefs: []
  type: TYPE_TB
- en: 'The reworked code, which implements a simple factory, is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory scenario – An accessory store](img/B05034_06_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Kingdom` class and the main execution code is shown next. The `Kingdom`
    class has an instance variable, `self.factory`, which represents our simple factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory scenario – An accessory store](img/B05034_06_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `self.factory` variable is used to create `armor` and `locket` instances,
    as indicated in the `buy_accessories` method.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As illustrated in the section on simple factories, the factory can also be specified
    as a class attribute accessed as `Kingdom.factory`, instead of creating an instance,
    `self.factory`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory scenario – An accessory store](img/B05034_06_49.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| *The changes you made simplified the implementation. Looks like Sir Foo is
    quite happy with his new Iron jacket, however, that doesn''t seem to be the case
    with others! There is a* *new problem...* |'
  prefs: []
  type: TYPE_TB
- en: Abstract factory – The problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| *One size* *doesn''t fit all! The DwarfKingdom is now using this AccessoryFactory,
    and has reported problems with the products:* |'
  prefs: []
  type: TYPE_TB
- en: '![Abstract factory – The problem](img/B05034_06_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| *The Great Dwarf has reason to be annoyed. The factory does not support customization
    for the products it creates. How do we address this?* |'
  prefs: []
  type: TYPE_TB
- en: This is one scenario where we can use the abstract factory pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract factory – Rethinking the design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Observe the following class diagram. It represents a typical abstract factory
    pattern, our approach to solve the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory – Rethinking the design](img/B05034_06_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s review the components of the UML-like diagram presented here, and correlate
    them with the terms used in the earlier definition of an abstract factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DwarfAccessoryFactory`, `ElfAccessoryFactory`: The follower or concrete factories.
    Recall that each concrete factory creates products that share a common theme.
    Here, they create accessories for the game characters. As mentioned earlier, they
    are required to implement standard procedures set by the master factory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AbstractAccessoryFactory`: This is the abstract factory class, or what we
    referred to as a master factory earlier. It defines an interface (a set of abstract
    methods) that must be implemented by the concrete factories. In this case, each
    of the concrete factories is required to implement methods to create armors and
    lockets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, each concrete factory implements the `create_armor` and `create_locket`
    methods. These methods return instances of concrete product classes. Thus, each
    factory creates its own flavor of the products. For instance, `create_locket`
    of `DwarfAccessoryFactory` returns an instance of `DwarfGoldLocket`, whereas the
    same method in `ElfAccessoryFactory` returns an instance of `ElfGoldLocket`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AbstractArmor`, `AbstractLocket`: These are abstract product classes. There
    could be several concrete product types that inherit from these abstract classes.
    For example, the concrete product classes `DwarfGoldLocket` and `SuperLocket`
    inherit from `AbstractLocket`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The client code**: This is not shown in the class diagram. The client code
    doesn''t need to know which concrete product class gives it the desired product.
    It just knows the high-level name of the product (for example, `create_locket`).
    Essentially, it chooses the factory, and invokes the standard API methods, such
    as `create_locket`, to get the required objects. See the next solution section
    for an example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying the design further
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding class diagram shows a classic way of implementing the abstract
    factory pattern. For ease of understanding, let's simplify the problem further.
    We will assume that all the concrete factories define the required methods without
    the abstract factory enforcing the rule (interface) to do so.
  prefs: []
  type: TYPE_NORMAL
- en: With this assumption, we could even remove the `AbstractAccessoryFactory` class
    from the design, and just have the concrete factories. Recall that we discussed
    duck typing at the beginning of this chapter. So as long as the concrete factories
    implement the required methods, the client code (see `Knight.buy_accessories`
    in the next example) won't complain.
  prefs: []
  type: TYPE_NORMAL
- en: For conceptual understanding, we will retain the inheritance hierarchy in the
    upcoming discussion. We will call this class simply `AccessoryFactory`, and won't
    define `create_armor` and `create_locket` as abstract methods. Enforcing an interface
    will require some minor adjustments in the code. We will briefly discuss this
    as an optional or advanced topic at the end of the next section, where we look
    at the actual implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract factory solution – Pythonic approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we saw a representative class diagram that shows the
    implementation details for the abstract factory pattern. We will discuss only
    a Pythonic solution for implementing this pattern. Since we have already covered
    the simple factory in depth, the abstract factory pattern is just a few steps
    away. We will limit our discussion to some of the important classes. Look at the
    `abstractfactory_pythonic.py` file in the supporting code for the complete source.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Kingdom` and `DwarfKingdom` classes are shown next. The code is self explanatory,
    and was pretty much discussed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory solution – Pythonic approach](img/B05034_06_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at the `AccessoryFactory` class (see a note on design simplification
    under the previous heading, *Simplifying the design further*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory solution – Pythonic approach](img/B05034_06_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is very similar to the `UnitFactory` class we reviewed in the section on
    simple factory implementation. The only difference is that the factory produces
    two separate products, `armor` and `locket`. So, we have two different class methods
    (factory methods) for creating each of the concrete products. The `armor_dict`
    dictionary holds armor-related concrete classes as its values, and `locket_dict`
    is used for the locket-related classes. Both of these are defined as class variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet is for `DwarfAccessoryFactory`, one of the concrete
    factories. Here, we have only redefined the `armor_dict` and `locket_dict` dictionaries.
    Nothing else changes. Likewise, you can define other concrete factories such as
    `ElfAccesoryFactory`. If you want a strict abstract factory pattern implementation,
    you should also enforce an interface in the concrete factory. This is briefly
    discussed at the end of this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory solution – Pythonic approach](img/B05034_06_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The last piece of the puzzle is the main execution code. It creates two kingdoms,
    the first is a default `Kingdom`, and the second is a kingdom of *The Great Dwarfs*—`DwarfKingdom`.
    This is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory solution – Pythonic approach](img/B05034_06_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Observe that `buy_accessories` is invoked for both the kingdoms with the same
    arguments, `ironjacket` and `goldlocket`. But what each kingdom gets as the concrete
    product depends on the factory chosen. For example, as the `DwarfKingdom` has
    selected `DwarfAccessoryFactory` as its factory, for the abstract product named
    `ironjacket` it would get an instance of `DwarfIronJacket`. The following is a
    sample output of the code in the `abstractfactory_pythonic.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory solution – Pythonic approach](img/B05034_06_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Advanced topic – enforcing an interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section illustrates one way of enforcing an interface in Python. If this
    does not mean anything to you right now, just ignore this and move on to the next
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that for ease of illustrating a Pythonic solution, we had simplified
    the problem. `AccessoryFactory` does not enforce any rule that requires the subclasses
    to implement the `create_armor` and `create_locket` methods. Actually, it is easy
    to do so. If you are using Python 3.3 or higher, you can simply define these methods
    as abstract methods in addition to being class methods, using the two decorators,
    `@classmethod` and `@abstractmethod`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In subclasses such as `DwarfAccessoryFactory`, you just need to implement these
    class methods. For completeness, make `AccessoryFactory` abstract by inheriting
    from `ABCMeta`. Technically, that would confirm the formal design of an abstract
    factory. But if you look at the code inside this method (`create_armor`), it hasn't
    changed a bit. Thus, in this example, declaring an abstract method would help
    only to enforce the rule that subclasses must implement certain methods.
  prefs: []
  type: TYPE_NORMAL
- en: Adapter pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The adapter design pattern enables a handshake between two incompatible interfaces.
    Here, the incompatible interface of a class or a library is transformed into the
    one expected by your client code. This transformation is accomplished by an adapter
    class. The other class with a different interface than what the client expects
    is often referred to as an adaptee.
  prefs: []
  type: TYPE_NORMAL
- en: There are two broad categories of adapter pattern, namely a class adapter pattern
    and an object adapter pattern. In the former, the adapter inherits from the adaptee.
    It is possible to implement a class adapter in Python, as the language supports
    multiple inheritance. However, it is better to choose object composition (has
    a relationship) over inheritance. In the object adapter pattern, the adapter object
    has an adaptee object instead of inheriting from the adaptee class. The object
    adapter pattern helps maintain a loose coupling between the adaptee and the client
    code, wherein the client does not need to have any knowledge of the adaptee interface.
    This offers more flexibility when compared to the class adapter pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming discussion, we will only talk about the object adapter pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Adapter scenario – Elf's distant cousin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| *Let''s fast-forward to an* *imaginary future one more time. A group of developers
    has approached you. They have been working on a similar fantasy game application.
    Given the popularity of your game, they would like to collaborate. It''s a win-win
    situation for both parties. You happily accept this proposal, as it will give
    you access to several game characters in their collection.* |'
  prefs: []
  type: TYPE_TB
- en: Adapter – The problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You begin the integration work, and notice a problem. Let''s hear it from our
    friend, the Elf:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adapter – The problem](img/B05034_06_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code that follows highlights this problem further. What is shown here is
    a simplified version of the new `WoodElf` class that only shows the `leap()` method.
    Assume that all its other methods match our existing interface.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is no correlation between the `jump` method (rather, the jump strategies)
    discussed in the section on *Strategy pattern* with the one illustrated here.
    For easier understanding of the pattern, only the bare minimum code is shown.
    For example, the `AbstractGameUnit` class is not used here. As an exercise, try
    to use the code from the strategy pattern here, and implement an adapter so that
    we can talk to `WoodElf` (the solution is not provided)!
  prefs: []
  type: TYPE_NORMAL
- en: '![Adapter – The problem](img/B05034_06_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adapter – Attempted solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| *The new class* *doesn''t have a leap() method. How can we solve this problem?
    Any thoughts, Fairy?* |'
  prefs: []
  type: TYPE_TB
- en: '![Adapter – Attempted solution](img/B05034_06_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We could have possibly done that, but this code is owned by a third party. If
    they have shared the source, then you can update it. But that is going to be a
    maintenance overhead for you. If you don't have the source code, then you have
    to depend on them to get this method supported. For all these reasons, the solution
    suggested by the Fairy may not be the best way to go forward. That said, the Fairy
    is on the right track! She has a `jump()` method that delegates this to the `leap()`
    method. Let's see how the adapter pattern can help here.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about adding a new class that enables a handshake between these two interfaces?
    Look at the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adapter – Attempted solution](img/B05034_06_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This last code fragment seems to address one issue. We do not need to make
    any changes to the third-party class `WoodElf`. We feed an instance of `WoodElf`
    to the adapter, `WoodElfAdapter`. This adapter class has a `jump` method, which
    calls the `leap` method of `WoodElf`. The client code simply needs to use this
    adapter instance instead of the `WoodElf` instance. However, there are two main
    problems with this solution:'
  prefs: []
  type: TYPE_NORMAL
- en: The adapter class seems to be tied to the `WoodElf` class. What if we have a
    new class, `MountainElf`, which implements the `spring` method as an equivalent
    of the `jump` method?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imagine that the `WoodElf` class has other methods such as `attack`, `info`,
    `climb`, and so on. Some might already be compatible with the existing interface,
    while for others, there is no equivalent. All such methods can be directly called
    without any special processing like what was done for `leap()`. If we follow the
    approach discussed in the preceding code fragment, you will have to define each
    of these methods in the adapter class `WoodElfAdapter`. Without implementing them,
    you won't be able to use the adapter class seamlessly in your client code. That's
    quite a bit of work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is very easy to address both these problems. Let's write a generalized solution
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Adapter solution – Pythonic approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To summarize the problem, a new class, `WoodElf`, provided by third-party developers,
    has a `leap()` method instead of `jump()`. Put another way, it has an incompatible
    interface. We are seeking a solution that doesn't require us to touch the `WoodElf`
    class. We created an adapter, `WoodElfAdapter`, but it had its own shortcomings,
    as discussed in the previous section, *Adapter – Attempted Solution*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s generalize the adapter class further to address these issues. See the
    supplementary `adapterpattern.py` file for the source code. This will be illustrated
    next. First look at the following code fragment, and then we will talk through
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adapter solution – Pythonic approach](img/B05034_06_43.jpg)![Adapter solution
    – Pythonic approach](img/B05034_06_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following things are to be noted in the preceding code screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: The adapter class is renamed as `ForeignUnitAdapter`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first input argument, `adaptee`, represents the instance of the class for
    which we need an adapter. The second argument, `adaptee_method`, is the instance
    method that needs to be adapted (for example, `wood_elf.leap` needs to be interpreted
    as a `jump` method).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we take advantage of the Python first-class functions to assign `adaptee_method`
    to `self.jump`. For example, calling `self.jump()` is now equivalent to calling
    `wood_elf.leap()`. This eliminates the need to create a separate `jump` method
    inside the adapter class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Earlier in the chapter, we learned about the `__getattr__` method. Here, we
    have implemented it in the adapter class `ForeignUnitAdapter`. The client code
    assumes that the adapter object (which represents a third-party game character),
    has defined methods such as `info()`, `attack()`, and `climb()`. The client calls
    these methods using the adapter object. In reality, the adapter class has not
    defined any of them. It relies on `self.foreign_unit` to provide these methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This handling code is written in the `__getattr__` method. Here, `getattr(self.foreign_unit,
    item)` would simply return `self.foreign_unit.item`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can create multiple adapter objects by passing in different instances of
    the game units, and the method that needs to be the adapter. One such example
    is shown in the preceding code fragment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapter – Multiple adapter methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the earlier illustration, we assumed that `self.jump` would be the handling
    adapter method. What if we have multiple methods that need to be an adapter to
    conform to our existing API? You can generalize this implementation further. Here
    is one way to handle multiple methods. This source can be found in the supporting
    code bundle. Look for the `adapterpattern_multiple_methods.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adapter – Multiple adapter methods](img/B05034_06_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the main execution code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adapter – Multiple adapter methods](img/B05034_06_48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, we take advantage of the Python first-class functions. The `set_adapter`
    method uses a built-in method, `setattr()`, to set new attributes for the `ForeignUnitAdapter`
    class. These act as the adapter methods. Alternatively, you can also set the attributes
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provided an introduction to design patterns in Python, an important
    aspect of application development. We started this chapter with an introduction
    and saw how design patterns are classified. Next we reviewed some key features
    offered by the Python language that help simplify several design patterns. With
    practical illustrations, you learned how design patterns can be implemented to
    provide a solution to recurring problems in application development. More specifically,
    you learned about strategy, abstract factory, and adapter patterns. For each of
    these patterns, we first used an interesting game scenario to describe the problem.
    We then discussed how the design pattern can tackle this problem, and further
    implemented the design pattern using a Pythonic approach. For some patterns, we
    also reviewed a traditional approach to implementing the design pattern. Last
    but not the least, we met some of Sir Foo's new friends.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have discussed several important aspects of application development.
    This discussion helped us write better code, make the application more robust,
    and increase the application's life expectancy. In the next three chapters, we
    will learn various ways to improve the performance of the application.
  prefs: []
  type: TYPE_NORMAL
