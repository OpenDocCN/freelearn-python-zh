- en: Chapter 6. Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 设计模式
- en: 'This chapter will introduce you to some commonly used design patterns. Here
    is how the chapter is organized:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向你介绍一些常用的设计模式。以下是本章的组织结构：
- en: We will start with a quick introduction to design patterns, followed by a discussion
    on some Python language features that help to simplify their implementation.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从设计模式的一个快速介绍开始，然后讨论一些有助于简化它们实现的Python语言特性。
- en: 'Next, with the help of a fantasy game theme, we will discuss the following
    design patterns:'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，借助幻想游戏主题，我们将讨论以下设计模式：
- en: Strategy pattern
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略模式
- en: Simple and abstract factory pattern
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单和抽象工厂模式
- en: Adapter pattern
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器模式
- en: For each pattern, a simple game scenario will demonstrate a practical problem.
    We will see how the design pattern can help solve this problem.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个模式，一个简单的游戏场景将演示一个实际的问题。我们将看到设计模式如何帮助解决这个问题。
- en: We will also implement each of these patterns using a Pythonic approach.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将使用Python方法实现这些模式中的每一个。
- en: There are several known design patterns out there. As outlined earlier, we will
    discuss only a few. The idea is not to present a new cookbook on patterns, but
    just to show you how design patterns help solve some commonly encountered problems,
    and how to implement them in Python. Beyond this book, you can explore other traditional
    design patterns and try adding a Pythonic flavor to them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 已知有几种设计模式。如前所述，我们只讨论其中的一些。我们的目的是不提供一本关于模式的全新食谱，而是仅仅展示设计模式如何帮助解决一些常见的问题，以及如何在Python中实现它们。除了这本书之外，你还可以探索其他传统的设计模式，并尝试为它们添加Python风格。
- en: By the way, you are about to get introduced to some new game characters. So
    get ready to learn design patterns with Sir Foo and friends!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，你即将被介绍到一些新的游戏角色。所以准备好和Sir Foo和他的朋友们一起学习设计模式吧！
- en: Introduction to design patterns
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式简介
- en: Let's say that during application development, you stumble upon a problem that
    pops up again and again. Frustrated, you ask your co-developers or a community
    for help. Guess what, you are not alone. Many have encountered a similar problem
    in their code. Luckily, you get a response from someone who has found a solution.
    This solution seemed to have worked reliably on similar problems. You change your
    problematic code so that it conforms to the suggested design, and voila! Your
    problem is resolved!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在进行应用程序开发过程中，你遇到了一个反复出现的问题。沮丧之余，你向你的共同开发者或社区寻求帮助。猜猜看，你并不孤单。很多人在他们的代码中遇到过类似的问题。幸运的是，你得到了一个找到解决方案的人的回应。这个解决方案似乎在类似的问题上工作得很可靠。你修改了有问题的代码，使其符合建议的设计，哇！你的问题解决了！
- en: What we just discussed is a software design pattern. A software design pattern
    is a tried and tested solution or a strategy that helps us solve a commonly encountered
    problem in the code. Let's start with the broad categories of design patterns
    followed by some important design principles.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才讨论的是软件设计模式。软件设计模式是一种经过验证的解决方案或策略，帮助我们解决代码中常见的难题。让我们从设计模式的广泛类别开始，然后讨论一些重要的设计原则。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**The Gang of Four book**:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**四人帮书籍**：'
- en: 'Before beginning any discussion on the design patterns in Python, it is worth
    noting that there is an excellent book you may want on your bookshelf, *Design
    Patterns: Elements of Reusable Object-Oriented Software*, by Erich Gamma, Richard
    Helm, Ralph Johnson, and John Vlissides. These four authors are commonly referred
    to as the **Gang of Four** (**GoF**). Their book illustrates design patterns using
    C++ and Smalltalk examples. If you have a background in programming languages
    such as C++ or Java, this might be of more interest to you. As you will see in
    this chapter, some high-level language features in Python make many design patterns
    much simpler to implement. The GoF book is still a great reference, and will help
    you understand the core concepts behind the design patterns.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '在开始任何关于Python中设计模式的讨论之前，值得注意的是，有一本非常好的书你可能想在你的书架上，那就是Erich Gamma、Richard Helm、Ralph
    Johnson和John Vlissides合著的《设计模式：可复用面向对象软件元素》（Design Patterns: Elements of Reusable
    Object-Oriented Software）。这四位作者通常被称为**四人帮**（**GoF**）。他们的书使用C++和Smalltalk示例来说明设计模式。如果你有C++或Java等编程语言背景，这本书可能对你更有兴趣。正如你将在本章中看到的，Python的一些高级语言特性使得许多设计模式更容易实现。GoF的书仍然是一本很好的参考书，将帮助你理解设计模式背后的核心概念。'
- en: Classification of patterns
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式的分类
- en: Software design patterns can be broadly classified into four categories, namely
    behavioral patterns, creational patterns, structural patterns, and concurrency
    patterns. In this book, we will limit our discussion to just three design patterns.
    We will see one example each of behavioral, creational, and structural patterns.
    The concurrency patterns are not covered here, as it is an advanced topic, beyond
    the scope of this book. For an in-depth understanding of other design patterns,
    you can grab a book on design patterns, such as the GoF book mentioned earlier.
    With this in mind, let's briefly talk about each of these categories next.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计模式可以大致分为四类，即行为模式、创建模式、结构模式和并发模式。在本书中，我们将仅讨论三种设计模式。我们将分别看到一个行为模式、一个创建模式和结构模式的例子。并发模式在此不涉及，因为它是一个高级主题，超出了本书的范围。为了深入了解其他设计模式，你可以阅读关于设计模式的书籍，例如前面提到的GoF书籍。考虑到这一点，接下来我们将简要讨论这些类别。
- en: Behavioral patterns
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行为模式
- en: 'The behavioral design patterns try to simplify how different objects communicate
    with each other. While doing so, these patterns help keep these objects loosely
    coupled or less dependent on each other. The following is a partial list of behavioral
    design patterns: chain of responsibility, command, strategy, observer, iterator,
    visitor pattern, and many more. In this chapter, we will see how to implement
    the strategy pattern in Python.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 行为设计模式试图简化不同对象之间如何相互通信。在这样做的同时，这些模式有助于保持这些对象松散耦合或减少彼此的依赖。以下是一些行为设计模式的列表：责任链模式、命令模式、策略模式、观察者模式、迭代器模式、访问者模式，等等。在本章中，我们将看到如何在Python中实现策略模式。
- en: Creational patterns
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建模式
- en: These patterns are all about instance creation mechanisms. These design patterns
    show a better way to create objects depending on the situation you are dealing
    with.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式都是关于实例创建机制的。这些设计模式展示了根据你所处理的情况创建对象的更好方式。
- en: 'Here is a list of the major creational design patterns: abstract factory, factory
    method, builder, prototype, and singleton pattern. We will discuss the abstract
    factory pattern in this chapter.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是主要创建设计模式列表：抽象工厂模式、工厂方法模式、建造者模式、原型模式和单例模式。我们将在本章中讨论抽象工厂模式。
- en: Structural patterns
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构模式
- en: The structural design patterns typically deal with the relationship between
    the components, such as objects or classes, so that it is easier to make these
    entities work together in a larger and more complex system. Some examples of structural
    design patterns include adapter, composite, decorator, facade, flyweight, proxy
    pattern, and so on. In this chapter, we will see a Pythonic implementation of
    the adapter pattern.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 结构设计模式通常处理组件之间的关系，例如对象或类，以便更容易使这些实体在一个更大、更复杂的系统中协同工作。结构设计模式的例子包括适配器模式、组合模式、装饰器模式、外观模式、享元模式、代理模式等等。在本章中，我们将看到适配器模式的Python实现。
- en: Concurrency patterns
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并发模式
- en: 'In a nutshell, concurrency means simultaneously performing multiple things.
    Concurrency enables your application to execute one task (for example, updating
    a database) while it is also working on something else (such as responding to
    a user query). Concurrency design patterns, in general, deal with the multi-threaded
    programming paradigm. The following is a partial list of concurrency patterns:
    active object, balking, monitor object, double-checked locking, and so on. As
    mentioned before, we will not talk about any of the concurrency patterns in this
    book. That said, [Chapter 9](ch09.html "Chapter 9. Improving Performance – Part
    Two, NumPy and Parallelization"), *Improving Performance – Part two, NumPy and
    Parallelization* will introduce you to some aspects of multi-threaded programming
    in Python. Visit the wiki for more information at [https://en.wikipedia.org/wiki/Concurrency_pattern](https://en.wikipedia.org/wiki/Concurrency_pattern).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，并发意味着同时执行多项任务。并发使你的应用程序能够在执行一项任务（例如，更新数据库）的同时，也在处理其他事情（例如，响应用户查询）。一般来说，并发设计模式处理多线程编程范式。以下是一些并发模式的列表：主动对象模式、拒绝模式、监控对象模式、双重检查锁定，等等。如前所述，本书将不讨论任何并发模式。尽管如此，[第9章](ch09.html
    "第9章。性能提升 – 第二部分，NumPy和并行化") *性能提升 – 第二部分，NumPy和并行化* 将介绍Python中多线程编程的一些方面。有关更多信息，请访问[https://en.wikipedia.org/wiki/Concurrency_pattern](https://en.wikipedia.org/wiki/Concurrency_pattern)。
- en: Python language and design patterns
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python语言和设计模式
- en: Thanks to the high-level built-in language features in Python, many of the formal
    design patterns are easy to implement. In some cases, the patterns appear so natural
    to the language that it becomes tough to realize them as formal design patterns.
    For example, an iterator pattern can be realized by using any iterable object,
    such as lists, dictionaries, and so on. Let's quickly review such language features
    or paradigms in this section. It is not an exhaustive list, but we will cover
    some important aspects.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python中内置的高级语言特性，许多正式的设计模式都很容易实现。在某些情况下，这些模式对语言来说如此自然，以至于很难将其视为正式的设计模式。例如，迭代器模式可以通过使用任何可迭代对象来实现，例如列表、字典等。让我们快速回顾本节中的这些语言特性或范式。这不是一个详尽的列表，但我们将涵盖一些重要方面。
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The idioms that you are about to read (first-class functions, closures, and
    so on) might sound onerous. But do not get overwhelmed by these terms! If you
    are a Python programmer, it is very likely that you have already used many of
    these features knowingly or unknowingly. If these idioms mean nothing to you at
    the moment, skip ahead to the next section where we fast forward to an imaginary
    game scenario. In the upcoming discussion, we will use some of these language
    features. You can then come back to this section whenever you need a handy reference.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你即将阅读的习语（一等函数、闭包等）可能听起来有些复杂。但不要被这些术语所压倒！如果你是Python程序员，那么你很可能已经有意或无意地使用了这些特性。如果这些习语对你来说现在毫无意义，请跳到下一节，在那里我们将快速跳到一个假想的游戏场景。在接下来的讨论中，我们将使用这些语言特性。当你需要方便的参考时，可以随时回到这一节。
- en: First-class functions
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一等函数
- en: There is a programming idiom called **first-class citizens**. In Python, any
    function, a class, a class method, or an object, all qualify as first-class citizens.
    On each of these entities, you can freely perform operations that are typically
    supported on other entities.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个名为**一等公民**的编程习语。在Python中，任何函数、类、类方法或对象，都符合一等公民的资格。在这些实体上，你可以自由执行通常在其他实体上支持的操作。
- en: 'For example, you can assign a function to a variable as if you are assigning
    a value to that variable. Likewise, you can pass this function as an argument,
    or get it as a return value of some other function. Any programming language that
    supports such operations on functions is said to have first-class functions. The
    following is a simple piece of code that illustrates what we can accomplish with
    a first-class function in Python. In this example, a function, `test`, is assigned
    to a variable, `x`. After the assignment, the function can be called either `x()`
    or as `test()`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以将一个函数赋值给一个变量，就像你将一个值赋给该变量一样。同样，你可以将这个函数作为参数传递，或者从另一个函数的返回值中获取它。任何支持在函数上执行此类操作的编程语言都被说成具有一等函数。以下是一段简单的代码，展示了我们如何在Python中使用一等函数所能实现的事情。在这个例子中，一个函数`test`被赋值给一个变量`x`。赋值之后，该函数可以以`x()`或`test()`的形式调用：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is another example that illustrates the first-class function feature.
    It shows how we can pass the same function, `test`, as an argument to another
    function, called `some_function`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个例子，说明了第一等函数特性。它展示了我们如何将相同的函数`test`作为参数传递给另一个名为`some_function`的函数：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's see what we can do with the other first-class entity, Python classes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以用其他一等实体，Python类，做什么。
- en: Classes as first-class objects
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为一等对象的类
- en: 'Just like functions, Python classes are first-class citizens. They can be passed
    around as an argument, assigned to variables, or returned from a function. Here
    is an example where a class, `Foo`, is assigned to a variable `bar`. After this
    assignment, you can use `bar` to create an instance of `Foo`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 就像函数一样，Python类也是一等公民。它们可以作为参数传递，赋值给变量，或从函数中返回。以下是一个例子，其中类`Foo`被赋值给变量`bar`。在这个赋值之后，你可以使用`bar`来创建`Foo`的一个实例：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We will not be using closures in this chapter. It is a bit of an advanced topic
    that is included for completeness. You can optionally skip the next section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中不会使用闭包。这是一个相对高级的话题，包含在这里是为了完整性。你可以选择性地跳过下一节。
- en: Closures
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: Take any function in Python that defines some local variables. You can use these
    variables inside the function, but those can not be accessed by the outside world
    (unless you return it from the function). In some sense, the functions can be
    considered as closed. When the function executes, it uses these local variables;
    when the function is done, the local variables go out of scope. Their job is done,
    that's the end of the story. Now what if you want a function that keeps its local
    environment at the time it was created?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑任何在Python中定义了一些局部变量的函数。你可以在函数内部使用这些变量，但它们不能被外部世界访问（除非你从函数中返回它）。从某种意义上说，函数可以被认为是封闭的。当函数执行时，它使用这些局部变量；当函数完成后，局部变量超出作用域。它们的任务完成了，这就是故事的结尾。现在，如果你想要一个在创建时保持其局部环境的函数呢？
- en: 'We want some way to wrap this function along with its local environment. It
    could be better explained with the following example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有一种方法可以将这个函数及其局部环境一起封装起来。以下示例可以更好地解释这一点：
- en: '![Closures](img/B05034_06_46.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![闭包](img/B05034_06_46.jpg)'
- en: 'In the preceding example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中：
- en: '`modified_number` is a nested function within the function `initial_number`.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modified_number`是`initial_number`函数内的嵌套函数。'
- en: This nested function uses a local variable, `x`, which is in the scope of the
    top-level function.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个嵌套函数使用一个局部变量`x`，它在顶层函数的作用域内。
- en: In the main program, we create `foo`, which is the return value of `initial_number`.
    But look at the return value of the `initial_number` function. It returns the
    nested function, `modified_number`.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主程序中，我们创建了`foo`，它是`initial_number`的返回值。但看看`initial_number`函数的返回值。它返回嵌套函数`modified_number`。
- en: What this means is that the `foo` variable becomes the nested function, `modified_number`.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这意味着`foo`变量变成了嵌套函数`modified_number`。
- en: 'What did we achieve here? We accomplished two things—first, it enabled access
    to a nested function from the main program, and second, the nested function still
    has the original working environment we used while instantiating `initial_number`.
    In this example, the working environment refers to the `x` argument with a value
    of `100`, passed to this function. The following is the program output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里实现了什么？我们实现了两个目标——首先，它使得从主程序中访问嵌套函数成为可能，其次，嵌套函数仍然保留了我们在实例化`initial_number`时使用的原始工作环境。在这个例子中，工作环境指的是传递给这个函数的具有`100`值的`x`参数。以下是该程序的输出：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Observe that the value of `x` remains unchanged. Any subsequent calls to `foo`
    retain this original local environment, which is used by the nested function `modified_number`.
    Likewise, you can create another instance of `initial_number` with a different
    value of `x`. This is called a closure in Python. Closures can be used to realize
    design patterns such as the observer pattern.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`x`的值保持不变。任何后续对`foo`的调用都保留了这个原始的局部环境，这是嵌套函数`modified_number`使用的。同样，你也可以使用不同的`x`值创建`initial_number`的另一个实例。这被称为Python中的闭包。闭包可以用来实现如观察者模式等设计模式。
- en: Miscellaneous features
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他特性
- en: Let's review some built-in functions and decorators that would come in handy
    while implementing some design patterns. Again, it is not a complete list, but
    enough to aid us in the upcoming discussion on design patterns.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一些在实现某些设计模式时非常有用的内置函数和装饰器。再次强调，这并不是一个完整的列表，但足以帮助我们进行即将到来的设计模式讨论。
- en: Class method
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类方法
- en: A class method (`@classmethod`) is something that you can call without the need
    to create an instance of that class. Unlike a regular instance method, which takes
    the instance of the class (`self`) as its first argument, a class method takes
    the class as its first argument. The decorator `@classmethod` is just one convenient
    way to create a class method. We will see how to use a class method in the discussion
    on simple factory.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法（`@classmethod`）是一种可以在不创建该类实例的情况下调用的方法。与需要将类的实例（`self`）作为其第一个参数的常规实例方法不同，类方法将类作为其第一个参数。装饰器`@classmethod`只是创建类方法的一种方便方式。我们将在简单工厂的讨论中看到如何使用类方法。
- en: Abstract method
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象方法
- en: The `@abstractmethod` decorator is used to indicate that the given method is
    abstract and must be reimplemented in subclasses. Recall that we have already
    used this to implement `AbstractGameUnit.info()` as an abstract method using this
    decorator. See the *Abstract base classes in Python* section in [Chapter 1](ch01.html
    "Chapter 1. Developing Simple Applications"), *Developing Simple Applications*
    for further details. In this chapter, we won't be using this decorator.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@abstractmethod` 装饰器来指示给定方法是抽象的，必须在子类中重新实现。回想一下，我们已经使用此装饰器将 `AbstractGameUnit.info()`
    实现为抽象方法。有关更多详细信息，请参阅[第1章](ch01.html "第1章. 开发简单应用程序")中的*Python中的抽象基类*部分，*开发简单应用程序*。在本章中，我们不会使用此装饰器。
- en: The __getattr__ method
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`__getattr__` 方法'
- en: Python automatically calls the `__getattr__` method when you try to access an
    instance attribute that is not already defined in your class. You can implement
    `__getattr__` in your class, and use it to add special handling code for all such
    undefined attributes. The use of this method will be later illustrated in the
    adapter pattern.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试访问在类中尚未定义的实例属性时，Python 会自动调用 `__getattr__` 方法。你可以在类中实现 `__getattr__`，并使用它为所有此类未定义属性添加特殊处理代码。此方法的使用将在适配器模式中稍后进行说明。
- en: Duck typing
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 鸭子类型
- en: 'The term **duck typing** is often exemplified as, *if it swims and quacks like
    a duck, then we will treat that object as a duck*. Let''s see what this means
    with a simple example. We have a class, `Knight`, with the methods `move` and
    `attack`, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: “鸭子类型”这个术语通常被举例说明为：“如果它像鸭子游泳和嘎嘎叫，那么我们就把它当作鸭子对待。”让我们通过一个简单的例子来看看这意味着什么。我们有一个名为
    `Knight` 的类，具有 `move` 和 `attack` 方法，如下所示：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A function takes an instance of `Knight` as an argument, and calls these methods
    like so:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数接受 `Knight` 实例作为参数，并按如下方式调用这些方法：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, the function does not check whether the input argument is really an
    instance of the `Knight` class. As long as the object has the `move` and `attack`
    methods, it will not complain. Thus, in duck typing, the language does not make
    any verification of the object. The only thing it cares about is whether or not
    it can call certain attributes using that object. One advantage of duck typing
    is code reusability. You can reuse the `do_something` function in some other code
    by passing an object of a different class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，该函数不会检查输入参数是否真的是 `Knight` 类的实例。只要对象具有 `move` 和 `attack` 方法，它就不会抱怨。因此，在鸭子类型中，语言不会对对象进行任何验证。它唯一关心的是是否可以使用该对象调用某些属性。鸭子类型的一个优点是代码可重用性。你可以通过传递不同类的对象来在其他代码中重用
    `do_something` 函数。
- en: 'For example, imagine a `Lion` class that implements the `move` and `attack`
    methods. You would like to reuse the aforementioned `do_something` function in
    some other project that is already using this class:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一个实现了 `move` 和 `attack` 方法的 `Lion` 类。你希望在某个其他项目中重用上述 `do_something` 函数，该项目已经使用了这个类：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `do_something` function will work just fine as long as the input object
    has the `move` and `attack` methods defined. How does this all translate to a
    design pattern discussion? Other programming languages, such as Java, define a
    formal interface in the code to implement certain design patterns, such as the
    abstract factory pattern. In C++, an abstract base class is defined with pure
    virtual functions. In Python, we have an option to use duck typing instead of
    implementing an interface or an abstract base class. For clarity on the design
    pattern itself, you may still want to document such an abstract base class or
    interface.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 只要输入对象定义了 `move` 和 `attack` 方法，`do_something` 函数就会正常工作。这一切如何转化为设计模式讨论？其他编程语言，如
    Java，在代码中定义正式接口以实现某些设计模式，例如抽象工厂模式。在 C++ 中，使用纯虚函数定义抽象基类。在 Python 中，我们有选择使用鸭子类型而不是实现接口或抽象基类的选项。为了对设计模式本身有更清晰的理解，你可能仍然需要记录这样的抽象基类或接口。
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'In Python, we could still use Java-style interfaces. The **Zope** web framework
    (not covered in this book) is a good example. Visit the following link for more
    information: [https://docs.zope.org/zope.interface/README.html](https://docs.zope.org/zope.interface/README.html).
    Also, see a note in the abstract factory discussion later that shows how to enforce
    an interface in Python.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们仍然可以使用 Java 风格的接口。**Zope** 网络框架（本书未涉及）是一个很好的例子。有关更多信息，请访问以下链接：[https://docs.zope.org/zope.interface/README.html](https://docs.zope.org/zope.interface/README.html)。另外，请参阅稍后关于抽象工厂讨论中的注释，说明如何在
    Python 中强制执行接口。
- en: Duck typing offers a lot of freedom to programmers, so much freedom that it
    has the potential to introduce bugs that are difficult to notice just by looking
    at the code. But such errors can be detected with extensive unit testing. Another
    way to reduce such problems is to enforce strict coding standards and documentation.
    For example, you can create some custom coding standards that can avoid confusion
    arising due to duck typing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Duck typing为程序员提供了很多自由，但这种自由有可能引入仅通过查看代码就难以察觉的bug。但通过广泛的单元测试可以检测到这样的错误。减少此类问题的另一种方法是强制执行严格的编码标准和文档。例如，你可以创建一些自定义编码标准，以避免由于Duck
    typing引起的混淆。
- en: With this basic introduction to some key language features, let's move on and
    discuss how to implement some design patterns, and what problems they address.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对一些关键语言特性的基本介绍，让我们继续讨论如何实现一些设计模式，以及它们解决什么问题。
- en: Structure of the rest of the chapter
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章剩余部分的结构
- en: 'Before diving into the discussion on design patterns and their implementation,
    let''s first lay out a strategy for the rest of the discussion. As mentioned before,
    we will review the strategy pattern, the simple and abstract factory patterns,
    and the adapter pattern. The discussion on design patterns will be roughly structured
    as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论设计模式和它们的实现之前，让我们首先为剩余的讨论制定一个策略。如前所述，我们将回顾策略模式、简单工厂模式和抽象工厂模式，以及适配器模式。关于设计模式的讨论将大致按照以下结构进行：
- en: Start with a formal definition of the pattern
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从模式的正式定义开始
- en: Present an imaginary scenario where a new feature is requested
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提出一个新的功能请求的假设场景
- en: Talk about the problem encountered in introducing this new feature
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论引入这个新功能时遇到的问题
- en: Make an attempt to solve this problem, quickly realizing that we need to rethink
    the design
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试快速解决这个问题，很快意识到我们需要重新思考设计
- en: The solution(s) to the problem using the design pattern
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用设计模式解决问题的方案
- en: For a few design patterns, we will discuss two approaches to solving the problem.
    A traditional approach that resembles the one followed in languages like C++,
    and the other, the Pythonic approach.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些设计模式，我们将讨论两种解决问题的方法。一种类似于在C++等语言中遵循的传统方法，另一种是Pythonic方法。
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Skip the traditional solution if you are interested only in the Pythonic approach.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只对Pythonic方法感兴趣，可以跳过传统解决方案。
- en: 'The following is a list of files from the supporting code bundle that will
    be reviewed:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从支持代码包中将要审查的文件列表：
- en: '![Structure of the rest of the chapter](img/B05034_06_47.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![本章剩余部分的结构](img/B05034_06_47.jpg)'
- en: It is also worth noting that we will not be developing a full-fledged game application.
    The idea is to use this game theme as an aid to understanding some design patterns.
    The code used in this chapter is quite simple. While most of the code is illustrated
    in the upcoming discussion, you can also download and review the source from the
    supplementary code bundle for this chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们不会开发一个完整的功能游戏应用。这个想法是利用这个游戏主题作为理解一些设计模式的辅助。本章使用的代码相当简单。虽然大部分代码将在接下来的讨论中展示，但你也可以从本章的补充代码包中下载并审查源代码。
- en: Fast forward – Attack of the Orcs v6.0.0
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快进 – 魔兽攻击v6.0.0
- en: Let's fast forward to a future imaginary version of the game!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速跳到游戏的未来假设版本！
- en: '| *This imaginary version is one of the most downloaded open source Python
    applications. Now you have a team of developers helping you with application development.
    The game has evolved quite a bit. It is no longer a simple application where you
    gain control of a hut by defeating the enemy. It is now a turn-based fantasy game,
    where the player and the enemy take turns attacking each other, or use that turn
    to move towards or away from the opponent.**You have introduced several new game
    missions, and have redesigned and refactored the code to accommodate the new requirements.
    In the most recent version, you have the following game characters: Knight, Orc
    Rider, and Elf Rider.* |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 这个假设版本是最受欢迎的开源Python应用程序之一。现在你有一支开发团队帮助你进行应用开发。游戏已经发展得相当多。它不再是一个简单的应用，通过击败敌人来控制小屋。现在它是一个回合制的幻想游戏，玩家和敌人轮流攻击对方，或者利用这个回合向对手靠近或远离。**你引入了几个新的游戏任务，并重新设计和重构了代码以适应新的要求。在最新版本中，你有以下游戏角色：骑士、兽人骑手和精灵骑手。**
    |'
- en: Tip
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: An **Elf** is an imaginary supernatural mythical being. Read the *The theme
    of the book* section in [Chapter 1](ch01.html "Chapter 1. Developing Simple Applications"),
    *Developing Simple Applications* for some references on Elves.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵**是一种想象中的超自然神话生物。请参阅[第1章](ch01.html "第1章. 开发简单应用程序")中的*书籍主题*部分，*开发简单应用程序*，以获取有关精灵的一些参考资料。'
- en: 'Each game character in this version has an ability to attack the enemy, move
    towards or away from the enemy, or get healed inside a hut. Let''s not worry about
    the actual logic that implements these features in the application. We shall rather
    focus on the high-level design of the application. The following pseudo-UML diagram
    shows various classes and a few of their public methods:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，每个游戏角色都有攻击敌人、向敌人靠近或远离敌人，或在棚屋内恢复的能力。我们不必担心实现这些功能的应用程序的实际逻辑。我们更应关注应用程序的高级设计。以下伪UML图显示了各种类及其一些公共方法：
- en: '![Fast forward – Attack of the Orcs v6.0.0](img/B05034_06_01.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![快进 – 魔兽攻击 v6.0.0](img/B05034_06_01.jpg)'
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As indicated in [Chapter 1](ch01.html "Chapter 1. Developing Simple Applications"),
    *Developing Simple Applications*, we will loosely follow the UML representation.
    We referred to it as a pseudo-UML schematic. An explanation for the convention
    used here is in order. Each class in the schematics is represented by a rounded
    rectangle. It shows the class name followed by its attributes. The plus sign (`+`)
    before the attribute indicates it is public. A protected or private method is
    generally represented with a negative sign (`-`). For ease of illustration, only
    a few relevant public attributes will be listed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](ch01.html "第1章. 开发简单应用程序")中所述，*开发简单应用程序*，我们将松散地遵循UML表示。我们将其称为伪UML图。这里使用的惯例的解释是必要的。图中的每个类都由一个圆角矩形表示。它显示了类名后跟其属性。属性前的加号（`+`）表示它是公共的。受保护的或私有方法通常用负号（`-`）表示。为了便于说明，只列出了几个相关的公共属性。
- en: As illustrated in the class diagram, all the game characters inherit from a
    common superclass, `AbstractGameUnit`. Each of the subclasses has its own implementation
    of `info()` and `attack()`. In other words, each subclass has its own way of attacking
    the enemy. Further assume that in the aforementioned version, all the subclasses
    use a common `move()` method defined in the superclass. This could be better imagined
    if you see the game instructions in action.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如类图所示，所有游戏角色都继承自一个共同的超类`AbstractGameUnit`。每个子类都有自己的`info()`和`attack()`实现。换句话说，每个子类都有自己攻击敌人的方式。进一步假设在上述版本中，所有子类都使用在超类中定义的公共`move()`方法。如果你看到游戏说明的实际操作，这可能会更容易想象。
- en: 'See the following screenshot that shows how the player will be prompted to
    perform a move:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下截图，展示了玩家将被提示进行移动的方式：
- en: '![Fast forward – Attack of the Orcs v6.0.0](img/B05034_06_02.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![快进 – 魔兽攻击 v6.0.0](img/B05034_06_02.jpg)'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Cool! I want to play this new game scenario. Where is the source code?**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**太棒了！我想玩这个新游戏场景。源代码在哪里？**'
- en: The intention here is not to develop the full game logic. This is an imaginary
    scenario that is used just to highlight some commonly encountered problems in
    application development. With this scenario, we will see how design patterns could
    help tackle such problems. No code has been provided to actually "play" this new
    game. The supporting code illustrates how to implement various design patterns
    discussed here.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的意图不是开发完整的游戏逻辑。这是一个想象场景，仅用于突出应用程序开发中常见的一些问题。通过这个场景，我们将看到设计模式如何帮助解决这些问题。没有提供代码来实际“玩”这个新游戏。支持代码说明了如何实现这里讨论的各种设计模式。
- en: As can be seen from the command-line output, it gives the player a choice to
    move in one of four directions. It also indicates what lies ahead in each direction.
    In this particular case, the player decides to go South, but this movement is
    restricted by a fence.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如从命令行输出中可见，它为玩家提供了选择向四个方向之一移动的选项。它还指示了每个方向前方的情况。在这个特定的情况下，玩家决定向南移动，但这种移动受到栅栏的限制。
- en: Strategy pattern
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略模式
- en: A strategy design pattern is a behavioral pattern that is used to represent
    a family of algorithms. An algorithm within such a family is represented as a
    strategy object. The pattern enables easy switching between different strategies
    (algorithms) of a particular family. This is generally useful when you want to
    switch to a different strategy at runtime. We will revisit this definition towards
    the end of the discussion on strategy pattern.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 策略设计模式是一种行为模式，用于表示一组算法。该家族中的一个算法表示为一个策略对象。该模式使得在特定家族的不同策略（算法）之间轻松切换。这通常在你想要在运行时切换到不同的策略时非常有用。我们将在讨论策略模式的末尾重新审视这个定义。
- en: Strategy scenario – The jump feature
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略场景 – 跳跃功能
- en: '| *There is a high priority* *feature request. Rather, it is a complaint. The
    users just hate the movement restriction imposed by the fence. Now even Sir Foo
    has joined the protest...* |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| *有一个高优先级的特性请求。更确切地说，这是一个投诉。用户们只是讨厌栅栏强加的运动限制。现在连Foo爵士也加入了抗议...* |'
- en: '![Strategy scenario – The jump feature](img/B05034_06_03.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![策略场景 – 跳跃功能](img/B05034_06_03.jpg)'
- en: '| *Rather than removing the fence from the scenario, how about a new feature
    that enables units to jump over the fence or any similar obstacle?* |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| *与其从场景中移除栅栏，不如添加一个新功能，允许单位跳过栅栏或任何类似的障碍物？* |'
- en: 'You have introduced a new method, `jump()`, in the superclass `AbstractGameUnit`.
    All the classes inherit this method, as shown in the following class diagram:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你在超类 `AbstractGameUnit` 中引入了一个新的方法，`jump()`。所有类都继承了这个方法，如下面的类图所示：
- en: '![Strategy scenario – The jump feature](img/B05034_06_04.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![策略场景 – 跳跃功能](img/B05034_06_04.jpg)'
- en: The fence no longer prevents the player from moving around. The new jump option
    enables crossing the fence without any problem. That was easy, wasn't it? Everyone
    is happy (especially Sir Foo)!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 栅栏不再阻止玩家移动。新的跳跃选项使得跨越栅栏没有任何问题。这很简单，不是吗？每个人都感到高兴（尤其是Foo爵士）！
- en: Strategy – The problem
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略 – 问题
- en: Let's fast forward to a few more major releases of the application.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速前进到应用的一些更多主要版本。
- en: '| *You have introduced two new imaginary characters to the game, a Dwarf and
    a Fairy, offering unique skills. For example, the Fairy has powers to heal nearby
    injured units in your army, and the Dwarf units offer a solid line of defense
    against enemy attack. With this, the number of application downloads per week
    has now reached a new high. However, there is a new problem that the users have
    reported. Let''s hear it from The Great Dwarf:* |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| *你向游戏中引入了两个新的虚构角色，一个矮人和一个精灵，提供了独特的技能。例如，精灵拥有治愈你军队中附近受伤单位的能力，而矮人单位则提供对敌人攻击的坚固防线。因此，每周的应用程序下载量现在已经达到了新的高峰。然而，用户们报告了一个新的问题。让我们听听伟大的矮人的意见：*
    |'
- en: '![Strategy – The problem](img/B05034_06_05.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![策略 – 问题](img/B05034_06_05.jpg)'
- en: 'Do you see the problem here? The jump feature has an unwanted side effect.
    It allows even a Fairy or a Dwarf to jump over the fence. The Knight, ElfRider,
    and OrcRider are all mounted units. It is easier to imagine these units jumping
    over the fence. However, it is not intuitive to think this way for a game character
    like a Dwarf. We encounter this issue because all the classes use the default
    implementation of the `AbstractGameUnit.jump` method. This is shown in the following
    class diagram:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里看到了问题吗？跳跃功能有一个不希望出现的副作用。它甚至允许精灵或矮人跳过栅栏。骑士、精灵骑手和兽人骑手都是骑乘单位。想象这些单位跳过栅栏更容易。然而，对于一个像矮人这样的游戏角色来说，这样思考并不直观。我们遇到这个问题是因为所有类都使用了
    `AbstractGameUnit.jump` 方法的默认实现。如下面的类图所示：
- en: '![Strategy – The problem](img/B05034_06_06.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![策略 – 问题](img/B05034_06_06.jpg)'
- en: Strategy – Attempted solution
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略 – 尝试的解决方案
- en: 'The Dwarf and Fairy game units should not have the jump feature. So what can
    we do here? The Fairy has something to say:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵和矮人游戏单位不应该有跳跃功能。那么我们在这里能做什么呢？精灵有话要说：
- en: '![Strategy – Attempted solution](img/B05034_06_07.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![策略 – 尝试的解决方案](img/B05034_06_07.jpg)'
- en: Using inheritance is certainly one approach. You can override the `jump` method
    and make it a no operation inside the new classes. However, in the next release,
    you are planning to introduce a number of new characters that are not supposed
    to jump, or need to jump differently. Some of the new classes are represented
    in the following class diagram. All of these need to override and implement their
    own logic.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用继承当然是一种方法。你可以在新类中覆盖`jump`方法，使其成为无操作。然而，在下一个版本中，你计划引入一些不应该跳跃或需要以不同方式跳跃的新角色。以下是一些在以下类图中表示的新类。所有这些都需要覆盖并实现它们自己的逻辑。
- en: '![Strategy – Attempted solution](img/B05034_06_08.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![策略 – 尝试的解决方案](img/B05034_06_08.jpg)'
- en: The jump feature is just one of the many things where you will see this problem.
    We don't even need to look beyond what we already have. In the preceding diagram,
    look at the `move` and `attack` methods. Do you see the same problem brewing?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 跳跃功能只是你将看到这个问题的地方之一。我们甚至不需要超出我们已有的内容。在上面的图中，看看`move`和`attack`方法。你是否看到了同样的问题在酝酿？
- en: The game characters are evolving. They have their own rules to move. For example,
    a `Knight` riding a horse may cross a river in two turns, whereas a `DwarfFighter`
    would need 10 turns for the same task.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏角色在进化。它们有自己的移动规则。例如，骑马的`Knight`可能需要两回合就能穿越河流，而`DwarfFighter`则需要10回合才能完成同样的任务。
- en: Similarly, each unit has its signature style for attacking the enemy. An old
    `Wizard` in your army can cast magical spells on the enemy. The `ElfRider` character
    attacks twice in a single turn using a bow and arrows. The `DwarfFighter` character
    uses a hammer to attack, and so on.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，每个单位都有其独特的攻击敌人的风格。你军队中的老`Wizard`可以对敌人施展魔法咒语。`ElfRider`角色在一回合内使用弓箭攻击两次。`DwarfFighter`角色则使用锤子攻击，等等。
- en: If we continue to use the inheritance principle here, it would soon become a
    maintenance nightmare. Why so? This is because each class that you write is responsible
    for implementing and maintaining its own logic for its move, jump, and attack
    abilities. Initially, you may see this as a trivial issue, where overriding the
    functionality in the subclasses just works. But with a growing number of character
    types and their ever-growing set of abilities (move, jump, swim, defend, hide,
    regenerate, and so on), this will turn out to be a daunting task. The code might
    also get repeated across classes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续在这里使用继承原则，很快就会变成一个维护噩梦。为什么？这是因为你写的每个类都负责实现和维护其移动、跳跃和攻击能力的逻辑。最初，你可能认为这是一个微不足道的问题，在子类中覆盖功能即可解决问题。但随着角色类型和它们不断增长的能力（移动、跳跃、游泳、防御、隐藏、再生等）的增加，这将会变成一项艰巨的任务。代码也可能在各个类之间重复。
- en: Every small change to the logic will require you to update the corresponding
    methods in all the classes. It could also invite new bugs if you miss out a few
    methods during the update process. We need to rethink the design to accommodate
    future requirements easily. Let's do that next.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑的任何小改动都需要你更新所有类中的相应方法。如果在更新过程中遗漏了一些方法，也可能引入新的错误。我们需要重新思考设计，以便更容易地适应未来的需求。让我们接下来这么做。
- en: Strategy – Rethinking the design
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略 – 重新思考设计
- en: What can we do in such situations? Observe that the implementation code defining
    these abilities varies across subclasses. In this example, the `DwarfFighter`
    cannot jump whereas a `Knight` jumps using a horse.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下我们能做什么？观察发现，定义这些能力的实现代码在子类之间是不同的。在这个例子中，`DwarfFighter`不能跳跃，而`Knight`则骑马跳跃。
- en: The first question to ask is why do these classes carry the burden of defining
    abilities? Can this be outsourced to a different class or a function? We will
    redesign the `AbstractGameUnit` class (and its subclasses) so that the various
    abilities are now handled by objects dedicated to those tasks. In other words,
    we will use object composition to take this load off `AbstractGameUnit` and its
    subclasses.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要问的问题是为什么这些类要承担定义能力的负担？这能否外包给不同的类或函数？我们将重新设计`AbstractGameUnit`类（及其子类），使得各种能力现在由专门处理这些任务的对象来处理。换句话说，我们将使用对象组合来减轻`AbstractGameUnit`及其子类的工作负担。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Recall that in [Chapter 1](ch01.html "Chapter 1. Developing Simple Applications"),
    *Developing Simple Applications*, we used object composition in the `Hut` class
    where its `occupant` was represented by a different object. Object composition
    allows you to represent a complex object by putting together simple objects. Just
    say it out loud, a Knight has-the ability to move, a Knight has the ability to
    jump, and so on. Each of these abilities will be represented by separate objects.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在[第1章](ch01.html "第1章. 开发简单应用程序")《开发简单应用程序》中，我们使用了`Hut`类中的对象组合，其中其`occupant`由不同的对象表示。对象组合允许你通过组合简单对象来表示复杂对象。大声说出来，骑士有移动的能力，骑士有跳跃的能力，等等。每种能力都将由单独的对象表示。
- en: How do we implement this new design? We will discuss two approaches to solving
    this problem. The first one is more of a classical approach that resembles the
    one typically followed in other languages, such as C++. If you have such a development
    background, this approach will look more familiar. The second approach is more
    Pythonic. It uses first-class functions, a language feature in Python. This second
    approach will make the whole problem appear trivial. If you are not interested
    in the traditional approach, skip ahead to the Pythonic solution for the strategy
    pattern.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何实现这个新设计？我们将讨论两种解决问题的方法。第一种方法更像是经典方法，类似于在其他语言（如C++）中通常遵循的方法。如果你有这样的开发背景，这种方法看起来会更熟悉。第二种方法更符合Python风格。它使用Python中的第一类函数，这是一种语言特性。第二种方法将使整个问题看起来微不足道。如果你对传统方法不感兴趣，可以跳到策略模式的Python解决方案。
- en: Strategy solution 1 – Traditional approach
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略解决方案 1 – 传统方法
- en: 'In the preceding section, we decided to create dedicated objects to represent
    abilities such as jump. Let''s draw a class diagram that explains this better:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们决定创建专用对象来表示如跳跃等能力。让我们绘制一个类图来更好地解释这一点：
- en: '![Strategy solution 1 – Traditional approach](img/B05034_06_09.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![策略解决方案 1 – 传统方法](img/B05034_06_09.jpg)'
- en: 'Here is a more verbose description of what is represented in the preceding
    diagram:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对前面图表所表示内容的更详细描述：
- en: Three new classes, `AttackStrategy`, `MoveStrategy`, and `JumpStrategy`, now
    handle the logic for the `attack`, `move`, and `jump` methods respectively.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在有三个新类，`AttackStrategy`、`MoveStrategy`和`JumpStrategy`，分别处理`attack`、`move`和`jump`方法的逻辑。
- en: The class `AbstractGameUnit` is now composed of the instances of these classes,
    namely `attack_strategy`, `move_strategy`, and `jump_strategy`.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在的`AbstractGameUnit`类由这些类的实例组成，即`attack_strategy`、`move_strategy`和`jump_strategy`。
- en: The `AbstractGameUnit.jump` method just calls `jump_strategy.jump()`. A similar
    implementation for the `move` and `attack` methods is followed.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbstractGameUnit.jump`方法只是调用`jump_strategy.jump()`。对于`move`和`attack`方法，采用类似的实现方式。'
- en: 'As the game characters need their on-jump implementation, we will create subclasses
    of `JumpStrategy`. For example, a subclass `CanNotJump` can be used for game units
    that are unable to jump. This is illustrated in the following class diagram:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏角色需要它们自己的跳跃实现，我们将创建`JumpStrategy`的子类。例如，一个子类`CanNotJump`可以用于无法跳跃的游戏单位。以下类图展示了这一点：
- en: '![Strategy solution 1 – Traditional approach](img/B05034_06_10.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![策略解决方案 1 – 传统方法](img/B05034_06_10.jpg)'
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Revisiting the strategy pattern definition**:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**重新审视策略模式定义**：'
- en: We started the discussion on strategy pattern with a definition. This design
    pattern represents a family of algorithms. Take a closer look at the preceding
    class diagram. The `JumpStrategy` and its subclasses represent a family of algorithms.
    Functionality defined in each of these classes is equivalent to an algorithm or
    a strategy. These classes are part of the same family, because the execution of
    any of the algorithms is related to a jump. As an example, the `PowerJump` class
    defines an algorithm different from the `HorseJump` class. Likewise, `MoveStrategy`
    defines a family of algorithms for movement, and `AttackStrategy` for attacking
    the enemy. There is one last missing piece to complete the strategy pattern. We
    need a way to dynamically switch between algorithm families. Let's see how to
    implement this next.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从策略模式的定义开始讨论。这个设计模式代表了一组算法。仔细看看前面的类图。`JumpStrategy` 及其子类代表了一组算法。每个这些类中定义的功能相当于一个算法或策略。这些类属于同一个家族，因为任何算法的执行都与跳跃有关。例如，`PowerJump`
    类定义了一个与 `HorseJump` 类不同的算法。同样，`MoveStrategy` 定义了一组移动算法，`AttackStrategy` 定义了攻击敌人的算法。为了完成策略模式，我们还需要一种动态在算法家族之间切换的方法。让我们看看如何实现这一点。
- en: 'Let''s review the new class, `JumpStrategy`. It now defines the jump behavior
    that was earlier defined in `AbstractGameUnit`. The overall logic is represented
    by the following schematic diagram and the code fragments. For easier understanding,
    we will only discuss the methods related to the jump ability:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下新的类 `JumpStrategy`。它现在定义了之前在 `AbstractGameUnit` 中定义的跳跃行为。整体逻辑由以下示意图和代码片段表示。为了便于理解，我们只讨论与跳跃能力相关的函数：
- en: '![Strategy solution 1 – Traditional approach](img/B05034_06_11.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![策略解决方案 1 – 传统方法](img/B05034_06_11.jpg)'
- en: 'Thus, we have a family of algorithms represented by `JumpStrategy` and its
    subclasses. Here is the related code fragment that shows the classes `AbstractGameUnit`
    and `DwarfFighter`. The supporting file, `strategypattern_traditional.py`, contains
    this code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个由 `JumpStrategy` 及其子类表示的算法系列。以下是相关的代码片段，展示了 `AbstractGameUnit` 和 `DwarfFighter`
    类。支持文件 `strategypattern_traditional.py` 包含此代码：
- en: '![Strategy solution 1 – Traditional approach](img/B05034_06_12.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![策略解决方案 1 – 传统方法](img/B05034_06_12.jpg)'
- en: The instance variable `self.jump_strategy` is used to represent a strategy or
    an algorithm for the jump behavior. The subclasses of `AbstractGameUnit` get to
    choose any jump strategy from the family of algorithms defined by the `JumpStrategy`
    class and its subclasses. For example, the `DwarfFighter` subclass can use the
    algorithm defined in the `CanNotJump` class as its jump strategy, and so on. The
    `AbstractGameUnit.jump` method is now an API method for the calling code. This
    method relies on the strategy object for the actual jump implementation. It simply
    calls the corresponding method of that strategy object, as shown in the preceding
    class diagram.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量 `self.jump_strategy` 用于表示跳跃行为的一种策略或算法。`AbstractGameUnit` 的子类可以选择由 `JumpStrategy`
    类及其子类定义的算法系列中的任何跳跃策略。例如，`DwarfFighter` 子类可以使用 `CanNotJump` 类中定义的算法作为其跳跃策略，等等。`AbstractGameUnit.jump`
    方法现在是调用代码的 API 方法。此方法依赖于策略对象来实现实际的跳跃。它只是调用该策略对象的相应方法，如前一个类图所示。
- en: 'The subclass `DwarfFighter` in this simple example just overrides the abstract
    method info. You may include some additional customization to this class. Now
    let''s look at the family of algorithms for the jump feature:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，子类 `DwarfFighter` 只覆盖了抽象方法 info。你可以为这个类添加一些额外的定制。现在让我们看看跳跃功能的算法系列：
- en: '![Strategy solution 1 – Traditional approach](img/B05034_06_13.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![策略解决方案 1 – 传统方法](img/B05034_06_13.jpg)'
- en: 'As mentioned earlier, the purpose is not to develop a full-fledged game application,
    but just to understand the important concepts in application development. In this
    trivial example, we just print an informative message to illustrate the concept.
    In a practical implementation, these are the classes where your algorithms need
    to be defined. Finally, let''s review the calling code that instantiates a game
    character, and dynamically sets up different jump strategies:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，目的不是开发一个完整的游戏应用程序，而是仅仅理解应用开发中的重要概念。在这个微不足道的例子中，我们只是打印一条信息性消息来阐述这个概念。在实际实现中，这些是定义你的算法的类。最后，让我们回顾一下实例化游戏角色并动态设置不同跳跃策略的调用代码：
- en: '![Strategy solution 1 – Traditional approach](img/B05034_06_14.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![策略解决方案 1 – 传统方法](img/B05034_06_14.jpg)'
- en: 'We start by creating `jump_strategy`, an object that defines how the unit should
    jump. In this case, it is passed as an argument to the `__init__` method for `DwarfFighter`.
    Alternatively, you could also define a default strategy object in this class,
    as we know the default behavior for this class (the unit cannot jump). You can
    then call `set_jump_strategy` to switch to a different jump algorithm, as illustrated
    in the code fragment. Here is the output of this program:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建 `jump_strategy`，这是一个定义单位如何跳跃的对象。在这种情况下，它被作为参数传递给 `DwarfFighter` 的 `__init__`
    方法。或者，你也可以在这个类中定义一个默认策略对象，因为我们知道这个类的默认行为（单位不能跳跃）。然后你可以调用 `set_jump_strategy` 来切换到不同的跳跃算法，如代码片段所示。以下是这个程序的输出：
- en: '![Strategy solution 1 – Traditional approach](img/B05034_06_15.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![策略解决方案 1 – 传统方法](img/B05034_06_15.jpg)'
- en: Strategy solution 2 – Pythonic approach
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略解决方案 2 – Pythonic 方法
- en: 'What we discussed in the last section was more of a traditional approach, typically
    followed in programming languages such as C++. Given the flexibility that the
    Python language offers, there is no real need to define the various strategy classes
    as illustrated in the previous solution. We will exploit first-class functions,
    the language feature discussed earlier. Let''s look at the revised code. You can
    also find this code in the `strategypattern_pythonic.py` file in the code bundle:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个章节中讨论的更多的是一种传统方法，通常在像 C++ 这样的编程语言中遵循。鉴于 Python 语言提供的灵活性，实际上没有必要像前一个解决方案中那样定义各种策略类。我们将利用前面讨论的一等函数语言特性。让我们看看修改后的代码。你还可以在代码包中的
    `strategypattern_pythonic.py` 文件中找到这段代码：
- en: '![Strategy solution 2 – Pythonic approach](img/B05034_06_16.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![策略解决方案 2 – Pythonic 方法](img/B05034_06_16.jpg)'
- en: In the preceding code, we have used the Python language feature that supports
    assigning a function (`jump_strategy`) to a variable (`self.jump`). Why do we
    do this? It will become clear when we review the next code fragment. Before that,
    let's quickly discuss the preceding code snippet.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了 Python 语言支持将函数（`jump_strategy`）赋值给变量（`self.jump`）的功能。我们为什么要这样做？当我们回顾下一个代码片段时，答案就会变得清晰。在那之前，让我们快速讨论一下前面的代码片段。
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**What exactly do we accomplish with the following assert statement?**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**以下断言语句我们到底实现了什么？**'
- en: '[PRE7]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This statement is from `AbstractGameUnit.__init__` method in the earlier code
    snippet. Before assigning the function to a variable, we need to make sure that
    it is indeed a function. The assertion prevents further execution of the code
    if this condition is not met. The idea is simple. You want to make sure that `jump_strategy`
    is a callable object. Any callable object defines a built-in `__call__()` method.
    The `collections.abc.Callable` class is an abstract base class for all the classes
    that provide a built-in `__call__()` method. In the `assert` statement, we check
    whether `jump_strategy` is an instance of this `Callable` class. For Python 2.7.9,
    this class should be imported directly as `collections.Callable`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这段话来自前面代码片段中的 `AbstractGameUnit.__init__` 方法。在将函数赋值给变量之前，我们需要确保它确实是一个函数。这个断言语句会在条件不满足的情况下阻止代码的进一步执行。这个想法很简单。你想要确保
    `jump_strategy` 是一个可调用的对象。任何可调用的对象都定义了一个内置的 `__call__()` 方法。`collections.abc.Callable`
    类是所有提供内置 `__call__()` 方法的类的抽象基类。在 `assert` 语句中，我们检查 `jump_strategy` 是否是这个 `Callable`
    类的实例。对于 Python 2.7.9，这个类应该直接导入为 `collections.Callable`。
- en: 'As before, let''s review the code fragment that instantiates a game character
    (`dwarf`), and dynamically sets up different jump strategies:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，让我们回顾一下实例化游戏角色（`矮人`）并动态设置不同跳跃策略的代码片段：
- en: '![Strategy solution 2 – Pythonic approach](img/B05034_06_17.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![策略解决方案 2 – Pythonic 方法](img/B05034_06_17.jpg)'
- en: Compare this code with the first approach discussed earlier. There is a difference.
    In the previous solution, while instantiating `DwarfFighter`, we passed an instance
    of the class `CanNotJump` that deals with the jump behavior. Here, we pass the
    function `can_not_jump` as an argument, just like any simple variable. To dynamically
    change the `jump` algorithm, we just assign `dwarf.jump` to `power_jump`, as shown.
    Now when we call `dwarf.jump()`, it actually executes the code in the `power_jump()`
    function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码与之前讨论的第一个方法进行比较。这里有一个区别。在先前的解决方案中，在实例化`DwarfFighter`时，我们传递了一个处理跳跃行为的`CanNotJump`类的实例。在这里，我们传递了`can_not_jump`函数作为参数，就像任何简单变量一样。为了动态更改`jump`算法，我们只需将`dwarf.jump`赋值给`power_jump`，如图所示。现在当我们调用`dwarf.jump()`时，它实际上执行了`power_jump()`函数中的代码。
- en: Tip
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Remarks on the Pythonic way**:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于Python风格的方法**:'
- en: What we just saw was a cool Pythonic way that made things very easy. If you
    are coming from a C++ or Java programming background, at first you might feel
    uncomfortable with the freedom that Python offers. For example, there could be
    situations where a programmer mistakenly treats a function argument as a simple
    variable, leading to potential bugs. But this should not stop you from using this
    excellent language feature. To avoid such problems, you should document the code
    well so that the purpose of each input argument is clear.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到的是一个酷炫的Python风格，让事情变得非常简单。如果你来自C++或Java编程背景，一开始你可能不太适应Python提供的自由度。例如，可能会出现程序员错误地将函数参数视为简单变量的情况，从而导致潜在的bug。但这不应该阻止你使用这个出色的语言特性。为了避免这样的问题，你应该很好地记录代码，以便每个输入参数的目的清晰。
- en: Simple factory
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单工厂
- en: A simple factory is generally not viewed as a formal design pattern, but you
    will find it quite useful in your day-to-day programming. The understanding we
    gain at the end of this section will be helpful in the discussion on a more formal
    pattern called abstract factory design pattern. Let's start with the definition
    of a simple factory.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 简单工厂通常不被视为正式的设计模式，但你会在日常编程中发现它非常有用。在本节末尾获得的理解将有助于讨论一个更正式的模式，即抽象工厂设计模式。让我们从简单工厂的定义开始。
- en: A factory encapsulates the instance creation piece. The client code doesn't
    need to know the logic of instance creation. It just knows that whenever it needs
    an object of a specific type, the factory is the go-to place. Any class, or function,
    or class method that is used to construct such objects is often referred to as
    a factory. A simple factory is something you will use quite often. It is typically
    considered a better object-oriented technique than a formal design pattern.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂封装了实例创建的部分。客户端代码不需要知道实例创建的逻辑。它只知道，每当它需要特定类型的对象时，工厂就是首选的地方。任何用于构建此类对象的类、函数或类方法通常被称为工厂。简单工厂是你经常会用到的东西。它通常被认为比正式的设计模式更优秀的面向对象技术。
- en: Simple factory scenario – The recruit feature
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单工厂场景 – 招募功能
- en: '| *Recall that we had fast-forwarded the game to an imaginary future version
    called Attack of the Orcs v6.0.0\. This version introduced another much-anticipated
    feature that enabled recruiting new units to fight against the enemy.* |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| *回想一下，我们已将游戏快进到一个名为“Orcs的攻击v6.0.0”的虚构未来版本。这个版本引入了另一个备受期待的功能，允许招募新单位与敌人作战。*
    |'
- en: 'Here is the initial version of the `recruit` method of a new class, `Kingdom`.
    Other methods are not shown. Let''s assume those exist. Further assume that the
    player or the enemy is allowed to recruit any of the following game characters:
    `ElfRider`, `Knight`, `DwarfFighter`, `OrcRider`, and `OrcKnight`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是新类`Kingdom`的`recruit`方法的初始版本，其他方法未展示。让我们假设它们存在。进一步假设玩家或敌人可以招募以下游戏角色中的任何一个：`ElfRider`、`Knight`、`DwarfFighter`、`OrcRider`和`OrcKnight`：
- en: '![Simple factory scenario – The recruit feature](img/B05034_06_18.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![简单工厂场景 – 招募功能](img/B05034_06_18.jpg)'
- en: The `recruit` method has the logic to create a game unit based on user input
    (the `if..else` block). Once the character is created, `Kingdom` pays for the
    hiring fees (`pay_gold`), and a central database is updated to reflect the new
    addition to the army (`update_records`).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`recruit`方法包含基于用户输入（`if..else`块）创建游戏单位的逻辑。一旦角色创建完成，`Kingdom`就会支付雇佣费用（`pay_gold`），并且中央数据库会更新以反映军队中新成员的加入（`update_records`）。'
- en: Simple factory – The problem
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单工厂 – 问题
- en: '| *As expected, users liked this* *feature, and now want the ability to recruit
    even more unit types. Let''s see what Sir Foo has to say:* |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 如预期，用户喜欢这个*功能，现在希望有招募更多单位类型的能力。让我们看看Sir Foo有什么要说的：* |'
- en: '![Simple factory – The problem](img/B05034_06_19.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![简单工厂 – 问题](img/B05034_06_19.jpg)'
- en: 'Let''s add new recruit types, and to avoid Sir Foo''s wrath, remove `OrcKnight`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加新的招募类型，为了避免Sir Foo的愤怒，移除`OrcKnight`：
- en: '![Simple factory – The problem](img/B05034_06_20.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![简单工厂 – 问题](img/B05034_06_20.jpg)'
- en: As can be seen in the preceding code snippet, this is already becoming difficult
    to maintain. Tomorrow, you may decide to support even more units, or remove some
    of the existing ones. How do we handle this problem? Let's see that next.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，这已经变得难以维护。明天，你可能会决定支持更多的单位，或者移除一些现有的单位。我们如何处理这个问题？让我们看看下一个。
- en: Simple factory – Rethinking the design
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单工厂 – 重新思考设计
- en: What can we say about that big `if..else` block in the `recruit` method? It
    is subject to change. The rest of the code in the method is just the bookkeeping
    (for example, updating records) and remains unchanged. What if we take out the
    variable piece of code and give it a new home? It will take the load off the `recruit`
    method so that you don't need to open it for editing every time there is a change
    in the requirements. The next question to ask is where do we put this code?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能说些什么关于`recruit`方法中的那个大`if..else`块呢？它是可以改变的。方法中的其余代码只是记账（例如，更新记录）并且保持不变。如果我们把那块变量代码移除并给它一个新的家呢？这将减轻`recruit`方法的负担，这样你就不需要在需求有变化时每次都打开它进行编辑。接下来要问的问题是，我们将把这段代码放在哪里？
- en: '![Simple factory – Rethinking the design](img/B05034_06_21.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![简单工厂 – 重新思考设计](img/B05034_06_21.jpg)'
- en: Yes Fairy, that is an option. You can create a new method in the `Kingdom` class,
    and dump all this object creation code in there.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，Fairy，这是一个选项。你可以在`Kingdom`类中创建一个新的方法，并将所有这些对象创建代码放在那里。
- en: But imagine a game scenario where there is a grand galactic army, represented
    by a `GalacticArmy` class. This class needs a way to recruit or get various game
    characters. It is not at all related to the `Kingdom` class. Thus, we won't be
    able to reuse the object creation code in `Kingdom.recruit`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 但想象一下一个游戏场景，其中有一个庞大的银河系军队，由`GalacticArmy`类表示。这个类需要一种招募或获取各种游戏角色的方法。它与`Kingdom`类毫不相干。因此，我们无法在`Kingdom.recruit`中重用对象创建代码。
- en: Let's free the `Kingdom` class of the responsibility for creating new units.
    Once again, we will use the object composition principle. Let there be a new class
    (or even a function) that encapsulates the instance creation piece. We will call
    this a simple factory. The client code (the `Kingdom` or `GalacticArmy` class
    in this discussion) can now use this factory to get specific types of objects.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让`Kingdom`类摆脱创建新单位的责任。再一次，我们将使用对象组合原则。将有一个新的类（甚至是一个函数），它封装了实例创建的部分。我们将称之为简单工厂。客户端代码（在这个讨论中的`Kingdom`或`GalacticArmy`类）现在可以使用这个工厂来获取特定类型的对象。
- en: Simple factory solution 1 – Traditional approach
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单工厂解决方案 1 – 传统方法
- en: It is now time to implement the simple factory. Let's review a traditional approach
    first.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现简单工厂了。让我们首先回顾一下传统方法。
- en: Tip
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This is the bare minimum code, without any exception handling. The purpose is
    just to illustrate a simple factory using a style that somewhat resembles a C++
    implementation. You can make it more robust as an exercise. The code can be found
    in the `simplefactory_traditional.py` file. This example is written as a single
    module for ease of understanding. Ideally, you should refactor this, and put classes
    in their own modules.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最低限度的代码，没有任何异常处理。目的是仅仅为了说明使用类似于C++实现风格的简单工厂。你可以作为一个练习使它更健壮。代码可以在`simplefactory_traditional.py`文件中找到。这个例子被写成单个模块以方便理解。理想情况下，你应该重构它，并将类放在它们自己的模块中。
- en: 'Take a look at the following reworked code. We start with the new class, `UnitFactory`,
    which encapsulates the object creation piece:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的重构代码。我们从一个新的类开始，`UnitFactory`，它封装了对象创建的部分：
- en: '![Simple factory solution 1 – Traditional approach](img/B05034_06_22.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![简单工厂解决方案 1 – 传统方法](img/B05034_06_22.jpg)'
- en: 'In the preceding code, we have refactored out the big `if..else` clause in
    the `Kingdom.recruit` method discussed earlier, and put it in the `create_unit`
    method of the `UnitFactory` class. The `create_unit` method only has a single
    responsibility to create and return an instance of a game character for the given
    input argument (`unit_type`). The following is the `Kingdom` class after this
    refactoring:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将之前讨论的 `Kingdom.recruit` 方法中的大 `if..else` 子句重构出来，并将其放入 `UnitFactory`
    类的 `create_unit` 方法中。`create_unit` 方法只有一个职责，即根据给定的输入参数（`unit_type`）创建并返回一个游戏角色的实例。以下是在此重构后的
    `Kingdom` 类：
- en: '![Simple factory solution 1 – Traditional approach](img/B05034_06_23.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![简单工厂解决方案 1 – 传统方法](img/B05034_06_23.jpg)'
- en: 'The `self.factory` instance represents `UnitFactory`. In the `recruit` method,
    the responsibility for creating game characters is delegated to this factory object.
    The `pay_gold` and `update_records` methods are just shown for completeness. Let''s
    not worry about the logic inside these two methods. They remain unchanged. Finally,
    the following is one way to use the factory. The code is self-explanatory:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.factory` 实例代表 `UnitFactory`。在 `recruit` 方法中，创建游戏角色的责任委托给了这个工厂对象。`pay_gold`
    和 `update_records` 方法只是为了完整性而展示。让我们不要担心这两个方法内部的逻辑。它们保持不变。最后，以下是一种使用工厂的方法。代码是自解释的：'
- en: '![Simple factory solution 1 – Traditional approach](img/B05034_06_24.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![简单工厂解决方案 1 – 传统方法](img/B05034_06_24.jpg)'
- en: What we have not shown in this example is the actual implementation of the concrete
    product classes that our factory uses to create products, such as `ElfRider`,
    `Knight`, and so on. These classes are going to be similar to the ones we have
    discussed so far. For example, all these concrete classes can be subclasses of
    `AbstractGameUnit`. These details were not shown in the example we just covered.
    However, this is not the only way to implement a simple factory. In Python, we
    can deal with this problem in other ways as well. One such approach will be discussed
    next.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们没有展示的是我们工厂实际使用的具体产品类（如 `ElfRider`、`Knight` 等）的实现。这些类将与我们之前讨论过的类相似。例如，所有这些具体类都可以是
    `AbstractGameUnit` 的子类。这些细节在我们刚刚覆盖的例子中没有展示。然而，实现简单工厂的方法不止一种。在 Python 中，我们还可以用其他方式处理这个问题。接下来将讨论其中一种方法。
- en: Simple factory solution 2 – Pythonic approach
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单工厂解决方案 2 – Pythonic 方法
- en: There is one problem with the solution presented in the previous section. You
    still need to maintain the `if..else` block in `create_unit`. Another thing to
    ask is, do we really need to instantiate `UnitFactory`? Depending on your application,
    the answer could be yes or no. In this example, the `create_unit` code would be
    identical for each instance of the factory you create. So, we do not really need
    an instance of `UnitFactory`. Let's discuss how to implement a simple factory
    without actually instantiating it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中提出的解决方案有一个问题。你仍然需要在 `create_unit` 中维护 `if..else` 块。另一个问题是，我们真的需要实例化 `UnitFactory`
    吗？根据你的应用程序，答案可能是是或否。在这个例子中，`create_unit` 代码对于你创建的每个工厂实例都是相同的。所以，我们实际上不需要 `UnitFactory`
    的实例。让我们讨论如何在不实际实例化的情况下实现简单工厂。
- en: Tip
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: What is illustrated here is not the only way to implement a simple factory.
    The source code is available in the supporting material as `simplefactory_pythonic.py`.
    Depending on the type of problem you are dealing with, you can tweak this approach
    further, and come up with a different solution. For example, you can choose a
    factory instance, and access its methods as normal instance methods. This approach
    is illustrated in the `simplefactory_pythonic_alternatesolution.py` file.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的并不是实现简单工厂的唯一方法。源代码在支持材料中作为 `simplefactory_pythonic.py` 提供。根据你处理的问题类型，你可以进一步调整这种方法，并提出不同的解决方案。例如，你可以选择一个工厂实例，并像访问普通实例方法一样访问其方法。这种方法在
    `simplefactory_pythonic_alternatesolution.py` 文件中有展示。
- en: 'Here is the reworked `UnitFactory` class from the file `simplefactory_pythonic.py`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是来自文件 `simplefactory_pythonic.py` 的重新工作的 `UnitFactory` 类：
- en: '![Simple factory solution 2 – Pythonic approach](img/B05034_06_25.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![简单工厂解决方案 2 – Pythonic 方法](img/B05034_06_25.jpg)'
- en: 'Earlier in the chapter, we reviewed some Python language features that come
    in handy for design patterns. Let''s see how first-class classes and class methods
    can be used in a simple factory:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早期，我们回顾了一些对设计模式有帮助的 Python 语言特性。让我们看看如何使用一等类和类方法在简单工厂中应用：
- en: '`units_dict` is a Python dictionary object declared as a class variable (for
    the class `UnitFactory`).'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`units_dict` 是一个作为类变量声明的 Python 字典对象（对于 `UnitFactory` 类）。'
- en: Python classes are first-class objects. So we can simply put them as values
    of the dictionary, `units_dict`. The dictionary keys can be unique strings of
    your choice. Just make sure that the calling code knows which key corresponds
    to which class.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 类是一等对象。因此，我们可以简单地将其作为字典 `units_dict` 的值。字典键可以是您选择的唯一字符串。只需确保调用代码知道哪个键对应哪个类。
- en: The method `create_unit` is defined as a class method using the decorator `@classmethod`.
    What this means is that the first argument passed to this method is the class
    itself (denoted by `cls`) instead of being self (an instance of the class).
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_unit` 方法被定义为使用装饰器 `@classmethod` 的类方法。这意味着传递给此方法的第一个参数是类本身（表示为 `cls`），而不是
    `self`（类的实例）。'
- en: 'Now look at the `return` statement of the `create_unit` method:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在看看 `create_unit` 方法的 `return` 语句：
- en: '[PRE8]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we access `units_dict`, a class variable, as `cls.units_dict`, and get
    the value for a particular key given as an input argument. This can be better
    explained with an example. Assume that the given key is `elfrider`. The corresponding
    value in the dictionary is the `ElfRider` class. So, the `create_unit` method
    will return `ElfRider()`, which is an instance of the `ElfRider` class.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们通过 `cls.units_dict` 访问类变量 `units_dict`，并根据输入参数提供的特定键获取其值。这可以通过一个例子更好地解释。假设给定的键是
    `elfrider`。字典中对应的值是 `ElfRider` 类。因此，`create_unit` 方法将返回 `ElfRider()`，它是 `ElfRider`
    类的一个实例。
- en: Compare this code with the one we saw in the previous heading, *Simple factory
    solution 1 – Traditional approach*. As can be noticed, the number of lines of
    code has not been reduced significantly. But the code clarity is much better here.
    You still need to maintain the dictionary object (`units_dict`) for all future
    requirements, which is relatively easy compared to maintaining the `if..else`
    clause.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码与我们在上一标题中看到的代码进行比较，*简单的工厂解决方案 1 – 传统方法*。如可注意到，代码行数并没有显著减少。但这里的代码清晰度要好得多。您仍然需要维护字典对象（`units_dict`）以供所有未来的需求，这相对于维护
    `if..else` 子句来说相对容易。
- en: 'Now observe the `Kingdom` class. It has just a few changes:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在观察 `Kingdom` 类。它只有几个变化：
- en: '![Simple factory solution 2 – Pythonic approach](img/B05034_06_26.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![简单的工厂解决方案 2 – Pythonic 方法](img/B05034_06_26.jpg)'
- en: Let's review the preceding code snippet
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下前面的代码片段
- en: First, we assign the `UnitFactory` class to a class variable, `factory`. Again,
    we can do this because Python classes are first-class objects.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将 `UnitFactory` 类赋值给类变量 `factory`。我们之所以能够这样做，是因为 Python 类是一等对象。
- en: The `recruit` method is just a normal instance method of `Kingdom`. The class
    variable `factory` is accessed as `type(self).factory`.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recruit` 方法是 `Kingdom` 的一个普通实例方法。类变量 `factory` 通过 `type(self).factory` 访问。'
- en: In this example, `type(self).factory.create_unit` is equivalent to `UnitFactory.create_unit`.
    We could have directly written it that way, but if a subclass of `Kingdom` defines
    its `factory` as a different class, say `DwarfUnitFactory`, then it will require
    you to write some extra code, such as overriding the `recruit` method.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个例子中，`type(self).factory.create_unit` 等同于 `UnitFactory.create_unit`。我们本可以直接那样写，但如果
    `Kingdom` 的子类将其 `factory` 定义为不同的类，例如 `DwarfUnitFactory`，那么它将需要您编写一些额外的代码，例如重写
    `recruit` 方法。
- en: 'Finally, here is the calling code. Notice that we are not creating any `factory`
    instances:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是调用代码。请注意，我们没有创建任何 `factory` 实例：
- en: '![Simple factory solution 2 – Pythonic approach](img/B05034_06_27.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![简单的工厂解决方案 2 – Pythonic 方法](img/B05034_06_27.jpg)'
- en: The discussion on the simple factory has set the stage for the formal design
    pattern called the abstract factory pattern. Let's review that next.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对简单工厂的讨论为正式设计模式——抽象工厂模式奠定了基础。让我们接下来回顾一下。
- en: Abstract factory pattern
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂模式
- en: We have just learned how to create and use a simple factory in a program. Let's
    go a little further and study a formal pattern known as the abstract factory pattern.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学习了如何在程序中创建和使用简单的工厂。让我们更进一步，研究一个称为抽象工厂模式的形式化模式。
- en: Imagine we have a master factory and some follower factories. Further assume
    that each follower factory is responsible for producing its own trademark products
    (objects). The follower factories are related in some sense. They create products
    that share a common theme. For example, each follower factory produces its own
    version of tomato ketchup. The factories have their own ordering form for their
    product.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们有一个主工厂和一些跟随工厂。进一步假设每个跟随工厂负责生产其自己的品牌产品（对象）。跟随工厂在某种程度上是相关的。它们创建具有共同主题的产品。例如，每个跟随工厂都生产其自己的番茄酱版本。这些工厂有自己的产品订购表格。
- en: 'The customers have a hard time in keeping up with so many forms for ordering
    a tomato ketchup. For example, one factory says you should call it MyRedTomatoKetchup,
    otherwise it won''t understand. So, the master factory says:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 客户在保持这么多订购番茄酱的表格方面感到困难。例如，一个工厂说你应该称之为MyRedTomatoKetchup，否则它不会理解。因此，主工厂说：
- en: '| *We make products that are like a part of an extended family. Our customers
    would benefit if we can simplify and standardize the procedure to order these
    products from our group of factories. From now on, every follower factory is required
    to implement a common ordering form.* |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| *我们制造的产品就像一个大家庭的一部分。如果我们可以简化并标准化从我们工厂集团订购这些产品的程序，我们的客户将受益。从现在起，每个跟随工厂都必须实现一个共同的订购表格。*
    |'
- en: 'The customers benefit, as they just need to know the high-level name tomato
    ketchup and the factory that can supply this product. Let''s put this into programming
    terminology:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 客户受益，因为他们只需要知道高级名称番茄酱和可以提供这种产品的工厂。让我们用编程术语来表达这一点：
- en: The master factory is an abstract factory, and the follower factories are concrete
    factories.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主工厂是一个抽象工厂，而跟随工厂是具体工厂。
- en: The tomato ketchup is an abstract class. Every concrete factory creates its
    custom version of tomato ketchup; we will call this a concrete object (an instance
    of a concrete class).
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 番茄酱是一个抽象类。每个具体工厂都创建其定制的番茄酱版本；我们将称之为具体对象（具体类的实例）。
- en: The standardization procedure referenced earlier is called an interface. The
    abstract factory declares such an interface (or in Python terms, a set of abstract
    methods) that is required to be implemented by the concrete factories for creating
    families of concrete objects.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前提到的标准化程序被称为接口。抽象工厂声明了这样一个接口（或者用Python术语来说，一组抽象方法），具体工厂必须实现它以创建具体对象系列。
- en: The customer is the client code. It doesn't need to know the details of the
    concrete object received from a concrete factory. It just needs to have knowledge
    of the abstract class.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户是客户端代码。它不需要知道从具体工厂接收到的具体对象的详细信息。它只需要了解抽象类。
- en: Note
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Java programming language has a provision to create an abstract type called
    interface. If a class implements an interface, it must implement all the methods
    described by that interface. For more information on interface in the Java language,
    visit the wiki page: [https://en.wikipedia.org/wiki/Interface_(Java)](https://en.wikipedia.org/wiki/Interface_(Java)).
    In Python, there is no such formal provision to create and implement an interface.
    Instead, we can use inheritance, where concrete factories inherit from the abstract
    factory. Instead, we can use the first-class features offered by Python, as discussed
    earlier. Let''s see these next.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Java编程语言有一个创建抽象类型接口的条款。如果一个类实现了接口，它必须实现该接口描述的所有方法。有关Java语言中接口的更多信息，请访问维基页面：[https://en.wikipedia.org/wiki/Interface_(Java)](https://en.wikipedia.org/wiki/Interface_(Java))。在Python中，没有这样的正式条款来创建和实现接口。相反，我们可以使用继承，具体工厂从抽象工厂继承。或者，我们可以使用之前讨论过的一等特性。让我们看看这些。
- en: Quite a mouthful? Let's dig deeper into the abstract factory pattern with a
    game scenario.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 太多了？让我们通过一个游戏场景更深入地了解抽象工厂模式。
- en: Abstract factory scenario – An accessory store
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象工厂场景 – 配件商店
- en: '| *Imagine* *you have implemented a new feature that enables buying accessories
    for your army. At the moment, you can buy an armored jacket or a gold locket,
    as shown in the following code fragment:* |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| *想象一下，你已经实现了一个新功能，允许为你的军队购买配件。目前，你可以购买装甲夹克或金质护身符，如下面的代码片段所示：* |'
- en: '![Abstract factory scenario – An accessory store](img/B05034_06_28.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![抽象工厂场景 – 配件商店](img/B05034_06_28.jpg)'
- en: 'More choices for armor and lockets were added as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了更多关于装甲和护身符的选择如下：
- en: '![Abstract factory scenario – An accessory store](img/B05034_06_29.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: '| *You reworked the preceding piece of code, and implemented a simple factory
    instead. This factory would produce all the accessories for the game characters.
    In this example, it would return armor and locket objects.* |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: 'The reworked code, which implements a simple factory, is shown next:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory scenario – An accessory store](img/B05034_06_30.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
- en: 'The `Kingdom` class and the main execution code is shown next. The `Kingdom`
    class has an instance variable, `self.factory`, which represents our simple factory:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory scenario – An accessory store](img/B05034_06_31.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: The `self.factory` variable is used to create `armor` and `locket` instances,
    as indicated in the `buy_accessories` method.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As illustrated in the section on simple factories, the factory can also be specified
    as a class attribute accessed as `Kingdom.factory`, instead of creating an instance,
    `self.factory`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory scenario – An accessory store](img/B05034_06_49.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: '| *The changes you made simplified the implementation. Looks like Sir Foo is
    quite happy with his new Iron jacket, however, that doesn''t seem to be the case
    with others! There is a* *new problem...* |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
- en: Abstract factory – The problem
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| *One size* *doesn''t fit all! The DwarfKingdom is now using this AccessoryFactory,
    and has reported problems with the products:* |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
- en: '![Abstract factory – The problem](img/B05034_06_32.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: '| *The Great Dwarf has reason to be annoyed. The factory does not support customization
    for the products it creates. How do we address this?* |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: This is one scenario where we can use the abstract factory pattern.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Abstract factory – Rethinking the design
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Observe the following class diagram. It represents a typical abstract factory
    pattern, our approach to solve the problem:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory – Rethinking the design](img/B05034_06_33.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: 'Let''s review the components of the UML-like diagram presented here, and correlate
    them with the terms used in the earlier definition of an abstract factory:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '`DwarfAccessoryFactory`, `ElfAccessoryFactory`: The follower or concrete factories.
    Recall that each concrete factory creates products that share a common theme.
    Here, they create accessories for the game characters. As mentioned earlier, they
    are required to implement standard procedures set by the master factory.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AbstractAccessoryFactory`: This is the abstract factory class, or what we
    referred to as a master factory earlier. It defines an interface (a set of abstract
    methods) that must be implemented by the concrete factories. In this case, each
    of the concrete factories is required to implement methods to create armors and
    lockets.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, each concrete factory implements the `create_armor` and `create_locket`
    methods. These methods return instances of concrete product classes. Thus, each
    factory creates its own flavor of the products. For instance, `create_locket`
    of `DwarfAccessoryFactory` returns an instance of `DwarfGoldLocket`, whereas the
    same method in `ElfAccessoryFactory` returns an instance of `ElfGoldLocket`.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AbstractArmor`, `AbstractLocket`: These are abstract product classes. There
    could be several concrete product types that inherit from these abstract classes.
    For example, the concrete product classes `DwarfGoldLocket` and `SuperLocket`
    inherit from `AbstractLocket`, and so on.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The client code**: This is not shown in the class diagram. The client code
    doesn''t need to know which concrete product class gives it the desired product.
    It just knows the high-level name of the product (for example, `create_locket`).
    Essentially, it chooses the factory, and invokes the standard API methods, such
    as `create_locket`, to get the required objects. See the next solution section
    for an example.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying the design further
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding class diagram shows a classic way of implementing the abstract
    factory pattern. For ease of understanding, let's simplify the problem further.
    We will assume that all the concrete factories define the required methods without
    the abstract factory enforcing the rule (interface) to do so.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: With this assumption, we could even remove the `AbstractAccessoryFactory` class
    from the design, and just have the concrete factories. Recall that we discussed
    duck typing at the beginning of this chapter. So as long as the concrete factories
    implement the required methods, the client code (see `Knight.buy_accessories`
    in the next example) won't complain.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: For conceptual understanding, we will retain the inheritance hierarchy in the
    upcoming discussion. We will call this class simply `AccessoryFactory`, and won't
    define `create_armor` and `create_locket` as abstract methods. Enforcing an interface
    will require some minor adjustments in the code. We will briefly discuss this
    as an optional or advanced topic at the end of the next section, where we look
    at the actual implementation.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Abstract factory solution – Pythonic approach
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we saw a representative class diagram that shows the
    implementation details for the abstract factory pattern. We will discuss only
    a Pythonic solution for implementing this pattern. Since we have already covered
    the simple factory in depth, the abstract factory pattern is just a few steps
    away. We will limit our discussion to some of the important classes. Look at the
    `abstractfactory_pythonic.py` file in the supporting code for the complete source.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Kingdom` and `DwarfKingdom` classes are shown next. The code is self explanatory,
    and was pretty much discussed earlier:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory solution – Pythonic approach](img/B05034_06_34.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at the `AccessoryFactory` class (see a note on design simplification
    under the previous heading, *Simplifying the design further*):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory solution – Pythonic approach](img/B05034_06_35.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
- en: This is very similar to the `UnitFactory` class we reviewed in the section on
    simple factory implementation. The only difference is that the factory produces
    two separate products, `armor` and `locket`. So, we have two different class methods
    (factory methods) for creating each of the concrete products. The `armor_dict`
    dictionary holds armor-related concrete classes as its values, and `locket_dict`
    is used for the locket-related classes. Both of these are defined as class variables.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet is for `DwarfAccessoryFactory`, one of the concrete
    factories. Here, we have only redefined the `armor_dict` and `locket_dict` dictionaries.
    Nothing else changes. Likewise, you can define other concrete factories such as
    `ElfAccesoryFactory`. If you want a strict abstract factory pattern implementation,
    you should also enforce an interface in the concrete factory. This is briefly
    discussed at the end of this section:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory solution – Pythonic approach](img/B05034_06_36.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
- en: 'The last piece of the puzzle is the main execution code. It creates two kingdoms,
    the first is a default `Kingdom`, and the second is a kingdom of *The Great Dwarfs*—`DwarfKingdom`.
    This is done as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory solution – Pythonic approach](img/B05034_06_37.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
- en: 'Observe that `buy_accessories` is invoked for both the kingdoms with the same
    arguments, `ironjacket` and `goldlocket`. But what each kingdom gets as the concrete
    product depends on the factory chosen. For example, as the `DwarfKingdom` has
    selected `DwarfAccessoryFactory` as its factory, for the abstract product named
    `ironjacket` it would get an instance of `DwarfIronJacket`. The following is a
    sample output of the code in the `abstractfactory_pythonic.py` file:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '![Abstract factory solution – Pythonic approach](img/B05034_06_38.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
- en: Advanced topic – enforcing an interface
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section illustrates one way of enforcing an interface in Python. If this
    does not mean anything to you right now, just ignore this and move on to the next
    topic.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that for ease of illustrating a Pythonic solution, we had simplified
    the problem. `AccessoryFactory` does not enforce any rule that requires the subclasses
    to implement the `create_armor` and `create_locket` methods. Actually, it is easy
    to do so. If you are using Python 3.3 or higher, you can simply define these methods
    as abstract methods in addition to being class methods, using the two decorators,
    `@classmethod` and `@abstractmethod`, like so:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In subclasses such as `DwarfAccessoryFactory`, you just need to implement these
    class methods. For completeness, make `AccessoryFactory` abstract by inheriting
    from `ABCMeta`. Technically, that would confirm the formal design of an abstract
    factory. But if you look at the code inside this method (`create_armor`), it hasn't
    changed a bit. Thus, in this example, declaring an abstract method would help
    only to enforce the rule that subclasses must implement certain methods.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Adapter pattern
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The adapter design pattern enables a handshake between two incompatible interfaces.
    Here, the incompatible interface of a class or a library is transformed into the
    one expected by your client code. This transformation is accomplished by an adapter
    class. The other class with a different interface than what the client expects
    is often referred to as an adaptee.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: There are two broad categories of adapter pattern, namely a class adapter pattern
    and an object adapter pattern. In the former, the adapter inherits from the adaptee.
    It is possible to implement a class adapter in Python, as the language supports
    multiple inheritance. However, it is better to choose object composition (has
    a relationship) over inheritance. In the object adapter pattern, the adapter object
    has an adaptee object instead of inheriting from the adaptee class. The object
    adapter pattern helps maintain a loose coupling between the adaptee and the client
    code, wherein the client does not need to have any knowledge of the adaptee interface.
    This offers more flexibility when compared to the class adapter pattern.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming discussion, we will only talk about the object adapter pattern.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Adapter scenario – Elf's distant cousin
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| *Let''s fast-forward to an* *imaginary future one more time. A group of developers
    has approached you. They have been working on a similar fantasy game application.
    Given the popularity of your game, they would like to collaborate. It''s a win-win
    situation for both parties. You happily accept this proposal, as it will give
    you access to several game characters in their collection.* |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
- en: Adapter – The problem
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You begin the integration work, and notice a problem. Let''s hear it from our
    friend, the Elf:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '![Adapter – The problem](img/B05034_06_39.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: The code that follows highlights this problem further. What is shown here is
    a simplified version of the new `WoodElf` class that only shows the `leap()` method.
    Assume that all its other methods match our existing interface.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is no correlation between the `jump` method (rather, the jump strategies)
    discussed in the section on *Strategy pattern* with the one illustrated here.
    For easier understanding of the pattern, only the bare minimum code is shown.
    For example, the `AbstractGameUnit` class is not used here. As an exercise, try
    to use the code from the strategy pattern here, and implement an adapter so that
    we can talk to `WoodElf` (the solution is not provided)!
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '![Adapter – The problem](img/B05034_06_40.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
- en: Adapter – Attempted solution
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| *The new class* *doesn''t have a leap() method. How can we solve this problem?
    Any thoughts, Fairy?* |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
- en: '![Adapter – Attempted solution](img/B05034_06_41.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
- en: We could have possibly done that, but this code is owned by a third party. If
    they have shared the source, then you can update it. But that is going to be a
    maintenance overhead for you. If you don't have the source code, then you have
    to depend on them to get this method supported. For all these reasons, the solution
    suggested by the Fairy may not be the best way to go forward. That said, the Fairy
    is on the right track! She has a `jump()` method that delegates this to the `leap()`
    method. Let's see how the adapter pattern can help here.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'How about adding a new class that enables a handshake between these two interfaces?
    Look at the following code fragment:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '![Adapter – Attempted solution](img/B05034_06_42.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
- en: 'This last code fragment seems to address one issue. We do not need to make
    any changes to the third-party class `WoodElf`. We feed an instance of `WoodElf`
    to the adapter, `WoodElfAdapter`. This adapter class has a `jump` method, which
    calls the `leap` method of `WoodElf`. The client code simply needs to use this
    adapter instance instead of the `WoodElf` instance. However, there are two main
    problems with this solution:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: The adapter class seems to be tied to the `WoodElf` class. What if we have a
    new class, `MountainElf`, which implements the `spring` method as an equivalent
    of the `jump` method?
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imagine that the `WoodElf` class has other methods such as `attack`, `info`,
    `climb`, and so on. Some might already be compatible with the existing interface,
    while for others, there is no equivalent. All such methods can be directly called
    without any special processing like what was done for `leap()`. If we follow the
    approach discussed in the preceding code fragment, you will have to define each
    of these methods in the adapter class `WoodElfAdapter`. Without implementing them,
    you won't be able to use the adapter class seamlessly in your client code. That's
    quite a bit of work.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is very easy to address both these problems. Let's write a generalized solution
    next.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Adapter solution – Pythonic approach
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To summarize the problem, a new class, `WoodElf`, provided by third-party developers,
    has a `leap()` method instead of `jump()`. Put another way, it has an incompatible
    interface. We are seeking a solution that doesn't require us to touch the `WoodElf`
    class. We created an adapter, `WoodElfAdapter`, but it had its own shortcomings,
    as discussed in the previous section, *Adapter – Attempted Solution*.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s generalize the adapter class further to address these issues. See the
    supplementary `adapterpattern.py` file for the source code. This will be illustrated
    next. First look at the following code fragment, and then we will talk through
    it:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '![Adapter solution – Pythonic approach](img/B05034_06_43.jpg)![Adapter solution
    – Pythonic approach](img/B05034_06_44.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
- en: 'The following things are to be noted in the preceding code screenshots:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: The adapter class is renamed as `ForeignUnitAdapter`.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first input argument, `adaptee`, represents the instance of the class for
    which we need an adapter. The second argument, `adaptee_method`, is the instance
    method that needs to be adapted (for example, `wood_elf.leap` needs to be interpreted
    as a `jump` method).
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we take advantage of the Python first-class functions to assign `adaptee_method`
    to `self.jump`. For example, calling `self.jump()` is now equivalent to calling
    `wood_elf.leap()`. This eliminates the need to create a separate `jump` method
    inside the adapter class.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Earlier in the chapter, we learned about the `__getattr__` method. Here, we
    have implemented it in the adapter class `ForeignUnitAdapter`. The client code
    assumes that the adapter object (which represents a third-party game character),
    has defined methods such as `info()`, `attack()`, and `climb()`. The client calls
    these methods using the adapter object. In reality, the adapter class has not
    defined any of them. It relies on `self.foreign_unit` to provide these methods.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This handling code is written in the `__getattr__` method. Here, `getattr(self.foreign_unit,
    item)` would simply return `self.foreign_unit.item`.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can create multiple adapter objects by passing in different instances of
    the game units, and the method that needs to be the adapter. One such example
    is shown in the preceding code fragment.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapter – Multiple adapter methods
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the earlier illustration, we assumed that `self.jump` would be the handling
    adapter method. What if we have multiple methods that need to be an adapter to
    conform to our existing API? You can generalize this implementation further. Here
    is one way to handle multiple methods. This source can be found in the supporting
    code bundle. Look for the `adapterpattern_multiple_methods.py` file:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '![Adapter – Multiple adapter methods](img/B05034_06_45.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
- en: 'The following is the main execution code:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '![Adapter – Multiple adapter methods](img/B05034_06_48.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
- en: 'Again, we take advantage of the Python first-class functions. The `set_adapter`
    method uses a built-in method, `setattr()`, to set new attributes for the `ForeignUnitAdapter`
    class. These act as the adapter methods. Alternatively, you can also set the attributes
    as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Summary
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provided an introduction to design patterns in Python, an important
    aspect of application development. We started this chapter with an introduction
    and saw how design patterns are classified. Next we reviewed some key features
    offered by the Python language that help simplify several design patterns. With
    practical illustrations, you learned how design patterns can be implemented to
    provide a solution to recurring problems in application development. More specifically,
    you learned about strategy, abstract factory, and adapter patterns. For each of
    these patterns, we first used an interesting game scenario to describe the problem.
    We then discussed how the design pattern can tackle this problem, and further
    implemented the design pattern using a Pythonic approach. For some patterns, we
    also reviewed a traditional approach to implementing the design pattern. Last
    but not the least, we met some of Sir Foo's new friends.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Python中的设计模式，这是应用开发的一个重要方面。我们以一个介绍开始本章，并了解了设计模式的分类。接下来，我们回顾了Python语言提供的几个关键特性，这些特性有助于简化几个设计模式。通过实际示例，你学习了如何实现设计模式以解决应用开发中反复出现的问题。更具体地说，你学习了策略模式、抽象工厂模式和适配器模式。对于这些模式中的每一个，我们首先用一个有趣的游戏场景来描述问题。然后，我们讨论了设计模式如何解决这个问题，并进一步使用Python风格实现了设计模式。对于某些模式，我们还回顾了实现设计模式的传统方法。最后但同样重要的是，我们遇到了Sir
    Foo的一些新朋友。
- en: So far, we have discussed several important aspects of application development.
    This discussion helped us write better code, make the application more robust,
    and increase the application's life expectancy. In the next three chapters, we
    will learn various ways to improve the performance of the application.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了应用开发中的几个重要方面。这次讨论帮助我们编写更好的代码，使应用更加健壮，并延长了应用的使用寿命。在接下来的三章中，我们将学习各种提高应用性能的方法。
