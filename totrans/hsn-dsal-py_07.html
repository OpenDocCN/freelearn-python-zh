<html><head></head><body>
  <div><h1 class="chapterNumber">7</h1>
    <h1 id="_idParaDest-153" class="chapterTitle">Heaps and Priority Queues</h1>
    <p class="normal">A heap data structure is a tree-based data structure in which each node of the tree has a specific relationship with other nodes, and they are stored in a specific order. Depending upon the specific order of the nodes in the tree, heaps can be of different types, such as a <code class="inlineCode">min</code> heap and a <code class="inlineCode">max</code> heap.</p>
    <p class="normal">A priority queue <a id="_idIndexMarker605"/>is an important data structure that is similar to the queue and stack data structures that stores data along with the priority associated with them. In this, the data is served according to the priority. Priority queues can be implemented using an array, linked list, and trees; however, they are often implemented using a heap as it is very efficient.</p>
    <p class="normal">In this chapter, we will learn the following:</p>
    <ul>
      <li class="bulletList">The concept of the heap data structure and different operations on it</li>
      <li class="bulletList">Understanding the concept of the priority queue and its implementation using Python</li>
    </ul>
    <h1 id="_idParaDest-154" class="heading-1">Heaps</h1>
    <p class="normal">A heap data structure<a id="_idIndexMarker606"/> is a specialization of a tree in which the nodes are ordered in a specific way. A heap is a data structure where each data elements satisfies a <code class="inlineCode">heap</code> property, and the <code class="inlineCode">heap</code> property states that there must be a certain relationship between a parent node and its child nodes. According to this certain relationship in<a id="_idIndexMarker607"/> the tree, the <a id="_idIndexMarker608"/>heaps can be of two types, in other words, <code class="inlineCode">max</code> heaps and <code class="inlineCode">min</code> heaps. In a <code class="inlineCode">max</code> heap, each parent node value must always be greater than or equal to all its children. In this kind of tree, the <code class="inlineCode">root</code> node must be the greatest value in the tree. For example, see <em class="italic">Figure 7.1</em> showing the <code class="inlineCode">max</code> heap in which all the nodes have greater values compared to their children:</p>
    <figure class="mediaobject"><img src="img/B17217_07_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.1: An example of a max heap</p>
    <p class="normal">In a <code class="inlineCode">min</code> heap, the <a id="_idIndexMarker609"/>relationship between parent and children<a id="_idIndexMarker610"/> is that<a id="_idIndexMarker611"/> the value of the parent node must always be <a id="_idIndexMarker612"/>less than or equal to its children. This rule should be followed by all the nodes in the tree. In the <code class="inlineCode">min</code> heap, the <code class="inlineCode">root</code> node holds the lowest value. For example, see <em class="italic">Figure 7.2</em> showing the <code class="inlineCode">min</code> heap in which all the nodes have smaller values compared to their children:</p>
    <figure class="mediaobject"><img src="img/B17217_07_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.2: An example of a min heap</p>
    <p class="normal">The heap<a id="_idIndexMarker613"/> is an important data structure due to its several <a id="_idIndexMarker614"/>applications and uses in implementing heap sort algorithms and priority queues. We will be discussing these in detail later in the chapter. The heap can be any kind of tree; however the most common type of heap is a binary heap in which each node has at most two children.</p>
    <p class="normal">If the <a id="_idIndexMarker615"/>binary heap<a id="_idIndexMarker616"/> is a <strong class="keyWord">complete binary tree</strong> with <code class="inlineCode">n</code> nodes, then<a id="_idIndexMarker617"/> it will have a minimum height<a id="_idIndexMarker618"/> of <code class="inlineCode">log</code><sub class="subscript">2</sub><code class="inlineCode">n</code>. </p>
    <p class="normal">A complete binary tree is one in which each row must be fully filled before starting to fill the next row, as shown in the following <em class="italic">Figure 7.3</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_07_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.3: An example of a complete binary tree</p>
    <p class="normal">In order to <a id="_idIndexMarker619"/>implement the heap, we can derive a relationship <a id="_idIndexMarker620"/>between parent and child nodes in <code class="inlineCode">index</code> values. The relationship is that the children of any node at the <code class="inlineCode">n</code> index can be retrieved easily, in other words, the left child will be located at <code class="inlineCode">2n</code>, and the right child will be located at <code class="inlineCode">2n + 1</code>. For example, the node <code class="inlineCode">C</code> would be at the index of <code class="inlineCode">3</code>, since node <code class="inlineCode">C</code> is a right child of the node <code class="inlineCode">A</code>, which is at index <code class="inlineCode">1</code>, so it becomes <code class="inlineCode">2n+1 = 2*1 + 1 = 3</code>. This relationship always holds true. Let’s say we have a list of elements <code class="inlineCode">{A, B, C, D, E}</code> as shown in <em class="italic">Figure 7.4</em>. If we store any element at an index of <code class="inlineCode">i</code>, then its parent can be stored at index <code class="inlineCode">i/2</code>, for example, if the index of the node <code class="inlineCode">D</code> is <code class="inlineCode">4</code>, then its parent would be at 4/2 = 2, index <code class="inlineCode">2</code>. The index of root has to be starting from 1 in the array. See <em class="italic">Figure 7.4</em> to understand the concept:</p>
    <figure class="mediaobject"><img src="img/B17217_07_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.4: Binary tree and index positions of all the nodes</p>
    <p class="normal">This relation between parent and child is a complete binary tree. In respect of indexing values, it is very important in order to efficiently retrieve, search, and store the data elements in the heap. Due to this property, it is very easy to implement the heap. The only constraint is that we should have indexing starting from <code class="inlineCode">1</code>, and if we implement the heap using an array, then we have to add one dummy element at index <code class="inlineCode">0</code> in the array. Next, let’s understand the implementation of the heap. It is important to note that we will be discussing all the concepts with respect to the <code class="inlineCode">min</code> heap, and the implementation for the <code class="inlineCode">max</code> heap will be very similar to it, with the only difference being the <code class="inlineCode">heap</code> property. </p>
    <p class="normal">Let’s discuss the<a id="_idIndexMarker621"/> implementation of the <code class="inlineCode">min</code> heap using Python. We start with the <code class="inlineCode">heap</code> class, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">    class MinHeap: 
        def __init__(self): 
            self.heap = [0] 
            self.size = 0 
</code></pre>
    <p class="normal">We initialize the heap list with a zero to represent the dummy first element, and we are adding a dummy element just to start the indexing of data items from <code class="inlineCode">1</code> since if we start indexing from <code class="inlineCode">1</code>, accessing of the elements becomes very easy due to the parent-child relationship. We also create a variable to hold the size of the heap. We will further discuss different <a id="_idIndexMarker622"/>operations, such as <code class="inlineCode">insert</code>, <code class="inlineCode">delete</code>, and <code class="inlineCode">delete</code> at a specific location in the heap. Let’s start with the insertion operation in the heap.</p>
    <h2 id="_idParaDest-155" class="heading-2">Insert operation</h2>
    <p class="normal">The<a id="_idIndexMarker623"/> insertion of an item into a <code class="inlineCode">min</code> heap works in<a id="_idIndexMarker624"/> two steps. First, we add the new element to the end of the list (which we understand to be the bottom of the tree), and we increment the size of the heap by one. Secondly, after each insertion operation, we need to arrange the new element up in the heap tree, to organize all the nodes in such a way that satisfies the <code class="inlineCode">heap</code> property, which in this case is that each node must be larger than its parent. In other words, the value of the parent node must always be less than or equal to its children, and the lowest element in the <code class="inlineCode">min-heap</code> needs to be the root element. Therefore, we first insert an element into the last heap of the tree; however, after inserting an element into the heap, it is possible that the <code class="inlineCode">heap</code> property is violated. In that case, the nodes have to be rearranged so that all the nodes satisfy the <code class="inlineCode">heap</code> property. This process is called heapifying. To heapify the <code class="inlineCode">min</code> heap, we need to find the minimum of its children and swap it with the current element, and this process has to be repeated until the <code class="inlineCode">heap</code> property is satisfied for all the nodes. </p>
    <p class="normal">Let’s consider an example of adding an element in the <code class="inlineCode">min</code> heap, such as inserting a new node with a value of <code class="inlineCode">2</code> in <em class="italic">Figure 7.5</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_07_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.5: Insertion of a new node 2 in the existing heap</p>
    <p class="normal">The new element will be added to the last position in the third row or level. Its index value is <code class="inlineCode">7</code>. We compare that value with its parent. The parent is at index <code class="inlineCode">7/2 = 3</code> (integer division). The <a id="_idIndexMarker625"/>parent node holds value <code class="inlineCode">6</code>, which is <a id="_idIndexMarker626"/>higher than the new node value (in other words, 2), so according to the property of the <code class="inlineCode">min</code> heap, we swap these values, as shown in <em class="italic">Figure 7.6</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_07_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.6: Swapping nodes 2 and 6 to maintain the heap property</p>
    <p class="normal">The new data element has been swapped and moved up to index <code class="inlineCode">3</code>. Since, we have to check all the nodes up to the root, we check the index of its parent node which is <em class="italic">3/2 = 1 (integer division)</em>, so we continue the process to heapify. </p>
    <p class="normal">So, we compare both of these elements, and swap again, as shown in <em class="italic">Figure 7.7</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_07_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.7: Swapping nodes 2 and 3 to maintain the heap property</p>
    <p class="normal">After the final swap, we<a id="_idIndexMarker627"/> reach the root. Here, we can notice that this heap adheres to the definition <a id="_idIndexMarker628"/>of the <code class="inlineCode">min</code> heap, as shown in <em class="italic">Figure 7.8</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_07_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.8: Final heap after insertion of a new node 2</p>
    <p class="normal">Now, let’s take another example to see how to create and insert elements in a heap. We start with the construction of a heap by inserting 10 elements, one by one. The elements are <code class="inlineCode">{4, 8, 7, 2, 9, 10, 5, 1, 3, 6}</code>. We can see a step-by-step process to insert elements into the heap in <em class="italic">Figure 7.9</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_07_09.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.9: The step-by-step procedure to create a heap</p>
    <p class="normal">We can see, in <a id="_idIndexMarker629"/>the preceding diagram, a step-by-step process<a id="_idIndexMarker630"/> to insert elements into the heap. Here, we continue adding elements, as shown in <em class="italic">Figure 7.10</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_07_10.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.10: Steps 7 to 9 in creating the heap</p>
    <p class="normal">Finally, we<a id="_idIndexMarker631"/> insert an element, <code class="inlineCode">6</code>, into the heap, as <a id="_idIndexMarker632"/>shown in <em class="italic">Figure 7.11</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_07_11.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.11: Last step and construction of the final heap</p>
    <p class="normal">The<a id="_idIndexMarker633"/> implementation of the insertion operation in <a id="_idIndexMarker634"/>the heap is discussed as follows. Firstly, we create a helper method, called the <code class="inlineCode">arrange</code>, that takes care of arrangements of all the nodes after insertion of a new node. Here is the implementation of the <code class="inlineCode">arrange()</code> method, which should be defined in the <code class="inlineCode">MinHeap</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">    def arrange(self, k):
        while k // 2 &gt; 0:
            if self.heap[k] &lt; self.heap[k//2]:
                self.heap[k], self.heap[k//2] = self.heap[k//2], self.heap[k]
            k //= 2
</code></pre>
    <p class="normal">We execute the loop until we reach up to the <code class="inlineCode">root</code> node; until then, we can keep arranging the element. Here, we are using integer division. The loop will break out after the following condition:</p>
    <pre class="programlisting code"><code class="hljs-code">    while k // 2 &gt; 0:
</code></pre>
    <p class="normal">After that, we compare the values between the parent and child node. If the parent is greater than the child, swap the two values:</p>
    <pre class="programlisting code"><code class="hljs-code">        if self.heap[k] &lt; self.heap[k//2]: 
            self.heap[k], self.heap[k//2] = self.heap[k//2], self.heap[k] 
</code></pre>
    <p class="normal">Finally, after each iteration, we move up in the tree:</p>
    <pre class="programlisting code"><code class="hljs-code">             k //= 2 
</code></pre>
    <p class="normal">This method ensures that the elements are ordered properly.</p>
    <p class="normal">Now, for <a id="_idIndexMarker635"/>adding new elements in the heap, we need to use the following <code class="inlineCode">insert</code> method, which should be defined in the <code class="inlineCode">MinHeap</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">    def insert(self, item): 
        self.heap.append(item) 
        self.size += 1 
        self.arrange(self.size) 
</code></pre>
    <p class="normal">In the <a id="_idIndexMarker636"/>above code, we can insert an element using the <code class="inlineCode">append</code> method; then we increase the size of the heap. Then, in the last line of the <code class="inlineCode">insert</code> method, we call the <code class="inlineCode">arrange()</code> method to reorganize the heap (heapify it) to ensure that all the nodes in the heap satisfy the <code class="inlineCode">heap</code> property.</p>
    <p class="normal">Now, let’s create the heap and insert that data <code class="inlineCode">{4, 8, 7, 2, 9, 10, 5, 1, 3, 6}</code> using the <code class="inlineCode">insert()</code> method, which is defined in the <code class="inlineCode">MinHeap</code> class, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">    h = MinHeap()
    for i in (4, 8, 7, 2, 9, 10, 5, 1, 3, 6): 
        h.insert(i)
</code></pre>
    <p class="normal">We can print the heap list, just to inspect how the elements are ordered. If you redraw this as a tree structure, you will notice that it meets the required properties of a heap, similar to what we created manually:</p>
    <pre class="programlisting code"><code class="hljs-code">    print(h.heap)
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">[0, 1, 2, 5, 3, 6, 10, 7, 8, 4, 9]
</code></pre>
    <p class="normal">We can see in the output that all the data items of the heap in the array are as in the index position as per <em class="italic">Figure 7.11</em>. Next, we will discuss the delete operation in the heap.</p>
    <h2 id="_idParaDest-156" class="heading-2">Delete operation</h2>
    <p class="normal">The <code class="inlineCode">delete</code> operation <a id="_idIndexMarker637"/>removes an element from the heap. To delete any element from the heap, let’s first discuss how we can delete the root element since it is mostly used for several use cases, such as finding the minimum or maximum element in a heap. Remember, in a <code class="inlineCode">min-heap</code>, the root element denotes the minimum value of the list, and the root of the <code class="inlineCode">max-heap</code> gives the maximum value of the list of elements. </p>
    <p class="normal">Once we <a id="_idIndexMarker638"/>delete the root element from the heap, we make the last element of the heap the new root of the heap. In that case, the <code class="inlineCode">heap</code> property will not be satisfied by the tree. So, we have to reorganize the nodes of the tree such that all the nodes of the tree satisfy the <code class="inlineCode">heap</code> property. The delete operation in <code class="inlineCode">min-heap</code> works as follows.</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Once we delete the <code class="inlineCode">root</code> node, we need a new <code class="inlineCode">root</code> node. For this, we take the last item from the list and make it the new root.</li>
      <li class="numberedList">Since the selected last node might not be the lowest element of the heap, we have to reorganize the nodes of the heap.</li>
      <li class="numberedList">We reorganize the nodes from the <code class="inlineCode">root</code> node to the last node (which is made into a new root); this process is called heapify. Since we move from top to bottom (which means from the <code class="inlineCode">root</code> node down to the last element) of the heap, this process is called percolate down.</li>
    </ol>
    <p class="normal">Let’s consider an example to help us understand this concept in the following heap. First, we delete the <code class="inlineCode">root</code> node that has value <code class="inlineCode">2</code>, as shown in <em class="italic">Figure 7.12</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_07_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.12: Deletion of a node with value 2 at the root in the existing heap</p>
    <p class="normal">Once we delete the root, next we need to choose a node that can be the new root; commonly, <a id="_idIndexMarker639"/>we choose to take the last node, in other words, node <code class="inlineCode">6</code> at index <code class="inlineCode">7</code>. So, the last element, <code class="inlineCode">6</code>, is placed at the root position, as shown in <em class="italic">Figure 7.13</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_07_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.13: Moving the last element, in other words, node 6 to the root position</p>
    <p class="normal">After moving<a id="_idIndexMarker640"/> the last element to the new root, clearly this tree is now not satisfying the <code class="inlineCode">min-heap</code> property. So, we have to reorganize the nodes of the heap, hence we move down from the root to the nodes in the heap, that is, heapify the tree. So, we compare the value of the newly replaced node with all its children nodes in the tree. In this example, we compare the two children of the root, that is, <code class="inlineCode">5</code> and <code class="inlineCode">3</code>. Since the right child is smaller, its index is <code class="inlineCode">3</code>, which is represented as <em class="italic">(root index * 2 + 1)</em>. We will go ahead with this node and compare the new <code class="inlineCode">root</code> node with the value at this index, as shown in <em class="italic">Figure 7.14</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_07_14.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.14: Swapping of the root node with the node 3</p>
    <p class="normal">Now, the <a id="_idIndexMarker641"/>node with value <code class="inlineCode">6</code> should be moved down to index <code class="inlineCode">3</code> as per the <code class="inlineCode">min heap</code> property. Next, we <a id="_idIndexMarker642"/>need to compare it to its children down to the heap. Here, we only have one child, so we don’t need to worry about which child to compare it against (for a <code class="inlineCode">min</code> heap, it is always the lesser child), as shown in <em class="italic">Figure 7.15</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_07_15.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.15: Swapping of node 6 and node 10</p>
    <p class="normal">There is no need to swap here since it is following the <code class="inlineCode">min-heap</code> property. After reaching the last one, the final heap adheres to the <code class="inlineCode">min-heap</code> property.</p>
    <p class="normal">In order to implement the deletion of the <code class="inlineCode">root</code> node from the heap using Python, firstly, we implement the percolate-down process, in other words, the <code class="inlineCode">sink()</code> method. Before we implement the <code class="inlineCode">sink()</code> method, we implement a <code class="inlineCode">helper</code> method for finding out which of the children to compare against the parent node. This <code class="inlineCode">helper</code> method is <code class="inlineCode">minchild()</code>, which should be defined in the <code class="inlineCode">MinHeap</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">    def minchild(self, k):
        if k * 2 + 1 &gt; self.size:
            return k * 2
        elif self.heap[k*2] &lt; self.heap[k*2+1]:
            return k * 2
        else:
            return k * 2 + 1
</code></pre>
    <p class="normal">In this method, firstly, we check if we get beyond the end of the list—if we do, then we return the index of the left child:</p>
    <pre class="programlisting code"><code class="hljs-code">        if k * 2 + 1 &gt; self.size: 
            return k * 2 
</code></pre>
    <p class="normal">Otherwise, we<a id="_idIndexMarker643"/> simply return the index of the lesser <a id="_idIndexMarker644"/>of the two children:</p>
    <pre class="programlisting code"><code class="hljs-code">        elif self.heap[k*2] &lt; self.heap[k*2+1]: 
            return k * 2 
        else: 
            return k * 2 + 1
</code></pre>
    <p class="normal">Now we can create the <code class="inlineCode">sink()</code> method. The <code class="inlineCode">sink()</code> method should be defined in the <code class="inlineCode">MinHeap</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">def sink(self, k):
        while k * 2 &lt;= self.size:
            mc = self.minchild(k)
            if self.heap[k] &gt; self.heap[mc]:
                self.heap[k], self.heap[mc] = self.heap[mc], self.heap[k]
            k = mc
</code></pre>
    <p class="normal">In the above code, we first run the loop until the end of the tree so that we can sink (move down) our element down as far as is needed; this is shown in the following code snippet:</p>
    <pre class="programlisting code"><code class="hljs-code">    def sink(self, k): 
          while k*2 &lt;= self.size: 
</code></pre>
    <p class="normal">Next, we need to know which of the left or right children to compare against. This is where we make use of the <code class="inlineCode">minindex()</code> function, as shown in the following code snippet:</p>
    <pre class="programlisting code"><code class="hljs-code">            mi = self.minchild(k)
</code></pre>
    <p class="normal">Next, we compare parent and child to see whether we need to make the swap, as we did in the <code class="inlineCode">arrange()</code> method during the insertion operation:</p>
    <pre class="programlisting code"><code class="hljs-code">            if self.heap[k] &gt; self.heap[mc]: 
                self.heap[k], self.heap[mc] = self.heap[mc], self.heap[k] 
</code></pre>
    <p class="normal">Finally, we need to make sure that we move down the tree in each iteration so that we don’t get stuck in a loop, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">            k = mc
</code></pre>
    <p class="normal">Now, we<a id="_idIndexMarker645"/> can implement the main <code class="inlineCode">delete_at_root()</code> method<a id="_idIndexMarker646"/> itself, which should be defined in the <code class="inlineCode">MinHeap</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">    def delete_at_root(self): 
        item = self.heap[1] 
        self.heap[1] = self.heap[self.size] 
        self.size -= 1 
        self.heap.pop() 
        self.sink(1) 
        return item
</code></pre>
    <p class="normal">In the above code for deletion of the <code class="inlineCode">root</code> node, we first copy the root element in a variable item, and then the last element is moved to the <code class="inlineCode">root</code> node in the following statement:</p>
    <pre class="programlisting code"><code class="hljs-code">self.heap[1] = self.heap[self.size]
</code></pre>
    <p class="normal">Further, we reduce the size of the heap, and remove the element from the heap, and then we use the <code class="inlineCode">sink()</code> method to reorganize the heap element so that all the elements of the heap follow the <code class="inlineCode">heap</code> property.</p>
    <p class="normal">We can now use the following code to delete the <code class="inlineCode">root</code> node from the heap. Let’s first insert some data items <code class="inlineCode">{2, 3, 5, 7, 9, 10, 6}</code> in the heap and then remove the <code class="inlineCode">root</code> node:</p>
    <pre class="programlisting code"><code class="hljs-code">h = MinHeap()
for i in (2, 3, 5, 7, 9, 10, 6):
    h.insert(i)
print(h.heap)
n = h.delete_at_root()
print(n)
print(h.heap)
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">[0, 2, 3, 5, 7, 9, 10, 6]
2
[0, 3, 6, 5, 7, 9, 10]
</code></pre>
    <p class="normal">We can see in the output that the root element 2 is returned in the new heap, and that the data elements are<a id="_idIndexMarker647"/> rearranged so that all the nodes of the heap <a id="_idIndexMarker648"/>are following the <code class="inlineCode">heap</code> property (indexes of the nodes can checked as shown in <em class="italic">Figure 7.16</em>). Next, we will discuss if we want to delete any node with the given index position.</p>
    <h2 id="_idParaDest-157" class="heading-2">Deleting an element at a specific location from a heap</h2>
    <p class="normal">Generally, we <a id="_idIndexMarker649"/>delete an element at the root, however, an element can be deleted at a specific location from the heap. Let us understand it with an example. Given the following heap, let’s assume that we want to delete a node with value <code class="inlineCode">3</code> at index <code class="inlineCode">2</code>. After deleting the node with value <code class="inlineCode">3</code>, we move the last node to the deleted node, in other words, the node with value <code class="inlineCode">15</code>, as shown in <em class="italic">Figure 7.16</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_07_16.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.16: The deletion of node 3 from the heap</p>
    <p class="normal">After shifting the last element to the deleted node, we compare this with its root element since it is already greater than the root element, so we do not swap. Next, we compare this element with all of its children, and since the left child is smaller, it is swapped with the left child, as shown in <em class="italic">Figure 7.17</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_07_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.17: A comparison of node 15 with 5 and 11, and swapping node 15 and node 5</p>
    <p class="normal">After <a id="_idIndexMarker650"/>swapping node <code class="inlineCode">15</code> with node <code class="inlineCode">5</code>, we move down in the heap. Next, we compare node <code class="inlineCode">15</code> with its child, node <code class="inlineCode">8</code>. Finally, node <code class="inlineCode">8</code> and node <code class="inlineCode">15</code> are swapped. Now, the final tree follows the <code class="inlineCode">heap</code> property, as shown in <em class="italic">Figure 7.18</em>:</p>
    <p class="packt_figref"><img src="img/B17217_07_18.png" alt=""/></p>
    <p class="packt_figref">Figure 7.18: The final heap after swapping node 8 and node 15</p>
    <p class="normal">The implementation of the delete operation for removing a data item at any given index location is given below, which should be defined in the <code class="inlineCode">MinHeap</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">    def delete_at_location(self, location):
        item = self.heap[location]
        self.heap[location] = self.heap[self.size]
        self.size -= 1
        self.heap.pop()
        self.sink(location)
        return item
</code>
{4, 8, 7, 2, 9, 10, 5, 1, 3, 6}</code>:</pre>
    <pre class="programlisting code"><code class="hljs-code">h = MinHeap()  
for i in (4, 8, 7, 2, 9, 10, 5, 1, 3, 6):  
    h.insert(i)    
print(h.heap)
 
n = h.delete_at_location(2)
print(n)
print(h.heap)
</code></pre>
    <p class="normal">The output of the preceding code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">[0, 1, 2, 5, 3, 6, 10, 7, 8, 4, 9]
2
[0, 1, 3, 5, 4, 6, 10, 7, 8, 9]
</code></pre>
    <p class="normal">In the above output, we see that, before and after, the heap nodes are placed according to their index positions. We have discussed the concepts and implementation using examples of <code class="inlineCode">min-heap</code>; all these operations and concepts can be easily implemented for a <code class="inlineCode">max-heap</code> by simply reversing the logic in conditions where we ensured that the parent node should have smaller values compared to the children in <code class="inlineCode">min-heap</code>. Now in the case of <code class="inlineCode">max-heap</code>, we have to make the larger value in the parent. Heaps are used in various applications such as to implement heap sort and priority queues, which we will discuss in subsequent sections.</p>
    <h2 id="_idParaDest-158" class="heading-2">Heap sort</h2>
    <p class="normal">Heap is <a id="_idIndexMarker652"/>an important data structure for sorting a list of elements since it is very suitable for a large number of elements. If we want to sort a list of elements, say in ascending order, we can use <code class="inlineCode">min-heap</code> for this purpose; we first create a <code class="inlineCode">min-heap</code> of all the given data elements, and as per the <code class="inlineCode">heap</code> property, the smallest data value will be stored at the root of the heap. With the help of the <code class="inlineCode">heap</code> property, it is straightforward to sort the elements. The process is as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a <code class="inlineCode">min-heap</code> using all the given data elements.</li>
      <li class="numberedList">Read and delete the root element, which is the minimum value. After that, copy the last element of the tree to the new root, and further reorganize the tree to maintain the <code class="inlineCode">heap</code> property.</li>
      <li class="numberedList">Now, we repeat <em class="italic">step 2</em> until we get all the elements.</li>
      <li class="numberedList">Finally, we get the sorted list of elements. </li>
    </ol>
    <p class="normal">The data <a id="_idIndexMarker653"/>elements are stored in the heap adhering to the <code class="inlineCode">heap</code> property; whenever a new element is added or deleted, the <code class="inlineCode">heap</code> property is maintained using the <code class="inlineCode">arrange()</code> and <code class="inlineCode">sink()</code> <code class="inlineCode">helper</code> methods, respectively, as discussed in previous sections.</p>
    <p class="normal">In order to implement heap sort using the heap data structure, first we create a heap with the data items <code class="inlineCode">{4, 8, 7, 2, 9, 10, 5, 1, 3, 6}</code> using the below code (details of the creation of the heap are given in previous sections):</p>
    <pre class="programlisting code"><code class="hljs-code">    h = MinHeap() 
    unsorted_list = [4, 8, 7, 2, 9, 10, 5, 1, 3, 6] 
    for i in unsorted_list: 
        h.insert(i) 
    print("Unsorted list: {}".format(unsorted_list)) 
</code></pre>
    <p class="normal">In the above code, the <code class="inlineCode">min-heap</code>, <code class="inlineCode">h</code>, is created and the elements in <code class="inlineCode">unsorted_list</code> are inserted. After each call to the <code class="inlineCode">insert()</code> method, the heap order property is restored by the subsequent call to the <code class="inlineCode">sink</code> method.</p>
    <p class="normal">After creation of the heap, next, we read and delete the root element. In each iteration, we get the minimum value, and thus the data items in ascending order. The implementation of the <code class="inlineCode">heap_sort() method</code> should be defined in the <code class="inlineCode">minHeap</code> class (it uses the <code class="inlineCode">delete_at_root()</code> method discussed in previous sections):</p>
    <pre class="programlisting code"><code class="hljs-code">        def heap_sort(self): 
            sorted_list = [] 
            for node in range(self.size): 
                n = self.delete_at_root() 
                sorted_list.append(n) 
            return sorted_list
</code></pre>
    <p class="normal">In the above code, we create an empty array, <code class="inlineCode">sorted_list</code>, which stores all the data elements in sorted order. Then we run the loop for the number of items in the list. In each<a id="_idIndexMarker654"/> iteration, we call the <code class="inlineCode">delete_at_root()</code> method to get the minimum value, which is appended to <code class="inlineCode">sorted_list</code>.</p>
    <p class="normal">Now we can use the heap sort algorithm using the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">print("Unsorted list: {}".format(unsorted_list))
print("Sorted list: {}".format(h.heap_sort()))
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">Unsorted list: [4, 8, 7, 2, 9, 10, 5, 1, 3, 6]
Sorted list: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</code></pre>
    <p class="normal">The time complexity to build the heap using the insert method takes <code class="inlineCode">O(n)</code> times. Further, to reorganize the tree after deleting the root element takes <code class="inlineCode">O(log n)</code> since we go from top to bottom in the heap tree, and the height of the heap is <code class="inlineCode">log2(n)</code>, hence the complexity of rearranging the tree is <code class="inlineCode">O(log n)</code>. So, overall, the worst-case time complexity of the heap sort is <code class="inlineCode">O(n logn)</code>. Heapsort is very efficient in general, giving a worst-case, average-case and best-case complexity of <code class="inlineCode">O(nlogn)</code>.</p>
    <h1 id="_idParaDest-159" class="heading-1">Priority queues</h1>
    <p class="normal">A priority queue<a id="_idIndexMarker655"/> is a data structure that is similar to a queue in which data is <a id="_idIndexMarker656"/>retrieved based on the <strong class="keyWord">First In, First Out</strong> (<strong class="keyWord">FIFO</strong>) policy, but in the priority queue, priority is attached with the data. In the priority queue, the data is retrieved based on the priority associated with the data elements, the data elements with the highest priority are retrieved before the lower priority data elements, and if two data elements have the same priority, they are retrieved according to the <strong class="keyWord">FIFO </strong>policy. </p>
    <p class="normal">We can assign the priority of the data depending upon the application. It is used in many applications, such as CPU scheduling, and many algorithms also rely on priority queues, such as Dijkstra’s shortest-path, A* search, and Huffman codes for data compression.</p>
    <p class="normal">So, in the priority queue, the item with the highest priority is served first. The priority queue stores the data according to the priority associated with the data, so insertion of an element will be at a specific position in the priority queue. Priority queues can be considered as modified queues that return the items in the order of highest priority instead of returning the items in the <strong class="keyWord">FIFO</strong> order. A priority queue can be implemented by modifying an enqueue position by inserting the item according to the priority. It is demonstrated in <em class="italic">Figure 7.19</em>, in which given the queue, a new item <code class="inlineCode">5</code> is added to the queue at a specific index (here assuming that the data items having higher values have higher priority):</p>
    <figure class="mediaobject"><img src="img/B17217_07_19.png" alt="A picture containing text, clock  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 7.19: A demonstration of a priority queue</p>
    <p class="normal">Let’s <a id="_idIndexMarker657"/>understand the priority queue with an example. When we receive data elements in an order, the elements are enqueued in the priority queue in the order of priority (assuming that the higher data value is of higher importance). Firstly, the priority queue is empty, so <code class="inlineCode">3</code> is added initially in the queue; the next data element is <code class="inlineCode">8</code>, which will be enqueued at the start since it is greater than <code class="inlineCode">3</code>. Next, the data item is <code class="inlineCode">2</code>, then <code class="inlineCode">6</code>, and finally, <code class="inlineCode">10</code>, which are enqueued in the priority queue as per their priority, and when the dequeue operation is applied, the high priority item will be dequeued first. All the steps are represented in <em class="italic">Figure 7.20</em>:</p>
    <figure class="mediaobject"><img src="img/B17217_07_20.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.20: A step-by-step procedure to create a priority queue</p>
    <p class="normal">Let us discuss<a id="_idIndexMarker658"/> the implementation of a priority queue in Python. We first define the node class. A node class will have the data elements along with the priority associated with the data in the priority queue:</p>
    <pre class="programlisting code"><code class="hljs-code"># class for Node with data and priority
class Node:
  def __init__(self, info, priority):
    self.info = info
    self.priority = priority 
</code></pre>
    <p class="normal">Next, we define the <code class="inlineCode">PriorityQueue</code> class and initialize the queue:</p>
    <pre class="programlisting code"><code class="hljs-code"># class for Priority queue
class PriorityQueue:
  def __init__(self):
    self.queue = []
</code></pre>
    <p class="normal">Next, let us discuss the<a id="_idIndexMarker659"/> implementation of the insertion operation for adding a new data element to the priority queue. In the implementation, we assume that the data element has high priority if it has a smaller priority value (for example, a data element with the priority value <code class="inlineCode">1</code> has higher priority compared to the data element that has a priority value <code class="inlineCode">4</code>). The following are cases of insertion of elements in a priority queue:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Insertion of a data element to the priority queue when the queue is initially empty.</li>
      <li class="numberedList">If the queue is not empty, we perform the traversal of the queue and reach the appropriate index position in the queue according to the associated priorities by comparing the priorities of the existing node with the new node. We add the new node before the node that has a priority greater than the new node.</li>
      <li class="numberedList">If the new node has a lower priority than the high priority value, then the node will be added to the start of the queue.</li>
    </ol>
    <p class="normal">The <a id="_idIndexMarker660"/>implementation of the <code class="inlineCode">insert()</code> method is as follows, which should be defined in the <code class="inlineCode">PriorityQueue</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">    def insert(self, node):        
        if len(self.queue) == 0:
            # add the new node
            self.queue.append(node)
        else:
            # traverse the queue to find the right place for new node
            for x in range(0, len(self.queue)):
                # if the priority of new node is greater
                if node.priority &gt;= self.queue[x].priority:
                    # if we have traversed the complete queue
                    if x == (len(self.queue)-1):
                        # add new node at the end
                        self.queue.insert(x+1, node)
                    else:
                        continue
                else:
                    self.queue.insert(x, node)
                    return True
</code></pre>
    <p class="normal">In the above code, we first append a new data element when the queue is empty, and then we iteratively reach the appropriate position by comparing the priorities associated with the data elements. </p>
    <p class="normal">Next, when <a id="_idIndexMarker661"/>we apply the delete operation in the priority queue, the highest priority data element is returned and removed from the queue. It should be defined in the <code class="inlineCode">PriorityQueue</code> class as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">    def delete(self):
        # remove the first node from the queue
        x = self.queue.pop(0)
        print("Deleted data with the given priority-", x.info, x.priority)
        return x
</code></pre>
    <p class="normal">In the preceding code, we <a id="_idIndexMarker662"/>get the top element with the highest priority value. Further, the implementation of the <code class="inlineCode">show()</code> method that prints all the data elements of the priority queue in the order of the priorities should be defined in the <code class="inlineCode">PriorityQueue</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">    def show(self):
        for x in self.queue:
            print(str(x.info)+ " - "+ str(x.priority))
  
</code></pre>
    <p class="normal">Now, let’s consider an <a id="_idIndexMarker663"/>example to see how to use the priority queue in which we firstly add data elements (<code class="inlineCode">"Cat"</code>, “<code class="inlineCode">Bat"</code>, <code class="inlineCode">"Rat"</code>, <code class="inlineCode">"Ant"</code>, and <code class="inlineCode">"Lion"</code>) with associated priorities <code class="inlineCode">13</code>, <code class="inlineCode">2</code>, <code class="inlineCode">1</code>, <code class="inlineCode">26</code>, and <code class="inlineCode">25</code>, respectively:</p>
    <pre class="programlisting code"><code class="hljs-code">p = PriorityQueue()
p.insert(Node("Cat", 13))
p.insert(Node("Bat", 2))
p.insert(Node("Rat", 1))
p.insert(Node("Ant", 26))
p.insert(Node("Lion", 25))
p.show()
p.delete()
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">Rat – 1
Bat – 2
Cat – 13
Lion – 25
Ant – 26
Deleted data with the given priority- Rat 1
</code></pre>
    <p class="normal">Priority queues can be implemented using several data structures; in the above example, we saw its implementation using a list of tuples where the tuple contains the priority as the first element and the value data item as the next element. However, the priority queues are mostly implemented using a heap, since it is efficient with the worst-case time complexity of <code class="inlineCode">O(log n)</code> in insertion and deletion operations.</p>
    <p class="normal">The implementation of the <a id="_idIndexMarker664"/>priority queue using heap is very similar to what we have discussed in the <code class="inlineCode">min-heap</code> implementation. The only difference is that now we store the priorities associated with the data elements, and we create a <code class="inlineCode">min-heap</code> tree considering the priority values using a list of tuples in Python. For completeness, the code for the priority queue using heaps is as follows:</p>
    <pre class="programlisting gen"><code class="hljs">class PriorityQueueHeap:
    def __init__(self):
        self.heap = [()]
        self.size = 0
 
    def arrange(self, k):
        while k // 2 &gt; 0:
            if self.heap[k][0] &lt; self.heap[k//2][0]:
                self.heap[k], self.heap[k//2] = self.heap[k//2], self.heap[k]
            k //= 2
 
    def insert(self,priority, item):
        self.heap.append((priority, item))
        self.size += 1
        self.arrange(self.size)
 
    def sink(self, k):
        while k * 2 &lt;= self.size:
            mc = self.minchild(k)
            if self.heap[k][0] &gt; self.heap[mc][0]:
                self.heap[k], self.heap[mc] = self.heap[mc], self.heap[k]
            k = mc
 
    def minchild(self, k):
        if k * 2 + 1 &gt; self.size:
            return k * 2
        elif self.heap[k*2][0] &lt; self.heap[k*2+1][0]:
            return k * 2
        else:
            return k * 2 + 1
 
    def delete_at_root(self):
        item = self.heap[1][1]
        self.heap[1] = self.heap[self.size]
        self.size -= 1
        self.heap.pop()
        self.sink(1)
        return item
</code></pre>
    <p class="normal">We use the <a id="_idIndexMarker665"/>code below to create a priority queue with data elements <code class="inlineCode">"Bat"</code>, <code class="inlineCode">"Cat"</code>, <code class="inlineCode">"Rat"</code>, <code class="inlineCode">"Ant"</code>, <code class="inlineCode">"Lion"</code>, and <code class="inlineCode">"Bear"</code> with the associated priority values <code class="inlineCode">2</code>, <code class="inlineCode">13</code>, <code class="inlineCode">18</code>, <code class="inlineCode">26</code>, <code class="inlineCode">3</code>, and <code class="inlineCode">4</code>, respectively:</p>
    <pre class="programlisting code"><code class="hljs-code">h = PriorityQueueHeap() 
h.insert(2, "Bat") 
h.insert(13,"Cat")
h.insert(18, "Rat")
h.insert(26, "Ant")
h.insert(3, "Lion")
h.insert(4, "Bear")
h.heap
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">[(), (2, 'Bat'), (3, 'Lion'),  (4, 'Bear'),  (26, 'Ant'),  (13, 'Cat'),  (18, 'Rat')]
</code></pre>
    <p class="normal">In the above output, we can see that it shows a <code class="inlineCode">min-heap</code> tree that adheres to the <code class="inlineCode">min-heap</code> property. Now we can use the code below to remove the data elements:</p>
    <pre class="programlisting code"><code class="hljs-code">for i in range(h.size):
    n = h.delete_at_root()
    print(n)
    print(h.heap)
</code></pre>
    <p class="normal">The output of the preceding code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">'Bat
[(), (3, 'Lion'), (13, 'Cat'), (4, 'Bear'), (26, 'Ant'), (18, 'Rat')]
Lion
[(), (4, 'Bear'), (13, 'Cat'), (18, 'Rat'), (26, 'Ant')]
Bear
[(), (13, 'Cat'), (26, 'Ant'), (18, 'Rat')]
Cat
[(), (18, 'Rat'), (26, 'Ant')]
Rat
[(), (26, 'Ant')]
Ant
[()]
</code></pre>
    <p class="normal">In the above output, we <a id="_idIndexMarker666"/>can see that the data items are produced according to the priorities associated with the data elements.</p>
    <h1 id="_idParaDest-160" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we have discussed an important data structure, in other words, the heap data structure. We also discussed heap properties for <code class="inlineCode">min-heap</code> and <code class="inlineCode">max-heap</code>. We have seen the implementation of several operations that can be applied to the heap data structure, such as heapifying, and the insertion and deletion of a data element from the heap. We have also discussed two of the important applications of the heap—heap sort and a priority queue. The heap is an important data structure since it has many applications, such as sorting, selecting minimum and maximum values in a list, graph algorithms, and priority queues. Moreover, the heap can also be useful when we have to repeatedly remove a data object with the highest or lowest priority values.</p>
    <p class="normal">In the next chapter, we will discuss the concepts of <strong class="keyWord">Hashing</strong> and <strong class="keyWord">Symbol Tables</strong>.</p>
    <h1 id="_idParaDest-161" class="heading-1">Exercises</h1>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">What will be the time complexity for deleting an arbitrary element from the <code class="inlineCode">min-heap</code>?</li>
      <li class="numberedList">What will be the time complexity for finding the <code class="inlineCode">kth</code> smallest element from the <code class="inlineCode">min-heap</code>?</li>
      <li class="numberedList">What will be the worst-case time complexity for ascertaining the smallest element from a binary <code class="inlineCode">max-heap</code> and binary <code class="inlineCode">min-heap</code>?</li>
      <li class="numberedList">What will be the time complexity to make a <code class="inlineCode">max-heap</code> that combines two <code class="inlineCode">max-heap</code> each of size <code class="inlineCode">n</code>?</li>
      <li class="numberedList">The level order traversal of <code class="inlineCode">max-heap</code> is <code class="inlineCode">12</code>, <code class="inlineCode">9</code>, <code class="inlineCode">7</code>, <code class="inlineCode">4</code>, and <code class="inlineCode">2</code>. After inserting new elements <code class="inlineCode">1</code> and <code class="inlineCode">8</code>, what will be the final <code class="inlineCode">max-heap</code> and the level order traversal of the final <code class="inlineCode">max-heap</code>?</li>
      <li class="numberedList">Which of the following is a binary <code class="inlineCode">max-heap</code>?</li>
    </ol>
    <figure class="mediaobject"><img src="img/B17217_07_21.png" alt="Diagram  Description automatically generated"/></figure>
    <figure class="mediaobject"><img src="img/B17217_07_22.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 7.21: Example trees</p>
    <h1 class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://packt.link/MEvK4">https://packt.link/MEvK4</a></p>
    <p class="normal"><img src="img/QR_Code1421249772551223062.png" alt=""/></p>
  </div>
</body></html>