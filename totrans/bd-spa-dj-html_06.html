<html><head></head><body>
		<div id="_idContainer049">
			<h1 id="_idParaDest-53"><a id="_idTextAnchor090"/>Chapter 4: Working with the Database</h1>
			<p>This chapter does not aim to teach you how to interact with a database using Django or to create migrations—I assume you already have those minimal skills. This chapter instead will show you how to work with real situations where a Channels instance interacts recurrently with models.</p>
			<p>Unless the application is only powered by external APIs, having a database is an elementary requirement in any modern web development. The needs can range from functionality as simple as storing plain text in an orderly fashion, to an authentication system, to managing a complex structure of connections between users. In other words, you must connect to a database if you want to build a practical project.</p>
			<p>Fortunately, Django is compatible with the most popular relational databases: PostgreSQL, MariaDB, MySQL, Oracle, and SQLite. And if that’s not enough, we can also connect to other possibilities thanks to extensions created by the community: <strong class="bold">CockroachDB</strong>, <strong class="bold">Firebird</strong>, <strong class="bold">Google Cloud Spanner</strong>, and <strong class="bold">Microsoft SQL Server</strong>.</p>
			<p>We are going to focus on creating a real-time app that manages a database. We will learn how to perform the minimum functionalities of <strong class="bold">BREAD</strong>: <strong class="bold">Browse-Read-Edit-Add-Delete</strong>, including simple pagination. And what better example than to create a social network? The information should be saved, sorted, and displayed to all users with as little delay as possible. If there is a very slow response, then we have failed to offer a real-time system and have achieved a boring email system. </p>
			<p>For didactic reasons, we will create an anarchist social network. Any visitor, without prior registration, will be able to manipulate the data of any user. If you find it unsafe, you can create a disclaimer page invoking human kindness and suggest not to change other people’s content or wait for the next chapters where we will incorporate a complete registration and identification system.</p>
			<p> We’ll cover the following topics in the chapter:</p>
			<ul>
				<li>Inserting information into the database</li>
				<li>Rendering database information</li>
				<li>Limiting queries with a pager</li>
				<li>Deleting rows from a database</li>
				<li>Updating rows in a database</li>
			</ul>
			<p>In addition, we will incorporate some CSS lines to enhance the visual impact, and we will take all the logic to the backend, leaving only the responsibility of managing events on the client side.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor091"/>Technical requirements</h1>
			<p>We will build on all the accumulated knowledge from the previous chapters. If you want to start with a template, you can use the following structure, which I will use for future projects:</p>
			<p><a href="https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-4/initial-template">https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-4/initial-template</a></p>
			<p>Inside you will find a sample project that is already prepared with different points that we have touched upon in the previous chapters:</p>
			<ul>
				<li>Integration with Docker</li>
				<li>Minimum structure for working with Channels</li>
				<li>Connection to the database with PostgreSQL</li>
				<li>An HTML home page</li>
				<li>A minimal JavaScript file that connects to Channels</li>
			</ul>
			<p>For this project, I created a fork of the template and made some minor changes. You can use either of the two templates, although I recommend the fork for simple aesthetics. You can download it from here: <a href="https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-4/social-network_step_1">https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-4/social-network_step_1</a>. I have changed the project name to <strong class="source-inline">social_network</strong> and the app to <strong class="source-inline">website</strong>. I have also renamed the consumer to <strong class="source-inline">SocialNetworkConsumer</strong>.</p>
			<p>Finally, a schema has been added to the database, or model, called <strong class="source-inline">Message</strong> in <strong class="source-inline">app/website/models.py</strong>, which we will use to manage all the messages created by users:</p>
			<pre class="source-code">from django.db import models</pre>
			<pre class="source-code"><a id="_idTextAnchor092"/>class Message(models.Model):</pre>
			<pre class="source-code">    author = models.CharField(max_length=100)</pre>
			<pre class="source-code">    text = models.TextField(max_length=200)</pre>
			<pre class="source-code">    created_at = models.DateTimeField(auto_now_add=True)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    class Meta:</pre>
			<pre class="source-code">        db_table = "messages"</pre>
			<pre class="source-code">        verbose_name_plural = "Messages"</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def __str__(self):</pre>
			<pre class="source-code">        return self.text[:10] + "..."</pre>
			<p>The fields included are minimal: <strong class="source-inline">author</strong> to store the author’s name, <strong class="source-inline">text</strong> for the text of the message, and <strong class="source-inline">created_at</strong> to have the creation date for later sorting.</p>
			<p>To set up the project, you must use Docker:</p>
			<p class="source-code">docker-compose up</p>
			<p>Open your favorite browser to enter <strong class="source-inline">http://social-network.localhost</strong>. You should find the following result.</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/Figure_4.01_B18321.jpg" alt="Figure 4.1 – Displaying a static HTML page on the domain http://social-network.localhost&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Displaying a static HTML page on the domain http://social-network.localhost</p>
			<p>Visually it is too... minimalistic. But it contains all the elementary pieces to work with.</p>
			<p>Next, we will start building the application step by step, touching on the whole flow of editing the <strong class="source-inline">Message</strong> table or querying it afterward.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor093"/>Inserting information into the database</h1>
			<p>We are now ready with an <a id="_idIndexMarker166"/>almost empty project but perfectly configured with Channels, rendering a simple static HTML. The first step is to <strong class="source-inline">INSERT</strong> or save new information in the database. For this, we need a minimum of HTML. We are going to include a form with two fields: <strong class="source-inline">name</strong> and <strong class="source-inline">message</strong>. We will also leave a space to show the future messages that we list.</p>
			<p>Create an HTML file in <strong class="source-inline">app/website/templates/index.html</strong> with the following content.</p>
			<p>First, we will incorporate a CSS file and a JavaScript file. For the moment, we incorporate the files in the headers:</p>
			<pre class="source-code">{% load static %}</pre>
			<pre class="source-code">&lt;!doctype html&gt;</pre>
			<pre class="source-code">&lt;html lang="en"&gt;</pre>
			<pre class="source-code">&lt;head&gt;</pre>
			<pre class="source-code">    &lt;meta charset="UTF-8"&gt;</pre>
			<pre class="source-code">    &lt;meta name="viewport"</pre>
			<pre class="source-code">          content="width=device-width, user-scalable=no,</pre>
			<pre class="source-code">              initial-scale=1.0, maximum-scale=1.0, </pre>
			<pre class="source-code">                  minimum-scale=1.0"&gt;</pre>
			<pre class="source-code">    &lt;title&gt;Social Network&lt;/title&gt;</pre>
			<pre class="source-code">    &lt;link rel="stylesheet" href="{% static 'css/main.css' %}"&gt;</pre>
			<pre class="source-code">    &lt;script defer src="{% static 'js/index.js' %}"&gt;</pre>
			<pre class="source-code">    &lt;/script&gt;</pre>
			<pre class="source-code">&lt;/head&gt;</pre>
			<p>Next, in order to have the host and the scheme (HTTP or HTTPS), we must incorporate it as a dataset that we will later<a id="_idIndexMarker167"/> collect in the JavaScript. We have added a form box and another one to list messages, which we will not use for the time being: </p>
			<pre class="source-code">&lt;body</pre>
			<pre class="source-code">        data-host="{{ request.get_host }}"</pre>
			<pre class="source-code">        data-scheme="{{ request.scheme }}"</pre>
			<pre class="source-code">&gt;</pre>
			<p>The following will be the HTML form we will use to capture and save the new messages. JavaScript will be in charge, in the future, of retrieving all the information:</p>
			<pre class="source-code">    &lt;div class="container"&gt;</pre>
			<pre class="source-code">        &lt;header&gt;</pre>
			<pre class="source-code">            &lt;h1&gt;Social Network&lt;/h1&gt;</pre>
			<pre class="source-code">        &lt;/header&gt;</pre>
			<pre class="source-code">        &lt;main id="main"&gt;</pre>
			<pre class="source-code">            &lt;section class="message-form"&gt;</pre>
			<pre class="source-code">                &lt;form&gt;</pre>
			<pre class="source-code">                    &lt;input</pre>
			<pre class="source-code">                            type="text"</pre>
			<pre class="source-code">                            placeholder="Name"</pre>
			<pre class="source-code">                            id="message-form__author"</pre>
			<pre class="source-code">                            class="message-form__author" </pre>
			<pre class="source-code">                               class="message-form__author"</pre>
			<pre class="source-code">                            name="author"</pre>
			<pre class="source-code">                            required</pre>
			<pre class="source-code">                    &gt;</pre>
			<pre class="source-code">                    &lt;textarea</pre>
			<pre class="source-code">                            name="message"</pre>
			<pre class="source-code">                            placeholder="Write your message </pre>
			<pre class="source-code">                               here..."</pre>
			<pre class="source-code">                            id="message-form__text"</pre>
			<pre class="source-code">                            class="message-form__text" </pre>
			<pre class="source-code">                                class="message-form__text"</pre>
			<pre class="source-code">                            required</pre>
			<pre class="source-code">                    &gt;&lt;/textarea&gt;</pre>
			<pre class="source-code">                    &lt;input</pre>
			<pre class="source-code">type="submit"</pre>
			<pre class="source-code">class="message-form__submit"id="message-form__submit"</pre>
			<pre class="source-code">value="Send"</pre>
			<pre class="source-code">                    &gt;</pre>
			<pre class="source-code">                &lt;/form&gt;</pre>
			<pre class="source-code">            &lt;/section&gt;</pre>
			<pre class="source-code">            &lt;!-- End Form for adding new messages --&gt;</pre>
			<p>We’ll then define a place to list all <a id="_idIndexMarker168"/>messages received from the database. We will also include buttons to paginate the results in blocks of five elements:</p>
			<pre class="source-code">            &lt;section id="messages"&gt;</pre>
			<pre class="source-code">                &lt;div id="messages__list"&gt;&lt;/div&gt;</pre>
			<pre class="source-code">                &lt;button class="button" </pre>
			<pre class="source-code">                    id="messages__previous-page" disabled&gt; </pre>
			<pre class="source-code">                        Previous&lt;/button&gt;</pre>
			<pre class="source-code">                &lt;button class="button" id="messages__next-</pre>
			<pre class="source-code">                    page"&gt;Next&lt;/button&gt;</pre>
			<pre class="source-code">            &lt;/section&gt;</pre>
			<pre class="source-code">            &lt;!-- End Messages --&gt;</pre>
			<pre class="source-code">        &lt;/main&gt;</pre>
			<pre class="source-code">    &lt;/div&gt;</pre>
			<pre class="source-code">&lt;/body&gt;</pre>
			<pre class="source-code">&lt;/html&gt;</pre>
			<p>Inside <strong class="source-inline">/static/css/main.css</strong>, we will add some minimal styles to feel like we are in the 21st century:</p>
			<pre class="source-code">:root {</pre>
			<pre class="source-code">    --color__background: #f6f4f3;</pre>
			<pre class="source-code">    --color__gray: #ccc;</pre>
			<pre class="source-code">}</pre>
			<p>We add typography that <a id="_idIndexMarker169"/>brightens things up for the eye a bit. Helvetica goes well with everything, but you are free to use whatever you like. You won’t hurt Django’s feelings:</p>
			<pre class="source-code">* {</pre>
			<pre class="source-code">    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;</pre>
			<pre class="source-code">    box-sizing: border-box;</pre>
			<pre class="source-code">}</pre>
			<p>Some of the improvements we added are to correct the margin of the body and to center the content with <strong class="source-inline">container</strong>:</p>
			<pre class="source-code">body {</pre>
			<pre class="source-code">    margin: 0;</pre>
			<pre class="source-code">    background-color: var(--color__background);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">.container {</pre>
			<pre class="source-code">    margin: 0 auto;</pre>
			<pre class="source-code">    padding: 1rem;</pre>
			<pre class="source-code">    max-width: 40rem;</pre>
			<pre class="source-code">}</pre>
			<p>We’ll also style the buttons so they don’t look like they’re from the 90s:</p>
			<pre class="source-code">. button {</pre>
			<pre class="source-code">    display: inline-block;</pre>
			<pre class="source-code">    padding: 0.5rem 1rem;</pre>
			<pre class="source-code">    background-color: var(--color__gray);</pre>
			<pre class="source-code">    border: 0;</pre>
			<pre class="source-code">    cursor: pointer;</pre>
			<pre class="source-code">    text-decoration: none;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">. button:hover {</pre>
			<pre class="source-code">    filter: brightness(90%);</pre>
			<pre class="source-code">}</pre>
			<p>And we use a less retro<a id="_idIndexMarker170"/> look for forms or elements. Design should not be in conflict with backend work:</p>
			<pre class="source-code">.message-form__author, .message-form__text {</pre>
			<pre class="source-code">    display: block;</pre>
			<pre class="source-code">    width: 100%;</pre>
			<pre class="source-code">    outline: none;</pre>
			<pre class="source-code">    padding: .5rem;</pre>
			<pre class="source-code">    resize: none;</pre>
			<pre class="source-code">    border: 1px solid var(--color__gray);</pre>
			<pre class="source-code">    box-sizing: border-box;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">.message-form__submit {</pre>
			<pre class="source-code">    display: block;</pre>
			<pre class="source-code">    width: 100%;</pre>
			<pre class="source-code">    outline: none;</pre>
			<pre class="source-code">    padding: .5rem;</pre>
			<pre class="source-code">    background-color: var(--color__gray);</pre>
			<pre class="source-code">    border: none;</pre>
			<pre class="source-code">    cursor: pointer;</pre>
			<pre class="source-code">    font-weight: bold;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">.message-form__submit:hover {</pre>
			<pre class="source-code">    filter: brightness(90%);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">.message {</pre>
			<pre class="source-code">    border: 1px solid var(--color__gray);</pre>
			<pre class="source-code">    border-top: 0;</pre>
			<pre class="source-code">    padding: .5rem;</pre>
			<pre class="source-code">    border-radius: .5rem;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">.message__author {</pre>
			<pre class="source-code">    font-size: 1rem;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">.message__created_at {</pre>
			<pre class="source-code">    colour: var(--color__gray);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">.message__footer {</pre>
			<pre class="source-code">    display: flex;</pre>
			<pre class="source-code">    justify-content: space-between;</pre>
			<pre class="source-code">    align-items: center;</pre>
			<pre class="source-code">}</pre>
			<p>If you pull up Docker, and <a id="_idIndexMarker171"/>you enter <strong class="source-inline">http://social-network.localhost</strong>, you will find the following page:</p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/Figure_4.02_B18321.jpg" alt="Figure 4.2 – The form for entering a new message with CSS styles&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The form for entering a new message with CSS styles</p>
			<p>Feel free to add whatever you need, and even a CSS framework.</p>
			<p>Now we are going to include the JavaScript events to send the form data to the consumer. We will create a new file in <strong class="source-inline">/static/js/index.js</strong> with the following content:</p>
			<pre class="source-code">/*</pre>
			<pre class="source-code">    VARIABLES</pre>
			<pre class="source-code">*/</pre>
			<pre class="source-code">// Connect to WebSockets server (SocialNetworkConsumer)</pre>
			<pre class="source-code">const myWebSocket = new WebSocket(`${document.body.</pre>
			<pre class="source-code">    dataset.scheme === 'http' ? 'ws' : 'wss'}://${ </pre>
			<pre class="source-code">    document.body.dataset.host }/ws/social-network/`);</pre>
			<pre class="source-code">const inputAuthor = document.querySelector("#message-</pre>
			<pre class="source-code">    form__author");</pre>
			<pre class="source-code">const inputText = document.querySelector("#message-</pre>
			<pre class="source-code">    form__text");</pre>
			<pre class="source-code">const inputSubmit = document.querySelector("#message-</pre>
			<pre class="source-code">    form__submit");</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">/*</pre>
			<pre class="source-code">    FUNCTIONS</pre>
			<pre class="source-code">*/</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">/**</pre>
			<pre class="source-code">* Send data to WebSockets server</pre>
			<pre class="source-code">* @param {string} message</pre>
			<pre class="source-code">* @param {WebSocket} webSocket</pre>
			<pre class="source-code">* @return {void}</pre>
			<pre class="source-code">*/</pre>
			<pre class="source-code">function sendData(message, webSocket) {</pre>
			<pre class="source-code">    webSocket.send(JSON.stringify(message));</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">/**</pre>
			<pre class="source-code">* Send new message</pre>
			<pre class="source-code">* @param {Event} event</pre>
			<pre class="source-code">* @return {void}</pre>
			<pre class="source-code">*/</pre>
			<pre class="source-code">function sendNewMessage(event) {</pre>
			<pre class="source-code">    event.preventDefault();</pre>
			<pre class="source-code">    // Prepare the information we will send</pre>
			<pre class="source-code">    const newData = {</pre>
			<pre class="source-code">        "action": "add message",</pre>
			<pre class="source-code">        "data": {</pre>
			<pre class="source-code">            "author": inputAuthor.value,</pre>
			<pre class="source-code">            "text": inputText.value</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    };</pre>
			<pre class="source-code">    // Send the data to the server</pre>
			<pre class="source-code">    sendData(newData, myWebSocket);</pre>
			<pre class="source-code">    // Clear message form</pre>
			<pre class="source-code">    inputText.value = "";</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">/*</pre>
			<pre class="source-code">    EVENTS</pre>
			<pre class="source-code">*/</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">// Event when a new message is received by WebSockets</pre>
			<pre class="source-code">myWebSocket.addEventListener("message", (event) =&gt; {</pre>
			<pre class="source-code">    // Parse the data received</pre>
			<pre class="source-code">    const data = JSON.parse(event.data);</pre>
			<pre class="source-code">    // Renders the HTML received from the Consumer</pre>
			<pre class="source-code">    document.querySelector(data.selector). innerHTML = </pre>
			<pre class="source-code">        data.html;</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">// Sends new message when you click on Submit</pre>
			<pre class="source-code">inputSubmit.addEventListener("click", sendNewMessage);</pre>
			<p>In the variable <a id="_idIndexMarker172"/>section, we capture all the HTML elements that we need to capture all events and create a <strong class="source-inline">WebSockets</strong> connection. The <strong class="source-inline">sendData</strong> function is used to send messages to the backend, and <strong class="source-inline">sendNewMessage</strong> is executed when we click on the <strong class="bold">Submit</strong> button. The JSON will always be sent with the following structure:</p>
			<pre class="source-code">{</pre>
			<pre class="source-code">        "action": "text",</pre>
			<pre class="source-code">        "data": {}</pre>
			<pre class="source-code">}</pre>
			<p>We modify the consumer to receive the information and save it. Edit <strong class="source-inline">app/website/consumers.py</strong> with the following content:</p>
			<pre class="source-code">from channels.generic.websocket import JsonWebsocketConsumer</pre>
			<pre class="source-code">from django.template.loader import render_to_string</pre>
			<pre class="source-code">from . models import Message</pre>
			<pre class="source-code">from asgiref.sync import async_to_sync</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">class SocialNetworkConsumer(JsonWebsocketConsumer):</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    room_name = 'broadcast</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def connect(self):</pre>
			<pre class="source-code">        """Event when client connects"""</pre>
			<pre class="source-code">        # Accept the connection</pre>
			<pre class="source-code">        self.accept()</pre>
			<pre class="source-code">        # Assign the Broadcast group</pre>
			<pre class="source-code">        async_to_sync(self.channel_layer.group_add)</pre>
			<pre class="source-code">            (self.room_name, self.channel_name)</pre>
			<pre class="source-code">        # Send you all the messages stored in the database.</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def disconnect(self, close_code):</pre>
			<pre class="source-code">        """Event when client disconnects"""</pre>
			<pre class="source-code">        # Remove from the Broadcast group</pre>
			<pre class="source-code">        async_to_sync(self.channel_layer.group_discard)</pre>
			<pre class="source-code">            (self.room_name, self.channel_name)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def receive_json(self, data_received):</pre>
			<pre class="source-code">        """</pre>
			<pre class="source-code">            Event when data is received</pre>
			<pre class="source-code">            All information will arrive in 2 variables:</pre>
			<pre class="source-code">            'action', with the action to be taken</pre>
			<pre class="source-code">            'data' with the information</pre>
			<pre class="source-code">        """</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        # Get the data</pre>
			<pre class="source-code">        data = data_received['data']</pre>
			<pre class="source-code">        # Depending on the action we will do one task or </pre>
			<pre class="source-code">        another.</pre>
			<pre class="source-code">        match data_received['action']:</pre>
			<pre class="source-code">            case 'add message':</pre>
			<pre class="source-code">                # Add message to database</pre>
			<pre class="source-code">                Message.objects.create(</pre>
			<pre class="source-code">                    author=data['author'],</pre>
			<pre class="source-code">                    text=data['text'],</pre>
			<pre class="source-code">                )</pre>
			<p>You can see that the client is added to a room when connecting and removed when disconnecting. In <a href="B18321_05_ePub.xhtml#_idTextAnchor106"><em class="italic">Chapter 5</em></a>, <em class="italic">Separating Communication in Rooms</em>, we will talk in depth about the possibilities of rooms, but for now, we will group all users in a single room with the name <em class="italic">broadcast</em>. </p>
			<p>When an action with the text <strong class="source-inline">'add message'</strong> is received, we directly create a new message with the<a id="_idIndexMarker173"/> information we are sending from the frontend.</p>
			<p>We already stored information! Although we can’t see it or sort it at the moment.</p>
			<p>All the code up to this point can be found in the following repository, which is the first part of the activity:</p>
			<p><a href="https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-4/social-network_step_2">https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-4/social-network_step_2</a></p>
			<p>In the next section, we will print all the messages we have saved directly in HTML via WebSockets.</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor094"/>Rendering database information</h1>
			<p>We have already built a<a id="_idIndexMarker174"/> form that sends a new message to the backend via a WebSockets connection, which we capture in the consumer and then store in the database.</p>
			<p>Now we’re going to get all the messages from the database, render them with Django’s template engine, send the HTML to the client over the connection we kept, and inject the content into the appropriate frontend element.</p>
			<p>Create the HTML template that will generate all the message blocks in the path <strong class="source-inline">/app/website/templates/comp<a id="_idTextAnchor095"/>onents/_list-messages.html</strong> with the content:</p>
			<pre class="source-code">{% for message in messages %}</pre>
			<pre class="source-code">    &lt;article class="message" id="message--{{ message.id</pre>
			<pre class="source-code">        }}"&gt;</pre>
			<pre class="source-code">        &lt;h2 class="message__author"&gt;{{ message.author }}</pre>
			<pre class="source-code">        &lt;/h2&gt;</pre>
			<pre class="source-code">        &lt;p class="message__text"&gt;{{ message.text }}&lt;/p&gt;</pre>
			<pre class="source-code">        &lt;footer class="message__footer"&gt;</pre>
			<pre class="source-code">            &lt;time class="message__created_at"&gt;{{ </pre>
			<pre class="source-code">                message.created_at }}&lt;/time&gt;</pre>
			<pre class="source-code">            &lt;div class="message__controls"&gt;</pre>
			<pre class="source-code">                &lt;button class="button messages__update" </pre>
			<pre class="source-code">                  data-id="{{ message.id }}"&gt; Edit&lt;/button&gt;</pre>
			<pre class="source-code">                &lt;button class="button messages__delete" </pre>
			<pre class="source-code">                    data-id="{{ message.id }}"&gt; Delete</pre>
			<pre class="source-code">                        &lt;/button&gt;</pre>
			<pre class="source-code">            &lt;/div&gt;</pre>
			<pre class="source-code">        &lt;/footer&gt;</pre>
			<pre class="source-code">    &lt;/article&gt;</pre>
			<pre class="source-code">{% endfor %}</pre>
			<p>At the moment, the <strong class="bold">Edit</strong> and <strong class="bold">Delete</strong> buttons are for decoration. Later, we will give them their<a id="_idIndexMarker175"/> functionality.</p>
			<p>Edit the consumer, which is in <strong class="source-inline">app/website/consumers.py</strong>, to include an action that returns messages:</p>
			<pre class="source-code">from channels.generic.websocket import JsonWebsocketConsumer</pre>
			<pre class="source-code">from django.template.loader import render_to_string</pre>
			<pre class="source-code">from . models import Message</pre>
			<pre class="source-code">from asgiref.sync import async_to_sync</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">class SocialNetworkConsumer(JsonWebsocketConsumer):</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    room_name = 'broadcast'</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def connect(self):</pre>
			<pre class="source-code">        """Event when client connects"""</pre>
			<pre class="source-code">        # Accept the connection</pre>
			<pre class="source-code">        self.accept()</pre>
			<pre class="source-code">        # Assign the Broadcast group</pre>
			<pre class="source-code">        async_to_sync(self.channel_layer.group_add)</pre>
			<pre class="source-code">            (self.room_name, self.channel_name)</pre>
			<pre class="source-code">        # Send you all the messages stored in the database.</pre>
			<pre class="source-code">        self.send_list_messages()</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def disconnect(self, close_code):</pre>
			<pre class="source-code">        """Event when client disconnects"""</pre>
			<pre class="source-code">        # Remove from the Broadcast group</pre>
			<pre class="source-code">        async_to_sync(self.channel_layer.group_discard)</pre>
			<pre class="source-code">            (self.room_name, self.channel_name)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def receive_json(self, data_received):</pre>
			<pre class="source-code">        """</pre>
			<pre class="source-code">            Event when data is received</pre>
			<pre class="source-code">            All information will arrive in 2 variables:</pre>
			<pre class="source-code">            'action', with the action to be taken</pre>
			<pre class="source-code">            'data' with the information</pre>
			<pre class="source-code">        """</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">        # Get the data</pre>
			<pre class="source-code">        data = data_received['data']</pre>
			<pre class="source-code">        # Depending on the action we will do one task or </pre>
			<pre class="source-code">          another.</pre>
			<pre class="source-code">        match data_received['action']:</pre>
			<pre class="source-code">            case 'add message':</pre>
			<pre class="source-code">                # Add message to database</pre>
			<pre class="source-code">                Message.objects.create(</pre>
			<pre class="source-code">                    author=data['author'],</pre>
			<pre class="source-code">                    text=data['text'],</pre>
			<pre class="source-code">                )</pre>
			<pre class="source-code">                # Send messages to all clients</pre>
			<pre class="source-code">                self.send_list_messages()</pre>
			<pre class="source-code">            case 'list messages':</pre>
			<pre class="source-code">                # Send messages to all clients</pre>
			<pre class="source-code">                self.send_list_messages()</pre>
			<pre class="source-code"><a id="_idTextAnchor096"/> </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def send_html(self, event):</pre>
			<pre class="source-code">        """Event: Send html to client"""</pre>
			<pre class="source-code">        data = {</pre>
			<pre class="source-code">            'selector': event['selector'],</pre>
			<pre class="source-code">            'html': event['html'],</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        self.send_json(data)</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">    def send_list_messages(self):</pre>
			<pre class="source-code">        """ Send list of messages to client"""</pre>
			<pre class="source-code">        # Filter messages to the current page</pre>
			<pre class="source-code">        messages = Message.objects.order_by('-created_at')</pre>
			<pre class="source-code">        # Render HTML and send to client</pre>
			<pre class="source-code">        async_to_sync(self.channel_layer.group_send)(</pre>
			<pre class="source-code">            self.room_name, {</pre>
			<pre class="source-code">                type': 'send.html', # Run 'send_html()' </pre>
			<pre class="source-code">                    method</pre>
			<pre class="source-code">                'selector': '#messages__list',</pre>
			<pre class="source-code">                'html': render_to_string</pre>
			<pre class="source-code">                ('components/_list-messages.html', { </pre>
			<pre class="source-code">                    'messages': messages})</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        )</pre>
			<p>When the frontend sends us the <strong class="source-inline">'list messages'</strong> action or creates a WebSockets connection, we will execute the <strong class="source-inline">send_list_messages()</strong> function. The backend will get all the messages, render the HTML, and send the messages to the frontend. Inside the function, we are <a id="_idIndexMarker176"/>performing a query to get all the messages in descending order, an elementary action if you have worked with models before. The important thing happens in the next snippet:</p>
			<pre class="source-code">async_to_sync(self.channel_layer.group_send)(</pre>
			<pre class="source-code">            self.room_name, {</pre>
			<pre class="source-code">                type': 'send.html', # Run 'send_html()' </pre>
			<pre class="source-code">                    method</pre>
			<pre class="source-code">                'selector': '#messages__list',</pre>
			<pre class="source-code">                'html': render_to_string('components/_list-</pre>
			<pre class="source-code">                   messages.html', { 'messages': messages})</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">        )</pre>
			<p>When sending information to a group, it will always be done asynchronously so as not to block the main thread, but when communicating with the database, it must be synchronous. How can both types of logic coexist? By turning <strong class="source-inline">self.channel_layer.group_send()</strong> into a synchronous function thanks to <strong class="source-inline">async_to_sync()</strong>. </p>
			<p><strong class="source-inline">self.channel_layer.group_send()</strong> is an unusual function. Its first argument must be the name of the room where you want to send the information, which in our case will be <strong class="source-inline">self.room_name</strong>, which is declared at the beginning of the consumer. And the second argument must have a dictionary where <strong class="source-inline">type</strong> is the name of the function to execute (if you have <strong class="source-inline">_</strong>, it must be replaced with a dot), and the rest of the keys are the information that we want to pass to the function. Inside <strong class="source-inline">send_html</strong>, we capture the previous information with <strong class="source-inline">event[]</strong>. And finally, we send the data to the client in the same way <a id="_idIndexMarker177"/>as in <a href="B18321_03_ePub.xhtml#_idTextAnchor055"><em class="italic">Chapter 3</em></a>, <em class="italic">Adding WebSockets to Django</em>, with <strong class="source-inline">send_json()</strong>.</p>
			<p>When we want to inject HTML, we will send the <strong class="source-inline">html</strong> key with the rendered HTML and <strong class="source-inline">selector</strong> to tell JavaScript where to inject it. The backend will decide what and where each element should go.</p>
			<p>When viewing the browser, we will find the messages that we have been adding, as shown in <em class="italic">Figure 4.3 </em>:</p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/Figure_4.03_B18321.jpg" alt="Figure 4.3 – All messages we have saved in the database are displayed&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – All messages we have saved in the database are displayed</p>
			<p>All the code up to this point can be found at the following link:</p>
			<p><a href="https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-4/social-network_step_3">https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-4/social-network_step_3</a></p>
			<p>What would happen<a id="_idIndexMarker178"/> if we were to display hundreds or thousands of messages per user? The performance and memory consequences would be catastrophic. We must avoid fireworks by limiting the number of messages that can be displayed. Therefore, we will limit it to five messages per page and add some buttons to navigate between each slice. Let’s see that in the next section.</p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor097"/>Limiting queries with a pager</h1>
			<p>We can add <a id="_idIndexMarker179"/>and list messages from the database. But we must limit the <a id="_idIndexMarker180"/>amount of information a user can see. A good practice is to provide the user with a pager to move through all the data. </p>
			<p>Follow the given steps to add a simple pager:</p>
			<ol>
				<li>Modify the template <strong class="source-inline">/app/website/templates/components/_list-messages.html</strong> to add a simple pager divided into two buttons (forward and back):<p class="source-code">{% for message in messages %}</p><p class="source-code">    &lt;article class="message" id="message--{{ </p><p class="source-code">        message.id }}"&gt;</p><p class="source-code">        &lt;h2 class="message__author"&gt;{{ message.author </p><p class="source-code">        }}&lt;/h2&gt;</p><p class="source-code">        &lt;p class="message__text"&gt;{{ message.text }}</p><p class="source-code">        &lt;/p&gt;</p><p class="source-code">        &lt;footer class="message__footer"&gt;</p><p class="source-code">            &lt;time class="message__created_at"&gt;{{ </p><p class="source-code">                message.created_at }}&lt;/time&gt;</p><p class="source-code">            &lt;div class="message__controls"&gt;</p><p class="source-code">                &lt;button class="button </p><p class="source-code">                    messages__update" data-id="{{ </p><p class="source-code">                        message.id }}"&gt; Edit&lt;/button&gt;</p><p class="source-code">                &lt;button class="button </p><p class="source-code">                    messages__delete" data-id="{{ </p><p class="source-code">                       message.id }}"&gt; Delete&lt;/button&gt;</p><p class="source-code">            &lt;/div&gt;</p><p class="source-code">        &lt;/footer&gt;</p><p class="source-code">    &lt;/article&gt;</p><p class="source-code">{% endfor %}</p><p class="source-code">{% if total_pages != 0 %}</p><p class="source-code">    &lt;!-- Paginator --&gt;</p><p class="source-code">    &lt;div id="paginator" data-page="{{ page }}"&gt;</p><p class="source-code">        {# The back button on the first page is not </p><p class="source-code">        displayed #}</p><p class="source-code">        {% if page ! = 1 %}</p><p class="source-code">        &lt;button class="button" id="messages__previous-</p><p class="source-code">            page"&gt; Previous&lt;/button&gt;</p><p class="source-code">        {% endif %}</p><p class="source-code"> </p><p class="source-code">        {# The forward button on the last page is not </p><p class="source-code">        displayed #}</p><p class="source-code">        {% if page ! = total_pages %}</p><p class="source-code">        &lt;button class="button" id="messages__next-</p><p class="source-code">            page"&gt;Next&lt;/button&gt;</p><p class="source-code">        {% endif %}</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">    &lt;!-- End Paginator --&gt;</p><p class="source-code">{% endif %}</p><ul><li>With <strong class="source-inline">data-page="{{ page }}"</strong>, we are giving JavaScript a counter with the page we are on. We will use this data to create a new event that will trigger an <a id="_idIndexMarker181"/>action indicating whether we want to go to the next page or back.</li><li>The conditional <strong class="source-inline">{% if page ! = 1 %}</strong> is used to avoid showing the back button if we are on the first page.</li><li>The conditional <strong class="source-inline">{% if page ! = total_pages %}</strong> ignores the rendering of the forward button if we are on the last page.</li></ul></li>
				<li> We add to the<a id="_idIndexMarker182"/> consumer (<strong class="source-inline">/app/website/consumers.py</strong>) a slice system for <strong class="source-inline">send_list_messages()</strong>:<p class="source-code">from channels.generic.websocket import JsonWebsocketConsumer</p><p class="source-code">from django.template.loader import render_to_string</p><p class="source-code">from . models import Message</p><p class="source-code">from asgiref.sync import async_to_sync</p><p class="source-code">import math</p><p class="source-code"> </p><p class="source-code"> </p><p class="source-code">class SocialNetworkConsumer(JsonWebsocketConsumer):</p><p class="source-code"> </p><p class="source-code">    room_name = 'broadcast</p><p class="source-code">    max_messages_per_page = 5 # New line</p><p class="source-code"> </p><p class="source-code">    def connect(self):</p><p class="source-code">        """Event when client connects"""</p><p class="source-code">        # Accept the connection</p><p class="source-code">        self.accept()</p><p class="source-code">        # Assign the Broadcast group</p><p class="source-code">        async_to_sync(self.channel_layer.group_add)(self.room_name, self.channel_name)</p><p class="source-code">        # Send you all the messages stored in the database.</p><p class="source-code">        self.send_list_messages()</p><p class="source-code"> </p><p class="source-code">    def disconnect(self, close_code):</p><p class="source-code">        """Event when client disconnects"""</p><p class="source-code">        # Remove from the Broadcast group</p><p class="source-code">        async_to_sync(self.channel_layer.</p><p class="source-code">            group_discard)(self.room_name, </p><p class="source-code">                self.channel_name)</p><p class="source-code"> </p><p class="source-code">    def receive_json(self, data_received):</p><p class="source-code">        """</p><p class="source-code">            Event when data is received</p><p class="source-code">            All information will arrive in 2 </p><p class="source-code">            variables:</p><p class="source-code">            'action', with the action to be taken</p><p class="source-code">            'data' with the information</p><p class="source-code">        """</p><p class="source-code"> </p><p class="source-code">        # Get the data</p><p class="source-code">        data = data_received['data']</p><p class="source-code">        # Depending on the action we will do one task</p><p class="source-code">         or another.</p><p class="source-code">        match data_received['action']:</p><p class="source-code">            case 'add message':</p><p class="source-code">                # Add message to database</p><p class="source-code">                Message.objects.create(</p><p class="source-code">                    author=data['author'],</p><p class="source-code">                    text=data['text'],</p><p class="source-code">                )</p><p class="source-code">                # Send messages to all clients</p><p class="source-code">                self.send_list_messages()</p><p class="source-code">            case 'list messages':</p><p class="source-code">                # Send messages to all clients</p><p class="source-code">                self.send_list_messages(data['page'])</p><p class="source-code">                # Update line</p><p class="source-code"> </p><p class="source-code"> </p><p class="source-code">    def send_html(self, event):</p><p class="source-code">        """Event: Send html to client"""</p><p class="source-code">        data = {</p><p class="source-code">            'selector': event['selector'],</p><p class="source-code">            'html': event['html'],</p><p class="source-code">        }</p><p class="source-code">        self.send_json(data)</p><p class="source-code"> </p><p class="source-code"> </p><p class="source-code">    def send_list_messages(self, page=1): </p><p class="source-code">    # Update line</p><p class="source-code">        "Send list of messages to client"""""</p><p class="source-code">        # Filter messages to the current page</p><p class="source-code">        start_pager = self.max_messages_per_page * </p><p class="source-code">            (page - 1) # New line</p><p class="source-code">        end_pager = start_pager + </p><p class="source-code">            self.max_messages_per_page # New line</p><p class="source-code">        messages = Message.objects.order_by('-</p><p class="source-code">            created_at')</p><p class="source-code">        messages_page = messages[start_pager:</p><p class="source-code">            end_pager] # New line</p><p class="source-code">        # Render HTML and send to client</p><p class="source-code">        total_pages = math.ceil(messages.count() / </p><p class="source-code">            self.max_messages_per_page) # New line    </p><p class="source-code">        async_to_sync(self.channel_layer.group_send)(</p><p class="source-code">            self.room_name, {</p><p class="source-code">                'type': 'send.html', # Run </p><p class="source-code">                    'send_html()' method</p><p class="source-code">                'selector': '#messages__list',</p><p class="source-code">                'html': render_to_string</p><p class="source-code">                  ('components/_list-messages.html', {</p><p class="source-code">                    'messages': messages_page, </p><p class="source-code">                    # Update line</p><p class="source-code">                    'page': page, # New line</p><p class="source-code">                    total_pages': total_pages, </p><p class="source-code">                    # New line</p><p class="source-code">                })</p><p class="source-code">            }</p><p class="source-code">        )</p><ul><li>The variable <strong class="source-inline">max_messages_per_page = 5</strong> has been added to indicate the number of items per page.</li><li>The <strong class="source-inline">'list messages'</strong> action <a id="_idIndexMarker183"/>now collects and passes to the <strong class="source-inline">send_list_messages</strong> function the page to be displayed.</li><li>We have updated <strong class="source-inline">send_list_messages</strong>. We allow you to indicate the page to be displayed, we <a id="_idIndexMarker184"/>calculate the query slices, and we give <strong class="source-inline">render_to_string</strong> the <strong class="source-inline">messages</strong> with the slice, <strong class="source-inline">page</strong>, and <strong class="source-inline">total_pages</strong> variables, which we use to know if we are on the last page.</li></ul></li>
				<li>In <strong class="source-inline">/static/js/index.js</strong>, add the two JavaScript functions (<strong class="source-inline">goToNextPage</strong> and <strong class="source-inline">goToPreviousPage</strong>) that will take care of the page-turning. Actually, they just use an action with the request to list the messages but in another slice:<p class="source-code">/*</p><p class="source-code">    VARIABLES</p><p class="source-code">*/</p><p class="source-code">// Connect to WebSockets server (SocialNetworkConsumer)</p><p class="source-code">const myWebSocket = new WebSocket</p><p class="source-code">(`${document.body.dataset.scheme === 'http' ? 'ws' : </p><p class="source-code">'wss'}://${ document.body.dataset.host }/ws/social-</p><p class="source-code">    network/`);</p><p class="source-code">const inputAuthor = document.querySelector("#message-</p><p class="source-code">    form__author");</p><p class="source-code">const inputText = document.querySelector("#message-</p><p class="source-code">    form__text");</p><p class="source-code">const inputSubmit = document.querySelector("#message-</p><p class="source-code">    form__submit");</p><p class="source-code"> </p><p class="source-code">/*</p><p class="source-code">    FUNCTIONS</p><p class="source-code">*/</p><p class="source-code"> </p><p class="source-code">/**</p><p class="source-code">* Send data to WebSockets server</p><p class="source-code">* @param {string} message</p><p class="source-code">* @param {WebSocket} webSocket</p><p class="source-code">* @return {void}</p><p class="source-code">*/</p><p class="source-code">function sendData(message, webSocket) {</p><p class="source-code">    webSocket.send(JSON.stringify(message));</p><p class="source-code">}</p><p class="source-code"> </p><p class="source-code"> </p><p class="source-code">/**</p><p class="source-code">* Send new message</p><p class="source-code">* @param {Event} event</p><p class="source-code">* @return {void}</p><p class="source-code">*/</p><p class="source-code">function sendNewMessage(event) {</p><p class="source-code">    event.preventDefault();</p><p class="source-code">    // Prepare the information we will send</p><p class="source-code">    const newData = {</p><p class="source-code">        "action": "add message",</p><p class="source-code">        "data": {</p><p class="source-code">            "author": inputAuthor.value,</p><p class="source-code">            "text": inputText.value</p><p class="source-code">        }</p><p class="source-code">    };</p><p class="source-code">    // Send the data to the server</p><p class="source-code">    sendData(newData, myWebSocket);</p><p class="source-code">    // Clear message form</p><p class="source-code">    inputText.value = "";</p><p class="source-code">}</p><p class="source-code"> </p><p class="source-code">/**</p><p class="source-code">* Get current page stored in #paginator as dataset</p><p class="source-code">* @returns {number}</p><p class="source-code">*/</p><p class="source-code">function getCurrentPage() {</p><p class="source-code">    return parseInt(document.</p><p class="source-code">        querySelector("#paginator"). dataset.page);</p><p class="source-code">}</p><p class="source-code"> </p><p class="source-code">/**</p><p class="source-code">* Switch to the next page</p><p class="source-code">* @param {Event} event</p><p class="source-code">* @return {void}</p><p class="source-code">*/</p><p class="source-code">function goToNextPage(event) {</p><p class="source-code">    // Prepare the information we will send</p><p class="source-code">    const newData = {</p><p class="source-code">        "action": "list messages",</p><p class="source-code">        "data": {</p><p class="source-code">            "page": getCurrentPage() + 1,</p><p class="source-code">        }</p><p class="source-code">    };</p><p class="source-code">    // Send the data to the server</p><p class="source-code">    sendData(newData, myWebSocket);</p><p class="source-code">}</p><p class="source-code"> </p><p class="source-code">/**</p><p class="source-code">* Switch to the previous page</p><p class="source-code">* @param {Event} event</p><p class="source-code">* @return {void}</p><p class="source-code">*/</p><p class="source-code">function goToPreviousPage(event) {</p><p class="source-code">    // Prepare the information we will send</p><p class="source-code">    const newData = {</p><p class="source-code">        "action": "list messages",</p><p class="source-code">        "data": {</p><p class="source-code">            "page": getCurrentPage() - 1,</p><p class="source-code">        }</p><p class="source-code">    };</p><p class="source-code">    // Send the data to the server</p><p class="source-code">    sendData(newData, myWebSocket);</p><p class="source-code">}</p><p class="source-code"> </p><p class="source-code">/*</p><p class="source-code">    EVENTS</p><p class="source-code">*/</p><p class="source-code"> </p><p class="source-code">// Event when a new message is received by WebSockets</p><p class="source-code">myWebSocket.addEventListener("message", (event) =&gt; {</p><p class="source-code">    // Parse the data received</p><p class="source-code">    const data = JSON.parse(event.data);</p><p class="source-code">    // Renders the HTML received from the Consumer</p><p class="source-code">    document.querySelector(data.selector). innerHTML = </p><p class="source-code">        data.html;</p><p class="source-code">    /* Reassigns the events of the newly rendered HTML */</p><p class="source-code">    // Pagination</p><p class="source-code">    document.querySelector("#messages__next-page")?. </p><p class="source-code">        addEventListener("click", goToNextPage);</p><p class="source-code">    document.querySelector("#messages__previous-</p><p class="source-code">        page")?. addEventListener("click", </p><p class="source-code">            goToPreviousPage);</p><p class="source-code">});</p><p class="source-code"> </p><p class="source-code">// Sends new message when you click on Submit</p><p class="source-code">inputSubmit.addEventListener("click", sendNewMessage);</p></li>
			</ol>
			<p>And where do we add the listeners for the buttons to execute the functions? Inside the <strong class="source-inline">"message"</strong> event of <strong class="source-inline">WebSockets</strong>. Why? Every time the message section is updated, all the <a id="_idIndexMarker185"/>HTML is deleted and recreated with what is<a id="_idIndexMarker186"/> received from the backend. The events disappear with every update. We have to reassign them. After redrawing the messages, we will assign the listeners:</p>
			<p class="source-code">document.querySelector("#messages__next-page")?. </p>
			<p class="source-code">    addEventListener("click", goToNextPage); </p>
			<p class="source-code">document.querySelector("#messages__previous-page")?. </p>
			<p class="source-code">    addEventListener("click", goToPreviousPage);</p>
			<p>Go ahead, create as many messages as you want – at least six – to check how the pager does its job properly.</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/Figure_4.04_B18321.jpg" alt="Figure 4.4 – We display the first page of messages&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – We display the first page of messages</p>
			<p>If we turn<a id="_idIndexMarker187"/> the page by clicking on the <strong class="bold">Next</strong> button, the next block of<a id="_idIndexMarker188"/> messages will be rendered.</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/Figure_4.05_B18321.jpg" alt="Figure 4.5 – We display the last page of messages&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – We display the last page of messages</p>
			<p>All the code up to <a id="_idIndexMarker189"/>this point can be found at the following link:</p>
			<p><a href="https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-4/social-network_step_4">https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-4/social-network_step_4</a></p>
			<p>The next target will be to <a id="_idIndexMarker190"/>delete messages with the <strong class="bold">Delete</strong> button. In the next section, we will send via <strong class="source-inline">WebSockets</strong> an action with the instruction to delete messages with the concrete <strong class="source-inline">id</strong> of a message—we will be as precise as a sniper.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor098"/>Deleting rows from a database</h1>
			<p>In the previous sections, we <a id="_idIndexMarker191"/>managed to build a system where we could <a id="_idIndexMarker192"/>add new messages, list them, and paginate them. But so far, we are unable to delete anything. </p>
			<p>The way the project is structured, it is really quick to implement:</p>
			<ol>
				<li value="1">We check in <strong class="source-inline">/app/website/templates/components/_list-messages.html</strong> that we are adding to each button a dataset with the <strong class="source-inline">id</strong>. We do this task when we list the messages; we must be aware of the source where the <strong class="source-inline">id</strong> that we will use comes from to know which message we must delete:<p class="source-code">&lt;button class="button messages__delete" data-id="{{ </p><p class="source-code">    message.id }}"&gt; Delete&lt;/button&gt;</p></li>
				<li>In <strong class="source-inline">/static/js/index.js</strong>, add the <strong class="source-inline">deleteMessage</strong> function. We will capture the dataset with the id <a id="_idIndexMarker193"/>and send it to the consumer with the action <strong class="source-inline">"delete message"</strong>. In addition, we will add each listener after the<a id="_idIndexMarker194"/> listener of the pager. Let’s not forget the reason for this positioning: all events must be reassigned after every change or new backend message with HTML that we inject:<p class="source-code">/*</p><p class="source-code">    VARIABLES</p><p class="source-code">*/</p><p class="source-code">// Connect to WebSockets server (SocialNetworkConsumer)</p><p class="source-code">const myWebSocket = new WebSocket</p><p class="source-code">    (`${document.body.dataset.scheme === 'http' ? 'ws' </p><p class="source-code">    : 'wss'}://${ document.body.dataset.host </p><p class="source-code">    }/ws/social-network/`);</p><p class="source-code">const inputAuthor = document.querySelector("#message-</p><p class="source-code">    form__author");</p><p class="source-code">const inputText = document.querySelector("#message-</p><p class="source-code">    form__text");</p><p class="source-code">const inputSubmit = document.querySelector("#message-</p><p class="source-code">    form__submit");</p><p class="source-code"> </p><p class="source-code">/*</p><p class="source-code">    FUNCTIONS</p><p class="source-code">*/</p><p class="source-code"> </p><p class="source-code">/**</p><p class="source-code">* Send data to WebSockets server</p><p class="source-code">* @param {string} message</p><p class="source-code">* @param {WebSocket} webSocket</p><p class="source-code">* @return {void}</p><p class="source-code">*/</p><p class="source-code">function sendData(message, webSocket) {</p><p class="source-code">    webSocket.send(JSON.stringify(message));</p><p class="source-code">}</p><p class="source-code"> </p><p class="source-code">/**</p><p class="source-code">* Delete message</p><p class="source-code">* @param {Event} event</p><p class="source-code">* @return {void}</p><p class="source-code">*/</p><p class="source-code">function deleteMessage(event) {</p><p class="source-code">    const message = {</p><p class="source-code">        "action": "delete message",</p><p class="source-code">        "data": {</p><p class="source-code">            "id": event.target.dataset.id</p><p class="source-code">        }</p><p class="source-code">    };</p><p class="source-code">    sendData(message, myWebSocket);</p><p class="source-code">}</p><p class="source-code"> </p><p class="source-code">/**</p><p class="source-code">* Send new message</p><p class="source-code">* @param {Event} event</p><p class="source-code">* @return {void}</p><p class="source-code">*/</p><p class="source-code">function sendNewMessage(event) {</p><p class="source-code">    event.preventDefault();</p><p class="source-code">    // Prepare the information we will send</p><p class="source-code">    const newData = {</p><p class="source-code">        "action": "add message",</p><p class="source-code">        "data": {</p><p class="source-code">            "author": inputAuthor.value,</p><p class="source-code">            "text": inputText.value</p><p class="source-code">        }</p><p class="source-code">    };</p><p class="source-code">    // Send the data to the server</p><p class="source-code">    sendData(newData, myWebSocket);</p><p class="source-code">    // Clear message form</p><p class="source-code">    inputText.value = "";</p><p class="source-code">}</p><p class="source-code"> </p><p class="source-code"> </p><p class="source-code">/**</p><p class="source-code">* Get current page stored in #paginator as dataset</p><p class="source-code">* @returns {number}</p><p class="source-code">*/</p><p class="source-code">function getCurrentPage() {</p><p class="source-code">    return parseInt(document.querySelector("#paginator"). dataset.page);</p><p class="source-code">}</p><p class="source-code"> </p><p class="source-code"> </p><p class="source-code">/**</p><p class="source-code">* Switch to the next page</p><p class="source-code">* @param {Event} event</p><p class="source-code">* @return {void}</p><p class="source-code">*/</p><p class="source-code">function goToNextPage(event) {</p><p class="source-code">    // Prepare the information we will send</p><p class="source-code">    const newData = {</p><p class="source-code">        "action": "list messages",</p><p class="source-code">        "data": {</p><p class="source-code">            "page": getCurrentPage() + 1,</p><p class="source-code">        }</p><p class="source-code">    };</p><p class="source-code">    // Send the data to the server</p><p class="source-code">    sendData(newData, myWebSocket);</p><p class="source-code">}</p><p class="source-code"> </p><p class="source-code">/**</p><p class="source-code">* Switch to the previous page</p><p class="source-code">* @param {Event} event</p><p class="source-code">* @return {void}</p><p class="source-code">*/</p><p class="source-code">function goToPreviousPage(event) {</p><p class="source-code">    // Prepare the information we will send</p><p class="source-code">    const newData = {</p><p class="source-code">        "action": "list messages",</p><p class="source-code">        "data": {</p><p class="source-code">            "page": getCurrentPage() - 1,</p><p class="source-code">        }</p><p class="source-code">    };</p><p class="source-code">    // Send the data to the server</p><p class="source-code">    sendData(newData, myWebSocket);</p><p class="source-code">}</p><p class="source-code"> </p><p class="source-code">/*</p><p class="source-code">    EVENTS</p><p class="source-code">*/</p><p class="source-code"> </p><p class="source-code">// Event when a new message is received by WebSockets</p><p class="source-code">myWebSocket.addEventListener("message", (event) =&gt; {</p><p class="source-code">    // Parse the data received</p><p class="source-code">    const data = JSON.parse(event.data);</p><p class="source-code">    // Renders the HTML received from the Consumer</p><p class="source-code">    document.querySelector(data.selector). innerHTML = </p><p class="source-code">        data.html;</p><p class="source-code">    /* Reassigns the events of the newly rendered HTML */</p><p class="source-code">    // Pagination</p><p class="source-code">    document.querySelector("#messages__next-</p><p class="source-code">      page")?.addEventListener("click", goToNextPage);</p><p class="source-code">    document.querySelector("#messages__previous-</p><p class="source-code">       page")?.addEventListener("click", </p><p class="source-code">           goToPreviousPage);</p><p class="source-code">    // Add to all delete buttons the event</p><p class="source-code">    document.querySelectorAll</p><p class="source-code">        (".messages__delete").forEach(button =&gt; {</p><p class="source-code">        button.addEventListener("click", </p><p class="source-code">            deleteMessage);</p><p class="source-code">    });</p><p class="source-code">});</p><p class="source-code"> </p><p class="source-code">// Sends new message when you click on Submit</p><p class="source-code">inputSubmit.addEventListener("click", sendNewMessage);</p></li>
				<li>Now, edit <strong class="source-inline">/app/website/consumers.py</strong> with<a id="_idIndexMarker195"/> the<a id="_idIndexMarker196"/> action <strong class="source-inline">'delete message'</strong>:<p class="source-code"># app/website/consumers.py</p><p class="source-code">from channels.generic.websocket import JsonWebsocketConsumer</p><p class="source-code">from django.template.loader import render_to_string</p><p class="source-code">from .models import Message</p><p class="source-code">from asgiref.sync import async_to_sync</p><p class="source-code">import math</p><p class="source-code"> </p><p class="source-code"> </p><p class="source-code">class SocialNetworkConsumer(JsonWebsocketConsumer):</p><p class="source-code"> </p><p class="source-code">    room_name = 'broadcast'</p><p class="source-code">    max_messages_per_page = 5</p><p class="source-code"> </p><p class="source-code">    def connect(self):</p><p class="source-code">        """Event when client connects"""</p><p class="source-code">        # Accept the connection</p><p class="source-code">        self.accept()</p><p class="source-code">        # Assign the Broadcast group</p><p class="source-code">        async_to_sync(self.channel_layer.group_add)</p><p class="source-code">            (self.room_name, self.channel_name)</p><p class="source-code">        # Send you all the messages stored in the </p><p class="source-code">        database.</p><p class="source-code">        self.send_list_messages()</p><p class="source-code"> </p><p class="source-code">    def disconnect(self, close_code):</p><p class="source-code">        """Event when client disconnects"""</p><p class="source-code">        # Remove from the Broadcast group</p><p class="source-code">        async_to_sync(self.channel_layer.group_</p><p class="source-code">           discard)(self.room_name, self.channel_name)</p><p class="source-code"> </p><p class="source-code">    def receive_json(self, data_received):</p><p class="source-code">        """</p><p class="source-code">            Event when data is received</p><p class="source-code">            All information will arrive in 2 variables:</p><p class="source-code">            'action', with the action to be taken</p><p class="source-code">            'data' with the information</p><p class="source-code">        """</p><p class="source-code"> </p><p class="source-code">        # Get the data</p><p class="source-code">        data = data_received['data']</p><p class="source-code">        # Depending on the action we will do one task or another.</p><p class="source-code">        match data_received['action']:</p><p class="source-code">            case 'add message':</p><p class="source-code">                # Add message to database</p><p class="source-code">                Message.objects.create(</p><p class="source-code">                    author=data['author'],</p><p class="source-code">                    text=data['text'],</p><p class="source-code">                )</p><p class="source-code">                # Send messages to all clients</p><p class="source-code">                self.send_list_messages()</p><p class="source-code">            case 'list messages':</p><p class="source-code">                # Send messages to all clients</p><p class="source-code">                self.send_list_messages(<a id="_idTextAnchor099"/>data['page'])</p><p class="source-code">            case 'delete message':</p><p class="source-code">                # Delete message from database</p><p class="source-code">                Message.objects.get</p><p class="source-code">                   (id=data['id']).delete() # New line</p><p class="source-code">                # Send messages to all clients</p><p class="source-code">                self.send_list_messages() # New line</p><p class="source-code"> </p><p class="source-code"> </p><p class="source-code">    def send_html(self, event):</p><p class="source-code">        """Event: Send html to client"""</p><p class="source-code">        data = {</p><p class="source-code">            'selector': event['selector'],</p><p class="source-code">            'html': event['html'],</p><p class="source-code">        }</p><p class="source-code">        self.send_json(data)</p><p class="source-code"> </p><p class="source-code"> </p><p class="source-code">    def send_list_messages(self, page=1):</p><p class="source-code">        """Send list of messages to client"""</p><p class="source-code">        # Filter messages to the current page</p><p class="source-code">        start_pager = self.max_messages_per_page * </p><p class="source-code">           (page - 1)</p><p class="source-code">        end_pager = start_pager + </p><p class="source-code">            self.max_messages_per_page</p><p class="source-code">        messages = Message.objects.order_by('-</p><p class="source-code">            created_at')</p><p class="source-code">        messages_page = messages</p><p class="source-code">            [start_pager:end_pager]</p><p class="source-code">        # Render HTML and send to client</p><p class="source-code">        total_pages = math.ceil(messages.count() / </p><p class="source-code">            self.max_messages_per_page)</p><p class="source-code">        async_to_sync(self.channel_layer.group_send)(</p><p class="source-code">            self.room_name, {</p><p class="source-code">                'type': 'send.html', # Run </p><p class="source-code">                 'send_html()' method</p><p class="source-code">                'selector': '#messages__list',</p><p class="source-code">                'html': render_to_string</p><p class="source-code">                  ('components/_list-messages.html', {</p><p class="source-code">                    'messages': messages_page,</p><p class="source-code">                    'page': page,</p><p class="source-code">                    'total_pages': total_pages,</p><p class="source-code">                }) </p><p class="source-code">            }</p><p class="source-code">        )</p></li>
			</ol>
			<p>With <strong class="source-inline">Message.objects.get(id=data['id']).delete()</strong>, we delete the message directly from the <strong class="source-inline">id</strong> sent to us by the frontend. Finally, we update the list of messages from all clients with <strong class="source-inline">self.send_list_messages()</strong>.</p>
			<p>All the code up to this point can be found at the following link:</p>
			<p><a href="https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-4/social-network_step_5">https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-4/social-network_step_5</a></p>
			<p>We have finished<a id="_idIndexMarker197"/> creating the functionality to delete rows in the database. We<a id="_idIndexMarker198"/> are now able to selectively delete messages. In the next part of the exercise, we will finish building the social network by adding the ability to modify an existing message. And with this new feature, we will have all the letters of BREAD. </p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor100"/>Updating rows in a database</h1>
			<p>In this last part <a id="_idIndexMarker199"/>of the exercise, we will finish building the social network by adding a form to <a id="_idIndexMarker200"/>modify the information.</p>
			<p>All the finished code can be found at the following link:</p>
			<p><a href="https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-4/social-network_step_6">https://github.com/PacktPublishing/Building-SPAs-with-Django-and-HTML-Over-the-Wire/tree/main/chapter-4/social-network_step_6</a></p>
			<p>Let’s start:</p>
			<ol>
				<li value="1">Create a new HTML component, in <strong class="source-inline">/app<a id="_idTextAnchor101"/>/website/templates/components/_edit-message.html</strong>, with the following content:<p class="source-code">&lt;form class="update-form" data-id="{{ message.id }}"&gt;</p><p class="source-code">    &lt;input</p><p class="source-code">            type="text"</p><p class="source-code">            placeholder="Name"</p><p class="source-code">            id="message-form__author--update"</p><p class="source-code">            class="message-form__author" </p><p class="source-code">            name="author"</p><p class="source-code">            required</p><p class="source-code">            value="{{ message.author }}"</p><p class="source-code">    &gt;</p><p class="source-code">    &lt;textarea</p><p class="source-code">            name="message"</p><p class="source-code">            placeholder="Write your message here..."</p><p class="source-code">            id="message-form__text--update"</p><p class="source-code">            class="message-form__text" </p><p class="source-code">            required</p><p class="source-code">    &gt;{{ message.text }}&lt;/textarea&gt;</p><p class="source-code">    &lt;input</p><p class="source-code">            type="submit"</p><p class="source-code">            class="message-form__submit" class="message-form__submit" </p><p class="source-code">            id="message-form__submit--update"</p><p class="source-code">            value="Update"</p><p class="source-code">    &gt;</p><p class="source-code">&lt;/form&gt;</p></li>
			</ol>
			<p>The HTML component is <a id="_idIndexMarker201"/>practically the same as when we create a <a id="_idIndexMarker202"/>message, except for the detail that we store the <strong class="source-inline">id</strong> of the message to be modified in a dataset that we host in the <strong class="source-inline">&lt;form&gt;</strong> tag with <strong class="source-inline">data-id="{{ message.id }}"</strong> and that we fill in all the fields.</p>
			<ol>
				<li value="2">Create an action<a id="_idIndexMarker203"/> requesting the edit form in the consumer:<p class="source-code">case 'open edit page':</p><p class="source-code">self.open_edit_page(data['id'])</p></li>
			</ol>
			<p>This action will only<a id="_idIndexMarker204"/> render and send the previous component so that the user ca<a id="_idTextAnchor102"/>n edit the following information:</p>
			<p class="source-code">def open_edit_page(self, id):</p>
			<p class="source-code">        """Send the form to edit the message"""</p>
			<p class="source-code">        message = Message.objects.get(id=id)</p>
			<p class="source-code">        async_to_sync(self.channel_layer.group_send)(</p>
			<p class="source-code">            self.room_name, {</p>
			<p class="source-code">                'type': 'send.html', # Run </p>
			<p class="source-code">                   'send_html()' method</p>
			<p class="source-code">                'selector': f'#message--{id}',</p>
			<p class="source-code">                'html': render_to_string</p>
			<p class="source-code">                   ('components/_edit-message.html',</p>
			<p class="source-code">                       {'message': message})</p>
			<p class="source-code">            }</p>
			<p class="source-code">        )</p>
			<ol>
				<li value="3">Now, in the consumer, add the action to collect the information from the form, update the database, <a id="_idTextAnchor103"/>and render the list of messages: <p class="source-code">case 'update message':</p><p class="source-code">                # Update message in database</p><p class="source-code">                Message.objects.filter(id=data['id']). update(</p><p class="source-code">                    author=data['author'],</p><p class="source-code">                    text=data['text'],</p><p class="source-code">                )</p><p class="source-code">                # Send messages to all clients</p><p class="source-code">                self.send_list_messages()</p></li>
			</ol>
			<p>The entire<a id="_idIndexMarker205"/> integrated consumer, including the up<a id="_idTextAnchor104"/>date action, will look <a id="_idIndexMarker206"/>like this:</p>
			<p class="source-code">from channels.generic.websocket import JsonWebsocketConsumer</p>
			<p class="source-code">from django.template.loader import render_to_string</p>
			<p class="source-code">from .models import Message</p>
			<p class="source-code">from asgiref.sync import async_to_sync</p>
			<p class="source-code">import math</p>
			<p class="source-code"> </p>
			<p class="source-code"> </p>
			<p class="source-code">class SocialNetworkConsumer(JsonWebsocketConsumer):</p>
			<p class="source-code"> </p>
			<p class="source-code">    room_name = 'broadcast'</p>
			<p class="source-code">    max_messages_per_page = 5</p>
			<p class="source-code"> </p>
			<p class="source-code">    def connect(self):</p>
			<p class="source-code">        """Event when client connects"""</p>
			<p class="source-code">        # Accept the connection</p>
			<p class="source-code">        self.accept()</p>
			<p class="source-code">        # Assign the Broadcast group</p>
			<p class="source-code">        async_to_sync(self.channel_layer.group_add)(self.room_name, self.channel_name)</p>
			<p class="source-code">        # Send you all the messages stored in the database.</p>
			<p class="source-code">        self.send_list_messages()</p>
			<p class="source-code"> </p>
			<p class="source-code">    def disconnect(self, close_code):</p>
			<p class="source-code">        """Event when client disconnects"""</p>
			<p class="source-code">        # Remove from the Broadcast group</p>
			<p class="source-code">        async_to_sync(self.channel_layer.</p>
			<p class="source-code">           group_discard)(self.room_name, </p>
			<p class="source-code">              self.channel_name)</p>
			<p class="source-code"> </p>
			<p class="source-code">    def receive_json(self, data_received):</p>
			<p class="source-code">        """</p>
			<p class="source-code">            Event when data is received</p>
			<p class="source-code">            All information will arrive in 2 variables:</p>
			<p class="source-code">            'action', with the action to be taken</p>
			<p class="source-code">            'data' with the information</p>
			<p class="source-code">        """</p>
			<p class="source-code"> </p>
			<p class="source-code">        # Get the data</p>
			<p class="source-code">        data = data_received['data']</p>
			<p class="source-code">        # Depending on the action we will do one task or another.</p>
			<p class="source-code">        match data_received['action']:</p>
			<p class="source-code">            case 'add message':</p>
			<p class="source-code">                # Add message to database</p>
			<p class="source-code">                Message.objects.create(</p>
			<p class="source-code">                    author=data['author'],</p>
			<p class="source-code">                    text=data['text'],</p>
			<p class="source-code">                )</p>
			<p class="source-code">                # Send messages to all clients</p>
			<p class="source-code">                self.send_list_messages()</p>
			<p class="source-code">            case 'list messages':</p>
			<p class="source-code">                # Send messages to all clients</p>
			<p class="source-code">                self.send_list_messages(data['page'])</p>
			<p class="source-code">            case 'delete message':</p>
			<p class="source-code">                # Delete message from database</p>
			<p class="source-code">                Message.objects.get</p>
			<p class="source-code">                   (id=data['id']).delete()</p>
			<p class="source-code">                # Send messages to all clients</p>
			<p class="source-code">                self.send_list_messages()</p>
			<p class="source-code">            case 'open edit page':</p>
			<p class="source-code">                self.open_edit_page(data['id'])</p>
			<p class="source-code">            case 'update message':</p>
			<p class="source-code">                # Update message in database</p>
			<p class="source-code">                Message.objects.filter(id=data['id']). </p>
			<p class="source-code">                    update(</p>
			<p class="source-code">                    author=data['author'],</p>
			<p class="source-code">                    text=data['text'],</p>
			<p class="source-code">                ) # New block</p>
			<p class="source-code">                # Send messages to all clients</p>
			<p class="source-code">                self.send_list_messages() # New line</p>
			<p class="source-code"> </p>
			<p class="source-code"> </p>
			<p class="source-code">    def send_html(self, event):</p>
			<p class="source-code">        """Event: Send html to client"""</p>
			<p class="source-code">        data = {</p>
			<p class="source-code">            'selector': event['selector'],</p>
			<p class="source-code">            'html': event['html'],</p>
			<p class="source-code">        }</p>
			<p class="source-code">        self.send_json(data)</p>
			<p class="source-code"> </p>
			<p class="source-code"> </p>
			<p class="source-code">    def send_list_messages(self, page=1):</p>
			<p class="source-code">        """Send list of messages to client"""</p>
			<p class="source-code">        # Filter messages to the current page</p>
			<p class="source-code">        start_pager = self.max_messages_per_page * (page - 1)</p>
			<p class="source-code">        end_pager = start_pager + </p>
			<p class="source-code">            self.max_messages_per_page</p>
			<p class="source-code">        messages = Message.objects.order_by('-</p>
			<p class="source-code">            created_at')</p>
			<p class="source-code">        messages_page = </p>
			<p class="source-code">            messages[start_pager:end_pager].</p>
			<p class="source-code">        # Render HTML and send to client</p>
			<p class="source-code">        total_pages = math.ceil(messages.count() / </p>
			<p class="source-code">            self.max_messages_per_page)</p>
			<p class="source-code">        async_to_sync(self.channel_layer.group_send)(</p>
			<p class="source-code">            self.room_name, {</p>
			<p class="source-code">                'type': 'send.html', # Run </p>
			<p class="source-code">                    'send_html()' method</p>
			<p class="source-code">                'selector': '#messages__list',</p>
			<p class="source-code">                'html': render_to_string</p>
			<p class="source-code">                  ('components/_list-messages.html', {</p>
			<p class="source-code">                    'messages': messages_page,</p>
			<p class="source-code">                    'page': page,</p>
			<p class="source-code">                    'total_pages': total_pages,</p>
			<p class="source-code">                })</p>
			<p class="source-code">            }</p>
			<p class="source-code">        )</p>
			<p class="source-code"> </p>
			<p class="source-code"> </p>
			<p class="source-code">    def open_edit_page(self, id):</p>
			<p class="source-code">        """Send the form to edit the message"""</p>
			<p class="source-code">        message = Message.objects.get(id=id)</p>
			<p class="source-code">        async_to_sync(self.channel_layer.group_send)(</p>
			<p class="source-code">            self.room_name, {</p>
			<p class="source-code">                'type': 'send.html', # Run </p>
			<p class="source-code">                    'send_html()' method</p>
			<p class="source-code">                'selector': f'#message--{id}',</p>
			<p class="source-code">                'html': render_to_string</p>
			<p class="source-code">                    ('components/_edit-message.html', </p>
			<p class="source-code">                        {'message': message})</p>
			<p class="source-code">            }</p>
			<p class="source-code">        )</p>
			<ol>
				<li value="4">We create the <a id="_idIndexMarker207"/>necessary events in the frontend to request<a id="_idIndexMarker208"/> the form, collect the information, and send it.</li>
			</ol>
			<p>We connect to the channel and collect the form fields where users can write new messages:</p>
			<p class="source-code">/*</p>
			<p class="source-code">    VARIABLES</p>
			<p class="source-code">*/</p>
			<p class="source-code">// Connect to WebSockets server (SocialNetworkConsumer)</p>
			<p class="source-code">const myWebSocket = new WebSocket(`${document.body.dataset.scheme === 'http' ? 'ws' : 'wss'}://${ document.body.dataset.host }/ws/social-network/`);</p>
			<p class="source-code">const inputAuthor = document.querySelector("#message-</p>
			<p class="source-code">     form__author");</p>
			<p class="source-code">const inputText = document.querySelector("#message-  </p>
			<p class="source-code">    form__text");</p>
			<p class="source-code">const inputSubmit = document.querySelector("#message-</p>
			<p class="source-code">    form__submit");</p>
			<p>We use minimal and <a id="_idIndexMarker209"/>essential functions such as sending new<a id="_idIndexMarker210"/> information, showing the form to update, sending information to update, deleting a specific element, and pagination management: </p>
			<p class="source-code">/*</p>
			<p class="source-code">    FUNCTIONS</p>
			<p class="source-code">*/</p>
			<p class="source-code"> </p>
			<p class="source-code">/**</p>
			<p class="source-code">* Send data to WebSockets server</p>
			<p class="source-code">* @param {string} message</p>
			<p class="source-code">* @param {WebSocket} webSocket</p>
			<p class="source-code">* @return {void}</p>
			<p class="source-code">*/</p>
			<p class="source-code">function sendData(message, webSocket) {</p>
			<p class="source-code">    webSocket.send(JSON.stringify(message));</p>
			<p class="source-code">}</p>
			<p class="source-code"> </p>
			<p class="source-code">/**</p>
			<p class="source-code">* Displays the update form</p>
			<p class="source-code">* @param {Event} event</p>
			<p class="source-code">* @return {void}</p>
			<p class="source-code">*/</p>
			<p class="source-code">function displayUpdateForm(event) {</p>
			<p class="source-code">    const message = {</p>
			<p class="source-code">        "action": "open edit page",</p>
			<p class="source-code">        "data": {</p>
			<p class="source-code">            "id": event.target.dataset.id</p>
			<p class="source-code">        }</p>
			<p class="source-code">    };</p>
			<p class="source-code">    sendData(message, myWebSocket);</p>
			<p class="source-code">}</p>
			<p class="source-code"> </p>
			<p class="source-code">/**</p>
			<p class="source-code">* Update message</p>
			<p class="source-code">* @param {Event} event</p>
			<p class="source-code">* @return {void}</p>
			<p class="source-code">*/</p>
			<p class="source-code">function updateMessage(event) {</p>
			<p class="source-code">    event.preventDefault();</p>
			<p class="source-code">    const message = {</p>
			<p class="source-code">        "action": "update message",</p>
			<p class="source-code">        "data": {</p>
			<p class="source-code">            "id": event.target.dataset.id,</p>
			<p class="source-code">            "author": event.target.querySelector("#message-form__author--update"). value,</p>
			<p class="source-code">            "text": event.target.querySelector("#message-form__text--update"). value</p>
			<p class="source-code">        }</p>
			<p class="source-code">    };</p>
			<p class="source-code">    sendData(message, myWebSocket);</p>
			<p class="source-code">}</p>
			<p class="source-code"> </p>
			<p class="source-code">/**</p>
			<p class="source-code">* Delete message</p>
			<p class="source-code">* @param {Event} event</p>
			<p class="source-code">* @return {void}</p>
			<p class="source-code">*/</p>
			<p class="source-code">function deleteMessage(event) {</p>
			<p class="source-code">    const message = {</p>
			<p class="source-code">        "action": "delete message",</p>
			<p class="source-code">        "data": {</p>
			<p class="source-code">            "id": event.target.dataset.id</p>
			<p class="source-code">        }</p>
			<p class="source-code">    };</p>
			<p class="source-code">    sendData(message, myWebSocket);</p>
			<p class="source-code">}</p>
			<p class="source-code"> </p>
			<p class="source-code">/**</p>
			<p class="source-code">* Send new message</p>
			<p class="source-code">* @param {Event} event</p>
			<p class="source-code">* @return {void}</p>
			<p class="source-code">*/</p>
			<p class="source-code">function sendNewMessage(event) {</p>
			<p class="source-code">    event.preventDefault();</p>
			<p class="source-code">    // Prepare the information we will send</p>
			<p class="source-code">    const newData = {</p>
			<p class="source-code">        "action": "add message",</p>
			<p class="source-code">        "data": {</p>
			<p class="source-code">            "author": inputAuthor.value,</p>
			<p class="source-code">            "text": inputText.value</p>
			<p class="source-code">        }</p>
			<p class="source-code">    };</p>
			<p class="source-code">    // Send the data to the server</p>
			<p class="source-code">    sendData(newData, myWebSocket);</p>
			<p class="source-code">    // Clear message form</p>
			<p class="source-code">    inputText.value = "";</p>
			<p class="source-code">}</p>
			<p class="source-code"> </p>
			<p class="source-code"> </p>
			<p class="source-code">/**</p>
			<p class="source-code">* Get current page stored in #paginator as dataset</p>
			<p class="source-code">* @returns {number}</p>
			<p class="source-code">*/</p>
			<p class="source-code"> </p>
			<p class="source-code">function getCurrentPage() {</p>
			<p class="source-code">    return parseInt(document.querySelector("#paginator"). dataset.page);</p>
			<p class="source-code">}</p>
			<p class="source-code"> </p>
			<p class="source-code"> </p>
			<p class="source-code">/**</p>
			<p class="source-code">* Switch to the next page</p>
			<p class="source-code">* @param {Event} event</p>
			<p class="source-code">* @return {void}</p>
			<p class="source-code">*/</p>
			<p class="source-code">function goToNextPage(event) {</p>
			<p class="source-code">    // Prepare the information we will send</p>
			<p class="source-code">    const newData = {</p>
			<p class="source-code">        "action": "list messages",</p>
			<p class="source-code">        "data": {</p>
			<p class="source-code">            "page": getCurrentPage() + 1,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    };</p>
			<p class="source-code">    // Send the data to the server</p>
			<p class="source-code">    sendData(newData, myWebSocket);</p>
			<p class="source-code">}</p>
			<p class="source-code"> </p>
			<p class="source-code"> </p>
			<p class="source-code">/**</p>
			<p class="source-code">* Switch to the previous page</p>
			<p class="source-code">* @param {Event} event</p>
			<p class="source-code">* @return {void}</p>
			<p class="source-code">*/</p>
			<p class="source-code">function goToPreviousPage(event) {</p>
			<p class="source-code">    // Prepare the information we will send</p>
			<p class="source-code">    const newData = {</p>
			<p class="source-code">        "action": "list messages",</p>
			<p class="source-code">        "data": {</p>
			<p class="source-code">            "page": getCurrentPage() - 1,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    };</p>
			<p class="source-code">    // Send the data to the server</p>
			<p class="source-code">    sendData(newData, myWebSocket);</p>
			<p class="source-code">}</p>
			<p class="source-code"> </p>
			<p>The most important <a id="_idIndexMarker211"/>event that receives information from the <a id="_idIndexMarker212"/>backend is "<strong class="source-inline">message</strong>". Every time we receive new data, we print it and recapture all events. Without this constant re-assignment, we would lose all events on every new rendering or redrawing of HTML:</p>
			<p class="source-code">/*</p>
			<p class="source-code">    EVENTS</p>
			<p class="source-code">*/</p>
			<p class="source-code"> </p>
			<p class="source-code">// Event when a new message is received by WebSockets</p>
			<p class="source-code">myWebSocket.addEventListener("message", (event) =&gt; {</p>
			<p class="source-code">    // Parse the data received</p>
			<p class="source-code">    const data = JSON.parse(event.data);</p>
			<p class="source-code">    // Renders the HTML received from the Consumer</p>
			<p class="source-code">    document.querySelector(data.selector). innerHTML = </p>
			<p class="source-code">        data.html;</p>
			<p class="source-code">    /* Reassigns the events of the newly rendered HTML */</p>
			<p class="source-code">    // Pagination</p>
			<p class="source-code">    document.querySelector("#messages__next-page")?. </p>
			<p class="source-code">        addEventListener("click", goToNextPage);</p>
			<p class="source-code">    document.querySelector("#messages__previous-   </p>
			<p class="source-code">        page")?. addEventListener("click", </p>
			<p class="source-code">            goToPreviousPage);</p>
			<p class="source-code">    // Add to all delete buttons the event</p>
			<p class="source-code">    document.querySelectorAll(". messages__delete"). forEach(button =&gt; {</p>
			<p class="source-code">        button.addEventListener("click", deleteMessage);</p>
			<p class="source-code">    });</p>
			<p class="source-code">    // Add to all update buttons the event</p>
			<p class="source-code">    document.querySelectorAll(". messages__update"). forEach(button =&gt; {</p>
			<p class="source-code">        button.addEventListener("click", displayUpdateForm);</p>
			<p class="source-code">    });</p>
			<p class="source-code">    // Add to the update form the event</p>
			<p class="source-code">    document.querySelectorAll(". update-form"). forEach(form =&gt; {</p>
			<p class="source-code">        form.addEventListener("submit", updateMessage);</p>
			<p class="source-code">    });</p>
			<p class="source-code">});</p>
			<p class="source-code"> </p>
			<p class="source-code">// Sends new message when you click on Submit</p>
			<p class="source-code">inputSubmit.addEventListener("click", sendNewMessage);</p>
			<p>All of the preceding<a id="_idIndexMarker213"/> code is the final version of JavaScript:</p>
			<ul>
				<li>The function <strong class="source-inline">displayUpdateForm</strong> has been added to ask the consumer to draw the edit <a id="_idIndexMarker214"/>form in the same place where the message is located.</li>
				<li>The <strong class="source-inline">updateMessage</strong> function has been created to send new information to the consumer in order to update the message.</li>
				<li>Button listeners are included for updating right after the paging and deleting events.</li>
			</ul>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/Figure_4.06_B18321.jpg" alt="Figure 4.6 – The edit form is displayed when you click on edit&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – The edit form is displayed when you click on edit</p>
			<p>We did it! The BREAD is <a id="_idIndexMarker215"/>complete. We can now spread it with butter and <a id="_idIndexMarker216"/>let it be consumed by as many customers as possible. </p>
			<p>Remember to open the exercise with different browsers to appreciate the magic of synchronization. Every action of any user will be visualized by the rest.</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor105"/>Summary</h1>
			<p>We have been able to connect a consumer to a database to manage its information and reply with new rendered HTML structures that we have injected. Gradually, a very basic real-time social network has been built to insert messages, list them, filter them, update them, and delete them. The frontend has a simple role – handling events, sending data, and receiving HTML via WebSockets.</p>
			<p>Currently, there are several limitations related to group discrimination. When an action is performed, it is propagated to all users, meaning all actions have an impact on all visitors at the same time. Basically, that’s a good thing that we want it to happen, but not in all flows. Do I want everyone to update their message listings when a new message is inserted? Yes, of course – and when editing or deleting. Although it should be avoided for certain actions that should be private. At the moment, if one user changes page, everyone changes page. That’s why we are going to delve into the possibilities offered by the Channels Rooms: a mechanism that allows us to send data to a specific client or a group defined by us. With this technique, we can go a step further by incorporating private rooms or information limited to certain customers.</p>
			<p>In the next chapter, we will deal with the different techniques for creating rooms and their optimal management. All the knowledge acquired about a database will help us to create a simple chat that will allow us to maintain private conversations between two clients, restrict groups, or broadcast to all those connected.</p>
		</div>
		<div>
			<div id="_idContainer050">
			</div>
		</div>
	</body></html>