<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Asynchronous Programming</span></h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="koboSpan" id="kobo.2.1">Beside </span><span><span class="koboSpan" id="kobo.3.1">the sequential and parallel execution models, there is a third model that is of fundamental importance together with the concept of</span></span><span class="koboSpan" id="kobo.4.1"> event programming: </span><span><span class="koboSpan" id="kobo.5.1">the</span></span> <span><em><span class="koboSpan" id="kobo.6.1">asynchronous model</span></em><span class="koboSpan" id="kobo.7.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">The execution model of asynchronous tasks can be implemented through a single main control flow, both in single-processor systems and in multiprocessor systems. </span><span class="koboSpan" id="kobo.8.2">In the</span><span><span class="koboSpan" id="kobo.9.1"> </span></span><span class="koboSpan" id="kobo.10.1">concurrent</span><span><span class="koboSpan" id="kobo.11.1"> </span></span><span class="koboSpan" id="kobo.12.1">asynchronous execution model, the executions of various tasks intersect along the timeline, and everything happens under the action of a single flow of control (single-threaded). </span><span class="koboSpan" id="kobo.12.2">O</span><span><span class="koboSpan" id="kobo.13.1">nce started, </span></span><span class="koboSpan" id="kobo.14.1">the execution of tasks can be suspended and then resumed over time, alternating with the execution of other current tasks that are present.</span></p>
<p><span class="koboSpan" id="kobo.15.1">The development of code for the asynchronous model is completely different from that for multithreaded programming. </span><span class="koboSpan" id="kobo.15.2">A substantial difference between the concurrent multithreaded parallel model and the single-threaded concurrent asynchronous model lies in the fact that, in the first case, the OS decides on the timeline if we suspend the activity of one thread and start another.</span></p>
<p><span class="koboSpan" id="kobo.16.1">This remains outside the control of the coder, unlike the asynchronous model. </span><span class="koboSpan" id="kobo.16.2">The execution or termination of a task continues as long as it is explicitly required.</span></p>
<p><span class="koboSpan" id="kobo.17.1">The most important feature of this type of programming is that the code is not performed on multiple threads, as in the classic concurrent programming, but on a single thread. </span><span class="koboSpan" id="kobo.17.2">Thus, it is not at all true that two tasks are executed at the same time, but, according to this approach, they are performed at almost the same time.</span></p>
<p><span class="koboSpan" id="kobo.18.1">In particular, we will describe the </span><kbd><span class="koboSpan" id="kobo.19.1">asyncio</span></kbd><span><em><span class="koboSpan" id="kobo.20.1"> </span></em><span class="koboSpan" id="kobo.21.1">Python module</span></span><span class="koboSpan" id="kobo.22.1">, which was introduced in Python 3.4. </span><span class="koboSpan" id="kobo.22.2">This allows us to use coroutines and futures to make writing asynchronous code easier and to make it more readable.</span></p>
<p><span class="koboSpan" id="kobo.23.1">In this chapter, we will cover the following recipes:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.24.1">Using the </span><kbd><span class="koboSpan" id="kobo.25.1">concurrent.futures</span></kbd><span class="koboSpan" id="kobo.26.1"> Python module</span></li>
<li><span class="koboSpan" id="kobo.27.1">Managing the e</span><span><span class="koboSpan" id="kobo.28.1">vent</span></span> <span><span class="koboSpan" id="kobo.29.1">loop</span></span><span class="koboSpan" id="kobo.30.1"> with </span><kbd><span class="koboSpan" id="kobo.31.1">asyncio</span></kbd></li>
<li><span class="koboSpan" id="kobo.32.1">Handling coroutines with </span><kbd><span class="koboSpan" id="kobo.33.1">asyncio</span></kbd></li>
<li><span class="koboSpan" id="kobo.34.1">Manipulating tasks with </span><kbd><span class="koboSpan" id="kobo.35.1">asyncio</span></kbd></li>
<li><span class="koboSpan" id="kobo.36.1">Dealing with </span><kbd><span class="koboSpan" id="kobo.37.1">asyncio</span></kbd><span class="koboSpan" id="kobo.38.1"> and futures</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Using the concurrent.futures Python module</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">concurrent.futures</span></kbd><span class="koboSpan" id="kobo.4.1"> module, which is part of the standard Python library, provides a level of abstraction on threads by modelling them as asynchronous functions.</span></p>
<p><span class="koboSpan" id="kobo.5.1">This module is built by two main classes:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.6.1">concurrent.futures.Executor</span></kbd><span class="koboSpan" id="kobo.7.1">: </span><span><span class="koboSpan" id="kobo.8.1">This</span></span><span class="koboSpan" id="kobo.9.1"> is an abstract class that provides methods to execute calls asynchronously.</span></li>
<li><kbd><span class="koboSpan" id="kobo.10.1">concurrent.futures.Future</span></kbd><span class="koboSpan" id="kobo.11.1">: </span><span><span class="koboSpan" id="kobo.12.1">This</span></span><span class="koboSpan" id="kobo.13.1"> encapsulates the asynchronous execution of a callable.</span><span><span class="koboSpan" id="kobo.14.1"> </span></span><span class="koboSpan" id="kobo.15.1">Future</span><span><span class="koboSpan" id="kobo.16.1"> </span></span><span class="koboSpan" id="kobo.17.1">objects are instantiated by submitting tasks (functions with optional parameters) to</span><span><span class="koboSpan" id="kobo.18.1"> </span></span><kbd><span class="koboSpan" id="kobo.19.1">Executors</span></kbd><span class="koboSpan" id="kobo.20.1">.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.21.1">Here are some of the main methods of the module:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.22.1">submit(function,argument)</span></kbd><span class="koboSpan" id="kobo.23.1">: </span><span><span class="koboSpan" id="kobo.24.1">This</span></span><span class="koboSpan" id="kobo.25.1"> schedules the execution of the callable function on the arguments.</span></li>
<li><strong><kbd><span class="koboSpan" id="kobo.26.1">map(function,argument)</span></kbd></strong><span class="koboSpan" id="kobo.27.1">: </span><span><span class="koboSpan" id="kobo.28.1">This</span></span><span class="koboSpan" id="kobo.29.1"> executes the functions of arguments in asynchronous mode.</span></li>
<li><kbd><span class="koboSpan" id="kobo.30.1">shutdown(Wait=True)</span></kbd><span class="koboSpan" id="kobo.31.1">: </span><span><span class="koboSpan" id="kobo.32.1">This</span></span><span class="koboSpan" id="kobo.33.1"> signals the executor to free any resource.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.34.1">The executors are accessed through their subclasses: </span><kbd><span class="koboSpan" id="kobo.35.1">ThreadPoolExecutor</span></kbd><span class="koboSpan" id="kobo.36.1"> or </span><kbd><span class="koboSpan" id="kobo.37.1">ProcessPoolExecutor</span></kbd><span class="koboSpan" id="kobo.38.1">. </span><span class="koboSpan" id="kobo.38.2">Because the instantiation of threads and processes is a resource-demanding task, it is better to pool these resources and use them as repeatable launchers or executors (hence the </span><kbd><span class="koboSpan" id="kobo.39.1">Executors</span></kbd><span class="koboSpan" id="kobo.40.1"> concept) for parallel or concurrent tasks.</span></p>
<p><span class="koboSpan" id="kobo.41.1">The approach we are taking here involves using a pool executor. </span><span class="koboSpan" id="kobo.41.2">We will submit the assets to the pool (thread and process) and get the futures, which are the results that will be available to us in the future. </span><span class="koboSpan" id="kobo.41.3">Of course, we can wait for all futures to become real results.</span></p>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p><span class="koboSpan" id="kobo.42.1">A thread or process pool (also called </span><em><span class="koboSpan" id="kobo.43.1">pooling</span></em><span class="koboSpan" id="kobo.44.1">) indicates a management software that is being used to optimize and simplify the use of threads and/or processes within a program. </span><span class="koboSpan" id="kobo.44.2">Through pooling, you can submit the task (or tasks) in order to execute them to the pooler.</span></p>
<p><span class="koboSpan" id="kobo.45.1">The pool is equipped with an internal queue of tasks pending and several threads </span><em><span class="koboSpan" id="kobo.46.1">or</span></em><span class="koboSpan" id="kobo.47.1"> processes that execute them. </span><span class="koboSpan" id="kobo.47.2">A recurring concept in pooling is reusing: a thread (or process) is used several times for different tasks during its life cycle. This decreases the overhead of creating new threads or processes and increases the performance of the program.</span></p>
<p><span class="koboSpan" id="kobo.48.1">Reuse </span><em><span class="koboSpan" id="kobo.49.1">is not a rule</span></em><span class="koboSpan" id="kobo.50.1">, but it is one of the main reasons that lead a coder to use pooling in their application.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">concurrent.futures</span></kbd><span class="koboSpan" id="kobo.4.1"> </span><span><span class="koboSpan" id="kobo.5.1">module </span></span><span class="koboSpan" id="kobo.6.1">provides two subclasses of the </span><kbd><span class="koboSpan" id="kobo.7.1">Executor</span></kbd><span class="koboSpan" id="kobo.8.1"> </span><span><span class="koboSpan" id="kobo.9.1">class,</span></span><span class="koboSpan" id="kobo.10.1"> which </span><span><span class="koboSpan" id="kobo.11.1">asynchronously </span></span><span class="koboSpan" id="kobo.12.1">manipulate a pool of threads and a pool of processes. </span><span class="koboSpan" id="kobo.12.2">The two subclasses are as follows:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.13.1">concurrent.futures.ThreadPoolExecutor(max_workers)</span></kbd></li>
<li><kbd><span class="koboSpan" id="kobo.14.1">concurrent.futures.ProcessPoolExecutor(max_workers)</span></kbd></li>
</ul>
<p><span class="koboSpan" id="kobo.15.1">The </span><kbd><span class="koboSpan" id="kobo.16.1">max_workers</span></kbd> <span><span class="koboSpan" id="kobo.17.1">parameter </span></span><span class="koboSpan" id="kobo.18.1">identifies the maximum number of workers that execute the call asynchronously.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Here is an example of thread and process pool usage, where we will compare the execution time with the time it takes for sequential execution.</span></p>
<p><span class="koboSpan" id="kobo.3.1">The task to be performed is as follows: we have a list of 10 elements. </span><span class="koboSpan" id="kobo.3.2">Each element of the list is made to count up to 100,000,000 (just to waste time), and then the last number is multiplied by the </span><em><span class="koboSpan" id="kobo.4.1">i-th</span></em><span class="koboSpan" id="kobo.5.1"> element of the list. </span><span class="koboSpan" id="kobo.5.2">In particular, we are evaluating the following cases:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.6.1">Sequential execution</span></strong></li>
<li><strong><span class="koboSpan" id="kobo.7.1">Thread pool with five workers</span></strong></li>
<li><strong><span class="koboSpan" id="kobo.8.1">Process pool with </span><span><span class="koboSpan" id="kobo.9.1">five</span></span><span class="koboSpan" id="kobo.10.1"> workers</span></strong></li>
</ul>
<p><span class="koboSpan" id="kobo.11.1">Now, let's look at how to do it:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.12.1">Import the relevant libraries:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.13.1">import concurrent.futures</span><br/><span class="koboSpan" id="kobo.14.1">import time</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.15.1">Define the list of numbers from </span><kbd><span class="koboSpan" id="kobo.16.1">1</span></kbd><span class="koboSpan" id="kobo.17.1"> to </span><kbd><span class="koboSpan" id="kobo.18.1">10</span></kbd><span class="koboSpan" id="kobo.19.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.20.1">number_list = list(range(1, 11))</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.21.1">The </span><kbd><span class="koboSpan" id="kobo.22.1">count(number)</span></kbd><span class="koboSpan" id="kobo.23.1"> function counts the numbers from </span><kbd><span class="koboSpan" id="kobo.24.1">1</span></kbd><span class="koboSpan" id="kobo.25.1"> to </span><kbd><span class="koboSpan" id="kobo.26.1">100000000</span></kbd><span class="koboSpan" id="kobo.27.1">, and then returns the product of </span><kbd><span class="koboSpan" id="kobo.28.1">number</span></kbd><span class="koboSpan" id="kobo.29.1"> × 100,000,000:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.30.1">def count(number):</span><br/><span class="koboSpan" id="kobo.31.1">    for i in range(0,100000000):</span><br/><span class="koboSpan" id="kobo.32.1">        i += 1</span><br/><span class="koboSpan" id="kobo.33.1">    return i*number</span></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.34.1">The </span><kbd><span class="koboSpan" id="kobo.35.1">evaluate(item)</span></kbd><span class="koboSpan" id="kobo.36.1"> function evaluates the </span><kbd><span class="koboSpan" id="kobo.37.1">count</span></kbd><span class="koboSpan" id="kobo.38.1"> function on the </span><kbd><span class="koboSpan" id="kobo.39.1">item</span></kbd><span class="koboSpan" id="kobo.40.1"> parameter. </span><span class="koboSpan" id="kobo.40.2">It prints out the </span><kbd><span class="koboSpan" id="kobo.41.1">item</span></kbd><span class="koboSpan" id="kobo.42.1"> value and the result of </span><kbd><span class="koboSpan" id="kobo.43.1">count(item)</span></kbd><span class="koboSpan" id="kobo.44.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.45.1">def evaluate(item):</span><br/><span class="koboSpan" id="kobo.46.1">    result_item = count(item)</span><br/><span class="koboSpan" id="kobo.47.1">    print('Item %s, result %s' % (item, result_item))</span></pre>
<ol start="5">
<li><span class="koboSpan" id="kobo.48.1">In </span><kbd><span class="koboSpan" id="kobo.49.1">__main__</span></kbd><span class="koboSpan" id="kobo.50.1">, the sequential execution, thread pool, and process pool are executed:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.51.1">if __name__ == '__main__':</span></pre>
<ol start="6">
<li><span class="koboSpan" id="kobo.52.1">For the sequential execution, the </span><kbd><span class="koboSpan" id="kobo.53.1">evaluate</span></kbd><span class="koboSpan" id="kobo.54.1"> function is executed for each item of </span><kbd><span class="koboSpan" id="kobo.55.1">number_list</span></kbd><span class="koboSpan" id="kobo.56.1">. </span><span class="koboSpan" id="kobo.56.2">Then, the execution time is printed out:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.57.1">    start_time = time.clock()</span><br/><span class="koboSpan" id="kobo.58.1">    for item in number_list:</span><br/><span class="koboSpan" id="kobo.59.1">        evaluate(item)</span><br/><span class="koboSpan" id="kobo.60.1">    print('Sequential Execution in %s seconds' % (time.clock() -\ </span><br/><span class="koboSpan" id="kobo.61.1">        start_time))</span></pre>
<ol start="7">
<li><span class="koboSpan" id="kobo.62.1">Regarding thread and process pool execution, the same number of workers (</span><kbd><span class="koboSpan" id="kobo.63.1">max_workers=5</span></kbd><span class="koboSpan" id="kobo.64.1">) is used. </span><span class="koboSpan" id="kobo.64.2">Of course, for both pools, execution times are displayed:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.65.1">    start_time = time.clock()</span><br/><span class="koboSpan" id="kobo.66.1">    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as\ </span><br/><span class="koboSpan" id="kobo.67.1">    executor:</span><br/><span class="koboSpan" id="kobo.68.1">        for item in number_list:</span><br/><span class="koboSpan" id="kobo.69.1">            executor.submit(evaluate, item)</span><br/><span class="koboSpan" id="kobo.70.1">    print('Thread Pool Execution in %s seconds' % (time.clock() -\ </span><br/><span class="koboSpan" id="kobo.71.1">        start_time))</span><br/><span class="koboSpan" id="kobo.72.1">    start_time = time.clock()</span><br/><span class="koboSpan" id="kobo.73.1">    with concurrent.futures.ProcessPoolExecutor(max_workers=5) as\ </span><br/><span class="koboSpan" id="kobo.74.1">    executor:</span><br/><span class="koboSpan" id="kobo.75.1">        for item in number_list:</span><br/><span class="koboSpan" id="kobo.76.1">            executor.submit(evaluate, item)</span><br/><span class="koboSpan" id="kobo.77.1">    print('Process Pool Execution in %s seconds' % (time.clock() -\ </span><br/><span class="koboSpan" id="kobo.78.1">        start_time))</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We build a list of numbers stored in </span><kbd><span class="koboSpan" id="kobo.3.1">number_list</span></kbd><span class="koboSpan" id="kobo.4.1">:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">number_list = list(range(1, 11))</span></pre>
<p><span class="koboSpan" id="kobo.6.1">For each element in the list, we operate the counting procedure until we reach </span><kbd><span class="koboSpan" id="kobo.7.1">100000000</span></kbd><span class="koboSpan" id="kobo.8.1"> iterations, and then multiply the resulting value for </span><kbd><span class="koboSpan" id="kobo.9.1">100000000</span></kbd><span class="koboSpan" id="kobo.10.1">:</span></p>
<pre><span class="koboSpan" id="kobo.11.1">def count(number) : </span><br/><span class="koboSpan" id="kobo.12.1">    for i in range(0, 100000000):</span><br/><span class="koboSpan" id="kobo.13.1">        i=i+1</span><br/><span class="koboSpan" id="kobo.14.1">    return i*number</span><br/><br/><span class="koboSpan" id="kobo.15.1">def evaluate_item(x):</span><br/><span class="koboSpan" id="kobo.16.1">    result_item = count(x)</span></pre>
<p><span class="koboSpan" id="kobo.17.1">In the </span><kbd><span class="koboSpan" id="kobo.18.1">main</span></kbd><span class="koboSpan" id="kobo.19.1"> program, we execute the same task in sequential mode:</span></p>
<pre><span class="koboSpan" id="kobo.20.1">if __name__ == "__main__":</span><br/><span class="koboSpan" id="kobo.21.1">   for item in number_list:</span><br/><span class="koboSpan" id="kobo.22.1">       evaluate_item(item)</span></pre>
<p><span class="koboSpan" id="kobo.23.1">Then, in parallel mode, use the </span><kbd><span class="koboSpan" id="kobo.24.1">concurrent.futures</span></kbd><span class="koboSpan" id="kobo.25.1"> pooling capabilities for a thread pool: </span></p>
<pre><span class="koboSpan" id="kobo.26.1">with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:</span><br/><span class="koboSpan" id="kobo.27.1">    for item in number_list:</span><br/><span class="koboSpan" id="kobo.28.1">        executor.submit(evaluate, item)</span></pre>
<p><span><span class="koboSpan" id="kobo.29.1">And do the same for a process pool: </span></span><span class="koboSpan" id="kobo.30.1"> </span></p>
<pre><span class="koboSpan" id="kobo.31.1">with concurrent.futures.ProcessPoolExecutor(max_workers=5) as executor:</span><br/><span class="koboSpan" id="kobo.32.1">    for item in number_list:</span><br/><span class="koboSpan" id="kobo.33.1">        executor.submit(evaluate, item)</span></pre>
<div class="packt_tip"><span class="koboSpan" id="kobo.34.1">Note that </span><span><span class="koboSpan" id="kobo.35.1">both</span></span><span class="koboSpan" id="kobo.36.1"> the thread </span><em><span class="koboSpan" id="kobo.37.1">and</span></em><span class="koboSpan" id="kobo.38.1"> process pools are set with </span><kbd><span class="koboSpan" id="kobo.39.1">max_workers=5</span></kbd><span class="koboSpan" id="kobo.40.1">; moreover, if </span><kbd><span class="koboSpan" id="kobo.41.1">max_workers</span></kbd><span class="koboSpan" id="kobo.42.1"> is equal to </span><kbd><span class="koboSpan" id="kobo.43.1">None</span></kbd><span class="koboSpan" id="kobo.44.1">, it will default to the number of processors on the machine.</span></div>
<p><span class="koboSpan" id="kobo.45.1">To run this example, open Command Prompt and, in the same folder where the example is contained, type the following:</span></p>
<pre><strong><span class="koboSpan" id="kobo.46.1">&gt; python concurrent_futures_pooling.py</span></strong></pre>
<p><span class="koboSpan" id="kobo.47.1">By executing the preceding example, we can see the execution of the three execution models with relative times:</span></p>
<pre><strong><span class="koboSpan" id="kobo.48.1">Item 1, result 10000000</span></strong><br/><strong><span class="koboSpan" id="kobo.49.1">Item 2, result 20000000</span></strong><br/><strong><span class="koboSpan" id="kobo.50.1">Item 3, result 30000000</span></strong><br/><strong><span class="koboSpan" id="kobo.51.1">Item 4, result 40000000</span></strong><br/><strong><span class="koboSpan" id="kobo.52.1">Item 5, result 50000000</span></strong><br/><strong><span class="koboSpan" id="kobo.53.1">Item 6, result 60000000</span></strong><br/><strong><span class="koboSpan" id="kobo.54.1">Item 7, result 70000000</span></strong><br/><strong><span class="koboSpan" id="kobo.55.1">Item 8, result 80000000</span></strong><br/><strong><span class="koboSpan" id="kobo.56.1">Item 9, result 90000000</span></strong><br/><strong><span class="koboSpan" id="kobo.57.1">Item 10, result 100000000</span></strong><br/><strong><span class="koboSpan" id="kobo.58.1">Sequential Execution in 6.8109448 seconds</span></strong><br/><strong><span class="koboSpan" id="kobo.59.1">Item 2, result 20000000</span></strong><br/><strong><span class="koboSpan" id="kobo.60.1">Item 1, result 10000000</span></strong><br/><strong><span class="koboSpan" id="kobo.61.1">Item 4, result 40000000</span></strong><br/><strong><span class="koboSpan" id="kobo.62.1">Item 5, result 50000000</span></strong><br/><strong><span class="koboSpan" id="kobo.63.1">Item 3, result 30000000</span></strong><br/><strong><span class="koboSpan" id="kobo.64.1">Item 8, result 80000000</span></strong><br/><strong><span class="koboSpan" id="kobo.65.1">Item 7, result 70000000</span></strong><br/><strong><span class="koboSpan" id="kobo.66.1">Item 6, result 60000000</span></strong><br/><strong><span class="koboSpan" id="kobo.67.1">Item 10, result 100000000</span></strong><br/><strong><span class="koboSpan" id="kobo.68.1">Item 9, result 90000000</span></strong><br/><strong><span class="koboSpan" id="kobo.69.1">Thread Pool Execution in 6.805766899999999 seconds</span></strong><br/><strong><span class="koboSpan" id="kobo.70.1">Item 1, result 10000000</span></strong><br/><strong><span class="koboSpan" id="kobo.71.1">Item 4, result 40000000</span></strong><br/><strong><span class="koboSpan" id="kobo.72.1">Item 2, result 20000000</span></strong><br/><strong><span class="koboSpan" id="kobo.73.1">Item 3, result 30000000</span></strong><br/><strong><span class="koboSpan" id="kobo.74.1">Item 5, result 50000000</span></strong><br/><strong><span class="koboSpan" id="kobo.75.1">Item 6, result 60000000</span></strong><br/><strong><span class="koboSpan" id="kobo.76.1">Item 7, result 70000000</span></strong><br/><strong><span class="koboSpan" id="kobo.77.1">Item 9, result 90000000</span></strong><br/><strong><span class="koboSpan" id="kobo.78.1">Item 8, result 80000000</span></strong><br/><strong><span class="koboSpan" id="kobo.79.1">Item 10, result 100000000</span></strong><br/><strong><span class="koboSpan" id="kobo.80.1">Process Pool Execution in 4.166398899999999 seconds</span></strong></pre>
<p><span class="koboSpan" id="kobo.81.1">It should be noted that although the example is not expensive in computational terms, sequential and thread pool execution are comparable in terms of time. </span><span class="koboSpan" id="kobo.81.2">Using a process pool gives us the </span><span><span class="koboSpan" id="kobo.82.1">fastest execution time. </span></span></p>
<p><span class="koboSpan" id="kobo.83.1">The pool then distributes the processes (in this case, five processes) between the available cores (for this example, a machine with four cores was used) in </span><strong><span class="koboSpan" id="kobo.84.1">FIFO</span></strong><span class="koboSpan" id="kobo.85.1"> (short for </span><strong><span><span class="koboSpan" id="kobo.86.1">first in</span></span><span><span class="koboSpan" id="kobo.87.1">,</span></span> <span><span class="koboSpan" id="kobo.88.1">first out</span></span></strong><span class="koboSpan" id="kobo.89.1">) mode.</span></p>
<p><span class="koboSpan" id="kobo.90.1">So, for each core, the assigned process runs in series. </span><span class="koboSpan" id="kobo.90.2">Only after the I/O operation is performed does the pool schedule the execution of another process. Of course, the execution mechanism is the same if you use a thread pool.</span></p>
<p><span class="koboSpan" id="kobo.91.1">The computational times, which are lower in the case of the process pool, must be traced back to the fact that I/O operations are not significant. </span><span class="koboSpan" id="kobo.91.2">This allows the pool of processes to be faster because, unlike threads, they do not require any synchronization mechanisms (as explained in </span><a href="64fc65f9-fe29-4c34-9da7-13f272eaab9e.xhtml"><span class="koboSpan" id="kobo.92.1">Chapter 1</span></a><span class="koboSpan" id="kobo.93.1">, </span><em><span class="koboSpan" id="kobo.94.1">Getting Started with Parallel Computing and Python</span></em><span class="koboSpan" id="kobo.95.1">, in the </span><em><span class="koboSpan" id="kobo.96.1">Introducing parallel programming</span></em><span class="koboSpan" id="kobo.97.1"> recipe).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="koboSpan" id="kobo.2.1">The pooling technique is widely used in server applications, as it is necessary to manage multiple simultaneous requests from any number of clients.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Many other applications, however, require that every activity be performed immediately or that you have more control over the thread that runs it: in this case, pooling is not the best choice.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">See also</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">An interesting tutorial on </span><kbd><span class="koboSpan" id="kobo.3.1">concurrent.futures</span></kbd><span class="koboSpan" id="kobo.4.1"> can be found here: </span><a href="http://masnun.com/2016/03/29/python-a-quick-introduction-to-the-concurrent-futures-module.html"><span class="koboSpan" id="kobo.5.1">http://masnun.com/2016/03/29/python-a-quick-introduction-to-the-concurrent-futures-module.html</span></a><span class="koboSpan" id="kobo.6.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Managing the event loop with asyncio</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">asyncio</span></kbd> <span><span class="koboSpan" id="kobo.4.1">Python module </span></span><span class="koboSpan" id="kobo.5.1">provides facilities for managing events, coroutines, tasks, as well as threads, and synchronization primitives for writing concurrent code.</span></p>
<p><span class="koboSpan" id="kobo.6.1">The main components of this module are as follows:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.7.1">Event loop</span></strong><span class="koboSpan" id="kobo.8.1">: The </span><kbd><span class="koboSpan" id="kobo.9.1">asyncio</span></kbd><span class="koboSpan" id="kobo.10.1"> module allows one event loop per process. </span><span class="koboSpan" id="kobo.10.2">This is the entity that deals with managing and distributing the execution of different tasks. </span><span class="koboSpan" id="kobo.10.3">In particular, t</span><span><span class="koboSpan" id="kobo.11.1">his</span></span><span class="koboSpan" id="kobo.12.1"> registers the tasks and manages them by switching the control flow from one task to another.</span></li>
<li><strong><span class="koboSpan" id="kobo.13.1">Coroutines</span></strong><span class="koboSpan" id="kobo.14.1">: </span><span><span class="koboSpan" id="kobo.15.1">This</span></span><span class="koboSpan" id="kobo.16.1"> is a generalization of the concept of the subroutine. </span><span class="koboSpan" id="kobo.16.2">Also, a coroutine can be suspended during execution to wait for external processing (some routine in I/O) and return from the point it had stopped at when the external processing is done.</span></li>
<li><strong><span class="koboSpan" id="kobo.17.1">Futures</span></strong><span class="koboSpan" id="kobo.18.1">: </span><span><span class="koboSpan" id="kobo.19.1">This</span></span><span class="koboSpan" id="kobo.20.1"> defines the </span><kbd><span class="koboSpan" id="kobo.21.1">Future</span></kbd> <span><span class="koboSpan" id="kobo.22.1">object </span></span><span class="koboSpan" id="kobo.23.1">exactly like the </span><kbd><span class="koboSpan" id="kobo.24.1">concurrent.futures</span></kbd><span class="koboSpan" id="kobo.25.1"> module. </span><span class="koboSpan" id="kobo.25.2">It represents a computation that </span><em><span class="koboSpan" id="kobo.26.1">has still not been accomplished</span></em><span class="koboSpan" id="kobo.27.1">.</span></li>
<li><strong><span class="koboSpan" id="kobo.28.1">Tasks</span></strong><span class="koboSpan" id="kobo.29.1">: </span><span><span class="koboSpan" id="kobo.30.1">This</span></span><span class="koboSpan" id="kobo.31.1"> is a subclass of </span><kbd><span class="koboSpan" id="kobo.32.1">asyncio</span></kbd><span class="koboSpan" id="kobo.33.1"> that is used to encapsulate and manage coroutines in a parallel mode.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.34.1">In this recipe, the focus is on the concept of events</span><em><span class="koboSpan" id="kobo.35.1"> </span></em><span class="koboSpan" id="kobo.36.1">and event management (namely, event loops) within a software program.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Understanding event loops</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In computer science, an </span><em><span class="koboSpan" id="kobo.3.1">event </span></em><span class="koboSpan" id="kobo.4.1">is an action intercepted by the program that can be managed by the program itself. </span><span class="koboSpan" id="kobo.4.2">As an example, an event could be the virtual pressure of a key by the user during interaction with the graphical interface, the pressure of a key on the physical keyboard, an external interrupt signal, or, more abstractly, the reception of data through the network. </span><span class="koboSpan" id="kobo.4.3">But more generally, any other form of event that has happened that can be detected and managed in some way.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Within a system, the entity that can generate events is called an </span><em><span class="koboSpan" id="kobo.6.1">event source</span></em><span class="koboSpan" id="kobo.7.1">, while the entity that deals with handling an event that occurs are an event handler.</span></p>
<p><span class="koboSpan" id="kobo.8.1">The </span><em><span class="koboSpan" id="kobo.9.1">event loop</span></em><span class="koboSpan" id="kobo.10.1"> programming construct realizes the functionality of managing events within a program. </span><span class="koboSpan" id="kobo.10.2">More precisely, the event loop acts cyclically during the whole execution of the program, keeping track of events that have occurred within a data structure to queue and then process them one at a time by invoking the event handler if the main thread is free.</span></p>
<p><span class="koboSpan" id="kobo.11.1">The pseudocode of the event loop manager is shown here:</span></p>
<pre><span class="koboSpan" id="kobo.12.1">while (1) {</span><br/><span class="koboSpan" id="kobo.13.1">    events = getEvents()</span><br/><span class="koboSpan" id="kobo.14.1">    for (e in events)</span><br/><span class="koboSpan" id="kobo.15.1">        processEvent(e)</span><br/><span class="koboSpan" id="kobo.16.1">}</span></pre>
<p><span class="koboSpan" id="kobo.17.1">All the events that are fed into the </span><kbd><span class="koboSpan" id="kobo.18.1">while</span></kbd><span class="koboSpan" id="kobo.19.1"> loop are caught and then processed by the event handler. </span><span class="koboSpan" id="kobo.19.2">The handler that processes an event is the only activity taking place in the system. </span><span class="koboSpan" id="kobo.19.3">When the handler has ended, control passes to the next event scheduled.</span></p>
<p><kbd><span class="koboSpan" id="kobo.20.1">asyncio</span></kbd><span class="koboSpan" id="kobo.21.1"> provides the following methods to manage an event loop:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.22.1">loop = get_event_loop()</span></kbd><span class="koboSpan" id="kobo.23.1">: This gets the event loop for the current context.</span></li>
<li><kbd><span class="koboSpan" id="kobo.24.1">loop.call_later(time_delay,callback,argument)</span></kbd><span class="koboSpan" id="kobo.25.1">: This arranges for the callback to be called after the given </span><kbd><span class="koboSpan" id="kobo.26.1">time_delay</span></kbd><span class="koboSpan" id="kobo.27.1">, in seconds.</span></li>
<li><kbd><span class="koboSpan" id="kobo.28.1">loop.call_soon(callback, argument)</span></kbd><span class="koboSpan" id="kobo.29.1">: This arranges for a callback to be called as soon as possible. </span><span class="koboSpan" id="kobo.29.2">The callback is called after </span><kbd><span class="koboSpan" id="kobo.30.1">call_soon()</span></kbd><span class="koboSpan" id="kobo.31.1"> (</span><a href="https://docs.python.org/3/library/asyncio-eventloop.html"><span class="koboSpan" id="kobo.32.1">https://docs.python.org/3/library/asyncio-eventloop.html</span></a><span class="koboSpan" id="kobo.33.1">) returns when control returns to the event loop.</span></li>
<li><kbd><span class="koboSpan" id="kobo.34.1">loop.time()</span></kbd><span class="koboSpan" id="kobo.35.1">: This returns the current time as a </span><kbd><span class="koboSpan" id="kobo.36.1">float</span></kbd><span class="koboSpan" id="kobo.37.1"> </span><span><span class="koboSpan" id="kobo.38.1">value </span></span><span class="koboSpan" id="kobo.39.1">(</span><a href="https://docs.python.org/3/library/functions.html"><span class="koboSpan" id="kobo.40.1">https://docs.python.org/3/library/functions.html</span></a><span class="koboSpan" id="kobo.41.1">), according to the event loop's internal clock.</span></li>
<li><kbd><span class="koboSpan" id="kobo.42.1">asyncio.set_event_loop()</span></kbd><span class="koboSpan" id="kobo.43.1">: This sets the event loop for the current context to loop.</span></li>
<li><kbd><span class="koboSpan" id="kobo.44.1">asyncio.new_event_loop()</span></kbd><span class="koboSpan" id="kobo.45.1">: This creates and returns a new event loop object according to this policy's rules.</span></li>
<li><kbd><span class="koboSpan" id="kobo.46.1">loop.run_forever()</span></kbd><span class="koboSpan" id="kobo.47.1">: This runs until </span><kbd><span class="koboSpan" id="kobo.48.1">stop()</span></kbd><span class="koboSpan" id="kobo.49.1"> (</span><a href="https://docs.python.org/3/library/asyncio-eventloop.html"><span class="koboSpan" id="kobo.50.1">https://docs.python.org/3/library/asyncio-eventloop.html</span></a><span class="koboSpan" id="kobo.51.1">) is called.</span></li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this example, we look at how to use the event loop statements provided by the </span><kbd><span class="koboSpan" id="kobo.3.1">asyncio</span></kbd><span><span class="koboSpan" id="kobo.4.1"> </span></span><span class="koboSpan" id="kobo.5.1">library, in order to build an application that works in asynchronous mode. </span></p>
<p><span class="koboSpan" id="kobo.6.1">In this example, we defined three tasks. </span><span class="koboSpan" id="kobo.6.2">Each task has an execution time determined by a time random parameter. </span><span class="koboSpan" id="kobo.6.3">Once the execution is finished, </span><strong><span class="koboSpan" id="kobo.7.1">Task A</span></strong><span class="koboSpan" id="kobo.8.1"> calls </span><strong><span class="koboSpan" id="kobo.9.1">Task B</span></strong><span class="koboSpan" id="kobo.10.1">, </span><strong><span class="koboSpan" id="kobo.11.1">Task B</span></strong><span class="koboSpan" id="kobo.12.1"> calls </span><strong><span class="koboSpan" id="kobo.13.1">Task C</span></strong><span class="koboSpan" id="kobo.14.1">, and </span><strong><span class="koboSpan" id="kobo.15.1">Task C</span></strong><span class="koboSpan" id="kobo.16.1"> calls </span><strong><span class="koboSpan" id="kobo.17.1">Task A</span></strong><span class="koboSpan" id="kobo.18.1">.</span></p>
<p><span class="koboSpan" id="kobo.19.1">The event loop will continue until a termination condition is met. </span><span class="koboSpan" id="kobo.19.2">As we can imagine, this example follows this asynchronous schema:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.20.1"><img src="assets/49fee3e4-437a-47a5-b656-1ecf755cf488.png"/></span></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><span><span class="koboSpan" id="kobo.21.1"> Asynchronous programming model</span></span></div>
<p><span class="koboSpan" id="kobo.22.1">Let's have a look at the following steps:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.23.1">Let's start by importing the libraries needed for our implementation:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.24.1">import asyncio</span><br/><span class="koboSpan" id="kobo.25.1">import time</span><br/><span class="koboSpan" id="kobo.26.1">import random</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.27.1">Then, we define </span><kbd><span class="koboSpan" id="kobo.28.1">task_A</span></kbd><span class="koboSpan" id="kobo.29.1">, whose execution time is determined randomly and can vary from </span><kbd><span class="koboSpan" id="kobo.30.1">1</span></kbd><span class="koboSpan" id="kobo.31.1"> to </span><kbd><span class="koboSpan" id="kobo.32.1">5</span></kbd><span class="koboSpan" id="kobo.33.1"> seconds. </span><span class="koboSpan" id="kobo.33.2">At the end of the execution, if the termination condition is not satisfied, then the computation goes to </span><kbd><span class="koboSpan" id="kobo.34.1">task_B</span></kbd><span class="koboSpan" id="kobo.35.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.36.1">def task_A(end_time, loop):</span><br/><span class="koboSpan" id="kobo.37.1">    print ("task_A called")</span><br/><span class="koboSpan" id="kobo.38.1">    time.sleep(random.randint(0, 5))</span><br/><span class="koboSpan" id="kobo.39.1">    if (loop.time() + 1.0) &lt; end_time:</span><br/><span class="koboSpan" id="kobo.40.1">        loop.call_later(1, task_B, end_time, loop)</span><br/><span class="koboSpan" id="kobo.41.1">    else:</span><br/><span class="koboSpan" id="kobo.42.1">        loop.stop()</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="3">
<li><span class="koboSpan" id="kobo.43.1">Here, </span><kbd><span class="koboSpan" id="kobo.44.1">task_B</span></kbd><span class="koboSpan" id="kobo.45.1"> is defined. </span><span><span class="koboSpan" id="kobo.46.1">Its execution time is determined randomly and can vary from</span></span> <kbd><span class="koboSpan" id="kobo.47.1">4</span></kbd><span class="koboSpan" id="kobo.48.1"> </span><span><span class="koboSpan" id="kobo.49.1">to</span></span> <kbd><span class="koboSpan" id="kobo.50.1">7</span></kbd><span class="koboSpan" id="kobo.51.1"> seconds. </span><span class="koboSpan" id="kobo.51.2">At the end of the execution, if the termination condition is not satisfied, then the computation goes to </span><kbd><span class="koboSpan" id="kobo.52.1">task_B</span></kbd><span class="koboSpan" id="kobo.53.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.54.1">def task_B(end_time, loop):</span><br/><span class="koboSpan" id="kobo.55.1">    print ("task_B called ")</span><br/><span class="koboSpan" id="kobo.56.1">    time.sleep(random.randint(3, 7))</span><br/><span class="koboSpan" id="kobo.57.1">    if (loop.time() + 1.0) &lt; end_time:</span><br/><span class="koboSpan" id="kobo.58.1">        loop.call_later(1, task_C, end_time, loop)</span><br/><span class="koboSpan" id="kobo.59.1">    else:</span><br/><span class="koboSpan" id="kobo.60.1">        loop.stop()</span></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.61.1">Then, </span><kbd><span class="koboSpan" id="kobo.62.1">task_C</span></kbd><span class="koboSpan" id="kobo.63.1"> is implemented. </span><span class="koboSpan" id="kobo.63.2">Its execution time is determined randomly and can vary from </span><kbd><span class="koboSpan" id="kobo.64.1">6</span></kbd><span class="koboSpan" id="kobo.65.1"> to </span><kbd><span class="koboSpan" id="kobo.66.1">10</span></kbd><span class="koboSpan" id="kobo.67.1"> seconds. </span><span class="koboSpan" id="kobo.67.2">At the end of the execution, if the termination condition is not satisfied, then the computation goes back to </span><kbd><span class="koboSpan" id="kobo.68.1">task_A</span></kbd><span class="koboSpan" id="kobo.69.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.70.1">def task_C(end_time, loop):</span><br/><span class="koboSpan" id="kobo.71.1">    print ("task_C called")</span><br/><span class="koboSpan" id="kobo.72.1">    time.sleep(random.randint(5, 10))</span><br/><span class="koboSpan" id="kobo.73.1">    if (loop.time() + 1.0) &lt; end_time:</span><br/><span class="koboSpan" id="kobo.74.1">        loop.call_later(1, task_A, end_time, loop)</span><br/><span class="koboSpan" id="kobo.75.1">    else:</span><br/><span class="koboSpan" id="kobo.76.1">        loop.stop()</span></pre>
<ol start="5">
<li><span class="koboSpan" id="kobo.77.1">The next statement defines the </span><kbd><span class="koboSpan" id="kobo.78.1">loop</span></kbd><span class="koboSpan" id="kobo.79.1"> parameter, which simply gets the current event loop:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.80.1">loop = asyncio.get_event_loop()</span></pre>
<ol start="6">
<li><span class="koboSpan" id="kobo.81.1">The </span><kbd><span class="koboSpan" id="kobo.82.1">end_loop</span></kbd><span class="koboSpan" id="kobo.83.1"> value defines the termination condition. </span><span class="koboSpan" id="kobo.83.2">The execution of this example code must last </span><kbd><span class="koboSpan" id="kobo.84.1">60</span></kbd><span class="koboSpan" id="kobo.85.1"> seconds:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.86.1">end_loop = loop.time() + 60</span></pre>
<ol start="7">
<li><span class="koboSpan" id="kobo.87.1">Then, let's request the execution of </span><kbd><span class="koboSpan" id="kobo.88.1">task_A</span></kbd><span class="koboSpan" id="kobo.89.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.90.1">loop.call_soon(task_A, end_loop, loop)</span></pre>
<ol start="8">
<li><span class="koboSpan" id="kobo.91.1">Now, we set a long duration cycle that continues to respond to events until it is stopped:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.92.1">loop.run_forever()</span></pre>
<ol start="9">
<li><span class="koboSpan" id="kobo.93.1">Now, close the event loop:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.94.1">loop.close()</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In order to manage the execution of the three tasks, </span><kbd><span class="koboSpan" id="kobo.3.1">task_A</span></kbd><span class="koboSpan" id="kobo.4.1">, </span><kbd><span class="koboSpan" id="kobo.5.1">task_B</span></kbd><span class="koboSpan" id="kobo.6.1">, and </span><kbd><span class="koboSpan" id="kobo.7.1">task_C</span></kbd><span class="koboSpan" id="kobo.8.1">, we need to capture the event loop:</span></p>
<pre><span class="koboSpan" id="kobo.9.1">loop = asyncio.get_event_loop()</span></pre>
<p><span class="koboSpan" id="kobo.10.1">Then, we schedule the first call to </span><kbd><span class="koboSpan" id="kobo.11.1">task_A</span></kbd><span class="koboSpan" id="kobo.12.1"> by using the </span><kbd><span class="koboSpan" id="kobo.13.1">call_soon</span></kbd><span class="koboSpan" id="kobo.14.1"> </span><span><span class="koboSpan" id="kobo.15.1">construct:</span></span></p>
<pre><span class="koboSpan" id="kobo.16.1">end_loop = loop.time() + 60</span><br/><span class="koboSpan" id="kobo.17.1">loop.call_soon(function_1, end_loop, loop)</span></pre>
<p><span class="koboSpan" id="kobo.18.1">Let's note the definition of </span><kbd><span class="koboSpan" id="kobo.19.1">task_A</span></kbd><span class="koboSpan" id="kobo.20.1">:</span></p>
<pre><span class="koboSpan" id="kobo.21.1">def task_A(end_time, loop):</span><br/><span class="koboSpan" id="kobo.22.1">    print ("task_A called")</span><br/><span class="koboSpan" id="kobo.23.1">    time.sleep(random.randint(0, 5))</span><br/><span class="koboSpan" id="kobo.24.1">    if (loop.time() + 1.0) &lt; end_time:</span><br/><span class="koboSpan" id="kobo.25.1">        loop.call_later(1, task_B, end_time, loop)</span><br/><span class="koboSpan" id="kobo.26.1">    else:</span><br/><span class="koboSpan" id="kobo.27.1">        loop.stop()</span></pre>
<p><span class="koboSpan" id="kobo.28.1">The asynchronous behavior of the application is determined by the following parameters:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.29.1">time.sleep(random.randint(0, 5))</span></kbd><span class="koboSpan" id="kobo.30.1">: This defines the duration time of the task execution.</span></li>
<li><kbd><span class="koboSpan" id="kobo.31.1">end_time</span></kbd><span class="koboSpan" id="kobo.32.1">: </span><span><span class="koboSpan" id="kobo.33.1">This</span></span><span class="koboSpan" id="kobo.34.1"> defines the upper time limit within </span><kbd><span class="koboSpan" id="kobo.35.1">task_A</span></kbd><span class="koboSpan" id="kobo.36.1"> and makes the call to </span><kbd><span class="koboSpan" id="kobo.37.1">task_B</span></kbd><span class="koboSpan" id="kobo.38.1"> through the </span><kbd><span class="koboSpan" id="kobo.39.1">call_later</span></kbd><span><span class="koboSpan" id="kobo.40.1"> method.</span></span></li>
<li><kbd><span class="koboSpan" id="kobo.41.1">loop</span></kbd><span class="koboSpan" id="kobo.42.1">: This is the event loop captured previously with the </span><kbd><span class="koboSpan" id="kobo.43.1">get_event_loop()</span></kbd><span class="koboSpan" id="kobo.44.1"> method.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.45.1">After executing the task, </span><kbd><span class="koboSpan" id="kobo.46.1">loop.time</span></kbd><span class="koboSpan" id="kobo.47.1"> is compared to </span><kbd><span class="koboSpan" id="kobo.48.1">end_time</span></kbd><span class="koboSpan" id="kobo.49.1">. </span><span class="koboSpan" id="kobo.49.2">If the execution time is within the maximum time (60 seconds), then the computation continues by calling </span><kbd><span class="koboSpan" id="kobo.50.1">task_B</span></kbd><span class="koboSpan" id="kobo.51.1">, otherwise, the computation ends, closing the event loop:</span></p>
<pre><span class="koboSpan" id="kobo.52.1"> if (loop.time() + 1.0) &lt; end_time:</span><br/><span class="koboSpan" id="kobo.53.1">        loop.call_later(1, task_B, end_time, loop)</span><br/><span class="koboSpan" id="kobo.54.1">    else:</span><br/><span class="koboSpan" id="kobo.55.1">        loop.stop()</span></pre>
<p><span class="koboSpan" id="kobo.56.1">For the other two tasks, the operations are practically the same, but only the execution time and the call to the next task </span><span><span class="koboSpan" id="kobo.57.1">vary</span></span><span class="koboSpan" id="kobo.58.1">.</span></p>
<p><span class="koboSpan" id="kobo.59.1">Now, let me summarize the situation:</span></p>
<ol>
<li><kbd><span class="koboSpan" id="kobo.60.1">task_A</span></kbd><span class="koboSpan" id="kobo.61.1"> calls </span><kbd><span class="koboSpan" id="kobo.62.1">task_B</span></kbd><span class="koboSpan" id="kobo.63.1"> with a random execution time between 1 </span><span><span class="koboSpan" id="kobo.64.1">and</span></span><span class="koboSpan" id="kobo.65.1"> 5 seconds.</span></li>
<li><kbd><span class="koboSpan" id="kobo.66.1">task_B</span></kbd><span class="koboSpan" id="kobo.67.1"> calls </span><kbd><span class="koboSpan" id="kobo.68.1">task_C</span></kbd><span class="koboSpan" id="kobo.69.1"> with a random execution time </span><span><span class="koboSpan" id="kobo.70.1">between</span></span><span class="koboSpan" id="kobo.71.1"> 4 </span><span><span class="koboSpan" id="kobo.72.1">and</span></span><span class="koboSpan" id="kobo.73.1"> 7 seconds.</span></li>
<li><kbd><span class="koboSpan" id="kobo.74.1">task_C</span></kbd><span class="koboSpan" id="kobo.75.1"> calls </span><kbd><span class="koboSpan" id="kobo.76.1">task_A</span></kbd><span class="koboSpan" id="kobo.77.1"> with a random execution time between 6 and 10 s</span><span><span class="koboSpan" id="kobo.78.1">econds</span></span><span class="koboSpan" id="kobo.79.1">.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.80.1">When the running time expires, the event loop must end:</span></p>
<pre><span class="koboSpan" id="kobo.81.1">loop.run_forever()</span><br/><span class="koboSpan" id="kobo.82.1">loop.close()</span></pre>
<p><span class="koboSpan" id="kobo.83.1">A possible output of this example would be the following:</span></p>
<pre><strong><span class="koboSpan" id="kobo.84.1">task_A called</span></strong><br/><strong><span class="koboSpan" id="kobo.85.1">task_B called </span></strong><br/><strong><span class="koboSpan" id="kobo.86.1">task_C called</span></strong><br/><strong><span class="koboSpan" id="kobo.87.1">task_A called</span></strong><br/><strong><span class="koboSpan" id="kobo.88.1">task_B called </span></strong><br/><strong><span class="koboSpan" id="kobo.89.1">task_C called</span></strong><br/><strong><span class="koboSpan" id="kobo.90.1">task_A called</span></strong><br/><strong><span class="koboSpan" id="kobo.91.1">task_B called </span></strong><br/><strong><span class="koboSpan" id="kobo.92.1">task_C called</span></strong><br/><strong><span class="koboSpan" id="kobo.93.1">task_A called</span></strong><br/><strong><span class="koboSpan" id="kobo.94.1">task_B called </span></strong><br/><strong><span class="koboSpan" id="kobo.95.1">task_C called</span></strong><br/><strong><span class="koboSpan" id="kobo.96.1">task_A called</span></strong><br/><strong><span class="koboSpan" id="kobo.97.1">task_B called </span></strong><br/><strong><span class="koboSpan" id="kobo.98.1">task_C called</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Asynchronous event programming replaces a type of concurrent programming in which several parts of the program are executed simultaneously by different threads that have access to the same data in memory, thus giving rise to the problem of critical runs. </span><span class="koboSpan" id="kobo.2.2">At the same time, it has become essential to be able to exploit the different cores of modern CPUs because, in certain areas, performance similar to that made available by the latter can no longer be achieved with a single-core processor.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">See also</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Here is a good introduction to </span><kbd><span class="koboSpan" id="kobo.3.1">asyncio</span></kbd><span class="koboSpan" id="kobo.4.1">: </span><a href="https://hackernoon.com/a-simple-introduction-to-pythons-asyncio-595d9c9ecf8c"><span class="koboSpan" id="kobo.5.1">https://hackernoon.com/a-simple-introduction-to-pythons-asyncio-595d9c9ecf8c</span></a><span class="koboSpan" id="kobo.6.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Handling coroutines with asyncio</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Throughout the various examples presented, we have seen that when a program becomes very long and complex, it is convenient to divide it into subroutines, each of which implements a specific task. </span><span class="koboSpan" id="kobo.2.2">However, subroutines cannot be executed independently, but only at the request of the main program, which is responsible for coordinating the use of subroutines.</span></p>
<p><span class="koboSpan" id="kobo.3.1">In this section, we introduce a generalization of the concept of subroutines, known as coroutines: just like subroutines, coroutines compute a single computational step, but unlike subroutines, there is no </span><kbd><span class="koboSpan" id="kobo.4.1">main</span></kbd><span class="koboSpan" id="kobo.5.1"> program to coordinate the results. </span><span class="koboSpan" id="kobo.5.2">The coroutines link themselves together to form a pipeline without any supervising function responsible for calling them in a particular order. </span></p>
<p><span class="koboSpan" id="kobo.6.1">In a coroutine, the execution point can be suspended and resumed later, since the coroutine keeps track of the state of execution. </span><span class="koboSpan" id="kobo.6.2">Having a pool of coroutines, it is possible to interleave the computations: the first one runs until it </span><em><span class="koboSpan" id="kobo.7.1">yields control back</span></em><span class="koboSpan" id="kobo.8.1">, then the second runs and goes on down the line.</span></p>
<p><span class="koboSpan" id="kobo.9.1">The interleaving is managed by the event loop, which was described in the </span><em><span class="koboSpan" id="kobo.10.1">Managing the event loop with asyncio</span></em><span class="koboSpan" id="kobo.11.1"> recipe. </span><span class="koboSpan" id="kobo.11.2">It keeps track of all the coroutines and schedules when they will be executed.</span></p>
<p><span class="koboSpan" id="kobo.12.1">Other important aspects of coroutines are as follows:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Coroutines allow for multiple entry points that can yield multiple times.</span></li>
<li><span class="koboSpan" id="kobo.14.1">Coroutines can transfer execution to any other coroutine.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.15.1">The term </span><em><span class="koboSpan" id="kobo.16.1">yield</span></em><span class="koboSpan" id="kobo.17.1"> is used here to describe a coroutine pausing and passing the control flow to another coroutine.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We will use the following notation to work with coroutines:</span></p>
<pre><span class="koboSpan" id="kobo.3.1">import asyncio </span><br/><br/><span class="koboSpan" id="kobo.4.1">@asyncio.coroutine</span><br/><span class="koboSpan" id="kobo.5.1">def coroutine_function(function_arguments):</span><br/><span class="koboSpan" id="kobo.6.1">    ............</span><br/><span class="koboSpan" id="kobo.7.1">    DO_SOMETHING</span><br/><span class="koboSpan" id="kobo.8.1">    ............   </span></pre>
<p><span class="koboSpan" id="kobo.9.1">Coroutines use the </span><kbd><span class="koboSpan" id="kobo.10.1">yield from</span></kbd><span class="koboSpan" id="kobo.11.1"> syntax introduced in PEP 380 (read more at </span><a href="https://www.python.org/dev/peps/pep-0380/"><span class="koboSpan" id="kobo.12.1">https://www.python.org/dev/peps/pep-0380/</span></a><span class="koboSpan" id="kobo.13.1">) to </span><span><span class="koboSpan" id="kobo.14.1">stop the execution of the current computation and suspends the coroutine's internal state.</span></span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.15.1">In particular, in the case of </span><kbd><span class="koboSpan" id="kobo.16.1">yield from future</span></kbd><span class="koboSpan" id="kobo.17.1">, the coroutine is </span><span><span class="koboSpan" id="kobo.18.1">suspended until</span></span><span class="koboSpan" id="kobo.19.1"> </span><kbd><span class="koboSpan" id="kobo.20.1">future</span></kbd> <span><span class="koboSpan" id="kobo.21.1">is done, then the result of </span><kbd><span class="koboSpan" id="kobo.22.1">future</span></kbd><span class="koboSpan" id="kobo.23.1"> will be propagated (or raise an exception); in the case of</span></span> <kbd><span class="koboSpan" id="kobo.24.1">yield from coroutine</span></kbd><span class="koboSpan" id="kobo.25.1">, </span><span><span class="koboSpan" id="kobo.26.1">the coroutine waits for</span></span><span class="koboSpan" id="kobo.27.1"> another coroutine </span><span><span class="koboSpan" id="kobo.28.1">to produce a result that will be propagated (or raise an exception).</span></span></p>
<p><span class="koboSpan" id="kobo.29.1">As we shall see in the next example, in which the coroutines will be used to simulate a finite state machine, we will use the </span><kbd><span class="koboSpan" id="kobo.30.1">yield from coroutine</span></kbd><span class="koboSpan" id="kobo.31.1"> notation.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.32.1">More on coroutines with </span><kbd><span class="koboSpan" id="kobo.33.1">asyncio</span></kbd><span class="koboSpan" id="kobo.34.1"> are available at </span><a href="https://docs.python.org/3.5/library/asyncio-task.html"><span class="koboSpan" id="kobo.35.1">https://docs.python.org/3.5/library/asyncio-task.html</span></a><span class="koboSpan" id="kobo.36.1">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this example, we see how to use coroutines to simulate a finite state machine with five states.</span></p>
<p><span class="koboSpan" id="kobo.3.1">A </span><strong><span class="koboSpan" id="kobo.4.1">finite state machine</span></strong><span class="koboSpan" id="kobo.5.1"> or </span><strong><span><span class="koboSpan" id="kobo.6.1">fi</span></span><span><span class="koboSpan" id="kobo.7.1">nite state</span></span><span><span class="koboSpan" id="kobo.8.1"> </span></span><span class="koboSpan" id="kobo.9.1">automaton</span></strong><span class="koboSpan" id="kobo.10.1"> is a mathematical model that is widely used in engineering disciplines, but also in sciences such as mathematics and computer science.</span></p>
<p><span class="koboSpan" id="kobo.11.1">The automaton that we want to simulate the behavior of using coroutines is as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.12.1"><img src="assets/11c82c0c-3add-446c-8ca7-ba4f599bc622.png" style="width:20.58em;height:33.58em;"/></span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span><span class="koboSpan" id="kobo.13.1">  </span></span> <span><span class="koboSpan" id="kobo.14.1"> Finite-state machine</span></span><span class="koboSpan" id="kobo.15.1"> </span></div>
<p><span class="koboSpan" id="kobo.16.1">The states of the system are </span><strong><span class="koboSpan" id="kobo.17.1">S0</span></strong><span class="koboSpan" id="kobo.18.1">, </span><strong><span class="koboSpan" id="kobo.19.1">S1</span></strong><span class="koboSpan" id="kobo.20.1">, </span><strong><span class="koboSpan" id="kobo.21.1">S2</span></strong><span class="koboSpan" id="kobo.22.1">, </span><strong><span class="koboSpan" id="kobo.23.1">S3</span></strong><span class="koboSpan" id="kobo.24.1">, and </span><strong><span class="koboSpan" id="kobo.25.1">S4</span></strong><span class="koboSpan" id="kobo.26.1">, with </span><strong><span class="koboSpan" id="kobo.27.1">0</span></strong><span class="koboSpan" id="kobo.28.1"> and </span><strong><span class="koboSpan" id="kobo.29.1">1</span></strong><span class="koboSpan" id="kobo.30.1">: the values for which the automaton can pass from one state to the next state (this operation is called a </span><em><span class="koboSpan" id="kobo.31.1">transition</span></em><span class="koboSpan" id="kobo.32.1">). </span><span class="koboSpan" id="kobo.32.2">So, for example, state </span><strong><span class="koboSpan" id="kobo.33.1">S0</span></strong><span class="koboSpan" id="kobo.34.1"> can pass to state </span><strong><span class="koboSpan" id="kobo.35.1">S1</span></strong><span class="koboSpan" id="kobo.36.1">, but only for the value </span><strong><span class="koboSpan" id="kobo.37.1">1</span></strong><span class="koboSpan" id="kobo.38.1">, and </span><strong><span class="koboSpan" id="kobo.39.1">S0</span></strong><span class="koboSpan" id="kobo.40.1"> can pass to state </span><strong><span class="koboSpan" id="kobo.41.1">S2</span></strong><span class="koboSpan" id="kobo.42.1">, but only for the value </span><strong><span class="koboSpan" id="kobo.43.1">0</span></strong><span class="koboSpan" id="kobo.44.1">.</span></p>
<p><span class="koboSpan" id="kobo.45.1">The </span><span><span class="koboSpan" id="kobo.46.1">following </span></span><span class="koboSpan" id="kobo.47.1">Python code simulates a transition of the automaton from state </span><strong><span class="koboSpan" id="kobo.48.1">S0</span></strong><span class="koboSpan" id="kobo.49.1"> (the start state), up to state </span><strong><span class="koboSpan" id="kobo.50.1">S4</span></strong><span class="koboSpan" id="kobo.51.1"> (the end state):</span></p>
<ol>
<li><span class="koboSpan" id="kobo.52.1">The first step is obviously to import the relevant libraries:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.53.1">import asyncio</span><br/><span class="koboSpan" id="kobo.54.1">import time</span><br/><span class="koboSpan" id="kobo.55.1">from random import randint</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.56.1">Then, we define the coroutine relative to </span><kbd><span class="koboSpan" id="kobo.57.1">start_state</span></kbd><span class="koboSpan" id="kobo.58.1">. </span><span class="koboSpan" id="kobo.58.2">The </span><kbd><span class="koboSpan" id="kobo.59.1">input_value</span></kbd><span class="koboSpan" id="kobo.60.1"> parameter is evaluated randomly; it can be </span><kbd><span class="koboSpan" id="kobo.61.1">0</span></kbd><span class="koboSpan" id="kobo.62.1"> or </span><kbd><span class="koboSpan" id="kobo.63.1">1</span></kbd><span class="koboSpan" id="kobo.64.1">. </span><span class="koboSpan" id="kobo.64.2">If it is </span><kbd><span class="koboSpan" id="kobo.65.1">0</span></kbd><span class="koboSpan" id="kobo.66.1">, then the control goes to coroutine </span><kbd><span class="koboSpan" id="kobo.67.1">state2</span></kbd><span class="koboSpan" id="kobo.68.1">; otherwise, it changes to coroutine </span><kbd><span class="koboSpan" id="kobo.69.1">state1</span></kbd><span class="koboSpan" id="kobo.70.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.71.1">@asyncio.coroutine</span><br/><span class="koboSpan" id="kobo.72.1">def start_state():</span><br/><span class="koboSpan" id="kobo.73.1">    print('Start State called\n')</span><br/><span class="koboSpan" id="kobo.74.1">    input_value = randint(0, 1)</span><br/><span class="koboSpan" id="kobo.75.1">    time.sleep(1)</span><br/><span class="koboSpan" id="kobo.76.1">    if input_value == 0:</span><br/><span class="koboSpan" id="kobo.77.1">        result = yield from state2(input_value)</span><br/><span class="koboSpan" id="kobo.78.1">    else:</span><br/><span class="koboSpan" id="kobo.79.1">        result = yield from state1(input_value)</span><br/><span class="koboSpan" id="kobo.80.1">    print('Resume of the Transition:\nStart State calling'+ result)</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.81.1">Here is the coroutine for </span><kbd><span class="koboSpan" id="kobo.82.1">state1</span></kbd><span class="koboSpan" id="kobo.83.1">. </span><span class="koboSpan" id="kobo.83.2">The </span><kbd><span class="koboSpan" id="kobo.84.1">input_value</span></kbd><span class="koboSpan" id="kobo.85.1"> parameter is evaluated randomly; it can be </span><kbd><span class="koboSpan" id="kobo.86.1">0</span></kbd><span class="koboSpan" id="kobo.87.1"> or </span><kbd><span class="koboSpan" id="kobo.88.1">1</span></kbd><span class="koboSpan" id="kobo.89.1">. </span><span class="koboSpan" id="kobo.89.2">If it is </span><kbd><span class="koboSpan" id="kobo.90.1">0</span></kbd><span class="koboSpan" id="kobo.91.1">, then the control goes to </span><kbd><span class="koboSpan" id="kobo.92.1">state2</span></kbd><span class="koboSpan" id="kobo.93.1">; otherwise, it changes to </span><kbd><span class="koboSpan" id="kobo.94.1">state1</span></kbd><span class="koboSpan" id="kobo.95.1">: </span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.96.1">@asyncio.coroutine</span><br/><span class="koboSpan" id="kobo.97.1">def state1(transition_value):</span><br/><span class="koboSpan" id="kobo.98.1">    output_value ='State 1 with transition value = %s\n'% \</span><br/><span class="koboSpan" id="kobo.99.1">                                             transition_value</span><br/><span class="koboSpan" id="kobo.100.1">    input_value = randint(0, 1)</span><br/><span class="koboSpan" id="kobo.101.1">    time.sleep(1)</span><br/><span class="koboSpan" id="kobo.102.1">    print('...evaluating...')</span><br/><span class="koboSpan" id="kobo.103.1">    if input_value == 0:</span><br/><span class="koboSpan" id="kobo.104.1">        result = yield from state3(input_value)</span><br/><span class="koboSpan" id="kobo.105.1">    else:</span><br/><span class="koboSpan" id="kobo.106.1">        result = yield from state2(input_value)</span><br/><span class="koboSpan" id="kobo.107.1">    return output_value + 'State 1 calling %s' % result</span></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.108.1">The coroutine for </span><kbd><span class="koboSpan" id="kobo.109.1">state1</span></kbd><span class="koboSpan" id="kobo.110.1"> has the </span><kbd><span class="koboSpan" id="kobo.111.1">transition_value</span></kbd> <span><span class="koboSpan" id="kobo.112.1">argument </span></span><span class="koboSpan" id="kobo.113.1">that allowed the passage of the state. </span><span class="koboSpan" id="kobo.113.2">Also, in this case, </span><kbd><span class="koboSpan" id="kobo.114.1">input_value</span></kbd><span class="koboSpan" id="kobo.115.1"> is randomly evaluated. </span><span class="koboSpan" id="kobo.115.2">If it is </span><kbd><span class="koboSpan" id="kobo.116.1">0</span></kbd><span class="koboSpan" id="kobo.117.1">, then the state transitions to </span><kbd><span class="koboSpan" id="kobo.118.1">state3</span></kbd><span class="koboSpan" id="kobo.119.1">; otherwise, the control changes to </span><kbd><span class="koboSpan" id="kobo.120.1">state2</span></kbd><span class="koboSpan" id="kobo.121.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.122.1">@asyncio.coroutine</span><br/><span class="koboSpan" id="kobo.123.1">def state2(transition_value):</span><br/><span class="koboSpan" id="kobo.124.1">    output_value = 'State 2 with transition value = %s\n' %\</span><br/><span class="koboSpan" id="kobo.125.1">                                             transition_value</span><br/><span class="koboSpan" id="kobo.126.1">    input_value = randint(0, 1)</span><br/><span class="koboSpan" id="kobo.127.1">    time.sleep(1)</span><br/><span class="koboSpan" id="kobo.128.1">    print('...evaluating...')</span><br/><span class="koboSpan" id="kobo.129.1">    if input_value == 0:</span><br/><span class="koboSpan" id="kobo.130.1">        result = yield from state1(input_value)</span><br/><span class="koboSpan" id="kobo.131.1">    else:</span><br/><span class="koboSpan" id="kobo.132.1">        result = yield from state3(input_value)</span><br/><span class="koboSpan" id="kobo.133.1">    return output_value + 'State 2 calling %s' % result</span></pre>
<ol start="5">
<li><span class="koboSpan" id="kobo.134.1">The coroutine for </span><kbd><span class="koboSpan" id="kobo.135.1">state3</span></kbd><span class="koboSpan" id="kobo.136.1"> has the </span><kbd><span class="koboSpan" id="kobo.137.1">transition_value</span></kbd> <span><span class="koboSpan" id="kobo.138.1">argument, which</span></span><span class="koboSpan" id="kobo.139.1"> allowed the passage of the state. </span><kbd><span class="koboSpan" id="kobo.140.1">input_value</span></kbd><span class="koboSpan" id="kobo.141.1"> is randomly evaluated. </span><span class="koboSpan" id="kobo.141.2">If it is </span><kbd><span class="koboSpan" id="kobo.142.1">0</span></kbd><span class="koboSpan" id="kobo.143.1">, then the state transitions to </span><kbd><span class="koboSpan" id="kobo.144.1">state1</span></kbd><span class="koboSpan" id="kobo.145.1">; otherwise, the control changes to </span><kbd><span class="koboSpan" id="kobo.146.1">end_state</span></kbd><span class="koboSpan" id="kobo.147.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.148.1">@asyncio.coroutine</span><br/><span class="koboSpan" id="kobo.149.1">def state3(transition_value):</span><br/><span class="koboSpan" id="kobo.150.1">    output_value = 'State 3 with transition value = %s\n' %\</span><br/><span class="koboSpan" id="kobo.151.1">                                                 transition_value</span><br/><span class="koboSpan" id="kobo.152.1">    input_value = randint(0, 1)</span><br/><span class="koboSpan" id="kobo.153.1">    time.sleep(1)</span><br/><span class="koboSpan" id="kobo.154.1">    print('...evaluating...')</span><br/><span class="koboSpan" id="kobo.155.1">    if input_value == 0:</span><br/><span class="koboSpan" id="kobo.156.1">        result = yield from state1(input_value)</span><br/><span class="koboSpan" id="kobo.157.1">    else:</span><br/><span class="koboSpan" id="kobo.158.1">        result = yield from end_state(input_value)</span><br/><span class="koboSpan" id="kobo.159.1">    return output_value + 'State 3 calling %s' % result</span></pre>
<ol start="6">
<li><kbd><span class="koboSpan" id="kobo.160.1">end_state</span></kbd><span class="koboSpan" id="kobo.161.1"> prints out the </span><kbd><span class="koboSpan" id="kobo.162.1">transition_value</span></kbd><span class="koboSpan" id="kobo.163.1"> argument, which allowed the passage of the state, and then stops the computation:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.164.1">@asyncio.coroutine</span><br/><span class="koboSpan" id="kobo.165.1">def end_state(transition_value):</span><br/><span class="koboSpan" id="kobo.166.1">    output_value = 'End State with transition value = %s\n'%\</span><br/><span class="koboSpan" id="kobo.167.1">                                                transition_value</span><br/><span class="koboSpan" id="kobo.168.1">    print('...stop computation...')</span><br/><span class="koboSpan" id="kobo.169.1">    return output_value</span></pre>
<ol start="7">
<li><span class="koboSpan" id="kobo.170.1">In the </span><kbd><span class="koboSpan" id="kobo.171.1">__main__</span></kbd><span class="koboSpan" id="kobo.172.1"> function, the event loop is acquired, and then we start the simulation of the finite state machine, calling </span><span><span class="koboSpan" id="kobo.173.1">the automaton's</span></span><span class="koboSpan" id="kobo.174.1"> </span><kbd><span class="koboSpan" id="kobo.175.1">start_state</span></kbd><span class="koboSpan" id="kobo.176.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.177.1">if __name__ == '__main__':</span><br/><span class="koboSpan" id="kobo.178.1">    print('Finite State Machine simulation with Asyncio Coroutine')</span><br/><span class="koboSpan" id="kobo.179.1">    loop = asyncio.get_event_loop()</span><br/><span class="koboSpan" id="kobo.180.1">    loop.run_until_complete(start_state())</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Each state of the automaton has been defined by using the decorator:</span></p>
<pre><span class="koboSpan" id="kobo.3.1"> @asyncio.coroutine</span></pre>
<p><span class="koboSpan" id="kobo.4.1">For example, state </span><strong><span class="koboSpan" id="kobo.5.1">S0</span></strong><span class="koboSpan" id="kobo.6.1"> is</span><span><span class="koboSpan" id="kobo.7.1"> defined</span></span><span class="koboSpan" id="kobo.8.1"> here:</span></p>
<pre><span class="koboSpan" id="kobo.9.1">@asyncio.coroutine</span><br/><span class="koboSpan" id="kobo.10.1">def StartState():</span><br/><span class="koboSpan" id="kobo.11.1">    print ("Start State called \n")</span><br/><span class="koboSpan" id="kobo.12.1">    input_value = randint(0,1)</span><br/><span class="koboSpan" id="kobo.13.1">    time.sleep(1)</span><br/><span class="koboSpan" id="kobo.14.1">    if (input_value == 0):</span><br/><span class="koboSpan" id="kobo.15.1">        result = yield from State2(input_value)</span><br/><span class="koboSpan" id="kobo.16.1">    else :</span><br/><span class="koboSpan" id="kobo.17.1">        result = yield from State1(input_value)</span></pre>
<p><span class="koboSpan" id="kobo.18.1">The transition to the next state is determined by </span><kbd><span class="koboSpan" id="kobo.19.1">input_value</span></kbd><span class="koboSpan" id="kobo.20.1">, which is defined by the </span><kbd><span class="koboSpan" id="kobo.21.1">randint (0,1)</span></kbd><span class="koboSpan" id="kobo.22.1"> </span><span><span class="koboSpan" id="kobo.23.1">function </span></span><span class="koboSpan" id="kobo.24.1">of Python's </span><kbd><span class="koboSpan" id="kobo.25.1">random</span></kbd><span class="koboSpan" id="kobo.26.1"> </span><span><span class="koboSpan" id="kobo.27.1">module.</span></span><span class="koboSpan" id="kobo.28.1"> This function </span><span><span class="koboSpan" id="kobo.29.1">randomly </span></span><span class="koboSpan" id="kobo.30.1">provides a value of </span><kbd><span class="koboSpan" id="kobo.31.1">0</span></kbd><span class="koboSpan" id="kobo.32.1"> or </span><kbd><span class="koboSpan" id="kobo.33.1">1</span></kbd><span class="koboSpan" id="kobo.34.1">.</span></p>
<p><span class="koboSpan" id="kobo.35.1">In this manner, </span><span><span><kbd><span class="koboSpan" id="kobo.36.1">randint</span></kbd></span></span><span class="koboSpan" id="kobo.37.1"> randomly determines the state to which the finite state machine will pass:</span></p>
<pre><span class="koboSpan" id="kobo.38.1">input_value = randint(0,1)</span></pre>
<p><span class="koboSpan" id="kobo.39.1">After determining the values to pass, the coroutine calls the next coroutine using the </span><kbd><span class="koboSpan" id="kobo.40.1">yield from</span></kbd><span><span class="koboSpan" id="kobo.41.1"> command:</span></span></p>
<pre><span class="koboSpan" id="kobo.42.1">if (input_value == 0):</span><br/><span class="koboSpan" id="kobo.43.1">        result = yield from State2(input_value)</span><br/><span class="koboSpan" id="kobo.44.1">    else :</span><br/><span class="koboSpan" id="kobo.45.1">        result = yield from State1(input_value)</span></pre>
<p><span class="koboSpan" id="kobo.46.1">The </span><kbd><span class="koboSpan" id="kobo.47.1">result</span></kbd> <span><span class="koboSpan" id="kobo.48.1">variable </span></span><span class="koboSpan" id="kobo.49.1">is the value that each coroutine returns. </span><span class="koboSpan" id="kobo.49.2">It is a string, and, at the end of the computation, we can reconstruct the transition from the initial state of the automaton, </span><kbd><span class="koboSpan" id="kobo.50.1">start_state</span></kbd><span class="koboSpan" id="kobo.51.1">, up to </span><kbd><span class="koboSpan" id="kobo.52.1">end_state</span></kbd><span class="koboSpan" id="kobo.53.1">.</span></p>
<p><span class="koboSpan" id="kobo.54.1">The </span><kbd><span class="koboSpan" id="kobo.55.1">main</span></kbd><span class="koboSpan" id="kobo.56.1"> program starts the evaluation inside the event loop:</span></p>
<pre><span class="koboSpan" id="kobo.57.1">if __name__ == "__main__":</span><br/><span class="koboSpan" id="kobo.58.1">    print("Finite State Machine simulation with Asyncio Coroutine")</span><br/><span class="koboSpan" id="kobo.59.1">    loop = asyncio.get_event_loop()</span><br/><span class="koboSpan" id="kobo.60.1">    loop.run_until_complete(StartState())</span></pre>
<p><span class="koboSpan" id="kobo.61.1">Running the code, we have an output like this:</span></p>
<pre><strong><span class="koboSpan" id="kobo.62.1">Finite State Machine simulation with Asyncio Coroutine</span></strong><br/><strong><span class="koboSpan" id="kobo.63.1">Start State called</span></strong><br/><strong><span class="koboSpan" id="kobo.64.1">...evaluating...</span></strong><br/><strong><span class="koboSpan" id="kobo.65.1">...evaluating...</span></strong><br/><strong><span class="koboSpan" id="kobo.66.1">...evaluating...</span></strong><br/><strong><span class="koboSpan" id="kobo.67.1">...evaluating...</span></strong><br/><strong><span class="koboSpan" id="kobo.68.1">...stop computation...</span></strong><br/><strong><span class="koboSpan" id="kobo.69.1">Resume of the Transition : </span></strong><br/><strong><span class="koboSpan" id="kobo.70.1">Start State calling State 1 with transition value = 1</span></strong><br/><strong><span class="koboSpan" id="kobo.71.1">State 1 calling State 2 with transition value = 1</span></strong><br/><strong><span class="koboSpan" id="kobo.72.1">State 2 calling State 1 with transition value = 0</span></strong><br/><strong><span class="koboSpan" id="kobo.73.1">State 1 calling State 3 with transition value = 0</span></strong><br/><strong><span class="koboSpan" id="kobo.74.1">State 3 calling End State with transition value = 1</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Before Python 3.5 was released, the </span><kbd><span class="koboSpan" id="kobo.3.1">asyncio</span></kbd><span class="koboSpan" id="kobo.4.1"> module used generators to mimic asynchronous calls and, therefore, had a different syntax than the current version of Python 3.5.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Python 3.5 introduced the </span><kbd><span class="koboSpan" id="kobo.6.1">async</span></kbd><span class="koboSpan" id="kobo.7.1"> and </span><kbd><span class="koboSpan" id="kobo.8.1">await</span></kbd><span class="koboSpan" id="kobo.9.1"> </span><span><span class="koboSpan" id="kobo.10.1">keywords.</span></span><span class="koboSpan" id="kobo.11.1"> Notice the lack of parentheses around the </span><kbd><span class="koboSpan" id="kobo.12.1">await func()</span></kbd><span class="koboSpan" id="kobo.13.1"> call.</span></p>
<p><span class="koboSpan" id="kobo.14.1">The following is an example of </span><kbd><span class="koboSpan" id="kobo.15.1">"Hello, world!"</span></kbd><span class="koboSpan" id="kobo.16.1">, using </span><kbd><span class="koboSpan" id="kobo.17.1">asyncio</span></kbd><span class="koboSpan" id="kobo.18.1"> with the new syntax introduced by Python 3.5+:</span></p>
<pre><span class="koboSpan" id="kobo.19.1">import asyncio</span><br/> <br/><span class="koboSpan" id="kobo.20.1">async def main():</span><br/><span class="koboSpan" id="kobo.21.1">    print(await func())</span><br/> <br/><span class="koboSpan" id="kobo.22.1">async def func():</span><br/><span class="koboSpan" id="kobo.23.1">    # Do time intensive stuff...</span><br/><span class="koboSpan" id="kobo.24.1">    return "Hello, world!"</span><br/> <br/><span class="koboSpan" id="kobo.25.1">if __name__ == "__main__":</span><br/><span class="koboSpan" id="kobo.26.1">    loop = asyncio.get_event_loop()</span><br/><span class="koboSpan" id="kobo.27.1">    loop.run_until_complete(main())</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">See also</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Coroutines in Python are well described here: </span><a href="https://www.geeksforgeeks.org/coroutine-in-python/"><span class="koboSpan" id="kobo.3.1">https://www.geeksforgeeks.org/coroutine-in-python/</span></a><span class="koboSpan" id="kobo.4.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Manipulating tasks with asyncio</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">asyncio</span></kbd><span class="koboSpan" id="kobo.4.1"> module is designed to handle asynchronous processes and concurrent task execution over an event loop. </span><span class="koboSpan" id="kobo.4.2">It also provides the </span><kbd><span class="koboSpan" id="kobo.5.1">asyncio.Task()</span></kbd><span class="koboSpan" id="kobo.6.1"> class for the purpose of wrapping coroutines in a task (</span><a href="https://docs.python.org/3/library/asyncio-task.html"><span class="koboSpan" id="kobo.7.1">https://docs.python.org/3/library/asyncio-task.html</span></a><span class="koboSpan" id="kobo.8.1">). </span><span class="koboSpan" id="kobo.8.2">Its use is to allow independently running tasks to run concurrently with other tasks over the same event loop.</span></p>
<p><span class="koboSpan" id="kobo.9.1">When a coroutine is wrapped in a task, it connects </span><kbd><span class="koboSpan" id="kobo.10.1">Task</span></kbd><span class="koboSpan" id="kobo.11.1"> to the event loop and then runs automatically when the loop is started, thus providing a mechanism for automatically driving the coroutine.</span></p>
<p><span class="koboSpan" id="kobo.12.1">The </span><kbd><span class="koboSpan" id="kobo.13.1">asyncio</span></kbd><span class="koboSpan" id="kobo.14.1"> module provides the </span><span><kbd><span class="koboSpan" id="kobo.15.1">asyncio.Task(coroutine)</span></kbd><span class="koboSpan" id="kobo.16.1"> </span></span><span class="koboSpan" id="kobo.17.1">method to handle computations with tasks; moreover, </span><kbd><span class="koboSpan" id="kobo.18.1">asyncio.Task(coroutine)</span></kbd><span class="koboSpan" id="kobo.19.1"> schedules the execution of a coroutine (</span><a href="https://docs.python.org/3/library/asyncio-task.html"><span class="koboSpan" id="kobo.20.1">https://docs.python.org/3/library/asyncio-task.html</span></a><span class="koboSpan" id="kobo.21.1">).</span></p>
<p><span><span class="koboSpan" id="kobo.22.1">A task is responsible for executing a coroutine object in an</span></span> <em><span class="koboSpan" id="kobo.23.1">event loop</span><span><span class="koboSpan" id="kobo.24.1">.</span></span></em></p>
<p><span><span class="koboSpan" id="kobo.25.1">If the wrapped coroutine uses the</span></span> <kbd><span class="koboSpan" id="kobo.26.1">yields from future</span></kbd><span><span class="koboSpan" id="kobo.27.1"> notation, as already described in the </span></span><em><span class="koboSpan" id="kobo.28.1">Handling coroutines with asyncio</span></em><span class="koboSpan" id="kobo.29.1"> section</span><em><span class="koboSpan" id="kobo.30.1">, </span></em><span><span class="koboSpan" id="kobo.31.1">then the task suspends the execution of the wrapped coroutine and awaits completion of the future.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">When the future is done, the execution of the wrapped coroutine restarts with the result or the exception of the future. </span><span class="koboSpan" id="kobo.32.2">Also, we must note that an event loop only runs one task at a time. </span><span class="koboSpan" id="kobo.32.3">Other tasks may run in parallel if other event loops are running in different threads.</span></p>
<p><span class="koboSpan" id="kobo.33.1">While a task waits for the completion of a future, the event loop executes a new task.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this example, we show how three mathematical functions can be executed concurrently by the </span><kbd><span class="koboSpan" id="kobo.3.1">asyncio.Task()</span></kbd><span class="koboSpan" id="kobo.4.1"> statement:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.5.1">Of course, let's start by importing the </span><kbd><span class="koboSpan" id="kobo.6.1">asyncio</span></kbd><span class="koboSpan" id="kobo.7.1"> library:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.8.1">import asyncio</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.9.1">In the first coroutine, the </span><kbd><span class="koboSpan" id="kobo.10.1">factorial</span></kbd><span class="koboSpan" id="kobo.11.1"> function is defined:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.12.1">@asyncio.coroutine</span><br/><span class="koboSpan" id="kobo.13.1">def factorial(number):</span><br/><span class="koboSpan" id="kobo.14.1">    f = 1</span><br/><span class="koboSpan" id="kobo.15.1">    for i in range(2, number + 1):</span><br/><span class="koboSpan" id="kobo.16.1">        print("Asyncio.Task: Compute factorial(%s)" % (i))</span><br/><span class="koboSpan" id="kobo.17.1">        yield from asyncio.sleep(1)</span><br/><span class="koboSpan" id="kobo.18.1">        f *= i</span><br/><span class="koboSpan" id="kobo.19.1">    print("Asyncio.Task - factorial(%s) = %s" % (number, f))</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.20.1">After which, the second function is defined—the </span><kbd><span class="koboSpan" id="kobo.21.1">fibonacci</span></kbd><span class="koboSpan" id="kobo.22.1"> function:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.23.1">@asyncio.coroutine</span><br/><span class="koboSpan" id="kobo.24.1">def fibonacci(number):</span><br/><span class="koboSpan" id="kobo.25.1">    a, b = 0, 1</span><br/><span class="koboSpan" id="kobo.26.1">    for i in range(number):</span><br/><span class="koboSpan" id="kobo.27.1">        print("Asyncio.Task: Compute fibonacci (%s)" % (i))</span><br/><span class="koboSpan" id="kobo.28.1">        yield from asyncio.sleep(1)</span><br/><span class="koboSpan" id="kobo.29.1">        a, b = b, a + b</span><br/><span class="koboSpan" id="kobo.30.1">    print("Asyncio.Task - fibonacci(%s) = %s" % (number, a))</span></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.31.1">The last function to be executed concurrently is the binomial coefficient:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.32.1">@asyncio.coroutine</span><br/><span class="koboSpan" id="kobo.33.1">def binomial_coefficient(n, k):</span><br/><span class="koboSpan" id="kobo.34.1">    result = 1</span><br/><span class="koboSpan" id="kobo.35.1">    for i in range(1, k + 1):</span><br/><span class="koboSpan" id="kobo.36.1">        result = result * (n - i + 1) / i</span><br/><span class="koboSpan" id="kobo.37.1">        print("Asyncio.Task: Compute binomial_coefficient (%s)" % </span><br/><span class="koboSpan" id="kobo.38.1">            (i))</span><br/><span class="koboSpan" id="kobo.39.1">        yield from asyncio.sleep(1)</span><br/><span class="koboSpan" id="kobo.40.1">    print("Asyncio.Task - binomial_coefficient(%s , %s) = %s" % </span><br/><span class="koboSpan" id="kobo.41.1">        (n,k,result))</span></pre>
<ol start="5">
<li><span class="koboSpan" id="kobo.42.1">In the </span><kbd><span class="koboSpan" id="kobo.43.1">__main__</span></kbd><span class="koboSpan" id="kobo.44.1"> function, </span><kbd><span class="koboSpan" id="kobo.45.1">task_list</span></kbd><span class="koboSpan" id="kobo.46.1"> contains the functions that must be performed in parallel using the </span><kbd><span class="koboSpan" id="kobo.47.1">asyncio.Task</span></kbd><span class="koboSpan" id="kobo.48.1"> function:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.49.1">if __name__ == '__main__':</span><br/><span class="koboSpan" id="kobo.50.1">    task_list = [asyncio.Task(factorial(10)),</span><br/><span class="koboSpan" id="kobo.51.1">                 asyncio.Task(fibonacci(10)),</span><br/><span class="koboSpan" id="kobo.52.1">                 asyncio.Task(binomial_coefficient(20, 10))]</span></pre>
<ol start="6">
<li><span class="koboSpan" id="kobo.53.1">Finally, we acquire the event loop and start the computation:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.54.1">    loop = asyncio.get_event_loop()</span><br/><span class="koboSpan" id="kobo.55.1">    loop.run_until_complete(asyncio.wait(task_list))</span><br/><span class="koboSpan" id="kobo.56.1">    loop.close()</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Each coroutine is defined by the </span><kbd><span><span class="koboSpan" id="kobo.3.1">@asyncio.coroutine</span></span></kbd><span class="koboSpan" id="kobo.4.1"> annotation (called the </span><em><span class="koboSpan" id="kobo.5.1">decorator</span></em><span class="koboSpan" id="kobo.6.1">):</span></p>
<pre><span class="koboSpan" id="kobo.7.1">@asyncio.coroutine</span><br/><span class="koboSpan" id="kobo.8.1">def function (args):</span><br/><span class="koboSpan" id="kobo.9.1">    do something</span></pre>
<p><span class="koboSpan" id="kobo.10.1">To run in parallel, each function is an argument of the </span><kbd><span class="koboSpan" id="kobo.11.1">asyncio.Task</span></kbd><span class="koboSpan" id="kobo.12.1"> module, and therefore, they are included in </span><kbd><span class="koboSpan" id="kobo.13.1">task_list</span></kbd><span class="koboSpan" id="kobo.14.1">:</span></p>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.15.1">if __name__ == '__main__':</span><br/><span class="koboSpan" id="kobo.16.1">    task_list = [asyncio.Task(factorial(10)),</span><br/><span class="koboSpan" id="kobo.17.1">                 asyncio.Task(fibonacci(10)),</span><br/><span class="koboSpan" id="kobo.18.1">                 asyncio.Task(binomial_coefficient(20, 10))]</span></pre>
<p><span class="koboSpan" id="kobo.19.1">Then, we get the event loop:</span></p>
<pre><span class="koboSpan" id="kobo.20.1">    loop = asyncio.get_event_loop()</span></pre>
<p><span class="koboSpan" id="kobo.21.1">Finally, we add the execution of </span><kbd><span class="koboSpan" id="kobo.22.1">task_list</span></kbd><span class="koboSpan" id="kobo.23.1"> to the event loop:</span></p>
<pre><span class="koboSpan" id="kobo.24.1">    loop.run_until_complete(asyncio.wait(task_list))</span><br/><span class="koboSpan" id="kobo.25.1">    loop.close()</span></pre>
<div class="packt_tip"><span><span class="koboSpan" id="kobo.26.1">Note that the </span><kbd><span class="koboSpan" id="kobo.27.1">asyncio.wait(task_list)</span></kbd><span class="koboSpan" id="kobo.28.1"> statement waits for the given coroutines to complete.</span></span></div>
<p><span class="koboSpan" id="kobo.29.1">The output for the preceding code looks like this:</span></p>
<pre><strong><span class="koboSpan" id="kobo.30.1">Asyncio.Task: Compute factorial(2)</span></strong><br/><strong><span class="koboSpan" id="kobo.31.1">Asyncio.Task: Compute fibonacci(0)</span></strong><br/><strong><span class="koboSpan" id="kobo.32.1">Asyncio.Task: Compute binomial_coefficient(1)</span></strong><br/><strong><span class="koboSpan" id="kobo.33.1">Asyncio.Task: Compute factorial(3)</span></strong><br/><strong><span class="koboSpan" id="kobo.34.1">Asyncio.Task: Compute fibonacci(1)</span></strong><br/><strong><span class="koboSpan" id="kobo.35.1">Asyncio.Task: Compute binomial_coefficient(2)</span></strong><br/><strong><span class="koboSpan" id="kobo.36.1">Asyncio.Task: Compute factorial(4)</span></strong><br/><strong><span class="koboSpan" id="kobo.37.1">Asyncio.Task: Compute fibonacci(2)</span></strong><br/><strong><span class="koboSpan" id="kobo.38.1">Asyncio.Task: Compute binomial_coefficient(3)</span></strong><br/><strong><span class="koboSpan" id="kobo.39.1">Asyncio.Task: Compute factorial(5)</span></strong><br/><strong><span class="koboSpan" id="kobo.40.1">Asyncio.Task: Compute fibonacci(3)</span></strong><br/><strong><span class="koboSpan" id="kobo.41.1">Asyncio.Task: Compute binomial_coefficient(4)</span></strong><br/><strong><span class="koboSpan" id="kobo.42.1">Asyncio.Task: Compute factorial(6)</span></strong><br/><strong><span class="koboSpan" id="kobo.43.1">Asyncio.Task: Compute fibonacci(4)</span></strong><br/><strong><span class="koboSpan" id="kobo.44.1">Asyncio.Task: Compute binomial_coefficient(5)</span></strong><br/><strong><span class="koboSpan" id="kobo.45.1">Asyncio.Task: Compute factorial(7)</span></strong><br/><strong><span class="koboSpan" id="kobo.46.1">Asyncio.Task: Compute fibonacci(5)</span></strong><br/><strong><span class="koboSpan" id="kobo.47.1">Asyncio.Task: Compute binomial_coefficient(6)</span></strong><br/><strong><span class="koboSpan" id="kobo.48.1">Asyncio.Task: Compute factorial(8)</span></strong><br/><strong><span class="koboSpan" id="kobo.49.1">Asyncio.Task: Compute fibonacci(6)</span></strong><br/><strong><span class="koboSpan" id="kobo.50.1">Asyncio.Task: Compute binomial_coefficient(7)</span></strong><br/><strong><span class="koboSpan" id="kobo.51.1">Asyncio.Task: Compute factorial(9)</span></strong><br/><strong><span class="koboSpan" id="kobo.52.1">Asyncio.Task: Compute fibonacci(7)</span></strong><br/><strong><span class="koboSpan" id="kobo.53.1">Asyncio.Task: Compute binomial_coefficient(8)</span></strong><br/><strong><span class="koboSpan" id="kobo.54.1">Asyncio.Task: Compute factorial(10)</span></strong><br/><strong><span class="koboSpan" id="kobo.55.1">Asyncio.Task: Compute fibonacci(8)</span></strong><br/><strong><span class="koboSpan" id="kobo.56.1">Asyncio.Task: Compute binomial_coefficient(9)</span></strong><br/><strong><span class="koboSpan" id="kobo.57.1">Asyncio.Task - factorial(10) = 3628800</span></strong><br/><strong><span class="koboSpan" id="kobo.58.1">Asyncio.Task: Compute fibonacci(9)</span></strong><br/><strong><span class="koboSpan" id="kobo.59.1">Asyncio.Task: Compute binomial_coefficient(10)</span></strong><br/><strong><span class="koboSpan" id="kobo.60.1">Asyncio.Task - fibonacci(10) = 55</span></strong><br/><strong><span class="koboSpan" id="kobo.61.1">Asyncio.Task - binomial_coefficient(20, 10) = 184756.0</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><kbd><span class="koboSpan" id="kobo.2.1">asyncio</span></kbd><span class="koboSpan" id="kobo.3.1"> provides other ways to schedule tasks using the </span><kbd><span class="koboSpan" id="kobo.4.1">ensure_future()</span></kbd><span class="koboSpan" id="kobo.5.1"> or </span><kbd><span class="koboSpan" id="kobo.6.1">AbstractEventLoop.create_task()</span></kbd><span class="koboSpan" id="kobo.7.1"> methods, which both accept a coroutine object.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">See also</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">More on </span><kbd><span class="koboSpan" id="kobo.3.1">asyncio</span></kbd><span class="koboSpan" id="kobo.4.1"> and tasks can be found here: </span><a href="https://tutorialedge.net/python/concurrency/asyncio-tasks-tutorial/"><span class="koboSpan" id="kobo.5.1">https://tutorialedge.net/python/concurrency/asyncio-tasks-tutorial/</span></a><span class="koboSpan" id="kobo.6.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Dealing with asyncio and futures</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Another key component of the </span><kbd><span class="koboSpan" id="kobo.3.1">asyncio</span></kbd><span class="koboSpan" id="kobo.4.1"> module is the </span><kbd><span class="koboSpan" id="kobo.5.1">asyncio.Future</span></kbd><span class="koboSpan" id="kobo.6.1"> </span><span><span class="koboSpan" id="kobo.7.1">class.</span></span><span class="koboSpan" id="kobo.8.1"> It is very similar to </span><kbd><span class="koboSpan" id="kobo.9.1">concurrent.Futures</span></kbd><span class="koboSpan" id="kobo.10.1">, but, of course, it is adapted to the main mechanism of </span><kbd><span class="koboSpan" id="kobo.11.1">asyncio</span></kbd><span class="koboSpan" id="kobo.12.1">: the event loop.</span></p>
<p><span class="koboSpan" id="kobo.13.1">The </span><kbd><span class="koboSpan" id="kobo.14.1">asyncio.Future</span></kbd> <span><span class="koboSpan" id="kobo.15.1">class </span></span><span class="koboSpan" id="kobo.16.1">represents a result (but can also be an exception) that is not yet available.</span></p>
<p><span class="koboSpan" id="kobo.17.1">Hence, it represents an abstraction of something that is yet to be achieved. </span><span class="koboSpan" id="kobo.17.2">The callbacks that have to process any results are, in fact, added to instances of this class.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">To define a </span><kbd><span class="koboSpan" id="kobo.3.1">future</span></kbd><span class="koboSpan" id="kobo.4.1"> object, the following syntax must be used:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">future = asyncio.Future</span></pre>
<p><span class="koboSpan" id="kobo.6.1">The main methods to manage this object are the following:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.7.1">cancel()</span></kbd><span class="koboSpan" id="kobo.8.1">: This cancels </span><span><span class="koboSpan" id="kobo.9.1">the </span></span><kbd><span class="koboSpan" id="kobo.10.1">future</span></kbd><span class="koboSpan" id="kobo.11.1"> object and schedules callbacks.</span></li>
<li><kbd><span class="koboSpan" id="kobo.12.1">result()</span></kbd><span class="koboSpan" id="kobo.13.1">: This returns the result that this </span><kbd><span class="koboSpan" id="kobo.14.1">future</span></kbd><span class="koboSpan" id="kobo.15.1"> represents.</span></li>
<li><kbd><span class="koboSpan" id="kobo.16.1">exception()</span></kbd><span class="koboSpan" id="kobo.17.1">: This returns the exception that was set on this </span><kbd><span class="koboSpan" id="kobo.18.1">future</span></kbd><span class="koboSpan" id="kobo.19.1">.</span></li>
<li><kbd><span class="koboSpan" id="kobo.20.1">add_done_callback(fn)</span></kbd><span class="koboSpan" id="kobo.21.1">: This adds a callback to be run when </span><kbd><span class="koboSpan" id="kobo.22.1">future</span></kbd><span class="koboSpan" id="kobo.23.1"> is done.</span></li>
<li><kbd><span class="koboSpan" id="kobo.24.1">remove_done_callback(fn)</span></kbd><span class="koboSpan" id="kobo.25.1">: This removes all instances of a callback from the call when done.</span></li>
<li><kbd><span class="koboSpan" id="kobo.26.1">set_result(result)</span></kbd><span class="koboSpan" id="kobo.27.1">: This marks </span><kbd><span class="koboSpan" id="kobo.28.1">future</span></kbd><span class="koboSpan" id="kobo.29.1"> as done and sets its result.</span></li>
<li><kbd><span class="koboSpan" id="kobo.30.1">set_exception(exception)</span></kbd><span class="koboSpan" id="kobo.31.1">: This marks </span><kbd><span class="koboSpan" id="kobo.32.1">future</span></kbd><span class="koboSpan" id="kobo.33.1"> as done and sets an exception.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The following example shows how to use the </span><kbd><span class="koboSpan" id="kobo.3.1">asyncio.Future</span></kbd><span class="koboSpan" id="kobo.4.1"> </span><span><span class="koboSpan" id="kobo.5.1">class </span></span><span class="koboSpan" id="kobo.6.1">for the management of two coroutines: </span><kbd><span class="koboSpan" id="kobo.7.1">first_coroutine</span></kbd><span class="koboSpan" id="kobo.8.1"> and </span><kbd><span class="koboSpan" id="kobo.9.1">second_coroutine</span></kbd><span class="koboSpan" id="kobo.10.1">, which perform the following tasks. </span><kbd><span><span class="koboSpan" id="kobo.11.1">first_coroutine</span></span></kbd><span class="koboSpan" id="kobo.12.1"> performs the sum of the first </span><em><span class="koboSpan" id="kobo.13.1">N</span></em><span class="koboSpan" id="kobo.14.1"> integers, and </span><kbd><span><span class="koboSpan" id="kobo.15.1">second_coroutine</span></span></kbd><span class="koboSpan" id="kobo.16.1"> performs the factorial of N:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.17.1">Now, let's import the relevant libraries:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.18.1">import asyncio</span><br/><span class="koboSpan" id="kobo.19.1">import sys</span></pre>
<ol start="2">
<li><kbd><span class="koboSpan" id="kobo.20.1">first_coroutine</span></kbd><span class="koboSpan" id="kobo.21.1"> implements the </span><kbd><span class="koboSpan" id="kobo.22.1">sum</span></kbd><span class="koboSpan" id="kobo.23.1"> function of the first </span><em><span class="koboSpan" id="kobo.24.1">N</span></em><span class="koboSpan" id="kobo.25.1"> integers:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.26.1">@asyncio.coroutine</span><br/><span class="koboSpan" id="kobo.27.1">def first_coroutine(future, num):</span><br/><span class="koboSpan" id="kobo.28.1">    count = 0</span><br/><span class="koboSpan" id="kobo.29.1">    for i in range(1, num + 1):</span><br/><span class="koboSpan" id="kobo.30.1">        count += i</span><br/><span class="koboSpan" id="kobo.31.1">    yield from asyncio.sleep(1)</span><br/><span class="koboSpan" id="kobo.32.1">    future.set_result('First coroutine (sum of N integers)\</span><br/><span class="koboSpan" id="kobo.33.1">                      result = %s' % count)</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.34.1">In </span><kbd><span class="koboSpan" id="kobo.35.1">second_coroutine</span></kbd><span class="koboSpan" id="kobo.36.1">, we still implement the </span><kbd><span class="koboSpan" id="kobo.37.1">factorial</span></kbd><span class="koboSpan" id="kobo.38.1"> function:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.39.1">@asyncio.coroutine</span><br/><span class="koboSpan" id="kobo.40.1">def second_coroutine(future, num):</span><br/><span class="koboSpan" id="kobo.41.1">    count = 1</span><br/><span class="koboSpan" id="kobo.42.1">    for i in range(2, num + 1):</span><br/><span class="koboSpan" id="kobo.43.1">        count *= i</span><br/><span class="koboSpan" id="kobo.44.1">    yield from asyncio.sleep(2)</span><br/><span class="koboSpan" id="kobo.45.1">    future.set_result('Second coroutine (factorial) result = %s' %\ </span><br/><span class="koboSpan" id="kobo.46.1">                      count)</span></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.47.1">Using the </span><kbd><span class="koboSpan" id="kobo.48.1">got_result</span></kbd><span class="koboSpan" id="kobo.49.1"> function, we print the output of the computation:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.50.1">def got_result(future):</span><br/><span class="koboSpan" id="kobo.51.1">    print(future.result())</span></pre>
<ol start="5">
<li><span class="koboSpan" id="kobo.52.1">In the </span><kbd><span class="koboSpan" id="kobo.53.1">main</span></kbd><span class="koboSpan" id="kobo.54.1"> function, the </span><kbd><span class="koboSpan" id="kobo.55.1">num1</span></kbd><span class="koboSpan" id="kobo.56.1"> and </span><kbd><span class="koboSpan" id="kobo.57.1">num2</span></kbd> <span><span class="koboSpan" id="kobo.58.1">parameters </span></span><span class="koboSpan" id="kobo.59.1">must be set by the user. </span><span class="koboSpan" id="kobo.59.2">They will be used as parameters for the functions implemented by the first and second coroutines:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.60.1">if __name__ == "__main__":</span><br/><span class="koboSpan" id="kobo.61.1">    num1 = int(sys.argv[1])</span><br/><span class="koboSpan" id="kobo.62.1">    num2 = int(sys.argv[2])</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="6">
<li><span class="koboSpan" id="kobo.63.1">Now, let's take the event loop:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.64.1">    loop = asyncio.get_event_loop()</span></pre>
<ol start="7">
<li><span class="koboSpan" id="kobo.65.1">Here, the futures are defined by the </span><kbd><span class="koboSpan" id="kobo.66.1">asyncio.future</span></kbd><span class="koboSpan" id="kobo.67.1"> </span><span><span class="koboSpan" id="kobo.68.1">function:</span></span></li>
</ol>
<pre><span class="koboSpan" id="kobo.69.1">    future1 = asyncio.Future()</span><br/><span class="koboSpan" id="kobo.70.1">    future2 = asyncio.Future()</span></pre>
<ol start="8">
<li><span class="koboSpan" id="kobo.71.1">The two coroutines—</span><kbd><span class="koboSpan" id="kobo.72.1">first_couroutine</span></kbd><span class="koboSpan" id="kobo.73.1"> and </span><kbd><span class="koboSpan" id="kobo.74.1">second_couroutine</span></kbd><span class="koboSpan" id="kobo.75.1">—included in the </span><kbd><span class="koboSpan" id="kobo.76.1">tasks</span></kbd><span class="koboSpan" id="kobo.77.1"> list have the </span><kbd><span class="koboSpan" id="kobo.78.1">future1</span></kbd><span class="koboSpan" id="kobo.79.1"> and </span><kbd><span class="koboSpan" id="kobo.80.1">future2</span></kbd><span class="koboSpan" id="kobo.81.1"> futures, the user-defined arguments, and the </span><kbd><span class="koboSpan" id="kobo.82.1">num1</span></kbd><span class="koboSpan" id="kobo.83.1"> and </span><kbd><span class="koboSpan" id="kobo.84.1">num2</span></kbd><span class="koboSpan" id="kobo.85.1"> </span><span><span class="koboSpan" id="kobo.86.1">parameters</span></span><span class="koboSpan" id="kobo.87.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.88.1">tasks = [first_coroutine(future1, num1),</span><br/><span class="koboSpan" id="kobo.89.1">        second_coroutine(future2, num2)]</span></pre>
<ol start="9">
<li><span class="koboSpan" id="kobo.90.1">The futures have added a callback:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.91.1">    future1.add_done_callback(got_result)</span><br/><span class="koboSpan" id="kobo.92.1">    future2.add_done_callback(got_result)</span></pre>
<ol start="10">
<li><span class="koboSpan" id="kobo.93.1">Then, the </span><kbd><span class="koboSpan" id="kobo.94.1">tasks</span></kbd><span class="koboSpan" id="kobo.95.1"> list is added to the event loop, so that the computation can begin:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.96.1">    loop.run_until_complete(asyncio.wait(tasks))</span><br/><span class="koboSpan" id="kobo.97.1">    loop.close()</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In the </span><kbd><span class="koboSpan" id="kobo.3.1">main</span></kbd><span class="koboSpan" id="kobo.4.1"> program, we define the </span><kbd><span class="koboSpan" id="kobo.5.1">future</span></kbd><span class="koboSpan" id="kobo.6.1"> objects,</span><em><span class="koboSpan" id="kobo.7.1"> </span></em><kbd><span class="koboSpan" id="kobo.8.1">future1</span></kbd><span class="koboSpan" id="kobo.9.1"> and </span><kbd><span class="koboSpan" id="kobo.10.1">future2</span></kbd><span class="koboSpan" id="kobo.11.1"> respectively, using via the </span><kbd><span class="koboSpan" id="kobo.12.1">asyncio.Future()</span></kbd><span class="koboSpan" id="kobo.13.1"> directive:</span></p>
<pre><span class="koboSpan" id="kobo.14.1">if __name__ == "__main__":</span><br/><span class="koboSpan" id="kobo.15.1">        future1 = asyncio.Future()</span><br/><span class="koboSpan" id="kobo.16.1">        future2 = asyncio.Future()</span></pre>
<p><span class="koboSpan" id="kobo.17.1">In defining the tasks, we pass the </span><kbd><span class="koboSpan" id="kobo.18.1">future</span></kbd><span class="koboSpan" id="kobo.19.1"> </span><span><span class="koboSpan" id="kobo.20.1">objects</span></span><span class="koboSpan" id="kobo.21.1"> as an argument of the two coroutines </span><kbd><span class="koboSpan" id="kobo.22.1">first_couroutine</span></kbd><span class="koboSpan" id="kobo.23.1"> and </span><kbd><span class="koboSpan" id="kobo.24.1">second_couroutine</span></kbd><span class="koboSpan" id="kobo.25.1">:</span></p>
<pre><span class="koboSpan" id="kobo.26.1">tasks = [first_coroutine(future1,num1), </span><br/><span class="koboSpan" id="kobo.27.1">         second_coroutine(future2,num2)]</span></pre>
<p><span class="koboSpan" id="kobo.28.1">Finally, we add a callback to be run when </span><kbd><span class="koboSpan" id="kobo.29.1">future</span></kbd><span class="koboSpan" id="kobo.30.1"> is done:</span></p>
<pre><span class="koboSpan" id="kobo.31.1">future1.add_done_callback(got_result)</span><br/><span class="koboSpan" id="kobo.32.1">future2.add_done_callback(got_result)</span></pre>
<p><span><span class="koboSpan" id="kobo.33.1">Here, </span><kbd><span class="koboSpan" id="kobo.34.1">got_result</span></kbd><span class="koboSpan" id="kobo.35.1"> is a function that prints the result of </span></span><kbd><span class="koboSpan" id="kobo.36.1">future</span></kbd><span class="koboSpan" id="kobo.37.1">:</span></p>
<pre><span class="koboSpan" id="kobo.38.1">def got_result(future):</span><br/><span class="koboSpan" id="kobo.39.1">    print(future.result())</span></pre>
<p><span class="koboSpan" id="kobo.40.1">In the coroutine, we pass the</span><span><span class="koboSpan" id="kobo.41.1"> </span><kbd><span class="koboSpan" id="kobo.42.1">future</span></kbd></span><span class="koboSpan" id="kobo.43.1"> object as an argument. </span><span class="koboSpan" id="kobo.43.2">After the computation, we set </span><kbd><span class="koboSpan" id="kobo.44.1">sleep</span></kbd><span class="koboSpan" id="kobo.45.1"> times of 3 seconds for the first coroutine and 4 seconds for the second one:</span></p>
<pre><span class="koboSpan" id="kobo.46.1">yield from asyncio.sleep(sleep_time)</span></pre>
<p><span class="koboSpan" id="kobo.47.1">The following output is obtained by executing the command with different values:</span></p>
<pre><strong><span class="koboSpan" id="kobo.48.1">&gt; python asyncio_and_futures.py 1 1</span><br/><span class="koboSpan" id="kobo.49.1">First coroutine (sum of N integers) result = 1</span><br/><span class="koboSpan" id="kobo.50.1">Second coroutine (factorial) result = 1</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.51.1">&gt; python asyncio_and_futures.py 2 2</span><br/><span class="koboSpan" id="kobo.52.1">First coroutine (sum of N integers) result = 2</span><br/></strong><strong><span class="koboSpan" id="kobo.53.1">Second coroutine (factorial) result = 2</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.54.1">&gt; python asyncio_and_futures.py 3 3</span><br/><span class="koboSpan" id="kobo.55.1">First coroutine (sum of N integers) result = 6</span><br/><span class="koboSpan" id="kobo.56.1">Second coroutine (factorial) result = 6</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.57.1">&gt; python asyncio_and_futures.py 5 5</span><br/><span class="koboSpan" id="kobo.58.1">First coroutine (sum of N integers) result = 15</span><br/><span class="koboSpan" id="kobo.59.1">Second coroutine (factorial) result = 120</span></strong><br/><strong><br/><span class="koboSpan" id="kobo.60.1">&gt; python asyncio_and_futures.py 50 50</span><br/><span class="koboSpan" id="kobo.61.1">First coroutine (sum of N integers) result = 1275</span><br/><span class="koboSpan" id="kobo.62.1">Second coroutine (factorial) result = 30414093201713378043612608166064768844377641568960512000000000000 </span><br/><span class="koboSpan" id="kobo.63.1">First coroutine (sum of N integers) result = 1275</span><br/><br/></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We can invert the output results, that is, have the output of </span><kbd><span class="koboSpan" id="kobo.3.1">second_coroutine</span></kbd><span class="koboSpan" id="kobo.4.1"> first, by simply swapping the sleep time between the coroutines: </span><kbd><span class="koboSpan" id="kobo.5.1">yield from asyncio.sleep(2)</span></kbd><span class="koboSpan" id="kobo.6.1"> in the </span><kbd><span class="koboSpan" id="kobo.7.1">first_coroutine</span></kbd><span class="koboSpan" id="kobo.8.1"> definition, and </span><kbd><span><span class="koboSpan" id="kobo.9.1">yield from asyncio.sleep(1)</span></span></kbd><span class="koboSpan" id="kobo.10.1"> in the </span><kbd><span class="koboSpan" id="kobo.11.1">second_coroutine</span></kbd><span class="koboSpan" id="kobo.12.1"> definition. </span><span class="koboSpan" id="kobo.12.2">This can be shown by the following example:</span></p>
<pre><strong><span class="koboSpan" id="kobo.13.1">&gt; python asyncio_and_future.py 1 10</span></strong><br/><strong><span class="koboSpan" id="kobo.14.1">second coroutine (factorial) result = 3628800</span></strong><br/><strong><span class="koboSpan" id="kobo.15.1">first coroutine (sum of N integers) result = 1</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">See also</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">More examples of </span><kbd><span class="koboSpan" id="kobo.3.1">asyncio</span></kbd><span class="koboSpan" id="kobo.4.1"> and futures can be found at </span><a href="https://www.programcreek.com/python/example/102763/asyncio.futures"><span class="koboSpan" id="kobo.5.1">https://www.programcreek.com/python/example/102763/asyncio.futures</span></a><span class="koboSpan" id="kobo.6.1">.</span></p>


            </article>

            
        </section>
    </body></html>