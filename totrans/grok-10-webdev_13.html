<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 12. Grokkers, Martian, and Agile Configuration"><div class="titlepage"><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Grokkers, Martian, and Agile Configuration</h1></div></div></div><p>Agility is very important in Grok, and having to do less configuration to get an application running is the key to being<span class="strong"><strong> agile</strong></span>. In Grok parlance, a<span class="strong"><strong> grokker</strong></span> is a piece of code that allows developers to use framework functionality by making declarations in the code instead of using ZCML configuration files. In this chapter, we introduce<span class="strong"><strong> Martian</strong></span> the library that is used to create grokkers and demonstrate how to create a simple one for our application. Among the subjects that we will cover are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What Martian is</li><li class="listitem" style="list-style-type: disc">Why it is needed and how Grok uses it</li><li class="listitem" style="list-style-type: disc">What a grokker is</li><li class="listitem" style="list-style-type: disc">How to create a grokker</li></ul></div><div class="section" title="Agile configuration"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec01"/>Agile configuration</h1></div></div></div><p>As we explained at the very beginning of this book, when we use the Zope Toolkit without Grok, we must use ZCML to configure everything. This means that we have to add ZCML directives for every view, viewlet, adapter, subscriber, and annotation in our code. That's quite a lot of markup there, all of which has to be maintained along with the code. Agility is not the first thing that comes to mind when we think about this.<a id="id427" class="indexterm"/>
</p><p>Grok's developers knew from experience that the Zope Toolkit and the<span class="strong"><strong> Zope Component Architecture</strong></span> (<span class="strong"><strong>ZCA</strong></span>) enable developers to create advanced object-oriented systems. This power comes at the cost of a raised barrier of entry for new developers.<a id="id428" class="indexterm"/>
</p><p>Another thing that proved to be a problem for Zope Toolkit adoption, is its emphasis on explicit configuration. ZCML allows developers to be very explicit and flexible in their application configuration, but it requires separate files for configuration, and takes more time to create, maintain, and understand. You simply need more time to understand an application because you have to take a look at the different pieces of code and then consult the ZCML files to see how they are connected with each other.</p><p>Grok was designed in such a way that, if the developer follows certain conventions in his code, there is no need for configuration files. Instead, Grok analyzes the Python code for the use of these conventions, and then 'groks' them. Behind the scenes, everything is connected just as it would be if the configuration was written with ZCML, but the developer doesn't even need to think about that.</p><p>As a result of this process, known as 'grokking', the code for a Grok application is clean and uniform. The entire configuration is in the code, in the form of directives and components, so it's easier to follow, and more fun to develop.<a id="id429" class="indexterm"/>
</p><p>Grok is definitely more agile than the Zope Toolkit alone, but it's not a subset or a 'stripped down' version of it. All of the power of the Zope Toolkit is available to the developer. Even explicit configuration can be used with ZCML when it's needed, as we saw when we configured the SMTP mailer, in the previous chapter.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="The Martian library"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec02"/>The Martian library</h1></div></div></div><p>The part of Grok that does the code 'grokking' has been extracted into a standalone library called Martian. This library provides a framework that allows configuration to be expressed in Python code, in the form of declarative statements. The idea is that, often, the structure of a piece of code can be examined and most of the configuration steps that it requires are deduced from this. Martian takes this a step further by using directives to annotate the code, making configuration requirements even more obvious.<a id="id430" class="indexterm"/>
</p><p>Martian is published as a standalone library because even though, it's a key part of Grok, it can be very useful for adding declarative configuration to any kind of framework. For example,<code class="literal"> repoze.bfg</code> (<a class="ulink" href="http://bfg.repoze.org">http://bfg.repoze.org</a>), a minimalist web framework based on Zope concepts, uses Martian to optionally allow the view configuration without ZCML.</p><p>At program startup time, Martian reads the Python code in a module and analyzes all of the classes to see if they belong to a 'grokked' base class (or a subclass of one). If they do, Martian retrieves information from the class registration and any of the directives that it may contain. This information is then used to perform component registrations in the ZCA registry, much like the ZCML machinery does. This process is called 'grokking' and as you see, allows for quick registration of plugins within the framework. Grokkers allow us to write "agility" and "Zope Toolkit" in the same sentence again, without being ironic about it.<a id="id431" class="indexterm"/>
</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Understanding grokkers"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec03"/>Understanding grokkers</h1></div></div></div><p>A grokker is a package that includes a base class to be grokked, a series of directives for configuring that class, and the actual code that performs the registration process using Martian.<a id="id432" class="indexterm"/>
</p><p>Let's take a look at a regular Grok view definition:<a id="id433" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class AddUser(grok.View):
grok.context(Interface)
grok.template('master')
</pre></div><p>In this code,<code class="literal"> grok.View</code> is a grokked class, which means that, when the "Grok time" comes at program startup, it will be found by Martian, 'grokked', and registered with the ZCA. The<code class="literal"> grok.context</code> and<code class="literal"> grok.template</code> declarations are the configuration directives available for this class. The actual 'grokking' is done by a piece of code associated with the grokked class, which registers a named adapter with the ZCA registry for the interface that is passed in the<code class="literal"> grok.context</code> directive. The registration is done by using the class name to name the view, and whatever string value is passed as a parameter to the<code class="literal"> grok.template</code> directive is used to name the associated template.<a id="id434" class="indexterm"/>
</p><p>That's all that grokking means, so if we have the three required parts, we can easily make our own grokkers.</p><div class="section" title="The grokked class"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec01"/>The grokked class</h2></div></div></div><p>Any class can be grokked; there are no special requirements. This makes it easy for a developer to get started, and is a lot less confusing to work with. Imagine that we have some<code class="literal"> Mailer</code> class that we want to grok. It can be as simple as this:<a id="id435" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class Mailer(object):
pass
</pre></div><p>Of course, it could be as complex as needed, but the point is that it doesn't need to be.</p></div><div class="section" title="The directives"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec02"/>The directives</h2></div></div></div><p>Once we have a class that we want to grok, we define the directives that we may need for configuring it. Again, there's nothing required of us here. We could perhaps perform our configuration without the need for directives, but most of the time we may need a couple of them.<a id="id436" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class hostname(martian.Directive):
scope = CLASS
default = 'localhost'
class port(martian.Directive):
scope = CLASS
default = 25
</pre></div><p>Directives do need to inherit from the<code class="literal"> martian.Directive</code> subclass. Also, they need to at least specify a scope, and probably a default value as well. Here, we defined two directives<code class="literal"> hostname</code> and<code class="literal"> port</code>, which will be used to configure the mailer.<a id="id437" class="indexterm"/>
</p></div><div class="section" title="The class grokker"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec03"/>The class grokker</h2></div></div></div><p>The final piece of our grokker is the one that does the actual registration, and it comes in the form of a class that inherits from<code class="literal"> martian.ClassGrokker:</code>
<a id="id438" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class MailGrokker(martian.ClassGrokker):
martian.component(Mailer)
martian.directive(hostname)
martian.directive(port)
def execute(self, class_, hostname, port, **kw):
register_mailer(class_, hostname, port)
</pre></div><p>The grokker class connects the grokked class with its directives, and does the grokking, or registration. It has to include an<code class="literal"> execute</code> method that will take care of any configuration actions.</p><p>The<code class="literal"> martian.component</code> directive connects the grokker with the class to be grokked, in this case,<code class="literal"> Mailer</code>. The directive<code class="literal"> martian.directive</code> is used to associate the various directives that we defined earlier with this grokker.<a id="id439" class="indexterm"/>
</p><p>Finally, the<code class="literal"> execute</code> method takes the base class and the directive values declared in the code that uses the grokker, and performs the final registration. Note that the<code class="literal"> register_mailer</code> method (which would actually do the work here) is not present in the preceding code, because all we want to show here is the structure of a grokker.<a id="id440" class="indexterm"/>
</p></div><div class="section" title="The only ZCML you'll ever need"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec04"/>The only ZCML you'll ever need</h2></div></div></div><p>Once the grokker is available, it has to be configured to be initialized and used, by the Grok registration machinery at startup time. To do that, we have to use a bit of ZCML in a file named<code class="literal"> meta.zcml:</code>
<a id="id441" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;configure &gt;
&lt;grok:grok package=".meta" /&gt;
&lt;/configure&gt;
</pre></div><p>If our<code class="literal"> MailGrokker</code> class is inside the<code class="literal"> meta.py</code> file, it will be initialized by the Grok machinery.<a id="id442" class="indexterm"/>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Creating our own grokker for zope.sendmail configuration"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec04"/>Creating our own grokker for zope.sendmail configuration</h1></div></div></div><p>Now that we know how a grokker is structured, let's create one for the SMTP mailer from the<code class="literal"> zope.sendmail</code> that we used in the section about adding e-mail notifications (in Chapter 11) to our application.<a id="id443" class="indexterm"/>
</p><p>What we want is to have a simple<code class="literal"> MailGrokker</code> class declaration with<code class="literal"> hostname, port, username, password</code>, and<code class="literal"> delivery type</code> directives. This will allow us to avoid using ZCML to configure the mailer, as we were required to do in the previous section.<a id="id444" class="indexterm"/>
</p><p>We'll have to create a new package, so that our grokker is independent of the<code class="literal"> todo_plus</code> code and can be used freely elsewhere.</p><div class="section" title="Creating the package"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec05"/>Creating the package</h2></div></div></div><p>We performed these steps in the<span class="emphasis"><em> Creating the new package</em></span> section of Chapter 11. If you have any doubts, please refer to that section for details.<a id="id445" class="indexterm"/>
</p><p>To create the package, go into the<code class="literal"> src</code> directory of our main<code class="literal"> todo</code> application, and type:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ ../bin/paster create -t basic_package mailgrokker
</strong></span>
</pre></div><p>This will create a<code class="literal"> mailgrokker</code> directory. Now, navigate to this directory and add<code class="literal"> grok, martian</code>, and the<code class="literal"> zope.sendmail</code> package to the<code class="literal"> install_requires</code> declaration:</p><div class="informalexample"><pre class="programlisting">install_requires=[
'grok',
'martian',
'zope.sendmail',
],
</pre></div><p>In this way, we make sure that the required packages are present, once<code class="literal"> mailgrokker</code> is installed. We also have to add our new<code class="literal"> mailgrokker</code> package to the main<code class="literal"> buildout.cfg</code> file at the top level of our project, immediately under<code class="literal"> todo_plus</code>. Do this in both the eggs and the develop sections.</p></div><div class="section" title="Writing our grokker"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec06"/>Writing our grokker</h2></div></div></div><p>First, we'll add a<code class="literal"> configure.zcml</code> file, which is just like the one in the<code class="literal"> todo_plus</code> package. In fact, we can copy it from there:<a id="id446" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;configure   &gt;
&lt;include package="grok" /&gt;
&lt;includeDependencies package="." /&gt;
&lt;grok:grok package="." /&gt;
&lt;/configure&gt;
</pre></div><p>Our grokked class will be inside the<code class="literal"> component.py</code> file. Here, we are using only one base class, but a grokker project could include several base classes, and by convention they are defined here:</p><div class="informalexample"><pre class="programlisting">import grok
class Mailer(object):
grok.baseclass()
</pre></div><p>This is just a simple base class with no methods. The<code class="literal"> grok.baseclass</code> directive is used to mark it as a base class, although this is not mandatory.</p><p>The configuration directives are stored in a file named<code class="literal"> directives.py:</code>
<a id="id447" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">import martian
class name(martian.Directive):
scope = martian.CLASS
store = martian.ONCE
class hostname(martian.Directive):
scope = martian.CLASS
store = martian.ONCE
default = 'localhost'
class port(martian.Directive):
scope = martian.CLASS
store = martian.ONCE
default = '25'
class username(martian.Directive):
scope = martian.CLASS
store = martian.ONCE
default = None
class password(martian.Directive):
scope = martian.CLASS
store = martian.ONCE
default = None
class delivery(martian.Directive):
scope = martian.CLASS
store = martian.ONCE
default = 'queued'
class permission(martian.Directive):
scope = martian.CLASS
store = martian.ONCE
default = 'zope.Public'
</pre></div><p>This is very straightforward. We just define all of the directives that we need, and then add a<code class="literal"> martian.CLASS</code> scope. Each directive has its own default value, depending on its purpose. The intent of each directive should be obvious just by looking at the code, except perhaps for the<code class="literal"> delivery</code> directive. This directive is needed because<code class="literal"> zope.sendmail</code> includes two different delivery mechanisms<code class="literal"> direct</code> and<code class="literal"> queued</code>.</p><p>Now comes the main grokker class, which we will add to the<code class="literal"> meta.py</code> file. First, are the<code class="literal"> import</code> statements. Note that here we import<code class="literal"> martian</code> as well as<code class="literal"> GrokError</code>, which is an exception that we can throw if the grokking fails. We also import everything that we are going to use from the<code class="literal"> zope.sendmail</code> library.</p><div class="informalexample"><pre class="programlisting">import martian
from martian.error import GrokError
from zope.component import getGlobalSiteManager
from zope.sendmail.delivery import QueuedMailDelivery, DirectMailDelivery
from zope.sendmail.delivery import QueueProcessorThread
from zope.sendmail.interfaces import IMailer, IMailDelivery
from zope.sendmail.mailer import SMTPMailer
from zope.sendmail.zcml import _assertPermission
from mailgrokker.components import Mailer
from mailgrokker.directives import name, hostname, port, username, password, delivery, permission
</pre></div><p>The<code class="literal"> register_mailer</code> function creates a<code class="literal"> zope.sendmail</code> SMTP mailer object, and registers it as a named utility for<code class="literal"> IMailer</code>, with the name taken from the<code class="literal"> name</code> directive. Note the use of the<code class="literal"> getGlobalSiteManager</code> function, which is really a fancy name for getting the component registry. We use the<code class="literal"> registerUtility</code> function of the registry to add our newly created<code class="literal"> SMTPMailer</code> instance.<a id="id448" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">def register_mailer(class_, name, hostname, port, username, password, delivery, permission):
sm = getGlobalSiteManager()
mailer = SMTPMailer(hostname, port, username, password)
sm.registerUtility(mailer, IMailer, name)
</pre></div><p>Continuing with the<code class="literal"> register_mailer</code> code, we now use the selected delivery mechanism, which was passed as a parameter, to decide if we should initialize a<code class="literal"> DirectMailDelivery</code> instance or a<code class="literal"> QueuedMailDelivery</code> instance. Either way, we register the result as a utility.</p><p>In the case of a<code class="literal"> queue</code> delivery mechanism, a thread that will take care of sending e-mail separately from the main application code is started.</p><div class="informalexample"><pre class="programlisting">if delivery=='direct':
mail_delivery = DirectMailDelivery(mailer)
_assertPermission(permission, IMailDelivery, mail_delivery)
sm.registerUtility(mail_delivery, IMailDelivery, name)
elif delivery=='queued':
mail_delivery = QueuedMailDelivery(name)
_assertPermission(permission, IMailDelivery, mail_delivery)
sm.registerUtility(mail_delivery, IMailDelivery, name)
thread = QueueProcessorThread()
thread.setMailer(mailer)
thread.setQueuePath(name)
thread.start()
else:
raise GrokError("Available delivery methods are 'direct' and 'queued'. Delivery method %s is not defined.",class_)
</pre></div><p>The<code class="literal"> MailGrokker</code> class declares all of the directives that we added to the<code class="literal"> directives</code> module, and associates itself with the<code class="literal"> Mailer</code> class that it will grok. It then defines the<code class="literal"> execute</code> method that will call the<code class="literal"> register_mailer</code> function to perform the required<code class="literal"> zope.sendmail</code> registrations.<a id="id449" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class MailGrokker(martian.ClassGrokker):
martian.component(Mailer)
martian.directive(name)
martian.directive(hostname)
martian.directive(port)
martian.directive(username)
martian.directive(password)
martian.directive(delivery)
martian.directive(permission)
def execute(self, class_, config, name, hostname, port, username, password, delivery, permission, **kwds):
config.action(
discriminator = ('utility', IMailer, name),
callable = register_mailer,
args = (class_, name, hostname, port, username, password, delivery, permission),
order = 5
)
return True
</pre></div><p>The only difference between the above code and the code that we showed earlier is that instead of calling the<code class="literal"> register_mailer</code> function directly, we wrap it inside a<code class="literal"> config.action</code> object. This is done so that Grok can perform the registrations in an arbitrary order after the code is loaded, instead of doing that as it initializes each package. This prevents any configuration conflicts, and allows us to be specific about the registration conditions.</p><p>For example, the<code class="literal"> discriminator</code> parameter, which could be empty, is, in this case, a tuple containing the string<code class="literal"> utility</code>, the interface<code class="literal"> IMailer</code>, and the value of the<code class="literal"> name</code> directive. If any other grokker package uses this same discriminator, Grok will signal a conflict error condition.</p><p>The<code class="literal"> order</code> parameter of the<code class="literal"> action</code> is used to dictate the order in which the actions are called, although here it was added for demonstration purposes only. The<code class="literal"> callable</code> parameter is the function that will perform the registration, and the<code class="literal"> args</code> parameter contains the parameters that will be passed to it.</p><p>We now have our grokker in the<code class="literal"> meta</code> module, and need to tell Grok to find it here, which we do by adding the small<code class="literal"> meta.zcml</code> file discussed earlier:</p><div class="informalexample"><pre class="programlisting">&lt;configure &gt;
&lt;grok:grok package=".meta" /&gt;
&lt;/configure&gt;
</pre></div><p>Finally, edit the existing<code class="literal"> __init__.py</code> file, which is inside<code class="literal"> src/mailgrokker/mailgrokker</code> directory, to look like the following code:</p><div class="informalexample"><pre class="programlisting">from mailgrokker.directives import name, hostname, port, username, password, del ivery, permission
from mailgrokker.components import Mailer
</pre></div><p>This will allow us to use the directives simply by importing the main<code class="literal"> mailgrokker</code> module, much in the way that<code class="literal"> grok.*</code> directives work.</p></div><div class="section" title="Using mailgrokker"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec07"/>Using mailgrokker</h2></div></div></div><p>Now that we are done with our grokker, the only thing that is missing is to show how it would be used inside an application. We will add it to the<code class="literal"> todo_plus</code> package. Insert the following lines at the bottom of that file:<a id="id450" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">import mailgrokker
class TodoMailer(mailgrokker.Mailer):
mailgrokker.name('todoplus')
mailgrokker.hostname('smtp.example.com')
mailgrokker.username('cguardia')
mailgrokker.password('password')
</pre></div><p>Obviously, you should substitute the values shown here with the real values of your<code class="literal"> smtp</code> server. You might also want to eliminate the mailer configuration that we placed in the<code class="literal"> configure.zcml</code> file, earlier.</p><p>Done. We have now created a small grokker package that can be used in any of our applications in order to easily configure e-mail submissions.<a id="id451" class="indexterm"/>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec05"/>Summary</h1></div></div></div><p>In this chapter we learned about the Martian library and how it enables Grok to be an agile framework. We are now ready to discuss how to debug our applications.</p></div></div>
</body></html>