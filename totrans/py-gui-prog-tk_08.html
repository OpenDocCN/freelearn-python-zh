<html><head></head><body>
  <div><h1 class="chapterNumber">8</h1>
    <h1 id="_idParaDest-181" class="chapterTitle">Navigating Records with Treeview and Notebook</h1>
    <p class="normal">You've received another request for features in the application. Now that your users can open arbitrary files for appending, they'd like to be able to see what's in those files and correct old records using the data entry form they've grown accustomed to, rather than having to switch over to a spreadsheet. In a nutshell, it's finally time to implement read and update capabilities in our application.</p>
    <p class="normal">In this chapter, we're going to cover the following topics:</p>
    <ul>
      <li class="bullet">In <em class="italic">Implementing read and update in the model</em>, we'll modify our CSV model for read and update capabilities.</li>
      <li class="bullet">In <em class="italic">The Ttk Treeview</em>, we'll explore the Ttk <code class="Code-In-Text--PACKT-">Treeview</code> widget.</li>
      <li class="bullet">In <em class="italic">Implementing a record list with Treeview</em>, we'll use our knowledge of the <code class="Code-In-Text--PACKT-">Treeview</code> widget to create an interactive display of records in the CSV file.</li>
      <li class="bullet">In <em class="italic">Adding the record list to the application</em>, we'll incorporate our new record list view into our application using the Ttk <code class="Code-In-Text--PACKT-">Notebook</code> widget.</li>
    </ul>
    <h1 id="_idParaDest-182" class="title">Implementing read and update in the model</h1>
    <p class="normal">Our entire design up to this point has been centered around a form that only appends data to a file; adding read and update<a id="_idIndexMarker607"/> capabilities is a fundamental change that will touch nearly every portion of the application. </p>
    <p class="normal">It may seem like a daunting task, but by taking it one component at a time, we'll see that the changes are not so overwhelming.</p>
    <p class="normal">The first thing we should do is update our documentation. Open the <code class="Code-In-Text--PACKT-">abq_data_entry_spec.rst</code> file in the <code class="Code-In-Text--PACKT-">docs</code> folder, and let's start with the Requirements section:</p>
    <pre class="programlisting code"><code class="hljs-code">Functional Requirements:
  * Provide a UI for reading, updating, and appending 
    data to the CSV file
  * ...
</code></pre>
    <p class="normal">And, of course, we should<a id="_idIndexMarker608"/> also update the part that is not required, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">The program does not need to:
  * Allow deletion of data.
</code></pre>
    <p class="normal">Now, it's a simple matter of making the code match with the documentation. Let's get started!</p>
    <h2 id="_idParaDest-183" class="title">Adding read and update to the CSVModel class</h2>
    <p class="normal">Take a moment to consider what's missing from the <code class="Code-In-Text--PACKT-">CSVModel</code> class that we'll need to add for read and update<a id="_idIndexMarker609"/> functionality:</p>
    <ul>
      <li class="bullet">We'll need a method that can retrieve all records in a file so we can display them. We'll call it <code class="Code-In-Text--PACKT-">get_all_records()</code>.</li>
      <li class="bullet">We'll need a method to fetch individual records from the file by row number. We can call this one <code class="Code-In-Text--PACKT-">get_record()</code>.</li>
      <li class="bullet">We'll need to save records in a way that can not only append new records but update existing records as well. We can update our <code class="Code-In-Text--PACKT-">save_record()</code> method to accommodate this.</li>
    </ul>
    <p class="normal">Open up <code class="Code-In-Text--PACKT-">models.py</code> in your editor, and let's work through making these changes.</p>
    <h3 id="_idParaDest-184" class="title">Implementing get_all_records()</h3>
    <p class="normal">Let's start a new<a id="_idIndexMarker610"/> method in <code class="Code-In-Text--PACKT-">CSVModel</code> called<a id="_idIndexMarker611"/> <code class="Code-In-Text--PACKT-">get_all_records()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"># models.py, in the CSVModel class
  def get_all_records(self):
    """Read in all records from the CSV and return a list"""
    if not self.file.exists():
      return []
</code></pre>
    <p class="normal">The first thing we've done is check if the model's file exists yet (recall that <code class="Code-In-Text--PACKT-">self.file</code> is a <code class="Code-In-Text--PACKT-">Path</code> object, so we can just call <code class="Code-In-Text--PACKT-">exists()</code> to see if it exists). When our users start the program each morning, the <code class="Code-In-Text--PACKT-">CSVModel</code> generates a default filename pointing to a file that likely doesn't exist yet, so <code class="Code-In-Text--PACKT-">get_all_records()</code> will need to handle this situation gracefully. It makes sense to return an empty list in this case, since there's no data if the file doesn't exist.</p>
    <p class="normal">If the file does exist, we will open it in read-only mode and get all the records. We could do that like this:</p>
    <pre class="programlisting code"><code class="hljs-code">    with open(self.file, 'r') as fh:
      csvreader = csv.DictReader(fh)
      records = list(csvreader)
</code></pre>
    <p class="normal">While not terribly<a id="_idIndexMarker612"/> efficient, pulling the entire file into memory<a id="_idIndexMarker613"/> and converting it into a list is acceptable in our case, since we know that our largest files should be limited to a mere 241 rows: 20 plots times 3 labs times 4 check sessions, plus a header row. That amount of data is easy work for Python, even on an old workstation. This method is just a little too trusting, however. We should at least do some sanity checks to make sure that the user has actually opened a CSV file containing the proper fields and not some other arbitrary file, which would likely crash the program.</p>
    <p class="normal">Let's revise the method so that it will check the file for the correct field structure:</p>
    <pre class="programlisting code"><code class="hljs-code"># models.py, inside CSVModel.get_all_records()
    with open(self.file, 'r', encoding='utf-8') as fh:
      csvreader = csv.DictReader(fh.readlines())
      missing_fields = (
        set(self.fields.keys()) - set(csvreader.fieldnames)
      )
      if len(missing_fields) &gt; 0:
        fields_string = ', '.join(missing_fields)
        raise Exception(
          f"File is missing fields: {fields_string}"
        )
      records = list(csvreader)
</code></pre>
    <p class="normal">In this version, we first find any missing fields by comparing the <code class="Code-In-Text--PACKT-">CSVModel.fields</code> dictionary keys to the <code class="Code-In-Text--PACKT-">fieldnames</code> list in the CSV file. To find the missing fields, we're using a simple trick involving the Python <code class="Code-In-Text--PACKT-">set</code> type: if we convert both lists to <code class="Code-In-Text--PACKT-">set</code> objects, we can subtract one from the other, leaving us with a <code class="Code-In-Text--PACKT-">set</code> object containing the fields from the first list (our <code class="Code-In-Text--PACKT-">fields</code> keys) that were missing from the second list (the CSV field names).</p>
    <p class="normal">If <code class="Code-In-Text--PACKT-">missing_fields</code> has any items, those are missing fields from the CSV file. We'll raise an exception in this case, detailing which fields<a id="_idIndexMarker614"/> are absent. Otherwise, we convert<a id="_idIndexMarker615"/> the CSV data to a list, as we did in our simpler version of the method.</p>
    <div><p class="Tip--PACKT-">Python <code class="Code-In-Text--PACKT-">set</code> objects are very useful for comparing the content of the list, tuple, and other sequence objects. They provide an easy way to get information such as the difference (items in <em class="italic">x</em> that are not in <em class="italic">y</em>) or intersection (items in both <em class="italic">x</em> and <em class="italic">y</em>) between two sets and allow you to compare sequences without respect to order.</p>
    </div>
    <p class="normal">Before we can return the <code class="Code-In-Text--PACKT-">records</code> list from the method, we need to correct one issue; all data in a CSV file is stored as text, and read by Python as a string. Most of this is not a problem, since Tkinter will take care of converting strings to <code class="Code-In-Text--PACKT-">float</code> or <code class="Code-In-Text--PACKT-">int</code> as necessary. Boolean values, however, are stored in the CSV file as the strings <code class="Code-In-Text--PACKT-">True</code> and <code class="Code-In-Text--PACKT-">False</code>, and coercing these values directly back to <code class="Code-In-Text--PACKT-">bool</code> doesn't work. The string <code class="Code-In-Text--PACKT-">False</code> is a non-empty string, and all non-empty strings evaluate to <code class="Code-In-Text--PACKT-">True</code> in Python.</p>
    <p class="normal">To fix this, let's first define a list of strings that should be interpreted as <code class="Code-In-Text--PACKT-">True</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"># models.py, inside CSVModel.get_all_records()
    trues = ('true', 'yes', '1')
</code></pre>
    <p class="normal">Any values not in this list will be considered <code class="Code-In-Text--PACKT-">False</code>. We'll do a case-insensitive comparison, so there are only lowercase values in our list.</p>
    <p class="normal">Next, we create a list of model fields that are Boolean using a list comprehension, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">    bool_fields = [
      key for key, meta
      in self.fields.items()
      if meta['type'] == FT.boolean
    ]
</code></pre>
    <p class="normal">Technically, we know that Equipment Fault is our only Boolean field, so in reality, we could just hard-code the method to correct that field. However, it's wiser to design the model so that any changes to the schema will be automatically handled appropriately by the logic portions. If fields are added or altered, we should ideally only need to alter the field specification and the rest of the model code should behave correctly.</p>
    <p class="normal">Now, let's iterate through the records and correct all the Boolean fields in each row:</p>
    <pre class="programlisting code"><code class="hljs-code">    for record in records:
      for key in bool_fields:
        record[key] = record[key].lower() in trues
</code></pre>
    <p class="normal">For every record, we iterate<a id="_idIndexMarker616"/> through our list of the Boolean fields and check<a id="_idIndexMarker617"/> the field's value against our list of truthy strings, setting the value of the item accordingly.</p>
    <p class="normal">With the Boolean values fixed, we can finish our function by returning the list of records, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">    return records
</code></pre>
    <div><p class="Tip--PACKT-">Note that the rows returned by this method are dictionaries in the same format expected by the <code class="Code-In-Text--PACKT-">save_record()</code> method when saving data. It's good practice for the model to be consistent about the way it represents data. In a more robust model, you might even make a class to represent a row of data, though for simpler applications a dictionary usually serves as well.</p>
    </div>
    <h3 id="_idParaDest-185" class="title">Implementing get_record()</h3>
    <p class="normal">The <code class="Code-In-Text--PACKT-">get_record()</code> method needs to take a row number and return a single dictionary containing the data<a id="_idIndexMarker618"/> for that row. Given that we are dealing in very small<a id="_idIndexMarker619"/> amounts of data, we can simply leverage the <code class="Code-In-Text--PACKT-">get_all_records()</code> method we just wrote and take care of this in just a few lines, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># models.py, inside the CSVModel class
  def get_record(self, rownum):
    return self.get_all_records()[rownum]
</code></pre>
    <p class="normal">Keep in mind, however, that it's possible to pass a <code class="Code-In-Text--PACKT-">rownum</code> value that doesn't exist in our records list; in this case, Python would raise an <code class="Code-In-Text--PACKT-">IndexError</code> exception. </p>
    <p class="normal">Since there's no meaningful way for us to handle that situation inside the model, we'll need to remember to have our controller<a id="_idIndexMarker620"/> catch this exception and<a id="_idIndexMarker621"/> deal with it appropriately when using this method.</p>
    <h3 id="_idParaDest-186" class="title">Adding update capability to save_record()</h3>
    <p class="normal">To convert our <code class="Code-In-Text--PACKT-">save_record()</code> method so that we can update records, the first thing we'll need to do is provide<a id="_idIndexMarker622"/> the ability to pass in a row<a id="_idIndexMarker623"/> number to update. The default will be <code class="Code-In-Text--PACKT-">None</code>, which will indicate that the data<a id="_idIndexMarker624"/> is a new row that should be appended to the file.</p>
    <p class="normal">The updated method signature looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"># models.py, in the CSVModel class
  def save_record(self, data, rownum=None):
    """Save a dict of data to the CSV file"""
</code></pre>
    <p class="normal">Our existing record-saving logic doesn't need to change, but it should only be run if <code class="Code-In-Text--PACKT-">rownum</code> is <code class="Code-In-Text--PACKT-">None</code>.</p>
    <p class="normal">So, the first thing to do in the method is check <code class="Code-In-Text--PACKT-">rownum</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">    if rownum is None:
      # This is a new record
      newfile = not self.file.exists()
      with open(self.file, 'a') as fh:
        csvwriter = csv.DictWriter(fh, fieldnames=self.fields.keys())
        if newfile:
          csvwriter.writeheader()
        csvwriter.writerow(data)
</code></pre>
    <p class="normal">If <code class="Code-In-Text--PACKT-">rownum</code> is <code class="Code-In-Text--PACKT-">None</code>, we're just running our existing code: writing a header if the file doesn't exist, and then appending the row to the end of the file.</p>
    <p class="normal">In the case that the <code class="Code-In-Text--PACKT-">rownum</code> is <em class="italic">not</em> <code class="Code-In-Text--PACKT-">None</code>, we'll need to update the given row and save the file. There are several approaches to this task, but for relatively small files, the simplest way to update a single row is:</p>
    <ol>
      <li class="numbered">Load the entire file into a list</li>
      <li class="numbered">Change the row in the list</li>
      <li class="numbered">Write the entire list back to a clean file</li>
    </ol>
    <p class="normal">That may seem inefficient, but again, we're dealing with very small amounts of data. A more surgical approach would<a id="_idIndexMarker625"/> only be required with much larger sets of data (more than should be stored<a id="_idIndexMarker626"/> in a CSV file, for sure!).</p>
    <p class="normal">So, let's add<a id="_idIndexMarker627"/> the following code that does this:</p>
    <pre class="programlisting code"><code class="hljs-code"># models.py, inside CSVModel.save_record()
    else:
      # This is an update
      records = self.get_all_records()
      records[rownum] = data
      with open(self.file, 'w', encoding='utf-8') as fh:
        csvwriter = csv.DictWriter(fh, fieldnames=self.fields.keys())
        csvwriter.writeheader()
        csvwriter.writerows(records)
</code></pre>
    <p class="normal">Once again, we leverage our <code class="Code-In-Text--PACKT-">get_all_records()</code> method to fetch the CSV file's content into a list. We then replace the dictionary in the requested row with the data dictionary provided. Finally, we open the file in write mode (<code class="Code-In-Text--PACKT-">w</code>), which will clear its content and replace it with whatever content we write to the file. We then write the header and all records back to the empty file.</p>
    <div><p class="Information-Box--PACKT-">Note that the approach we're taking makes it unsafe for two users to work in the same CSV file simultaneously. Creating software that allows multiple users to edit a single file at the same time is notoriously difficult, and many programs simply opt to prevent it in the first place using lock files or other protection mechanisms. In <em class="chapterRef">Chapter 12</em>, <em class="italic">Improving Data Storage with SQL</em>, we'll update our program so that multiple users can use it simultaneously. </p>
    </div>
    <p class="normal">This method is finished, and that's all we need to change in our model to enable the updating and viewing of data. Now, it's time to add the necessary features to our GUI.</p>
    <h1 id="_idParaDest-187" class="title">The Ttk Treeview</h1>
    <p class="normal">For users to be able to view the contents of a CSV file and select records to edit, we'll need to implement a new view in the application capable of displaying tabular data. This record list view<a id="_idIndexMarker628"/> will allow our users to browse the content of the file and open records for viewing or editing. </p>
    <p class="normal">Our users are accustomed to seeing this data in a spreadsheet, laid out in a table-like format, so it makes sense to design our view in a similar fashion.</p>
    <p class="normal">For building table-like views with selectable rows, Tkinter gives us the <strong class="keyword">Ttk Treeview</strong> widget. To build our record list view, we'll need to learn about <code class="Code-In-Text--PACKT-">Treeview</code>.</p>
    <h2 id="_idParaDest-188" class="title">Anatomy of a Treeview</h2>
    <p class="normal">To help us explore the treeview, let's go through<a id="_idIndexMarker629"/> a few basic terms and concepts related to the widget. A treeview<a id="_idIndexMarker630"/> is designed to display <strong class="keyword">hierarchical data</strong>; that is, data that is organized into <strong class="keyword">nodes</strong>, where each node can have exactly one parent node and zero or more<a id="_idIndexMarker631"/> child nodes. The following diagram shows an example of hierarchical data:</p>
    <figure class="mediaobject"><img src="img/B17578_08_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.1: A small hierarchical data structure. Nodes 1, 2, and 3 are children of the root, nodes 4 and 5 are children of node 1; "value" is an attribute of each node.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Treeview</code> widget displays hierarchical data in a table format; each row of the table represents a single node, which it calls an <strong class="keyword">item</strong>. Each column of the table represents some attribute of the node. When<a id="_idIndexMarker632"/> a node has child nodes, those rows are displayed under their parent and can be hidden or shown by clicking the parent row. </p>
    <p class="normal">For example, the hierarchy pictured above in a <code class="Code-In-Text--PACKT-">Treeview</code> would look like this:</p>
    <figure class="mediaobject"><img src="img/B17578_08_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 8.2: The berry hierarchy displayed in a Treeview widget</p>
    <p class="normal">Each item in a treeview<a id="_idIndexMarker633"/> is identified by a unique <strong class="keyword">item identifier </strong>(<strong class="keyword">IID</strong>), and each column by a <strong class="keyword">column identifier</strong> (<strong class="keyword">CID</strong>). These values are strings, and you can either assign them manually or let the widget<a id="_idIndexMarker634"/> choose them automatically.</p>
    <p class="normal">At the top<a id="_idIndexMarker635"/> of the treeview's columns are <strong class="keyword">header widgets</strong>. These are buttons that can display the name<a id="_idIndexMarker636"/> of each column, and optionally run a callback when clicked.</p>
    <p class="normal">The first column of the <code class="Code-In-Text--PACKT-">Treeview</code> widget is known as the <strong class="keyword">icon column</strong> and has a CID of <code class="Code-In-Text--PACKT-">#0</code>. It cannot be<a id="_idIndexMarker637"/> removed, nor can its CID be altered. Typically it contains identifying information about the item.</p>
    <h2 id="_idParaDest-189" class="title">Building a file browser</h2>
    <p class="normal">Perhaps the best example of the kind of data<a id="_idIndexMarker638"/> we can represent in a treeview is a filesystem<a id="_idIndexMarker639"/> tree:</p>
    <ul>
      <li class="bullet">Each row can represent a file or directory</li>
      <li class="bullet">Each directory can contain additional files or directories</li>
      <li class="bullet">Each row can have additional data properties, such as permissions, size, or ownership information</li>
    </ul>
    <p class="normal">To better understand how a <code class="Code-In-Text--PACKT-">Treeview</code> widget works, let's create a simple file browser.</p>
    <p class="normal">Open a new file called <code class="Code-In-Text--PACKT-">treeview_demo.py</code> and start with this template:</p>
    <pre class="programlisting code"><code class="hljs-code"># treeview_demo.py
import tkinter as tk
from tkinter import ttk
from pathlib import Path
root = tk.Tk()
# Code will go here
root.mainloop()
</code></pre>
    <p class="normal">We'll start by getting a list of all the file paths under the current working directory. <code class="Code-In-Text--PACKT-">Path</code> has a method called <code class="Code-In-Text--PACKT-">glob()</code> that will give us such a list. Add this line just below the <code class="Code-In-Text--PACKT-">root = tk.Tk()</code> line:</p>
    <pre class="programlisting code"><code class="hljs-code">paths = Path('.').glob('**/*')
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">glob()</code> searches a file path for files or directories matching a filesystem-matching expression. The expression can contain wildcard characters like <code class="Code-In-Text--PACKT-">*</code> (which means "zero or more characters") and <code class="Code-In-Text--PACKT-">?</code> (which means "a single character"). The name "glob" goes back to a very early Unix command, though this same wildcard syntax is now used across most modern operating systems' command-line interfaces.</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">Path('.')</code> creates a path object referencing the current working directory, and <code class="Code-In-Text--PACKT-">**/*</code> is a special wildcard syntax that recursively grabs all objects under the path. Given that wildcard expression, the <code class="Code-In-Text--PACKT-">glob()</code> method returns a list of the <code class="Code-In-Text--PACKT-">Path</code> objects that include every directory and file under our current directory.</p>
    <h3 id="_idParaDest-190" class="title">Creating and configuring a Treeview</h3>
    <p class="normal">Now that we have some<a id="_idIndexMarker640"/> data to display, let's create a <code class="Code-In-Text--PACKT-">Treeview</code> widget<a id="_idIndexMarker641"/> to display it, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">tv = ttk.Treeview(
  root, columns=['size', 'modified'], selectmode='none'
)
</code></pre>
    <p class="normal">Like any Tkinter widget, the first argument to <code class="Code-In-Text--PACKT-">Treeview</code> is its parent widget. Next, we've passed in a list<a id="_idIndexMarker642"/> of strings to the <code class="Code-In-Text--PACKT-">column</code> argument. These are the CID values for our columns. Note that these columns<a id="_idIndexMarker643"/> are <em class="italic">in addition to</em> the default icon column, so this <code class="Code-In-Text--PACKT-">Treeview</code> widget will have 3 total columns: <code class="Code-In-Text--PACKT-">#0</code>, <code class="Code-In-Text--PACKT-">size</code>, and <code class="Code-In-Text--PACKT-">modified</code>.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">selectmode</code> argument determines how users can select items in the tree. The different options for <code class="Code-In-Text--PACKT-">selectmode</code> are shown here:</p>
    <table id="table001-4" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Value</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Behavior</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">"none"</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">No selections can be made</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">"browse"</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">User can select one item only</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">"extended"</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">User can select multiple items</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">In this case, we're preventing selection, so we set it to <code class="Code-In-Text--PACKT-">none</code> (note that this is the string <code class="Code-In-Text--PACKT-">none</code>, not a <code class="Code-In-Text--PACKT-">None</code> object).</p>
    <p class="normal">While Tkinter will add a column for each CID value, it will not automatically give those columns a header label. We need to do that ourselves using the <code class="Code-In-Text--PACKT-">Treeview.heading()</code> method, like this:</p>
    <pre class="programlisting code"><code class="hljs-code">tv.heading('#0', text='Name')
tv.heading('size', text='Size', anchor='center')
tv.heading('modified', text='Modified', anchor='e')
</code></pre>
    <p class="normal">The treeview's <code class="Code-In-Text--PACKT-">heading()</code> method allows us to configure the column heading widget; it takes the CID of the column we wish to operate on, followed by any number of keyword arguments to configure the header widget.</p>
    <p class="normal">Those attributes can include:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">text</code>: The text displayed for the heading. By default, it's blank.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">anchor</code>: The alignment of the text; it can be any of eight cardinal directions or <code class="Code-In-Text--PACKT-">center</code>, specified as strings or Tkinter constants.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">command</code>: A callback to run when the heading is clicked. This might be used to order the rows by that column, or select all the values in the column, for example.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">image</code>: An image to display in the heading.</li>
    </ul>
    <p class="normal">In addition to configuring the headers, we can configure some attributes that affect the entire column using the <code class="Code-In-Text--PACKT-">Treeview.column()</code> method.</p>
    <p class="normal">For example:</p>
    <pre class="programlisting code"><code class="hljs-code">tv.column('#0', stretch=True)
tv.column('size', width=200)
</code></pre>
    <p class="normal">In this code, we've set <code class="Code-In-Text--PACKT-">stretch=True</code> in the first<a id="_idIndexMarker644"/> column, which<a id="_idIndexMarker645"/> will cause it to expand to fill any available<a id="_idIndexMarker646"/> space. Then we've set the <code class="Code-In-Text--PACKT-">width</code> value<a id="_idIndexMarker647"/> on the <code class="Code-In-Text--PACKT-">size</code> column to <code class="Code-In-Text--PACKT-">200</code> pixels.</p>
    <p class="normal">The column parameters that can be set include:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">stretch</code>: Whether or not to expand this column to fill the available space.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">width</code>: The width of the column in pixels.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">minwidth</code>: The minimum width to which the column can be resized, in pixels.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">anchor</code>: The alignment of the text in the column. Can be any of eight cardinal directions or <code class="Code-In-Text--PACKT-">center</code>, specified as strings or Tkinter constants.</li>
    </ul>
    <p class="normal">With the treeview configured, let's add it into the GUI, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">tv.pack(expand=True, fill='both')
</code></pre>
    <h3 id="_idParaDest-191" class="title">Populating a Treeview with data</h3>
    <p class="normal">Now that we've finished<a id="_idIndexMarker648"/> the GUI portion, our view needs to be filled<a id="_idIndexMarker649"/> with data. Populating a <code class="Code-In-Text--PACKT-">Treeview</code> widget with data is done one row at a time<a id="_idIndexMarker650"/> using its <code class="Code-In-Text--PACKT-">insert()</code> method.</p>
    <p class="normal">A basic call to the <code class="Code-In-Text--PACKT-">insert()</code> method looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">mytreeview.insert(
  parent, 'end', iid='item1',
  text='My Item 1', values=['12', '42']
)
</code></pre>
    <p class="normal">The first argument specifies the <strong class="keyword">parent item</strong> for the inserted row. This is <em class="italic">not</em> the parent widget, but rather the IID of the parent node under<a id="_idIndexMarker651"/> which the inserted node belongs in the hierarchical structure. For top-level items, this value should be an empty string.</p>
    <p class="normal">The next argument specifies where the<a id="_idIndexMarker652"/> item should be inserted under its parent node with respect to its sibling<a id="_idIndexMarker653"/> nodes. It can be either a numerical index or the string <code class="Code-In-Text--PACKT-">end</code>, which<a id="_idIndexMarker654"/> places the item at the end of the list.</p>
    <p class="normal">After those positional arguments, <code class="Code-In-Text--PACKT-">insert()</code> takes a number of keyword arguments, which can include:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">text</code>: This is the value to be shown in the icon column (CID <code class="Code-In-Text--PACKT-">#0</code>).</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">values</code>: This is a list of values for the remaining columns. Note that we need to specify them in order.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">image</code>: This is an image object to display in the far left of the icon column.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">iid</code>: The row's IID string. This will be automatically assigned if you don't specify it.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">open</code>: For nodes with children, this sets if the row is initially open (displaying child items) or not.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">tags</code>: A list of tag strings. We'll learn more about tags when we discuss styling in <em class="chapterRef">Chapter 9</em>, <em class="italic">Improving the Look with Styles and Themes</em>.</li>
    </ul>
    <p class="normal">To insert our file paths into the treeview, let's iterate the <code class="Code-In-Text--PACKT-">paths</code> list as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">for path in paths:
  meta = path.stat()
  parent = str(path.parent)
  if parent == '.':
    parent = ''
</code></pre>
    <p class="normal">Before calling <code class="Code-In-Text--PACKT-">insert()</code>, we need to extract and prepare some data from the <code class="Code-In-Text--PACKT-">path</code> object. The <code class="Code-In-Text--PACKT-">path.stat()</code> method will give us an object containing various file information, from which we'll extract the size and modified time. <code class="Code-In-Text--PACKT-">path.parent</code> provides us with the containing path; however, we need to change the name of the root path (currently a single dot) to an empty string, which is how <code class="Code-In-Text--PACKT-">Treeview</code> represents the root node.</p>
    <p class="normal">Now, still in the <code class="Code-In-Text--PACKT-">for</code> loop, we add the <code class="Code-In-Text--PACKT-">insert()</code> method call as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">  tv.insert(
    parent,
    'end',
    iid=str(path),
    text=str(path.name),
    values=[meta.st_size, meta.st_mtime]
  )
</code></pre>
    <p class="normal">By using the path string as the IID, we can then specify it as a parent for its child objects. We use only the path<a id="_idIndexMarker655"/> name (that is, the file or directory name without the containing<a id="_idIndexMarker656"/> path) as our display value, then retrieve <code class="Code-In-Text--PACKT-">st_size</code> and <code class="Code-In-Text--PACKT-">st_mtime</code> from the <code class="Code-In-Text--PACKT-">stat()</code> data for populating the size and<a id="_idIndexMarker657"/> modification time columns.</p>
    <p class="normal">Run this script and you should see a simple file tree browser that looks something like this:</p>
    <figure class="mediaobject"><img src="img/B17578_08_03.png" alt="Figure 8.1: Our Treeview filebrowser running on Ubuntu Linux"/></figure>
    <p class="packt_figref">Figure 8.3: Our Treeview widget file browser running on Ubuntu Linux</p>
    <h3 id="_idParaDest-192" class="title">Sorting Treeview records</h3>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Treeview</code> widget doesn't offer any kind of sorting functionality by default, but we can implement sorting<a id="_idIndexMarker658"/> by adding a callback function to the column headers.</p>
    <p class="normal">Sorting through hierarchical<a id="_idIndexMarker659"/> data of an unknown depth is a bit tricky; to do it, we're going to write a <strong class="keyword">recursive function</strong>. A recursive function is a function that calls itself, and they<a id="_idIndexMarker660"/> are most commonly employed when dealing with hierarchical data of unknown depth.</p>
    <p class="normal">Let's start by defining our function signature, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">def sort(tv, col, parent='', reverse=False):
</code></pre>
    <p class="normal">This <code class="Code-In-Text--PACKT-">sort()</code> function takes a <code class="Code-In-Text--PACKT-">Treeview</code> widget, a CID string of the column we want to sort on, an optional parent node IID, and a Boolean value indicating if the sort should be reversed. The default value for <code class="Code-In-Text--PACKT-">parent</code> is an empty string, indicating the root of the hierarchy.</p>
    <p class="normal">The first thing we're going to do is build a list of tuples, each containing the value we want to sort on and the IID of the row containing that value, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">  sort_index = list()
  for iid in tv.get_children(parent):
    sort_value = tv.set(iid, col) if col != '#0' else iid
    sort_index.append((sort_value, iid))
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Treeview.get_children()</code> method retrieves a list of IID strings that are immediate children of the given <code class="Code-In-Text--PACKT-">parent</code> IID. For example, in our file browser, calling <code class="Code-In-Text--PACKT-">tv.get_children('')</code> would return a list of all the IID values for the files and folders in the current directory (not in any sub-directories).</p>
    <p class="normal">Once we have this list, we iterate through it and start building a list we can sort on. To do this, we need to retrieve the contents of the sort column for each IID. Rather confusingly, this is done using the <code class="Code-In-Text--PACKT-">Treeview.set()</code> method. <code class="Code-In-Text--PACKT-">Treeview.set()</code> can be called with either two or three arguments, the first two always being the IID and CID of the cell we want to reference. If the third argument is present, <code class="Code-In-Text--PACKT-">set()</code> will write that value to the cell. If it is omitted, <code class="Code-In-Text--PACKT-">set()</code> will return the current value of that cell. There is no <code class="Code-In-Text--PACKT-">Treeview.get()</code> method, so this is how we retrieve the value of a particular cell.</p>
    <p class="normal">However, <code class="Code-In-Text--PACKT-">set()</code> cannot be called on CID <code class="Code-In-Text--PACKT-">#0</code>, even if we only want to retrieve the value. So we have added a check in case the user is sorting on that column, and return the IID instead. After obtaining the contents of the table cell, we add it with its IID to the <code class="Code-In-Text--PACKT-">sort_index</code> list.</p>
    <p class="normal">Now, we can sort the index:</p>
    <pre class="programlisting code"><code class="hljs-code">  sort_index.sort(reverse=reverse)
</code></pre>
    <p class="normal">Because our table cell value<a id="_idIndexMarker661"/> is first in each tuple, the tuples will be sorted on it by default. Note that we've passed in the <code class="Code-In-Text--PACKT-">reverse</code> value, to indicate which direction the list will be sorted in.</p>
    <p class="normal">Now that we have<a id="_idIndexMarker662"/> a sorted list, we'll need to move each node accordingly. Add this code next:</p>
    <pre class="programlisting code"><code class="hljs-code">  for index, (_, iid) in enumerate(sort_index):
    tv.move(iid, parent, index)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">enumerate()</code> function returns a tuple containing each item in the list with an integer indicating its index in the list. Since each item in our list is already a tuple, we're expanding that as well, giving us three variables: <code class="Code-In-Text--PACKT-">index</code>, the index number of the list item; <code class="Code-In-Text--PACKT-">_</code>, the sort value (which we no longer need, so we're naming it with an underscore); and <code class="Code-In-Text--PACKT-">iid</code>.</p>
    <p class="normal">For each item in the list, we call <code class="Code-In-Text--PACKT-">Treeview.move()</code>, which takes three arguments: the IID of the row we want to move, the parent node to which we want to move it, and the index under that node into which<a id="_idIndexMarker663"/> it should be inserted. This will effectively sort the rows according to the order of the <code class="Code-In-Text--PACKT-">sort_index</code> list.</p>
    <p class="normal">So far, though, this has only sorted the immediate children of our root node. Now it is time to employ recursion so that we can sort all the child nodes; this takes only one additional line of code:</p>
    <pre class="programlisting code"><code class="hljs-code">  for index, (_, iid) in enumerate(sort_index):
    tv.move(iid, parent, index)
    <strong class="hljs-slc">sort(tv, col, parent=iid, reverse=reverse)</strong>
</code></pre>
    <p class="normal">The last line of the <code class="Code-In-Text--PACKT-">for</code> loop calls the <code class="Code-In-Text--PACKT-">sort()</code> function again, this time passing in the child IID as the parent, and all other arguments the same. <code class="Code-In-Text--PACKT-">sort()</code> will continue to call itself recursively until it reaches a node that has no children. In the case where a node has no children, that call to <code class="Code-In-Text--PACKT-">sort()</code> will return without doing anything. In this way, all sub-directories containing files will be individually sorted by their own call to <code class="Code-In-Text--PACKT-">sort()</code>.</p>
    <p class="normal">To use our <code class="Code-In-Text--PACKT-">sort()</code> function, we need to bind it to our column headers; we can do that once again by calling the <code class="Code-In-Text--PACKT-">Treeview.heading()</code> method, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">for cid in ['#0', 'size', 'modified']:
  tv.heading(cid, command=lambda col=cid: sort(tv, col))
</code></pre>
    <p class="normal">Here we're looping through each of our CID values, calling the <code class="Code-In-Text--PACKT-">heading()</code> method to add a <code class="Code-In-Text--PACKT-">command</code> argument to the heading. We're doing this in the form of a <code class="Code-In-Text--PACKT-">lambda</code> function with a default argument for the CID.</p>
    <div><p class="Information-Box--PACKT-">Why use a default argument to pass in the CID? The body of a <code class="Code-In-Text--PACKT-">lambda</code> function is evaluated using <strong class="keyword">late binding</strong>, meaning that the value of the variables<a id="_idIndexMarker664"/> isn't established until the moment the body is run. By that point, <code class="Code-In-Text--PACKT-">cid</code> will be the last value in the list (<code class="Code-In-Text--PACKT-">'modified'</code>) no matter which column is calling the callback. The signature of the <code class="Code-In-Text--PACKT-">lambda</code> function, however, is evaluated immediately, meaning the default value of <code class="Code-In-Text--PACKT-">col</code> will be whatever <code class="Code-In-Text--PACKT-">cid</code> is when we create the function.</p>
    </div>
    <p class="normal">One last fix to make to this function; typically, a sort will reverse with a second click of the header. We can implement<a id="_idIndexMarker665"/> this with a second set of calls to the <code class="Code-In-Text--PACKT-">heading()</code> method inside the <code class="Code-In-Text--PACKT-">sort()</code> function<a id="_idIndexMarker666"/> that will replace the <code class="Code-In-Text--PACKT-">lambda</code> function with a reversed version. </p>
    <p class="normal">Inside the <code class="Code-In-Text--PACKT-">sort()</code> function, add this code:</p>
    <pre class="programlisting code"><code class="hljs-code">  if parent == '':
    tv.heading(
      col,
      command=lambda col=col: sort(tv, col, reverse=not reverse)
    )
</code></pre>
    <p class="normal">Since the function is called recursively, we do not want to call this more than once per sorting; so, we'll only run this code for the root node, indicated by the <code class="Code-In-Text--PACKT-">parent</code> value being a blank string. Inside that block, we reset the <code class="Code-In-Text--PACKT-">lambda</code> function on the column being sorted, this time setting <code class="Code-In-Text--PACKT-">reverse</code> to be the opposite of its current value.</p>
    <p class="normal">Now when you run the application, you should be able to sort in both directions by clicking the headers of each column.</p>
    <div><p class="Information-Box--PACKT-">Note that even though two of the columns contain numbers, they are sorted in <strong class="keyword">lexical order</strong> â€“ that is, as though they were strings, not numerical values. This is because the values<a id="_idIndexMarker667"/> put into a <code class="Code-In-Text--PACKT-">Treeview</code> widget are implicitly converted to strings, so the sort value returned by <code class="Code-In-Text--PACKT-">Treeview.set()</code> is a string. To sort these using a numerical sort, you would need to cast them back to integer or float values before sorting.</p>
    </div>
    <h3 id="_idParaDest-193" class="title">Using Treeview virtual events</h3>
    <p class="normal">To make it possible to respond<a id="_idIndexMarker668"/> to user interaction with the <code class="Code-In-Text--PACKT-">Treeview</code> widget's items, the widget includes<a id="_idIndexMarker669"/> three virtual events, shown in this table:</p>
    <table id="table002-4" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Event</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Generated</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">&lt;&lt;TreeviewSelect&gt;&gt;</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">When the user selects an item</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">&lt;&lt;TreeviewOpen&gt;&gt;</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">When a parent item is expanded to display child items</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">&lt;&lt;TreeviewClose&gt;&gt;</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">When an open parent item is closed again</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">For example, we can use these<a id="_idIndexMarker670"/> events to display some directory information in a status bar when the user opens<a id="_idIndexMarker671"/> a directory. First, let's add a status bar to the application:</p>
    <pre class="programlisting code"><code class="hljs-code"># treeview_demo.py
status = tk.StringVar()
tk.Label(root, textvariable=status).pack(side=tk.BOTTOM)
</code></pre>
    <p class="normal">Next, we'll create a callback for the event that will get some information about the opened directory and display it:</p>
    <pre class="programlisting code"><code class="hljs-code">def show_directory_stats(*_):
  clicked_path = Path(tv.focus())
  num_children = len(list(clicked_path.iterdir()))
  status.set(
    f'Directory: {clicked_path.name}, {num_children} children'
  )
</code></pre>
    <p class="normal">When a user clicks on an item to open it, that item gains focus, so we can use the treeview's <code class="Code-In-Text--PACKT-">focus()</code> method to get the IID of the item that was clicked on. We've converted that to a <code class="Code-In-Text--PACKT-">Path</code> and calculated the number of child objects in the directory using the <code class="Code-In-Text--PACKT-">Path</code> object's <code class="Code-In-Text--PACKT-">iterdir()</code> method. Then, we update the <code class="Code-In-Text--PACKT-">status</code> variable with that information.</p>
    <p class="normal">Now, we can bind this callback to the appropriate virtual events, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">tv.bind('&lt;&lt;TreeviewOpen&gt;&gt;', show_directory_stats)
tv.bind('&lt;&lt;TreeviewClose&gt;&gt;', lambda _: status.set(''))
</code></pre>
    <p class="normal">In addition to binding the open event to our callback, we've bound the close event to a <code class="Code-In-Text--PACKT-">lambda</code> function that clears<a id="_idIndexMarker672"/> the status control variable. Now, run the demo script and click on a directory. You should see some information show up in the status bar. Click it again and the information goes away.</p>
    <h1 id="_idParaDest-194" class="title">Implementing a record list with Treeview</h1>
    <p class="normal">Now that we understand<a id="_idIndexMarker673"/> how to use the <code class="Code-In-Text--PACKT-">Treeview</code> widget, it's time to implement<a id="_idIndexMarker674"/> a GUI that will allow us to browse the records in the CSV file and open them for editing. Let's take a moment to plan out what it is that we need to create:</p>
    <ul>
      <li class="bullet">We want to lay out the CSV data in a table structure, similar to how it would look in a spreadsheet. This will be a flat table, not a hierarchy.</li>
      <li class="bullet">Each table row will represent a record in the file. When a user double-clicks the row, or highlights it and presses Enter, we want the record form to open with the selected record.</li>
      <li class="bullet">We don't really need to show every field in the table, since its purpose is merely to locate records for editing. Instead, we'll show only the rows that uniquely identify a record to the user. Namely, those are <code class="Code-In-Text--PACKT-">Date</code>, <code class="Code-In-Text--PACKT-">Time</code>, <code class="Code-In-Text--PACKT-">Lab</code>, and <code class="Code-In-Text--PACKT-">Plot</code>. We can also show the CSV row number.</li>
      <li class="bullet">There isn't really a need to sort the data, so we won't implement sorting. The point is to visualize the CSV file, and its order shouldn't change.</li>
    </ul>
    <p class="normal">To make all of this work, we'll first implement a widget, using a treeview, to display all the records and allow the selection of a record. Then, we'll go through the rest of the application components and integrate the new functionality. Let's get started!</p>
    <h2 id="_idParaDest-195" class="title">Creating the RecordList class</h2>
    <p class="normal">We'll begin building our <code class="Code-In-Text--PACKT-">RecordList</code> class by subclassing <code class="Code-In-Text--PACKT-">tkinter.Frame</code>, just as we did with our<a id="_idIndexMarker675"/> record form:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py, at the end of the file
class RecordList(tk.Frame):
  """Display for CSV file contents"""
</code></pre>
    <p class="normal">To save ourselves from some repetitious code, we'll define our treeview's column properties and defaults as class attributes. This will also make it easier to tweak them later to suit our evolving needs. Add these properties to the class:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py, inside the RecordList class
  column_defs = {
    '#0': {'label': 'Row', 'anchor': tk.W},
    'Date': {'label': 'Date', 'width': 150, 'stretch': True},
    'Time': {'label': 'Time'},
    'Lab': {'label': 'Lab', 'width': 40},
    'Plot': {'label': 'Plot', 'width': 80}
  }
  default_width = 100
  default_minwidth = 10
  default_anchor = tk.CENTER
</code></pre>
    <p class="normal">Recall that we're going to be displaying <code class="Code-In-Text--PACKT-">Date</code>, <code class="Code-In-Text--PACKT-">Time</code>, <code class="Code-In-Text--PACKT-">Lab</code>, and <code class="Code-In-Text--PACKT-">Plot</code>. For the <code class="Code-In-Text--PACKT-">#0</code> column, we'll show the CSV row number. We've also set the <code class="Code-In-Text--PACKT-">width</code> and <code class="Code-In-Text--PACKT-">anchor</code> values for some columns and configured the <code class="Code-In-Text--PACKT-">Date</code> field to <code class="Code-In-Text--PACKT-">stretch</code>. We'll use these values when configuring the <code class="Code-In-Text--PACKT-">Treeview</code> widget in the <code class="Code-In-Text--PACKT-">RecordList</code> class's initializer.</p>
    <p class="normal">Moving on to the initializer<a id="_idIndexMarker676"/> method, let's begin it as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py, inside the RecordList class
def __init__(self, parent, *args, **kwargs):
  super().__init__(parent, *args, **kwargs)
  self.columnconfigure(0, weight=1)
  self.rowconfigure(0, weight=1)
</code></pre>
    <p class="normal">Here, after running the superclass initializer, we've configured the grid layout to expand the first row and first column. This is where our <code class="Code-In-Text--PACKT-">Treeview</code> widget will be placed, so we want it to take up any available space on the frame.</p>
    <h3 id="_idParaDest-196" class="title">Configuring a Treeview widget</h3>
    <p class="normal">Now we're ready<a id="_idIndexMarker677"/> to create our <code class="Code-In-Text--PACKT-">Treeview</code> widget, as<a id="_idIndexMarker678"/> follows:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py, inside the RecordList.__init__() method
  self.treeview = ttk.Treeview(
    self,
    columns=list(self.column_defs.keys())[1:],
    selectmode='browse'
  )
  self.treeview.grid(row=0, column=0, sticky='NSEW')
</code></pre>
    <p class="normal">Here, we've created a <code class="Code-In-Text--PACKT-">Treeview</code> widget and added it to the frame's layout. We've generated the <code class="Code-In-Text--PACKT-">columns</code> list by retrieving the keys from the <code class="Code-In-Text--PACKT-">column_defs</code> dictionary and excluding the first entry (<code class="Code-In-Text--PACKT-">#0</code>). Remember that <code class="Code-In-Text--PACKT-">#0</code> is automatically created and should not be included in the <code class="Code-In-Text--PACKT-">columns</code> list. We're also choosing the <code class="Code-In-Text--PACKT-">browse</code> selection mode so that users can select only individual<a id="_idIndexMarker679"/> rows of the CSV file. This will be important<a id="_idIndexMarker680"/> in the way we communicate back to the controller.</p>
    <p class="normal">Next, we'll configure the columns and headings of the <code class="Code-In-Text--PACKT-">Treeview</code> widget by iterating through the <code class="Code-In-Text--PACKT-">column_defs</code> dictionary:</p>
    <pre class="programlisting code"><code class="hljs-code">    for name, definition in self.column_defs.items():
      label = definition.get('label', '')
      anchor = definition.get('anchor', self.default_anchor)
      minwidth = definition.get('minwidth', self.default_minwidth)
      width = definition.get('width', self.default_width)
      stretch = definition.get('stretch', False)
      self.treeview.heading(name, text=label, anchor=anchor)
      self.treeview.column(
        name, anchor=anchor, minwidth=minwidth,
        width=width, stretch=stretch
      )
</code></pre>
    <p class="normal">For each entry in <code class="Code-In-Text--PACKT-">column_defs</code>, we're extracting the configuration values specified, then passing them to <code class="Code-In-Text--PACKT-">Treeview.heading()</code> or <code class="Code-In-Text--PACKT-">Treeview.column()</code> as appropriate. If the values aren't specified in the dictionary, the class default values will be used.</p>
    <p class="normal">Finally, we're going to set up some bindings so that double-clicking or hitting Enter on a record will cause a record to be opened, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py, in RecordList.__init__()
    self.treeview.bind('&lt;Double-1&gt;', self._on_open_record)
    self.treeview.bind('&lt;Return&gt;', self._on_open_record)
</code></pre>
    <p class="normal">The event <code class="Code-In-Text--PACKT-">&lt;Double-1&gt;</code> refers to double-clicking mouse button 1 (that is, the left mouse button), while the <code class="Code-In-Text--PACKT-">&lt;Return&gt;</code> event signifies striking the Return or Enter key (depending on how it's labeled on your hardware). These are both bound to an instance method called <code class="Code-In-Text--PACKT-">_on_open_record()</code>. Let's go ahead and implement that method, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py, in the RecordList class
  def _on_open_record(self, *args):
    self.event_generate('&lt;&lt;OpenRecord&gt;&gt;')
</code></pre>
    <p class="normal">Since opening a record is something that happens outside the <code class="Code-In-Text--PACKT-">RecordList</code> class, we're simply going to generate a custom event called <code class="Code-In-Text--PACKT-">&lt;&lt;OpenRecord&gt;&gt;</code> that our <code class="Code-In-Text--PACKT-">Application</code> class can listen for. Of course, <code class="Code-In-Text--PACKT-">Application</code> will need to know which record to switch to, so we'll need a way for it to retrieve<a id="_idIndexMarker681"/> the currently selected row from the table. We'll do this using a feature of Python classes called a <strong class="keyword">property</strong>. A class property appears to outside code to be a regular attribute, but runs a method to determine its value whenever it is evaluated. We could<a id="_idIndexMarker682"/> use a method here, of course, but using a property<a id="_idIndexMarker683"/> simplifies access for code outside the class. To create a property, we need to write a method that takes only <code class="Code-In-Text--PACKT-">self</code> as an argument and returns a value, then use the <code class="Code-In-Text--PACKT-">@property</code> decorator on it. We'll call our property <code class="Code-In-Text--PACKT-">selected_id</code>; add it to the <code class="Code-In-Text--PACKT-">RecordList</code> class like so:</p>
    <pre class="programlisting code"><code class="hljs-code">  @property
  def selected_id(self):
    selection = self.treeview.selection()
    return int(selection[0]) if selection else None
</code></pre>
    <p class="normal">In this method, we first retrieve a list of selected items using the <code class="Code-In-Text--PACKT-">selection()</code> method. This method always returns a list, even when only one item is selected (and even when only one item <em class="italic">can</em> be selected). Since we only want to return one IID, we retrieve item 0 from the list if it exists, or <code class="Code-In-Text--PACKT-">None</code> if nothing is selected. Remember that the IID of each row in our treeview is the CSV row number <em class="italic">as a string</em>. We'll want to convert that to an integer so that the controller can easily use it to locate the CSV record from the model.</p>
    <h3 id="_idParaDest-197" class="title">Adding a scrollbar for the Treeview</h3>
    <p class="normal">Since the CSV files are going to get<a id="_idIndexMarker684"/> several hundred records long, the record list is bound to overflow the height of the application<a id="_idIndexMarker685"/> window, even if the application is maximized. If this should happen, it would be helpful for users to have<a id="_idIndexMarker686"/> a scroll bar to navigate the list vertically.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Treeview</code> widget does not have a scrollbar by default; it can be scrolled using the keyboard or mouse-wheel controls, but users would reasonably expect a scrollbar on a scrollable area like the <code class="Code-In-Text--PACKT-">Treeview</code> to help them visualize the size of the list and their current position in it.</p>
    <p class="normal">Fortunately, Ttk provides us with a <code class="Code-In-Text--PACKT-">Scrollbar</code> widget that can be connected to our <code class="Code-In-Text--PACKT-">Treeview</code> widget. Back in the initializer, let's add one:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py , in RecordList.__init__()
    self.scrollbar = ttk.Scrollbar(
      self,
      orient=tk.VERTICAL,
      command=self.treeview.yview
    )
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Scrollbar</code> class takes two important keyword arguments:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">orient</code>: This argument determines whether it is a horizontal or vertical scroll. The strings <code class="Code-In-Text--PACKT-">horizontal</code> or <code class="Code-In-Text--PACKT-">vertical</code> can be used, or the Tkinter constants <code class="Code-In-Text--PACKT-">tk.HORIZONTAL</code> and <code class="Code-In-Text--PACKT-">tk.VERTICAL</code>.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">command</code>: This argument provides a callback for scrollbar move events. The callback will be passed arguments describing the scroll movement that happened.</li>
    </ul>
    <p class="normal">In this case, we set the callback<a id="_idIndexMarker687"/> to the treeview's <code class="Code-In-Text--PACKT-">yview()</code> method, which is used to make<a id="_idIndexMarker688"/> the treeview scroll up and down. (The other option would be <code class="Code-In-Text--PACKT-">xview()</code>, which would be used for horizontal scrolling.) The result<a id="_idIndexMarker689"/> is that when the scrollbar is moved, the position data is sent to <code class="Code-In-Text--PACKT-">Treeview.yview()</code>, causing the treeview to scroll up and down.</p>
    <p class="normal">We also need to connect our <code class="Code-In-Text--PACKT-">Treeview</code> back to the scrollbar:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.treeview.configure(yscrollcommand=self.scrollbar.set)
</code></pre>
    <p class="normal">This tells the <code class="Code-In-Text--PACKT-">Treeview</code> to send its current vertical position to the <code class="Code-In-Text--PACKT-">Scrollbar</code> widget's <code class="Code-In-Text--PACKT-">set()</code> method whenever it is scrolled. If we don't do this, our scrollbar won't know how far down the list we've scrolled or how long the list is, and won't be able to set the size or location of the bar widget appropriately.</p>
    <p class="normal">With our <code class="Code-In-Text--PACKT-">Scrollbar</code> widget configured, we need to place it on the frame. By convention, it should be just to the right of the widget being scrolled, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.scrollbar.grid(row=0, column=1, sticky='NSW')
</code></pre>
    <p class="normal">Notice we set <code class="Code-In-Text--PACKT-">sticky</code> to north, south, and<a id="_idIndexMarker690"/> west. North and south make sure the scrollbar stretches the entire<a id="_idIndexMarker691"/> height of the widget, and west makes<a id="_idIndexMarker692"/> sure it's snug against the <code class="Code-In-Text--PACKT-">Treeview</code> widget to the left of it.</p>
    <h3 id="_idParaDest-198" class="title">Populating the Treeview</h3>
    <p class="normal">Now that we have created<a id="_idIndexMarker693"/> and configured our <code class="Code-In-Text--PACKT-">Treeview</code> widget, we'll need a way to fill<a id="_idIndexMarker694"/> it with data. Let's create a <code class="Code-In-Text--PACKT-">populate()</code> method to do this:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py, in the RecordList class
  def populate(self, rows):
    """Clear the treeview and write the supplied data rows to it."""
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">rows</code> argument will take a list of dictionaries, such as what is returned from the model's <code class="Code-In-Text--PACKT-">get_all_records()</code> method. The idea is that the controller will fetch a list from the model and then pass it to the <code class="Code-In-Text--PACKT-">RecordList</code> via this method.</p>
    <p class="normal">Before refilling <code class="Code-In-Text--PACKT-">Treeview</code>, we need to empty it:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py, in RecordList.populate()
    for row in self.treeview.get_children():
      self.treeview.delete(row)
</code></pre>
    <p class="normal">To delete records from the treeview, we just need to call its <code class="Code-In-Text--PACKT-">delete()</code> method with the IID of the row we want to delete. Here, we've retrieved all row IIDs using <code class="Code-In-Text--PACKT-">get_children()</code>, then passed them one by one to <code class="Code-In-Text--PACKT-">delete()</code>.</p>
    <p class="normal">Now that the treeview is cleared, we can iterate through the <code class="Code-In-Text--PACKT-">rows</code> list and populate the table:</p>
    <pre class="programlisting code"><code class="hljs-code">    cids = self.treeview.cget('columns')
    for rownum, rowdata in enumerate(rows):
      values = [rowdata[cid] for cid in cids]
      self.treeview.insert('', 'end', iid=str(rownum),
         text=str(rownum), values=values)
</code></pre>
    <p class="normal">The first thing we do here is create a list of all the CIDs we actually want to fetch from each row by retrieving the treeview's <code class="Code-In-Text--PACKT-">columns</code> value.</p>
    <p class="normal">Next, we iterate through the provided data rows using the <code class="Code-In-Text--PACKT-">enumerate()</code> function to generate a row number. For each row, we'll create a list of values in the proper order using a list comprehension, then insert the list at the end of the <code class="Code-In-Text--PACKT-">Treeview</code> widget with the <code class="Code-In-Text--PACKT-">insert()</code> method. Notice that we're just using the row number (converted to a string) as both the IID and text for the first column of the row.</p>
    <p class="normal">The last thing we need to do<a id="_idIndexMarker695"/> in this function is a small usability tweak. To make our record list keyboard-friendly, we need to initially focus the first item so that keyboard<a id="_idIndexMarker696"/> users can immediately start to navigate it via the arrow keys.</p>
    <p class="normal">Doing this in a <code class="Code-In-Text--PACKT-">Treeview</code> widget actually takes three method calls:</p>
    <pre class="programlisting code"><code class="hljs-code">    if len(rows) &gt; 0:
      self.treeview.focus_set()
      self.treeview.selection_set('0')
      self.treeview.focus('0')
</code></pre>
    <p class="normal">First, the <code class="Code-In-Text--PACKT-">focus_set()</code> method moves focus to the <code class="Code-In-Text--PACKT-">Treeview</code> widget. Next, <code class="Code-In-Text--PACKT-">selection_set('0')</code> selects the first record in the list (note that the string <code class="Code-In-Text--PACKT-">0</code> is the IID of the first record). Finally, <code class="Code-In-Text--PACKT-">focus('0')</code> focuses the row with an IID of <code class="Code-In-Text--PACKT-">0</code>. And, of course, we only do this if there are any rows at all; if we called these methods on an empty <code class="Code-In-Text--PACKT-">Treeview</code>, we would cause an exception.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">RecordList</code> class is now complete. Now it's time to update the rest of the application to make use of it.</p>
    <h1 id="_idParaDest-199" class="title">Adding the record list to the application</h1>
    <p class="normal">Now that we have a model capable of reading and updating data, and a <code class="Code-In-Text--PACKT-">RecordList</code> widget capable of displaying the contents<a id="_idIndexMarker697"/> of a file, we need to make changes to the rest of the application<a id="_idIndexMarker698"/> to enable everything to work together. Specifically, we'll have to do the following:</p>
    <ul>
      <li class="bullet">We'll need to update the <code class="Code-In-Text--PACKT-">DataRecordForm</code> to be suitable for updating existing records as well as adding new ones.</li>
      <li class="bullet">We'll need to update the layout of the <code class="Code-In-Text--PACKT-">Application</code> window to accommodate the new record list.</li>
      <li class="bullet">We'll need to create new <code class="Code-In-Text--PACKT-">Application</code> callbacks to handle loading records and navigating the application.</li>
      <li class="bullet">Finally, we'll need to update the main menu with new options for the added functionality.</li>
    </ul>
    <p class="normal">Let's get started!</p>
    <h2 id="_idParaDest-200" class="title">Modifying the record form for read and update</h2>
    <p class="normal">As long as we're still in <code class="Code-In-Text--PACKT-">views.py</code>, let's scroll up to look at our <code class="Code-In-Text--PACKT-">DataRecordForm</code> class and adjust it to make it capable<a id="_idIndexMarker699"/> of loading and updating existing records.</p>
    <p class="normal">Take a moment and consider the following changes we'll need to make:</p>
    <ul>
      <li class="bullet">The form will need to keep track of what record it's editing, or if it's a new record.</li>
      <li class="bullet">The user will need some visual indication of what record is being edited.</li>
      <li class="bullet">The form will need some way to load in a record provided by the controller.</li>
    </ul>
    <p class="normal">Let's implement these changes.</p>
    <h3 id="_idParaDest-201" class="title">Adding a current record property</h3>
    <p class="normal">To keep track of the current<a id="_idIndexMarker700"/> record being edited, we'll just use an instance<a id="_idIndexMarker701"/> property. In the <code class="Code-In-Text--PACKT-">__init__()</code> method, just above where the first <code class="Code-In-Text--PACKT-">LabelFrame</code> widget is created, add this code:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py, in DataRecordForm.__init__()
    self.current_record = None
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">current_record</code> instance attribute is initially set to <code class="Code-In-Text--PACKT-">None</code>, which we'll use to indicate that no record is loaded and the form is being used to create a new record. When we edit a record, we'll update this value to an integer referencing a row in the CSV data. We could use a Tkinter variable here, but there's no real advantage in this case, and we wouldn't be able to use <code class="Code-In-Text--PACKT-">None</code> as a value.</p>
    <h3 id="_idParaDest-202" class="title">Adding a label to show what is being edited</h3>
    <p class="normal">Since the form might now be editing an existing<a id="_idIndexMarker702"/> record or a new one, it would be helpful to the user to be able to see<a id="_idIndexMarker703"/> what is going on at a glance. To do that, let's add a <code class="Code-In-Text--PACKT-">Label</code> to the top of the form to display the current<a id="_idIndexMarker704"/> record being edited, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py, in DataRecordForm.__init__()
    self.record_label = ttk.Label(self)
    self.record_label.grid(row=0, column=0)
</code></pre>
    <p class="normal">We're placing the new <code class="Code-In-Text--PACKT-">Label</code> widget in <code class="Code-In-Text--PACKT-">row 0</code>, <code class="Code-In-Text--PACKT-">column 0</code>, which is going to cause the other widgets to bump down one row. This won't affect our <code class="Code-In-Text--PACKT-">Frame</code> widgets generated by <code class="Code-In-Text--PACKT-">_add_frame()</code>, since they use implicit row numbers, but our Notes input and buttons will need to be moved. Let's update<a id="_idIndexMarker705"/> those widgets with a new position:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py, in DataRecordForm.__init__()
    w.LabelInput(
      self, "Notes", field_spec=fields['Notes'],
      var=self._vars['Notes'], input_args={"width": 85, "height": 10}
    ).grid(sticky="nsew", <strong class="hljs-slc">row=</strong><strong class="hljs-number-slc">4</strong>, column=0, padx=10, pady=10)
    buttons = tk.Frame(self)
    buttons.grid(sticky=tk.W + tk.E, <strong class="hljs-slc">row=</strong><strong class="hljs-number-slc">5</strong>)
</code></pre>
    <div><p class="Tip--PACKT-">Feel free to adjust the height of the Notes field if this change pushes the bottom of the form off-screen on your system!</p>
    </div>
    <h3 id="_idParaDest-203" class="title">Adding a load_record() method</h3>
    <p class="normal">The last thing to add to the <code class="Code-In-Text--PACKT-">DataRecordForm</code> class is a method for loading in a new record. This method will need to accept<a id="_idIndexMarker706"/> a row number and dictionary of data from the controller<a id="_idIndexMarker707"/> and use them to update the <code class="Code-In-Text--PACKT-">current_record</code>, the data in the form, and the label at the top. This will be a public method, since it will be called from the controller, and it will begin like this:</p>
    <pre class="programlisting code"><code class="hljs-code">  def load_record(self, rownum, data=None):
    self.current_record = rownum
    if rownum is None:
      self.reset()
      self.record_label.config(text='New Record')
</code></pre>
    <p class="normal">After updating the <code class="Code-In-Text--PACKT-">current_record</code> attribute, we check to see if <code class="Code-In-Text--PACKT-">rownum</code> is <code class="Code-In-Text--PACKT-">None</code>. Recall that this indicates we're requesting a blank form to enter a new record. In that case, we'll call the <code class="Code-In-Text--PACKT-">reset()</code> method and configure the label to show <strong class="screenText">New Record</strong>.</p>
    <div><p class="Tip--PACKT-">Note that our <code class="Code-In-Text--PACKT-">if</code> condition here checks specifically whether <code class="Code-In-Text--PACKT-">rownum</code> is <code class="Code-In-Text--PACKT-">None</code>; we can't just check the truth value of <code class="Code-In-Text--PACKT-">rownum</code>, since 0 is a valid <code class="Code-In-Text--PACKT-">rownum</code> for updating!</p>
    </div>
    <p class="normal">If we do have a valid <code class="Code-In-Text--PACKT-">rownum</code>, we'll need it to act differently:</p>
    <pre class="programlisting code"><code class="hljs-code">    else:
      self.record_label.config(text=f'Record #{rownum}')
      for key, var in self._vars.items():
        var.set(data.get(key, ''))
        try:
          var.label_widget.input.trigger_focusout_validation()
        except AttributeError:
          pass
</code></pre>
    <p class="normal">In this block, we first set the label appropriately with the row number we're editing. Then, we iterate over the form's <code class="Code-In-Text--PACKT-">_vars</code> dictionary, retrieving matching values from the <code class="Code-In-Text--PACKT-">data</code> dictionary that was passed to the function. Finally, we attempt to call the <code class="Code-In-Text--PACKT-">trigger_focusout_validation()</code> method<a id="_idIndexMarker708"/> on each variable's input widget, since it's possible that the CSV file contains<a id="_idIndexMarker709"/> invalid data. If the input has no such method (that is, if we used a regular Tkinter widget rather than one of our validated widgets), we just do nothing.</p>
    <p class="normal">Our form is now ready to load data records!</p>
    <h2 id="_idParaDest-204" class="title">Updating the application layout</h2>
    <p class="normal">We have the form ready for loading records, and we have the record list ready to display them. We now need to incorporate<a id="_idIndexMarker710"/> all of this into the main application. First, though, we need to consider how we can accommodate both forms into our GUI layout.</p>
    <p class="normal">Back in <em class="chapterRef">Chapter 2</em>, <em class="italic">Designing GUI Applications</em>, we listed a few options for widgets that can help us group GUI components and cut down on the clutter of the GUI. We chose to use framed boxes to organize our data entry form; could we do the same again?</p>
    <p class="normal">A quick mockup of the idea might look something like this:</p>
    <figure class="mediaobject"><img src="img/B17578_08_04.png" alt="Figure 8.2: A layout of our application using side-by-side frames"/></figure>
    <p class="packt_figref">Figure 8.4: A layout of our application using side-by-side frames</p>
    <p class="normal">This could work, but it's a lot of information on the screen at once, and the user doesn't really need to see all of this at the same time. The Record List is primarily for navigating, and the Data Entry form is for editing or entering data. It would probably be better if we showed only one component at a time.</p>
    <p class="normal">Another option for organizing<a id="_idIndexMarker711"/> these two large components into the same GUI is the <strong class="keyword">notebook</strong>. This type of widget can switch between multiple pages in a GUI<a id="_idIndexMarker712"/> by using tabs. Ttk offers us a <code class="Code-In-Text--PACKT-">Notebook</code> widget that implements this feature; you've seen it before, back in <em class="chapterRef">Chapter 1</em>, <em class="italic">Introduction to Tkinter</em>, when we looked at the IDLE configuration dialog. It can be seen here:</p>
    <figure class="mediaobject"><img src="img/B17578_08_05.png" alt="Ttk Notebook tabs in IDLE's config dialog"/></figure>
    <p class="packt_figref">Figure 8.5: Ttk Notebook tabs in IDLE's config dialog</p>
    <p class="normal">Let's take a quick look at the Ttk <code class="Code-In-Text--PACKT-">Notebook</code> to see how it can be used in an application.</p>
    <h3 id="_idParaDest-205" class="title">The Ttk Notebook widget</h3>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Notebook</code> widget is part of the <code class="Code-In-Text--PACKT-">ttk</code> module, so we don't need<a id="_idIndexMarker713"/> to add any additional imports to use it. Creating<a id="_idIndexMarker714"/> one is fairly simple, as shown here:</p>
    <pre class="programlisting code"><code class="hljs-code"># notebook_demo.py
import tkinter as tk
from tkinter import ttk
root = tk.Tk()
notebook = ttk.Notebook(root)
notebook.grid()
</code></pre>
    <p class="normal">To add pages to the widgets, we need to create some child widgets. Let's create a couple of <code class="Code-In-Text--PACKT-">Label</code> widgets with some informative content:</p>
    <pre class="programlisting code"><code class="hljs-code">banana_facts = [
  'Banana trees are of the genus Musa.',
  'Bananas are technically berries.',
  'All bananas contain small amounts of radioactive potassium.'
  'Bananas are used in paper and textile manufacturing.'
]
plantain_facts = [
  'Plantains are also of genus Musa.',
  'Plantains are starchier and less sweet than bananas',
  'Plantains are called "Cooking Bananas" since they are'
  ' rarely eaten raw.'
]
b_label = ttk.Label(notebook, text='\n\n'.join(banana_facts))
p_label = ttk.Label(notebook, text='\n\n'.join(plantain_facts))
</code></pre>
    <p class="normal">Here, we've created a couple of labels to be pages in our notebook. Typically your notebook page widgets would probably be <code class="Code-In-Text--PACKT-">Frame</code> objects or subclasses like our <code class="Code-In-Text--PACKT-">RecordList</code> or <code class="Code-In-Text--PACKT-">DataRecordForm</code> components, but any widget can be used.</p>
    <p class="normal">Rather than use a geometry manager to place these components in the notebook, we instead use the widget's <code class="Code-In-Text--PACKT-">add()</code> method, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">notebook.add(b_label, text='Bananas', padding=20)
notebook.add(p_label, text='Plantains', padding=20)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">add()</code> method creates a new page containing the given widget at the end of the notebook. If we wanted to insert<a id="_idIndexMarker715"/> the page somewhere other than the end, we could<a id="_idIndexMarker716"/> also use the <code class="Code-In-Text--PACKT-">insert()</code> method, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">notebook.insert(1, p_label, text='Plantains', padding=20)
</code></pre>
    <p class="normal">This method is identical, except that it takes an index number as the first argument. The page will be inserted at that index.</p>
    <p class="normal">Both methods take a number of keyword arguments to configure the page and its tab, shown here:</p>
    <table id="table003-3" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Argument</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Values</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Description</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">text</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">String</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">The text shown on the label. By default, tabs are blank.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">padding</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Integer</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Padding in pixels to add around the widget on the page.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">sticky</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Cardinal values (<code class="Code-In-Text--PACKT-">N</code>, <code class="Code-In-Text--PACKT-">S</code>, <code class="Code-In-Text--PACKT-">E</code>, <code class="Code-In-Text--PACKT-">W</code>)</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Where to stick the widget on the notebook page. <code class="Code-In-Text--PACKT-">NSEW</code> by default.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">underline</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Integer</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Index of a letter in the <code class="Code-In-Text--PACKT-">text</code> to bind for keyboard traversal.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">image</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Tkinter <code class="Code-In-Text--PACKT-">Photoimage</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">An image to display on the tab. See <em class="chapterRef">Chapter 9</em>, <em class="chapterRef">Improving the Look with Styles and Themes</em>.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">compound</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">LEFT</code>, <code class="Code-In-Text--PACKT-">RIGHT</code>, <code class="Code-In-Text--PACKT-">CENTER</code>, <code class="Code-In-Text--PACKT-">TOP</code>, <code class="Code-In-Text--PACKT-">BOTTOM</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">If both text and image are specified, where to display the image in relation to the text.</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">The <code class="Code-In-Text--PACKT-">underline</code> option is one we've seen before on other widgets (see <em class="chapterRef">Chapter 3</em>, <em class="italic">Creating Basic Forms with Tkinter and Ttk Widgets</em>); however, in the <code class="Code-In-Text--PACKT-">ttk.Notebook</code> widget, the option actually sets up a keyboard binding when we use it.</p>
    <p class="normal">Let's try that out on our example notebook:</p>
    <pre class="programlisting code"><code class="hljs-code">notebook.tab(0, underline=0)
notebook.tab(1, underline=0)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">tab()</code> method, similar to a widget's <code class="Code-In-Text--PACKT-">config()</code> method, allows us to change configuration options on the tab after we've already added it. </p>
    <p class="normal">In this case, we're specifying <code class="Code-In-Text--PACKT-">underline=0</code> for both tabs, meaning the first letter of each tab's <code class="Code-In-Text--PACKT-">text</code> string will be underlined. In addition, a keybinding will be created so that the key combination of Alt plus the underlined letter<a id="_idIndexMarker717"/> will switch to the matching tab. For example, in our application, we underlined<a id="_idIndexMarker718"/> letter 0 in the tab labeled <strong class="screenText">Banana</strong>, so Alt-B will switch to that tab; we also underlined letter 0 in the tab labeled <strong class="screenText">Plantain</strong>, so Alt-P will switch to the <strong class="screenText">Plantain</strong> tab.</p>
    <p class="normal">In addition to these bindings, we can enable general keyboard traversal of the notebook by calling its <code class="Code-In-Text--PACKT-">enable_traversal()</code> method, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">notebook.enable_traversal()
</code></pre>
    <p class="normal">If this method is called, Control-Tab will cycle through the tabs from left to right, and Shift-Control-Tab will cycle through them right to left.</p>
    <p class="normal">Our code may sometimes need to select a tab; for this, we can use the <code class="Code-In-Text--PACKT-">select()</code> method, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">notebook.select(0)
</code></pre>
    <p class="normal">In this case, we're passing in the integer <code class="Code-In-Text--PACKT-">0</code>, which indicates the first tab. We could also pass in the name of the widget contained by the tab, like this:</p>
    <pre class="programlisting code"><code class="hljs-code">notebook.select(p_label)
</code></pre>
    <p class="normal">This works for the <code class="Code-In-Text--PACKT-">tab()</code> method as well, and any method that requires a tab ID.</p>
    <div><p class="Information-Box--PACKT-">The <code class="Code-In-Text--PACKT-">Notebook</code> widget has a <code class="Code-In-Text--PACKT-">&lt;&lt;NotebookTabChanged&gt;&gt;</code> virtual signal that is generated whenever the user changes tabs. You might use this to refresh pages or display help messages, for example. </p>
    </div>
    <p class="normal">Now that we're familiar with the notebook, let's incorporate one into our application.</p>
    <h3 id="_idParaDest-206" class="title">Adding a notebook to our application</h3>
    <p class="normal">To add a <code class="Code-In-Text--PACKT-">Notebook</code> widget<a id="_idIndexMarker719"/> to our layout, we'll need to create one in <code class="Code-In-Text--PACKT-">Application.__init__()</code> before we create the <code class="Code-In-Text--PACKT-">DataRecordForm</code> and <code class="Code-In-Text--PACKT-">RecordList</code> widgets. Open the <code class="Code-In-Text--PACKT-">application.py</code> file and locate the lines that currently create<a id="_idIndexMarker720"/> the <code class="Code-In-Text--PACKT-">DataRecordForm</code> object, and let's create a notebook just above them, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, in Application.__init__()
    self.notebook = ttk.Notebook(self)
    self.notebook.enable_traversal()
    self.notebook.grid(row=1, padx=10, sticky='NSEW')
</code></pre>
    <p class="normal">Note that we're enabling keyboard traversal for our keyboard-only users, and sticking the widget to all sides of the grid. Now, update the lines that create the record form as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.recordform = v.DataRecordForm(
      self, 
      self.model, 
      self.settings
    )
    self.recordform.bind('&lt;&lt;SaveRecord&gt;&gt;', self._on_save)
    <strong class="hljs-slc">self.notebook.add(self.recordform, text=</strong><strong class="hljs-string-slc">'Entry Form'</strong><strong class="hljs-slc">)</strong>
</code></pre>
    <p class="normal">Here, we've simply removed the call to <code class="Code-In-Text--PACKT-">self.recordform.grid()</code> and replaced it with <code class="Code-In-Text--PACKT-">self.notebook.add()</code>. Next, let's create an instance of the <code class="Code-In-Text--PACKT-">RecordList</code> class and add it to the notebook:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.recordlist = v.RecordList(self)
    self.notebook.insert(0, self.recordlist, text='Records')
</code></pre>
    <p class="normal">Although we're adding the <code class="Code-In-Text--PACKT-">RecordList</code> widget second, we'd like it to display first; so, we're using <code class="Code-In-Text--PACKT-">insert()</code> to add it to the beginning<a id="_idIndexMarker721"/> of the tab list. That completes adding our pages, but let's start adding the necessary callbacks to make them work.</p>
    <h2 id="_idParaDest-207" class="title">Adding and updating application callbacks</h2>
    <p class="normal">To bring all of these new widgets together in a functional way, we need to create a few callback methods on the <code class="Code-In-Text--PACKT-">Application</code> object<a id="_idIndexMarker722"/> that will allow the application to get the user and the data<a id="_idIndexMarker723"/> to appropriate areas of the GUI when required. Specifically, we need to create four methods:</p>
    <ul>
      <li class="bullet">A <code class="Code-In-Text--PACKT-">_show_recordlist()</code> method we can use to display the record list when required</li>
      <li class="bullet">A <code class="Code-In-Text--PACKT-">_populate_recordlist()</code> method we can call to repopulate the record list from file data</li>
      <li class="bullet">A <code class="Code-In-Text--PACKT-">_new_record()</code> method that we can use to switch to a new, empty record</li>
      <li class="bullet">An <code class="Code-In-Text--PACKT-">_open_record()</code> method we can call to load a particular record into the form from the record list</li>
    </ul>
    <p class="normal">We also need to fix the <code class="Code-In-Text--PACKT-">Application._on_save()</code> method to make sure it's passing the model all the information necessary for both updating existing records and creating new records.</p>
    <p class="normal">Let's go through each method, creating or updating the method and binding or calling it where appropriate.</p>
    <h3 id="_idParaDest-208" class="title">The _show_recordlist() method</h3>
    <p class="normal">The first method we'll write is <code class="Code-In-Text--PACKT-">_show_recordlist()</code>. This method<a id="_idIndexMarker724"/> is fairly simple, as you can see:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, in the Application class
  def _show_recordlist(self, *_):
    self.notebook.select(self.recordlist)
</code></pre>
    <p class="normal">It's almost not worth writing<a id="_idIndexMarker725"/> such a simple method, but by having this as a method we can easily bind it as a callback without resorting to a <code class="Code-In-Text--PACKT-">lambda</code> function. Note that we could have written this as <code class="Code-In-Text--PACKT-">self.notebook.select(0)</code>, but passing the widget reference is more explicit about our intentions. Should we decide to switch the order of the tabs, this method will continue to work without alteration.</p>
    <p class="normal">One place we'll want to bind this callback is in our main menu. Back in the initializer for <code class="Code-In-Text--PACKT-">Application</code>, let's add this method to our dictionary of callback functions, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, in Application.__init__()
    event_callbacks = {
      #...
      '&lt;&lt;ShowRecordlist&gt;&gt;': self._show_recordlist
    }
</code></pre>
    <p class="normal">We'll add the<a id="_idIndexMarker726"/> necessary code for the menu itself<a id="_idIndexMarker727"/> in the next section. One other place we ought to call this method is at the end of <code class="Code-In-Text--PACKT-">__init__()</code>, to ensure that the record list is displayed when the user opens the program. Add this at the end of <code class="Code-In-Text--PACKT-">Application.__init__()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, at the end of Application.__init__()
    self._show_recordlist()
</code></pre>
    <h3 id="_idParaDest-209" class="title">The _populate_recordlist() method</h3>
    <p class="normal">The <code class="Code-In-Text--PACKT-">_populate_recordlist()</code> method needs<a id="_idIndexMarker728"/> to retrieve data from the model and hand it to the record list's <code class="Code-In-Text--PACKT-">populate()</code> method. We could<a id="_idIndexMarker729"/> write it like so:</p>
    <pre class="programlisting code"><code class="hljs-code">  def _populate_recordlist(self):
    rows = self.model.get_all_records()
    self.recordlist.populate(rows)
</code></pre>
    <p class="normal">However, remember that <code class="Code-In-Text--PACKT-">CSVModel.get_all_records()</code> can potentially raise an <code class="Code-In-Text--PACKT-">Exception</code> if there are problems with the data in the file. It's the controller's responsibility to catch that exception and take appropriate action, so we'll write the method like this instead:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, in the Application class
  def _populate_recordlist(self):
    try:
      rows = self.model.get_all_records()
    except Exception as e:
      messagebox.showerror(
        title='Error',
        message='Problem reading file',
        detail=str(e)
      )
    else:
      self.recordlist.populate(rows)
</code></pre>
    <p class="normal">In this version, if we get an exception from <code class="Code-In-Text--PACKT-">get_all_records()</code>, we'll display its message in an error dialog. It will then be up to the user to deal with that issue.</p>
    <p class="normal">Now that we have this method, when should it be called? To begin with, it should be called whenever we select a new file to work with; so, let's add a call to it at the end of <code class="Code-In-Text--PACKT-">_on_file_select()</code>, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">  def _on_file_select(self, *_):
    # ...
    if filename:
      self.model = m.CSVModel(filename=filename)
      <strong class="hljs-slc">self._populate_recordlist()</strong>
</code></pre>
    <p class="normal">In addition, we need<a id="_idIndexMarker730"/> to populate the list whenever<a id="_idIndexMarker731"/> we open the program, since it will automatically load the default file. Let's add a call to this method in the initializer just after creating the record list widget, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, in Application.__init__()
    self.recordlist = v.RecordList(self)
    self.notebook.insert(0, self.recordlist, text='Records')
    <strong class="hljs-slc">self._populate_recordlist()</strong>
</code></pre>
    <p class="normal">Finally, whenever we save a record, this should also update the record list, since the new record will have been added to the file. We need to add a call to the method in <code class="Code-In-Text--PACKT-">_on_save()</code>, like this:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, in Application._on_save()
  def _on_save(self, *_):
    #...
    self.recordform.reset()
    <strong class="hljs-slc">self._populate_recordlist()</strong>
</code></pre>
    <p class="normal">Now our record list should stay in sync with the state of the file we're working on.</p>
    <h3 id="_idParaDest-210" class="title">The _new_record() method</h3>
    <p class="normal">Next, we need a method that can open the data record form for the entry of a new record. Remember that our <code class="Code-In-Text--PACKT-">DataRecordForm.load_record()</code> method can take <code class="Code-In-Text--PACKT-">None</code> as arguments for the record number<a id="_idIndexMarker732"/> and data, indicating that we want to work<a id="_idIndexMarker733"/> on a new record, so we just need to write a callback that will do this.</p>
    <p class="normal">Add this method to <code class="Code-In-Text--PACKT-">Application</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, in the Application class
  def _new_record(self, *_):
    self.recordform.load_record(None)
    self.notebook.select(self.recordform)
</code></pre>
    <p class="normal">After calling <code class="Code-In-Text--PACKT-">load_record()</code> to prepare the form for a new record entry, we switch the notebook to the record form using <code class="Code-In-Text--PACKT-">notebook.select()</code>. To enable users to call this method, we'll create a menu entry, so we'll need to add another entry to the <code class="Code-In-Text--PACKT-">event_callbacks</code> dictionary.</p>
    <p class="normal">In <code class="Code-In-Text--PACKT-">Application.__init__()</code>, update the dictionary as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, in Application.__init__()
    event_callbacks = {
      #...
      <strong class="hljs-string-slc">'&lt;&lt;NewRecord&gt;&gt;'</strong><strong class="hljs-slc">: self._new_record</strong>
    }
</code></pre>
    <p class="normal">We'll add the necessary code to the menu in the next section.</p>
    <h3 id="_idParaDest-211" class="title">The _open_record() method</h3>
    <p class="normal">Next, we need to write a callback<a id="_idIndexMarker734"/> method that will open an existing<a id="_idIndexMarker735"/> record when the user selects one from the record list. Add this method to the <code class="Code-In-Text--PACKT-">Application</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, in the Application class
  def _open_record(self, *_):
    """Open the selected id from recordlist in the recordform"""
    rowkey = self.recordlist.selected_id
    try:
      record = self.model.get_record(rowkey)
    except Exception as e:
      messagebox.showerror(
        title='Error', message='Problem reading file', detail=str(e)
      )
    else:
      self.recordform.load_record(rowkey, record)
      self.notebook.select(self.recordform)
</code></pre>
    <p class="normal">Remember that the <code class="Code-In-Text--PACKT-">RecordList</code> object updates its <code class="Code-In-Text--PACKT-">selected_id</code> property whenever a record is double-clicked or activated with the Enter key. We're retrieving this ID number and passing it to the model's <code class="Code-In-Text--PACKT-">get_record()</code> method. Because <code class="Code-In-Text--PACKT-">get_record()</code> calls <code class="Code-In-Text--PACKT-">get_all_records()</code>, it can also potentially raise an exception if there is a problem with the file. Therefore, just as we did in <code class="Code-In-Text--PACKT-">_populate_recordlist()</code>, we're catching the exception and displaying its message to the user in the case of problem.</p>
    <p class="normal">If there's no problem, we've retrieved<a id="_idIndexMarker736"/> the data, and we need only pass<a id="_idIndexMarker737"/> the row number and dictionary of data to the form's <code class="Code-In-Text--PACKT-">load_record()</code> method. Last of all, we call <code class="Code-In-Text--PACKT-">notebook.select()</code> to switch to the record form view.</p>
    <p class="normal">This callback needs to be called whenever the user chooses a file from the record list. Remember that we have written our <code class="Code-In-Text--PACKT-">RecordList</code> objects to generate an <code class="Code-In-Text--PACKT-">&lt;&lt;OpenRecord&gt;&gt;</code> event whenever this happens. Back in the application's initializer method, we need to set up a binding to this event.</p>
    <p class="normal">Back in <code class="Code-In-Text--PACKT-">Application.__init__()</code>, add this binding just after creating the <code class="Code-In-Text--PACKT-">RecordList</code> widget, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, inside Application.__init__()
    self.notebook.insert(0, self.recordlist, text='Records')
    self._populate_recordlist()
    <strong class="hljs-slc">self.recordlist.bind(</strong><strong class="hljs-string-slc">'&lt;&lt;OpenRecord&gt;&gt;'</strong><strong class="hljs-slc">, self._open_record)</strong>
</code></pre>
    <p class="normal">Now a double-click or Enter keypress will open the selected record in the form.</p>
    <h3 id="_idParaDest-212" class="title">The _on_save() method</h3>
    <p class="normal">Finally, now that our model can handle updating existing records, we need to alter the call that we make to the model's <code class="Code-In-Text--PACKT-">save_record()</code> method to make sure we're passing in all the information it needs<a id="_idIndexMarker738"/> to either update an existing record or insert<a id="_idIndexMarker739"/> a new one. Recall that we updated <code class="Code-In-Text--PACKT-">save_record()</code> to take a <code class="Code-In-Text--PACKT-">rownum</code> argument. When this value is <code class="Code-In-Text--PACKT-">None</code>, a new record is added; when it is an integer, the indicated row number is updated.</p>
    <p class="normal">In <code class="Code-In-Text--PACKT-">Application._on_save()</code>, update the code as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, inside Application._on_save()
    data = self.recordform.get()
    <strong class="hljs-slc">rownum = self.recordform.current_record</strong>
    <strong class="hljs-slc">self.model.save_record(data, rownum)</strong>
</code></pre>
    <p class="normal">Recall that the record form object's <code class="Code-In-Text--PACKT-">current_record</code> holds the value of the current row being edited, or <code class="Code-In-Text--PACKT-">None</code> if it is a new record. We can pass<a id="_idIndexMarker740"/> that value directly on to the model's <code class="Code-In-Text--PACKT-">save()</code> method, ensuring<a id="_idIndexMarker741"/> that the data is saved to the proper place.</p>
    <h2 id="_idParaDest-213" class="title">Main menu changes</h2>
    <p class="normal">The last change we need to make to our application is updating the main menu with the new options for navigating the application; specifically, we need to add a command for adding a new file, and a command for going back to the record list. Remember that the <code class="Code-In-Text--PACKT-">Application</code> object has bound callbacks for these operations to the <code class="Code-In-Text--PACKT-">&lt;&lt;ShowRecordlist&gt;&gt;</code> and <code class="Code-In-Text--PACKT-">&lt;&lt;NewRecord&gt;&gt;</code> events, respectively.</p>
    <p class="normal">There isn't really a standard<a id="_idIndexMarker742"/> location for commands that navigate around the application, so we'll create a new sub-menu called Go. Open the <code class="Code-In-Text--PACKT-">mainmenu.py</code> file, and let's add a new sub-menu in the initializer method:</p>
    <pre class="programlisting code"><code class="hljs-code"># mainmenu.py, inside MainMenu.__init__()
    go_menu = tk.Menu(self, tearoff=False)
    go_menu.add_command(
      label="Record List",
      command=self._event('&lt;&lt;ShowRecordlist&gt;&gt;')
    )
    go_menu.add_command(
      label="New Record",
      command=self._event('&lt;&lt;NewRecord&gt;&gt;')
    )
</code></pre>
    <p class="normal">Here, we've added a new sub-menu widget and added our two navigation commands, once again taking advantage of the <code class="Code-In-Text--PACKT-">_event()</code> method, which gives us a reference to a method that generates the given event. Now add the <code class="Code-In-Text--PACKT-">Go</code> menu between the File and Options menus, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># mainmenu.py, at the end of MainMenu.__init__()
    self.add_cascade(label='File', menu=file_menu)
    <strong class="hljs-slc">self.add_cascade(label=</strong><strong class="hljs-string-slc">'Go'</strong><strong class="hljs-slc">, menu=go_menu)</strong>
    self.add_cascade(label='Options', menu=options_menu)
</code></pre>
    <h2 id="_idParaDest-214" class="title">Testing our program</h2>
    <p class="normal">At this point, you should<a id="_idIndexMarker743"/> be able to run the application and load in a sample CSV file as shown in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B17578_08_06.png" alt="Selecting an existing file for writing with our new menu and record list"/></figure>
    <p class="packt_figref">Figure 8.6: Selecting an existing file for writing with our new menu and record list</p>
    <p class="normal">Make sure to try opening a record, editing and saving it, as well as inserting new records and opening different files. You should also test<a id="_idIndexMarker744"/> the following error conditions:</p>
    <ul>
      <li class="bullet">Try opening a file that isn't a CSV file, or a CSV with incorrect fields. What happens?</li>
      <li class="bullet">Open a valid CSV file, select a record for editing, then, before clicking <strong class="screenText">Save</strong>, select a different or empty file. What happens?</li>
      <li class="bullet">Open two copies of the program and point them to the saved CSV file. Try alternating edit or update actions between the programs. Note what happens.</li>
    </ul>
    <p class="normal">Consider how you might address some of these issues; in some cases it may not be possible, and users will just have to be informed of the limitations. Also, if possible, try the last test on different operating systems. Are the results different?</p>
    <h1 id="_idParaDest-215" class="title">Summary</h1>
    <p class="normal">We have changed our program from being an append-only data entry form to an application capable of loading, viewing, and updating data from existing files. In the process, you learned how to update our model so that it could read and update CSV files. You also explored the <code class="Code-In-Text--PACKT-">Treeview</code> widget, including its basic use, virtual events, and column callbacks. You explored using the <code class="Code-In-Text--PACKT-">Treeview</code> widget with hierarchical data structures by creating a file-browsing tool. You learned how to organize multi-form applications using a <code class="Code-In-Text--PACKT-">Notebook</code> widget, and how to create scrolling interfaces using the <code class="Code-In-Text--PACKT-">Scrollbar</code> widget. Finally, you integrated these concepts into the ABQ Data Entry application to address user needs.</p>
    <p class="normal">In our next chapter, we'll be learning how to modify the look and feel of our application. We'll learn about using widget attributes, styles, and themes, as well as working with bitmapped graphics.</p>
  </div>
</body></html>