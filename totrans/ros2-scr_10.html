<html><head></head><body>
		<div id="_idContainer049" class="calibre2">
			<h1 class="chapter-number" id="_idParaDest-187"><a id="_idTextAnchor394" class="pcalibre calibre4 pcalibre1"/>8</h1>
			<h1 id="_idParaDest-188" class="calibre6"><a id="_idTextAnchor395" class="pcalibre calibre4 pcalibre1"/>Parameters – Making Nodes More Dynamic</h1>
			<p class="calibre3">We are now done with the basics of ROS 2 communications. In this chapter, we will continue to work on nodes, but this <a id="_idIndexMarker500" class="pcalibre calibre4 pcalibre1"/>time by making them more dynamic <span>with </span><span><strong class="bold">parameters</strong></span><span>.</span></p>
			<p class="calibre3">To understand parameters, I will start with why we need them in the first place. Then, you will learn how to add parameters to your nodes so that you can customize them at runtime. You will also <a id="_idIndexMarker501" class="pcalibre calibre4 pcalibre1"/>see how to load multiple parameters at once with <strong class="bold">YAML</strong> files and how <a id="_idIndexMarker502" class="pcalibre calibre4 pcalibre1"/>to allow parameters to be modified in your code with <span><strong class="bold">parameter callbacks</strong></span><span>.</span></p>
			<p class="calibre3">As a starting point, we will use the code inside the <strong class="source-inline1">ch7</strong> folder of the book’s GitHub repository (<a href="https://github.com/PacktPublishing/ROS-2-from-Scratch" class="pcalibre calibre4 pcalibre1">https://github.com/PacktPublishing/ROS-2-from-Scratch</a>). If you skipped <em class="italic">actions</em> (<a href="B22403_07.xhtml#_idTextAnchor338" class="pcalibre calibre4 pcalibre1"><span><em class="italic">Chapter 7</em></span></a>), you can also start from the <strong class="source-inline1">ch6</strong> folder, which will work the same. The final code for this chapter will be in the <span><strong class="source-inline1">ch8</strong></span><span> folder.</span></p>
			<p class="calibre3">By the end of this chapter, you will be able to add parameters to any of your nodes and handle parameters for other nodes that <span>you start.</span></p>
			<p class="calibre3">The concept of parameters is not too difficult, and there won’t be too much to do in the code. However, it’s an important concept and the first step toward making your application more dynamic <span>and scalable.</span></p>
			<p class="calibre3">In this chapter, we will cover the <span>following topics:</span></p>
			<ul class="calibre9">
				<li class="calibre10">What is a ROS <span>2 parameter?</span></li>
				<li class="calibre10">Using parameters in <span>your nodes</span></li>
				<li class="calibre10">Storing parameters in <span>YAML files</span></li>
				<li class="calibre10">Additional tools to <span>handle parameters</span></li>
				<li class="calibre10">Updating parameters with <span>parameter callbacks</span></li>
				<li class="calibre10"><span>Parameter challenge</span></li>
			</ul>
			<h1 id="_idParaDest-189" class="calibre6"><a id="_idTextAnchor396" class="pcalibre calibre4 pcalibre1"/>What is a ROS 2 parameter?</h1>
			<p class="calibre3">You have <a id="_idIndexMarker503" class="pcalibre calibre4 pcalibre1"/>already experimented a bit with parameters in <a href="B22403_03.xhtml#_idTextAnchor092" class="pcalibre calibre4 pcalibre1"><span><em class="italic">Chapter 3</em></span></a>, where you ran a node with <span>different settings.</span></p>
			<p class="calibre3">I am now going to start from scratch again and explain parameters with a <span>real-life exampl<a id="_idTextAnchor397" class="pcalibre calibre4 pcalibre1"/>e.</span></p>
			<h2 id="_idParaDest-190" class="calibre6"><a id="_idTextAnchor398" class="pcalibre calibre4 pcalibre1"/>Why parameters?</h2>
			<p class="calibre3">Let’s start with a problem to understand the need for parameters. I will use a camera driver <a id="_idIndexMarker504" class="pcalibre calibre4 pcalibre1"/>as an example—we won’t write the node; it’s just for <span>the explanation.</span></p>
			<p class="calibre3">This camera driver connects to a USB camera, reads images, and publishes them on a ROS 2 topic. This is classic behavior for any ROS 2 <span>hardware driver.</span></p>
			<p class="calibre3">Inside this node, you will have some variables for different kinds of settings. Here are <span>some examples:</span></p>
			<ul class="calibre9">
				<li class="calibre10">USB <a id="_idIndexMarker505" class="pcalibre calibre4 pcalibre1"/><span>device name</span></li>
				<li class="calibre10">Frames per <span>second (FPS)</span></li>
				<li class="calibre10"><span>Simulation mode</span></li>
			</ul>
			<p class="calibre3">Let’s say the camera you’re working on is connected to the <strong class="source-inline1">/dev/ttyUSB0</strong> port (typical USB port name on Linux). You want to set <strong class="source-inline1">60</strong> FPS and not use the simulation mode (<strong class="source-inline1">false</strong>). Those are the values you will write for the variables inside <span>your node.</span></p>
			<p class="calibre3">Later on, if the USB device name is different (for example, <strong class="source-inline1">/dev/ttyUSB1</strong>), you will have to change that setting in your code and maybe build again—you'll do the same thing if you want to start your camera with <strong class="source-inline1">30</strong> FPS instead of <strong class="source-inline1">60</strong> FPS, or if you want to run it in <span>simulation mode.</span></p>
			<p class="calibre3">Also, what if you have two cameras, and you want to use them both at the same time? Will you duplicate your code for each camera? How can you handle the different settings for <span>both cameras?</span></p>
			<p class="calibre3">As you can see, hardcoding those settings in your code is not a great option for reusability. This is why we have ROS <span>2 parame<a id="_idTextAnchor399" class="pcalibre calibre4 pcalibre1"/>ters.</span></p>
			<h2 id="_idParaDest-191" class="calibre6"><a id="_idTextAnchor400" class="pcalibre calibre4 pcalibre1"/>Example of a node with parameters</h2>
			<p class="calibre3">A ROS 2 parameter is basically a setting for a node that you can modify when you start <span>the node.</span></p>
			<p class="calibre3">So, if we <a id="_idIndexMarker506" class="pcalibre calibre4 pcalibre1"/>keep the camera driver example, we could add three parameters—USB device name (string), FPS value (integer), and simulation <span>mode (boolean):</span></p>
			<div class="calibre2">
				<div class="img---figure" id="_idContainer047">
					<img alt="Figure 8.1 – A node class with three parameters" src="image/B22403_08_1.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.1 – A node class with three parameters</p>
			<p class="calibre3">When you start this camera driver with <strong class="source-inline1">ros2 run</strong> (we will see how to do that later in this chapter), you will be able to provide the values you want for those <span>three parameters.</span></p>
			<p class="calibre3">Let’s say you want to start two nodes for two different cameras, given the <span>following settings:</span></p>
			<ol class="calibre11">
				<li class="calibre10">Port: <strong class="source-inline">/dev/ttyUSB0</strong>; FPS: <strong class="source-inline">30</strong>; simulation <span>mode: off</span></li>
				<li class="calibre10">Port: <strong class="source-inline">/dev/ttyUSB1</strong>; FPS: <strong class="source-inline">60</strong>; simulation <span>mode: off</span></li>
			</ol>
			<p class="calibre3">With the parameters we’ve added in the code, we can start the same node multiple times with <span>different values:</span></p>
			<div class="calibre2">
				<div class="img---figure" id="_idContainer048">
					<img alt="Figure 8.2 – Starting two nodes with different settings" src="image/B22403_08_2.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Starting two nodes with different settings</p>
			<p class="calibre3">From the <a id="_idIndexMarker507" class="pcalibre calibre4 pcalibre1"/>same code, we start two different nodes. At runtime, we rename the nodes (because we can’t have two nodes with the same name), and we provide the <span>parameters’ values.</span></p>
			<p class="calibre3">Our two camera nodes are now running, each with a different configuration. You could stop one camera node and start it again with a different set <span>of va<a id="_idTextAnchor401" class="pcalibre calibre4 pcalibre1"/>lues.</span></p>
			<h2 id="_idParaDest-192" class="calibre6"><a id="_idTextAnchor402" class="pcalibre calibre4 pcalibre1"/>ROS 2 parameters – wrapping things up</h2>
			<p class="calibre3">With parameters, you can reuse the same code and start several nodes with different settings. There’s no <a id="_idIndexMarker508" class="pcalibre calibre4 pcalibre1"/>need to compile or build anything again; you just have to provide the parameters’ values <span>at runtime.</span></p>
			<p class="calibre3">Making your nodes customizable allows for greater flexibility and reusability. Your application will become much <span>more dynamic.</span></p>
			<p class="calibre3">Parameters are also very convenient for collaborating with other ROS developers. If you develop a node that could be reused by others, then with parameters, you allow other developers to fully customize the node without even having to look at the code. This also applies when using existing nodes. Lots of them can be configured <span>at runtime.</span></p>
			<p class="calibre3">Here are a few important points <span>about parameters:</span></p>
			<ul class="calibre9">
				<li class="calibre10">Just as with a variable, a parameter has a name and a data type. Among the most common types, you can use booleans, integer numbers, float numbers, strings, and lists of <span>those types.</span></li>
				<li class="calibre10">A parameter’s <a id="_idIndexMarker509" class="pcalibre calibre4 pcalibre1"/>value is specific to a node. If you kill the node, the value is gone <span>with it.</span></li>
				<li class="calibre10">You can set the value for each parameter when you start a node with <strong class="source-inline">ros2 run</strong> (or from a launch file, which we will see in the <span>next chapter).</span></li>
			</ul>
			<p class="calibre3">Now, how to add parameters to your code? As for nodes, topics, and services, you will get everything you need from the <strong class="source-inline1">rclpy</strong> and <strong class="source-inline1">rclcpp</strong> libraries. You will be able to declare the parameters in your code and get the value for <span>each par<a id="_idTextAnchor403" class="pcalibre calibre4 pcalibre1"/>ameter.</span></p>
			<h1 id="_idParaDest-193" class="calibre6"><a id="_idTextAnchor404" class="pcalibre calibre4 pcalibre1"/>Using parameters in your nodes</h1>
			<p class="calibre3">We will continue with the code we have written in the previous chapters. Here, we will improve the <strong class="source-inline1">number_publisher</strong> node. As a quick recap, this node publishes a number <a id="_idIndexMarker510" class="pcalibre calibre4 pcalibre1"/>on a topic, at a given rate. The number <a id="_idIndexMarker511" class="pcalibre calibre4 pcalibre1"/>and publishing rate are directly written in <span>the code.</span></p>
			<p class="calibre3">Now, instead of hardcoding the number and publishing rate values, we will use parameters. This way, we will be able to specify what number to publish, and the publishing frequency or period, when we start <span>the node.</span></p>
			<p class="calibre3">You need to follow two steps to be able to use a parameter in <span>your code:</span></p>
			<ol class="calibre11">
				<li class="calibre10">Declare the parameter in the node. This will make the parameter exist within the node so that you can set a value to it when starting the node with <span><strong class="source-inline">ros2 run</strong></span><span>.</span></li>
				<li class="calibre10">Retrieve the parameter’s value so that you can use it in <span>the code.</span></li>
			</ol>
			<p class="calibre3">Let’s start with Python, and later on, we will also see the <a id="_idTextAnchor405" class="pcalibre calibre4 pcalibre1"/><span>C++ code.</span></p>
			<h2 id="_idParaDest-194" class="calibre6"><a id="_idTextAnchor406" class="pcalibre calibre4 pcalibre1"/>Declaring, getting, and using parameters with Python</h2>
			<p class="calibre3">Before <a id="_idIndexMarker512" class="pcalibre calibre4 pcalibre1"/>using a parameter, we need to declare it. Where <a id="_idIndexMarker513" class="pcalibre calibre4 pcalibre1"/>should we declare parameters? We will do <a id="_idIndexMarker514" class="pcalibre calibre4 pcalibre1"/>that in the node’s constructor, before everything else. To <a id="_idIndexMarker515" class="pcalibre calibre4 pcalibre1"/>declare a parameter, use the <strong class="source-inline1">declare_parameter()</strong> method <a id="_idIndexMarker516" class="pcalibre calibre4 pcalibre1"/>from the <span><strong class="source-inline1">Node</strong></span><span> class.</span></p>
			<p class="calibre3">You <a id="_idIndexMarker517" class="pcalibre calibre4 pcalibre1"/>will provide <span>two arguments:</span></p>
			<ul class="calibre9">
				<li class="calibre10"><strong class="bold">Parameter name</strong>: This is the name that you will use to set the parameter’s value <span>at runtime</span></li>
				<li class="calibre10"><strong class="bold">Default value</strong>: If the parameter’s value is not provided at runtime, this value will <span>be used</span></li>
			</ul>
			<p class="calibre3">There are, in fact, different ways to declare a parameter. You don’t necessarily need to provide a <a id="_idIndexMarker518" class="pcalibre calibre4 pcalibre1"/>default value if you provide the parameter type instead. However, we will keep things like that, as it will probably make your life easier. Adding a default value for each parameter is a best practice <span>to follow.</span></p>
			<p class="calibre3">Open the <strong class="source-inline1">number_publisher.py</strong> file, and let’s declare two parameters in <span>the constructor:</span></p>
			<pre class="source-code">
self.declare_parameter("number", 2)
self.declare_parameter("publish_period", 1.0)</pre>			<p class="calibre3">A parameter is defined by a name and a data type. Here, you choose the name, and the data type will be automatically set depending on the default value you have provided. In this example, the default value for <strong class="source-inline1">number</strong> is <strong class="source-inline1">2</strong>, which means that the parameter’s data type is integer. For the <strong class="source-inline1">publish_period</strong> parameter, the default value is <strong class="source-inline1">1.0</strong>, which is a <span>float number.</span></p>
			<p class="calibre3">Here are <a id="_idIndexMarker519" class="pcalibre calibre4 pcalibre1"/>a few <a id="_idIndexMarker520" class="pcalibre calibre4 pcalibre1"/>more examples of different <span>data types:</span></p>
			<ul class="calibre9">
				<li class="calibre10"><strong class="bold">Booleans</strong>: <span><strong class="source-inline">self.declare_parameter("simulation_mode", False)</strong></span></li>
				<li class="calibre10"><strong class="bold">String</strong>: <span><strong class="source-inline">self.declare_parameter("device_name", "/dev/ttyUSB0")</strong></span></li>
				<li class="calibre10"><strong class="bold">Integer array</strong>: <strong class="source-inline">self.declare_parameter("numbers", [4, </strong><span><strong class="source-inline">5, 6])</strong></span></li>
			</ul>
			<p class="calibre3">Now, declaring <a id="_idIndexMarker521" class="pcalibre calibre4 pcalibre1"/>a parameter means that it exists within the node, and you can set a value from the outside. However, in your code, to be able to use the parameter, it’s not enough to declare it. After doing that, you need to get <span>the value.</span></p>
			<p class="calibre3">For this, you <a id="_idIndexMarker522" class="pcalibre calibre4 pcalibre1"/>will use the <strong class="source-inline1">get_parameter()</strong> method, and <a id="_idIndexMarker523" class="pcalibre calibre4 pcalibre1"/>provide the parameter’s name as an argument. Then, you <a id="_idIndexMarker524" class="pcalibre calibre4 pcalibre1"/>can access the value with the <span><strong class="source-inline1">value</strong></span><span> attribute:</span></p>
			<pre class="source-code">
self.number_ = self.get_parameter("number").value
self.timer_period_ = self.get_parameter(
    "publish_period"
).value</pre>			<p class="calibre3">At this <a id="_idIndexMarker525" class="pcalibre calibre4 pcalibre1"/>point in the code, the <strong class="source-inline1">number_</strong> variable (which is a class attribute) contains <a id="_idIndexMarker526" class="pcalibre calibre4 pcalibre1"/>the value that was set <a id="_idIndexMarker527" class="pcalibre calibre4 pcalibre1"/>for the <strong class="source-inline1">number</strong> parameter at runtime with <span><strong class="source-inline1">ros2 run</strong></span><span>.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">You always need to declare a parameter before getting its value. If you fail to do so, when starting the node, you will get an exception (<strong class="source-inline">ParameterNotDeclaredException</strong>) as soon as you try to get <span>the value.</span></p>
			<p class="calibre3">After you get the values for all parameters and store them inside variables or class attributes, you can use them in your code. Here, we modify the <span>timer callback:</span></p>
			<pre class="source-code">
self.number_timer_ = self.create_timer(
    self.timer_period_, self.publish_number
)</pre>			<p class="calibre3">With this, we set the publishing period from the <span>parameter’s value.</span></p>
			<p class="calibre3">That’s <a id="_idIndexMarker528" class="pcalibre calibre4 pcalibre1"/>pretty much it for the code. As you can see, there is nothing <a id="_idIndexMarker529" class="pcalibre calibre4 pcalibre1"/>too complicated. For one parameter, you <a id="_idIndexMarker530" class="pcalibre calibre4 pcalibre1"/>will just add two instructions: one to <a id="_idIndexMarker531" class="pcalibre calibre4 pcalibre1"/>declare the parameter (give it a name and a default value), and <a id="_idIndexMarker532" class="pcalibre calibre4 pcalibre1"/>another to get <span>its value.</span></p>
			<p class="calibre3">Now, I’ve been <a id="_idIndexMarker533" class="pcalibre calibre4 pcalibre1"/>talking about setting a parameter’s value at runtime wi<a id="_idTextAnchor407" class="pcalibre calibre4 pcalibre1"/>th <strong class="source-inline1">ros2 run</strong>. How do we <span>do that?</span></p>
			<h2 id="_idParaDest-195" class="calibre6"><a id="_idTextAnchor408" class="pcalibre calibre4 pcalibre1"/>Providing parameters at runtime</h2>
			<p class="calibre3">Before going further, make sure to save the <strong class="source-inline1">number_publisher.py</strong> file and build the <strong class="source-inline1">my_py_pkg</strong> package (if you haven’t used <strong class="source-inline1">--</strong><span><strong class="source-inline1">symlink-install</strong></span><span> before).</span></p>
			<p class="calibre3">To provide <a id="_idIndexMarker534" class="pcalibre calibre4 pcalibre1"/>a parameter’s value with the <strong class="source-inline1">ros2 run</strong> command, follow the <span>next steps:</span></p>
			<ol class="calibre11">
				<li class="calibre10">You will first start your node with <strong class="source-inline">ros2 run &lt;</strong><span><strong class="source-inline">package_name&gt; &lt;exec_name&gt;</strong></span><span>.</span></li>
				<li class="calibre10">Then, to add any argument after this command, you have to write <strong class="source-inline">--ros-args</strong> (<span>only once).</span></li>
				<li class="calibre10">To specify a parameter’s value, write <strong class="source-inline">-p &lt;param_name&gt;:=&lt;param_value&gt;</strong>. You can add as many parameters as <span>you want.</span></li>
			</ol>
			<p class="calibre3">Let’s say we want to start the node and publish the number <strong class="source-inline1">3</strong> every <strong class="source-inline1">0.5</strong> seconds. In that case, we’d run the <span>following command:</span></p>
			<pre class="console">
$ ros2 run my_py_pkg number_publisher --ros-args -p number:=3 -p publish_period:=0.5</pre>			<p class="calibre3">To verify it’s working, we can subscribe to the <strong class="source-inline1">/</strong><span><strong class="source-inline1">number</strong></span><span> topic:</span></p>
			<pre class="console">
$ ros2 topic echo /number
data: 3
---
data: 3
---</pre>			<p class="calibre3">We can also verify the <span>publish rate:</span></p>
			<pre class="console">
$ ros2 topic hz /number
average rate: 2.000
    min: 0.500s max: 0.500s std dev: 0.00004s window: 3</pre>			<p class="calibre3">So, what happened? You provided some values for different parameters at runtime. The node will start <a id="_idIndexMarker535" class="pcalibre calibre4 pcalibre1"/>and recognize those parameters because they match the names that have been declared in the code. Then, the node can get the value for <span>each parameter.</span></p>
			<p class="calibre3">If you provide the wrong data type for a parameter, you will get an error. As seen previously, the data type is set in the code from the default value. In this example, the <strong class="source-inline1">number</strong> parameter should be an integer number. Look at what happens if we try to set a <span>double value:</span></p>
			<pre class="console">
$ ros2 run my_py_pkg number_publisher --ros-args -p number:=3.14
…
    raise InvalidParameterTypeException(
rclpy.exceptions.InvalidParameterTypeException: Trying to set parameter 'number' to '3.14' of type 'DOUBLE', expecting type 'INTEGER': number
[ros2run]: Process exited with failure 1</pre>			<p class="calibre3">As you can see, once a parameter type is set in the code, you have to use that exact same type whenever you provide a value <span>at runtime.</span></p>
			<p class="calibre3">As each parameter has a default value, you could also omit one or <span>more parameters:</span></p>
			<pre class="console">
$ ros2 run my_py_pkg number_publisher --ros-args -p number:=3</pre>			<p class="calibre3">In this case, the <strong class="source-inline1">publish_period</strong> parameter will be set to its default value (<strong class="source-inline1">1.0</strong>), defined in <span>the code.</span></p>
			<p class="calibre3">To finish here, let’s just see an example where renaming the node and setting parameters’ values can allow you to run several different nodes from the same code without having to modify anything in <span>the code.</span></p>
			<p class="calibre3">In Terminal 1, run <span>the following:</span></p>
			<pre class="console">
$ ros2 run my_py_pkg number_publisher --ros-args -r __node:=num_pub1 -p number:=3 -p publish_period:=0.5</pre>			<p class="calibre3">In Terminal 2, run <span>the following:</span></p>
			<pre class="console">
$ ros2 run my_py_pkg number_publisher --ros-args -r __node:=num_pub2 -p number:=4 -p publish_period:=1.0</pre>			<p class="calibre3">With this, you have <a id="_idIndexMarker536" class="pcalibre calibre4 pcalibre1"/>two nodes (<strong class="source-inline1">num_pub1</strong> and <strong class="source-inline1">num_pub2</strong>), both publishing to the <strong class="source-inline1">/number</strong> topic but with different data and publishing rates. With this example, you can see that parameters are a great way to make your nodes <span>more dynamic.</span></p>
			<p class="calibre3">Let’s now finish this section<a id="_idTextAnchor409" class="pcalibre calibre4 pcalibre1"/> with the C++ code <span>for parameters.</span></p>
			<h2 id="_idParaDest-196" class="calibre6"><a id="_idTextAnchor410" class="pcalibre calibre4 pcalibre1"/>Parameters with C++</h2>
			<p class="calibre3">Parameters work the same for Python and C++; only the syntax differs. Here, we will modify the <span><strong class="source-inline1">number_publisher.cpp</strong></span><span> file.</span></p>
			<p class="calibre3">In the <a id="_idIndexMarker537" class="pcalibre calibre4 pcalibre1"/>constructor, you can declare <span>some parameters:</span></p>
			<pre class="source-code">
this-&gt;declare_parameter("number", 2);
this-&gt;declare_parameter("publish_period", 1.0);</pre>			<p class="calibre3">We use the <strong class="source-inline1">declare_parameter()</strong> method from the <strong class="source-inline1">rclcpp::Node</strong> class. The arguments <a id="_idIndexMarker538" class="pcalibre calibre4 pcalibre1"/>are the same as for Python: name and default value. From this value, the parameter type will <span>be set.</span></p>
			<p class="calibre3">Then, to get a parameter’s value in the code, write <span>the following:</span></p>
			<pre class="source-code">
number_ = this-&gt;get_parameter("number").as_int();
double timer_period = this-&gt;get_parameter("publish_period")
                            .as_double();</pre>			<p class="calibre3">We use the <strong class="source-inline1">get_parameter()</strong> method and provide the name for the parameter. Then, we get the value with the method that corresponds to the data type: <strong class="source-inline1">as_int()</strong>, <strong class="source-inline1">as_double()</strong>, <strong class="source-inline1">as_string()</strong>, <strong class="source-inline1">as_string_array()</strong>, and so on. If you have an IDE with auto-completion, you should be able to see all <span>possible types.</span></p>
			<p class="calibre3">The rest is the same as for Python. Please refer to the GitHub files for any other minor changes <span>and additions.</span></p>
			<p class="calibre3">To start a node with parameters, run <span>the following:</span></p>
			<pre class="console">
$ ros2 run my_cpp_pkg number_publisher --ros-args -p number:=4 -p publish_period:=1.2</pre>			<p class="calibre3">Working with <a id="_idIndexMarker539" class="pcalibre calibre4 pcalibre1"/>parameters is not that tough. For each parameter <a id="_idIndexMarker540" class="pcalibre calibre4 pcalibre1"/>you want to create, you have to declare it in the code and get its value. When starting the node from the terminal, you can specify a value for each parameter <span>you want.</span></p>
			<p class="calibre3">Now, that works well only if you have a small number of parameters. In a real application, it’s not uncommon to have a few dozen or even hundreds of parameters for a node. <a id="_idTextAnchor411" class="pcalibre calibre4 pcalibre1"/>How can you manage so <span>many parameters?</span></p>
			<h1 id="_idParaDest-197" class="calibre6"><a id="_idTextAnchor412" class="pcalibre calibre4 pcalibre1"/>Storing parameters in YAML files</h1>
			<p class="calibre3">As your ROS 2 application grows, so will the number of parameters. Adding 10 or more parameters <a id="_idIndexMarker541" class="pcalibre calibre4 pcalibre1"/>from the command line is not really an <span>option anymore.</span></p>
			<p class="calibre3">Fortunately, you can <a id="_idIndexMarker542" class="pcalibre calibre4 pcalibre1"/>use YAML files to store your parameters, and you can load these files at runtime. If you don’t know YAML, it’s basically a markup language, similar to XML and JSON, but supposedly more readable <span>by humans.</span></p>
			<p class="calibre3">In this section, you will learn how to add your parameters to a YAML fi<a id="_idTextAnchor413" class="pcalibre calibre4 pcalibre1"/>le and how to load this file <span>at runtime.</span></p>
			<h2 id="_idParaDest-198" class="calibre6"><a id="_idTextAnchor414" class="pcalibre calibre4 pcalibre1"/>Loading parameters from a YAML file</h2>
			<p class="calibre3">Let’s start <a id="_idIndexMarker543" class="pcalibre calibre4 pcalibre1"/>by saving parameters into a file so we <a id="_idIndexMarker544" class="pcalibre calibre4 pcalibre1"/>can use them when we start <span>a node.</span></p>
			<p class="calibre3">First, create a YAML file with the <strong class="source-inline1">.yaml</strong> extension. The filename doesn’t matter that much, but it’s better to give it a meaningful name. As our application deals with numbers, we can name <span>it </span><span><strong class="source-inline1">number_params.yaml</strong></span><span>.</span></p>
			<p class="calibre3">For now, let’s just create a new file in our home directory (in the next chapter, we will see how to properly install a YAML file in a ROS <span>2 application):</span></p>
			<pre class="console">
$ cd ~
$ touch number_params.yaml</pre>			<p class="calibre3">Edit this <a id="_idIndexMarker545" class="pcalibre calibre4 pcalibre1"/>file and add parameters for the <strong class="source-inline1">/</strong><span><strong class="source-inline1">number_publisher</strong></span><span> node:</span></p>
			<pre class="source-code">
/number_publisher:
  ros__parameters:
    number: 7
    publish_period: 0.8</pre>			<p class="calibre3">First, you <a id="_idIndexMarker546" class="pcalibre calibre4 pcalibre1"/>write the name of the node. On the next line, and with an indentation (usually, it’s recommended to use two spaces), we add <strong class="source-inline1">ros__parameters</strong> (make sure you use two underscores). This will be the same for every node you add in a YAML file. On the following lines, and with yet another indentation, you can add all the parameters’ values for <span>the node.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">It’s important that the node name matches; otherwise, the parameters won’t be loaded into the node. If you omit the leading slash, it would still work for loading parameters with <strong class="source-inline">ros2 run</strong>, but you could have issues with <span>other commands.</span></p>
			<p class="calibre3">Once you’ve written this file, you can load the parameters with the <strong class="source-inline1">--</strong><span><strong class="source-inline1">params-file</strong></span><span> argument:</span></p>
			<pre class="console">
$ ros2 run my_py_pkg number_publisher --ros-args --params-file ~/number_params.yaml</pre>			<p class="calibre3">This will start the node and specify the values for the <strong class="source-inline1">number</strong> and <span><strong class="source-inline1">publish_period</strong></span><span> parameters.</span></p>
			<p class="calibre3">If you have two or fifty parameters, the <strong class="source-inline1">ros2 run</strong> command stays the same. All you have to do is add more parameters in the YAML file. If you want to modify a parameter, you can modify the corresponding line in the file or even create several<a id="_idTextAnchor415" class="pcalibre calibre4 pcalibre1"/> files for different sets <span>of configurations.</span></p>
			<h2 id="_idParaDest-199" class="calibre6"><a id="_idTextAnchor416" class="pcalibre calibre4 pcalibre1"/>Parameters for multiple nodes</h2>
			<p class="calibre3">What should you do if you want to save parameters for <span>several nodes?</span></p>
			<p class="calibre3">Good news: inside <a id="_idIndexMarker547" class="pcalibre calibre4 pcalibre1"/>one param YAML file, you can add the configuration for as many nodes as you want. Here’s <span>an example:</span></p>
			<pre class="source-code">
/num_pub1:
  ros__parameters:
    number: 3
    publish_period: 0.5
/num_pub2:
  ros__parameters:
    number: 4
    publish_period: 1.0</pre>			<p class="calibre3">This corresponds to the example we ran before, with two nodes and <span>different parameters.</span></p>
			<p class="calibre3">Now, to start the same nodes and parameters, we only need to run the commands <span>shown next.</span></p>
			<p class="calibre3">In Terminal 1, run <span>the following:</span></p>
			<pre class="console">
$ ros2 run my_py_pkg number_publisher --ros-args -r __node:=num_pub1 --params-file ~/number_params.yaml</pre>			<p class="calibre3">In Terminal 2, run <span>the following:</span></p>
			<pre class="console">
$ ros2 run my_py_pkg number_publisher --ros-args -r __node:=num_pub2 --params-file ~/number_params.yaml</pre>			<p class="calibre3">We give the same YAML file to both nodes. Each node will only load the parameters’<a id="_idTextAnchor417" class="pcalibre calibre4 pcalibre1"/> values that are defined under the <span>node name.</span></p>
			<h2 id="_idParaDest-200" class="calibre6"><a id="_idTextAnchor418" class="pcalibre calibre4 pcalibre1"/>Recapping all parameters’ data types</h2>
			<p class="calibre3">Let’s say <a id="_idIndexMarker548" class="pcalibre calibre4 pcalibre1"/>you have all those parameters declared in your code (Python example only, but you can easily translate <span>to C++):</span></p>
			<pre class="source-code">
self.declare_parameter("bool_value", False)
self.declare_parameter("int_number", 1)
self.declare_parameter("float_number", 0.0)
self.declare_parameter("str_text", "Hola")
self.declare_parameter("int_array", [1, 2, 3])
self.declare_parameter("float_array", [3.14, 1.2])
self.declare_parameter("str_array", ["default", "values"])
self.declare_parameter("bytes_array", [0x03, 0xA1])</pre>			<p class="calibre3">Those are basically all the available data types <span>for parameters.</span></p>
			<p class="calibre3">To specify the value for each parameter, you can create a YAML file or add some configuration to an existing YAML file. Here is what you would write for this node (<span>named </span><span><strong class="source-inline1">your_node</strong></span><span>):</span></p>
			<pre class="source-code">
/your_node:
  ros__parameters:
     bool_value: True
     int_number: 5
     float_number: 3.14
     str_text: "Hello"
     bool_array: [True, False, True]
     int_array: [10, 11, 12, 13]
     float_array: [7.5, 400.4]
     str_array: ['Nice', 'more', 'params']
     bytes_array: [0x01, 0xF1, 0xA2]</pre>			<p class="calibre3">With YAML files, you will be able to customize your nodes in a quick and efficient way. I recommend using them as soon as you get more than a <span>few parameters.</span></p>
			<p class="calibre3">Also, as you <a id="_idIndexMarker549" class="pcalibre calibre4 pcalibre1"/>continue your journey with ROS 2, you will start to use nodes and complete stacks developed by other developers. Those nodes often come with a bunch of YAML files that allow you to configure the stack without having to change anything in the <span>nodes directly.</span></p>
			<p class="calibre3">Let’s now continue with the command-line tools. You have set the parameters’ values with <strong class="source-inline1">ros2 run</strong>, but ther<a id="_idTextAnchor419" class="pcalibre calibre4 pcalibre1"/>e are actually more tools to <span>handle parameters.</span></p>
			<h1 id="_idParaDest-201" class="calibre6"><a id="_idTextAnchor420" class="pcalibre calibre4 pcalibre1"/>Additional tools for handling parameters</h1>
			<p class="calibre3">You start to get used to it: for each ROS 2 core concept, we get a dedicated <strong class="source-inline1">ros2</strong> command-line tool. For parameters, we have <span><strong class="source-inline1">ros2 param</strong></span><span>.</span></p>
			<p class="calibre3">You can <a id="_idIndexMarker550" class="pcalibre calibre4 pcalibre1"/>see all the commands with <strong class="source-inline1">ros2 param -h</strong>. Let’s focus on the most important ones so that we can get parameters’ values from the terminal and set some values after the node has been started. At the end of this section, we will also explore the diffe<a id="_idTextAnchor421" class="pcalibre calibre4 pcalibre1"/>rent parameter services available for <span>all nodes.</span></p>
			<h2 id="_idParaDest-202" class="calibre6"><a id="_idTextAnchor422" class="pcalibre calibre4 pcalibre1"/>Getting parameters’ values from the terminal</h2>
			<p class="calibre3">After you’ve <a id="_idIndexMarker551" class="pcalibre calibre4 pcalibre1"/>started one or several nodes, you can list all available parameters with <strong class="source-inline1">ros2 </strong><span><strong class="source-inline1">param list</strong></span><span>.</span></p>
			<p class="calibre3">Stop all nodes and start two nodes, <strong class="source-inline1">num_pub1</strong> and <strong class="source-inline1">num_pub2</strong>, either by using the YAML file or by providing the parameters’ <span>values manually.</span></p>
			<p class="calibre3">In Terminal 1, run <span>the following:</span></p>
			<pre class="console">
$ ros2 run my_py_pkg number_publisher --ros-args -r __node:=num_pub1 -p number:=3 -p publish_period:=0.5</pre>			<p class="calibre3">In Terminal 2, run <span>the following:</span></p>
			<pre class="console">
$ ros2 run my_py_pkg number_publisher --ros-args -r __node:=num_pub2 -p number:=4 -p publish_period:=1.0</pre>			<p class="calibre3">Now, list all <span>available parameters:</span></p>
			<pre class="console">
$ ros2 param list
/num_pub1:
  number
  publish_period
  start_type_description_service
  use_sim_time
/num_pub2:
  number
  publish_period
  start_type_description_service
  use_sim_time</pre>			<p class="calibre3">Here, I started <a id="_idIndexMarker552" class="pcalibre calibre4 pcalibre1"/>two nodes to show you that each node gets its own set of parameters. The <strong class="source-inline1">number</strong> parameter inside <strong class="source-inline1">/num_pub1</strong> is not the same as the <strong class="source-inline1">number</strong> parameter <span>inside </span><span><strong class="source-inline1">/num_pub2</strong></span><span>.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">For each parameter, we also always get the <strong class="source-inline">use_sim_time</strong> parameter with a default value of <strong class="source-inline">false</strong>. This means that we use the system clock. We would set it to <strong class="source-inline">true</strong> if we were simulating the robot so that we could use the simulation engine clock instead. This is not important for now, and you can ignore this parameter. You can also ignore the <span><strong class="source-inline">start_type_description_service</strong></span><span> parameter.</span></p>
			<p class="calibre3">From this, you can get the value for one specific parameter, using <strong class="source-inline1">ros2 param get &lt;</strong><span><strong class="source-inline1">node_name&gt; &lt;param_name&gt;</strong></span><span>:</span></p>
			<pre class="console">
$ ros2 param get /num_pub1 number
Integer value is: 3
$ ros2 param get /num_pub2 number
Integer value is: 4</pre>			<p class="calibre3">This corresponds to the values we have set when starting the node. Using <strong class="source-inline1">ros2 param get</strong> allows you to <a id="_idTextAnchor423" class="pcalibre calibre4 pcalibre1"/>introspect the parameters inside any <span>running node.</span></p>
			<h2 id="_idParaDest-203" class="calibre6"><a id="_idTextAnchor424" class="pcalibre calibre4 pcalibre1"/>Exporting parameters into YAML</h2>
			<p class="calibre3">If you’d <a id="_idIndexMarker553" class="pcalibre calibre4 pcalibre1"/>like to get the complete set of parameters for a node, you can do so with <strong class="source-inline1">ros2 param </strong><span><strong class="source-inline1">dump &lt;node_name&gt;</strong></span><span>.</span></p>
			<p class="calibre3">Let’s dump all parameters for the nodes we <span>are running.</span></p>
			<p class="calibre3">For the first node, run <span>the following:</span></p>
			<pre class="console">
$ ros2 param dump /num_pub1
/num_pub1:
  ros__parameters:
    number: 3
    publish_period: 0.5
    start_type_description_service: true
    use_sim_time: false</pre>			<p class="calibre3">For the second node, run <span>the following:</span></p>
			<pre class="console">
$ ros2 param dump /num_pub2
/num_pub2:
  ros__parameters:
    number: 4
    publish_period: 1.0
    start_type_description_service: true
    use_sim_time: false</pre>			<p class="calibre3">As you can see, the output is exactly what you need to write inside a YAML file. You can then just copy and paste what you get in the terminal and create your own YAML file to load later (there’s no need to set <strong class="source-inline1">use_sim_time</strong> <span>and </span><span><strong class="source-inline1">start_type_description_service</strong></span><span>).</span></p>
			<p class="calibre3">This <strong class="source-inline1">ros2 param dump</strong> command can be useful for getting all parameters’ values <a id="_idTextAnchor425" class="pcalibre calibre4 pcalibre1"/>at once and for building a param YAML <span>file quickly.</span></p>
			<h2 id="_idParaDest-204" class="calibre6"><a id="_idTextAnchor426" class="pcalibre calibre4 pcalibre1"/>Setting a parameter’s value from the terminal</h2>
			<p class="calibre3">Parameters are actually not set in stone for the entire life of a node. After you initialize a parameter’s value with <strong class="source-inline1">ros2 run</strong>, you can modify it from <span>the terminal.</span></p>
			<p class="calibre3">With our <a id="_idIndexMarker554" class="pcalibre calibre4 pcalibre1"/>camera driver example, let’s say you disconnect and reconnect the camera. The device name might change on Linux. If it were <strong class="source-inline1">/dev/ttyUSB0</strong>, now it could be <strong class="source-inline1">/dev/ttyUSB1</strong>. You could stop and start the node again with a different value for the device name parameter, but with the <strong class="source-inline1">ros2 param set</strong> command, you could also just change the value directly while the node is <span>still running.</span></p>
			<p class="calibre3">To show you how it works, let’s come back to our <span>number application.</span></p>
			<p class="calibre3">Stop all nodes and start one <strong class="source-inline1">number_publisher</strong> node (here, I don’t provide any parameter; we will use the <span>default values):</span></p>
			<pre class="console">
$ ros2 run my_py_pkg number_publisher</pre>			<p class="calibre3">Let’s just verify the value for the <span><strong class="source-inline1">number</strong></span><span> parameter:</span></p>
			<pre class="console">
$ ros2 param get /number_publisher number
Integer value is: 2</pre>			<p class="calibre3">To modify a parameter from the terminal, you have to run <strong class="source-inline1">ros2 param set &lt;node_name&gt; &lt;param_name&gt; &lt;new_value&gt;</strong>, as in the <span>following example:</span></p>
			<pre class="console">
$ ros2 param set /number_publisher number 3
Set parameter successful</pre>			<p class="calibre3">Of course, make sure to provide the correct data type for the parameter; otherwise, you will get an error. You can also load a YAML file directly with <strong class="source-inline1">ros2 param load &lt;node_name&gt; &lt;yaml_file&gt;</strong> so that you can set several parameters at the <span>same time:</span></p>
			<pre class="console">
$ ros2 param load /number_publisher ~/number_params.yaml
Set parameter number successful
Set parameter publish_period successful</pre>			<p class="calibre3">After modifying a parameter, we check the parameter’s <span>value again:</span></p>
			<pre class="console">
$ ros2 param get /number_publisher number
Integer value is: 7</pre>			<p class="calibre3">As you can see, the value was successfully changed. However, did this really work? Is the new parameter’s value used in <span>the code?</span></p>
			<p class="calibre3">Let’s verify <a id="_idIndexMarker555" class="pcalibre calibre4 pcalibre1"/>that we are publishing the <span>correct number:</span></p>
			<pre class="console">
$ ros2 topic echo /number
data: 2
---</pre>			<p class="calibre3">Even if we changed the parameter’s value, the new value was not updated inside the code. To do that, we will need to add a parameter callback. That’s what we will see in a minute, but for now, let’s just finish this section with the extra e<a id="_idTextAnchor427" class="pcalibre calibre4 pcalibre1"/>xisting services that allow you to <span>manage parameters.</span></p>
			<h2 id="_idParaDest-205" class="calibre6"><a id="_idTextAnchor428" class="pcalibre calibre4 pcalibre1"/>Parameter services</h2>
			<p class="calibre3">If you remember, when we worked on services, you saw that for each node, we got an additional set <a id="_idIndexMarker556" class="pcalibre calibre4 pcalibre1"/>of seven services, most of them related <span>to parameters.</span></p>
			<p class="calibre3">List all services for the <span><strong class="source-inline1">number_publisher</strong></span><span> node:</span></p>
			<pre class="console">
$ ros2 service list
/number_publisher/describe_parameters
/number_publisher/get_parameter_types
/number_publisher/get_parameters
/number_publisher/get_type_description
/number_publisher/list_parameters
/number_publisher/set_parameters
/number_publisher/set_parameters_atomically</pre>			<p class="calibre3">With those services, you can list parameters, get their value, and even set new values. Those services basically give you the same functionalities as the <strong class="source-inline1">ros2 param</strong> <span>command-line tool.</span></p>
			<p class="calibre3">This is good news because getting and setting parameters from the terminal is not really practical and scalable in a real application. By using those services, you can create a service client in node A, which will get or modify parameters in <span>node B.</span></p>
			<p class="calibre3">I will not dive <a id="_idIndexMarker557" class="pcalibre calibre4 pcalibre1"/>too far into this; you can experiment on your own with what you saw in <a href="B22403_06.xhtml#_idTextAnchor282" class="pcalibre calibre4 pcalibre1"><span><em class="italic">Chapter 6</em></span></a>. Let’s just do a quick example here by modifying the <strong class="source-inline1">number</strong> parameter. Let’s first check which interface you need <span>to use:</span></p>
			<pre class="console">
$ ros2 service type /number_publisher/set_parameters
rcl_interfaces/srv/SetParameters</pre>			<p class="calibre3">Then, you can get more details with <strong class="source-inline1">ros2 interface show</strong>. Finally, you can create a service client (inside a node) to modify a parameter. Let’s do so from <span>the terminal:</span></p>
			<pre class="console">
$ ros2 service call /number_publisher/set_parameters rcl_interfaces/srv/SetParameters "{parameters: [{name: 'number', value: {type: 2, integer_value: 3}}]}"</pre>			<p class="calibre3">This is the same as running <strong class="source-inline1">ros2 param set /number_publisher number 3</strong>. The benefit of the service is that you can use it inside any of your other nodes, with a service client from <strong class="source-inline1">rclpy</strong> <span>or </span><span><strong class="source-inline1">rclcpp</strong></span><span>.</span></p>
			<p class="calibre3">If you’re wondering what <strong class="source-inline1">type: 2</strong> means in the service request, here are all the types you can get or set with the <span>parameter services:</span></p>
			<pre class="console">
$ ros2 interface show rcl_interfaces/msg/ParameterType
uint8 PARAMETER_NOT_SET=0
uint8 PARAMETER_BOOL=1
uint8 PARAMETER_INTEGER=2
uint8 PARAMETER_DOUBLE=3
uint8 PARAMETER_STRING=4
uint8 PARAMETER_BYTE_ARRAY=5
uint8 PARAMETER_BOOL_ARRAY=6
uint8 PARAMETER_INTEGER_ARRAY=7
uint8 PARAMETER_DOUBLE_ARRAY=8
uint8 PARAMETER_STRING_ARRAY=9</pre>			<p class="calibre3">So, the number <strong class="source-inline1">2</strong> corresponds to the <span><strong class="source-inline1">PARAMETER_INTEGER</strong></span><span> type.</span></p>
			<p class="calibre3">Now that you’ve <a id="_idIndexMarker558" class="pcalibre calibre4 pcalibre1"/>seen how to set a parameter’s value while the node is already running, let’s continue with parameter callbacks. The problem so far is that if <a id="_idTextAnchor429" class="pcalibre calibre4 pcalibre1"/>we modify a parameter, the value doesn’t <em class="italic">reach</em> <span>the code.</span></p>
			<h1 id="_idParaDest-206" class="calibre6"><a id="_idTextAnchor430" class="pcalibre calibre4 pcalibre1"/>Updating parameters with parameter callbacks</h1>
			<p class="calibre3">After a parameter’s value has been set when the node starts, you can modify it from the terminal <a id="_idIndexMarker559" class="pcalibre calibre4 pcalibre1"/>or with a service client. To be able to receive the new value in your code, however, you will need to add what is called a <a id="_idIndexMarker560" class="pcalibre calibre4 pcalibre1"/><span>parameter callback.</span></p>
			<p class="calibre3">In this section, you will learn how to implement a parameter callback for Python and C++. This callback <a id="_idIndexMarker561" class="pcalibre calibre4 pcalibre1"/>will be triggered whenever a parameter’s value has been changed, and we will be able to get the new value in <span>the code.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">You don’t necessarily need to add parameter callbacks in your nodes. For some parameters, you will want to have a fixed value when you start the node and not modify this value anymore. Use parameter callbacks only if it makes sense to modify some parameters during the execution of <span>a node.</span></p>
			<p class="calibre3">Parameter callbacks are a great way to change a setting in your node without having to create yet another service. Let me explain that with the camera driver example. If you want to be able to change the device name while the node is running, the default way would be services. You would create a service server in your node that accepts requests to change the device name. However, doing this for each small setting in your node can be a hassle. With parameters, not only can you provide a different device name at runtime, but you can also modify it later by using the parameter services that each ROS 2 node already has. There’s no need to make it more complicated <span>than that.</span></p>
			<p class="calibre3">Now, let’s see how to solve the issue we had when setting a new value for the <strong class="source-inline1">number</strong> parameter, and let’s start <span>with Python.</span></p>
			<p class="calibre3">There <a id="_idIndexMarker562" class="pcalibre calibre4 pcalibre1"/>are actually several parameter <a id="_idIndexMarker563" class="pcalibre calibre4 pcalibre1"/>callbacks you could implement, but to keep things simple, I will just use one of them. Parameter callbacks are a nice and useful functionality, but it’s not necessarily the most important when you begin with ROS 2. Thus, here you will get an overview of the functionality, and feel free to do more research on your own after finishing<a id="_idTextAnchor431" class="pcalibre calibre4 pcalibre1"/> the book (you will find additional resources in <a href="B22403_14.xhtml#_idTextAnchor665" class="pcalibre calibre4 pcalibre1"><span><em class="italic">Chapter 14</em></span></a><span>).</span></p>
			<h2 id="_idParaDest-207" class="calibre6"><a id="_idTextAnchor432" class="pcalibre calibre4 pcalibre1"/>Python parameter callback</h2>
			<p class="calibre3">Let’s <a id="_idIndexMarker564" class="pcalibre calibre4 pcalibre1"/>write our first Python <span>parameter callback.</span></p>
			<p class="calibre3">Open the <strong class="source-inline1">number_publisher.py</strong> file and register a parameter callback in the <span>node’s constructor:</span></p>
			<pre class="source-code">
self.add_post_set_parameters_callback(self.parameters_callback)</pre>			<p class="calibre3">We also add a new <span>import line:</span></p>
			<pre class="source-code">
from rclpy.parameter import Parameter</pre>			<p class="calibre3">Then, we implement the <span>callback method:</span></p>
			<pre class="source-code">
def parameters_callback(self, params: list[Parameter]):
    for param in params:
        if param.name == "number":
            self.number_ = param.value</pre>			<p class="calibre3">In this callback, you receive a list of <strong class="source-inline1">Parameter</strong> objects. For each parameter, you can access its name, value, and type. With a <strong class="source-inline1">for</strong> loop, we go through each parameter we get and set the corresponding values in the code. You could also decide to validate the values (for example, only accept positive numbers), but I will not do that here to keep the <span>code minimal.</span></p>
			<p class="calibre3">To make a quick test, run the <strong class="source-inline1">number_publisher</strong> node again (no specified params; default values will be used). In another terminal, subscribe to the <strong class="source-inline1">/</strong><span><strong class="source-inline1">number</strong></span><span> topic:</span></p>
			<pre class="console">
$ ros2 topic echo /number
data: 2
---</pre>			<p class="calibre3">Now, change the <span>parameter’s value:</span></p>
			<pre class="console">
$ ros2 param set /number_publisher number 3
Set parameter successful</pre>			<p class="calibre3">Let’s now <a id="_idIndexMarker565" class="pcalibre calibre4 pcalibre1"/>go back to the other terminal to observe <span>the change:</span></p>
			<pre class="console">
$ ros2 topic echo /number
data: 3
---</pre>			<p class="calibre3">The parameter’s value has been changed, and we have rec<a id="_idTextAnchor433" class="pcalibre calibre4 pcalibre1"/>eived this value in the code, thanks to the <span>parameter callback.</span></p>
			<h2 id="_idParaDest-208" class="calibre6"><a id="_idTextAnchor434" class="pcalibre calibre4 pcalibre1"/>C++ parameter callback</h2>
			<p class="calibre3">The behavior for parameter callbacks in C++ is exactly the same as for Python. Let’s have a look <a id="_idIndexMarker566" class="pcalibre calibre4 pcalibre1"/>at the syntax. Open the <strong class="source-inline1">number_publisher.cpp</strong> file and register the parameter callback in <span>the constructor:</span></p>
			<pre class="source-code">
param_callback_handle_ = this-&gt;add_post_set_parameters_callback(
    std::bind(&amp;NumberPublisherNode::parametersCallback, this, _1));</pre>			<p class="calibre3">Here is the implementation for <span>the callback:</span></p>
			<pre class="source-code">
void parametersCallback(
    const std::vector&lt;rclcpp::Parameter&gt; &amp; parameters)
{
    for (const auto &amp;param: parameters) {
        if (param.get_name() == "number") {
            number_ = param.as_int();
        }
    }
}</pre>			<p class="calibre3">We get a list of <strong class="source-inline1">rclcpp::Parameter</strong> objects. From this, we can check each parameter’s name with the <strong class="source-inline1">get_name()</strong> method. If the parameter’s name matches, we get the value. Since we <a id="_idIndexMarker567" class="pcalibre calibre4 pcalibre1"/>are receiving an integer here, we use the <strong class="source-inline1">as_int()</strong> method. For a string, you would use the <strong class="source-inline1">as_string()</strong> method, and so on. Please refer to the GitHub files for the <span>complete code.</span></p>
			<p class="calibre3">You have now seen the basics of parameter callbacks. You will not necessarily add them to all your nodes. They are great if you need to be able to modify a parameter’s value after the node has <span>been started.</span></p>
			<p class="calibre3">Let’s end this chapter with a<a id="_idTextAnchor435" class="pcalibre calibre4 pcalibre1"/>n additional challenge to make you practice more <span>with parameters.</span></p>
			<h1 id="_idParaDest-209" class="calibre6"><a id="_idTextAnchor436" class="pcalibre calibre4 pcalibre1"/>Parameter challenge</h1>
			<p class="calibre3">With this challenge, you will practice everything you’ve seen in this chapter: declaring and getting parameters in your code, providing parameters’ values at runtime, and saving the values inside a YAML file. We will just skip parameter callbacks, but feel free to add them if you want to practice <span>those too.</span></p>
			<p class="calibre3">As usual for challenges, I will first explain what the challenge is and then provide the Python solution. You can find the compl<a id="_idTextAnchor437" class="pcalibre calibre4 pcalibre1"/>ete code for both Python and C++ in the book’s <span>GitHub repository.</span></p>
			<h2 id="_idParaDest-210" class="calibre6"><a id="_idTextAnchor438" class="pcalibre calibre4 pcalibre1"/>Challenge</h2>
			<p class="calibre3">We will <a id="_idIndexMarker568" class="pcalibre calibre4 pcalibre1"/>continue to improve the <strong class="source-inline1">turtle_controller</strong> node. For this challenge, we want to be able to choose different settings <span>at runtime:</span></p>
			<ul class="calibre9">
				<li class="calibre10">Pen color on the <span>right side</span></li>
				<li class="calibre10">Pen color on the <span>left side</span></li>
				<li class="calibre10">Velocity to publish on the <span><strong class="source-inline">cmd_vel</strong></span><span> topic</span></li>
			</ul>
			<p class="calibre3">To do that, you will add <span>these parameters:</span></p>
			<ul class="calibre9">
				<li class="calibre10"><strong class="source-inline">color_1</strong>: Instead of just arbitrarily choosing a color for when the turtle is on the right side, we rename the color as <strong class="source-inline">color_1</strong>, and we get the value from a parameter. This parameter will be an integer list containing three values (<strong class="source-inline">red</strong>, <span><strong class="source-inline">green</strong></span><span>, </span><span><strong class="source-inline">blue</strong></span><span>).</span></li>
				<li class="calibre10"><strong class="source-inline">color_2</strong>: Same as for <strong class="source-inline">color_1</strong>, this one is the color used when the turtle is on the left side of <span>the screen.</span></li>
				<li class="calibre10"><strong class="source-inline">turtle_velocity</strong>: By default, we used <strong class="source-inline">1.0</strong> and <strong class="source-inline">2.0</strong> for velocities sent on the <strong class="source-inline">cmd_vel</strong> topic. We make this a parameter so that we can provide the velocity at runtime. Instead of <strong class="source-inline">1.0</strong> and <strong class="source-inline">2.0</strong>, we will use <strong class="source-inline">turtle_velocity</strong> and <strong class="source-inline">turtle_velocity * </strong><span><strong class="source-inline">2.0</strong></span><span>.</span></li>
			</ul>
			<p class="calibre3">To test this node, you will start the <strong class="source-inline1">turtle_controller</strong> node with <strong class="source-inline1">ros2 run</strong> and provide different <a id="_idIndexMarker569" class="pcalibre calibre4 pcalibre1"/>values for the parameters. You should see if it works by watching how fast the turtle is moving and what the colors are for the pen. If needed, add some logs in the code to see <span>what’s happening.</span></p>
			<p class="calibre3">As a last step for this challenge, you can put all th<a id="_idTextAnchor439" class="pcalibre calibre4 pcalibre1"/>e parameters inside a YAML file and load this YAML file <span>at runtime.</span></p>
			<h2 id="_idParaDest-211" class="calibre6"><a id="_idTextAnchor440" class="pcalibre calibre4 pcalibre1"/>Solution</h2>
			<p class="calibre3">Let’s start <a id="_idIndexMarker570" class="pcalibre calibre4 pcalibre1"/>by declaring the parameters that we will need for <span>this challenge.</span></p>
			<p class="calibre3">Open the <strong class="source-inline1">turtle_controller.py</strong> file. Let’s declare a few parameters at the beginning of the <span>node’s constructor:</span></p>
			<pre class="source-code">
self.declare_parameter("color_1", [255, 0, 0])
self.declare_parameter("color_2", [0, 255, 0])
self.declare_parameter("turtle_velocity", 1.0)</pre>			<p class="calibre3">We provide default values that correspond to the same values we previously hardcoded. Thus, if we start the node without providing any parameters, the behavior will be the same <span>as before.</span></p>
			<p class="calibre3">After declaring the parameters, we can get <span>their values:</span></p>
			<pre class="source-code">
self.color_1_ = self.get_parameter("color_1").value
self.color_2_ = self.get_parameter("color_2").value
self.turtle_velocity_ = self.get_parameter("turtle_velocity").value</pre>			<p class="calibre3">We store the <a id="_idIndexMarker571" class="pcalibre calibre4 pcalibre1"/>values inside class attributes so that we can reuse them later in <span>the code.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">As a reminder, in Python, don’t forget to add <strong class="source-inline">.value</strong> (without any parentheses) after <strong class="source-inline">get_parameter()</strong>. This is a common error that will lead to an exception when you start <span>the node.</span></p>
			<p class="calibre3">Then, we modify a few lines in the <span><strong class="source-inline1">callback_pose()</strong></span><span> method:</span></p>
			<pre class="source-code">
if pose.x &lt; 5.5:
    cmd.linear.x = self.turtle_velocity_
    cmd.angular.z = self.turtle_velocity_
else:
    cmd.linear.x = self.turtle_velocity_ * 2.0
    cmd.angular.z = self.turtle_velocity_ * 2.0
self.cmd_vel_pub_.publish(cmd)</pre>			<p class="calibre3">Instead of hardcoding the velocity value, we use the one we got from <span>the parameter.</span></p>
			<p class="calibre3">Then, we set the <span>pen color:</span></p>
			<pre class="source-code">
if pose.x &gt; 5.5 and self.previous_x_ &lt;= 5.5:
    self.previous_x_ = pose.x
    self.get_logger().info("Set color 1.")
    self.call_set_pen(
        self.color_1_[0],
        self.color_1_[1],
        self.color_1_[2]
    )
elif pose.x &lt;= 5.5 and self.previous_x_ &gt; 5.5:
    self.previous_x_ = pose.x
    self.get_logger().info("Set color 2.")
    self.call_set_pen(
        self.color_2_[0],
        self.color_2_[1],
        self.color_2_[2]
    )</pre>			<p class="calibre3">Here, we modify the logs so that they make more sense, as the color could <span>be anything.</span></p>
			<p class="calibre3">Finally, there are <a id="_idIndexMarker572" class="pcalibre calibre4 pcalibre1"/>different ways you could pass the integer array to the <strong class="source-inline1">call_set_pen()</strong> method. You could modify <strong class="source-inline1">call_set_pen()</strong> so that it receives an array of <a id="_idIndexMarker573" class="pcalibre calibre4 pcalibre1"/>three integers and extracts each number from it. Or, like I did here, you don’t modify the method and you just make sure to pass the <span>correct arguments.</span></p>
			<p class="calibre3">The code is now finished. To test it, start the <strong class="source-inline1">turtlesim</strong> node in one terminal and the <strong class="source-inline1">turtle_controller</strong> node in another one. You can provide different values for the parameters. For example, if we want the velocity to be <strong class="source-inline1">1.5</strong> and the colors to be black and white, we run <span>the following:</span></p>
			<pre class="console">
$ ros2 run turtle_controller turtle_controller --ros-args -p color_1:=[0,0,0] -p color_2:=[255,255,255] -p turtle_velocity:=1.5</pre>			<p class="calibre3">You can also save those parameters inside a YAML file. Create a new YAML file (for example, in your home directory) named <strong class="source-inline1">turtle_params.yaml</strong>. In this file, <span>write this:</span></p>
			<pre class="source-code">
/turtle_controller:
  ros__parameters:
    color_1: [0, 0, 0]
    color_2: [255, 255, 255]
    turtle_velocity: 1.5</pre>			<p class="calibre3">Then, you can <a id="_idIndexMarker574" class="pcalibre calibre4 pcalibre1"/>start the turtle controller node with the YAML <span>file directly:</span></p>
			<pre class="console">
$ ros2 run turtle_controller turtle_controller --ros-args --params-file ~/turtle_params.yaml</pre>			<p class="calibre3">That’s it for this challenge. In the end, for each parameter, we did three things: we declared it, got its value, and used it in the code. This is not too complicated, and if you just know how to do that, you will be a<a id="_idTextAnchor441" class="pcalibre calibre4 pcalibre1"/>ble to successfully handle parameters in your future ROS <span>2 applications.</span></p>
			<h1 id="_idParaDest-212" class="calibre6"><a id="_idTextAnchor442" class="pcalibre calibre4 pcalibre1"/>Summary</h1>
			<p class="calibre3">In this chapter, you worked on parameters. Parameters allow you to provide settings for your nodes at runtime. Thus, with the same code, you could start several different nodes with different configurations. This increases the code reusability <span>a lot.</span></p>
			<p class="calibre3">To handle parameters in your nodes, follow <span>these guidelines:</span></p>
			<ol class="calibre11">
				<li class="calibre10">Declare the parameter so that it exists within the node. The best practice is to set a default value. This value will also set the type for <span>the parameter.</span></li>
				<li class="calibre10">Get the parameter’s value and store it in your node—for example, in a <span>private attribute.</span></li>
				<li class="calibre10">Use this value in <span>your code.</span></li>
			</ol>
			<p class="calibre3">Then, when you start a node with <strong class="source-inline1">ros2 run</strong>, you can specify any parameter’s value <span>you want.</span></p>
			<p class="calibre3">You can also organize your parameters inside a YAML file, which makes it much more convenient when you start to have more than a handful of parameters. You will load the YAML file when you start <span>a node.</span></p>
			<p class="calibre3">Finally, you can also decide to allow parameters to be modified even after you’ve started a node. To do that, you will need to implement <span>parameter callbacks.</span></p>
			<p class="calibre3">Parameters make your nodes much more dynamic. In almost every node you run, you will have parameters. Using them makes it easier to scale your application by allowing different sets of configurations to <span>be loaded.</span></p>
			<p class="calibre3">Speaking of scaling, in the following chapter, we will dive into launch files. With launch files, you can start multiple nodes and parameters at once. This will be of great help when your application starts <span>to grow.</span></p>
		</div>
	</body></html>