- en: '*Chapter 7*: Implementing Concurrency'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：实现并发'
- en: So far, we have explored how to measure and improve the performance of programs
    by reducing the number of operations performed by the **central processing unit**
    (**CPU**) through clever algorithms and more efficient machine code. In this chapter,
    we will shift our focus to programs where most of the time is spent waiting for
    resources that are much slower than the CPU, such as persistent storage and network
    resources.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了如何通过巧妙的算法和更高效的机器代码来减少**中央处理单元**（**CPU**）执行的操作数量，从而提高程序的性能。在本章中，我们将把重点转向那些大部分时间都花在等待比CPU慢得多的资源（如持久存储和网络资源）的程序。
- en: '**Asynchronous programming** is a programming paradigm that helps to deal with
    slow and unpredictable resources (such as users) and is widely used to build responsive
    services and **user interfaces** (**UIs**). In this chapter, we will show you
    how to program asynchronously in Python using techniques such as coroutines and
    reactive programming. As we will see, the successful application of these techniques
    will allow us to speed up our programs without the use of specialized data structures
    or algorithms.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步编程**是一种编程范式，有助于处理慢速和不可预测的资源（如用户），并且广泛用于构建响应式服务和**用户界面**（**UIs**）。在本章中，我们将向您展示如何使用协程和响应式编程等技术以异步方式在Python中进行编程。我们将看到，这些技术的成功应用将使我们能够加快程序的速度，而无需使用特殊的数据结构或算法。'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Asynchronous programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程
- en: The `asyncio` framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asyncio`框架'
- en: Reactive programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter07).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter07)找到。
- en: Asynchronous programming
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程
- en: Asynchronous programming is a way of dealing with slow and unpredictable resources.
    Rather than waiting idly for resources to become available, asynchronous programs
    can handle multiple resources concurrently and efficiently. Programming in an
    asynchronous way can be challenging because it is necessary to deal with external
    requests that can arrive in any order, may take a variable amount of time, or
    may fail unpredictably. In this section, we will introduce the topic by explaining
    the main concepts and terminology as well as by giving an idea of how asynchronous
    programs work.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程是一种处理慢速和不可预测资源的方法。与其无所事事地等待资源可用，异步程序可以同时高效地处理多个资源。以异步方式编程可能具有挑战性，因为必须处理可能以任何顺序到达、可能花费可变的时间或可能不可预测地失败的外部请求。在本节中，我们将通过解释主要概念和术语以及异步程序的工作方式来介绍这个主题。
- en: Waiting for input/output
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待输入/输出
- en: A modern computer employs different kinds of memory to store data and perform
    operations. In general, a computer possesses a combination of expensive memory
    that is capable of operating efficiently and cheaply and more abundant memory
    that is slower and is used to store a larger amount of data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算机使用不同类型的内存来存储数据和执行操作。一般来说，计算机拥有一种组合，即能够高效且便宜地操作的昂贵内存，以及更丰富的、较慢的内存，用于存储更多的数据。
- en: 'The memory hierarchy is shown in the following diagram:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 内存层次结构如下所示：
- en: '![Figure 7.1 – Illustration of the memory hierarchy ](img/Figure_7.1_B17499.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 内存层次结构的说明](img/Figure_7.1_B17499.jpg)'
- en: Figure 7.1 – Illustration of the memory hierarchy
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 内存层次结构的说明
- en: At the top of the memory hierarchy, are the CPU **registers**. Those are integrated
    with the CPU and are used to store and execute machine instructions. Accessing
    data in a register generally takes one clock cycle. This means that if the CPU
    operates at 3 **gigahertz** (**GHz**), the time it takes to access one element
    in a CPU register is in the order of 0.3 nanoseconds.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存层次结构的顶部是CPU **寄存器**。这些与CPU集成，用于存储和执行机器指令。在寄存器中访问数据通常需要一钟周期。这意味着如果CPU以3 **千兆赫兹**（**GHz**）的速度运行，那么访问CPU寄存器中的一个元素所需的时间大约是0.3纳秒。
- en: At the layer just below the registers, you can find the CPU **cache**, which
    comprise multiple levels and is integrated with the processor. The cache operates
    at a slightly slower speed than the registers but within the same **order of magnitude**
    (**OOM**).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在寄存器层下面，你可以找到CPU的**缓存**，它由多个级别组成，并与处理器集成。缓存的操作速度略慢于寄存器，但处于同一**数量级**（**OOM**）。
- en: The next item in the hierarchy is the main memory (**random-access memory**,
    or **RAM**), which holds much more data but is slower than the cache. Fetching
    an item from memory can take a few hundred clock cycles.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 层次结构中的下一个项目是主存储器（**随机存取存储器**，或**RAM**），它存储的数据更多，但比缓存慢。从内存中检索一个项目可能需要几百个时钟周期。
- en: At the bottom layer, you can find persistent **storage**, such as rotating disks
    (**hard disk drives** (**HDDs**)) and **solid-state drives** (**SSDs**). These
    devices hold the most data and are OOMs slower than the main memory. An HDD may
    take a few milliseconds to seek and retrieve an item, while an SSD is substantially
    faster and takes only a fraction of a millisecond.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在最底层，你可以找到持久**存储**，例如旋转磁盘（**硬盘驱动器**（**HDDs**））和**固态驱动器**（**SSDs**）。这些设备存储的数据最多，比主存储器慢几个数量级。一个HDD可能需要几毫秒来定位和检索一个项目，而一个SSD则快得多，只需几分之一毫秒。
- en: To put the relative speed of each memory type into perspective, if you were
    to have the CPU with a clock speed of about 1 second, a register access would
    be equivalent to picking up a pen from a table. A cache access would be equivalent
    to picking up a book from a shelf. Moving higher up the hierarchy, a RAM access
    would be equivalent to loading up the laundry (about 20 times slower than the
    cache). When we move to persistent storage, things are quite different. Retrieving
    an element from an SSD will be equivalent to going on a 4-day road trip while
    retrieving an element from an HDD can take up to 6 months! The duration can stretch
    even further if we move on to access resources over the network.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将每种内存类型的相对速度置于适当的视角，如果你有一个大约1秒的CPU时钟速度，寄存器访问将相当于从桌子上拿起一支笔。缓存访问将相当于从书架上拿起一本书。向更高层次移动，RAM访问将相当于洗衣服（比缓存慢20倍）。当我们转向持久存储时，情况就完全不同了。从SSD检索一个元素将相当于进行一次4天的公路旅行，而从HDD检索一个元素可能需要长达6个月！如果我们将访问网络资源，持续时间可能会进一步延长。
- en: Overall, accessing data from storage and other **input/output** (**I/O**) devices
    is much slower compared to the CPU; therefore, it is very important to handle
    those resources so that the CPU is never stuck waiting aimlessly. This can be
    accomplished by carefully designed software capable of managing multiple ongoing
    requests at the same time. This is the idea of concurrency or concurrent programming.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，与CPU相比，从存储和其他**输入/输出**（**I/O**）设备访问数据要慢得多；因此，非常重要的是要妥善处理这些资源，以确保CPU不会无目的地等待。这可以通过精心设计的软件来实现，该软件能够同时管理多个正在进行中的请求。这就是并发或并发编程的概念。
- en: Concurrency
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发
- en: '**Concurrency** is a way to implement a system that can deal with multiple
    requests at the same time. The idea is that we can move on and start handling
    other resources while we wait for a resource to become available. Concurrency
    works by splitting a task into smaller subtasks that can be executed out of order
    so that multiple tasks can be partially advanced without waiting for the previous
    tasks to finish.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发**是实现能够同时处理多个请求的系统的途径。其理念是，我们可以在等待资源可用时继续处理其他资源。并发通过将任务分割成可以无序执行的小子任务来实现，这样多个任务可以部分推进，而无需等待前一个任务完成。'
- en: 'As a first example, we will describe how to implement concurrent access to
    a slow network resource; the code for this example is included in `Chapter07/example1.py`.
    Let''s say we have a web service that takes the square of a number, and the time
    between our request and the response will be approximately 1 second. We can implement
    the `network_request` function that takes a number and returns a dictionary that
    contains information about the success of the operation and the result. We can
    simulate such services using the `time.sleep` function, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个例子，我们将描述如何实现对慢速网络资源的并发访问；本例的代码包含在`第07章/example1.py`中。假设我们有一个网络服务，它接受一个数字的平方，并且从我们的请求到响应的时间大约为1秒。我们可以实现一个`network_request`函数，它接受一个数字并返回一个包含操作成功信息和结果的字典。我们可以使用`time.sleep`函数来模拟此类服务，如下所示：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will also write some additional code that performs the request, verifies
    that the request was successful, and prints the result. In the following code
    snippet, we define the `fetch_square` function and use it to calculate the square
    of the number 2 using a call to `network_request`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将编写一些额外的代码来执行请求，验证请求是否成功，并打印结果。在以下代码片段中，我们定义了`fetch_square`函数，并使用它通过调用`network_request`来计算数字2的平方：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Fetching a number from the network will take 1 second because of the slow network.
    What if we want to calculate the square of multiple numbers? We can call `fetch_square`,
    which will start a network request as soon as the previous one is done. Its use
    is illustrated in the following code snippet:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网络速度慢，从网络获取一个数字将花费1秒钟。如果我们想计算多个数字的平方呢？我们可以调用`fetch_square`，它将在前一个请求完成后立即启动网络请求。其用法在以下代码片段中说明：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code as-is will take roughly 3 seconds to run, but it's not the best we
    can do. Notice that the calculation of the square of 2 is independent of that
    of the square of 3, and both are in turn independent of calculating the square
    of 4\. As such, waiting for a previous result to finish before moving on to the
    next number is unnecessary, if we can technically submit multiple requests and
    wait for them at the same time.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码按原样运行大约需要3秒钟，但这并不是我们能做的最好的。请注意，2的平方的计算与3的平方的计算是独立的，同样，这两个计算又都是独立的，与计算4的平方无关。因此，如果我们能够在技术上同时提交多个请求并等待它们，那么在继续下一个数字之前等待前一个结果完成是不必要的。
- en: 'In the following diagram, the three tasks are represented as boxes. The time
    spent by the CPU processing and submitting the request is in orange, while the
    waiting times are in blue. You can see how most of the time is spent waiting for
    the resources while our machine sits idle without doing anything else:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，三个任务被表示为方框。CPU处理和提交请求的时间用橙色表示，而等待时间用蓝色表示。您可以看到，大部分时间都花在等待资源上，而我们的机器闲置，什么也不做：
- en: '![Figure 7.2 – Illustration of the execution time of independent calculations
    ](img/Figure_7.2_B17499.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 独立计算执行时间的说明](img/Figure_7.2_B17499.jpg)'
- en: Figure 7.2 – Illustration of the execution time of independent calculations
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 独立计算执行时间的说明
- en: 'Ideally, we would like to start another new task while we are waiting for the
    already submitted tasks to finish. In the following screenshot, you can see that
    as soon as we submit our request in `fetch_square(2)`, we can start preparing
    for `fetch_square(3)`, and so on. This allows us to reduce the CPU waiting time
    and to start processing the results as soon as they become available:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望在等待已提交的任务完成的同时开始另一个新的任务。在下面的屏幕截图中，您可以看到，当我们提交`fetch_square(2)`请求后，我们可以立即开始准备`fetch_square(3)`，依此类推。这使我们能够减少CPU的等待时间，并在结果可用时立即开始处理：
- en: '![Figure 7.3 – A more efficient way of performing independent calculations
    ](img/Figure_7.3_B17499.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 执行独立计算的一种更有效的方法](img/Figure_7.3_B17499.jpg)'
- en: Figure 7.3 – A more efficient way of performing independent calculations
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 执行独立计算的一种更有效的方法
- en: Again, this strategy is made possible by the fact that the three requests are
    completely independent, and we don't need to wait for the completion of a previous
    task to start the next one. Also, note how a single CPU can comfortably handle
    this scenario. While distributing the work on multiple CPUs can further speed
    up the execution, if the waiting time is large compared to the processing times,
    the speedup will be minimal.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这种策略得以实现是因为这三个请求是完全独立的，我们不需要等待前一个任务的完成就开始下一个任务。此外，请注意单个CPU如何轻松地处理这种场景。虽然将工作分配到多个CPU可以进一步提高执行速度，但如果等待时间与处理时间相比很大，那么速度提升将是微不足道的。
- en: 'To implement concurrency, it is necessary to think about our programs and their
    design differently; in the following sections, we''ll demonstrate techniques and
    best practices to implement robust concurrent applications, starting with a new
    concept: callbacks.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现并发，有必要以不同的方式思考我们的程序及其设计；在接下来的章节中，我们将展示技术和最佳实践来实施健壮的并发应用程序，从一个新的概念开始：回调。
- en: Callbacks
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调
- en: The code we have seen so far blocks the execution of the program until the resource
    is available. The call responsible for the waiting is `time.sleep`. To make the
    code start working on other tasks, we need to find a way to avoid blocking the
    program flow so that the rest of the program can move on to these other tasks.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止看到的代码会阻塞程序执行，直到资源可用。负责等待的调用是`time.sleep`。为了使代码开始处理其他任务，我们需要找到一种方法来避免阻塞程序流程，这样程序的其他部分就可以继续执行这些其他任务。
- en: One of the simplest ways to accomplish this behavior is through callbacks. The
    strategy is quite similar to what we do when we request a cab. Imagine that you
    are at a restaurant and you've had a few drinks. It's raining outside, and you'd
    rather not take the bus; therefore, you request a taxi and ask them to call when
    they're outside so that you can come out and you don't have to wait in the rain.
    What you did, in this case, is request a taxi (that is, the slow resource), but
    instead of waiting outside until the taxi arrives, you provide your number and
    instructions (callback) so that you can come outside when they're ready and go
    home.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种行为的最简单方法之一是通过回调。策略与我们请求出租车时所做的非常相似。想象一下，你在一个餐厅里，已经喝了几杯酒。外面在下雨，你宁愿不去坐公交车；因此，你要求出租车，并让他们在你外面时打电话给你，这样你就可以出来，不必在雨中等待。在这种情况下，你所做的是要求出租车（即慢速资源），但你不是在外面等到出租车到来，而是提供你的号码和指示（回调），这样他们准备好时你可以出来，然后回家。
- en: We will now show how this mechanism can work in code. We will compare the blocking
    code of `time.sleep` with the equivalent non-blocking code of `threading.Timer`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将展示这个机制如何在代码中工作。我们将比较`time.sleep`的阻塞代码与`threading.Timer`的等效非阻塞代码。
- en: 'For this example, which is implemented in `example2.py`, we will write a function,
    `wait_and_print`, that will block the program execution for 1 second and then
    print a message, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，它在`example2.py`中实现，我们将编写一个名为`wait_and_print`的函数，该函数将阻塞程序执行1秒钟，然后打印一条消息，如下所示：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we want to write the same function in a non-blocking way, we can use the
    `threading.Timer` class. We can initialize a `threading.Timer` instance by passing
    the amount of time we want to wait and a `Timer.start` method to activate the
    timer:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想以非阻塞的方式编写相同的函数，我们可以使用`threading.Timer`类。我们可以通过传递我们想要等待的时间量和`Timer.start`方法来初始化一个`threading.Timer`实例来激活定时器：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: An important feature of the `wait_and_print_async` function is that none of
    the statements is blocking the execution flow of the program.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait_and_print_async`函数的一个重要特性是，没有任何语句会阻塞程序的执行流程。'
- en: How Is threading.Timer Capable of Waiting without Blocking?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`threading.Timer`如何能够在不阻塞的情况下等待？'
- en: The strategy used by `threading.Timer` involves starting a new thread that can
    execute code in parallel. If this is confusing, don't worry, as we will explore
    threading and parallel programming in detail in the following chapters.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`threading.Timer`使用的策略涉及启动一个新的线程，该线程可以并行执行代码。如果这让你感到困惑，不要担心，因为我们在接下来的章节中将详细探讨线程和并行编程。'
- en: This technique of registering callbacks for execution in response to certain
    events is commonly called the *Hollywood principle*. This is because, after auditioning
    for a movie or TV role at Hollywood, you may be told *Don't call us, we'll call
    you*, meaning that they won't tell you if they chose you for the role immediately,
    but they'll call you if they do.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在特定事件发生时注册回调以执行的技术通常被称为*好莱坞原则*。这是因为，在好莱坞试镜电影或电视角色后，你可能会被告知*别给我们打电话，我们会给你打电话*，这意味着他们不会立即告诉你是否选择了你，但如果他们选择了你，他们会给你打电话。
- en: 'To highlight the difference between the blocking and non-blocking versions
    of `wait_and_print`, we can test and compare the execution of the two versions.
    In the output comments, the waiting periods are indicated by `<wait...>`, as illustrated
    in the following code snippet:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了突出显示`wait_and_print`的阻塞和非阻塞版本之间的差异，我们可以测试和比较两个版本的执行。在输出注释中，等待期用`<wait...>`表示，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The synchronous version behaves in a very familiar, expected way. The code waits
    for a second, prints `First call`, waits for another second, and then prints `Second
    call` and `After call` messages.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 同步版本的行为非常熟悉，符合预期。代码等待一秒钟，打印`First call`，然后等待另一秒钟，并打印`Second call`和`After call`消息。
- en: In the asynchronous version, `wait_and_print_async` *submits* (rather than *executes*)
    those calls and moves on *immediately*. You can see this mechanism in action by
    noticing that the `"After submission"` message is printed immediately.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步版本中，`wait_and_print_async` *提交*（而不是*执行*）这些调用，并立即继续。你可以通过注意到“提交后”消息立即打印出来，来看到这个机制在起作用。
- en: 'With this in mind, we can explore a slightly more complex situation by rewriting
    our `network_request` function using callbacks. In `example3.py`, we define a
    `network_request_async` function, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个前提下，我们可以通过重新编写我们的`network_request`函数使用回调来探索一个稍微复杂的情况。在`example3.py`中，我们定义了一个`network_request_async`函数，如下所示：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The biggest difference between `network_request_async` and its blocking counterpart
    is that `network_request_async` *doesn't return anything*. This is because we
    are merely submitting the request when `network_request_async` is called, but
    the value is available only when the request is completed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`network_request_async`与其阻塞版本之间最大的区别是`network_request_async` *不返回任何内容*。这是因为我们在调用`network_request_async`时只是提交了请求，但值只有在请求完成时才可用。'
- en: If we can't return anything, how do we pass the result of the request? Rather
    than returning the value, we will pass the result as an argument to the `on_done`
    callback. The rest of the function consists of submitting a callback (called `timer_done`)
    to the `threading.Timer` class that will call `on_done` when it's ready.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不能返回任何内容，我们如何传递请求的结果？我们不会返回值，而是将结果作为参数传递给`on_done`回调。函数的其余部分包括提交一个回调（称为`timer_done`）到`threading.Timer`类，当它准备好时将调用`on_done`。
- en: 'The usage of `network_request_async` is quite similar to `threading.Timer`;
    all we have to do is pass the number we want to square and a callback that will
    receive the result *when it''s ready*. This is demonstrated in the following code
    snippet:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`network_request_async`的使用与`threading.Timer`非常相似；我们只需要传递我们想要平方的数字和一个当它准备好时将接收结果的回调。这在下面的代码片段中得到了演示：'
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, if we submit multiple network requests, we note that the calls get executed
    concurrently and do not block the code, as illustrated in the following code snippet:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们提交多个网络请求，我们会注意到调用是并发执行的，并且不会阻塞代码，如下面的代码片段所示：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In order to use `network_request_async` in `fetch_square`, we need to adapt
    the code to take advantage of asynchronous constructs. In the following code snippet,
    we modify `fetch_square` by defining and passing the `on_done` callback to `network_request_async`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在`fetch_square`中使用`network_request_async`，我们需要修改代码以利用异步构造。在下面的代码片段中，我们通过定义和传递`on_done`回调到`network_request_async`来修改`fetch_square`：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You may have noted that the asynchronous code is significantly more convoluted
    than its synchronous counterpart. This is due to the fact that we are required
    to write and pass a callback every time we need to retrieve a certain result,
    causing the code to become nested and hard to follow.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，异步代码比其同步版本要复杂得多。这是因为每次我们需要检索某个结果时，我们必须编写和传递一个回调，导致代码变得嵌套且难以理解。
- en: Fortunately, a concept that is essential to concurrent programming that we are
    examining next, futures, will help simplify matters.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们接下来要检查的并发编程中的一个基本概念，即期货，将有助于简化问题。
- en: Futures
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 期货
- en: Futures are a more convenient pattern that can be used to keep track of the
    results of asynchronous calls. In the preceding code snippet, we saw that rather
    than returning values, we accept callbacks and pass the results when they are
    ready. It is interesting to note that, so far, there is no easy way to track the
    status of the resource.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 期货是一个更方便的模式，可以用来跟踪异步调用的结果。在先前的代码片段中，我们看到我们不是返回值，而是接受回调，并在它们准备好时传递结果。值得注意的是，到目前为止，还没有简单的方法来跟踪资源的状态。
- en: 'A `concurrent.futures.Future` class. A `Future` instance can be created by
    calling its constructor with no arguments, as in the following IPython snippet:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`concurrent.futures.Future`类。可以通过不带参数调用其构造函数来创建`Future`实例，如下面的IPython代码片段所示：'
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A future represents a value that is not yet available. You can see that its
    string representation reports the current status of the result, which, in our
    case, is still pending. In order to make a result available, we can use the `fut.set_result`
    method, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 期货代表一个尚未可用的价值。你可以看到它的字符串表示报告了结果当前的状态，在我们的例子中，它仍然是待定的。为了使结果可用，我们可以使用`fut.set_result`方法，如下所示：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can see that once we set the result, the `Future` instance will report
    that the task is finished and can be accessed using the `fut.result` method. It
    is also possible to subscribe a callback to a future so that, as soon as the result
    is available, the callback is executed. To attach a callback, it is sufficient
    to pass a function to the `fut.add_done_callback` method. When the task is completed,
    the function will be called with the `Future` instance as its first argument and
    the result can be retrieved using the `future.result()` method, as illustrated
    in the following code snippet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，一旦我们设置了结果，`Future`实例将报告任务已完成，并且可以使用`fut.result`方法访问。也可以订阅一个回调到future上，以便结果一可用，回调就会被执行。为了附加一个回调，只需将一个函数传递给`fut.add_done_callback`方法。当任务完成时，该函数将以`Future`实例作为其第一个参数被调用，并且可以使用`future.result()`方法检索结果，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To understand how futures can be used in practice, we will adapt the `network_request_async`
    function to use futures in `example4.py`. The idea is that this time, instead
    of returning nothing, we return a `Future` instance that will keep track of the
    result for us. Note the following two things:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解如何在实践中使用future，我们将修改`network_request_async`函数，在`example4.py`中使用future。这次，我们不是返回空值，而是返回一个将为我们跟踪结果的`Future`实例。请注意以下两点：
- en: We don't need to accept an `on_done callback` as callbacks can be connected
    later using the `fut.add_done_callback` method. Also, we pass the generic `fut.set_result`
    method as the callback for `threading.Timer`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要接受一个`on_done callback`，因为回调可以在之后通过`fut.add_done_callback`方法连接。此外，我们将通用的`fut.set_result`方法作为`threading.Timer`的回调。
- en: 'This time, we are able to return a value, thus making the code a bit more similar
    to the blocking version we saw in the preceding section, as illustrated here:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这次，我们能够返回一个值，从而使代码与前面章节中看到的阻塞版本更加相似，如下所示：
- en: '[PRE13]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Even though we instantiate and manage futures directly in these examples, in
    practical applications, futures are handled by frameworks.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管在这些例子中我们直接实例化和管理future，但在实际应用中，future是由框架处理的。
- en: 'If you execute the preceding code, nothing will happen as the code only consists
    of preparing and returning a `Future` instance. To enable further operation of
    the future results, we need to use the `fut.add_done_callback` method. In the
    following code snippet, we adapt the `fetch_square` function to use futures:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行前面的代码，将不会发生任何事，因为代码只包含准备和返回一个`Future`实例。为了使未来的结果能够进一步操作，我们需要使用`fut.add_done_callback`方法。在下面的代码片段中，我们将`fetch_square`函数修改为使用future：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the code still looks quite similar to the callback version,
    but when `fetch_square` is called, the corresponding future will be processed,
    and the result string will be printed out.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码仍然看起来与回调版本非常相似，但当调用`fetch_square`时，相应的future将被处理，并将打印出结果字符串。
- en: Overall, futures are a different and slightly more convenient way of working
    with callbacks. Futures are also advantageous in the sense that they can keep
    track of the resource status, cancel (unschedule) scheduled tasks, and handle
    exceptions more naturally.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，future是处理回调的一种不同且稍微方便的方法。future还有优势，因为它们可以跟踪资源状态，取消（取消调度）计划中的任务，并更自然地处理异常。
- en: Event loops
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件循环
- en: So far, we have implemented parallelism using **operating system** (**OS**)
    threads. However, in many asynchronous frameworks, the coordination of concurrent
    tasks is managed by an **event loop**.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用**操作系统**（**OS**）线程来实现并行性。然而，在许多异步框架中，并发任务的协调是由**事件循环**管理的。
- en: The idea behind an event loop is to continuously monitor the status of the various
    resources (for example, network connections and database queries) and trigger
    the execution of callbacks when specific events take place (for example, when
    a resource is ready or when a timer expires).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环背后的思想是持续监控各种资源的状态（例如，网络连接和数据库查询），并在特定事件发生时（例如，资源就绪或定时器到期）触发回调的执行。
- en: Why Not Just Stick to Threading?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不就坚持使用线程呢？
- en: Events loops are sometimes preferred as every unit of execution never runs at
    the same time as another, and this can simplify dealing with shared variables,
    data structures, and resources.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环有时更受欢迎，因为每个执行单元永远不会同时运行另一个，这可以简化处理共享变量、数据结构和资源。
- en: 'As the first example in `example5.py`, we will implement a thread-free version
    of `threading.Timer`. We can define a `Timer` class that will take a timeout and
    implement the `Timer.done` method, which returns `True` if the timer has expired.
    The code is illustrated in the following snippet:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`example5.py`中的第一个示例，我们将实现一个无线程版本的`threading.Timer`。我们可以定义一个`Timer`类，它将接受一个超时并实现`Timer.done`方法，该方法在计时器过期时返回`True`。代码在下面的代码片段中展示：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To determine whether the timer has expired, we can write a loop that continuously
    checks the timer status by calling the `Timer.done` method. When the timer expires,
    we can print a message and exit the cycle. The code is illustrated in the following
    snippet:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定计时器是否已过期，我们可以编写一个循环，通过调用`Timer.done`方法连续检查计时器状态。当计时器过期时，我们可以打印一条消息并退出循环。代码在下面的代码片段中展示：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By implementing the timer in this way, the flow of execution is never blocked,
    and we can, in principle, do other work inside the `while` loop.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式实现计时器，执行流程永远不会被阻塞，原则上我们可以在`while`循环内部做其他工作。
- en: Busy-Waiting
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 忙等待
- en: Waiting for events to happen by continuously polling using a loop is commonly
    termed **busy-waiting**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过循环连续轮询等待事件发生通常被称为**忙等待**。
- en: 'Ideally, we would like to attach a custom function that executes when the timer
    goes off, just as we did in `threading.Timer`. To do this, we can implement a
    `Timer.on_timer_done` method that will accept a callback to be executed when the
    timer goes off in `example6.py`, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望附加一个自定义函数，当计时器触发时执行，就像我们在`threading.Timer`中做的那样。为此，我们可以在`example6.py`中实现一个`Timer.on_timer_done`方法，该方法将接受一个回调，当计时器触发时执行，如下所示：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that `on_timer_done` merely stores a reference to the callback. The entity
    that monitors the event and executes the callback is the loop. This concept is
    demonstrated as follows. Rather than using the `print` function, the loop will
    call `timer.callback` when appropriate:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`on_timer_done`仅仅存储了对回调的引用。监控事件并执行回调的是循环。这一概念如下所示。而不是使用`print`函数，当适当的时候，循环将调用`timer.callback`：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, an asynchronous framework is starting to take place. All we
    did outside the loop was define the timer and the callback, while the loop took
    care of monitoring the timer and executing the associated callback. We can further
    extend our code by implementing support for multiple timers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，异步框架正在开始形成。我们在循环外部所做的只是定义计时器和回调，而循环负责监控计时器和执行相关的回调。我们可以通过实现多个计时器的支持来进一步扩展我们的代码。
- en: 'A natural way to implement multiple timers is to add a few `Timer` instances
    to a list and modify our event loop to periodically check all the timers and dispatch
    the callbacks when required. In the following code snippet, we define two timers
    and attach a callback to each of them. Those timers are added to a list, `timers`,
    that is continuously monitored by our event loop. As soon as a timer is done,
    we execute the callback and remove the event from the list:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 实现多个计时器的自然方式是将几个`Timer`实例添加到一个列表中，并修改我们的事件循环以定期检查所有计时器，并在需要时调度回调。在下面的代码片段中，我们定义了两个计时器，并将回调附加到每个计时器上。这些计时器被添加到列表`timers`中，该列表由我们的事件循环持续监控。一旦计时器完成，我们就执行回调并将事件从列表中删除：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The main restriction of an event loop is, since the flow of execution is managed
    by a continuously running loop, that it `time.sleep`) inside the loop, you can
    imagine how the event monitoring and callback dispatching will stop until the
    blocking call is done.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环的主要限制是，由于执行流程由一个持续运行的循环管理，因此在循环内部调用`time.sleep`（），你可以想象事件监控和回调调度将停止，直到阻塞调用完成。
- en: To avoid this, rather than using a blocking call such as `time.sleep`, we let
    the event loop detect and execute the callback when the resource is ready. By
    not blocking the execution flow, the event loop is free to monitor multiple resources
    in a concurrent way.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们不是使用阻塞调用如`time.sleep`，而是让事件循环在资源准备好时检测并执行回调。通过不阻塞执行流程，事件循环可以以并发方式监控多个资源。
- en: How Is the Event Loop Notified of Events?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环如何通知事件？
- en: Events notification is usually implemented through OS calls (such as the `select`
    Unix tool) that will resume the execution of the program whenever an event is
    ready (in contrast to busy-waiting).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 事件通知通常通过操作系统调用（如Unix工具`select`）实现，这些调用将在事件准备好时（与忙等待相反）恢复程序的执行。
- en: The Python standard libraries include a very convenient event loop-based concurrency
    framework, `asyncio`, which will be the topic of the next section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Python 标准库包括一个非常方便的事件循环并发框架 `asyncio`，它将是下一节的主题。
- en: The asyncio framework
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: asyncio 框架
- en: At this point, we have seen how concurrency works and how to use callbacks and
    futures. We can now move on and learn how to use the `asyncio` package, which
    has been present in the standard Python library since version 3.4\. We will also
    explore the `async`/`await` syntax to deal with asynchronous programming in a
    very natural way.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经了解了并发是如何工作的，以及如何使用回调和未来。现在我们可以继续学习如何使用自 Python 3.4 版本以来就存在于标准库中的 `asyncio`
    包。我们还将探索 `async`/`await` 语法，以非常自然的方式处理异步编程。
- en: 'As a first example, we will see how to retrieve and execute a simple callback
    using `asyncio`. The `asyncio` loop can be retrieved by calling the `asyncio.get_event_loop()`
    function. We can schedule a callback for execution using `loop.call_later`, which
    takes a delay in seconds and a callback. We can also use the `loop.stop` method
    to halt the loop and exit the program. To start processing the scheduled call,
    it is necessary to start the loop, which can be done using `loop.run_forever`.
    The following example in `example7.py` demonstrates the usage of these basic methods
    by scheduling a callback that will print a message and halt the loop:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个例子，我们将看到如何使用 `asyncio` 获取和执行一个简单的回调。可以通过调用 `asyncio.get_event_loop()` 函数来获取
    `asyncio` 循环。我们可以使用 `loop.call_later` 来安排一个回调执行，它接受秒数延迟和一个回调。我们还可以使用 `loop.stop`
    方法来停止循环并退出程序。要开始处理安排的调用，必须启动循环，这可以通过 `loop.run_forever` 完成。以下 `example7.py` 代码示例通过安排一个将打印消息并停止循环的回调来演示这些基本方法的用法：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This code schedules a callback that will print out a message and then halt the
    loop. One of the main problems with callbacks is that they require you to break
    the program execution into small functions that will be invoked when a certain
    event takes place. As we saw in the earlier sections, callbacks can quickly become
    cumbersome. In the next section, we will see how to work with coroutines to, as
    with futures, simplify many aspects of concurrent programming.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码安排了一个回调，该回调将打印一条消息然后停止循环。回调的一个主要问题是它们要求你将程序执行分解成小函数，这些函数将在某个事件发生时被调用。正如我们在前面的章节中看到的，回调可以很快变得繁琐。在下一节中，我们将看到如何使用协程，就像使用未来一样，简化并发编程的许多方面。
- en: Coroutines
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协程
- en: '**Coroutines** are another, perhaps more natural, way to break up the program
    execution into chunks. They allow the programmer to write code that resembles
    synchronous code but will execute asynchronously. You may think of a coroutine
    as a function that can be stopped and resumed. A basic example of coroutines is
    generators.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**协程**是另一种，可能更自然的方法，可以将程序执行分解成块。它们允许程序员编写类似于同步代码的代码，但将以异步方式执行。你可以将协程想象为一个可以被停止和恢复的函数。协程的一个基本例子是生成器。'
- en: 'Generators can be defined in Python using the `yield` statement inside a function.
    In the following code example in `example8.py`, we implement the `range_generator`
    function, which produces and returns values from `0` to `n`. We also add a `print`
    statement to log the internal state of the generator:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，可以使用函数内的 `yield` 语句定义生成器。在以下 `example8.py` 代码示例中，我们实现了 `range_generator`
    函数，该函数从 `0` 到 `n` 生成并返回值。我们还添加了一个 `print` 语句来记录生成器的内部状态：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When we call the `range_generator` function, the code is not executed immediately.
    Note that nothing is printed to output when the following snippet is executed.
    Instead, a `generator` object is returned:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `range_generator` 函数时，代码不会立即执行。请注意，当执行以下代码片段时，不会打印任何内容到输出。相反，返回了一个 `generator`
    对象：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In order to start pulling values from a generator, it is necessary to use the
    `next` function, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始从生成器中提取值，必须使用 `next` 函数，如下所示：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that every time we invoke `next`, the code runs until it encounters the
    next `yield` statement, and it is necessary to issue another `next` statement
    to resume the generator execution. You can think of a `yield` statement as a breakpoint
    where we can stop and resume execution (while also maintaining the internal state
    of the generator). This ability to stop and resume execution can be leveraged
    by the event loop to allow for and implement concurrency.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每次我们调用`next`时，代码会运行直到遇到下一个`yield`语句，并且必须发出另一个`next`语句来恢复生成器的执行。你可以把`yield`语句看作是一个断点，在这里我们可以停止和恢复执行（同时保持生成器的内部状态）。这种停止和恢复执行的能力可以被事件循环利用，以允许并实现并发。
- en: 'It is also possible to *inject* (rather than *extract*) values in the generator
    through the `yield` statement. In the following code example in `example9.py`,
    we declare a `parrot` function that will repeat each message that we send:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`yield`语句，也可以在生成器中*注入*（而不是*提取*）值。在`example9.py`中的以下代码示例中，我们声明了一个`parrot`函数，该函数将重复发送的每条消息：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To allow a generator to receive a value, you can assign `yield` to a variable
    (in our case, it is `message = yield`). To insert values in the generator, we
    can use the `send` method. In the Python world, a generator that can also receive
    values is called a **generator-based coroutine**.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许生成器接收一个值，你可以将`yield`赋值给一个变量（在我们的例子中，它是`message = yield`）。要在生成器中插入值，我们可以使用`send`方法。在Python世界中，既能接收值又能发送值的生成器被称为**基于生成器的协程**。
- en: Note that we also need to issue a `generator.send(None)` request before we can
    start sending messages; this is to bootstrap the function execution and bring
    us to the first `yield` statement. Also, note that there is an infinite loop inside
    `parrot`; if we implement this without using generators, we will get stuck running
    the loop forever!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们开始发送消息之前，我们还需要发出一个`generator.send(None)`请求；这是为了启动函数执行并带我们到第一个`yield`语句。此外，注意`parrot`内部有一个无限循环；如果我们不使用生成器来实现这个循环，我们将陷入无限循环的困境！
- en: With this in mind, you can imagine how an event loop can partially progress
    several of these generators without blocking the execution of the whole program,
    as well as how a generator can be advanced only when some resource is ready, therefore
    eliminating the need for a callback.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以想象事件循环如何在不阻塞整个程序执行的情况下部分地推进这些生成器，以及生成器何时在某个资源准备好时才被推进，从而消除了回调的需要。
- en: 'It is possible to implement coroutines in `asyncio` using the `yield` statement.
    However, Python supports the definition of powerful coroutines using a more intuitive
    syntax. To define a coroutine with `asyncio`, you can use the `async def` statement,
    as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`yield`语句在`asyncio`中实现协程是可能的。然而，Python支持使用更直观的语法定义强大的协程。要使用`asyncio`定义协程，你可以使用`async
    def`语句，如下所示：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, if we call the `hello` function, the function body is not executed
    immediately, but a `coroutine object` instance is returned. The `asyncio` coroutines
    do not support `next`, but they can be easily run in the `asyncio` event loop
    using the `run_until_complete` method, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，如果我们调用`hello`函数，函数体不会立即执行，而是返回一个`coroutine object`实例。`asyncio`协程不支持`next`，但它们可以很容易地在`asyncio`事件循环中使用`run_until_complete`方法运行，如下所示：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Native Coroutines
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 原生协程
- en: Coroutines defined with the `async def` statement are also called *native coroutines*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`async def`语句定义的协程也被称为**原生协程**。
- en: 'The `asyncio` module provides resources (called `await` syntax. For example,
    in `example10.py`, if we want to wait for a certain time and then execute a statement,
    we can use the `asyncio.sleep` function, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`模块提供了资源（称为`await`语法。例如，在`example10.py`中，如果我们想等待一段时间然后执行一个语句，我们可以使用`asyncio.sleep`函数，如下所示：'
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The result is beautiful, clean code. We are writing perfectly functional asynchronous
    code without all the ugliness of callbacks!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是美丽、干净的代码。我们正在编写功能齐全的异步代码，而没有回调的所有丑陋之处！
- en: Breakpoints for Event Loops
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环的断点
- en: You may have noted how `await` provides a breakpoint for the event loop so that,
    as it waits for the resource, the event loop can move on and concurrently manage
    other coroutines.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了`await`如何为事件循环提供一个断点，这样在等待资源的同时，事件循环可以继续运行并并发管理其他协程。
- en: 'Even better, coroutines are also `awaitable`, and we can use the `await` statement
    to chain coroutines asynchronously. In the following example, we rewrite the `network_request`
    function, which we defined earlier, by replacing the call to `time.sleep` with
    `asyncio.sleep`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，协程也是 `awaitable` 的，我们可以使用 `await` 语句来异步地链式调用协程。在以下示例中，我们重写了之前定义的 `network_request`
    函数，将 `time.sleep` 的调用替换为 `asyncio.sleep`：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can follow up by reimplementing `fetch_square`, as illustrated in the following
    code snippet. As you can see, we await `network_request` directly without needing
    additional futures or callbacks:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过重新实现 `fetch_square` 来跟进，如下面的代码片段所示。如您所见，我们直接等待 `network_request`，无需额外的未来或回调：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The coroutines can be executed individually using `loop.run_until_complete`,
    as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `loop.run_until_complete` 单独执行协程，如下所示：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Running tasks using `run_until_complete` serves as a demonstration for testing
    and debugging. However, our program will be started with `loop.run_forever` most
    of the time, and we will need to submit our tasks while the loop is already running.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `run_until_complete` 运行任务可以作为测试和调试的演示。然而，我们的程序大多数情况下将以 `loop.run_forever`
    启动，并且我们需要在循环已经运行时提交我们的任务。
- en: '`asyncio` provides the `ensure_future` function, which schedules coroutines
    (as well as futures) for execution. `ensure_future` can be used by simply passing
    the coroutine we want to schedule. The following code snippet in `example11.py`
    will schedule multiple calls to `fetch_square` that will be executed concurrently:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio` 提供了 `ensure_future` 函数，该函数用于调度协程（以及未来）的执行。`ensure_future` 可以通过简单传递我们想要调度的协程来使用。以下
    `example11.py` 中的代码片段将调度多个对 `fetch_square` 的调用，这些调用将并发执行：'
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As a bonus, when passing a coroutine, the `asyncio.ensure_future` function will
    return a `Task` instance (which is a subclass of `Future`) so that we can take
    advantage of the `await` syntax without having to give up the resource-tracking
    capabilities of regular futures.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的好处，当传递一个协程时，`asyncio.ensure_future` 函数将返回一个 `Task` 实例（它是 `Future` 的子类），这样我们就可以利用
    `await` 语法，而无需放弃常规未来的资源跟踪能力。
- en: Converting blocking code into non-blocking code
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将阻塞代码转换为非阻塞代码
- en: 'While `asyncio` supports connecting to resources in an asynchronous way, it
    is required to use blocking calls in certain cases. This happens, for example,
    when third-party `asyncio`. Here are the steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `asyncio` 支持以异步方式连接到资源，但在某些情况下需要使用阻塞调用。例如，当第三方 `asyncio`。以下是步骤：
- en: An effective strategy for dealing with blocking code is to run it in a separate
    thread. Threads are implemented at the OS level and allow parallel execution of
    blocking code. For this purpose, Python provides the `Executor` interface designed
    to run tasks in a separate thread and to monitor their progress using futures.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理阻塞代码的有效策略是在单独的线程中运行它。线程在操作系统级别实现，允许并行执行阻塞代码。为此，Python 提供了 `Executor` 接口，用于在单独的线程中运行任务，并使用未来来监控它们的进度。
- en: You can initialize a `ThreadPoolExecutor` instance by importing it from the
    `concurrent.futures` module. The executor will spawn a collection of threads (called
    workers) that will wait to execute whichever task we throw at them. Once a function
    is submitted, the executor will take care of dispatching its execution to an available
    worker thread and keep track of the result. The `max_workers` argument can be
    used to select the number of threads.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过从 `concurrent.futures` 模块导入它来初始化 `ThreadPoolExecutor` 实例。执行器将启动一组线程（称为工作者），它们将等待执行我们抛给它们的任何任务。一旦提交了一个函数，执行器将负责将其执行调度到可用的工作者线程，并跟踪结果。可以使用
    `max_workers` 参数来选择线程数。
- en: Note that the executor will not destroy a thread once a task is completed. By
    doing so, it reduces the cost associated with the creation and destruction of
    threads.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦任务完成，执行器不会销毁线程。这样做可以减少与线程创建和销毁相关的成本。
- en: 'In the following code example in `example12.py`, we create a `ThreadPoolExecutor`
    instance with three workers, and we submit a `wait_and_return` function that will
    block the program execution for 1 second and return a message string. We then
    use the `submit` method to schedule its execution:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下 `example12.py` 代码示例中，我们创建了一个具有三个工作者的 `ThreadPoolExecutor` 实例，并提交了一个 `wait_and_return`
    函数，该函数将阻塞程序执行 1 秒并返回一个消息字符串。然后我们使用 `submit` 方法来调度其执行：
- en: '[PRE32]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `executor.submit` method immediately schedules the function and returns
    a future. It is possible to manage the execution of tasks in `asyncio` using the
    `loop.run_in_executor` method, which works quite similarly to `executor.submit`.
    The code is illustrated in the following snippet:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`executor.submit` 方法立即安排函数并返回一个 future。可以使用 `loop.run_in_executor` 方法来管理 `asyncio`
    中的任务执行，它的工作方式与 `executor.submit` 非常相似。以下代码片段展示了这一点：'
- en: '[PRE33]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `run_in_executor` method will also return an `asyncio.Future` instance
    that can be awaited from other code, the main difference being that the future
    will not be run until we start the loop. We can run and obtain the response using
    `loop.run_until_complete`, as illustrated in the following snippet:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`run_in_executor` 方法还将返回一个 `asyncio.Future` 实例，可以从其他代码中等待。主要区别在于，future 不会运行，直到我们开始循环。我们可以使用
    `loop.run_until_complete` 运行并获取响应，如下面的代码片段所示：'
- en: '[PRE34]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As a practical example, we can use this technique to implement concurrent fetching
    of several web pages. To do this, we will import the popular (blocking) `requests`
    library and run the `requests.get` function in the executor in `example13.py`,
    as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为实际示例，我们可以使用这项技术来实现多个网页的并发获取。为此，我们将导入流行的（阻塞的）`requests` 库，并在 `example13.py`
    中的执行器中运行 `requests.get` 函数，如下所示：
- en: '[PRE35]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This version of `fetch_url` will not block the execution and allow other coroutines
    in `asyncio` to run; however, it is not optimal as the function will not fetch
    a `asyncio.ensure_future` or employ the `asyncio.gather` convenience function
    that will submit all the coroutines at once and gather the results as they come.
    The usage of `asyncio.gather` is demonstrated in `example14.py`, as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个版本的 `fetch_url` 不会阻塞执行，并允许 `asyncio` 中的其他协程运行；然而，它并不理想，因为该函数不会获取 `asyncio.ensure_future`
    或使用 `asyncio.gather` 便利函数，该函数将一次性提交所有协程并收集结果。`asyncio.gather` 的使用在 `example14.py`
    中演示如下：
- en: '[PRE36]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Upper Bound for the Number of Threads
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 线程数量的上限
- en: The number of URLs you can fetch in parallel with this method will be dependent
    on the number of worker threads you have. To avoid this limitation, you should
    use a natively non-blocking library, such as `aiohttp`.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这种方法可以并行获取的 URL 数量将取决于您拥有的工作线程数量。为了避免这种限制，您应该使用原生的非阻塞库，例如 `aiohttp`。
- en: So far, we have seen how to work with concurrent programs in Python using core
    concepts such as callbacks, futures, and coroutines. For the remaining portion
    of this chapter, we will discuss a more streamlined programming paradigm for implementing
    concurrency.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何使用回调、futures 和协程等核心概念在 Python 中处理并发程序。在本章剩余部分，我们将讨论一种更简洁的编程范式来实现并发。
- en: Reactive programming
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式编程
- en: '**Reactive programming** is a paradigm that aims at building better concurrent
    systems. Reactive applications are designed to comply with the following requirements
    exemplified by the reactive manifesto:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**反应式编程**是一种旨在构建更好的并发系统的范式。反应式应用程序旨在符合反应式宣言中例示的以下要求：'
- en: '**Responsive**: The system responds immediately to the user.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式**：系统立即响应用户。'
- en: '**Elastic**: The system is capable of handling different levels of load and
    can adapt to accommodate increasing demands.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：系统能够处理不同级别的负载，并能适应不断增长的需求。'
- en: '**Resilient**: The system deals with failure gracefully. This is achieved by
    modularity and avoiding having a **single point of failure** (**SPOF**).'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：系统能够优雅地处理故障。这是通过模块化和避免存在**单点故障**（**SPOF**）来实现的。'
- en: '**Message-driven**: The system should not block and take advantage of events
    and messages. A message-driven application helps achieve all the previous requirements.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息驱动**：系统不应阻塞并利用事件和消息。消息驱动应用程序有助于实现所有先前要求。'
- en: 'The requirements for reactive systems are quite reasonable but abstract, which
    leads us to a natural question: how exactly does reactive programming work? In
    this section, we will learn about the principles of reactive programming using
    the **Reactive Extensions for Python** (**RxPY**) library.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式系统的要求相当合理但抽象，这引出了一个问题：反应式编程究竟是如何工作的？在本节中，我们将通过使用 **Reactive Extensions for
    Python**（**RxPY**）库来了解反应式编程的原则。
- en: Additional Information
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 其他信息
- en: The `RxPY` library is part of ReactiveX ([http://reactivex.io/](http://reactivex.io/)),
    which is a project that implements reactive programming tools for a large variety
    of languages.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`RxPY` 库是 ReactiveX ([http://reactivex.io/](http://reactivex.io/)) 的一部分，这是一个实现多种语言反应式编程工具的项目。'
- en: To install the library, simply run `pip install rx`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装库，只需运行`pip install rx`。
- en: Note that the following code uses `RxPY` v3, the syntax of which is quite different
    from `RxPY` v1\. If you are familiar with `RxPY` v1 and the discussion from this
    book's previous version, watch out for changes in syntax!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，以下代码使用的是`RxPY` v3，其语法与`RxPY` v1相当不同。如果你熟悉`RxPY` v1以及本书前版本的讨论，请注意语法的变化！
- en: Observables
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可观察对象
- en: As the name implies, the main idea of reactive programming is to *react* to
    events. In the preceding section, we saw some examples of this idea with callbacks;
    you subscribe to them and the callback is executed as soon as the event takes
    place.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，响应式编程的主要思想是*响应*事件。在前一节中，我们通过回调示例看到了这个想法的一些例子；你订阅它们，一旦事件发生，回调就会立即执行。
- en: 'In reactive programming, this idea is expanded if we think of events as streams
    of data. This can be exemplified by showing examples of such streams in `RxPY`.
    A data stream can be created from an iterator using the `from_iterable` method
    in IPython, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式编程中，如果我们将事件视为数据流，这个想法就会得到扩展。这可以通过在`RxPY`中展示此类数据流的示例来体现。可以使用IPython中的`from_iterable`方法从迭代器创建数据流，如下所示：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In order to receive data from `obs`, we can use the `Observable.subscribe`
    method, which will execute the function we pass for each value that the data source
    emits. This method is shown in the following code snippet:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从`obs`接收数据，我们可以使用`Observable.subscribe`方法，该方法将为数据源发出的每个值执行我们传递的函数。此方法在以下代码片段中显示：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You may have noticed that observables are ordered collections of items just
    like lists or, more generally, iterators. This is not a coincidence.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，可观察者是类似于列表或更一般地说，迭代器的有序集合。这并非巧合。
- en: The term *observable* comes from the combination of observer and iterable. An
    *observer* is an object that reacts to changes of the variable it observes, while
    an *iterable* is an object that can produce and keep track of an iterator.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*可观察*来自观察者和可迭代的组合。一个*观察者*是一个对它观察的变量的变化做出反应的对象，而一个*可迭代*是一个可以产生并跟踪迭代器的对象。
- en: 'In Python, iterators are objects that define the `__next__` method, and whose
    elements can be extracted by calling `next`. An iterator can generally be obtained
    by a collection using `iter`; then, we can extract elements using `next` or a
    `for` loop. Once an element is consumed from the iterator, we can''t go back.
    We can demonstrate its usage by creating an iterator from a list, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，迭代器是定义了`__next__`方法的对象，并且可以通过调用`next`来提取其元素。通常，我们可以通过使用`iter`从集合中获取迭代器；然后，我们可以使用`next`或`for`循环来提取元素。一旦从迭代器中消耗了一个元素，我们就无法回到之前的位置。我们可以通过从列表创建迭代器来演示其用法，如下所示：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can see how, every time we call `next` or we iterate, the iterator produces
    a value and advances. In a sense, we are *pulling* results from the iterator.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，每次我们调用`next`或迭代时，迭代器都会产生一个值并前进。从某种意义上说，我们是从迭代器中*拉取*结果。
- en: Iterators versus Generators
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器与生成器
- en: Iterators sound a lot like generators; however, they are more general. In Python,
    generators are returned by functions that use `yield` expressions. As we saw,
    generators support `next`; therefore, they are a special class of iterators.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器听起来很像生成器；然而，它们更通用。在Python中，生成器是由使用`yield`表达式的函数返回的。正如我们所见，生成器支持`next`；因此，它们是迭代器的一个特殊类。
- en: Now, you can appreciate the contrast between an iterator and an observable.
    An observable *pushes* a stream of data to us whenever it's ready, but that's
    not everything. An observable can also tell us when there is an error and where
    there is no more data. In fact, it is possible to register further callbacks to
    the `Observable.subscribe` method.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以欣赏迭代器和可观察对象之间的对比。可观察对象在准备好时将数据流推给我们，但这并非全部。可观察对象还可以告诉我们何时发生错误以及何时没有更多数据。实际上，我们可以将更多的回调注册到`Observable.subscribe`方法。
- en: 'In the following example in IPython, we create an observable and register callbacks
    to be called using `on_next` whenever the next item is available and using the
    `on_completed` argument when there is no more data:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下IPython示例中，我们创建了一个可观察对象，并注册了回调，当有下一个项目可用时使用`on_next`调用，当没有更多数据时使用`on_completed`参数：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With that said, the similarity between observables and iterators is more important,
    because we can use the same techniques that can be used with iterators to handle
    streams of events.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，可观察对象和迭代器之间的相似性更为重要，因为我们可以使用与迭代器相同的技巧来处理事件流。
- en: '`RxPy` provides operators that can be used to create, transform, filter, and
    group observables. The power of reactive programming lies in the fact that those
    operations return other observables that can be conveniently chained and composed
    together. For a quick demonstration, we will examine the usage of the `take` operator
    next.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`RxPy` 提供了可以用来创建、转换、过滤和分组的操作符。响应式编程的强大之处在于，这些操作返回其他可观察量，可以方便地链接和组合在一起。为了快速演示，我们将接下来检查
    `take` 操作符的用法。'
- en: 'Given an observable, `take` will return a new observable that will stop after
    `n` items. Its usage is straightforward, as we can see here:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个可观察量，`take` 将返回一个新的可观察量，该可观察量将在 `n` 个项目后停止。其用法很简单，如下所示：
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The collection of operations implemented in `RxPy` is varied and rich and can
    be used to build complex applications using these operators as building blocks.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `RxPy` 中实现的操作集合多样且丰富，可以使用这些操作符作为构建块来构建复杂的应用程序。
- en: Useful operators
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的操作符
- en: In this subsection, we will explore operators that transform the elements of
    a source observable in some way. The most prominent member of this family of operators
    is the familiar `map` operator, which emits the elements of the source observable
    after applying a function to them.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将探讨以某种方式转换源可观察量元素的运算符。这个家族中最突出的成员是熟悉的 `map` 操作符，它在对源可观察量的元素应用函数后发射这些元素。
- en: 'For example, we may use `map` to calculate the square of a sequence of numbers,
    as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用 `map` 来计算数字序列的平方，如下所示：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Operators can be represented with marble diagrams that help us better understand
    how the operator works, especially when taking into account the fact that elements
    can be emitted over a region of time. In a marble diagram, a data stream (in our
    case, an observable) is represented by a solid line. A circle (or another shape)
    identifies a value emitted by the observable, an *X* symbol represents an error,
    and a vertical line represents the end of the stream.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符可以用马赛克图表示，这有助于我们更好地理解操作符的工作原理，特别是考虑到元素可以在一段时间内发射。在马赛克图中，数据流（在我们的情况下，是可观察量）由一条实线表示。一个圆圈（或另一个形状）标识可观察量发射的值，一个
    *X* 符号表示错误，一条垂直线表示流的结束。
- en: 'Here, we can see a marble diagram of `map`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 `map` 的马赛克图：
- en: '![Figure 7.4 – Marble diagram illustrating the procedure of squaring numbers
    ](img/Figure_7.4_B17499.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 马赛克图说明平方数字的过程](img/Figure_7.4_B17499.jpg)'
- en: Figure 7.4 – Marble diagram illustrating the procedure of squaring numbers
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 马赛克图说明平方数字的过程
- en: The source observable is placed at the top of the diagram, the transformation
    is placed in the middle, and the resulting observable is placed at the bottom.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 源可观察量放置在图的最上方，变换放置在中间，结果可观察量放置在底部。
- en: Another example of a transformation is `group_by`, which sorts items into groups
    based on a key. The `group_by` operator takes a function that extracts a key when
    given an element and produces an observable for each key with the elements associated
    with it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个变换的例子是 `group_by`，它根据键将项目排序到组中。`group_by` 操作符接受一个函数，当给定一个元素时提取一个键，并为每个键及其相关元素生成一个可观察量。
- en: 'The `group_by` operation can be expressed more clearly using a marble diagram.
    In the following diagram, you can see how `group_by` emits two observables. Additionally,
    the items are dynamically sorted into groups *as soon as they are emitted*:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用马赛克图可以更清楚地表达 `group_by` 操作。在以下图中，你可以看到 `group_by` 发射了两个可观察量。此外，项目在发射后立即动态地排序到组中：
- en: '![Figure 7.5 – Marble diagram illustrating grouping ](img/Figure_7.5_B17499.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 马赛克图说明分组](img/Figure_7.5_B17499.jpg)'
- en: Figure 7.5 – Marble diagram illustrating grouping
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 马赛克图说明分组
- en: 'We can further understand how `group_by` works with a simple example. Let''s
    say that we want to group a number according to the fact that it''s even or odd.
    We can implement this using `group_by` by passing the `lambda x: x % 2` expression
    as a key function, which will return `0` if the number is even and `1` if the
    number is odd, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以通过一个简单的例子进一步了解 `group_by` 的工作原理。假设我们想要根据数字是偶数还是奇数来分组。我们可以通过传递 `lambda x:
    x % 2` 表达式作为键函数来实现这一点，该函数将返回 `0`（如果数字是偶数）或 `1`（如果数字是奇数），如下所示：'
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'At this point, if we subscribe and print the content of `obs`, two observables
    are actually printed, as illustrated in the following code snippet:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果我们订阅并打印 `obs` 的内容，实际上会打印出两个可观察量，如下面的代码片段所示：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can determine the group key using the `key` attribute. To extract all the
    even numbers, we can take the first observable (corresponding to a key equal to
    0) and subscribe to it. In the following code snippet, we show how this works:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`key`属性来确定组密钥。为了提取所有偶数，我们可以取第一个可观察项（对应于等于0的密钥）并订阅它。在下面的代码片段中，我们展示了它是如何工作的：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: With `group_by`, we introduced an observable that emits other observables. This
    turns out to be quite a common pattern in reactive programming, and there are
    functions that allow you to combine different observables.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`group_by`，我们引入了一个发出其他可观察项的可观察项。这实际上是响应式编程中相当常见的一种模式，并且有一些函数允许你组合不同的可观察项。
- en: 'A useful tool for combining observables is `merge_all` which takes multiple
    observables and produces a single observable that contains the element of the
    two observables in the order they are emitted. This is better illustrated using
    a marble diagram, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于组合可观察项的有用工具是`merge_all`，它接受多个可观察项并产生一个包含两个可观察项元素的单一可观察项，这些元素按照它们发出的顺序排列。以下是一个使用宝石图的示例，如下所示：
- en: '![Figure 7.6 – Marble diagram illustrating merging ](img/Figure_7.6_B17499.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6 – 说明合并的宝石图](img/Figure_7.6_B17499.jpg)'
- en: Figure 7.6 – Marble diagram illustrating merging
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 说明合并的宝石图
- en: 'To demonstrate its usage, we can apply the operation to the observable of observables
    returned by `group_by`, as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示其用法，我们可以将操作应用于`group_by`返回的可观察项的可观察项，如下所示：
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: With `merge_all`, the items are returned in the same order as they were initially
    (remember that `group_by` emits elements in the two groups as they come).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`merge_all`，项目将按照它们最初出现的顺序返回（记住`group_by`按两个组中的元素出现的顺序发出元素）。
- en: Tip
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`RxPy` also provides the `merge` operation, which can be used to combine individual
    observables.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`RxPy`还提供了`merge`操作，可以用来组合单个可观察项。'
- en: Hot and cold observables
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 热和冷可观察项
- en: In the preceding section, we learned how to create an observable using the `from_iterable`
    method. `RxPy` provides many other tools to create more interesting event sources.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何使用`from_iterable`方法创建可观察项。`RxPy`提供了许多其他工具来创建更有趣的事件源。
- en: '`interval` takes a time interval in seconds, `period`, and creates an observable
    that emits a value every time the period has passed. The following code can be
    used to define an observable, `obs`, that will emit a number, starting from zero,
    every second. We use the `take` operator to limit the timer to four events:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`interval`接受以秒为单位的时间间隔`period`，并创建一个在每次周期通过时发出值的可观察项。以下代码可以用来定义一个名为`obs`的可观察项，它将从零开始每秒发出一个数字。我们使用`take`操作符将计时器限制为四个事件：'
- en: '[PRE47]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'A very important fact about `interval` is that the timer doesn''t start until
    we subscribe. We can observe this by printing both the index and the delay from
    when the timer starts definition using `time.time()`, as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`interval`的一个非常重要的事实是，计时器不会在我们订阅之前启动。我们可以通过打印从计时器启动定义时的索引和延迟来观察这一点，如下所示：
- en: '[PRE48]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, the first element (corresponding to a `0` index) is produced
    after 3 seconds, which means that the timer started when we issue the `subscribe(print)`
    method.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，第一个元素（对应于`0`索引）在3秒后产生，这意味着计时器在我们发出`subscribe(print)`方法时启动。
- en: 'Observables such as `interval` are called *lazy* because they start producing
    values only when requested (think of them as vending machines that won''t dispense
    food unless we press the button). In Rx jargon, these kinds of observables are
    called **cold**. A property of cold observables is that, if we attach two subscribers,
    the interval timer will be started multiple times. This is quite evident from
    the following example. Here, we add a new subscription 0.5 seconds after the first,
    and you can see how the output of the two subscriptions comes at different times:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如`interval`这样的可观察项被称为*懒加载*，因为它们只有在被请求时才开始产生值（想想看它们就像自动售货机，除非我们按下按钮，否则不会分发食物）。在Rx术语中，这类可观察项被称为**冷可观察项**。冷可观察项的一个特性是，如果我们附加两个订阅者，间隔计时器将被多次启动。这可以从以下示例中清楚地看出。在这里，我们在第一个订阅后0.5秒添加一个新的订阅，你可以看到两个订阅的输出在时间上有所不同：
- en: '[PRE49]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Sometimes, we may not want this behavior as we may want multiple subscribers
    to subscribe to the same data source. To make the observable produce the same
    data, we can delay the data production and ensure that all the subscribers will
    get the same data using the `publish` method.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能不希望这种行为，因为我们可能希望多个订阅者订阅相同的数据源。为了使可观察项产生相同的数据，我们可以延迟数据生产，并确保所有订阅者都将获得相同的数据，使用`publish`方法。
- en: '`publish` will transform our observable into `ConnectableObservable`, which
    won''t start pushing data immediately, but only when we call the `connect` method.
    The usage of `publish` and `connect` is demonstrated in the following code snippet:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`publish` 将我们的可观察对象转换为 `ConnectableObservable`，它不会立即开始推送数据，而只有在我们调用 `connect`
    方法时才会。`publish` 和 `connect` 的用法在下面的代码片段中演示：'
- en: '[PRE50]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this example, you can see how we first issue `publish`, then we subscribe
    the first subscriber, and finally, we issue `connect`. When `connect` is issued,
    the timer will start producing data. The second subscriber joins the party late
    and, in fact, won't receive the first two messages but will start receiving data
    from the third, and so on. Note that, this time around, the subscribers share
    the exact same data. This kind of data source, where data is produced independently
    of the subscribers, is called **hot**.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以看到我们首先发出 `publish`，然后订阅第一个订阅者，最后发出 `connect`。当发出 `connect` 时，计时器将开始产生数据。第二个订阅者晚些时候加入，实际上它不会收到前两条消息，而是从第三条开始接收数据，依此类推。注意，这次，订阅者共享完全相同的数据。这种独立于订阅者产生数据的数据源被称为
    **热**。
- en: 'Similar to `publish`, you can use the `replay` method that will produce the
    data *from the beginning* for each new subscriber. This is illustrated in the
    following example, which is identical to the preceding one except that we replaced
    `publish` with `replay`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `publish` 类似，你可以使用 `replay` 方法，该方法将为每个新的订阅者从开始处产生数据。以下示例说明了这一点，它与前面的示例相同，只是我们将
    `publish` 替换为 `replay`：
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Notice that even though the second subscriber arrives late to the party, it
    is still given all the items that have been given out so far.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管第二个订阅者晚些时候到达聚会，但它仍然得到了迄今为止已经分发出去的所有项目。
- en: 'Another way of creating hot observables is through the `Subject` class. `Subject`
    is interesting because it''s capable of both receiving and pushing data, and thus
    it can be used to manually *push* items to an observable. Using `Subject` is very
    intuitive; in the following code snippet, we create a `Subject` instance and subscribe
    to it. Later, we push values to it using the `on_next` method; as soon as we do
    that, the subscriber is called:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 创建热可观察对象的另一种方式是通过 `Subject` 类。`Subject` 很有趣，因为它既能接收数据也能推送数据，因此它可以用来手动 *推送* 项目到一个可观察对象。使用
    `Subject` 非常直观；在下面的代码片段中，我们创建一个 `Subject` 实例并订阅它。稍后，我们使用 `on_next` 方法向它推送值；一旦这样做，订阅者就会被调用：
- en: '[PRE52]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that `Subject` is another example of a hot observable.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Subject` 是另一个热可观察对象的例子。
- en: Building a CPU monitor
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 CPU 监视器
- en: 'Now that we have a grasp of the main reactive programming concepts, we can
    implement an example application: a monitor that will give us real-time information
    about our CPU usage and that can detect spikes.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了主要的响应式编程概念，我们可以实现一个示例应用程序：一个将给我们提供关于我们的 CPU 使用情况的实时信息，并且可以检测尖峰的监视器。
- en: Note
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The complete code for the CPU monitor can be found in the `cpu_monitor.py` file.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 监视器的完整代码可以在 `cpu_monitor.py` 文件中找到。
- en: 'As a first step, let''s implement a data source. We will use the `psutil` module
    that provides a function, `psutil.cpu_percent`, that returns the latest available
    CPU usage as a percentage (and doesn''t block). The code is illustrated in the
    following snippet:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，让我们实现一个数据源。我们将使用 `psutil` 模块，该模块提供了一个函数 `psutil.cpu_percent`，它返回最新的 CPU
    使用率作为百分比（并且不会阻塞）。代码如下所示：
- en: '[PRE53]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Since we are developing a monitor, we would like to sample this information
    over a few time intervals. To accomplish, this we can use the familiar `interval`
    observable, followed by `map`, just as we did in the previous section. Also, we
    would like to make this observable *hot* as, for this application, all subscribers
    should receive a single source of data; to make `interval` hot, we can use the
    `publish` and `connect` methods. The full code for the creation of a `cpu_data`
    observable is shown here:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在开发一个监视器，我们希望在不同时间间隔内采样这些信息。为了实现这一点，我们可以使用熟悉的 `interval` 可观察对象，然后是 `map`，就像我们在前面的部分中所做的那样。此外，我们希望使这个可观察对象成为
    *热*，因为对于这个应用程序，所有订阅者都应该接收单一的数据源；为了使 `interval` 成为热，我们可以使用 `publish` 和 `connect`
    方法。创建 `cpu_data` 可观察对象的完整代码如下所示：
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can test our monitor by printing a sample of four items, as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过打印四个项目的样本来测试我们的监视器，如下所示：
- en: '[PRE55]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now that our main data source is in place, we can implement a monitor visualization
    using `matplotlib`. The idea is to create a plot that contains a fixed number
    of measurements and, as new data arrives, we include the newest measurement and
    remove the oldest one. This is commonly referred to as a *moving window* and is
    better understood with an illustration. In the following diagram, our `cpu_data`
    stream is represented as a list of numbers. The first plot is produced as soon
    as we have the first four numbers and, each time a new number arrives, we shift
    the window by one position and update the plot:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了主要数据源，我们可以使用`matplotlib`实现一个监控可视化。想法是创建一个包含固定数量测量的绘图，当新数据到达时，我们包括最新的测量值并移除最旧的测量值。这通常被称为*移动窗口*，通过一个示意图可以更好地理解。在以下图中，我们的`cpu_data`流被表示为数字列表。第一个绘图是在我们获得前四个数字时产生的，每次新数字到达时，我们通过一个位置移动窗口并更新绘图：
- en: '![Figure 7.7 – Illustration of a moving window ](img/Figure_7.7_B17499.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7 – 移动窗口的示意图](img/Figure_7.7_B17499.jpg)'
- en: Figure 7.7 – Illustration of a moving window
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 移动窗口的示意图
- en: 'To implement this algorithm, we can write a function called `monitor_cpu` that
    will create and update our plotting window. The function will do the following
    things:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个算法，我们可以编写一个名为`monitor_cpu`的函数，该函数将创建并更新我们的绘图窗口。该函数将执行以下操作：
- en: Initialize an empty plot and set up the correct plot limits.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化一个空绘图并设置正确的绘图限制。
- en: Transform our `cpu_data` observable to return a moving window over the data.
    This can be accomplished using the `buffer_with_count` operator, which will take
    the number of points in our window, `npoints`, as parameters and the shift as
    `1`.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的`cpu_data`可观察对象转换为返回数据移动窗口。这可以通过使用`buffer_with_count`运算符来实现，它将窗口中的点数`npoints`作为参数，并将偏移量设置为`1`。
- en: Subscribe to this new data stream and update the plot with the incoming data.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅这个新的数据流，并使用传入的数据更新绘图。
- en: The complete code for the function is implemented in `cpu_monitor.py` and shown
    here and, as you can see, is extremely compact. Go ahead and install `matplotlib`
    if you don't have it in your environment already, using `pip install matplotlib`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的完整代码在`cpu_monitor.py`中实现，并在此处展示，如您所见，它非常紧凑。如果您还没有在环境中安装`matplotlib`，请使用`pip
    install matplotlib`进行安装。
- en: 'Take some time to run the function and play with the parameters. You can view
    the code here:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间运行函数并调整参数。您可以在以下位置查看代码：
- en: '[PRE56]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Another feature we may want to develop is an alert that triggers when the CPU
    has been high for a certain amount of time, as this may indicate that some of
    the processes in our machine are working very hard. This can be accomplished by
    combining `buffer_with_count` and `map`. We can take the CPU stream and a window,
    and test whether all items have a value higher than 20% usage (in a quad-core
    CPU, that corresponds to about one processor working at 100%) in the `map` function.
    If all the points in the window have a higher-than-20% usage, we display a warning
    in our plot window.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还想开发一个功能，当CPU在一段时间内保持高负载时，会触发一个警报，因为这可能表明我们机器中的某些进程正在非常努力地工作。这可以通过结合`buffer_with_count`和`map`来实现。我们可以获取CPU流和窗口，并在`map`函数中测试所有项的值是否高于20%的使用率（在一个四核CPU中，这相当于一个处理器以100%的工作状态运行）。如果窗口中的所有点使用率都高于20%，我们将在我们的绘图窗口中显示一个警告。
- en: 'The implementation of the new observable can be written as follows and will
    produce an observable that emits `True` if the CPU has high usage, and `False`
    otherwise:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 新可观察对象的实现可以编写如下，并将产生一个可观察对象，如果CPU使用率高，则发出`True`，否则发出`False`：
- en: '[PRE57]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now that the `high_cpu` observable is ready, we can create a `matplotlib` label
    and subscribe to it for updates, as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`high_cpu`可观察对象已经准备好了，我们可以创建一个`matplotlib`标签并订阅它以获取更新，如下所示：
- en: '[PRE58]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Run the program from your terminal, and an interactive window will open to
    display your CPU usage data in real time. Here is a screenshot showing the output
    of our program:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的终端运行程序，将打开一个交互式窗口以实时显示您的CPU使用数据。以下是我们的程序输出的截图：
- en: '![Figure 7.8 – Monitoring CPU usage ](img/Figure_7.8_B17499.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8 – 监控CPU使用率](img/Figure_7.8_B17499.jpg)'
- en: Figure 7.8 – Monitoring CPU usage
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – 监控CPU使用率
- en: Here, the blue curve denotes the CPU usage, which stays below the normal threshold.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，蓝色曲线表示CPU使用率，它保持在正常阈值以下。
- en: While this example is relatively simple, it possesses the core components of
    a reactive program, and more complex applications that fully utilize the power
    of `RxPY` may be built using this as a blueprint.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子相对简单，但它包含了反应性程序的核心组件，并且可以使用这个作为蓝图构建充分利用`RxPY`功能的更复杂的应用程序。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Asynchronous programming is useful when our code deals with slow and unpredictable
    resources, such as I/O devices and networks. In this chapter, we explored the
    fundamental concepts of concurrency and asynchronous programming and how to write
    concurrent code with the `asyncio` and `RxPy` libraries.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的代码处理慢速且不可预测的资源时，如I/O设备和网络，异步编程非常有用。在本章中，我们探讨了并发和异步编程的基本概念，以及如何使用`asyncio`和`RxPy`库编写并发代码。
- en: '`asyncio` coroutines are an excellent choice when dealing with multiple, interconnected
    resources as they greatly simplify the code logic by cleverly avoiding callbacks.
    Reactive programming is also very good in these situations, but it truly shines
    when dealing with streams of data that are common in real-time applications and
    UIs.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理多个相互关联的资源时，`asyncio`协程是一个很好的选择，因为它们通过巧妙地避免回调，极大地简化了代码逻辑。反应性编程在这些情况下也非常好，但它真正在处理实时应用程序和UI中常见的流数据时大放异彩。
- en: Questions
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does asynchronous programming help programs run at higher speed?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步编程如何帮助程序以更高的速度运行？
- en: What are the main differences between callbacks and futures in asynchronous
    programming?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步编程中回调和未来之间主要区别是什么？
- en: What are the core characteristics/requirements of a reactive application?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反应性应用程序的核心特性/要求是什么？
- en: Further reading
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Migrating to `RxPY` v3: [https://rxpy.readthedocs.io/en/latests/migration.html](https://rxpy.readthedocs.io/en/latests/migration.html)'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '迁移到`RxPY` v3: [https://rxpy.readthedocs.io/en/latests/migration.html](https://rxpy.readthedocs.io/en/latests/migration.html)'
