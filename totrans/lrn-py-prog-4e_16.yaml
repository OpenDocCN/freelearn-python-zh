- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packaging Python Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ”Do you have any cheese at all?” “No.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Monty Python, the “Cheese Shop” sketch
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to create an installable package
    for a Python project and publish it for others to use.
  prefs: []
  type: TYPE_NORMAL
- en: There are many reasons why you should publish your code. In *Chapter 1, A Gentle
    Introduction to Python* , we said that one of the benefits of Python is the vast
    ecosystem of third-party packages that you can install for free using `pip` .
    Most of these were created by developers just like you and, by contributing with
    your own projects, you will be helping to ensure that the community keeps thriving.
    In the long term, it will also help to improve your code, since exposing it to
    more users means bugs might be discovered sooner. Finally, if you are trying to
    get a job as a software developer, it really helps to be able to point to projects
    that you have worked on.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to learn about packaging is to go through the process of creating
    a package and publishing it. That is what we are going to do in this chapter.
    The project that we will be working with is the Railway **command-line interface**
    ( **CLI** ) application we developed in *Chapter 15, CLI Applications* .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create a distribution package for your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to publish your package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different tools for packaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start packaging and publishing our project, we will give you a brief
    introduction to the **Python Package Index** ( **PyPI** ) and some important terminology
    around Python packaging.
  prefs: []
  type: TYPE_NORMAL
- en: The Python Package Index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**PyPI** is an online repository of Python packages, hosted at [https://pypi.org](https://pypi.org)
    . It has a web interface that can be used to browse or search for packages and
    view their details. It also has APIs for tools like `pip` to find and download
    packages to install. PyPI is open for anybody to register and distribute their
    projects for free. Anybody can also install any package from PyPI for free.'
  prefs: []
  type: TYPE_NORMAL
- en: The repository is organized into **projects** , **releases** , and **distribution
    packages** . A project is a library, script, or application with its associated
    data or resources. For example, *FastAPI* , *Requests* , *pandas* , *SQLAlchemy*
    , and our Railway CLI application are all projects. `pip` itself is a project
    as well. A release is a particular version (or snapshot in time) of a project.
    Releases are identified by version numbers. For example, `pip` *24.2* is a release
    of the `pip` project. Releases are distributed in the form of distribution packages.
    These are archive files, tagged with the release version, which contain the Python
    modules, data files, and so on, that make up the release. Distribution packages
    also contain metadata about the project and release, such as the name of the project,
    the authors, the release version, and dependencies that also need to be installed.
    Distribution packages are also referred to as **distributions** or just **packages**
    .
  prefs: []
  type: TYPE_NORMAL
- en: In Python, the word **package** is also used to refer to an importable module
    that can contain other modules, usually in the form of a folder containing a `__init__.py`
    file. It is important not to confuse this type of importable package with a distribution
    package. In this chapter, we will mostly use the term package to refer to a distribution
    package. Where there is ambiguity, we will use the terms **importable package**
    or **distribution package** .
  prefs: []
  type: TYPE_NORMAL
- en: Distribution packages can be either **source distributions** (also known as
    **sdists** ), which require a build step before they can be installed, or **built
    distributions** , which only require the archive contents to be moved to the correct
    locations during installation. The current format of source distributions was
    originally defined by PEP 517. The formal specification can be found at [https://packaging.python.org/specifications/source-distribution-format/](https://packaging.python.org/specifications/source-distribution-format/)
    . The standard built distribution format is called a **wheel** and was originally
    defined in PEP 427. The current version of the wheel specification can be found
    at [https://packaging.python.org/specifications/binary-distribution-format/](https://packaging.python.org/specifications/binary-distribution-format/)
    . The wheel format replaced the (now deprecated) **egg** built distribution format.
  prefs: []
  type: TYPE_NORMAL
- en: PyPI was initially nicknamed the Cheese Shop, after the famous Monty Python
    sketch that we quoted at the beginning of the chapter. Thus, the wheel distribution
    format is not named after the wheels of a car, but after wheels of cheese.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help understand all of this, let us go through a quick example of what happens
    when we run `pip install` . We will use `pip` to install release *2.32.3* of the
    *requests* project. To allow us to see exactly what `pip` is doing, we will use
    the `-v` command line option three times, to make the output as verbose as possible.
    We will also add the `--no-cache` command-line option to force `pip` to download
    packages from PyPI and not use any locally cached packages it might have. The
    output looks something like this (note that we have trimmed the output to fit
    on the page and omitted several lines; you can find the complete output in the
    source code for this chapter in the file `pip_install.txt` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`Pip` tells us that it has found information about the `requests` project at
    [https://pypi.org/simple/requests/](https://pypi.org/simple/requests/) . The output
    continues with a list of all the available distributions of the `requests` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `pip` collects the distribution for the release we requested. It downloads
    the metadata for the wheel distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, `pip` extracts the list of dependencies from the package metadata and
    proceeds to find and collect their metadata in the same way. Once all the required
    packages have been found, they can be downloaded and installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If `pip` had downloaded a source distribution for any of the packages (which
    might happen if no suitable wheel is available), it would have needed to build
    the package before installing it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the difference between a project, a release, and a package,
    we can start working on preparing a release and building distribution packages
    for the Railway CLI application.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging with Setuptools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using the **Setuptools** library to package our project. Setuptools
    is the oldest actively developed packaging tool for Python, and still the most
    popular. It is an extension of the original, standard library `distutils` packaging
    system. The `distutils` module was deprecated in Python 3.10 and removed from
    the standard library in Python 3.12.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will be looking at how to set up our project to build packages
    with Setuptools.
  prefs: []
  type: TYPE_NORMAL
- en: Project layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two popular conventions for laying out files in a Python project:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **src layout,** the importable packages that need to be distributed are
    placed in a folder named `src` within the main project folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the **flat layout,** the importable packages are placed directly in the top-level
    project folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The src layout has the advantage of being explicit about which files will be
    included in the distribution. This reduces the likelihood of accidentally including
    other files, such as scripts that are only meant for use during development. The
    src layout can, however, be less convenient during development as it is not possible
    to import the package from a script or Python console running in the top-level
    project folder without first installing the distribution in a virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: Proponents of the src layout argue that being forced to install the distribution
    package during development is actually a benefit, as it increases the likelihood
    that mistakes in creating the distribution package will be discovered during development.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this project, we have chosen to use the src layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `src/railway_cli` folder contains the code for the `railway_cli` importable
    package. We also added some tests, as an example for you to expand on, in the
    `test` folder. The `.flake8` file contains configuration for `flake8` , a Python
    code style checker that can help to point out PEP 8 violations in our code.
  prefs: []
  type: TYPE_NORMAL
- en: We will describe each of the remaining files in more detail below. Before that,
    though, let us look at how to install the project in a virtual environment during
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Development installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most common approach to working with an src layout is to use a **development
    installation** , also known as **development mode** , or an **editable installation**
    . This will build and install a wheel for the project. However, instead of copying
    the code into the virtual environment, it will add a link in the virtual environment
    to the source code in your project folder. This allows you to import and run the
    code as if it is installed, but any changes you make to the code will take effect
    without needing to rebuild and reinstall.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us try this now. Open a console, go to the source code folder for this
    chapter, create a new virtual environment, activate it, and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As the output shows, when we run `pip install` with the `-e` (or `--editable`
    ) option and give it the path to a project folder, it builds an editable wheel
    and installs it in the virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It should work as it did in the previous chapter. You can verify that we really
    have an editable installation by changing something in the code (for example,
    add a `print()` statement) and running it again.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a working editable installation of the project, let us discuss
    each of the files in the project folder in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Changelog
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although it is not required, it is considered good practice to include a change
    log file with your project. This file summarizes the changes made in each release
    of your project. The change log is useful for informing your users of new features
    that are available or of changes in the behavior of your software that they need
    to be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: Our changelog file is named `CHANGELOG.md` and is written in **Markdown** format.
  prefs: []
  type: TYPE_NORMAL
- en: License
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should include a license that defines the terms under which your code is
    distributed. There are many software licenses that you can use. If you are not
    sure which to choose, the website [https://choosealicense.com/](https://choosealicense.com/)
    is a useful resource that can help you. However, if you are at all in doubt about
    the legal implications, or need advice, you should consult a legal professional.
  prefs: []
  type: TYPE_NORMAL
- en: We are distributing our Railway CLI project under the MIT License. This is a
    simple license that allows anyone to use, distribute, or modify the code as long
    as they include our original copyright notice and license.
  prefs: []
  type: TYPE_NORMAL
- en: By convention, the license is included in a text file named `LICENSE` or `LICENSE.txt`
    , although some projects also use other names, such as `COPYING` .
  prefs: []
  type: TYPE_NORMAL
- en: README
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your project should also include a *README* file describing the project, why
    it exists, and even some basic usage instructions. The file can be in plain text
    format or use a markup syntax like **reStructuredText** or **Markdown** . The
    file is typically called `README` or `README.txt` if it is a plain text file,
    `README.rst` for reStructuredText, or `README.md` for Markdown.
  prefs: []
  type: TYPE_NORMAL
- en: Our `README.md` file contains a short paragraph describing the purpose of the
    project and some simple usage instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Markdown and reStructuredText are widely used markup languages that are designed
    to be easy to read or write in raw form but can also easily be converted to HTML
    to create simple web pages. You can read more about them at [https://daringfireball.net/projects/markdown/](https://daringfireball.net/projects/markdown/)
    and [https://docutils.sourceforge.io/rst.html](https://docutils.sourceforge.io/rst.html)
    .
  prefs: []
  type: TYPE_NORMAL
- en: pyproject.toml
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This file was introduced by PEP 518 ( [https://peps.python.org/pep-0518/](https://peps.python.org/pep-0518/)
    ) and extended by PEP 517 ( [https://peps.python.org/pep-0517/](https://peps.python.org/pep-0517/)
    ). The aim of these PEPs was to define standards to allow projects to specify
    their build dependencies and to specify what build tool should be used to build
    their packages. For a project using Setuptools, this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have specified that we require at least version 66.1.0 of Setuptools
    (this is the oldest version that is compatible with Python 3.12) and any release
    of the `wheel` project, which is the reference implementation of the wheel distribution
    format. Note that the `requires` field here does not list dependencies for running
    our code, only for building a distribution package. We will talk about how to
    specify dependencies for running our project later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `build-backend` field specifies the Python object that will be used to build
    packages. For Setuptools, this is the `build_meta` module in the `setuptools`
    (importable) package.
  prefs: []
  type: TYPE_NORMAL
- en: 'PEP 518 also allows you to put configurations for other development tools in
    the `pyproject.toml` file. Of course, the tools in question also need to support
    reading their configuration from this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have added configuration for *black* , a popular code formatting tool, and
    *isort* , a tool for sorting imports alphabetically, to our `pyproject.toml` file.
    We have configured both tools to use a line length of 66 characters to ensure
    our code will fit on a book page. We have also configured `isort` to maintain
    compatibility with `black` .
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about `black` and `isort` on their websites at [https://black.readthedocs.io/](https://black.readthedocs.io/)
    and [https://pycqa.github.io/isort](https://pycqa.github.io/isort) .
  prefs: []
  type: TYPE_NORMAL
- en: PEP 621 ( [https://peps.python.org/pep-0621/](https://peps.python.org/pep-0621/)
    ) introduced the ability to specify all project metadata in the `pyproject.toml`
    file. This has been supported in Setuptools since version 61.0.0. We will take
    a closer look at this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Package metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project metadata is defined in the `project` table in the `pyproject.toml`
    file. Let us go through it a few entries at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The table starts with the `[project]` heading. Our first two metadata entries
    consist of the `name` of our project and the list of authors with names and email
    addresses. We have used fake email addresses for this example project, but for
    a real project, you should use your real email address.
  prefs: []
  type: TYPE_NORMAL
- en: PyPI requires that all projects must have unique names. It is a good idea to
    check this when you start your project, to make sure that no other project has
    already used the name you want. It is also advisable to make sure your project
    name will not easily be confused with another; this will reduce the chances of
    anyone accidentally installing the wrong package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next entries in the `project` table are descriptions of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `description` field should be a short, single-sentence summary of the project,
    while `readme` should point to the README file containing a more detailed description.
  prefs: []
  type: TYPE_NORMAL
- en: The `readme` can also be specified as a TOML table, in which case it should
    contain a `content-type` key and either a `file` key with the path to the README
    file or a `text` key with the full README text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project’s license should also be specified in the metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `license` field is a TOML table containing either a `file` key with the
    path to the license file for the project, or a `text` key with the full text of
    the license.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next couple of metadata entries are meant to help potential users find
    our project on PyPI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `classifiers` field can be used to specify a list of *trove classifiers*
    , which are used to categorize projects on PyPI. The PyPI website allows users
    to filter by trove classifier when searching for projects. Your project’s classifiers
    must be chosen from the list of official classifiers at [https://pypi.org/classifiers/](https://pypi.org/classifiers/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: We have used classifiers to indicate that our project is meant to be used in
    a console environment, that it is released under the MIT License, that it works
    on macOS, Windows, and Linux, and that it is compatible with Python 3 (specifically
    versions 3.10, 3.11, and 3.12). Note that the classifiers are there purely to
    provide information to users and help them find your project on the PyPI website.
    They have no impact on which operating systems or Python versions your package
    can be installed on.
  prefs: []
  type: TYPE_NORMAL
- en: The `keywords` field can be used to provide additional keywords to help users
    find your project. Unlike the classifiers, there are no restrictions on what keywords
    you can use.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning and dynamic metadata
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The project metadata must contain a version number. Instead of specifying the
    version directly (via a `version` key), we have chosen to make the version a **dynamic
    field** . The `pyproject.toml` specification allows any project metadata except
    the `name` to be specified dynamically by other tools. The names of dynamic fields
    are specified via the `dynamic` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To use dynamic metadata with Setuptools, we need to use the `tool.setuptools.dynamic`
    table to specify how to compute the values. The `version` can either be read from
    a file (specified using a table with a `file` key) or from an attribute in a Python
    module (specified using a table with an `attr` key). For this project, we take
    the version from the `__version__` attribute of the `railway_cli` importable package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `__version__` attribute is defined in the `railway_cli/__init__.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using a dynamic field means that we can use the same version number in our code
    and project metadata without needing to define it twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can choose any versioning scheme that makes sense for your project, but
    it must comply with the rules defined in PEP 440 ( [https://peps.python.org/pep-0440/](https://peps.python.org/pep-0440/)
    ). A PEP 440-compatible version consists of a sequence of numbers, separated by
    dots, followed by optional pre-release, post-release, or developmental release
    indicators. A pre-release indicator can consist of the letter `a` (for *alpha*
    ), `b` (for *beta* ), or `rc` (for *release-candidate* ), followed by a number.
    A post-release indicator consists of the word `post` followed by a number. A developmental
    release indicator consists of the word `dev` followed by a number. A version number
    without a release indicator is referred to as a *final* release. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1.0.0.dev1` is the first developmental release of version 1.0.0 of our project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1.0.0.a1` is the first alpha release.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1.0.0.b1` is the first beta release.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1.0.0.rc1` is the first release candidate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1.0.0` is the final release of version 1.0.0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1.0.0.post1` is the first post-release.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developmental releases, pre-releases, final releases, and post-releases with
    the same main version number are ordered as in the list above.
  prefs: []
  type: TYPE_NORMAL
- en: Popular versioning schemes include **semantic versioning** , which aims to convey
    information about compatibility between releases through the versioning scheme,
    and **date-based versioning** , which typically uses the year and month of a release
    to indicate the version.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic versioning uses a version number consisting of three numbers, called
    the *major* , *minor* , and *patch* versions, separated by dots. This results
    in a version that looks like `major.minor.patch` . If a new release is completely
    compatible with its predecessor, only the patch number is incremented; usually,
    such a release only contains small bug fixes. For a release that adds new functionality
    without breaking compatibility with previous releases, the minor number should
    be incremented. The major number should be incremented if the release is incompatible
    with older versions. You can read all about semantic versioning at [https://semver.org/](https://semver.org/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Specifying dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we saw at the beginning of the chapter, a distribution package can provide
    a list of projects it depends on, and `pip` will ensure that releases of those
    projects are installed when it installs the package. These dependencies should
    be specified in the `dependencies` key of the `project` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Our project depends on the `pydantic` , `pydantic-settings` , and `requests`
    projects. The word `[email]` in square brackets for the `pydantic` dependency
    indicates that we also require some optional dependencies of the `pydantic` project
    related to dealing with email addresses. We will discuss optional dependencies
    in more detail in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: We can use **version specifiers** to indicate which releases of dependencies
    we require. Besides the normal Python comparison operators, version specifiers
    can also use `~=` to indicate a *compatible release* . The compatible release
    specifier is a way of indicating releases that may be expected to be compatible
    under a semantic versioning scheme. For example, `requests~=2.0` means that we
    require any 2.x version of the `requests` project, from 2.0 up to 3.0 (not included).
    A version specifier can also take a comma-separated list of version clauses that
    must all be satisfied. For example, `pydantic>=2.8.2,<3.0.0` means that we want
    at least version 2.8.2 of `pydantic` , but not version 3.0.0 or greater. Note
    that this is not the same as `pydantic~=2.8.2` , which would mean at least version
    2.8.2, but not version 2.9.0 or greater. For the full details of the dependency
    syntax and how versions are matched, please refer to PEP 508 ( [https://peps.python.org/pep-0508/](https://peps.python.org/pep-0508/)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: You should be careful not to make your dependency version specifiers too strict.
    Bear in mind that your package is likely to be installed alongside various other
    packages in the same virtual environment. This is particularly true of libraries
    or tools for developers. Allowing as much freedom as possible in the required
    versions of your dependencies means that projects that depend on yours are less
    likely to encounter dependency conflicts between your package and those of other
    projects they depend on. Making your version specifiers too restrictive also means
    that your users will not benefit from bug fixes or security patches in one of
    your dependencies unless you also publish a new release to update your version
    specifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from dependencies on other projects, you can also specify which versions
    of Python your project requires. In our project, we use features that were added
    in Python 3.10, so we specify that we require at least Python 3.10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As with `dependencies` , it is best to avoid limiting the Python versions you
    support too much. You should only restrict the Python version if you know your
    code will not work on all actively supported versions of Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a list of *Active Python Releases* on the official Python download
    page: [https://www.python.org/downloads/](https://www.python.org/downloads/) .'
  prefs: []
  type: TYPE_NORMAL
- en: You should make sure that your code really does work on all the versions of
    Python and the dependencies that you support in your setup configuration. One
    way of doing this is to create several virtual environments with different Python
    versions and different versions of your dependencies installed. Then, you can
    run your test suite in all these environments. Doing this manually would be very
    time-consuming. Fortunately, there are tools that will automate this process for
    you. The most popular of these tools is called *tox* . You can find out more about
    it at [https://tox.wiki/](https://tox.wiki/) .
  prefs: []
  type: TYPE_NORMAL
- en: You can also specify optional dependencies for your package. `pip` will only
    install such dependencies if a user specifically requests it. This is useful if
    some dependencies are only required for a feature that many users are not likely
    to need. Users who want the extra feature can then install the optional dependency
    and everyone else gets to save disk space and network bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the PyJWT project, which we used in *Chapter 9, Cryptography and
    Tokens* , depends on the cryptography project to sign JWTs using asymmetric keys.
    Many users of PyJWT do not use this feature, so the developers made cryptography
    an optional dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optional (or extra) dependencies are specified in the `project.optional-dependencies`
    table in the `pyproject.toml` file. This section can contain any number of named
    lists of optional dependencies. These lists are referred to as **extras** . In
    our project, we have one extra called `dev` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is a common convention for listing tools that are useful during the development
    of a project as optional dependencies. Many projects also have an extra `test`
    dependency for installing packages that are only needed to run the project’s test
    suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'To include optional dependencies when installing a package, you have to add
    the names of the extras you want in square brackets when you run `pip install`
    . For example, to do an editable install of our project with the `dev` dependencies
    included, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that we needed to use quotes in this `pip install` command to prevent the
    shell from interpreting the square brackets as a filename pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Project URLs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also include a list of URLs for websites related to your project in
    the `urls` sub-table of the `project` metadata table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The keys of the URLs table can be arbitrary strings describing the URLs. It
    is quite common for projects to include a link to their source code on a code-hosting
    service, such as GitHub or GitLab. Many projects also link to online documentation
    or bug trackers. We have used this field to add links to the source code repository
    for this book on GitHub and to information about the book on the publisher’s website.
  prefs: []
  type: TYPE_NORMAL
- en: Scripts and entry points
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we have been running our application by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not particularly user-friendly. It would be much better if we could
    run our application by just typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We can achieve this by configuring script **entry points** for our distribution.
    A script entry point is a function that we want to be able to execute as a command-line
    or GUI script. When our package is installed, `pip` will automatically generate
    scripts that import the specified functions and run them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We configure script entry points in the `project.scripts` table in the `pyproject.toml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Each key in this table defines the name of a script that should be generated
    when the package is installed. The corresponding value is an object reference
    pointing to the function that should be called when the script is executed. If
    we were packaging a GUI application, we would need to use the `project.gui-scripts`
    table instead.
  prefs: []
  type: TYPE_NORMAL
- en: The Windows operating system treats console and GUI applications differently.
    Console applications are launched in a console window and can print to the screen
    and read keyboard input through the console. GUI applications are launched without
    a console window. On other operating systems, there is no difference between `scripts`
    and `gui-scripts` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when we install the project in a virtual environment, `pip` will generate
    a `railway-cli` script in the virtual environment `bin` folder (or the `Scripts`
    folder on Windows). It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `#!/.../ch16/railway-project/venv/bin/python` comment at the top of the
    file is called a **shebang** (from hash + bang – bang is another name for an exclamation
    mark). It specifies the path to the Python executable that will be used to run
    the script. The script imports the `main()` function from the `railway_cli.main`
    module, performs some manipulation of the program name in `sys.argv[0]` , and
    then calls `main()` and passes the return value to `sys.exit()` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from script entry points, it is also possible to create arbitrary entry-point
    groups. Such groups are defined by sub-tables under the `project.entry-points`
    table. `pip` will not generate scripts for entry points in other groups, but they
    can be useful for other purposes. Specifically, many projects that support extending
    their functionality via plugins use particular entry point group names for plugin
    discovery. This is a more advanced subject that we won’t discuss in detail here,
    but if you are interested, you can read about it in the entry-points specification:
    [https://packaging.python.org/specifications/entry-points/](https://packaging.python.org/specifications/entry-points/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the package contents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For projects that use the src layout, Setuptools can usually automatically determine
    which Python modules to include in the distribution. For flat layouts, automatic
    discovery only works if there is only one importable package present in the project
    folder. If there are any other Python files present, you will need to configure
    the packages and modules to include or exclude via the `tools.setuptools` table
    in `pyproject.toml` .
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use an src layout, you only need additional configuration if you use
    a name other than `src` for the folder containing the code, or if there are some
    modules in the `src` folder that need to be excluded from the distribution. In
    our railway-cli project, we rely on automatic discovery, so we do not have any
    package discovery configuration in our `pyproject.toml` file. You can read more
    about Setuptools’s automatic discovery and how to customize it in the Setuptools
    user guide: [https://setuptools.pypa.io/en/latest/userguide/](https://setuptools.pypa.io/en/latest/userguide/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Our package metadata configuration is now complete. Before we move on to building
    and publishing a package, we will take a brief look at how we can access the metadata
    in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing metadata in your code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already seen how we can use dynamic metadata to share the version number
    between the distribution configuration and the code. For other dynamic metadata,
    Setuptools only supports loading from files, not from attributes in the code.
    Such files will not be included in the wheel distribution unless we add explicit
    configuration for this. There is, however, a more convenient way to access distribution
    metadata from the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `importlib.metadata` standard library module provides interfaces to access
    the distribution metadata of any installed package. To demonstrate this, we have
    added a command-line option for displaying the project license to the Railway
    CLI application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We use the `"version"` argument parser action to print the license string and
    exit if the `-L` or `--license` option is present on the command line. To get
    the license text, we first need to find the distribution corresponding to our
    importable package. The `packages_distributions()` function returns a dictionary
    whose keys are the names of importable packages in the virtual environment. The
    values are lists of distribution packages that provide the corresponding importable
    packages. We assume that no other installed distributions provide a package of
    the same name as ours, so we just take the first element of the `all_distributions[__package__]`
    list.
  prefs: []
  type: TYPE_NORMAL
- en: The `metadata` function returns a `dict` -like object with the metadata. The
    keys are similar to, but not quite the same as, the names of the `pyproject.toml`
    entries we use to define the metadata. Details of all the keys and their meanings
    can be found in the metadata specification at [https://packaging.python.org/specifications/core-metadata/](https://packaging.python.org/specifications/core-metadata/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Note that if our package is not installed, we will get a `KeyError` when we
    try to look it up in the dictionary returned by `packages_distributions()` . In
    this case, or in the case where there is no `"License"` specified in the project
    metadata, we return a default value to indicate that the license could not be
    found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see what the output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We have trimmed the output here to save space, but if you run it yourself, you
    should see the full license text printed out.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to proceed with building and publishing distribution packages.
  prefs: []
  type: TYPE_NORMAL
- en: Building and publishing packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the package builder provided by the *build* project ( [https://pypi.org/project/build/](https://pypi.org/project/build/)
    ) to build our distribution package. We will also need the *twine* ( [https://pypi.org/project/twine/](https://pypi.org/project/twine/)
    ) utility to upload our packages to PyPI. You can install these tools from the
    `requirements/build.txt` file provided with the source code of this chapter. We
    recommend installing these in a new virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: Because project names on PyPI must be unique, you will not be able to upload
    the `railway-cli` project without changing the name first. You should change the
    `name` in the `pyptoject.toml` file to something unique before building distribution
    packages. Bear in mind that this means that the filenames of your distribution
    packages will also be different from ours.
  prefs: []
  type: TYPE_NORMAL
- en: Building
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `build` project provides a simple script for building packages according
    to the PEP 517 specification. It will take care of all the details of building
    distribution packages for us. When we run it, `build` will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a virtual environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the build requirements listed in the `pyproject.toml` file in the virtual
    environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the build backend specified in the `pyproject.toml` file and run it to
    build a source distribution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another virtual environment and install the build requirements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the build backend and use it to build a wheel from the source distribution
    built in *step 3* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us see it in action. Enter the `railway-project` folder in the chapter’s
    source code, and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We have removed a lot of lines from the output to make it easier to see how
    it follows the steps we listed above. If you look at the content of your `railway-project`
    folder, you will notice there is a new folder called `dist` with two files: `railway_cli-0.0.1.tar.gz`
    is our source distribution, and `railway_cli-0.0.1-py3-none-any.whl` is the wheel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before uploading your package, it is advisable to do a couple of checks to
    make sure it is built correctly. First, we can use `twine` to verify that the
    `readme` will render correctly on the PyPI website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If `twine` reports any problems, you should fix them and rebuild the package.
    In our case, the checks passed, so let us install our wheel and make sure it works.
    In a separate virtual environment, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With the wheel installed in your virtual environment, try to run the application,
    preferably from outside the project directory. If you encounter any errors during
    installation or when running your code, check your configuration carefully for
    typos.
  prefs: []
  type: TYPE_NORMAL
- en: Our package seems to have been built successfully, so let us move on to publishing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since this is only an example project, we will upload it to TestPyPI instead
    of the real PyPI. This is a separate instance of the package index that was created
    specifically to allow developers to test package uploads and experiment with packaging
    tools and processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can upload packages, you will need to register an account. You can
    do this now, by going to the TestPyPI website at [https://test.pypi.org](https://test.pypi.org)
    and clicking on **Register** . Once you have completed the registration process
    and verified your email address, you will need to generate an API token. You can
    do so on the **Account Settings** page of the TestPyPI website. Make sure you
    copy the token and save it before closing the page. You should save your token
    to a file named `.pypirc` in your user home directory. The file should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `password` value should be replaced with your actual token.
  prefs: []
  type: TYPE_NORMAL
- en: We strongly recommend that you enable two-factor authentication for both your
    TestPyPI account and especially your real PyPI account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you are ready to run `twine` to upload your distribution packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`twine` displays progress bars to show how the uploads are progressing. Once
    the upload is complete, it prints out a URL where you can see details of your
    package. Open it in your browser, and you should see our project description with
    the contents of our `README.md` file. On the left of the page, you will see links
    for the project URLs, the author details, license information, keywords, and classifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B30992_16_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.1: Our project page on the TestPyPI website'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16.1* shows what this page looks like for our railway-cli project.
    You should check all the information on the page carefully and make sure it matches
    what you expect to see. If not, you will have to fix the metadata in your `pyproject.toml`
    , rebuild, and re-upload.'
  prefs: []
  type: TYPE_NORMAL
- en: PyPI will not let you re-upload distributions with the same filenames as previously
    uploaded packages. To fix your metadata, you will have to increment the version
    of your package. Using developmental release numbers until you are 100% sure everything
    is correct can help you avoid unnecessary version increments just to fix packaging
    mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can install our package from the TestPyPI repository. Run the following
    in a new virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `--index-url` option tells `pip` to use `https://test.pypi.org/simple/`
    as the main package index. We use `--extra-index-url https://pypi.org/simple/`
    to tell `pip` to also look up packages in standard PyPI so that dependencies that
    are not available in TestPyPI can be installed. The package was installed successfully,
    which confirms that our package was built and uploaded correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this were a real project, we would now proceed to upload to the real PyPI.
    The process is the same as for TestPyPI. When you save your PyPI API key, you
    should add it to your existing `.pypirc` file under the heading `[pypi]` , like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You also do not need to use the `--repository` option to upload your package
    to the real PyPI; you can just run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it is not difficult to package and publish a project, but there
    are quite a few details to take care of. The good news is that most of the work
    only needs to be done once: when you publish your first release. For subsequent
    releases, you usually just need to update the version and maybe adjust your dependencies.
    In the next section, we will give you some advice that should make the process
    easier.'
  prefs: []
  type: TYPE_NORMAL
- en: Advice for starting new projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It can be a tedious process to do all the preparation work for packaging in
    one go. It is also easy to make a mistake like forgetting to list a required dependency
    if you try to write all your package configurations just before publishing your
    package for the first time. It is much easier to start with a simple `pyproject.toml`
    , containing only the essential configuration and metadata. You can then add to
    your metadata and configuration as you work on your project. For example, every
    time you start using a new third-party project in your code, you can immediately
    add it to your `dependencies` list. It also helps to start writing your README
    file early on and then expanding it as you progress. You may even find that writing
    a paragraph or two describing your project helps you to think more clearly about
    what it is you are trying to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help you, we have created an initial skeleton for a new project. You can
    find it in the `skeleton-project` folder in this chapter’s source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Copy this, modify it as you wish, and use it as a starting point for your own
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: The cookiecutter project ( [https://cookiecutter.readthedocs.io](https://cookiecutter.readthedocs.io)
    ) allows you to create templates to use as starting points for projects. This
    can make the process of starting a new project much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Other files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The configuration files we showed you in this chapter are all you need to package
    and distribute most modern Python projects. There are, however, a few other files
    that you are likely to encounter if you look at other projects on PyPI:'
  prefs: []
  type: TYPE_NORMAL
- en: In early versions of Setuptools, every project needed to include a setup.py
    script, which was used to build the project. Most such scripts consisted only
    of a call to the `setuptools.setup()` function with project metadata specified
    as parameters. The use of `setup.py` has not been deprecated and this is still
    a valid method of configuring Setuptools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setuptools also supports reading its configuration from a `setup.cfg` file.
    Before the widespread adoption of `pyproject.toml` , this was the preferred way
    of configuring Setuptools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to include data files or other non-standard files in your distribution
    packages, you will need to use a `MANIFEST.in` file to specify the files to include.
    You can learn more about the use of this file at [https://packaging.python.org/guides/using-manifest-in/](https://packaging.python.org/guides/using-manifest-in/)
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternative tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we finish the chapter, let us briefly discuss some alternative options
    that you have for packaging your projects. Before PEP 517 and PEP 518, it was
    difficult to use anything other than Setuptools to build packages. There was no
    way for projects to specify what libraries were required to build them or how
    they should be built, so `pip` and other tools just assumed that packages should
    be built using Setuptools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to the build-system information in the `pyproject.toml` file, it is
    now easy to use any packaging library you want. There are several alternatives
    to choose from, including:'
  prefs: []
  type: TYPE_NORMAL
- en: The Flit project ( [https://flit.pypa.io](https://flit.pypa.io) ) was instrumental
    in inspiring the development of the PEP 517 and PEP 518 standards (the creator
    of Flit was a co-author of PEP 517). Flit aims to make packaging simple, pure
    Python projects that do not require complex build steps (like compiling C code)
    as easy as possible. Flit also provides a CLI for building packages and uploading
    them to PyPI (so you do not need the `build` tool or `twine` ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Poetry ( [https://python-poetry.org/](https://python-poetry.org/) ) also provides
    both a CLI for building and publishing packages and a lightweight PEP 517 build
    backend. Where Poetry really shines, though, is in its advanced dependency management
    features. Poetry can even manage virtual environments for you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hatch ( [https://hatch.pypa.io](https://hatch.pypa.io) ) is an extensible project
    manager tool for Python. It includes tools for installing and managing Python
    versions, managing virtual environments, running tests, and more. It also includes
    a PEP 517 build backend named hatchling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PDM ( [https://pdm-project.org/](https://pdm-project.org/) ) is another package
    and dependency manager that includes a build backend. Like Hatch, it can be used
    to manage virtual environments and install Python versions. There are also many
    plugins available to extend PDM’s functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enscons ( [https://dholth.github.io/enscons/](https://dholth.github.io/enscons/)
    ) is based on the SCons ( [https://scons.org/](https://scons.org/) ) general-purpose
    build system. This means that, unlike Flit or Poetry, enscons can be used to build
    distributions that include C language extensions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meson ( [https://mesonbuild.com/](https://mesonbuild.com/) ) is another popular
    general-purpose build system. The `meson-python` ( [https://mesonbuild.com/meson-python/](https://mesonbuild.com/meson-python/)
    )project provides a PEP 517 build backend that is built on top of Meson. This
    means that it can build distributions that include extension modules built with
    Meson.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maturin ( [https://www.maturin.rs/](https://www.maturin.rs/) ) is another build
    tool that can be used to build distributions with extension modules implemented
    in the Rust programming language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tools we have discussed in this chapter are all focused on distributing
    packages through PyPI. Depending on your target audience, this might not always
    be the best choice, though. PyPI exists mainly for distributing projects such
    as libraries and development tools for use by Python developers. Installing and
    using packages from PyPI also requires having a working Python installation and
    at least enough Python knowledge to know how to install packages with `pip` .
  prefs: []
  type: TYPE_NORMAL
- en: If your project is an application aimed at a less technically adept audience,
    you may want to consider other options. The Python Packaging User Guide has a
    useful overview of various options for distributing applications; it is available
    at [https://packaging.python.org/overview/#packaging-applications](https://packaging.python.org/overview/#packaging-applications)
    .
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of our packaging journey.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will finish this chapter with a few links to resources where you can read
    more about packaging:'
  prefs: []
  type: TYPE_NORMAL
- en: The Python Packaging Authority’s Packaging History page ( [https://www.pypa.io/en/latest/history/](https://www.pypa.io/en/latest/history/)
    ) is a useful resource for understanding the evolution of Python packaging.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python Packaging User Guide ( [https://packaging.python.org/](https://packaging.python.org/)
    ) has useful tutorials and guides, as well as a packaging glossary, links to packaging
    specifications, and a summary of various interesting projects related to packaging.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Setuptools documentation ( [https://setuptools.readthedocs.io/](https://setuptools.readthedocs.io/)
    ) contains a lot of useful information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are distributing a library that uses type hinting, you may want to distribute
    type information so that developers who depend on your library can run type checks
    against their code. The Python typing documentation includes some useful information
    on distributing type information: [https://typing.readthedocs.io/en/latest/spec/distributing.html](https://typing.readthedocs.io/en/latest/spec/distributing.html)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to access distribution metadata in your code.
    Most packaging tools also allow you to include data files in your distribution
    packages. The standard library `importlib.resources` module provides access to
    these **package resources** . You can read about it at [https://docs.python.org/3/library/importlib.resources.html](https://docs.python.org/3/library/importlib.resources.html)
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you read about these (and other packaging resources), it is worth bearing
    in mind that although PEP 517, PEP 518, and PEP 621 were finalized a few years
    ago, many projects have not fully migrated to using PEP 517 builds, or configuring
    project metadata in `pyproject.toml` files. Much of the available documentation
    also still refers to older ways of doing things.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to package and distribute Python projects
    through PyPI. We started with some theory about packaging and introduced the concepts
    of projects, releases, and distributions on PyPI.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about Setuptools, the most widely used packaging library for Python,
    and worked through the process of preparing a project for packaging with Setuptools.
    In the process, we saw various files that need to be added to a project to package
    it and what each of them is for.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the metadata that you should provide to describe your project and
    help users find it on PyPI, as well as how to add code to the distribution, how
    to specify our dependencies, and how to define entry points so that `pip` will
    automatically generate scripts for us. We also looked at the tools that Python
    provides for accessing the distribution metadata.
  prefs: []
  type: TYPE_NORMAL
- en: We moved on to talking about how to build distribution packages and how to use
    `twine` to upload those packages to PyPI. We also gave you some advice on starting
    new projects. We concluded our tour of packaging by briefly talking about some
    alternatives to Setuptools and pointing you to some resources where you can learn
    more about packaging.
  prefs: []
  type: TYPE_NORMAL
- en: We really do encourage you to start distributing your code on PyPI. No matter
    how trivial you think it might be, someone else somewhere in the world will probably
    find it useful. It really does feel good to contribute and give back to the community,
    and besides, it looks good on your CV.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will introduce you to the world of competitive programming.
    We are going to deviate a little bit from professional programming to learn a
    few things about programming challenges and why they can be so much fun, and useful,
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_16.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/QR_Code119001106417026468.png)'
  prefs: []
  type: TYPE_IMG
