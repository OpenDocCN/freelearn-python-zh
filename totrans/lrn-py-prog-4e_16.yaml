- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Packaging Python Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包Python应用程序
- en: ”Do you have any cheese at all?” “No.”
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “你总共有任何奶酪吗？”“没有。”
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Monty Python, the “Cheese Shop” sketch
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: – 蒙提·派森，"奶酪店"草图
- en: In this chapter, we are going to learn how to create an installable package
    for a Python project and publish it for others to use.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何为Python项目创建一个可安装的包，并将其发布供他人使用。
- en: There are many reasons why you should publish your code. In *Chapter 1, A Gentle
    Introduction to Python* , we said that one of the benefits of Python is the vast
    ecosystem of third-party packages that you can install for free using `pip` .
    Most of these were created by developers just like you and, by contributing with
    your own projects, you will be helping to ensure that the community keeps thriving.
    In the long term, it will also help to improve your code, since exposing it to
    more users means bugs might be discovered sooner. Finally, if you are trying to
    get a job as a software developer, it really helps to be able to point to projects
    that you have worked on.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多原因说明你应该发布你的代码。在*第一章，Python的温和介绍*中，我们提到Python的一个好处是拥有庞大的第三方包生态系统，你可以使用`pip`免费安装这些包。其中大部分都是由像你一样的开发者创建的，通过贡献你自己的项目，你将帮助确保社区持续繁荣。从长远来看，这也有助于改进你的代码，因为将其暴露给更多用户意味着错误可能会更快被发现。最后，如果你试图成为一名软件开发人员，能够指向你参与过的项目将非常有帮助。
- en: The best way to learn about packaging is to go through the process of creating
    a package and publishing it. That is what we are going to do in this chapter.
    The project that we will be working with is the Railway **command-line interface**
    ( **CLI** ) application we developed in *Chapter 15, CLI Applications* .
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 了解打包的最佳方式是通过创建包并发布的过程。这正是本章我们将要做的。我们将要工作的项目是在*第15章，CLI应用程序*中开发的铁路**命令行界面**（**CLI**）应用程序。
- en: 'In this chapter, we are going to learn about the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: How to create a distribution package for your project
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为你的项目创建一个发行版包
- en: How to publish your package
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何发布你的包
- en: The different tools for packaging
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包的不同工具
- en: Before we start packaging and publishing our project, we will give you a brief
    introduction to the **Python Package Index** ( **PyPI** ) and some important terminology
    around Python packaging.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始打包和发布我们的项目之前，我们将简要介绍**Python包索引**（**PyPI**）以及Python打包的一些重要术语。
- en: The Python Package Index
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python包索引
- en: '**PyPI** is an online repository of Python packages, hosted at [https://pypi.org](https://pypi.org)
    . It has a web interface that can be used to browse or search for packages and
    view their details. It also has APIs for tools like `pip` to find and download
    packages to install. PyPI is open for anybody to register and distribute their
    projects for free. Anybody can also install any package from PyPI for free.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**PyPI**是一个在线的Python包仓库，托管在[https://pypi.org](https://pypi.org) 。它有一个网页界面，可以用来浏览或搜索包，并查看它们的详细信息。它还提供了API，如`pip`，用于查找和下载安装包。PyPI对任何人开放，可以免费注册并免费分发他们的项目。任何人也可以免费从PyPI安装任何包。'
- en: The repository is organized into **projects** , **releases** , and **distribution
    packages** . A project is a library, script, or application with its associated
    data or resources. For example, *FastAPI* , *Requests* , *pandas* , *SQLAlchemy*
    , and our Railway CLI application are all projects. `pip` itself is a project
    as well. A release is a particular version (or snapshot in time) of a project.
    Releases are identified by version numbers. For example, `pip` *24.2* is a release
    of the `pip` project. Releases are distributed in the form of distribution packages.
    These are archive files, tagged with the release version, which contain the Python
    modules, data files, and so on, that make up the release. Distribution packages
    also contain metadata about the project and release, such as the name of the project,
    the authors, the release version, and dependencies that also need to be installed.
    Distribution packages are also referred to as **distributions** or just **packages**
    .
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库被组织成**项目**、**发布**和**发行包**。一个项目是一个带有其相关数据或资源的库、脚本或应用程序。例如，*FastAPI*、*Requests*、*pandas*、*SQLAlchemy*以及我们的Railway
    CLI应用程序都是项目。`pip`本身也是一个项目。发布是项目的特定版本（或时间点的快照）。发布通过版本号来标识。例如，`pip`的*24.2*版本是`pip`项目的发布。发布以发行包的形式分发。这些是带有发布版本的归档文件，包含构成发布的Python模块、数据文件等。发行包还包含有关项目和发布的项目元数据，例如项目名称、作者、发布版本以及需要安装的依赖项。发行包也被称为**distributions**或简称为**packages**。
- en: In Python, the word **package** is also used to refer to an importable module
    that can contain other modules, usually in the form of a folder containing a `__init__.py`
    file. It is important not to confuse this type of importable package with a distribution
    package. In this chapter, we will mostly use the term package to refer to a distribution
    package. Where there is ambiguity, we will use the terms **importable package**
    or **distribution package** .
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，单词**package**也用来指代一个可导入的模块，它可以包含其他模块，通常是以包含一个`__init__.py`文件的文件夹形式存在。重要的是不要将这种可导入的包与发行包混淆。在本章中，我们将主要使用术语**package**来指代发行包。在存在歧义的情况下，我们将使用术语**importable
    package**或**distribution package**。
- en: Distribution packages can be either **source distributions** (also known as
    **sdists** ), which require a build step before they can be installed, or **built
    distributions** , which only require the archive contents to be moved to the correct
    locations during installation. The current format of source distributions was
    originally defined by PEP 517. The formal specification can be found at [https://packaging.python.org/specifications/source-distribution-format/](https://packaging.python.org/specifications/source-distribution-format/)
    . The standard built distribution format is called a **wheel** and was originally
    defined in PEP 427. The current version of the wheel specification can be found
    at [https://packaging.python.org/specifications/binary-distribution-format/](https://packaging.python.org/specifications/binary-distribution-format/)
    . The wheel format replaced the (now deprecated) **egg** built distribution format.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 发行包可以是**源发行包**（也称为**sdists**），在安装之前需要构建步骤，或者**构建发行包**，在安装过程中只需将归档内容移动到正确的位置。源发行包的当前格式最初由PEP
    517定义。正式规范可以在[https://packaging.python.org/specifications/source-distribution-format/](https://packaging.python.org/specifications/source-distribution-format/)找到。标准的构建发行包格式称为**wheel**，最初在PEP
    427中定义。当前版本的wheel规范可以在[https://packaging.python.org/specifications/binary-distribution-format/](https://packaging.python.org/specifications/binary-distribution-format/)找到。wheel格式取代了（现在已弃用的）**egg**构建发行包格式。
- en: PyPI was initially nicknamed the Cheese Shop, after the famous Monty Python
    sketch that we quoted at the beginning of the chapter. Thus, the wheel distribution
    format is not named after the wheels of a car, but after wheels of cheese.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: PyPI最初被昵称为Cheese Shop，这个名字来源于我们本章开头引用的著名蒙提·派森素描。因此，轮分布格式并不是以汽车轮子命名，而是以奶酪轮子命名。
- en: 'To help understand all of this, let us go through a quick example of what happens
    when we run `pip install` . We will use `pip` to install release *2.32.3* of the
    *requests* project. To allow us to see exactly what `pip` is doing, we will use
    the `-v` command line option three times, to make the output as verbose as possible.
    We will also add the `--no-cache` command-line option to force `pip` to download
    packages from PyPI and not use any locally cached packages it might have. The
    output looks something like this (note that we have trimmed the output to fit
    on the page and omitted several lines; you can find the complete output in the
    source code for this chapter in the file `pip_install.txt` ):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助理解所有这些，让我们快速通过一个例子来看看运行`pip install`时会发生什么。我们将使用`pip`安装`requests`项目的发布版*2.32.3*。为了让我们看到`pip`正在做什么，我们将使用三次`-v`命令行选项，以使输出尽可能详细。我们还将添加`--no-cache`命令行选项，强制`pip`从PyPI下载包，而不是使用任何可能本地缓存的包。输出看起来像这样（请注意，我们已经将输出裁剪以适应页面，并省略了多行；你可以在本章源代码文件`pip_install.txt`中找到完整的输出）：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`Pip` tells us that it has found information about the `requests` project at
    [https://pypi.org/simple/requests/](https://pypi.org/simple/requests/) . The output
    continues with a list of all the available distributions of the `requests` project:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pip`告诉我们，它已经在[https://pypi.org/simple/requests/](https://pypi.org/simple/requests/)找到了关于`requests`项目的信息。输出接着列出了`requests`项目的所有可用发行版：'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, `pip` collects the distribution for the release we requested. It downloads
    the metadata for the wheel distribution:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`pip`收集我们请求的发布版的发行版。它下载wheel发行版的元数据：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, `pip` extracts the list of dependencies from the package metadata and
    proceeds to find and collect their metadata in the same way. Once all the required
    packages have been found, they can be downloaded and installed:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`pip`从包元数据中提取依赖项列表，并继续以相同的方式查找和收集它们的元数据。一旦找到所有必需的包，就可以下载并安装：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If `pip` had downloaded a source distribution for any of the packages (which
    might happen if no suitable wheel is available), it would have needed to build
    the package before installing it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`pip`为任何包下载了源发行版（如果没有合适的wheel可用，可能会发生这种情况），在安装之前需要构建该包。
- en: Now that we know the difference between a project, a release, and a package,
    we can start working on preparing a release and building distribution packages
    for the Railway CLI application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了项目、发布版和包之间的区别，我们可以开始准备发布版，并为铁路CLI应用程序构建发行版包。
- en: Packaging with Setuptools
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Setuptools进行打包
- en: We will be using the **Setuptools** library to package our project. Setuptools
    is the oldest actively developed packaging tool for Python, and still the most
    popular. It is an extension of the original, standard library `distutils` packaging
    system. The `distutils` module was deprecated in Python 3.10 and removed from
    the standard library in Python 3.12.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**Setuptools**库来打包我们的项目。Setuptools是Python最古老的活跃开发打包工具，并且仍然是最受欢迎的。它是原始标准库`distutils`打包系统的扩展。`distutils`模块在Python
    3.10中被弃用，并在Python 3.12中从标准库中移除。
- en: In this section, we will be looking at how to set up our project to build packages
    with Setuptools.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何设置我们的项目以使用Setuptools构建包。
- en: Project layout
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目布局
- en: 'There are two popular conventions for laying out files in a Python project:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python项目中布局文件有两种流行的约定：
- en: In the **src layout,** the importable packages that need to be distributed are
    placed in a folder named `src` within the main project folder.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**src布局**中，需要分发的可导入包放置在主项目文件夹内的`src`文件夹中。
- en: In the **flat layout,** the importable packages are placed directly in the top-level
    project folder.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**扁平布局**中，可导入的包直接放置在顶层项目文件夹中。
- en: The src layout has the advantage of being explicit about which files will be
    included in the distribution. This reduces the likelihood of accidentally including
    other files, such as scripts that are only meant for use during development. The
    src layout can, however, be less convenient during development as it is not possible
    to import the package from a script or Python console running in the top-level
    project folder without first installing the distribution in a virtual environment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`src`布局的优势在于明确指出哪些文件将被包含在发行版中。这减少了意外包含其他文件的可能性，例如仅用于开发期间使用的脚本。然而，`src`布局在开发期间可能不太方便，因为在不首先在虚拟环境中安装发行版的情况下，无法从顶层项目文件夹中的脚本或Python控制台导入包。'
- en: Proponents of the src layout argue that being forced to install the distribution
    package during development is actually a benefit, as it increases the likelihood
    that mistakes in creating the distribution package will be discovered during development.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 `src` 布局的倡导者认为，在开发过程中被迫安装发行版包实际上是一种好处，因为它增加了在开发过程中发现创建发行版包错误的可能性。
- en: 'For this project, we have chosen to use the src layout:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们选择使用 `src` 布局：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `src/railway_cli` folder contains the code for the `railway_cli` importable
    package. We also added some tests, as an example for you to expand on, in the
    `test` folder. The `.flake8` file contains configuration for `flake8` , a Python
    code style checker that can help to point out PEP 8 violations in our code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/railway_cli` 文件夹包含了 `railway_cli` 可导入包的代码。我们还在 `test` 文件夹中添加了一些测试，作为您扩展的示例。`.flake8`
    文件包含了 `flake8` 的配置，`flake8` 是一个Python代码风格检查器，可以帮助指出我们代码中的PEP 8违规。'
- en: We will describe each of the remaining files in more detail below. Before that,
    though, let us look at how to install the project in a virtual environment during
    development.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下面更详细地描述剩余的每个文件。在此之前，让我们看看如何在开发过程中在虚拟环境中安装项目。
- en: Development installation
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发安装
- en: The most common approach to working with an src layout is to use a **development
    installation** , also known as **development mode** , or an **editable installation**
    . This will build and install a wheel for the project. However, instead of copying
    the code into the virtual environment, it will add a link in the virtual environment
    to the source code in your project folder. This allows you to import and run the
    code as if it is installed, but any changes you make to the code will take effect
    without needing to rebuild and reinstall.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `src` 布局一起工作的最常见方法是使用 **开发安装**，也称为 **开发模式**，或 **可编辑安装**。这将构建并安装项目的wheel。然而，它不会将代码复制到虚拟环境中，而是在虚拟环境中添加一个指向项目文件夹中源代码的链接。这允许您像安装一样导入和运行代码，但您对代码所做的任何更改都将生效，而无需重新构建和重新安装。
- en: 'Let us try this now. Open a console, go to the source code folder for this
    chapter, create a new virtual environment, activate it, and run the following
    command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在尝试一下。打开一个控制台，转到本章的源代码文件夹，创建一个新的虚拟环境，激活它，并运行以下命令：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As the output shows, when we run `pip install` with the `-e` (or `--editable`
    ) option and give it the path to a project folder, it builds an editable wheel
    and installs it in the virtual environment.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，当我们使用 `-e`（或 `--editable`）选项运行 `pip install` 并给它项目文件夹的路径时，它会构建一个可编辑的wheel并将其安装在虚拟环境中。
- en: 'Now, if you run:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您运行：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It should work as it did in the previous chapter. You can verify that we really
    have an editable installation by changing something in the code (for example,
    add a `print()` statement) and running it again.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该像上一章中那样工作。您可以通过在代码中更改某些内容（例如，添加一个 `print()` 语句）并再次运行来验证我们确实有一个可编辑的安装。
- en: Now that we have a working editable installation of the project, let us discuss
    each of the files in the project folder in more detail.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个可工作的可编辑项目安装，让我们更详细地讨论项目文件夹中的每个文件。
- en: Changelog
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新日志
- en: Although it is not required, it is considered good practice to include a change
    log file with your project. This file summarizes the changes made in each release
    of your project. The change log is useful for informing your users of new features
    that are available or of changes in the behavior of your software that they need
    to be aware of.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是必需的，但包含一个变更日志文件与您的项目一起被认为是良好的实践。此文件总结了项目每个版本中进行的更改。变更日志对于通知您的用户新功能或他们需要了解的软件行为变化非常有用。
- en: Our changelog file is named `CHANGELOG.md` and is written in **Markdown** format.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的更新日志文件名为 `CHANGELOG.md`，并使用 **Markdown** 格式编写。
- en: License
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 许可证
- en: You should include a license that defines the terms under which your code is
    distributed. There are many software licenses that you can use. If you are not
    sure which to choose, the website [https://choosealicense.com/](https://choosealicense.com/)
    is a useful resource that can help you. However, if you are at all in doubt about
    the legal implications, or need advice, you should consult a legal professional.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该包含一个定义您的代码分发条款的许可证。有许多软件许可证可供选择。如果您不确定选择哪个，[https://choosealicense.com/](https://choosealicense.com/)
    网站是一个有用的资源，可以帮助您。然而，如果您对法律后果有任何疑问，或需要建议，您应该咨询法律专业人士。
- en: We are distributing our Railway CLI project under the MIT License. This is a
    simple license that allows anyone to use, distribute, or modify the code as long
    as they include our original copyright notice and license.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在MIT许可证下分发我们的铁路CLI项目。这是一个简单的许可证，允许任何人使用、分发或修改代码，只要他们包含我们的原始版权声明和许可证。
- en: By convention, the license is included in a text file named `LICENSE` or `LICENSE.txt`
    , although some projects also use other names, such as `COPYING` .
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，许可证包含在一个名为`LICENSE`或`LICENSE.txt`的文本文件中，尽管一些项目也使用其他名称，例如`COPYING`。
- en: README
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: README
- en: Your project should also include a *README* file describing the project, why
    it exists, and even some basic usage instructions. The file can be in plain text
    format or use a markup syntax like **reStructuredText** or **Markdown** . The
    file is typically called `README` or `README.txt` if it is a plain text file,
    `README.rst` for reStructuredText, or `README.md` for Markdown.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目还应包含一个*README*文件，描述项目内容、项目存在的原因以及一些基本的使用说明。该文件可以是纯文本格式，也可以使用如**reStructuredText**或**Markdown**这样的标记语法。如果是一个纯文本文件，通常命名为`README`或`README.txt`，如果是reStructuredText，则命名为`README.rst`，如果是Markdown，则命名为`README.md`。
- en: Our `README.md` file contains a short paragraph describing the purpose of the
    project and some simple usage instructions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`README.md`文件包含一个简短的段落，描述了项目的目的和一些简单的使用说明。
- en: Markdown and reStructuredText are widely used markup languages that are designed
    to be easy to read or write in raw form but can also easily be converted to HTML
    to create simple web pages. You can read more about them at [https://daringfireball.net/projects/markdown/](https://daringfireball.net/projects/markdown/)
    and [https://docutils.sourceforge.io/rst.html](https://docutils.sourceforge.io/rst.html)
    .
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Markdown和reStructuredText是广泛使用的标记语言，旨在易于以原始形式阅读或编写，但也可以轻松转换为HTML以创建简单的网页。您可以在[https://daringfireball.net/projects/markdown/](https://daringfireball.net/projects/markdown/)和[https://docutils.sourceforge.io/rst.html](https://docutils.sourceforge.io/rst.html)上了解更多关于它们的信息。
- en: pyproject.toml
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pyproject.toml
- en: 'This file was introduced by PEP 518 ( [https://peps.python.org/pep-0518/](https://peps.python.org/pep-0518/)
    ) and extended by PEP 517 ( [https://peps.python.org/pep-0517/](https://peps.python.org/pep-0517/)
    ). The aim of these PEPs was to define standards to allow projects to specify
    their build dependencies and to specify what build tool should be used to build
    their packages. For a project using Setuptools, this looks like:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件由PEP 518（[https://peps.python.org/pep-0518/](https://peps.python.org/pep-0518/)）引入并由PEP
    517（[https://peps.python.org/pep-0517/](https://peps.python.org/pep-0517/)）扩展。这些PEP的目标是定义标准，以便项目可以指定它们的构建依赖项以及用于构建它们的包的构建工具。对于使用Setuptools的项目，这看起来是这样的：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we have specified that we require at least version 66.1.0 of Setuptools
    (this is the oldest version that is compatible with Python 3.12) and any release
    of the `wheel` project, which is the reference implementation of the wheel distribution
    format. Note that the `requires` field here does not list dependencies for running
    our code, only for building a distribution package. We will talk about how to
    specify dependencies for running our project later in this chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定了至少需要Setuptools的66.1.0版本（这是与Python 3.12兼容的最旧版本）以及`wheel`项目的任何版本，`wheel`项目是轮分布格式的参考实现。请注意，这里的`requires`字段不列出运行我们的代码的依赖项，只列出构建分发包的依赖项。我们将在本章后面讨论如何指定运行我们的项目的依赖项。
- en: The `build-backend` field specifies the Python object that will be used to build
    packages. For Setuptools, this is the `build_meta` module in the `setuptools`
    (importable) package.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`build-backend`字段指定了将用于构建包的Python对象。对于Setuptools，这是`setuptools`（可导入）包中的`build_meta`模块。'
- en: 'PEP 518 also allows you to put configurations for other development tools in
    the `pyproject.toml` file. Of course, the tools in question also need to support
    reading their configuration from this file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 518还允许您在`pyproject.toml`文件中放置其他开发工具的配置。当然，相关的工具也需要支持从该文件中读取它们的配置：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have added configuration for *black* , a popular code formatting tool, and
    *isort* , a tool for sorting imports alphabetically, to our `pyproject.toml` file.
    We have configured both tools to use a line length of 66 characters to ensure
    our code will fit on a book page. We have also configured `isort` to maintain
    compatibility with `black` .
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的`pyproject.toml`文件中添加了*black*（一个流行的代码格式化工具）和*isort*（一个按字母顺序排序导入的工具）的配置。我们已将这两个工具配置为使用66个字符的行长度，以确保我们的代码可以适应书页。我们还配置了`isort`以与`black`保持兼容。
- en: You can learn more about `black` and `isort` on their websites at [https://black.readthedocs.io/](https://black.readthedocs.io/)
    and [https://pycqa.github.io/isort](https://pycqa.github.io/isort) .
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在它们的网站上了解更多关于 `black` 和 `isort` 的信息：[https://black.readthedocs.io/](https://black.readthedocs.io/)
    和 [https://pycqa.github.io/isort](https://pycqa.github.io/isort) 。
- en: PEP 621 ( [https://peps.python.org/pep-0621/](https://peps.python.org/pep-0621/)
    ) introduced the ability to specify all project metadata in the `pyproject.toml`
    file. This has been supported in Setuptools since version 61.0.0. We will take
    a closer look at this in the next section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 621 ([https://peps.python.org/pep-0621/](https://peps.python.org/pep-0621/))
    引入了在 `pyproject.toml` 文件中指定所有项目元数据的能力。这自 Setuptools 61.0.0 版本以来一直得到支持。我们将在下一节中详细探讨这一点。
- en: Package metadata
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包元数据
- en: 'The project metadata is defined in the `project` table in the `pyproject.toml`
    file. Let us go through it a few entries at a time:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 项目元数据定义在 `pyproject.toml` 文件中的 `project` 表格中。让我们一次查看几个条目：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The table starts with the `[project]` heading. Our first two metadata entries
    consist of the `name` of our project and the list of authors with names and email
    addresses. We have used fake email addresses for this example project, but for
    a real project, you should use your real email address.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 表格从 `[项目]` 标题开始。我们的前两个元数据条目包括我们项目的 `名称` 和作者名单，包括姓名和电子邮件地址。在这个示例项目中，我们使用了假电子邮件地址，但在实际项目中，你应该使用你的真实电子邮件地址。
- en: PyPI requires that all projects must have unique names. It is a good idea to
    check this when you start your project, to make sure that no other project has
    already used the name you want. It is also advisable to make sure your project
    name will not easily be confused with another; this will reduce the chances of
    anyone accidentally installing the wrong package.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: PyPI 要求所有项目都必须有唯一的名称。在你开始项目时检查这一点是个好主意，以确保没有其他项目已经使用了你想要的名称。还建议确保你的项目名称不会轻易与其他项目混淆；这将减少任何人意外安装错误包的可能性。
- en: 'The next entries in the `project` table are descriptions of our project:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`项目` 表格中的下一个条目是我们项目的描述：'
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `description` field should be a short, single-sentence summary of the project,
    while `readme` should point to the README file containing a more detailed description.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`description` 字段应该是项目的简短、单句总结，而 `readme` 应该指向包含更详细描述的 README 文件。'
- en: The `readme` can also be specified as a TOML table, in which case it should
    contain a `content-type` key and either a `file` key with the path to the README
    file or a `text` key with the full README text.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`readme` 也可以指定为 TOML 表格，在这种情况下，它应该包含一个 `content-type` 键，以及一个带有 README 文件路径的
    `file` 键或一个带有完整 README 文本的 `text` 键。'
- en: 'The project’s license should also be specified in the metadata:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 项目许可证也应指定在元数据中：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `license` field is a TOML table containing either a `file` key with the
    path to the license file for the project, or a `text` key with the full text of
    the license.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`license` 字段是一个 TOML 表格，包含一个带有项目许可证文件路径的 `file` 键，或者一个带有许可证全文的 `text` 键。'
- en: 'The next couple of metadata entries are meant to help potential users find
    our project on PyPI:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下几个元数据条目旨在帮助潜在用户在 PyPI 上找到我们的项目：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `classifiers` field can be used to specify a list of *trove classifiers*
    , which are used to categorize projects on PyPI. The PyPI website allows users
    to filter by trove classifier when searching for projects. Your project’s classifiers
    must be chosen from the list of official classifiers at [https://pypi.org/classifiers/](https://pypi.org/classifiers/)
    .
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`classifiers` 字段可以用来指定一个 *trove 分类器* 列表，这些分类器用于在 PyPI 上对项目进行分类。PyPI 网站允许用户在搜索项目时通过
    trove 分类器进行筛选。你的项目分类器必须从 [https://pypi.org/classifiers/](https://pypi.org/classifiers/)
    上的官方分类器列表中选择。'
- en: We have used classifiers to indicate that our project is meant to be used in
    a console environment, that it is released under the MIT License, that it works
    on macOS, Windows, and Linux, and that it is compatible with Python 3 (specifically
    versions 3.10, 3.11, and 3.12). Note that the classifiers are there purely to
    provide information to users and help them find your project on the PyPI website.
    They have no impact on which operating systems or Python versions your package
    can be installed on.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了分类器来表明我们的项目旨在在控制台环境中使用，它是在 MIT 许可证下发布的，它可以在 macOS、Windows 和 Linux 上运行，并且与
    Python 3 兼容（具体为 3.10、3.11 和 3.12 版本）。请注意，分类器纯粹是为了向用户提供信息并帮助他们找到 PyPI 网站上的项目。它们对您的软件包可以安装的操作系统或
    Python 版本没有影响。
- en: The `keywords` field can be used to provide additional keywords to help users
    find your project. Unlike the classifiers, there are no restrictions on what keywords
    you can use.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`keywords`字段可以用来提供额外的关键词，以帮助用户找到您的项目。与分类器不同，对您可以使用的关键词没有限制。'
- en: Versioning and dynamic metadata
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 版本控制和动态元数据
- en: 'The project metadata must contain a version number. Instead of specifying the
    version directly (via a `version` key), we have chosen to make the version a **dynamic
    field** . The `pyproject.toml` specification allows any project metadata except
    the `name` to be specified dynamically by other tools. The names of dynamic fields
    are specified via the `dynamic` key:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 项目元数据必须包含一个版本号。我们选择将版本作为一个**动态字段**来指定，而不是直接指定版本（通过`version`键）。`pyproject.toml`规范允许指定除`name`之外的所有项目元数据，由其他工具动态指定。动态字段的名称通过`dynamic`键指定：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To use dynamic metadata with Setuptools, we need to use the `tool.setuptools.dynamic`
    table to specify how to compute the values. The `version` can either be read from
    a file (specified using a table with a `file` key) or from an attribute in a Python
    module (specified using a table with an `attr` key). For this project, we take
    the version from the `__version__` attribute of the `railway_cli` importable package:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用与Setuptools兼容的动态元数据，我们需要使用`tool.setuptools.dynamic`表来指定如何计算值。`version`可以从文件中读取（使用带有`file`键的表指定）或从Python模块中的属性中读取（使用带有`attr`键的表指定）。对于本项目，我们从`railway_cli`可导入包的`__version__`属性中获取版本：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `__version__` attribute is defined in the `railway_cli/__init__.py` file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`__version__`属性在`railway_cli/__init__.py`文件中定义：'
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using a dynamic field means that we can use the same version number in our code
    and project metadata without needing to define it twice.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动态字段意味着我们可以在代码和项目元数据中使用相同的版本号，而无需定义两次。
- en: 'You can choose any versioning scheme that makes sense for your project, but
    it must comply with the rules defined in PEP 440 ( [https://peps.python.org/pep-0440/](https://peps.python.org/pep-0440/)
    ). A PEP 440-compatible version consists of a sequence of numbers, separated by
    dots, followed by optional pre-release, post-release, or developmental release
    indicators. A pre-release indicator can consist of the letter `a` (for *alpha*
    ), `b` (for *beta* ), or `rc` (for *release-candidate* ), followed by a number.
    A post-release indicator consists of the word `post` followed by a number. A developmental
    release indicator consists of the word `dev` followed by a number. A version number
    without a release indicator is referred to as a *final* release. For example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择适合您项目的任何版本控制方案，但它必须遵守PEP 440（[https://peps.python.org/pep-0440/](https://peps.python.org/pep-0440/)）中定义的规则。一个PEP
    440兼容的版本由一系列由点分隔的数字组成，后面可以跟有可选的预发布、发布后或开发版本指示符。预发布指示符可以由字母`a`（表示*alpha*）、`b`（表示*beta*）或`rc`（表示*release-candidate*）后跟一个数字组成。发布后指示符由单词`post`后跟一个数字组成。开发版本指示符由单词`dev`后跟一个数字组成。没有发布指示符的版本号被称为*final*发布。例如：
- en: '`1.0.0.dev1` is the first developmental release of version 1.0.0 of our project.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.0.0.dev1` 是我们项目1.0.0版本的第一个开发版本。'
- en: '`1.0.0.a1` is the first alpha release.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.0.0.a1` 是第一个alpha版本。'
- en: '`1.0.0.b1` is the first beta release.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.0.0.b1` 是第一个beta版本。'
- en: '`1.0.0.rc1` is the first release candidate.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.0.0.rc1` 是第一个发布候选版本。'
- en: '`1.0.0` is the final release of version 1.0.0.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.0.0` 是1.0.0版本的最终发布版本。'
- en: '`1.0.0.post1` is the first post-release.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.0.0.post1` 是第一个发布后版本。'
- en: Developmental releases, pre-releases, final releases, and post-releases with
    the same main version number are ordered as in the list above.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 开发版本、预发布版本、最终发布版本和发布后版本，如果主版本号相同，它们的顺序如上列表所示。
- en: Popular versioning schemes include **semantic versioning** , which aims to convey
    information about compatibility between releases through the versioning scheme,
    and **date-based versioning** , which typically uses the year and month of a release
    to indicate the version.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的版本控制方案包括**语义版本控制**，该方案旨在通过版本控制方案传达关于发布之间兼容性的信息，以及**基于日期的版本控制**，通常使用发布的年份和月份来表示版本。
- en: Semantic versioning uses a version number consisting of three numbers, called
    the *major* , *minor* , and *patch* versions, separated by dots. This results
    in a version that looks like `major.minor.patch` . If a new release is completely
    compatible with its predecessor, only the patch number is incremented; usually,
    such a release only contains small bug fixes. For a release that adds new functionality
    without breaking compatibility with previous releases, the minor number should
    be incremented. The major number should be incremented if the release is incompatible
    with older versions. You can read all about semantic versioning at [https://semver.org/](https://semver.org/)
    .
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 语义版本控制使用由三个数字组成的版本号，称为*主版本*、*次版本*和*修订版本*，由点分隔。这导致了一个看起来像`major.minor.patch`的版本。如果一个新版本与其前一个版本完全兼容，则只增加修订号；通常，这样的版本只包含小的错误修复。对于添加新功能而不破坏与先前版本兼容性的版本，应增加次版本号。如果发布版本与旧版本不兼容，则应增加主版本号。您可以在[https://semver.org/](https://semver.org/)上了解有关语义版本控制的全部内容。
- en: Specifying dependencies
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定依赖项
- en: 'As we saw at the beginning of the chapter, a distribution package can provide
    a list of projects it depends on, and `pip` will ensure that releases of those
    projects are installed when it installs the package. These dependencies should
    be specified in the `dependencies` key of the `project` table:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头所看到的，一个发行版包可以提供一个它所依赖的项目列表，并且`pip`在安装包时会确保安装这些项目的版本。这些依赖项应在`project`表的`dependencies`键中指定：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Our project depends on the `pydantic` , `pydantic-settings` , and `requests`
    projects. The word `[email]` in square brackets for the `pydantic` dependency
    indicates that we also require some optional dependencies of the `pydantic` project
    related to dealing with email addresses. We will discuss optional dependencies
    in more detail in a moment.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目依赖于`pydantic`、`pydantic-settings`和`requests`项目。方括号中的`[email]`单词表示`pydantic`依赖项还要求一些与处理电子邮件地址相关的`pydantic`项目的可选依赖项。我们将在稍后更详细地讨论可选依赖项。
- en: We can use **version specifiers** to indicate which releases of dependencies
    we require. Besides the normal Python comparison operators, version specifiers
    can also use `~=` to indicate a *compatible release* . The compatible release
    specifier is a way of indicating releases that may be expected to be compatible
    under a semantic versioning scheme. For example, `requests~=2.0` means that we
    require any 2.x version of the `requests` project, from 2.0 up to 3.0 (not included).
    A version specifier can also take a comma-separated list of version clauses that
    must all be satisfied. For example, `pydantic>=2.8.2,<3.0.0` means that we want
    at least version 2.8.2 of `pydantic` , but not version 3.0.0 or greater. Note
    that this is not the same as `pydantic~=2.8.2` , which would mean at least version
    2.8.2, but not version 2.9.0 or greater. For the full details of the dependency
    syntax and how versions are matched, please refer to PEP 508 ( [https://peps.python.org/pep-0508/](https://peps.python.org/pep-0508/)
    ).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**版本指定符**来指示我们需要的依赖项的版本。除了正常的Python比较运算符之外，版本指定符还可以使用`~=`来指示一个*兼容版本*。兼容版本指定符是一种表示在语义版本控制方案下可能兼容的版本的方式。例如，`requests~=2.0`表示我们需要`requests`项目的任何2.x版本，从2.0到3.0（不包括3.0）。版本指定符还可以接受一个逗号分隔的版本子句列表，必须满足所有这些子句。例如，`pydantic>=2.8.2,<3.0.0`表示我们想要至少`pydantic`版本2.8.2，但不能是版本3.0.0或更高版本。请注意，这与`pydantic~=2.8.2`不同，后者意味着至少版本2.8.2，但不能是版本2.9.0或更高版本。有关依赖项语法和版本匹配的完整细节，请参阅PEP
    508（[https://peps.python.org/pep-0508/](https://peps.python.org/pep-0508/)）。
- en: You should be careful not to make your dependency version specifiers too strict.
    Bear in mind that your package is likely to be installed alongside various other
    packages in the same virtual environment. This is particularly true of libraries
    or tools for developers. Allowing as much freedom as possible in the required
    versions of your dependencies means that projects that depend on yours are less
    likely to encounter dependency conflicts between your package and those of other
    projects they depend on. Making your version specifiers too restrictive also means
    that your users will not benefit from bug fixes or security patches in one of
    your dependencies unless you also publish a new release to update your version
    specifier.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该小心不要使您的依赖项版本指定过于严格。请记住，您的包可能将与同一虚拟环境中的各种其他包一起安装。这对于库或开发者工具尤其如此。在您的依赖项所需版本上尽可能提供最大自由度意味着，依赖于您的项目不太可能遇到您的包与其他项目依赖项之间的依赖项冲突。使您的版本指定过于严格还意味着，除非您也发布新版本来更新您的版本指定，否则您的用户将无法从您的依赖项中的错误修复或安全补丁中受益。
- en: 'Apart from dependencies on other projects, you can also specify which versions
    of Python your project requires. In our project, we use features that were added
    in Python 3.10, so we specify that we require at least Python 3.10:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对其他项目的依赖项之外，您还可以指定您的项目需要哪些版本的 Python。在我们的项目中，我们使用了 Python 3.10 中添加的功能，因此我们指定至少需要
    Python 3.10：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As with `dependencies` , it is best to avoid limiting the Python versions you
    support too much. You should only restrict the Python version if you know your
    code will not work on all actively supported versions of Python 3.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `dependencies` 一样，最好避免过多限制您支持的 Python 版本。只有当您知道您的代码在所有活跃支持的 Python 3 版本上都无法工作的情况下，您才应该限制
    Python 版本。
- en: 'You can find a list of *Active Python Releases* on the official Python download
    page: [https://www.python.org/downloads/](https://www.python.org/downloads/) .'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方 Python 下载页面上找到 *Active Python Releases* 列表：[https://www.python.org/downloads/](https://www.python.org/downloads/)。
- en: You should make sure that your code really does work on all the versions of
    Python and the dependencies that you support in your setup configuration. One
    way of doing this is to create several virtual environments with different Python
    versions and different versions of your dependencies installed. Then, you can
    run your test suite in all these environments. Doing this manually would be very
    time-consuming. Fortunately, there are tools that will automate this process for
    you. The most popular of these tools is called *tox* . You can find out more about
    it at [https://tox.wiki/](https://tox.wiki/) .
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该确保您的代码确实可以在您在设置配置中支持的 Python 和依赖项的所有版本上运行。完成此操作的一种方法是为不同的 Python 版本和不同版本的依赖项创建几个虚拟环境。然后，您可以在所有这些环境中运行您的测试套件。手动执行此操作将非常耗时。幸运的是，有一些工具可以为您自动化此过程。最受欢迎的这些工具之一被称为
    *tox*。您可以在 [https://tox.wiki/](https://tox.wiki/) 上了解更多信息。
- en: You can also specify optional dependencies for your package. `pip` will only
    install such dependencies if a user specifically requests it. This is useful if
    some dependencies are only required for a feature that many users are not likely
    to need. Users who want the extra feature can then install the optional dependency
    and everyone else gets to save disk space and network bandwidth.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以为您的包指定可选依赖项。`pip` 只会在用户明确请求时安装这些依赖项。如果某些依赖项仅适用于许多用户不太可能需要的特性，这很有用。想要额外特性的用户可以安装可选依赖项，而其他人则可以节省磁盘空间和网络带宽。
- en: For example, the PyJWT project, which we used in *Chapter 9, Cryptography and
    Tokens* , depends on the cryptography project to sign JWTs using asymmetric keys.
    Many users of PyJWT do not use this feature, so the developers made cryptography
    an optional dependency.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们在 *第 9 章，密码学和令牌* 中使用的 PyJWT 项目，依赖于密码学项目使用非对称密钥签名 JWT。许多 PyJWT 用户不使用此功能，因此开发者将密码学作为可选依赖项。
- en: 'Optional (or extra) dependencies are specified in the `project.optional-dependencies`
    table in the `pyproject.toml` file. This section can contain any number of named
    lists of optional dependencies. These lists are referred to as **extras** . In
    our project, we have one extra called `dev` :'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 可选（或额外）依赖项在 `pyproject.toml` 文件中的 `project.optional-dependencies` 表中指定。本节可以包含任意数量的命名可选依赖项列表。这些列表被称为
    **extras**。在我们的项目中，我们有一个名为 `dev` 的额外依赖项：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is a common convention for listing tools that are useful during the development
    of a project as optional dependencies. Many projects also have an extra `test`
    dependency for installing packages that are only needed to run the project’s test
    suite.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在项目开发期间列出有用的工具作为可选依赖项的常见约定。许多项目还有一个额外的 `test` 依赖项，用于安装仅用于运行项目测试套件的包。
- en: 'To include optional dependencies when installing a package, you have to add
    the names of the extras you want in square brackets when you run `pip install`
    . For example, to do an editable install of our project with the `dev` dependencies
    included, you can run:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装包时包含可选依赖项，你必须在运行 `pip install` 时在方括号中添加你想要的额外依赖项的名称。例如，为了包含 `dev` 依赖项进行我们的项目的可编辑安装，你可以运行：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that we needed to use quotes in this `pip install` command to prevent the
    shell from interpreting the square brackets as a filename pattern.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个 `pip install` 命令中我们需要使用引号来防止 shell 将方括号解释为文件名模式。
- en: Project URLs
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 URL
- en: 'You can also include a list of URLs for websites related to your project in
    the `urls` sub-table of the `project` metadata table:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 `project` 元数据表的 `urls` 子表中包含与你的项目相关的网站 URL 列表：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The keys of the URLs table can be arbitrary strings describing the URLs. It
    is quite common for projects to include a link to their source code on a code-hosting
    service, such as GitHub or GitLab. Many projects also link to online documentation
    or bug trackers. We have used this field to add links to the source code repository
    for this book on GitHub and to information about the book on the publisher’s website.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: URLs 表的键可以是描述 URL 的任意字符串。在项目中包含指向源代码托管服务（如 GitHub 或 GitLab）的链接是很常见的。许多项目也链接到在线文档或错误跟踪器。我们已使用此字段添加了指向本书在
    GitHub 上的源代码仓库的链接以及有关本书在出版社网站上的信息。
- en: Scripts and entry points
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 脚本和入口点
- en: 'So far, we have been running our application by typing:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过键入以下内容来运行我们的应用程序：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is not particularly user-friendly. It would be much better if we could
    run our application by just typing:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是特别用户友好。如果我们能只通过键入以下内容来运行我们的应用程序会更好：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can achieve this by configuring script **entry points** for our distribution.
    A script entry point is a function that we want to be able to execute as a command-line
    or GUI script. When our package is installed, `pip` will automatically generate
    scripts that import the specified functions and run them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过为我们的发行版配置脚本 **入口点** 来实现这一点。脚本入口点是我们希望能够作为命令行或 GUI 脚本执行的功能。当我们的包被安装时，`pip`
    将自动生成导入指定函数并运行它们的脚本。
- en: 'We configure script entry points in the `project.scripts` table in the `pyproject.toml`
    file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `pyproject.toml` 文件中的 `project.scripts` 表中配置脚本入口点：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Each key in this table defines the name of a script that should be generated
    when the package is installed. The corresponding value is an object reference
    pointing to the function that should be called when the script is executed. If
    we were packaging a GUI application, we would need to use the `project.gui-scripts`
    table instead.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在此表中，每个键定义了在安装包时应生成的脚本的名称。相应的值是一个对象引用，指向在执行脚本时应调用的函数。如果我们正在打包一个 GUI 应用程序，我们需要使用
    `project.gui-scripts` 表。
- en: The Windows operating system treats console and GUI applications differently.
    Console applications are launched in a console window and can print to the screen
    and read keyboard input through the console. GUI applications are launched without
    a console window. On other operating systems, there is no difference between `scripts`
    and `gui-scripts` .
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 操作系统以不同的方式处理控制台和 GUI 应用程序。控制台应用程序在控制台窗口中启动，可以通过控制台打印到屏幕并读取键盘输入。GUI 应用程序在没有控制台窗口的情况下启动。在其他操作系统上，`scripts`
    和 `gui-scripts` 之间没有区别。
- en: 'Now, when we install the project in a virtual environment, `pip` will generate
    a `railway-cli` script in the virtual environment `bin` folder (or the `Scripts`
    folder on Windows). It looks like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们在一个虚拟环境中安装项目时，`pip` 将在虚拟环境 `bin` 文件夹（或在 Windows 上的 `Scripts` 文件夹）中生成一个
    `railway-cli` 脚本。它看起来像这样：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `#!/.../ch16/railway-project/venv/bin/python` comment at the top of the
    file is called a **shebang** (from hash + bang – bang is another name for an exclamation
    mark). It specifies the path to the Python executable that will be used to run
    the script. The script imports the `main()` function from the `railway_cli.main`
    module, performs some manipulation of the program name in `sys.argv[0]` , and
    then calls `main()` and passes the return value to `sys.exit()` .
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 文件顶部的`#!/.../ch16/railway-project/venv/bin/python`注释被称为**shebang**（来自hash +
    bang – bang是感叹号的另一个名称）。它指定了将用于运行脚本的Python可执行文件的路径。脚本从`railway_cli.main`模块导入`main()`函数，对`sys.argv[0]`中的程序名称进行一些操作，然后调用`main()`并将返回值传递给`sys.exit()`。
- en: 'Apart from script entry points, it is also possible to create arbitrary entry-point
    groups. Such groups are defined by sub-tables under the `project.entry-points`
    table. `pip` will not generate scripts for entry points in other groups, but they
    can be useful for other purposes. Specifically, many projects that support extending
    their functionality via plugins use particular entry point group names for plugin
    discovery. This is a more advanced subject that we won’t discuss in detail here,
    but if you are interested, you can read about it in the entry-points specification:
    [https://packaging.python.org/specifications/entry-points/](https://packaging.python.org/specifications/entry-points/)
    .'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了脚本入口点之外，还可以创建任意的入口点组。这些组由`project.entry-points`表下的子表定义。`pip`不会为其他组中的入口点生成脚本，但它们可以用于其他目的。具体来说，许多支持通过插件扩展其功能的项目使用特定的入口点组名称进行插件发现。这是一个更高级的主题，我们在这里不会详细讨论，但如果您感兴趣，您可以在入口点规范中了解更多信息：[https://packaging.python.org/specifications/entry-points/](https://packaging.python.org/specifications/entry-points/)。
- en: Defining the package contents
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义包内容
- en: For projects that use the src layout, Setuptools can usually automatically determine
    which Python modules to include in the distribution. For flat layouts, automatic
    discovery only works if there is only one importable package present in the project
    folder. If there are any other Python files present, you will need to configure
    the packages and modules to include or exclude via the `tools.setuptools` table
    in `pyproject.toml` .
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用src布局的项目，Setuptools通常可以自动确定要包含在分发中的Python模块。对于平面布局，如果项目文件夹中只有一个可导入的包，则自动发现才会工作。如果存在任何其他Python文件，您将需要通过`pyproject.toml`文件中的`tools.setuptools`表配置要包含或排除的包和模块。
- en: 'If you use an src layout, you only need additional configuration if you use
    a name other than `src` for the folder containing the code, or if there are some
    modules in the `src` folder that need to be excluded from the distribution. In
    our railway-cli project, we rely on automatic discovery, so we do not have any
    package discovery configuration in our `pyproject.toml` file. You can read more
    about Setuptools’s automatic discovery and how to customize it in the Setuptools
    user guide: [https://setuptools.pypa.io/en/latest/userguide/](https://setuptools.pypa.io/en/latest/userguide/)
    .'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用src布局，只有当您为包含代码的文件夹使用除`src`之外的其他名称，或者当`src`文件夹中有一些模块需要从分发中排除时，您才需要额外的配置。在我们的railway-cli项目中，我们依赖于自动发现，因此我们`pyproject.toml`文件中没有任何包发现配置。您可以在Setuptools用户指南中了解更多关于Setuptools的自动发现以及如何自定义它的信息：[https://setuptools.pypa.io/en/latest/userguide/](https://setuptools.pypa.io/en/latest/userguide/)。
- en: Our package metadata configuration is now complete. Before we move on to building
    and publishing a package, we will take a brief look at how we can access the metadata
    in our code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的包元数据配置现在已经完成。在我们继续构建和发布包之前，我们将简要看看如何在我们的代码中访问元数据。
- en: Accessing metadata in your code
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在您的代码中访问元数据
- en: We have already seen how we can use dynamic metadata to share the version number
    between the distribution configuration and the code. For other dynamic metadata,
    Setuptools only supports loading from files, not from attributes in the code.
    Such files will not be included in the wheel distribution unless we add explicit
    configuration for this. There is, however, a more convenient way to access distribution
    metadata from the code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用动态元数据在分发配置和代码之间共享版本号。对于其他动态元数据，Setuptools仅支持从文件中加载，而不是从代码中的属性加载。除非我们为此添加显式配置，否则这些文件将不会包含在wheel分发中。然而，有一个更方便的方法可以从代码中访问分发元数据。
- en: 'The `importlib.metadata` standard library module provides interfaces to access
    the distribution metadata of any installed package. To demonstrate this, we have
    added a command-line option for displaying the project license to the Railway
    CLI application:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`importlib.metadata`标准库模块提供了访问任何已安装包的发行版元数据的接口。为了演示这一点，我们已向Railway CLI应用程序添加了一个用于显示项目许可证的命令行选项：'
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We use the `"version"` argument parser action to print the license string and
    exit if the `-L` or `--license` option is present on the command line. To get
    the license text, we first need to find the distribution corresponding to our
    importable package. The `packages_distributions()` function returns a dictionary
    whose keys are the names of importable packages in the virtual environment. The
    values are lists of distribution packages that provide the corresponding importable
    packages. We assume that no other installed distributions provide a package of
    the same name as ours, so we just take the first element of the `all_distributions[__package__]`
    list.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`"version"`参数解析器操作来打印许可证字符串，并在命令行上存在`-L`或`--license`选项时退出。要获取许可证文本，我们首先需要找到与我们的可导入包对应的发行版。`packages_distributions()`函数返回一个字典，其键是虚拟环境中可导入包的名称。值是提供相应可导入包的发行版包的列表。我们假设没有其他已安装的发行版提供与我们的包同名的一个包，所以我们只取`all_distributions[__package__]`列表的第一个元素。
- en: The `metadata` function returns a `dict` -like object with the metadata. The
    keys are similar to, but not quite the same as, the names of the `pyproject.toml`
    entries we use to define the metadata. Details of all the keys and their meanings
    can be found in the metadata specification at [https://packaging.python.org/specifications/core-metadata/](https://packaging.python.org/specifications/core-metadata/)
    .
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`metadata`函数返回一个类似`dict`的对象，包含元数据。键与用于定义元数据的`pyproject.toml`条目名称相似，但并不完全相同。所有键及其含义的详细信息可以在[https://packaging.python.org/specifications/core-metadata/](https://packaging.python.org/specifications/core-metadata/)的元数据规范中找到。'
- en: Note that if our package is not installed, we will get a `KeyError` when we
    try to look it up in the dictionary returned by `packages_distributions()` . In
    this case, or in the case where there is no `"License"` specified in the project
    metadata, we return a default value to indicate that the license could not be
    found.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们的包未安装，当我们尝试在`packages_distributions()`返回的字典中查找它时，将会得到一个`KeyError`。在这种情况下，或者在没有在项目元数据中指定`"License"`的情况下，我们返回一个默认值来表示无法找到许可证。
- en: 'Let us see what the output looks like:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看输出是什么样子：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We have trimmed the output here to save space, but if you run it yourself, you
    should see the full license text printed out.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里已经裁剪了输出以节省空间，但如果你亲自运行它，你应该能看到打印出的完整许可证文本。
- en: Now, we are ready to proceed with building and publishing distribution packages.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好进行构建和发布发行版包。
- en: Building and publishing packages
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和发布包
- en: We will use the package builder provided by the *build* project ( [https://pypi.org/project/build/](https://pypi.org/project/build/)
    ) to build our distribution package. We will also need the *twine* ( [https://pypi.org/project/twine/](https://pypi.org/project/twine/)
    ) utility to upload our packages to PyPI. You can install these tools from the
    `requirements/build.txt` file provided with the source code of this chapter. We
    recommend installing these in a new virtual environment.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用由*build*项目提供的包构建器（[https://pypi.org/project/build/](https://pypi.org/project/build/)）来构建我们的发行版包。我们还需要*twine*（[https://pypi.org/project/twine/](https://pypi.org/project/twine/)）工具来上传我们的包到PyPI。您可以从本章源代码提供的`requirements/build.txt`文件中安装这些工具。我们建议在新的虚拟环境中安装这些工具。
- en: Because project names on PyPI must be unique, you will not be able to upload
    the `railway-cli` project without changing the name first. You should change the
    `name` in the `pyptoject.toml` file to something unique before building distribution
    packages. Bear in mind that this means that the filenames of your distribution
    packages will also be different from ours.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PyPI上的项目名称必须是唯一的，因此您在更改名称之前无法上传`railway-cli`项目。在构建发行版包之前，您应该将`pyptoject.toml`文件中的`name`更改为一个唯一的名称。请注意，这意味着您的发行版包的文件名也将与我们不同。
- en: Building
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建
- en: 'The `build` project provides a simple script for building packages according
    to the PEP 517 specification. It will take care of all the details of building
    distribution packages for us. When we run it, `build` will do the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`build`项目提供了一个简单的脚本，用于根据PEP 517规范构建包。它将为我们处理构建分发包的所有细节。当我们运行它时，`build`将执行以下操作：'
- en: Create a virtual environment.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个虚拟环境。
- en: Install the build requirements listed in the `pyproject.toml` file in the virtual
    environment.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在虚拟环境中安装`pyproject.toml`文件中列出的构建需求。
- en: Import the build backend specified in the `pyproject.toml` file and run it to
    build a source distribution.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`pyproject.toml`文件中指定的构建后端并运行它以构建源分发。
- en: Create another virtual environment and install the build requirements.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个虚拟环境并安装构建需求。
- en: Import the build backend and use it to build a wheel from the source distribution
    built in *step 3* .
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入构建后端并使用它从*步骤3*中构建的源分发构建一个轮子。
- en: 'Let us see it in action. Enter the `railway-project` folder in the chapter’s
    source code, and run the following command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的。进入章节源代码中的`railway-project`文件夹，并运行以下命令：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We have removed a lot of lines from the output to make it easier to see how
    it follows the steps we listed above. If you look at the content of your `railway-project`
    folder, you will notice there is a new folder called `dist` with two files: `railway_cli-0.0.1.tar.gz`
    is our source distribution, and `railway_cli-0.0.1-py3-none-any.whl` is the wheel.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从输出中删除了很多行，以便更容易地看到它如何遵循我们上面列出的步骤。如果您查看`railway-project`文件夹的内容，您会注意到有一个名为`dist`的新文件夹，其中包含两个文件：`railway_cli-0.0.1.tar.gz`是我们的源分发，而`railway_cli-0.0.1-py3-none-any.whl`是轮子。
- en: 'Before uploading your package, it is advisable to do a couple of checks to
    make sure it is built correctly. First, we can use `twine` to verify that the
    `readme` will render correctly on the PyPI website:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在上传您的包之前，建议您进行一些检查以确保它正确构建。首先，我们可以使用`twine`来验证`readme`是否会在PyPI网站上正确渲染：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If `twine` reports any problems, you should fix them and rebuild the package.
    In our case, the checks passed, so let us install our wheel and make sure it works.
    In a separate virtual environment, run:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`twine`报告了任何问题，您应该修复它们并重新构建包。在我们的例子中，检查通过了，因此让我们安装我们的轮子并确保它工作。在一个单独的虚拟环境中运行：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With the wheel installed in your virtual environment, try to run the application,
    preferably from outside the project directory. If you encounter any errors during
    installation or when running your code, check your configuration carefully for
    typos.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的虚拟环境中安装了轮子后，尝试运行应用程序，最好从项目目录外部运行。如果在安装或运行代码时遇到任何错误，请仔细检查您的配置是否有误。
- en: Our package seems to have been built successfully, so let us move on to publishing
    it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的包似乎已经成功构建，因此让我们继续发布它。
- en: Publishing
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布
- en: Since this is only an example project, we will upload it to TestPyPI instead
    of the real PyPI. This is a separate instance of the package index that was created
    specifically to allow developers to test package uploads and experiment with packaging
    tools and processes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个示例项目，我们将将其上传到TestPyPI而不是真正的PyPI。这是一个专门创建的包索引的独立实例，旨在允许开发者测试包上传并实验打包工具和流程。
- en: 'Before you can upload packages, you will need to register an account. You can
    do this now, by going to the TestPyPI website at [https://test.pypi.org](https://test.pypi.org)
    and clicking on **Register** . Once you have completed the registration process
    and verified your email address, you will need to generate an API token. You can
    do so on the **Account Settings** page of the TestPyPI website. Make sure you
    copy the token and save it before closing the page. You should save your token
    to a file named `.pypirc` in your user home directory. The file should look like
    this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在您上传包之前，您需要注册一个账户。您可以通过访问[https://test.pypi.org](https://test.pypi.org)并点击**注册**来现在就完成此操作。完成注册过程并验证您的电子邮件地址后，您需要生成一个API令牌。您可以在TestPyPI网站的**账户设置**页面完成此操作。确保在关闭页面之前复制令牌并保存它。您应该将令牌保存到用户主目录中名为`.pypirc`的文件中。该文件应如下所示：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `password` value should be replaced with your actual token.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 应将`password`值替换为您的实际令牌。
- en: We strongly recommend that you enable two-factor authentication for both your
    TestPyPI account and especially your real PyPI account.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议您为您的TestPyPI账户以及尤其是您的真实PyPI账户启用双因素认证。
- en: 'Now, you are ready to run `twine` to upload your distribution packages:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经准备好运行`twine`来上传您的分发包：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`twine` displays progress bars to show how the uploads are progressing. Once
    the upload is complete, it prints out a URL where you can see details of your
    package. Open it in your browser, and you should see our project description with
    the contents of our `README.md` file. On the left of the page, you will see links
    for the project URLs, the author details, license information, keywords, and classifiers.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`twine` 显示进度条以显示上传进度。一旦上传完成，它将打印出一个 URL，你可以在这里看到你包的详细信息。在浏览器中打开它，你应该会看到我们的项目描述以及
    `README.md` 文件的内容。在页面的左侧，你会看到项目 URL、作者详情、许可信息、关键词和分类器的链接。'
- en: '![A screenshot of a computer  Description automatically generated](img/B30992_16_01.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B30992_16_01.png)'
- en: 'Figure 16.1: Our project page on the TestPyPI website'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.1：我们在 TestPyPI 网站上的项目页面
- en: '*Figure 16.1* shows what this page looks like for our railway-cli project.
    You should check all the information on the page carefully and make sure it matches
    what you expect to see. If not, you will have to fix the metadata in your `pyproject.toml`
    , rebuild, and re-upload.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16.1* 展示了我们的 railway-cli 项目在这个页面上的样子。你应该仔细检查页面上的所有信息，并确保它们与你期望看到的一致。如果不一致，你将不得不修复
    `pyproject.toml` 中的元数据，重新构建并重新上传。'
- en: PyPI will not let you re-upload distributions with the same filenames as previously
    uploaded packages. To fix your metadata, you will have to increment the version
    of your package. Using developmental release numbers until you are 100% sure everything
    is correct can help you avoid unnecessary version increments just to fix packaging
    mistakes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: PyPI 不会允许你重新上传与之前上传的包具有相同文件名的分发。为了修复你的元数据，你必须增加你包的版本号。在你完全确定一切正确无误之前使用开发版本号可以帮助你避免仅仅为了修复打包错误而不必要地增加版本号。
- en: 'Now, we can install our package from the TestPyPI repository. Run the following
    in a new virtual environment:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从 TestPyPI 仓库安装我们的包。在新的虚拟环境中运行以下命令：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `--index-url` option tells `pip` to use `https://test.pypi.org/simple/`
    as the main package index. We use `--extra-index-url https://pypi.org/simple/`
    to tell `pip` to also look up packages in standard PyPI so that dependencies that
    are not available in TestPyPI can be installed. The package was installed successfully,
    which confirms that our package was built and uploaded correctly.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`--index-url` 选项指示 `pip` 使用 `https://test.pypi.org/simple/` 作为主要包索引。我们使用 `--extra-index-url
    https://pypi.org/simple/` 来告诉 `pip` 还要查找标准 PyPI 中的包，以便可以安装 TestPyPI 中不可用的依赖项。包安装成功，这证实了我们的包已正确构建和上传。'
- en: 'If this were a real project, we would now proceed to upload to the real PyPI.
    The process is the same as for TestPyPI. When you save your PyPI API key, you
    should add it to your existing `.pypirc` file under the heading `[pypi]` , like
    this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个真实的项目，我们现在将开始上传到真实的 PyPI。过程与 TestPyPI 相同。当你保存 PyPI API 密钥时，你应该将其添加到现有
    `.pypirc` 文件下的 `[pypi]` 标题下，如下所示：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You also do not need to use the `--repository` option to upload your package
    to the real PyPI; you can just run the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你也不需要使用 `--repository` 选项将你的包上传到真实的 PyPI；你只需运行以下命令：
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see, it is not difficult to package and publish a project, but there
    are quite a few details to take care of. The good news is that most of the work
    only needs to be done once: when you publish your first release. For subsequent
    releases, you usually just need to update the version and maybe adjust your dependencies.
    In the next section, we will give you some advice that should make the process
    easier.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，打包和发布项目并不困难，但确实有很多细节需要注意。好消息是，大部分工作只需要做一次：当你发布第一个版本时。对于后续版本，你通常只需要更新版本号，也许调整一下依赖项。在下一节中，我们将给你一些建议，这应该会使整个过程更容易。
- en: Advice for starting new projects
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新项目启动建议
- en: It can be a tedious process to do all the preparation work for packaging in
    one go. It is also easy to make a mistake like forgetting to list a required dependency
    if you try to write all your package configurations just before publishing your
    package for the first time. It is much easier to start with a simple `pyproject.toml`
    , containing only the essential configuration and metadata. You can then add to
    your metadata and configuration as you work on your project. For example, every
    time you start using a new third-party project in your code, you can immediately
    add it to your `dependencies` list. It also helps to start writing your README
    file early on and then expanding it as you progress. You may even find that writing
    a paragraph or two describing your project helps you to think more clearly about
    what it is you are trying to achieve.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性完成所有包装准备工作的过程可能相当繁琐。如果您试图在首次发布包之前编写所有包配置，很容易犯诸如忘记列出所需依赖项之类的错误。从简单的 `pyproject.toml`
    开始，其中只包含基本配置和元数据，会更容易一些。您可以在项目开发过程中逐步添加元数据和配置。例如，每次您开始在代码中使用新的第三方项目时，您都可以立即将其添加到您的
    `dependencies` 列表中。这也有助于您尽早开始编写 README 文件，并在进展过程中对其进行扩展。您甚至可能会发现，写一段或两段描述您项目的段落有助于您更清晰地思考您试图实现的目标。
- en: 'To help you, we have created an initial skeleton for a new project. You can
    find it in the `skeleton-project` folder in this chapter’s source code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您，我们为新的项目创建了一个初始骨架。您可以在本章源代码的 `skeleton-project` 文件夹中找到它：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Copy this, modify it as you wish, and use it as a starting point for your own
    projects.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 将此内容复制下来，按需修改，并将其用作您自己项目的起点。
- en: The cookiecutter project ( [https://cookiecutter.readthedocs.io](https://cookiecutter.readthedocs.io)
    ) allows you to create templates to use as starting points for projects. This
    can make the process of starting a new project much simpler.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: cookiecutter 项目（[https://cookiecutter.readthedocs.io](https://cookiecutter.readthedocs.io)）允许您创建模板，用作项目的起点。这可以使启动新项目的流程变得更加简单。
- en: Other files
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他文件
- en: 'The configuration files we showed you in this chapter are all you need to package
    and distribute most modern Python projects. There are, however, a few other files
    that you are likely to encounter if you look at other projects on PyPI:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中向您展示的配置文件就是您包装和分发大多数现代 Python 项目所需的所有文件。然而，如果您查看 PyPI 上的其他项目，可能会遇到一些其他文件：
- en: In early versions of Setuptools, every project needed to include a setup.py
    script, which was used to build the project. Most such scripts consisted only
    of a call to the `setuptools.setup()` function with project metadata specified
    as parameters. The use of `setup.py` has not been deprecated and this is still
    a valid method of configuring Setuptools.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Setuptools 的早期版本中，每个项目都需要包含一个 `setup.py` 脚本，该脚本用于构建项目。大多数这样的脚本仅包含对 `setuptools.setup()`
    函数的调用，并将项目元数据作为参数指定。`setup.py` 的使用尚未被弃用，这仍然是一种配置 Setuptools 的有效方法。
- en: Setuptools also supports reading its configuration from a `setup.cfg` file.
    Before the widespread adoption of `pyproject.toml` , this was the preferred way
    of configuring Setuptools.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Setuptools 也支持从 `setup.cfg` 文件中读取其配置。在 `pyproject.toml` 得到广泛采用之前，这是配置 Setuptools
    的首选方式。
- en: If you need to include data files or other non-standard files in your distribution
    packages, you will need to use a `MANIFEST.in` file to specify the files to include.
    You can learn more about the use of this file at [https://packaging.python.org/guides/using-manifest-in/](https://packaging.python.org/guides/using-manifest-in/)
    .
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您需要在您的分发包中包含数据文件或其他非标准文件，您将需要使用 `MANIFEST.in` 文件来指定要包含的文件。您可以在 [https://packaging.python.org/guides/using-manifest-in/](https://packaging.python.org/guides/using-manifest-in/)
    上了解更多关于此文件的使用信息。
- en: Alternative tools
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替代工具
- en: Before we finish the chapter, let us briefly discuss some alternative options
    that you have for packaging your projects. Before PEP 517 and PEP 518, it was
    difficult to use anything other than Setuptools to build packages. There was no
    way for projects to specify what libraries were required to build them or how
    they should be built, so `pip` and other tools just assumed that packages should
    be built using Setuptools.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，让我们简要讨论一些您用于包装项目的替代选项。在 PEP 517 和 PEP 518 之前，除了 Setuptools 之外，很难使用其他任何工具来构建包。项目无法指定构建它们所需的库或构建方式，因此
    `pip` 和其他工具只是假设应该使用 Setuptools 来构建包。
- en: 'Thanks to the build-system information in the `pyproject.toml` file, it is
    now easy to use any packaging library you want. There are several alternatives
    to choose from, including:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了`pyproject.toml`文件中的构建系统信息，现在使用任何你想要的打包库都变得容易。有几种选择可供选择，包括：
- en: The Flit project ( [https://flit.pypa.io](https://flit.pypa.io) ) was instrumental
    in inspiring the development of the PEP 517 and PEP 518 standards (the creator
    of Flit was a co-author of PEP 517). Flit aims to make packaging simple, pure
    Python projects that do not require complex build steps (like compiling C code)
    as easy as possible. Flit also provides a CLI for building packages and uploading
    them to PyPI (so you do not need the `build` tool or `twine` ).
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flit项目（[https://flit.pypa.io](https://flit.pypa.io)）在启发PEP 517和PEP 518标准（Flit的创建者是PEP
    517的共同作者）的发展中起到了关键作用。Flit旨在使不需要复杂构建步骤（如编译C代码）的纯Python项目打包尽可能简单。Flit还提供了一个CLI用于构建软件包并将它们上传到PyPI（因此你不需要`build`工具或`twine`）。
- en: Poetry ( [https://python-poetry.org/](https://python-poetry.org/) ) also provides
    both a CLI for building and publishing packages and a lightweight PEP 517 build
    backend. Where Poetry really shines, though, is in its advanced dependency management
    features. Poetry can even manage virtual environments for you.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诗歌（[https://python-poetry.org/](https://python-poetry.org/)）也提供了用于构建和发布软件包的CLI以及一个轻量级的PEP
    517构建后端。然而，诗歌真正出色的地方在于其高级依赖管理功能。诗歌甚至可以为你管理虚拟环境。
- en: Hatch ( [https://hatch.pypa.io](https://hatch.pypa.io) ) is an extensible project
    manager tool for Python. It includes tools for installing and managing Python
    versions, managing virtual environments, running tests, and more. It also includes
    a PEP 517 build backend named hatchling.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hatch（[https://hatch.pypa.io](https://hatch.pypa.io)）是一个可扩展的Python项目管理工具。它包括安装和管理Python版本、管理虚拟环境、运行测试等功能。它还包含一个名为hatchling的PEP
    517构建后端。
- en: PDM ( [https://pdm-project.org/](https://pdm-project.org/) ) is another package
    and dependency manager that includes a build backend. Like Hatch, it can be used
    to manage virtual environments and install Python versions. There are also many
    plugins available to extend PDM’s functionality.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDM（[https://pdm-project.org/](https://pdm-project.org/)）是另一个包含构建后端的软件包和依赖管理器。像Hatch一样，它可以用来管理虚拟环境和安装Python版本。还有许多插件可用于扩展PDM的功能。
- en: Enscons ( [https://dholth.github.io/enscons/](https://dholth.github.io/enscons/)
    ) is based on the SCons ( [https://scons.org/](https://scons.org/) ) general-purpose
    build system. This means that, unlike Flit or Poetry, enscons can be used to build
    distributions that include C language extensions.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Enscons（[https://dholth.github.io/enscons/](https://dholth.github.io/enscons/)）基于SCons（[https://scons.org/](https://scons.org/)）通用构建系统。这意味着，与Flit或Poetry不同，enscons可以用来构建包含C语言扩展的发行版。
- en: Meson ( [https://mesonbuild.com/](https://mesonbuild.com/) ) is another popular
    general-purpose build system. The `meson-python` ( [https://mesonbuild.com/meson-python/](https://mesonbuild.com/meson-python/)
    )project provides a PEP 517 build backend that is built on top of Meson. This
    means that it can build distributions that include extension modules built with
    Meson.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Meson（[https://mesonbuild.com/](https://mesonbuild.com/)）是另一个流行的通用构建系统。`meson-python`（[https://mesonbuild.com/meson-python/](https://mesonbuild.com/meson-python/)）项目提供了一个基于Meson的PEP
    517构建后端。这意味着它可以构建包含使用Meson构建的扩展模块的发行版。
- en: Maturin ( [https://www.maturin.rs/](https://www.maturin.rs/) ) is another build
    tool that can be used to build distributions with extension modules implemented
    in the Rust programming language.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maturin（[https://www.maturin.rs/](https://www.maturin.rs/)）是另一个构建工具，可以用来构建包含使用Rust编程语言实现的扩展模块的发行版。
- en: The tools we have discussed in this chapter are all focused on distributing
    packages through PyPI. Depending on your target audience, this might not always
    be the best choice, though. PyPI exists mainly for distributing projects such
    as libraries and development tools for use by Python developers. Installing and
    using packages from PyPI also requires having a working Python installation and
    at least enough Python knowledge to know how to install packages with `pip` .
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中讨论的工具都专注于通过PyPI分发软件包。根据你的目标受众，这不一定总是最佳选择。PyPI主要存在是为了分发项目，如库和Python开发者的开发工具。从PyPI安装和使用软件包还需要有一个正常工作的Python安装，以及至少足够的Python知识，知道如何使用`pip`安装软件包。
- en: If your project is an application aimed at a less technically adept audience,
    you may want to consider other options. The Python Packaging User Guide has a
    useful overview of various options for distributing applications; it is available
    at [https://packaging.python.org/overview/#packaging-applications](https://packaging.python.org/overview/#packaging-applications)
    .
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目是一个面向技术能力较弱的受众的应用程序，你可能需要考虑其他选项。Python 打包用户指南提供了关于分发应用程序的各种选项的有用概述；它可在[https://packaging.python.org/overview/#packaging-applications](https://packaging.python.org/overview/#packaging-applications)找到。
- en: This brings us to the end of our packaging journey.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们打包之旅的结束。
- en: Further reading
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'We will finish this chapter with a few links to resources where you can read
    more about packaging:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将本章结束于一些链接，你可以通过这些链接阅读更多关于打包的资源：
- en: The Python Packaging Authority’s Packaging History page ( [https://www.pypa.io/en/latest/history/](https://www.pypa.io/en/latest/history/)
    ) is a useful resource for understanding the evolution of Python packaging.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 打包权威机构的打包历史页面（[https://www.pypa.io/en/latest/history/](https://www.pypa.io/en/latest/history/)）是了解
    Python 打包演变的有用资源。
- en: The Python Packaging User Guide ( [https://packaging.python.org/](https://packaging.python.org/)
    ) has useful tutorials and guides, as well as a packaging glossary, links to packaging
    specifications, and a summary of various interesting projects related to packaging.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 打包用户指南（[https://packaging.python.org/](https://packaging.python.org/)）包含有用的教程和指南，以及打包术语表、打包规范的链接和与打包相关的各种有趣项目的总结。
- en: The Setuptools documentation ( [https://setuptools.readthedocs.io/](https://setuptools.readthedocs.io/)
    ) contains a lot of useful information.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Setuptools 文档（[https://setuptools.readthedocs.io/](https://setuptools.readthedocs.io/)）包含大量有用信息。
- en: 'If you are distributing a library that uses type hinting, you may want to distribute
    type information so that developers who depend on your library can run type checks
    against their code. The Python typing documentation includes some useful information
    on distributing type information: [https://typing.readthedocs.io/en/latest/spec/distributing.html](https://typing.readthedocs.io/en/latest/spec/distributing.html)
    .'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在分发一个使用类型提示的库，你可能希望分发类型信息，以便依赖你的库的开发者可以对他们的代码运行类型检查。Python 类型文档包括一些关于分发类型信息的有用信息：[https://typing.readthedocs.io/en/latest/spec/distributing.html](https://typing.readthedocs.io/en/latest/spec/distributing.html)。
- en: In this chapter, we showed you how to access distribution metadata in your code.
    Most packaging tools also allow you to include data files in your distribution
    packages. The standard library `importlib.resources` module provides access to
    these **package resources** . You can read about it at [https://docs.python.org/3/library/importlib.resources.html](https://docs.python.org/3/library/importlib.resources.html)
    .
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了如何在代码中访问分发元数据。大多数打包工具还允许你在分发包中包含数据文件。标准库 `importlib.resources` 模块提供了对这些**包资源**的访问。你可以在[https://docs.python.org/3/library/importlib.resources.html](https://docs.python.org/3/library/importlib.resources.html)了解更多信息。
- en: As you read about these (and other packaging resources), it is worth bearing
    in mind that although PEP 517, PEP 518, and PEP 621 were finalized a few years
    ago, many projects have not fully migrated to using PEP 517 builds, or configuring
    project metadata in `pyproject.toml` files. Much of the available documentation
    also still refers to older ways of doing things.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当你阅读这些（以及其他打包资源）时，值得记住的是，尽管 PEP 517、PEP 518 和 PEP 621 几年前就已经最终确定，但许多项目尚未完全迁移到使用
    PEP 517 构建，或在 `pyproject.toml` 文件中配置项目元数据。大部分可用的文档也仍然引用了较旧的做法。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how to package and distribute Python projects
    through PyPI. We started with some theory about packaging and introduced the concepts
    of projects, releases, and distributions on PyPI.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何通过 PyPI 打包和分发 Python 项目。我们首先介绍了一些关于打包的理论，并引入了 PyPI 上的项目、发布和分发等概念。
- en: We learned about Setuptools, the most widely used packaging library for Python,
    and worked through the process of preparing a project for packaging with Setuptools.
    In the process, we saw various files that need to be added to a project to package
    it and what each of them is for.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了 Setuptools，这是 Python 最广泛使用的打包库，并了解了使用 Setuptools 准备项目打包的过程。在这个过程中，我们看到了需要添加到项目中以进行打包的各种文件，以及每个文件的作用。
- en: We discussed the metadata that you should provide to describe your project and
    help users find it on PyPI, as well as how to add code to the distribution, how
    to specify our dependencies, and how to define entry points so that `pip` will
    automatically generate scripts for us. We also looked at the tools that Python
    provides for accessing the distribution metadata.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了你应该提供哪些元数据来描述你的项目并帮助用户在 PyPI 上找到它，以及如何将代码添加到发行版中，如何指定我们的依赖项，以及如何定义入口点，以便
    `pip` 自动为我们生成脚本。我们还探讨了 Python 提供的用于访问发行版元数据的工具。
- en: We moved on to talking about how to build distribution packages and how to use
    `twine` to upload those packages to PyPI. We also gave you some advice on starting
    new projects. We concluded our tour of packaging by briefly talking about some
    alternatives to Setuptools and pointing you to some resources where you can learn
    more about packaging.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续讨论如何构建发行包以及如何使用 `twine` 将这些包上传到 PyPI。我们还给你提供了一些关于启动新项目的建议。在简要介绍了一些 Setuptools
    的替代方案后，我们指出了你可以学习更多关于打包知识的一些资源。
- en: We really do encourage you to start distributing your code on PyPI. No matter
    how trivial you think it might be, someone else somewhere in the world will probably
    find it useful. It really does feel good to contribute and give back to the community,
    and besides, it looks good on your CV.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的非常鼓励你开始在 PyPI 上分发你的代码。无论你认为它可能多么微不足道，世界上某个地方的其他人可能觉得它很有用。为社区做出贡献并回馈社区的感觉真的很好，而且，这对你的简历也有好处。
- en: The next chapter will introduce you to the world of competitive programming.
    We are going to deviate a little bit from professional programming to learn a
    few things about programming challenges and why they can be so much fun, and useful,
    too.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将带你进入竞技编程的世界。我们将稍微偏离专业编程，学习一些关于编程挑战及其为何如此有趣、有用的知识。
- en: Join our community on Discord
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_16.xhtml)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.com/invite/uaKmaz7FEC](Chapter_16.xhtml)'
- en: '![img](img/QR_Code119001106417026468.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/QR_Code119001106417026468.png)'
