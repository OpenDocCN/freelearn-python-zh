<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-150" class="chapter-number" lang="en-GB"><a id="_idTextAnchor159"/>9</h1>&#13;
			<h1 id="_idParaDest-151" lang="en-GB"><a id="_idTextAnchor160"/>Raspberry Pi: An Introduction</h1>&#13;
			<p lang="en-GB">In previous chapters, we introduced the digital computer and explained its operation at the instruction set level. Now you will learn about a real, low-cost computer that was designed for educational purposes.</p>&#13;
			<p lang="en-GB">In this chapter, we introduce Raspberry Pi, which is based on the popular ARM microprocessor. We describe its instruction set architecture and demonstrate how you can use it to run assembly language programs in debugging mode. The highlights of this chapter are as follows:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">An introduction to Raspberry Pi’s operating system</li>&#13;
				<li lang="en-GB">Using the GCC ARM assembler and linker</li>&#13;
				<li lang="en-GB">Debugging ARM assembly language programs</li>&#13;
			</ul>&#13;
			<p lang="en-GB">This is not a handbook for Raspberry Pi. We are interested only in using it to enter assembly language programs, run them, and observe their behavior. We do not cover Raspberry Pi’s Windows-style GUI because it is very similar to the corresponding PC and macOS user interfaces. Moreover, the Raspberry Pi operating system includes utilities and a web browser.</p>&#13;
			<h1 id="_idParaDest-152" lang="en-GB"><a id="_idTextAnchor161"/>Technical requirements</h1>&#13;
			<p lang="en-GB">This chapter is based on the Raspberry Pi 4. The software we use should also be compatible with the earlier 3B model. In order to use Raspberry Pi, you will need the following:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">Raspberry Pi 4 (available with 2 GB, 4 GB, and 8 GB DRAM)</li>&#13;
				<li lang="en-GB">Raspberry Pi 5V 3A power supply</li>&#13;
				<li lang="en-GB">USB mouse</li>&#13;
				<li lang="en-GB">USB keyboard</li>&#13;
				<li lang="en-GB">Wi-Fi internet connection</li>&#13;
				<li lang="en-GB">Video display with micro HDMI lead</li>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB">32 GB Class 10 micro SD card pre-loaded with NOOBS (see the note at the end of this section)</li>&#13;
			</ul>&#13;
			<p lang="en-GB">All these items are available on Amazon or from Raspberry Pi suppliers. You can get the operating system pre-loaded onto a micro SD card, or download the operating system and preload it onto your own card using a PC or Mac. The Raspberry Pi web page at <a href="https://www.raspberrypi.org/">https://www.raspberrypi.org/</a> provides full details about this computer including getting started, setting up, and loading the operating system on your own card.</p>&#13;
			<p lang="en-GB">The text was written <a id="_idIndexMarker582"/>using <strong class="bold">NOOBS</strong> (<strong class="bold">New Out Of the Box Software</strong>). The Raspberry Pi Foundation no longer supports NOOBS and recommends that you download the latest version of the operating system using Raspberry Pi Imager, which runs under macOS, Windows, and Ubuntu. You can find the necessary information at <a href="https://www.raspberrypi.org/">https://www.raspberrypi.org/</a>.</p>&#13;
			<p lang="en-GB">The ARM code we use in this book is designed to run on a Raspberry Pi with a 32-bit operating system.</p>&#13;
			<h1 id="_idParaDest-153" lang="en-GB"><a id="_idTextAnchor162"/>Raspberry Pi basics</h1>&#13;
			<p lang="en-GB">Microcomputers have been around <a id="_idIndexMarker583"/>since the 1970s. In the 1970s, several systems aimed at the enthusiast based on the Z80, 6502, and 6809 8-bit microprocessors appeared. Operating systems, apps, and the web didn’t exist then.</p>&#13;
			<p lang="en-GB">Then, in the late 1970s, Intel introduced the 8086 and Motorola its 68000 16-bit CPU (the 68000 microprocessor actually had a 32-bit instruction set architecture, but Motorola marketed it initially as a 16-bit machine. In my view this was a catastrophic marketing mistake. 16-bit computers were a giant leap up from their 8-bit predecessors for two reasons. First, the technology had advanced, permitting designers to put far more circuitry on a chip (i.e., more registers, more powerful instruction sets, etc.), and second, processors were far faster due to the reduction in feature size (i.e., smaller transistors). Finally, the declining cost of memory meant that people could run larger and more sophisticated programs.</p>&#13;
			<p lang="en-GB">In the 1960s, the giant corporation IBM was famous for its large-scale data-processing machines. However, IBM wanted a change of direction and IBM’s engineers decided to build a PC around Motorola’s 68000 processor. Unfortunately for Motorola, a version of that chip wasn’t yet in production. Intel released the 8088, an 8-bit version of its 16-bit 8086 processor with an 8-bit data bus that made it easy to create a low-cost microcomputer using 8-bit peripherals and memory components. The 8088 still had a 16-bit architecture but was able to interface to 8-bit memory and I/O devices.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">IBM formed a relationship with Intel, and the IBM PC in all its beige-colored splendor arose in 1981. Unlike Apple, IBM created an open architecture that anyone could use without paying a royalty. And a million PC clones flowered. The rest is history. However, the PC and Apple’s Mac left a hole in the market: an ultra-low-cost computer that the young, the student, the experimenter, and the enthusiast can play with. Raspberry Pi plugs this gap.</p>&#13;
			<p lang="en-GB">Low-cost computing has been around for a long time. For a few dollars, you can buy a greeting card that plays “Happy Birthday” when you open it. High-performance computing is more expensive. The cost of a computer often lies not in the processor but in the supporting cast of components and systems required to convert a microprocessor into a computer system – in particular, the graphics and display interface, the memory interface, and the communications interface (input/output). That’s why the Raspberry Pi has been such an amazing success. On a tiny, low-cost board, you have all the peripherals and interfaces that you need to create a complete system comparable to a PC (although not in terms of performance).</p>&#13;
			<p lang="en-GB">To turn the board into a fully-fledged microcomputer, you need only a low-cost power supply and the very same mouse and keyboard you would use with a PC. Indeed, many people use peripherals left over from PCs and other computers they have lying around. I bought a 2-to-1 HDMI switch to interface my 4K monitor to both my PC and Raspberry Pi. You just press a button and the display switches from PC to Raspberry Pi. The Raspberry Pi uses an open source operating system with vast amounts of free software. No more having to take out a mortgage for Office or Photoshop.</p>&#13;
			<p lang="en-GB">The Raspberry Pi was an outstanding <a id="_idIndexMarker584"/>success and rapidly created a very large and enthusiastic following. It found applications at all levels of education from kindergarten to PhD. Over the years, improved versions of Raspberry Pi were introduced, as well as truly minimal versions that could be used as dedicated embedded processors for a few dollars.</p>&#13;
			<p lang="en-GB"><em class="italic">Figure 9</em><em class="italic">.1</em> illustrates the Raspberry Pi 4 that was used while writing this book. The first Raspberry Pi Model B appeared in 2012 with 256 MB of DRAM, USB ports, and Ethernet, but no wireless communications. By 2019, the Raspberry Pi 4 was available with 2 USB 2.0 and 2 USB 3.0 ports, on-board Wi-Fi 502.11ac, Bluetooth 5, and Gigabit Ethernet, plus dual-monitor support via 2 micro HDMI ports capable of supporting 4K displays. The principal features of the RPi 4 are as follows:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">The powerful ARM CPU (Quad core Cortex-A72 64-bit architecture)</li>&#13;
				<li lang="en-GB">Audio (sound processing system)</li>&#13;
				<li lang="en-GB">Video display and graphics logic system (you just need to plug the card into a monitor)</li>&#13;
				<li lang="en-GB">DRAM main memory (2, 4, or 8 GB)</li>&#13;
				<li lang="en-GB">Non-volatile flash memory with the operating system (not normally included)</li>&#13;
				<li lang="en-GB">Mouse and keyboard USB ports</li>&#13;
				<li lang="en-GB">Wi-Fi (both 2.4 and 5.0 GHz bands)</li>&#13;
				<li lang="en-GB">Bluetooth 5.0</li>&#13;
				<li lang="en-GB">Ethernet port</li>&#13;
				<li lang="en-GB">A general I/O port for directly interfacing with external hardware</li>&#13;
			</ul>&#13;
			<div>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_9.01_B19624.jpg" alt="Figure 9.1 – The Raspberry Pi 4 (Image by Laserlicht / Wikimedia Commons / CC BY-SA 4.0)" width="653" height="422"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – The Raspberry Pi 4 (Image by Laserlicht / Wikimedia Commons / CC BY-SA 4.0)</p>&#13;
			<p lang="en-GB">The Raspberry Pi board is not normally sold with an operating system. It has a micro-SD port into which you have to insert a memory card containing a suitable operating system. You can buy a card with the OS already installed, or load one of the freely available variants from the web onto a card (using your PC or Mac) and plug it into the Raspberry Pi.</p>&#13;
			<p lang="en-GB">The classic operating system used by computer <a id="_idIndexMarker585"/>scientists in academia is Unix, which was developed at AT&amp;T’s Bell Labs in the late 1960s by a team that included Ken Thomson and Dennis Richie (two of the most significant players in computer science history). Unix was one of the first operating systems to become portable – that is, to run on different types of computers.</p>&#13;
			<p lang="en-GB">A strong thread in the history of computer science is open software – that is, software developed by a community of individuals that is freely available, such as the Python programming language and the LibreOffice application package, which provides much of the functionality of Microsoft’s Office suite.</p>&#13;
			<p lang="en-GB">In the 1980s, the Free Software Foundation led by Richard Stillman led the development of the GNU operating system, which was designed to provide an open source version of Unix. In 1991, Linus Torvalds released an open source component of GNU, its kernel, called Linux.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Today, the Linux kernel plus the GNU tools and compilers have become a free, open source alternative to proprietary operating systems such as Windows. GNU/Linux is available in different flavors (distributions written by various groups with the same basic structure but different features). The original official Raspberry Pi operating system was called <em class="italic">Raspbian</em> and is based on a version of Debian Linux optimized for Raspberry Pi.</p>&#13;
			<p lang="en-GB">Unix and Linux operate in a <em class="italic">command-line mode</em> – that is, operating system instructions are entered in text form (just like Microsoft’s DOS). Unix, Linux, and DOS all now have user-friendly graphical inputs that make use of the mouse as a key input device. The most famous of these graphical inputs is Microsoft’s Windows operating system.</p>&#13;
			<p lang="en-GB">Raspberry Pi now includes both a Windows-based version of Linux and a text-based command-line interface that is used to invoke some of the tools required to assemble and execute ARM assembly language programs. This chapter provides a very short introduction to RPi’s Linux operating system.</p>&#13;
			<p lang="en-GB">The Raspberry Pi operating system includes <a id="_idIndexMarker586"/>several packages that are very relevant to this book. For example, the Thonny Python IDE provides an <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>) for Python and software to edit, assemble, debug, and run Python programs.</p>&#13;
			<p lang="en-GB">Another useful package is the Geany editor, which has built-in support for more than 50 programming languages. You can <a id="_idIndexMarker587"/>get Geany at <a href="https://www.geany.org/">https://www.geany.org/</a>.</p>&#13;
			<p lang="en-GB">There is also a Terminal emulator window that lets you operate in the Linux command-line mode – a feature that is useful when working with the ARM assembly language utilities. <em class="italic">Figure 9</em><em class="italic">.2</em> shows the Raspberry Pi screen on a 4K monitor with several windows open.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_9.02_B19624.jpg" alt="Figure 9.2 – Screenshot of Raspberry Pi’s multiple windows" width="1517" height="1201"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 9.2 – Screenshot of Raspberry Pi’s multiple windows</p>&#13;
			<p lang="en-GB">While writing this book, I was also introduced to Visual Studio Code, which is an editor and debugging platform. Visual Studio Code is free and available on Linux, macOS, and Windows platforms. <em class="italic">Figure 9</em><em class="italic">.3</em> shows an example of a session using Visual Studio Code to write a Python program.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_9.03_B19624.jpg" alt="Figure 9.3 – A VS Code session while developing a Python program" width="1578" height="788"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – A VS Code session while developing a Python program</p>&#13;
			<p lang="en-GB">I must thank Graeme Harker for encouraging me to use VS Code. Had I discovered VS Code earlier, I would probably have stuck to that.</p>&#13;
			<p lang="en-GB">Now that we’ve introduced the ubiquitous Raspberry Pi that can form the basis of a computer system with the addition of a mouse, keyboard, and display, we are going to introduce its operating system.</p>&#13;
			<p lang="en-GB">However, we do not delve too deeply. In order to <a id="_idIndexMarker588"/>use the Raspberry Pi to enter, run, and debug ARM assembly language, you need to know only a few basic elements of the operating system. Moreover, even though the Raspberry Pi has a Unix-based command-line operating system, it includes a graphical interface that behaves very much like Windows or macOS.</p>&#13;
			<h1 id="_idParaDest-154" lang="en-GB"><a id="_idTextAnchor163"/>Basics of the Raspberry Pi operating system</h1>&#13;
			<p lang="en-GB">In this section, you will learn how to use the Raspberry Pi to create an ARM assembly language program, assemble it into code that <a id="_idIndexMarker589"/>can be executed, and then run it on the Raspberry Pi. In the next chapter, we will look at the ARM architecture in greater depth.</p>&#13;
			<p lang="en-GB">We do not devote much time discussing RPi’s operating system because the world is full of websites devoted to Linux. We will cover the absolute minimum to help you use some of the commands that may be helpful. Most readers will use a graphical interface to perform editing, web searches, and running programs such as Python. We will introduce the basic concepts of Linux’s filing system and the command-line instruction necessary to assemble and run a source file written in the ARM assembly language. Unfortunately, the names of Unix/Linux commands are not intuitive.</p>&#13;
			<p lang="en-GB"><em class="italic">Figure 9</em><em class="italic">.4</em> illustrates the basic concepts of the Linux hierarchical operating system, with a node at each level that can support <em class="italic">child</em> nodes at a lower level; for example, <code>Desktop</code> is a child of the <code>pi</code> node.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_9.04_B19624.jpg" alt="Figure 9.4 – The Raspberry Pi file structure" width="1627" height="1188"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – The Raspberry Pi file structure</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The top-level folder is <code>/</code> and is called the <em class="italic">root folder</em>. The <code>/</code> backslash is used to navigate the filing system very much like the Windows equivalent. A big difference between Linux and Windows is that, in Linux, you don’t have to specify the disk on <a id="_idIndexMarker590"/>which the file resides (e.g., Windows invariably uses <code>c:/</code> for operating systems files). In <em class="italic">Figure 9</em><em class="italic">.4</em>, the <code>MyFile.doc</code> file is a text file whose location is <code>/home/pi/Documents/MyFile.doc.</code></p>&#13;
			<h2 id="_idParaDest-155" lang="en-GB"><a id="_idTextAnchor164"/>Directory navigation</h2>&#13;
			<p lang="en-GB">If you press the <a id="_idIndexMarker591"/>enter key, Raspberry Pi responds with an “<em class="italic">I am here</em>” prompt, as shown in this example:</p>&#13;
			<p lang="en-GB"><code>pi@raspberrypi:</code>/var/log/apt $</p>&#13;
			<p lang="en-GB">This prompt gives the device name and the path to the current directory (in bold font in this example). You can change the active directory with the <code>cd</code> (<em class="italic">change directory</em>) command, as shown in this example:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
cd ..         # This means change directory to parent (the node above)&#13;
cd home&#13;
cd pi&#13;
cd Desktop</pre>&#13;
			<p lang="en-GB">To list the files and subdirectories in the current directory, you can use the <code>ls</code> command (<em class="italic">list files</em>).</p>&#13;
			<p lang="en-GB">The <code>ls </code>-l /home/pi command generates the following <a id="_idIndexMarker592"/>output that gives permissions (what you can do with them), their size, and creation dates. <em class="italic">Figure 9</em><em class="italic">.5</em> demonstrates this command.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_9.05_B19624.jpg" alt="Figure 9.5 – The Raspberry Pi File Structure" width="758" height="312"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – The Raspberry Pi File Structure</p>&#13;
			<p lang="en-GB">The <code>ls</code> command has several options; for example, <code>ls ~</code> indicates a list in the home directory. In Linux, the tilda<code>, ~,</code> indicates the home directory. Similarly, <code>ls –t</code> indicates list files by date and time created.</p>&#13;
			<h2 id="_idParaDest-156" lang="en-GB"><a id="_idTextAnchor165"/>File operations</h2>&#13;
			<p lang="en-GB">We now introduce some of Linux’s basic file commands. The <code>pwd</code> command looks as if it should mean <em class="italic">password</em>. Actually, it means <em class="italic">print working directory</em> and displays the contents <a id="_idIndexMarker593"/>of the current directory. It’s a “<em class="italic">where am I?</em>” command. Entering <code>pwd</code> will generate a response such as <code>/home/pi</code>.</p>&#13;
			<p lang="en-GB">To create a new subdirectory, you use the <code>mkdir</code> command. Typing <code>mkdir</code> <code>newFolder</code> creates a subdirectory called <code>newFolder</code> in the current directory.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">If you enter <code>mkdir /home/pi/newFolder</code>, it will create the subdirectory in <code>pi</code>.</p>&#13;
			<p lang="en-GB">One of Linux’s more confusing command names is <code>cat</code>, which lists the contents of a file. The name <code>cat</code> means <code>catalog</code>; for example, <code>cat /home/pi/firstExample.txt</code> displays the contents of the <code>firstExample.txt</code> file on the console as a text file.</p>&#13;
			<p lang="en-GB"> To delete or <em class="italic">remove</em> a file, you use <code>rm</code>; for example, <code>rm tempData.py</code> deletes the <code>tempData.py</code> file in the current subdirectory. You can remove an entire directory with <code>rm -r</code>. This deletes the current directory and is not reversible. It is a dangerous command. The alternative is <code>rm –d</code>, which removes the current directory <em class="italic">only if it is empty</em> (i.e., you must first delete its contents).</p>&#13;
			<p lang="en-GB">Linux has a help command, <code>man</code> (i.e., manual) that provides <a id="_idIndexMarker594"/>details of another command; for example, <code>man ls</code> would provide details of the <code>ls</code> command.</p>&#13;
			<p lang="en-GB">In general, when working with Raspberry Pi, most users will be using the graphical interface. However, we will be using the command-line input to set up the Raspberry Pi and assemble, debug, and execute assembly language programs.</p>&#13;
			<h2 id="_idParaDest-157" lang="en-GB"><a id="_idTextAnchor166"/>Installing and updating programs and packages</h2>&#13;
			<p lang="en-GB">Having set up the RPi, you need to maintain it (i.e., install and update software). The following two commands retrieve new packages and <a id="_idIndexMarker595"/>update your software. It’s a good <a id="_idIndexMarker596"/>idea to run them occasionally to get new updates. Note that <code>sudo</code> stands for <em class="italic">superuser do</em> and is required for operations that may be restricted to the administrator because they can harm the system if used inappropriately. The term <code>aptget</code> obtains and installs packages (<code>apt = Advanced </code><code>Package Tool</code>):</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
su<a id="_idTextAnchor167"/>do apt-get update        # Downloads the packages you have in your configuration source files&#13;
sudo apt-get upgrade       # Updates the packages</pre>&#13;
			<p class="callout-heading" lang="en-GB">Note</p>&#13;
			<p class="callout" lang="en-GB">sudo apt-get update updates packages but does not install them.</p>&#13;
			<p lang="en-GB">To install a new package on Raspberry Pi, you use the <code>apt-get install</code> command; for example,</p>&#13;
			<p lang="en-GB"><code>su<a id="_idTextAnchor168"/>do apt-get install vim</code> installs the <code>vim</code> editor package.</p>&#13;
			<p lang="en-GB">Linux provides a shutdown command that ends a session in an orderly manner:</p>&#13;
			<p lang="en-GB"><code>sudo shutdown -h now     Stop</code> and enter the halt state</p>&#13;
			<p lang="en-GB">The <code>-h</code> parameter indicates <em class="italic">enter the halt state</em>, and the <code>now</code> parameter indicates an immediate halt. A command to shut down is <code>sudo shutdown -r now</code>. To reboot Raspberry Pi, you can enter either of the following two commands. These commands have the same effect on a single-user system. You would use <code>shutdown -r</code> on a multi-user system:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
sudo shutdown -r now</pre>&#13;
			<pre class="source-code">sudo reboot</pre>&#13;
			<p lang="en-GB">However, most Raspberry Pi users will shut down Raspberry Pi using a mouse from its GUI. Indeed, the only time it’s necessary to use the text-based input mode is when assembling, linking, and debugging assembly language programs.</p>&#13;
			<p lang="en-GB">You can apply a delayed shutdown; for example, sudo shutdown -h 30 will shut down the RPi after 30 minutes. You can shut down at a specific clock time with, say, sudo shutdown -h 22:30, which shuts down at 10:30 P.M. A delayed shutdown command can be rescinded (canceled) by sudo shutdown -c.</p>&#13;
			<h2 id="_idParaDest-158" lang="en-GB"><a id="_idTextAnchor169"/>Creating and editing an assembly language program</h2>&#13;
			<p lang="en-GB">Let’s go through the steps needed to create an ARM program on the Raspberry Pi and then execute it before we look at the ARM processor in greater detail. Although we haven’t introduced the ARM assembly language yet, the actions of the instructions we use are self-evident.</p>&#13;
			<p lang="en-GB">First, you have to create an assembly <a id="_idIndexMarker597"/>language program in <a id="_idIndexMarker598"/>text form with a <code>.s</code> file type. There are many text editors and the one you choose is a personal preference. I initially used Geany, which is an IDE for languages such as C. I later used Thonny on my desktop PC. Both Geany and Thonny are excellent tools. If you create a text file on a desktop PC (or any other device), you simply change the <code>.txt</code> extension to <code>.s</code> to make it compatible with RPi’s assembler.</p>&#13;
			<p lang="en-GB"><em class="italic">Figure 9</em><em class="italic">.6</em> shows the initial Geany screen:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_9.06_B19624.jpg" alt="Figure 9.6 – Geany text editor window" width="1309" height="750"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 9.6 – Geany text editor window</p>&#13;
			<p lang="en-GB"><em class="italic">Figure 9</em><em class="italic">.7</em> shows a Geany window after we’ve created an ARM assembly language program:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_9.07_B19624.jpg" alt="Figure 9.7 – Geany window – note that add r3,r0,r1 adds r0 to r1 and puts the sum in r0" width="1132" height="663"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Geany window – note that add r3,r0,r1 adds r0 to r1 and puts the sum in r0</p>&#13;
			<p lang="en-GB">In the following program, the text in bold <a id="_idIndexMarker599"/>font indicates an <a id="_idIndexMarker600"/>assembler directive that tells the assembler about the program’s environment and how to deal with the allocation of memory space:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
.<strong class="bold">section .text       </strong>@ .text indicates a region of code (not data)&#13;
<strong class="bold">.global _start       </strong>@ .global indicates that this label is visible to external objects&#13;
<strong class="bold">_start:              </strong>@ _start is the entry point to this program&#13;
   mov r0,#1         @ Load r0 with 1. mov copies an 8-bit value into a register&#13;
   mov r1,#2         @ Load r1 with 2&#13;
   add r3,r0,r1      @ Add r0 and r1 and put result in r3&#13;
<strong class="bold">.end                 </strong>@ .end indicates the end of the program. It is optional</pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Note that ARM uses <code>mov</code> to load a literal and not <code>ldr</code> (as you might expect).</p>&#13;
			<h2 id="_idParaDest-159" lang="en-GB"><a id="_idTextAnchor170"/>Assembling ARM code</h2>&#13;
			<p lang="en-GB">Before we can look at the ARM architecture in depth, we will demonstrate how you write a program and run it. The Raspberry Pi’s Debian-based <a id="_idIndexMarker601"/>operating system includes GCC, the <em class="italic">GNU Compiler Collection</em>, which can compile both C programs and assembly language programs. We do not deal with C here.</p>&#13;
			<p lang="en-GB">The two GCC commands we need to assemble the source <code>myProg.s</code> text file are as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
as –<a id="_idTextAnchor171"/>o myProg.o myProg.s&#13;
ld –o myProg myProg.o</pre>&#13;
			<p lang="en-GB">The first command, <code>as</code>, takes the assembly language <em class="italic">source</em> file, <code>myProg.s</code>, and creates an <em class="italic">object</em> code file, <code>myProg.o</code>. The second command, <code>ld</code>, invokes a <em class="italic">linker</em> that uses the object file to create a binary code file, <code>myProg</code>, that can be executed. The <code>-o</code> option is necessary to build an output file. You can then run the assembled binary code program by typing <code>./my<a id="_idTextAnchor172"/>Prog</code>.</p>&#13;
			<p lang="en-GB">Although a <em class="italic">single</em> assembly language program can be assembled to create binary code, programs are often written in modules (files) that are fitted together. These files may be written by different programmers or even library programs. They are individually assembled to create files that the linker combines to create the final binary code that can be executed. In this text, we do not make full use of the linker’s facilities; all assembly language programs are single files.</p>&#13;
			<p lang="en-GB">Following the linking operation, an executable binary program is created. Let’s now type the following:</p>&#13;
			<p lang="en-GB"><code>./myProg ; </code><code>echo $?</code></p>&#13;
			<p lang="en-GB">The <code>myProg</code> binary code is executed and a message is displayed. A semicolon in Linux allows two commands to be put on the same line; the two operations are <em class="italic">execute a program </em>and <em class="italic">display </em><em class="italic">a message</em>.</p>&#13;
			<p lang="en-GB">The <code>echo $?</code> command prints a message from the executed program. The print command is <code>echo</code> and <code>$?</code> indicates the actual message to be printed. In this case, the <code>$?</code> command returns the exit status of the last command. You can print other messages; for example, <code>$3</code> prints the contents of register <code>r3</code>.</p>&#13;
			<p lang="en-GB">Note that if a program crashes or goes into an endless loop (non-responsive), you can enter <code>control-C</code> to escape and return to the OS level.</p>&#13;
			<h2 id="_idParaDest-160" lang="en-GB"><a id="_idTextAnchor173"/>Debugging assembly language</h2>&#13;
			<p lang="en-GB">We will now introduce the ARM <a id="_idIndexMarker602"/>debugger that lets you monitor the execution of a program and trace code just as we did with the simulators of <a href="B19624_06.xhtml#_idTextAnchor091"><em class="italic">Chapter 6</em></a> and <a href="B19624_07.xhtml#_idTextAnchor121"><em class="italic">Chapter 7</em></a>.</p>&#13;
			<p lang="en-GB">What we want is the ability to monitor the execution of an assembly language program, a task that we’ve already done when running Python computer simulators. We can do this with a <em class="italic">debugger</em>, called <code>gdb</code>, which is part of the GCC compiler suite. Consider the following example:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
as -g –o myProg.o myProg.s       # Assemble myProg.s Note the -g parameter&#13;
ld –o myProg myProg.o            # Link myProg.o to create source code myProg</pre>&#13;
			<pre class="source-code">gdb myProg                       # Run the debugger</pre>&#13;
			<p lang="en-GB">The <code>-g</code> parameter in the assembler section generates information for later use by the <code>gdb</code> debugger.</p>&#13;
			<p lang="en-GB"><code>gdb</code> is a very powerful tool with the facilities required to debug a program. We are going to look at only these facilities that allow us to run an ARM assembly language program and observe its execution, line by line. We begin by listing some of <code>gdb</code>’s commands. These commands can be abbreviated; for example, the <code>quit</code> command can be entered as q. In <em class="italic">Table 9.1</em>, we put the required part of the command in bold, and the part of the command that can be omitted in gray, such as quit. Note the difference between <code>next</code> and <code>step</code>. These are the same except <a id="_idIndexMarker603"/>when they encounter a <em class="italic">function</em>. Step traces all the operations in a function, whereas next treats the function as a single instruction and does not trace it.</p>&#13;
			<p lang="en-GB">When you load a program into <code>gdb</code>, nothing appears to happen. If you try to look at your assembly language code or the registers, you will get an error message. You must explicitly run the program first.</p>&#13;
			<table id="table001-7" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Command</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Effect</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">quit</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Quit: leave the gdb debugger and return to the shell. Ctrl + D also exits gdb.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">list</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">List: list the program being debugged.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">run</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Run: execute the program. The program will run to completion or to a breakpoint.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">break</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Breakpoint: Execution runs until a breakpoint is encountered. The breakpoint can be a line number, an address, or a label.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">info r</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Info: show registers. This command displays register contents.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">info b</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Info: show breakpoints. This displays breakpoints.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">continue</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Continue: resume execution after a breakpoint.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">delete</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Delete: remove a breakpoint. Enter <code>d &lt;number&gt;</code> to remove a specific breakpoint.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">next</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Single step (execute one instruction). This does not trace a function.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">step</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Single step including all the operations in a function.</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">file &lt;name&gt;</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Load a binary code file into gdb for debugging.</p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.1 – Basic gdb commands</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Let’s write and debug an ARM program on the Raspberry Pi. We haven’t covered the ARM architecture yet. You don’t need to know a lot about the ARM to follow the example because it’s similar to the RISC architectures we simulated in <a href="B19624_06.xhtml#_idTextAnchor091"><em class="italic">Chapter 6</em></a>. The ARM is a 32-bit computer with an RSIC architecture; that is, it is a load/store computer and the only memory accesses allowed are load and store. Operations on data are register-to-register using three operands – for example, <code>add r1,r2,r3</code>. The ARM has 16 registers, <code>r0</code> to <code>r15</code>. Registers <code>r0</code> to <code>r12</code> can be treated as general-purpose (i.e., they all behave in the same way). Registers <code>r13</code>, <code>r14</code>, and <code>r15</code> have specific functions.</p>&#13;
			<h3 lang="en-GB">Pseudo instructions – a key concept</h3>&#13;
			<p lang="en-GB">The ARM assembler includes <em class="italic">pseudo-instructions</em> that are not part <a id="_idIndexMarker604"/>of the ARM’s <code>clr</code> <code>r0</code> instruction that loads <code>r0</code> with <code>0</code>. A pseudo-instruction, <code>clr r0</code>, could be devised and the assembler could automatically replace it with the <code>sub r0</code>,<code>r0</code> operation, which has the same effect.</p>&#13;
			<p lang="en-GB">Pseudo-instructions make the programmer’s life easier; for example, the ARM’s <code>adr</code> r0,<code>abc</code> pseudo-instruction loads a 32-bit address, ABC, into <code>r0</code>. Such an instruction does not exist; the assembler replaces adr with the appropriate ARM instructions.</p>&#13;
			<h4 lang="en-GB">An example of an ARM program</h4>&#13;
			<p lang="en-GB">Suppose we wish to generate the sum <a id="_idIndexMarker606"/>of the cubes of numbers from 1 to 10. The following ARM code implements this algorithm. It also uses the ARM’s four-operand <em class="italic">multiply and </em><em class="italic">accumulate</em>, <code>mla</code>:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
       mov   <strong class="bold">r0</strong>,#0           @ Clear the total in r0&#13;
       mov   <strong class="bold">r1</strong>,#4           @ FOR i = 1 to 4 (count down)&#13;
<strong class="bold">Next:</strong>  mul   <strong class="bold">r2</strong>,r1,r1        /* Square a number */&#13;
       mla   <strong class="bold">r0</strong>,r2,r1,r0     @ Cube the number and add to total&#13;
       subs  <strong class="bold">r1</strong>,r1,#1        @ Decrement counter (and set condition flags)&#13;
       bne   <strong class="bold">Next</strong>            @ END FOR (branch back on count not zero)</pre>&#13;
			<p lang="en-GB">The label field beginning in the first column (bold in the preceding code) provides a <em class="italic">user-defined</em> tag that must be terminated by a colon. The label field is followed by the instruction consisting of an operation and any required operands. It doesn’t matter if there is more than one space after commas in argument lists. The text following the <code>@</code> symbol is a comment field and is ignored by the assembler. The GCC compiler also supports the C language style of comments: text delimited by <code>/*  */</code> characters, as this example shows.</p>&#13;
			<p lang="en-GB"><em class="italic">Table 9.2</em> describes some of the ARM’s instructions. There is only one surprise here; the <code>mla</code> <em class="italic">multiply and add instruction</em> that specifies <em class="italic">four</em> registers. It multiplies two registers together and adds a third register, and then puts the sum in a fourth register; that is, it can calculate <code>A = B + </code><code>C.D</code>:</p>&#13;
			<table id="table002-5" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><strong class="bold">Instruction</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><strong class="bold">ARM mnemonic</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><strong class="bold">Definition</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Addition</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>add </code>r0<code>,r1,r2</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">[r0] ← [r1] + [r2]</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Subtraction</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>sub </code>r0<code>,r1,r2</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">[r0] ← [r1] - [r2]</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">AND</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>and </code>r0<code>,r1,r2</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">[r0] ← [r1] ∧ [r2]</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">OR</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>orr </code>r0<code>,r1,r2</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">[r0] ← [r1] ∨ [r2]</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Exclusive OR</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>eor </code>r0<code>,r1,r2</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">[r0] ← [r1] ⊕ [r2]</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Multiply</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>mul </code>r0<code>,r1,r2</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">[r0] ← [r1] × [r2]</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">Register-to-register move</p>&#13;
							<p lang="en-GB">Literal-to-register move</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB"><code>mov </code>r0<code>,r1</code></p>&#13;
							<p lang="en-GB"><code>mov </code>r0<code>,#0xAB</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">[r0] ← [r1]</p>&#13;
							<p lang="en-GB">[r0] ← 0xAB Move 8-bit literal</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Compare</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>cmp </code>r1<code>,r2</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">[r1] – [r2]</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Branch on zero to label</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>beq label</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">[PC] ← label (jump to label if z = 1)</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Branch on not zero to label</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>bne label</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">[PC] ← label (jump to label if z = 0)</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Multiply and add</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>mla </code>r0<code>,r1,r2,r3</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">[r0] ← [r1] x [r2] + [r3]</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Load register from memory</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>ldr </code>r0<code>,[r1]</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">[r0] ← [[r1]]</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Store register in memory</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>str r0,</code>[r1]</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">[[r1]] ← [r0]</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Call the operating system</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><code>svc 0</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Request an operation from the OS</p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.2 – ARM data processing, data transfer, and compare instructions</p>&#13;
			<p lang="en-GB">Some computers always update condition <a id="_idIndexMarker607"/>codes after an operation. The ARM does not automatically update its status flags after an operation; you have to command a status update by appending s to the appropriate mnemonic. For example, <code>add </code>r1<code>,r2,r3</code> performs an addition without updating status flags, whereas <code>add</code>s<code> </code>r1<code>,r2,r3</code> updates status flags. This is not yet a program. The following provides the code and assembly language directives needed to run it on the Raspberry Pi:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
        <strong class="bold">.global _start</strong>        @ Provide entry point&#13;
<strong class="bold">_start:</strong> mov   <strong class="bold">r0,</strong>#0           @ Clear the total in r0&#13;
        mov   <strong class="bold">r1,</strong>#10          @ FOR i = 1 to 10 (count down)&#13;
Next:   mul   <strong class="bold">r2,</strong>r1,r1        /* Square a number. Note the C style comment */&#13;
        mla   <strong class="bold">r0,</strong>r2,r1,r0     @ Cube the number and add to total&#13;
        subs  <strong class="bold">r1,</strong>r1,#1        @ Decrement counter (set condition flags)&#13;
        bne   Next            @ END FOR (branch back on count not zero)&#13;
        mov   r7,#1           @ r7 contains 1 to indicate a leave request&#13;
        svc   #0              @ Call operating system to exit this code</pre>&#13;
			<p lang="en-GB">We’ve added an assembly language directive, <code>.global</code>, that declares the <code>_start</code> label as being <em class="italic">visible</em> outside this fragment of code. The GCC linking process links together separately assembled modules and inserts the appropriate addresses of the labels in the code.</p>&#13;
			<p lang="en-GB">By declaring a label as global, you are telling the linker that this label is visible to other modules and they can refer to it. Labels without a global directive are local to the current module and invisible to all other modules; that is, you could use the same label in two modules and there would not be a conflict.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The <code>_start</code> label indicates the point at which execution begins. The linker and operating system deal with storing the program in memory; that is, you don’t have to worry about where it is going to be actually stored in the computer’s physical memory.</p>&#13;
			<p lang="en-GB">Finally, the last two operations (shaded) provide a means of getting back to the operating system level once the code has been executed. ARM has an <code>svc</code> instruction, which stands for <em class="italic">service call</em> and is used to invoke the operating system. Most computers have an operation such as <code>svc</code> and it has many names – for example, <em class="italic">software interrupt</em>. This instruction calls the operating system and supplies one or more parameters. The parameter can be part of the instruction itself or it <a id="_idIndexMarker608"/>can be loaded into a register. When the operating system detects a service call, the parameter is read and the appropriate operation is performed. This action is entirely system dependent; that is, it is part of the operating system and not part of the computer’s architecture.</p>&#13;
			<p lang="en-GB">In this case, the specific function required by the service call is pre-loaded into <code>r7</code>. This mechanism is part of the Raspberry Pi’s operating system.</p>&#13;
			<p lang="en-GB">Key points to note about the assembly language program are as follows:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">Comments are preceded by an <code>@</code> symbol (or the C language <code>/*  */</code> book ends)</li>&#13;
				<li lang="en-GB">Assembler directives are preceded by a period</li>&#13;
				<li lang="en-GB">Labels begin in the first column and are terminated by a colon</li>&#13;
				<li lang="en-GB">An <code>.end</code> directive can be used to terminate the assembly language (it’s optional)</li>&#13;
				<li lang="en-GB">The <code>.global</code> directive provides a label that indicates the entry point of the program</li>&#13;
			</ul>&#13;
			<h2 id="_idParaDest-161" lang="en-GB"><a id="_idTextAnchor174"/>Using the Raspberry Pi debugger</h2>&#13;
			<p lang="en-GB">We can now run an ARM assembly language program and observe its execution, line by line, using gdb. When you load a program into gdb, nothing appears <a id="_idIndexMarker609"/>to happen. If you try to look at your assembly language code or the registers, you will get an error message. You must explicitly run the program first.</p>&#13;
			<p lang="en-GB">Consider the fragment of code in <em class="italic">Figure 9</em><em class="italic">.8</em>. This is a screenshot of the program after it’s been loaded into the Geany editor. It’s just a set of instructions and directives intended to demonstrate the steps involved in creating and testing an assembly language program. Here, we are using the Geany editor. The program demonstrates the following assembly language directives:</p>&#13;
			<ul>&#13;
				<li lang="en-GB"><code>.data</code>    Defines a memory region where variables and constants are stored.</li>&#13;
				<li lang="en-GB"><code>.text</code>    Defines a region of code (i.e., the assembly language).</li>&#13;
				<li lang="en-GB"><code>.word</code>    Allows you to store a number in memory and give the location a symbolic address.</li>&#13;
				<li lang="en-GB"><code>.balign</code>  Aligns code and text on a 4-byte boundary. Required because instructions are 32 bits.</li>&#13;
				<li lang="en-GB"><code>.asciz</code>   Creates an ASCII text string terminated by zero in memory and gives it a name.</li>&#13;
				<li lang="en-GB"><code>.global</code>  Makes a label visible to the linker. Otherwise, it is private to this module.</li>&#13;
			</ul>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The <code>balign</code> operation is required because memory is byte addressed and ARM instructions are 4 bytes long. Consequently, instruction addresses must be 0, 4, 8, 12, 16, 20, and so on. If you put data elements in memory that are not multiples of 4 bytes (32 bits) between instructions, the program will crash. The <code>balign</code> instruction pads out any data you store with zeros to ensure that the next free address is on a 4-byte boundary.</p>&#13;
			<p lang="en-GB">Note that the code in <em class="italic">Figure 9</em><em class="italic">.8</em> uses a <em class="italic">pseudo-instruction</em>. The instruction <code>ldr</code> r4<code>,=Alan3</code> loads <code>r4</code> with the 32-bit literal, <code>Alan3</code>. The assembler will automatically substitute the necessary ARM code to perform this operation.</p>&#13;
			<p lang="en-GB">The next step is to assemble and link the code, which we called a4.s (I got fed up with typing long names and called the source program a4.s). We can do this with the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
pi@raspberrypi:~ $ <strong class="bold">cd Desktop</strong>                     # Change to Desktop directory&#13;
pi@raspberrypi:~/Desktop $ <strong class="bold">as -g -o a4.o a4.s</strong>     # Assemble the program a4.s&#13;
pi@raspberrypi:~/Desktop $ <strong class="bold">ld -o a4 a4.o</strong>          # Now link it to create executable&#13;
pi@raspberrypi:~/Desktop $ <strong class="bold">./a4 ; echo $?</strong>         # Run the executable program a4</pre>&#13;
			<p lang="en-GB">The text in bold is my input. These lines change the <a id="_idIndexMarker610"/>working directory to Desktop where my source program is, and then assemble and link the source program. The final line, <code>./a4 ; echo $?</code>, runs the program and prints its return value (showing it’s been successfully executed by printing <code>4</code>, the value in <code>r0</code>).</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_9.08_B19624.jpg" alt="Figure 9.8 – The demonstration program in the Geany editor" width="1528" height="1036"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 9.8 – The demonstration program in the Geany editor</p>&#13;
			<p lang="en-GB">The following four lines demonstrate how we call the gdb debugger and set a breakpoint. Text in bold font indicates lines entered from the keyboard. The other text is the debugger’s output:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
pi@raspberrypi:~/Desktop <strong class="bold">$ gdb a4</strong>&#13;
Reading symbols from a4...done.&#13;
(gdb) <strong class="bold">b _start</strong>&#13;
Breakpoint 1 at 0x10074: file a4.s, line 14.</pre>&#13;
			<p lang="en-GB">Entering a breakpoint is done by b &lt;breakpoint&gt;, where the breakpoint is a line number or a label. Here, it’s _start. If we run the code, it executes instructions up to the breakpoint. The next few lines are as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) <strong class="bold">run</strong>&#13;
Starting program: /home/pi/Desktop/a4&#13;
Breakpoint 1, _start () at a4.s:14&#13;
14    _start: mov r0,#4             @ Enter here (first instruction)</pre>&#13;
			<p lang="en-GB">Note that you can continue from a <a id="_idIndexMarker611"/>breakpoint by entering <code>c</code> (i.e., continue) and execution will continue to the next breakpoint.</p>&#13;
			<p lang="en-GB">After entering a run command, the debugger begins execution and prints the next line to be executed – that is, the line labeled by _start. The gdb instruction i r (information registers) displays the ARM’s registers as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) i r&#13;
r0             0x0                 0&#13;
r1             0x0                 0&#13;
r2             0x0                 0&#13;
r3             0x0                 0&#13;
r4             0x0                 0&#13;
r5             0x0                 0&#13;
r6             0x0                 0&#13;
r7             0x0                 0&#13;
r8             0x0                 0&#13;
r9             0x0                 0&#13;
r10            0x0                 0&#13;
r11            0x0                 0&#13;
r12            0x0                 0&#13;
sp             0xbefff390          0xbefff390&#13;
lr             0x0                 0&#13;
pc             0x10074             0x10074 &lt;_start&gt;&#13;
cpsr           0x10                16</pre>&#13;
			<pre class="source-code">fpscr          0x0                 0</pre>&#13;
			<p lang="en-GB"><code>cpsr</code> and <code>fpscr</code> are both status registers that contain information about the state of the processor.</p>&#13;
			<p lang="en-GB">All registers have been initialized to zero automatically by the system software, except r13, r15 (<code>sp, pc</code>), and the two status registers. We can now start tracing the code, executing instructions one by one with the step command, <code>s 1</code>. You can just hit <code>enter</code> to trace the next instruction, as the following output demonstrates. If you were to type si 2 (or s 2), you would step two instructions:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<strong class="bold">(gdb) si 1</strong>&#13;
15            mov r1,#9&#13;
<strong class="bold">(gdb)</strong>&#13;
16            add r2,r0,r1&#13;
<strong class="bold">(gdb)</strong>&#13;
17            sub r3,r2,#3&#13;
<strong class="bold">(gdb)</strong>&#13;
18            ldr r4,=Alan3         @ Load an address into r4&#13;
<strong class="bold">(gdb)</strong>&#13;
19            ldr r5,[r4]           @ And pick up a word from memory</pre>&#13;
			<p lang="en-GB">Let’s look at the registers using the i r command. We have removed registers from this list that haven’t changed to make it easier to read. Register contents <a id="_idIndexMarker612"/>are given in hex and decimal formats:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<strong class="bold">(gdb) i r</strong>&#13;
r0             0x4                 4&#13;
r1             0x9                 9&#13;
<strong class="bold">r2             0xd                 13</strong> Note: r2 is expressed in hex and decimal&#13;
r3             0xa                 10&#13;
r4             0x200a0             131232&#13;
r5             0x0                 0&#13;
pc             0x10088             0x10088 &lt;_start+20&gt; Note: 20 bytes from start</pre>&#13;
			<p lang="en-GB">Finally, we will continue stepping until the code has been executed. You can step just by using the <em class="italic">enter</em> key after the first si 1 command:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) <strong class="bold">si 1</strong>&#13;
21            mov r7,#1             @ Prepare to exit&#13;
(gdb)&#13;
22            svc 0                 @ Go&#13;
(gdb)</pre>&#13;
			<pre class="source-code">[Inferior 1 (process 1163) exited with code 04]</pre>&#13;
			<p lang="en-GB">The gdb executes the move and supervisor <a id="_idIndexMarker613"/>call instruction and exits the simulation. What have we learned? This example demonstrates the following:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">How to create an ARM assembly language program</li>&#13;
				<li lang="en-GB">How to assemble and link it</li>&#13;
				<li lang="en-GB">How to load it into the gdb debugger</li>&#13;
				<li lang="en-GB">How to set breakpoints and run the code until a breakpoint is reached</li>&#13;
				<li lang="en-GB">How to display the contents of registers at any point in a program</li>&#13;
				<li lang="en-GB">How to step through the code line by line</li>&#13;
			</ul>&#13;
			<h3 lang="en-GB">Tracing execution and displaying memory</h3>&#13;
			<p lang="en-GB">An important facility of a debugger is the ability to step through the code and display registers while executing a program. This allows you to follow the execution <a id="_idIndexMarker614"/>of a program and detect errors. The gdb debugger incorporates this facility via its <code>l<a id="_idTextAnchor175"/>ayout regs</code>.</p>&#13;
			<p lang="en-GB"><em class="italic">Figure 9</em><em class="italic">.9</em> provides a demonstration of the TUI with three panels. The upper window is the register window (the registers that have changed <a id="_idIndexMarker616"/>are highlighted; in this case, it’s <code>r7</code>). The middle panel displays the program code, with the next instruction to be executed highlighted. Each line includes the memory address of the code in hexadecimal form and as a distance from the <code>start</code> label.</p>&#13;
			<p lang="en-GB">Note that the code continues after my last instruction, <code>svc</code>. This is because the disassembler reads a block of memory and displays it as code (even if it is not part of your program). In this case, the data we entered in memory with the <code>.word</code> directive is read and displayed as the corresponding ARM instruction. Remember that the debugger does not know whether a binary value in memory is an instruction or user data. If it reads a data value corresponding to an instruction op-code, it prints that op-code.</p>&#13;
			<p lang="en-GB">The disassembled instructions display their address in memory in hex form; for example, the first instruction is at <code>0x10074</code>. This address is determined by Raspberry Pi’s operating system. As you can see, each instruction has an address 4 bytes greater than the previous one because the ARM is a 32-bit machine with 32-bit, or 4-byte, instructions; hence the need for the align directive that forces the next instruction or data onto a specific boundary.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The bottommost panel contains the commands you enter. In this case, I’ve used <code>si 1</code> to step through the instructions.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_9.09_B19624.jpg" alt="Figure 9.9 – The TUI showing registers and memory contents" width="982" height="1113"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – The TUI showing registers and memory contents</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Let’s look at another example of an <a id="_idIndexMarker617"/>assembly language <a id="_idIndexMarker618"/>program and its debugging. This example is designed only for demonstration purposes. It doesn’t do anything useful. Our intention is to demonstrate the features of an ARM assembly language program running under the GCC assembler and the gdb debugger. <em class="italic">Table 9.3</em> gives some of GCC’s most common assembler directives.</p>&#13;
			<table id="table003-3" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">GCC </strong><strong class="bold">Assembly directive</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Action</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">.text</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Indicates a program segment containing code</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">.data</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Indicates a program segment containing data</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">.global<code> label</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Makes the label visible to the linker</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">.extern<code> label</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Makes the label visible outside the file</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">.byte<code> </code><code>byte1,byte2, …</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Defines one or more bytes of data and stores them in memory</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">.hword<code> </code><code>hw1,hw2, …</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Defines 1 or more 16-bit halfwords and stores them in memory</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">.word<code> </code><code>w1,w2, …</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Defines 1 or more 32-bit words and stores them in memory</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">.space<code> bytes,fill</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Fills a block of memory with a given value (e.g., <code>.</code><code>fill</code> <code>64</code>,<code>0xFF</code>)</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>.</code>balign 4</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Aligns next address to a 4-byte boundary (you can also use 2, 4, 8, and 16)</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">.ascii<code> "</code><code>any string"</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Stores an ASCII string in memory</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">.asciz<code> "</code><code>any string"</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Stores an ASCII string in memory terminated by 0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">.equ<code> </code><code>symbol, value</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Equates the symbolic name to its value (e.g., <code>.equ </code><code>hours 24</code>)</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">.end</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Marks the end of a program</p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.3 – GCC ARM assembler directives</p>&#13;
			<p lang="en-GB">We have presented a more detailed <a id="_idIndexMarker619"/>explanation of some of the features of the program; these are of the form <code>@ PRINT </code><code>STRING @</code>:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
                                @ Test function calls and memory access&#13;
<a id="_idTextAnchor176"/>         .text                  @ Program (code) area&#13;
         .global  _start        @ Provide entry point and make it known to linker&#13;
         .equ     v1,0xAB       @ Test equate directive&#13;
_start:   mov     r0,#23        @ Just three dummy operations for debugging&#13;
          mov     r1,#v1        @ ARM assembler uses # to indicate a literal&#13;
          add     r2,r0,r1</pre>&#13;
			<h4 lang="en-GB">@ PRINT STRING ON CONSOLE @</h4>&#13;
			<pre class="source-code" lang="en-GB">&#13;
          ldr     r1, =banner   @ Test display function (this is a pseudo-instruction)&#13;
          mov     r2,#15        @ Number of characters to print 13 plus two newlines)&#13;
          mov     r0,#1         @ Tell the OS we want to print on console display&#13;
          <strong class="bold">mov     r7,#4</strong>         @ Tell the OS we want to perform a print operation</pre>&#13;
			<pre class="source-code">          svc     0             @ Call the operating system to do the printing</pre>&#13;
			<h4 lang="en-GB">@ USING ADR @</h4>&#13;
			<pre class="source-code" lang="en-GB">&#13;
          adr     r3,v3              @ Load address of v3 into register r3 (a pseudo-instruction)&#13;
          ldr     r4,[r3]            @ Read contents of v3 in memory&#13;
                                     @ Read from memory, increment and store in next location&#13;
          ldr     r0,adr_dat1        @ r0 is a pointer to dat1 in memory&#13;
          ldr     r1,[r0]            @ Load r1 with the contents of dat1&#13;
          add     r2,r1,#1           @ Add 1 to dat1 and put in r2&#13;
          add     r3,r0,#4           @ Use r3 to point to next memory location after dat1&#13;
          str     r2,[r3]            @ Store new data in location after dat1</pre>&#13;
			<h4 lang="en-GB">@ EXITING THE PROGRAM @</h4>&#13;
			<pre class="source-code" lang="en-GB">&#13;
          mov     r0,#0              @ Exit status code (0 indicates OK)&#13;
          mov     r7,#1              @ Tell the OS we want to return from this program&#13;
          svc     0                  @ Call the operating system to return</pre>&#13;
			<h4 lang="en-GB">@ THE ADDRESS VECTOR @</h4>&#13;
			<pre class="source-code" lang="en-GB">&#13;
adr_dat1: .word   dat1               @ Generate an address for dat1 in the memory area&#13;
v2:       .word   0xFACE             @ Dummy data&#13;
banner:   .ascii "\nTest printing\n" @ String to print. Note newlines "\n"&#13;
                                     @ This string has 15 characters (13 ASCII two newlines)&#13;
          .balign 4                  @ Align data (0 inserted because the string is 15 chars)&#13;
v3:       .word   0x1111             @ Dummy test data&#13;
          .space  4,0xAB             @ Reserve 8 bytes of storage and fill with 0xAB&#13;
          .word   0x2222&#13;
          .data                      @ Data segment&#13;
test:     .word 0xbbbb&#13;
dat1:     .word 0x1234&#13;
          .end                       @ End of this program</pre>&#13;
			<p lang="en-GB">This code illustrates several points – for example, the use of assembler directives such as<code>.equ</code>, which binds a symbolic name to a value. I’ve shaded <a id="_idIndexMarker620"/>interesting blocks of code so that we can discuss them.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">We have used ARM’s pseudo-instructions. These are <code>adr </code>r3<code>,v3 and ldr </code>r1<code>,=banner</code>. These both load 32-bit addresses into a register. Such instructions don’t exist. The ARM assembler chooses real instructions to perform the required actions.</p>&#13;
			<h4 lang="en-GB">@ PRINT STRING @</h4>&#13;
			<p lang="en-GB">The first block demonstrates how we can print data from an assembly program. Well, in fact, we can’t print the data but we can ask the operating system to do it for us. Most processors have an instruction called a <em class="italic">software interrupt</em> (or a system call, a trap, an exception, or an <em class="italic">extra code</em>). All these terms refer to the same thing: an instruction inserted by the programmer that invokes the operating system. In the case of ARM, it’s the svc instruction (previously called swi). When used by Linux, this instruction is called with the parameter <code>0</code> – that is <code>svc 0</code>.</p>&#13;
			<p lang="en-GB">The system call is entirely operating-system-dependent and <a id="_idIndexMarker621"/>tells the operating system what it needs by passing parameters in registers. We are going to print a string of characters on the display. The Raspberry Pi OS needs the location of the string in memory to be passed in register r1, the number of characters to print in register <code>r2</code>, the type of the display in <code>r0</code>, and the operation to be performed (printing) in <code>r7</code>.</p>&#13;
			<p lang="en-GB">The address of the text to be printed, <code>banner</code>, is loaded into <code>r1</code> by <code>ldr</code> r1<code>,=banner</code>. This pseudo-instruction takes an address specified by <code>=&lt;address&gt;</code>. In the program, we have used the <code>.ascii</code> directive to store the string to print in memory. The string is text with <code>\n</code> at each end, which corresponds to the newline character. Note that the newline character code is 1 byte, although it is represented in the program by <code>\n</code>. Unless a string or other data item stored in memory is a multiple of 4 bytes, you must follow it with a <code>.balign 4</code> to ensure that the next instruction falls on a word boundary.</p>&#13;
			<h4 lang="en-GB">@ USING ADR @</h4>&#13;
			<p lang="en-GB">The second block demonstrates the use of an <code>adr</code> pseudo-instruction with <code>adr </code>r3<code>,v3</code>. We are going to load register <code>r3</code> with the address of a variable we’ve called <code>v3</code> and loaded into memory with a <code>.word</code> directive. One practical consideration is that when you disassemble the code, you will not see <code>adr</code>; you’ll see the actual code that the ARM assembler translated it into.</p>&#13;
			<p lang="en-GB">Putting the address of the <code>v3</code> variable into a register means we can use that register as a pointer with a load instruction; for example, <code>ldr </code>r4<code>,[r3]</code> loads the value of the variable (i.e., <code>0x1111</code> ) into <code>r4</code>. If you wish to modify that variable, you might think that you could store it back in memory with <code>str r5,</code>[r3]. Sadly not! The <code>adr</code> instruction generates code that allows you to access only the current segment of the program. That segment is read-only because it contains the code. You cannot alter memory in that segment. If you wish to modify memory, you have to use a different technique, as we will soon see.</p>&#13;
			<h4 lang="en-GB">@ EXITING THE PROGRAM @</h4>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">After an assembly language program has been executed to completion, it is necessary to return to the operating system level. Register <code>r7</code> is loaded with an exit code of <code>1</code> and an <code>svc 0</code> instruction executed to call the operating system. By convention, programmers load register r0 with their own exit code before exiting. An exit code of <code>0</code> is often used to indicate all went well, and an exit code of <code>1</code> indicates it didn’t.</p>&#13;
			<h4 lang="en-GB">@ THE ADDRESS VECTOR @</h4>&#13;
			<p lang="en-GB">You can’t use the <code>adr</code> pseudo-instruction to write to read/write memory that is in a different segment to the code part of a program. This dilemma exists in all <a id="_idIndexMarker622"/>code development systems and is not peculiar to the ARM GCC environment. The ARM processor will allow you to read memory and write to memory anywhere within the logically addressable memory space. However, the ARM <em class="italic">operating system</em> does not let you write to regions of read-only memory or other forbidden areas. The trick is to create a pointer to the variable and store that pointer in the code segment.</p>&#13;
			<p lang="en-GB">Consider the following assembler directive. This stores a 32-bit <code>dat1</code> value in memory at location <code>adr_dat1</code>. By convention, some programmers indicate that an item is a pointer (i.e., address) by prefixing its name with a marker (typically <code>adr</code>). This is not a rule but a convention:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_9.10_B19624.jpg" alt="Figure 9.10 - Creating a pointer to a data value" width="1182" height="234"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 - Creating a pointer to a data value</p>&#13;
			<p lang="en-GB">We have created a name, <code>adr_dat1</code>, which is the <em class="italic">address</em> of the address of our target variable. The value stored is the address of the actual variable, <code>dat1</code>. So, when we write the instruction <code>ldr r0,adr_dat1</code>, the <em class="italic">address</em> of <code>dat1</code> is loaded in register <code>r0</code>. That is, register <code>r0</code> now points to <code>dat1</code>.</p>&#13;
			<p lang="en-GB">In the data section headed by <code>.data</code>, we have the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
dat1:     .word 0x1234   @ The value 0x1234 is stored in memory at address dat1</pre>&#13;
			<p lang="en-GB">This stores the <code>0x1234</code> value in memory and gives it the name <code>dat1</code>. As we have seen, that name is used to create the address of the variable in the code section by the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
adr_dat1: .word   dat1</pre>&#13;
			<p lang="en-GB">The next step is to run the code. We’ve done this and have provided an edited output from the session (removing empty prompt lines between operations and some text) in <em class="italic">Listing 9.1</em>:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<code>pi@raspberrypi:~ $ cd Desktop</code>&#13;
<code>pi@raspberrypi:~/Desktop $ as -g -o t1a.o t1a.s</code>&#13;
<code>pi@raspberrypi:~/Desktop $ ld -o t1a t1a.o</code>&#13;
<code>pi@raspberrypi:~/Desktop $ gdb</code>&#13;
<code>GNU gdb (Raspbian 8.2.1-2) 8.2.1</code>&#13;
<code>(gdb) file t1a</code>&#13;
<code>Reading symbols from t1a...done.</code>&#13;
(<code>gdb) b _start</code>&#13;
<code>Breakpoint 1 at 0x10074: file t1a.s, line 7.</code>&#13;
<code>(gdb) r 1</code>&#13;
<code>Starting program: /home/pi/Desktop/t1a 1</code>&#13;
<code>Breakpoint 1, _start () at t1a.s:7</code>&#13;
<code>7    _start: mov     r0,#23        </code>@ Just three dummy operations for debugging&#13;
<code>(gdb) si 1</code>&#13;
<code>8            mov     r1,#v1</code>&#13;
<code>9            add     r2,r0,r1</code>&#13;
<code>11           ldr     r1,=banner   </code>@ Test display function (r1 has address of a string)&#13;
<code>12           mov     r2,#15        </code>@ Number of characters to print 13 plus two newlines)&#13;
<code>13           mov     r0,#1         </code>@ Tell the OS we want to print on console display&#13;
<code>14           mov     r7,#4         </code>@ Tell the OS we want to perform a print operation&#13;
<code>15           svc     0             </code>@ Call the operating system to do the printing&#13;
Test printing&#13;
<code>17           adr     r3,v3         </code>@ Load address of v3&#13;
<code>18           ldr     r4,[r3]       </code>@ Read its contents in memory&#13;
<code>21           ldr     r0,adr_dat1   </code>@ r0 is a pointer to dat1 in memory&#13;
<code>22           ldr     r1,[r0]       </code>@ Load r1 with the contents of data1&#13;
<code>23           add     r2,r1,#1      </code>@ Add 1 to dat1 and put in r2&#13;
<code>24           add     r3,r0,#4      </code>@ Use r3 to point to next memory location after dat1&#13;
<code>25           str     r2,[r3]       </code>@ Store new data in location after dat1&#13;
<code>(gdb) i r r0 r1 r2 r3</code>&#13;
<code>r0           0x200e8             131304</code>&#13;
<code>r1           0x1234              4660</code>&#13;
<code>r2           0x1235              4661</code>&#13;
<code>r3           0x200ec             131308</code>&#13;
<code>(gdb) si 1</code>&#13;
<code>28          mov    r0,#0           </code>@ Exit status code (indicates OK)&#13;
<code>29          mov    r7,#1           </code>@ Tell the OS we want to return from this program&#13;
<code>30          svc    0               </code>@ Call the operating system to return&#13;
<code>(gdb) </code>x/2xw 0x200e8&#13;
<code>0x200e8:    0x00001234    0x00001235</code>&#13;
<code>(gdb) si 1</code>&#13;
<code>[Inferior 1 (process 7601) exited normally]</code></pre>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Listing 9.1 – A debugging session</p>&#13;
			<h2 id="_idParaDest-162" lang="en-GB"><a id="_idTextAnchor177"/>Accessing memory</h2>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">We have demonstrated how you can step through a program and display registers as instructions are executed. For example, gdb lets you display the contents of registers <code>r0</code> to <code>r3</code> using the <code>i r r0 r1 r2 r3</code> command. We will now demonstrate how the contents of memory locations can be displayed.</p>&#13;
			<p lang="en-GB">In <em class="italic">Listing 9.1</em>, we single-step the code through <a id="_idIndexMarker623"/>the first few instructions (memory access and store operations) and then, after line 25, we can see that the address of the <code>dat3</code> variable is <code>0x200e8</code>. Suppose we want to check that its value is <code>0x1234</code>, and that the next word location 4 bytes on, <code>0x2008c</code>, contains the <code>0x1235</code> value.</p>&#13;
			<p lang="en-GB">You might reasonably expect that the <code>gdb</code> command to read the memory location is <code>m</code> <code>0x200c</code>. As you can see from <em class="italic">Listing 9.1</em>, the command is the rather less memorable:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<a id="_idTextAnchor178"/>x/2xw 0x2208    Read the contents of two memory locations</pre>&#13;
			<p lang="en-GB">The memory access command is x/ and the three required parameters are 2xw. These are as follows:</p>&#13;
			<ul>&#13;
				<li lang="en-GB"><code>2</code>   The number of memory locations to be displayed.</li>&#13;
				<li lang="en-GB"><code>x</code>   The format of the data. <code>x</code> indicates hexadecimal.</li>&#13;
				<li lang="en-GB"><code>w</code>   The width of the data (number of bytes). <code>w</code> indicates a 4-byte 32-bit word.</li>&#13;
			</ul>&#13;
			<p lang="en-GB">The available formats are as follows:</p>&#13;
			<ul>&#13;
				<li lang="en-GB"><code>o</code>   octal</li>&#13;
				<li lang="en-GB"><code>d</code>   decimal</li>&#13;
				<li lang="en-GB"><code>x</code>   hexadecimal</li>&#13;
				<li lang="en-GB"><code>u</code>   unsigned integer</li>&#13;
				<li lang="en-GB"><code>s</code>   string</li>&#13;
				<li lang="en-GB"><code>b</code>   byte</li>&#13;
			</ul>&#13;
			<p lang="en-GB">The data display sizes are as follows:</p>&#13;
			<ul>&#13;
				<li lang="en-GB"><code>b</code>   byte</li>&#13;
				<li lang="en-GB"><code>h</code>   halfword (16 bits)</li>&#13;
				<li lang="en-GB"><code>w</code>   word (32 bits)</li>&#13;
				<li lang="en-GB"><code>g</code>   double word (giant word of 8 bytes or 64 bits)</li>&#13;
			</ul>&#13;
			<p lang="en-GB">Consider these <a id="_idIndexMarker624"/>examples:</p>&#13;
			<ul>&#13;
				<li lang="en-GB"><code>x/1xw 0x1234</code>   Print one 4-byte word in hex form at address <code>0x1234</code></li>&#13;
				<li lang="en-GB"><code>x/6xh 0x1234</code>   Print six 2-byte values in hex form at address <code>0x1234</code></li>&#13;
				<li lang="en-GB"><code>x/3db 0x1234</code>   Print three one-byte values in decimal form at address <code>0x1234</code></li>&#13;
				<li lang="en-GB"><code>x/9sb 0x1234</code>   Print nine one-byte characters in string form at address <code>0x1234</code></li>&#13;
			</ul>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">In the next section, we are now going to look at the ARM GCC assembler in a little more detail. For example, we will introduce the ARM’s assembler directives that control the allocation of memory to a program.</p>&#13;
			<h1 id="_idParaDest-163" lang="en-GB"><a id="_idTextAnchor179"/>Features of the GCC ARM assembler</h1>&#13;
			<p lang="en-GB">We will begin this section by looking at how memory space can be reserved for constants and variables. We have already seen that <a id="_idIndexMarker625"/>literals in the ARM assembly language are prefixed by a <code>#</code> symbol. Numbers are regarded as decimal unless prefixed by <code>0x</code>, which indicates hexadecimal – for example, <code>mov r0,#0x2C</code>. ASCII characters are indicated by using single quotes, as in this example:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
      cmp   <strong class="bold">r0</strong>,#'A'            @ Was it a letter 'A'?</pre>&#13;
			<p lang="en-GB">Two important assembler directives are <code>.equ</code>, which binds a name to a value, and <code>.word</code>, which allows you to preload memory with data before a program runs. The <code>.equ</code> directive is very easy to understand; it binds a numeric value to a name. Consider the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
      .equ  Tuesday, 2</pre>&#13;
			<p lang="en-GB">This assembly directive binds the name <code>Tuesday</code> to the value <code>2</code>. Whenever you write <code>Tuesday</code>, the assembler replaces it with <code>2</code>. The GCC ARM <code>.word</code> assembler directive reserves memory space for constants and variables; that is, it declares a variable (or constant) and initializes it. Consider the following example:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
      .equ    Value1,12        @ Associate name Value1 with 12&#13;
      .equ    Value2,45        @ Associate name Value2 with 45&#13;
      .word   Table,Value1     @ Store the 32-bit word 12 in memory at address Table&#13;
      .word   Value2           @ Store the word 45 in memory&#13;
      .word   Value2 + 14      @ Store  45 + 14 = 59 in memory (you can use expressions)</pre>&#13;
			<p lang="en-GB">The <code>.word</code> directive reserves a 32-bit word (i.e., 4 bytes) of storage in memory and loads whatever value the expression to the right of <code>.word</code> yields into that location. In this case, we’ve bound <code>Value1</code> to the number <code>12</code> and, therefore, the binary value <code>00000000000000000000000000001100</code> will be stored at this location. The next memory location used is the next free location (i.e., storage directives store data in memory sequentially).</p>&#13;
			<p lang="en-GB">The <em class="italic">location counter</em> is advanced by four bytes so that the next <code>.word</code> or instruction will be placed in the next word in memory. The term <em class="italic">location counter</em> refers to the pointer to the next location in memory when a program is being assembled and is similar, in concept, to the program counter.</p>&#13;
			<p lang="en-GB">You don’t have to use 32-bit values in the ARM programs. The<code>.byte</code> and <code>.hword</code> assembler directives store a byte and a 16-bit halfword in memory, respectively, as in this example:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Q1:    .byte        25                  @ Store the byte 25 in memory&#13;
Q2:    .byte        42                  @ Store the byte 42 in memory&#13;
Tx2:   .hword       12342               @ Store the 16-bit halfword 12,342 in memory</pre>&#13;
			<p lang="en-GB">Although you could use <code>.byte</code> to store text strings in memory, it would be very clumsy because you would have to look up the ASCII value of each character. The GCC ARM assembler provides a simpler mechanism. The <code>.ascii</code> directive takes a string and <a id="_idIndexMarker626"/>stores each character as an 8-bit ASCII-encoded byte in consecutive memory locations. The <code>.asciz</code> command performs the same function but inserts an 8-bit binary byte of all 0s as a terminator:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Mess1: .ascii    "This is message 1"    @ Store string memory&#13;
Mess2: .asciz    "This is message 2"    @ Store string followed by 0&#13;
       .balign  4                       @ Align code on word boundary</pre>&#13;
			<p lang="en-GB">Because the ARM aligns all instructions on 32-bit word boundaries, the <code>.balign 4</code> directive is required to align whatever follows on the next word boundary (the 4 indicates a 4-byte boundary). In other words, if you store three 8-bit characters in memory, the <code>.balign 4</code> command skips a byte to force the next address to a 32-bit boundary. Note that <code>.balign 2</code> forces alignment on a halfword boundary (you can use <code>.balign 16</code>, or any other power of 2, to force the next memory access to be appropriately aligned).</p>&#13;
			<p lang="en-GB">The following ARM code demonstrates storage allocation and the use of the <code>.balign </code><code>4</code> directive:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
        .global  _start                 @ Tell the linker where we start from&#13;
        .text                           @ This is a text (code) segment&#13;
_start: mov     r0,#XX                  @ Load r0 with 5 (i.e., XX)&#13;
        mov     r1,#P1                  @ Load r1 with P1 which is equated to 0x12 or 18 decimal&#13;
        add     r2,r0,r1                @ Just a dummy instruction&#13;
        add     r3,r2,#YY               @ Test equate to ASCII byte (should be 0x42 for 'B')&#13;
        adr     r4,test                 @ Let's load an address (i.e., location of variable test)&#13;
        ldr     r5,[r4]                 @ Now, access that variable which should be 0xBB)&#13;
Again:  b       Again                   @ Eternal endless loop (terminate here)&#13;
       .equ     XX,5                    @ Equate XX to 5&#13;
       .equ     P1,0x12                 @ Equate P1 to 0x12&#13;
       .equ     YY,'B'                  @ Equate YY to the ASCII value for 'B'&#13;
       .ascii   "Hello"                 @ Store the ASCII byte string "Hello"&#13;
       .balign  4                       @ Ensure code is on a 32-bit word boundary&#13;
       .ascii   "Hello"                 @ Store the ASCII byte string "Hello"&#13;
       .byte    0xAA                    @ Store the byte 0xAA in memory&#13;
test:  .byte    0xBB                    @ Store the byte 0xBB in memory&#13;
       .balign  2                       @ Ensure code is on a 16-bit halfword boundary&#13;
       .hword   0xABCD                  @ Store the 16-bit halfword 0xABCD in memory&#13;
last:  .word    0x12345678              @ Store a 32-bit hex value in memory&#13;
       .end</pre>&#13;
			<p lang="en-GB">Let’s assemble, link, and run this <a id="_idIndexMarker627"/>code on a Raspberry Pi using gdb. The first few lines from the terminal windows show the loading of the program, setting a breakpoint, and executing in a single-step mode:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
pi@raspberrypi:~ $ cd Desktop&#13;
pi@raspberrypi:~/Desktop $ as -g -o labels.o labels.s&#13;
pi@raspberrypi:~/Desktop $ ld -o labels labels.o&#13;
pi@raspberrypi:~/Desktop $ gdb labels&#13;
GNU gdb (Raspbian 8.2.1-2) 8.2.1&#13;
Reading symbols from labels...done.&#13;
(gdb) b _start&#13;
Breakpoint 1 at 0x10054: file labels.s, line 3.&#13;
(gdb) run 1&#13;
Starting program: /home/pi/Desktop/labels 1&#13;
Breakpoint 1, _start () at labels.s:3&#13;
3    _start: mov     r0,#XX             @ Load r0 with 5 (i.e., XX)&#13;
(gdb) si 1&#13;
4            mov     r1,#P1             @ Load r1 with 0x12 (i.e., P1)&#13;
5            add     r2,r0,r1           @ Dummy instruction (r2 is 5+0x12=0x17)&#13;
6            add     r3,r2,#YY          @ Dummy instruction (r3 is 0x17+0x42=0x59)&#13;
7            adr     r4,test&#13;
8            ldr     r5,[r4]&#13;
Again () at labels.s:9&#13;
9    Again:  b       Again              @ Eternal endless loop (enter control-C to exit)</pre>&#13;
			<p lang="en-GB">So far, so good. Let’s see what the registers hold. We have deleted lines with registers that we’re not interested in to make the output more readable:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) i r&#13;
r0             0x5                 5&#13;
r1             0x12                18&#13;
r2             0x17                23&#13;
r3             0x59                89 Note 0x59 = 0x17 + 0x42&#13;
r4             0x1007e             65662&#13;
r5             0xabcd00bb          2882339003&#13;
pc             0x1006c Current pc     0x1006c &lt;Again&gt;</pre>&#13;
			<p lang="en-GB">Registers <code>r0</code> to <code>r3</code> contain what we would expect (<code>r3</code> is <code>0x17</code> in <code>r3</code> plus the <code>0x42</code> code for <code>'B'</code> which is <code>0x59</code>).</p>&#13;
			<p lang="en-GB">Register r4 contains <code>0x1007e</code>, which is the address of the data called <code>test</code>: (i.e., <code>0xBB</code>) in memory. That address is used to load the <code>0xBB</code> constant into <code>r5</code>, which now contains <code>0xABCD00BB</code> and not <code>0x000000BB</code> as we expected. What went wrong?</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The problem is that <code>ldr</code> loads a 32-bit value into a register from memory. <code>0xABCD00</code> is the word following <code>0xBB</code> plus a null byte due to the <code>.balign</code> <code>2</code> statement. We should have used a special <em class="italic">“load a byte”</em> instruction, loaded four bytes and cleared three to zero, or aligned the byte correctly in memory. The great strength of a computer is that it does what you tell it. Alas, its great weakness is that…it does <em class="italic">exactly</em> what you tell it.</p>&#13;
			<p lang="en-GB">Next, we look at the data stored in memory using the <code>x/7xw 0x1006c</code> command, which displays <code>7</code> words of memory in hexadecimal form starting at address <code>0x1006c</code> (we got that address from the <code>pc</code> in the register dump). Remember that it’s the ARM’s operating system that initially sets up the program counter:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) <strong class="bold">x/7xw 0x1006c</strong>&#13;
0x1006c &lt;Again&gt;:    0xeafffffe 0x6c6c6548 0x0000006f 0x6c6c6548&#13;
0x1007c &lt;Again+16&gt;: 0x00bbaa6f 0x5678abcd 0x00001234</pre>&#13;
			<p lang="en-GB">We can also look at the data stored in memory <a id="_idIndexMarker628"/>in byte form using <code>x/28xb 0x1006c</code>, which displays <code>7</code> words (4 x 7 = 28 bytes) of memory in hexadecimal form starting at address <code>0x1006c</code>:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) x/28xb 0x1006c&#13;
0x1006c &lt;Again&gt;:      0xfe   0xff   0xff   0xea   0x48   0x65   0x6c   0x6c&#13;
0x10074 &lt;Again+8&gt;:    0x6f   0x00   0x00   0x00   0x48   0x65   0x6c   0x6c&#13;
0x1007c &lt;Again+16&gt;:   0x6f   0xaa   0xbb   0x00   0xcd   0xab   0x78   0x56&#13;
0x10084 &lt;last+2&gt;:     0x34   0x12   0x00   0x00</pre>&#13;
			<p lang="en-GB"><em class="italic">Figure 9</em><em class="italic">.10</em> provides a memory map demonstrating the allocation of memory. The bold hexadecimal addresses are the 4-byte word boundaries. You can see how the <code>.balign</code> directives insert zeros as padding in memory to form the required boundaries.</p>&#13;
			<p lang="en-GB">In the next section, we look at one of the key aspects of modern computer design – how a computer with a 32-bit word length can load a 32-bit value into a register:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
000000010070     <code>48</code>             ASCII H start of the sequence Hello&#13;
<code>000000000071</code>     <code>65</code>             ASCII e&#13;
<code>000000000072</code>     <code>6C</code>             ASCII l&#13;
<code>000000000073</code>     <code>6C</code>             ASCII l&#13;
000000000074     <code>6F</code>             ASCII o&#13;
<code>000000000075</code>     <code>00</code>             Padded zero due to align&#13;
<code>000000000076</code>     <code>00</code>             Padded zero due to align&#13;
<code>000000000077</code>     <code>0</code>              Padded zero due to align&#13;
000000010078     <code>48</code>             ASCII H&#13;
<code>000000000079</code>     <code>65</code>             ASCII e&#13;
<code>00000000007A</code>     <code>6C</code>             ASCII l&#13;
<code>00000000007B</code>     <code>6C</code>             ASCII l&#13;
00000000007C     6C             ASCII o&#13;
<code>00000000007D</code>     <code>0xAA</code>           Byte 0xAA&#13;
<code>00000000007E</code>     <code>0xBB</code>           Byte 0xBB&#13;
<code>00000000007F</code>     <code>00</code>             Padded zero due to align&#13;
000000000080     <code>0xAB</code>           First byte of 0xABCD&#13;
<code>000000000081</code>     <code>0xCD</code>           Second byte of 0xABCD</pre>&#13;
			<p class="IMG---Caption">Figure 9.10 – Allocating data to memory – the memory map</p>&#13;
			<p lang="en-GB">We next look at a dilemma that affects <a id="_idIndexMarker629"/>all computers: how do you load a constant (literal) that is the same size as the instruction word?</p>&#13;
			<h1 id="_idParaDest-164" lang="en-GB"><a id="_idTextAnchor180"/>Dealing with 32-bit literals</h1>&#13;
			<p lang="en-GB">Here, you will learn how the ARM uses a 32-bit instruction to load a 32-bit literal. A literal can’t be combined with an op-code as we have done in the simulators. We will <a id="_idIndexMarker630"/>demonstrate how the ARM uses several techniques to use a 32-bit instruction to access a 32-bit literal.</p>&#13;
			<p lang="en-GB">The ARM has 32-bit data words and instructions. You can’t load a 32-bit literal into an ARM register in one instruction because you can’t specify both the operation and the data in one instruction. CISC processors chain two or more instructions together; for example, a 16-bit machine might take 2 instruction words to create a 32-bit instruction containing a 16-bit operation and a 16-bit literal. Some processors load a 16-bit literal (load high) with one instruction and then load a second 16-bit literal (load low) with a second instruction. The computer then concatenates the high and low halfword 16-bit values into a 32-bit literal.</p>&#13;
			<p lang="en-GB">The ARM has two pseudo-instructions that can load a 32-bit value into a register by letting the assembler generate the actual code needed to do this. The pseudo-instruction <code>adr</code> (load address) has the format adr rdestination,label, where <code>label</code> indicates a line (address) in the program. <code>adr</code> lets the assembler generate the appropriate machine code and relieves the programmer of some <em class="italic">housekeeping</em>. The <code>adr</code> uses the ARM’s <code>add</code> or <code>sub</code> instruction together with <em class="italic">PC relative addressing</em> to generate the required address. Program counter-relative addressing specifies an address by its distance from the current instruction. The following code fragment demonstrates the use of <code>adr</code>:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
          <strong class="bold">adr    r0,someData</strong>    @ Setup r1 to point to someData in memory&#13;
          ldr    <strong class="bold">r1</strong>,[r0]        @ Read someData using the pointer in r0&#13;
          .        .&#13;
someData: .word  0x12345678     @ Here's the data</pre>&#13;
			<p lang="en-GB">The pseudo-instruction <code>adr </code>r0,<code>someData</code> loads register <code>r0</code> with the 32-bit address of <code>someData</code> using the appropriate code generated by the assembler. You don’t normally <a id="_idIndexMarker631"/>have to know how the assembler generates the actual code to implement the <code>adr</code>.</p>&#13;
			<p lang="en-GB">Another useful ARM pseudo-instruction is <code>ldr</code> r1<code>,=value</code>. In this case, the compiler generates the code that allows register r1 to be loaded with the stated value, as in this example:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
      ldr r2, =0x12345678       @ Load a 32-bit literal into r2</pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">This loads r2 with 1234567816. The assembler employs a <code>mov</code> or <code>mvn</code> instruction if it can. The ARM’s unusual <em class="italic">move</em> <code>not</code> instruction takes an 8-bit literal, inverts the bits, and moves it to a register. For example <code>MVN r1,#0xF0</code> copies <code>0x0F</code> to r1. Alternatively, the assembler uses an <code>ldr</code><code> </code>r2<code>,[pc,#offset]</code> instruction to access the appropriate constant 1234567816 that is stored in a so-called <em class="italic">literal pool</em> or <em class="italic">constant pool</em> somewhere in memory. A literal pool is one or more data items embedded in code.</p>&#13;
			<p lang="en-GB">Let’s look at how pseudo-instructions are treated by the GCC assembler development system. Consider the following fragment of code:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
        .text&#13;
        .global _start&#13;
_start: ldr    r0,=0x12345678   @ Load r0 with a 32-bit constant&#13;
        adr    r1,Table1        @ Load r1 with the address of Table1&#13;
        adr    r2,Table2        @ Load r2 with the address of Table2&#13;
        ldr    r3,[r1]          @ Load r3 with data in Table1&#13;
        ldr    r4,[r2]          @ Load r4 with data in Table2&#13;
        ldr    r5, =0xAAAAAAAA  @ Load r5 with a 32-bit constant&#13;
wait:   mov    r0,#0            @ Goodbye message&#13;
        mov    r7,#1            @ Goodbye command in r7&#13;
        svc    0                @ Call operating system to return&#13;
Table1: .word  0xABCDDCBA       @ Dummy data&#13;
Table2: .word  0xFFFFFFFF</pre>&#13;
			<p lang="en-GB">The following is the edited output of a gdb debugger session. The code has been executed to completion and the register contents are as follows. The righthand column displays the data in decimal form:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
r0             0x0                 0&#13;
r1             0x10078             65656&#13;
r2             0x1007c             65660&#13;
r3             0xabcddcba          2882395322&#13;
r4             0xffffffff          4294967295&#13;
r5             0xaaaaaaaa          2863311530&#13;
pc             0x10074             0x10074 &lt;wait+8&gt;</pre>&#13;
			<p lang="en-GB">The pointer registers, <code>r1</code> and <code>r2</code>, have been loaded with the addresses of the two data elements in memory (i.e., Table1 and Table2). These pointers have been used to retrieve the two elements, and you can see from the debugger that the operation worked.</p>&#13;
			<p lang="en-GB">The following debugger output <a id="_idIndexMarker632"/>provides a disassembly of the code. This is not what was written. The assembler has converted the three pseudo-operations into actual ARM code (in bold font):</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Dump of assembler code from 0x10054 to 0x10086:&#13;
   <strong class="bold">0x00010054 &lt;_start+0&gt;:    ldr    r0, [pc, #36]    ; 0x10080 &lt;Table2+4&gt;</strong>&#13;
   <strong class="bold">0x00010058 &lt;_start+4&gt;:    add    r1, pc, #24</strong>&#13;
   <strong class="bold">0x0001005c &lt;_start+8&gt;:    add    r2, pc, #24</strong>&#13;
   0x00010060 &lt;_start+12&gt;:   ldr    r3, [r1]&#13;
   0x00010064 &lt;_start+16&gt;:   ldr    r4, [r2]</pre>&#13;
			<pre class="source-code">   0x00010068 &lt;_start+20&gt;:   ldr    r5, [pc, #20]    ; 0x10084 &lt;Table2+8&gt;</pre>&#13;
			<p lang="en-GB">The first load instruction loads register <code>r0</code> with data from memory 36 bytes from the current program counter. At that location, the assembler has stored the <code>0x12345678</code> constant to be loaded.</p>&#13;
			<p lang="en-GB">The two <code>adr</code> operations generate an address by adding the distance between the pc and the data in memory. This is called <em class="italic">program counter relative addressing</em> and we will look at it in more detail later.</p>&#13;
			<p lang="en-GB">Let’s look at the data in memory. We use the <code>x/6xw 0x10080</code> gdb command to display six words of memory from address <code>0x10080</code>:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) x/6xw 0x10080&#13;
0x10080 &lt;Table2+4&gt;:    <strong class="bold">0x12345678</strong>    0xaaaaaaaa    0x00001141    0x61656100&#13;
0x10090:               0x01006962    0x00000007</pre>&#13;
			<p lang="en-GB">This shows the <code>0x12345678</code> constant that has been loaded in memory following the program, together with the other constants we loaded.</p>&#13;
			<h2 id="_idParaDest-165" lang="en-GB"><a id="_idTextAnchor181"/>A note on endianism</h2>&#13;
			<p lang="en-GB">We’ve not mentioned one topic yet - <em class="italic">endianism</em>. The term is <a id="_idIndexMarker633"/>borrowed from <em class="italic">Gulliver’s Travels</em> where the world is divided into those who eat their boiled eggs from the big end and those who eat their eggs from the little end. This divides the world into mutually hostile big enders and little enders (it is, of course, satire).</p>&#13;
			<p lang="en-GB">Computers do something similar. Suppose you store the 32-bit hexadecimal value <code>0x12345678</code> in memory. If you stored this in word memory, where the address of each word differs by 1, life would be simple. But because computer memories are <em class="italic">byte-organized</em>, each memory location has an individual byte address, so successive byte addresses are <code>0,1,2,3,4,5,6…</code> and successive word addresses are <code>0,4,8,12,16,20,24…</code>.</p>&#13;
			<p lang="en-GB">A consequence of byte addressing means that word 0 occupies byte addresses 0,1,2,3. Suppose we store <code>0x12345678</code> at address 0. Which end of the number do we put in first? Is it stored in bytes 0 to 3 as <code>12 34 56 78</code> or as <code>78 56 </code><code>34 12</code>?</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB"><em class="italic">Figure 9</em><em class="italic">.4</em> illustrates three memory systems. In all three cases, memory is byte-addressed. In the 32-bit version, we have two 32-bit values representing <code>0x12345678</code> stored in memory at addresses c and <code>0x1014</code>. Notice that the individual bytes of the stored word have different byte addresses. A little-endian number is arranged so that the most significant byte, <code>0x12</code>, is stored in the lowest address of the word <code>0x1010</code>. A big-endian number is stored with the most-significant byte at the lowest address, <code>0x1013</code>.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_9.11_B19624.jpg" alt="Figure 9.11 – Memory organization" width="1470" height="650"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Memory organization</p>&#13;
			<p lang="en-GB">Some computers are big-endian and <a id="_idIndexMarker634"/>some little-endian. Motorola microprocessors are big-endian and Intel is little-endian. ARM was originally little-endian, but it now has a bit in its CPSR status register that can be used to select the required version of endianism. By default, the ARM is little-endian.</p>&#13;
			<p lang="en-GB">Does the endian matter? It matters in two ways. If you are building systems or interfacing systems with mixed endianism, it matters because you must ensure that the bytes are in the correct sequence when passed from one system to another. For example, the TCP/IP protocol is big-endian. Equally, if you are performing byte and word operations on data, you have to be aware of the relationship between byte and word addresses. If you store the ASCII “Mike” at word address <code>0x1000</code> and you wanted the <em class="italic">“e,”</em> it would be at <code>0x1000</code> in a big-endian system and <code>0x1003</code> in a little-endian system.</p>&#13;
			<h2 id="_idParaDest-166" lang="en-GB"><a id="_idTextAnchor182"/>Bringing everything together – a final example</h2>&#13;
			<p lang="en-GB">To conclude this chapter, we provide a final example of using the Raspberry Pi to enter the ARM assembly language and run it in a debugging mode using gdb. As before, the example does not perform a useful function. Its purpose is to demonstrate addressing modes, the use of assembler directives to load data in memory, the nature of endianism, and the ability to declare variables in memory and modify them.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">This example also demonstrates how memory <a id="_idIndexMarker635"/>data is displayed and how to use the memory display function to read data. We have used gdb and copied various screens during the debugging. These have been put together in what follows. We have removed some material (e.g., status registers and registers not accessed) and have slightly edited the format for readability.</p>&#13;
			<h3 lang="en-GB">The source program</h3>&#13;
			<p lang="en-GB">The source program sets up data in memory and accesses it. We use ASCII text and numeric text as part of the demonstration. Note that an ASCII string or character using the GCC assembler requires double quotes. We also read bytes with ldrb and a halfword (16 bits) with ldrh.</p>&#13;
			<p lang="en-GB">The program uses <code>ldrb r5,[r3,#1]</code> to demonstrate reading bytes from a 32-bit word that is 3 bytes on from the base address of the word in r5.</p>&#13;
			<p lang="en-GB">The program contains dummy <a id="_idIndexMarker636"/>data stored in memory, such as <code>0xAAAAAAAA</code>. We do this to demonstrate how data is stored, but mainly to help with debugging. When you display data contents in memory, these dummy values provide great markers to help you read the memory data.</p>&#13;
			<p lang="en-GB">Note that the word that we access in read/write memory, testRW, is in a .data section. This is initialized to <code>0xFFFFFFFF</code> and is later modified:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
        .global _start&#13;
_start: adr     r0,mike        @ r0 points to ASCII string "Mike"&#13;
        ldr     r1,[r0]        @ Read the string into r1&#13;
        ldrb    r2,[r0,#3]     @ Read byte 3 of "Mike"&#13;
        adr     r3,test        @ Point to data value 0x2468FACE in memory&#13;
        ldrb    r4,[r3]        @ Read single byte of test. Pointer in r0&#13;
        ldrb    r5,[r3,#1]     @ Read single byte 1 offset&#13;
        ldrh    r6,[r3]        @ Read halfword of test&#13;
        ldr     r7,a_adr       @ r7 points at address of testRW&#13;
        ldr     r8,=0x12345678 @ r8 loaded with 32-bit literal 0x12345678&#13;
        str     r8,[r7]        @ Store r8 in read/write memory at testRW&#13;
        ldrh    r9,[r7]        @ Read halfword of testRW&#13;
        mvn     r10,r9         @ Logically negate r9&#13;
        strh    r10,[r7,#4]    @ Store halfword in next word after testRW&#13;
        nop                    @ Just a place to stop&#13;
        mov     r0,#1          @ Raspberry Pi exit sequence&#13;
        mov     r7,#7&#13;
        svc     0&#13;
mike:   .ascii  "Mike"         @ Store string as 4 ASCII characters&#13;
test:   .word   0x2468FACE     @ Save a word in memory&#13;
a_adr:  .word   testRW         @ Pointer to data in read/write memory&#13;
        .data                  @ Data section in read/write memory&#13;
nines:  .word   0x99999999     @ 0x99999999 Just dummy data&#13;
testRW: .word   0xFFFFFFFF     @&#13;
        .word   0x77777777     @ More dummy data&#13;
        .word   0xBBBBBBBB     @ More dummy data</pre>&#13;
			<pre class="source-code">        .end</pre>&#13;
			<p lang="en-GB">The first steps are to assemble and load the program (called endian) and invoke the gdb debugger. We use bold font to indicate input from the keyboard:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
alan@raspberrypi:~/Desktop $ <strong class="bold">as g o endian.o endian.s</strong>&#13;
alan@raspberrypi:~/Desktop $ <strong class="bold">ld o endian endian.o</strong>&#13;
alan@raspberrypi:~/Desktop $ <strong class="bold">gdb endian</strong>&#13;
GNU gdb (Raspbian 10.11.7) 10.1.90.20210103git</pre>&#13;
			<p lang="en-GB">We can use gdb to set a breakpoint at <code>_start</code> and then run the program to that breakpoint:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) b _start&#13;
Breakpoint 1 at 0x10074: file endian.s, line 2.&#13;
(gdb) r&#13;
Starting program: /home/alan/Desktop/endian&#13;
Breakpoint 1, _start () at endian.s:2&#13;
2    _start: adr     r0,mike   @ r0 points to ASCII string "Mike"</pre>&#13;
			<p lang="en-GB">Let’s look at the program that is actually loaded <a id="_idIndexMarker637"/>into memory. This differs slightly from the one we wrote because pseudo-operations have been replaced by actual code. Note that the <code>adr</code> is translated into an <code>add</code> by taking the program counter and adding the distance of the required variable to the current pc to generate its address.</p>&#13;
			<p lang="en-GB">The <code>ldr r8,=0x12345678</code> is translated into a load program counter relative instruction because the required constant has been loaded into memory after the end of the program:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) <strong class="bold">disassemble</strong>&#13;
Dump of assembler code for function _start:&#13;
=&gt; 0x00010074 &lt;+0&gt;:     <strong class="bold">add    r0, pc, #60</strong>    ; 0x3c&#13;
   0x00010078 &lt;+4&gt;:     ldr    r1, [r0]&#13;
   0x0001007c &lt;+8&gt;:     ldrb   r2, [r0, #3]&#13;
   0x00010080 &lt;+12&gt;:    <strong class="bold">add    r3, pc, #52</strong>    ; 0x34&#13;
   0x00010084 &lt;+16&gt;:    ldrb   r4, [r3]&#13;
   0x00010088 &lt;+20&gt;:    ldrb   r5, [r3, #1]&#13;
   0x0001008c &lt;+24&gt;:    ldrh   r6, [r3]&#13;
   0x00010090 &lt;+28&gt;:    ldr    r7, [pc, #40]   ; 0x100c0 &lt;a_adr&gt;&#13;
   0x00010094 &lt;+32&gt;:    <strong class="bold">ldr    r8, [pc, #40]</strong>   ; 0x100c4 &lt;a_adr+4&gt;&#13;
   0x00010098 &lt;+36&gt;:    str    r8, [r7]&#13;
   0x0001009c &lt;+40&gt;:    ldrh   r9, [r7]&#13;
   0x000100a0 &lt;+44&gt;:    mvn    r10, r9&#13;
   0x000100a4 &lt;+48&gt;:    strh   r10, [r7, #4]&#13;
   0x000100a8 &lt;+52&gt;:    nop                    ; (mov r0, r0)&#13;
   0x000100ac &lt;+56&gt;:    mov    r0, #1&#13;
   0x000100b0 &lt;+60&gt;:    mov    r7, #7&#13;
   0x000100b4 &lt;+64&gt;:    svc    0x00000000</pre>&#13;
			<pre class="source-code">End of assembler dump.</pre>&#13;
			<p lang="en-GB">This differs from the code we wrote because pseudo-operations have been replaced by actual ARM code. Note that the <code>adr</code> is translated into an <code>add</code> by taking the program counter and adding the distance of the required variable to the current pc to generate its address.</p>&#13;
			<p lang="en-GB">The <code>ldr r8,=0x12345678</code> is translated into a load program counter relative instruction because the required constant has been loaded into memory after the end of the program.</p>&#13;
			<p lang="en-GB">Let’s look at memory. The following shows the <a id="_idIndexMarker638"/>contents of 8 consecutive words starting with <code>0x100b4</code>, which is the address of the <code>svc </code><code>0</code> instruction.</p>&#13;
			<p lang="en-GB">Before continuing and executing the program, we will look at the contents of memory, set up by the program. Where is this data? It follows the last executable instruction, <code>svc 0</code>, which is at address <code>0x000100B4</code>. We display the eight words from the <code>svc</code> in hexadecimal format:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) <strong class="bold">x/8wx 0x100b4</strong>&#13;
0x100b4 &lt;_start+64&gt;:    0xef000000    0x656b694d    0x2468face    0x000200cc&#13;
0x100c4 &lt;a_adr+4&gt;:      0x12345678    0x99999999    0xffffffff    0x77777777</pre>&#13;
			<p lang="en-GB">You can see the <code>0x12345678</code> constant loaded by the assembler and some of the markers.</p>&#13;
			<p lang="en-GB">We will step through the first few instructions:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) <strong class="bold">si 1</strong>&#13;
3          ldr   r1,[r0]       @ Read the string into r1&#13;
4          ldrb  r2,[r0,#3]    @ Read byte 3 of "Mike"&#13;
6          adr   r3,test       @ Point to data value 0x2468FACE in memory</pre>&#13;
			<p lang="en-GB">The next step is to look at the registers before the program runs to completion. We do this with gdb’s <code>i r</code> command. There’s not much to see yet (it’s a partial listing), as we’ve executed only the first few instructions. However, <code>r0</code> now contains a pointer to the ASCII text string <em class="italic">“Mike”</em> at address <code>0x100B8</code>. If you look back at that address, you see that it contains <code>0x656b694d</code>, which is <code>ekiM</code>. That’s what little-endian does!</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) <strong class="bold">i r</strong>&#13;
r0             0x100b8             65720&#13;
r1             0x656b694d          1701538125&#13;
r2             0x65                101&#13;
r3             0x0                 0&#13;
r4             0x0                 0&#13;
sp             0x7efff360          0x7efff360&#13;
lr             0x0                 0</pre>&#13;
			<pre class="source-code">pc             0x10080             0x10080 &lt;_start+12&gt;</pre>&#13;
			<p lang="en-GB">Continuing <a id="_idIndexMarker639"/>single-stepping:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) <strong class="bold">si 1</strong>&#13;
7          ldrb    r4,[r3]          @ Read byte of test Pointer in r0&#13;
8          ldrb    r5,[r3,#1]       @ Read single byte 1 offset&#13;
9          ldrh    r6,[r3]          @ Read halfword of test&#13;
11         ldr     r7,a_adr         @ r7 points at address of testRW&#13;
12         ldr     r8,=0x12345678   @ r8 loaded with 32-bit 0x12345678&#13;
(gdb) i r&#13;
<strong class="bold">r0             0x100b8             65720</strong>&#13;
<strong class="bold">r1             0x656b694d          1701538125</strong>&#13;
<strong class="bold">r2             0x65                101</strong>&#13;
<strong class="bold">r3             0x100bc             65724</strong>&#13;
<strong class="bold">r4             0xce                206</strong>&#13;
<strong class="bold">r5             0xfa                250</strong>&#13;
<strong class="bold">r6             0xface              64206</strong>&#13;
<strong class="bold">r7             0x200cc             131276</strong>&#13;
<strong class="bold">sp             0x7efff360          0x7efff360</strong>&#13;
<strong class="bold">lr             0x0                 0</strong>&#13;
<strong class="bold">pc             0x10094             0x10094 &lt;_start+32&gt;</strong></pre>&#13;
			<p lang="en-GB">Let’s look at the memory in the data section. Register <code>r7</code> points to the read/write data area. It starts 4 bytes before the pointer to <code>testRW</code>, in <code>r7</code> ; that is, <code>0x200CC - 4 = 0x200C8</code>. The four words beginning at that address are as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) <strong class="bold">x/4xw 0x200c8</strong>&#13;
0x200c8:    0x99999999    0xffffffff    0x77777777    0xbbbbbbbb</pre>&#13;
			<p lang="en-GB">Finally, we step through the instruction until we meet the <code>nop</code> at the end:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) <strong class="bold">si 1</strong>&#13;
13          str    r8,[r7]       @ Store r8 in read/write memory at testRW&#13;
14          ldrh   r9,[r7]       @ Read halfword of testRW&#13;
15          mvn    r10,r9        @ Logically negate r9&#13;
16          strh   r10,[r7,#4]   @ Store halfword in next word after testRW</pre>&#13;
			<pre class="source-code">17          nop                  @ Just a place to stop</pre>&#13;
			<p lang="en-GB">Let’s take a final look at <a id="_idIndexMarker640"/>the state of the registers:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) i r&#13;
r0             0x100b8             65720&#13;
r1             0x656b694d          1701538125&#13;
r2             0x65                101&#13;
r3             0x100bc             65724&#13;
r4             0xce                206&#13;
r5             0xfa                250&#13;
r6             0xface              64206&#13;
r7             0x200cc             131276&#13;
r8             0x12345678          305419896&#13;
r9             0x5678              22136&#13;
r10            0xffffa987          4294945159&#13;
sp             0x7efff360          0x7efff360&#13;
lr             0x0                 0&#13;
pc             0x100a8             0x100a8 &lt;_start+52&gt;</pre>&#13;
			<p lang="en-GB">Here’s our final look at the data memory. Note that <code>0xFFFFFFFF</code> has been replaced with the value <code>0x12345678</code> that we wrote to memory. This demonstrates how you can access data memory using an ARM.</p>&#13;
			<p lang="en-GB">Note also the data value at <code>0x200D0</code> ; that is, <code>0x7777a987</code>. We have changed half the word using a halfword load:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) <strong class="bold">x/4xw 0x200c8</strong>&#13;
0x200c8:    0x99999999    0x12345678    0x7777a987    0xbbbbbbbb</pre>&#13;
			<h1 id="_idParaDest-167" lang="en-GB"><a id="_idTextAnchor183"/>Summary</h1>&#13;
			<p lang="en-GB">In this chapter, we have introduced a real computer, the Raspberry Pi. Instead of designing our own computer instruction sets, we’ve looked at the ARM microprocessor that is at the heart of the Raspberry Pi and most smartphones.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">We introduced the basics of the Raspberry Pi and showed how to write an ARM assembly language program that can run on it. This requires an understanding of the ARM assembler and the use of the linker. We demonstrated how you can then run your ARM program instruction-by-instruction using the gdb debugger.</p>&#13;
			<p lang="en-GB">One important feature of Raspberry Pi’s architecture we have encountered is the way in which data in memory is modified. You cannot use a str (store) instruction to modify data in memory. You must do it indirectly via a pointer to the address of the memory you wish to change. The following short program demonstrates this vital point. A data item in memory is read directly using an <code>ldr</code> but modified in memory using a pointer to a pointer. The key operations are in bold:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
         .text           @ Code section&#13;
         .global _start&#13;
_start:  ldr r1,=xxx     @ Point to data xxx&#13;
         ldr r2,[r1]     @ Read the data&#13;
         <strong class="bold">adr r3,adr_xxx</strong>  @ Point to the address of the address of xxx&#13;
         <strong class="bold">ldr r4,[r3]</strong>     @ Point to the data xxx&#13;
         ldr r5,[r4]     @ Read the value of xxx&#13;
         add r5,r5,#1    @ Increment the data&#13;
         <strong class="bold">str r5,[r4]</strong>     @ Change xxx in memory&#13;
         mov r0,#0       @ Exit procedure&#13;
         mov r7,#1&#13;
         svc 0&#13;
<strong class="bold">adr_xxx: .word</strong>           @ Pointer to data xxx&#13;
         <strong class="bold">.data</strong>           @ Data section&#13;
<strong class="bold">xxx:     .word  0xABCD</strong>   @ Initialize variable xxx&#13;
         .end</pre>&#13;
			<p lang="en-GB">In order to demonstrate an ARM program, we have introduced the ARM’s assembly language. Mercifully, this is not too far from the language adopted by some of the simulators. Indeed, the ARM’s assembly language is not too difficult to learn, although it does incorporate some very interesting features, which we will describe in later chapters.</p>&#13;
			<p lang="en-GB">In the next chapter, we return to the ARM architecture and one of its most important aspects: addressing and how data is transferred to and from memory.</p>&#13;
		</div>&#13;
	</div></body></html>