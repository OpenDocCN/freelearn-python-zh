<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer069" class="_idGenObjectStyleOverride-1">&#13;
			<h1 id="_idParaDest-150" class="chapter-number" lang="en-GB"><a id="_idTextAnchor159"/>9</h1>&#13;
			<h1 id="_idParaDest-151" lang="en-GB"><a id="_idTextAnchor160"/>Raspberry Pi: An Introduction</h1>&#13;
			<p lang="en-GB">In previous chapters, we introduced the digital computer and explained its operation at the instruction set level. Now you will learn about a real, low-cost computer that was designed for <span class="No-Break">educational purposes.</span></p>&#13;
			<p lang="en-GB">In this chapter, we introduce Raspberry Pi, which is based on the popular ARM microprocessor. We describe its instruction set architecture and demonstrate how you can use it to run assembly language programs in debugging mode. The highlights of this chapter are <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">An introduction to Raspberry Pi’s <span class="No-Break">operating system</span></li>&#13;
				<li lang="en-GB">Using the GCC ARM assembler <span class="No-Break">and linker</span></li>&#13;
				<li lang="en-GB">Debugging ARM assembly <span class="No-Break">language programs</span></li>&#13;
			</ul>&#13;
			<p lang="en-GB">This is not a handbook for Raspberry Pi. We are interested only in using it to enter assembly language programs, run them, and observe their behavior. We do not cover Raspberry Pi’s Windows-style GUI because it is very similar to the corresponding PC and macOS user interfaces. Moreover, the Raspberry Pi operating system includes utilities and a <span class="No-Break">web browser.</span></p>&#13;
			<h1 id="_idParaDest-152" lang="en-GB"><a id="_idTextAnchor161"/>Technical requirements</h1>&#13;
			<p lang="en-GB">This chapter is based on the Raspberry Pi 4. The software we use should also be compatible with the earlier 3B model. In order to use Raspberry Pi, you will need <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">Raspberry Pi 4 (available with 2 GB, 4 GB, and 8 <span class="No-Break">GB DRAM)</span></li>&#13;
				<li lang="en-GB">Raspberry Pi 5V 3A <span class="No-Break">power supply</span></li>&#13;
				<li lang="en-GB"><span class="No-Break">USB mouse</span></li>&#13;
				<li lang="en-GB"><span class="No-Break">USB keyboard</span></li>&#13;
				<li lang="en-GB">Wi-Fi <span class="No-Break">internet connection</span></li>&#13;
				<li lang="en-GB">Video display with micro <span class="No-Break">HDMI lead</span></li>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB">32 GB Class 10 micro SD card pre-loaded with NOOBS (see the note at the end of <span class="No-Break">this section)</span></li>&#13;
			</ul>&#13;
			<p lang="en-GB">All these items are available on Amazon or from Raspberry Pi suppliers. You can get the operating system pre-loaded onto a micro SD card, or download the operating system and preload it onto your own card using a PC or Mac. The Raspberry Pi web page at <a href="https://www.raspberrypi.org/">https://www.raspberrypi.org/</a> provides full details about this computer including getting started, setting up, and loading the operating system on your <span class="No-Break">own card.</span></p>&#13;
			<p lang="en-GB">The text was written <a id="_idIndexMarker582"/>using <strong class="bold">NOOBS</strong> (<strong class="bold">New Out Of the Box Software</strong>). The Raspberry Pi Foundation no longer supports NOOBS and recommends that you download the latest version of the operating system using Raspberry Pi Imager, which runs under macOS, Windows, and Ubuntu. You can find the necessary information <span class="No-Break">at </span><a href="https://www.raspberrypi.org/"><span class="No-Break">https://www.raspberrypi.org/</span></a><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The ARM code we use in this book is designed to run on a Raspberry Pi with a 32-bit <span class="No-Break">operating system.</span></p>&#13;
			<h1 id="_idParaDest-153" lang="en-GB"><a id="_idTextAnchor162"/>Raspberry Pi basics</h1>&#13;
			<p lang="en-GB">Microcomputers have been around <a id="_idIndexMarker583"/>since the 1970s. In the 1970s, several systems aimed at the enthusiast based on the Z80, 6502, and 6809 8-bit microprocessors appeared. Operating systems, apps, and the web didn’t <span class="No-Break">exist then.</span></p>&#13;
			<p lang="en-GB">Then, in the late 1970s, Intel introduced the 8086 and Motorola its 68000 16-bit CPU (the 68000 microprocessor actually had a 32-bit instruction set architecture, but Motorola marketed it initially as a 16-bit machine. In my view this was a catastrophic marketing mistake. 16-bit computers were a giant leap up from their 8-bit predecessors for two reasons. First, the technology had advanced, permitting designers to put far more circuitry on a chip (i.e., more registers, more powerful instruction sets, etc.), and second, processors were far faster due to the reduction in feature size (i.e., smaller transistors). Finally, the declining cost of memory meant that people could run larger and more <span class="No-Break">sophisticated programs.</span></p>&#13;
			<p lang="en-GB">In the 1960s, the giant corporation IBM was famous for its large-scale data-processing machines. However, IBM wanted a change of direction and IBM’s engineers decided to build a PC around Motorola’s 68000 processor. Unfortunately for Motorola, a version of that chip wasn’t yet in production. Intel released the 8088, an 8-bit version of its 16-bit 8086 processor with an 8-bit data bus that made it easy to create a low-cost microcomputer using 8-bit peripherals and memory components. The 8088 still had a 16-bit architecture but was able to interface to 8-bit memory and <span class="No-Break">I/O devices.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">IBM formed a relationship with Intel, and the IBM PC in all its beige-colored splendor arose in 1981. Unlike Apple, IBM created an open architecture that anyone could use without paying a royalty. And a million PC clones flowered. The rest is history. However, the PC and Apple’s Mac left a hole in the market: an ultra-low-cost computer that the young, the student, the experimenter, and the enthusiast can play with. Raspberry Pi plugs <span class="No-Break">this gap.</span></p>&#13;
			<p lang="en-GB">Low-cost computing has been around for a long time. For a few dollars, you can buy a greeting card that plays “Happy Birthday” when you open it. High-performance computing is more expensive. The cost of a computer often lies not in the processor but in the supporting cast of components and systems required to convert a microprocessor into a computer system – in particular, the graphics and display interface, the memory interface, and the communications interface (input/output). That’s why the Raspberry Pi has been such an amazing success. On a tiny, low-cost board, you have all the peripherals and interfaces that you need to create a complete system comparable to a PC (although not in terms <span class="No-Break">of performance).</span></p>&#13;
			<p lang="en-GB">To turn the board into a fully-fledged microcomputer, you need only a low-cost power supply and the very same mouse and keyboard you would use with a PC. Indeed, many people use peripherals left over from PCs and other computers they have lying around. I bought a 2-to-1 HDMI switch to interface my 4K monitor to both my PC and Raspberry Pi. You just press a button and the display switches from PC to Raspberry Pi. The Raspberry Pi uses an open source operating system with vast amounts of free software. No more having to take out a mortgage for Office <span class="No-Break">or Photoshop.</span></p>&#13;
			<p lang="en-GB">The Raspberry Pi was an outstanding <a id="_idIndexMarker584"/>success and rapidly created a very large and enthusiastic following. It found applications at all levels of education from kindergarten to PhD. Over the years, improved versions of Raspberry Pi were introduced, as well as truly minimal versions that could be used as dedicated embedded processors for a <span class="No-Break">few dollars.</span></p>&#13;
			<p lang="en-GB"><span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.1</em> illustrates the Raspberry Pi 4 that was used while writing this book. The first Raspberry Pi Model B appeared in 2012 with 256 MB of DRAM, USB ports, and Ethernet, but no wireless communications. By 2019, the Raspberry Pi 4 was available with 2 USB 2.0 and 2 USB 3.0 ports, on-board Wi-Fi 502.11ac, Bluetooth 5, and Gigabit Ethernet, plus dual-monitor support via 2 micro HDMI ports capable of supporting 4K displays. The principal features of the RPi 4 are <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">The powerful ARM CPU (Quad core Cortex-A72 <span class="No-Break">64-bit architecture)</span></li>&#13;
				<li lang="en-GB">Audio (sound <span class="No-Break">processing system)</span></li>&#13;
				<li lang="en-GB">Video display and graphics logic system (you just need to plug the card into <span class="No-Break">a monitor)</span></li>&#13;
				<li lang="en-GB">DRAM main memory (2, 4, or <span class="No-Break">8 GB)</span></li>&#13;
				<li lang="en-GB">Non-volatile flash memory with the operating system (not <span class="No-Break">normally included)</span></li>&#13;
				<li lang="en-GB">Mouse and keyboard <span class="No-Break">USB ports</span></li>&#13;
				<li lang="en-GB">Wi-Fi (both 2.4 and 5.0 <span class="No-Break">GHz bands)</span></li>&#13;
				<li lang="en-GB"><span class="No-Break">Bluetooth 5.0</span></li>&#13;
				<li lang="en-GB"><span class="No-Break">Ethernet port</span></li>&#13;
				<li lang="en-GB">A general I/O port for directly interfacing with <span class="No-Break">external hardware</span></li>&#13;
			</ul>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer058" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_9.01_B19624.jpg" alt="Figure 9.1 – The Raspberry Pi 4 (Image by Laserlicht / Wikimedia Commons / CC BY-SA 4.0)" width="653" height="422"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – The Raspberry Pi 4 (Image by Laserlicht / Wikimedia Commons / CC BY-SA 4.0)</p>&#13;
			<p lang="en-GB">The Raspberry Pi board is not normally sold with an operating system. It has a micro-SD port into which you have to insert a memory card containing a suitable operating system. You can buy a card with the OS already installed, or load one of the freely available variants from the web onto a card (using your PC or Mac) and plug it into the <span class="No-Break">Raspberry Pi.</span></p>&#13;
			<p lang="en-GB">The classic operating system used by computer <a id="_idIndexMarker585"/>scientists in academia is Unix, which was developed at AT&amp;T’s Bell Labs in the late 1960s by a team that included Ken Thomson and Dennis Richie (two of the most significant players in computer science history). Unix was one of the first operating systems to become portable – that is, to run on different types <span class="No-Break">of computers.</span></p>&#13;
			<p lang="en-GB">A strong thread in the history of computer science is open software – that is, software developed by a community of individuals that is freely available, such as the Python programming language and the LibreOffice application package, which provides much of the functionality of Microsoft’s <span class="No-Break">Office suite.</span></p>&#13;
			<p lang="en-GB">In the 1980s, the Free Software Foundation led by Richard Stillman led the development of the GNU operating system, which was designed to provide an open source version of Unix. In 1991, Linus Torvalds released an open source component of GNU, its kernel, <span class="No-Break">called Linux.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Today, the Linux kernel plus the GNU tools and compilers have become a free, open source alternative to proprietary operating systems such as Windows. GNU/Linux is available in different flavors (distributions written by various groups with the same basic structure but different features). The original official Raspberry Pi operating system was called <em class="italic">Raspbian</em> and is based on a version of Debian Linux optimized for <span class="No-Break">Raspberry Pi.</span></p>&#13;
			<p lang="en-GB">Unix and Linux operate in a <em class="italic">command-line mode</em> – that is, operating system instructions are entered in text form (just like Microsoft’s DOS). Unix, Linux, and DOS all now have user-friendly graphical inputs that make use of the mouse as a key input device. The most famous of these graphical inputs is Microsoft’s Windows <span class="No-Break">operating system.</span></p>&#13;
			<p lang="en-GB">Raspberry Pi now includes both a Windows-based version of Linux and a text-based command-line interface that is used to invoke some of the tools required to assemble and execute ARM assembly language programs. This chapter provides a very short introduction to RPi’s Linux <span class="No-Break">operating system.</span></p>&#13;
			<p lang="en-GB">The Raspberry Pi operating system includes <a id="_idIndexMarker586"/>several packages that are very relevant to this book. For example, the Thonny Python IDE provides an <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>) for Python and software to edit, assemble, debug, and run <span class="No-Break">Python programs.</span></p>&#13;
			<p lang="en-GB">Another useful package is the Geany editor, which has built-in support for more than 50 programming languages. You can <a id="_idIndexMarker587"/>get Geany <span class="No-Break">at </span><a href="https://www.geany.org/"><span class="No-Break">https://www.geany.org/</span></a><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">There is also a Terminal emulator window that lets you operate in the Linux command-line mode – a feature that is useful when working with the ARM assembly language utilities. <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.2</em> shows the Raspberry Pi screen on a 4K monitor with several <span class="No-Break">windows open.</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer059" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_9.02_B19624.jpg" alt="Figure 9.2 – Screenshot of Raspberry Pi’s multiple windows" width="1517" height="1201"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 9.2 – Screenshot of Raspberry Pi’s multiple windows</p>&#13;
			<p lang="en-GB">While writing this book, I was also introduced to Visual Studio Code, which is an editor and debugging platform. Visual Studio Code is free and available on Linux, macOS, and Windows platforms. <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.3</em> shows an example of a session using Visual Studio Code to write a <span class="No-Break">Python program.</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer060" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_9.03_B19624.jpg" alt="Figure 9.3 – A VS Code session while developing a Python program" width="1578" height="788"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – A VS Code session while developing a Python program</p>&#13;
			<p lang="en-GB">I must thank Graeme Harker for encouraging me to use VS Code. Had I discovered VS Code earlier, I would probably have stuck <span class="No-Break">to that.</span></p>&#13;
			<p lang="en-GB">Now that we’ve introduced the ubiquitous Raspberry Pi that can form the basis of a computer system with the addition of a mouse, keyboard, and display, we are going to introduce its <span class="No-Break">operating system.</span></p>&#13;
			<p lang="en-GB">However, we do not delve too deeply. In order to <a id="_idIndexMarker588"/>use the Raspberry Pi to enter, run, and debug ARM assembly language, you need to know only a few basic elements of the operating system. Moreover, even though the Raspberry Pi has a Unix-based command-line operating system, it includes a graphical interface that behaves very much like Windows <span class="No-Break">or macOS.</span></p>&#13;
			<h1 id="_idParaDest-154" lang="en-GB"><a id="_idTextAnchor163"/>Basics of the Raspberry Pi operating system</h1>&#13;
			<p lang="en-GB">In this section, you will learn how to use the Raspberry Pi to create an ARM assembly language program, assemble it into code that <a id="_idIndexMarker589"/>can be executed, and then run it on the Raspberry Pi. In the next chapter, we will look at the ARM architecture in <span class="No-Break">greater depth.</span></p>&#13;
			<p lang="en-GB">We do not devote much time discussing RPi’s operating system because the world is full of websites devoted to Linux. We will cover the absolute minimum to help you use some of the commands that may be helpful. Most readers will use a graphical interface to perform editing, web searches, and running programs such as Python. We will introduce the basic concepts of Linux’s filing system and the command-line instruction necessary to assemble and run a source file written in the ARM assembly language. Unfortunately, the names of Unix/Linux commands are <span class="No-Break">not intuitive.</span></p>&#13;
			<p lang="en-GB"><span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.4</em> illustrates the basic concepts of the Linux hierarchical operating system, with a node at each level that can support <em class="italic">child</em> nodes at a lower level; for example, <strong class="source-inline">Desktop</strong> is a child of the <span class="No-Break"><strong class="source-inline">pi</strong></span><span class="No-Break"> node.</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer061" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_9.04_B19624.jpg" alt="Figure 9.4 – The Raspberry Pi file structure" width="1627" height="1188"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – The Raspberry Pi file structure</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The top-level folder is <strong class="source-inline">/</strong> and is called the <em class="italic">root folder</em>. The <strong class="source-inline">/</strong> backslash is used to navigate the filing system very much like the Windows equivalent. A big difference between Linux and Windows is that, in Linux, you don’t have to specify the disk on <a id="_idIndexMarker590"/>which the file resides (e.g., Windows invariably uses <strong class="source-inline">c:/</strong> for operating systems files). In <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.4</em>, the <strong class="source-inline">MyFile.doc</strong> file is a text file whose location <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">/home/pi/Documents/MyFile.doc.</strong></span></p>&#13;
			<h2 id="_idParaDest-155" lang="en-GB"><a id="_idTextAnchor164"/>Directory navigation</h2>&#13;
			<p lang="en-GB">If you press the <a id="_idIndexMarker591"/>enter key, Raspberry Pi responds with an “<em class="italic">I am here</em>” prompt, as shown in <span class="No-Break">this example:</span></p>&#13;
			<p lang="en-GB"><span class="No-Break"><strong class="source-inline">pi@raspberrypi:</strong></span><span class="No-Break"><span class="pcode-bold">/var/log/apt $</span></span></p>&#13;
			<p lang="en-GB">This prompt gives the device name and the path to the current directory (in bold font in this example). You can change the active directory with the <strong class="source-inline">cd</strong> (<em class="italic">change directory</em>) command, as shown in <span class="No-Break">this example:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>cd ..         <span class="sc-comment"># This means change directory to parent (the node above)</span></span>&#13;
<span>cd home</span>&#13;
<span>cd pi</span>&#13;
<span>cd Desktop</span></pre>&#13;
			<p lang="en-GB">To list the files and subdirectories in the current directory, you can use the <strong class="source-inline">ls</strong> command (<span class="No-Break"><em class="italic">list files</em></span><span class="No-Break">).</span></p>&#13;
			<p lang="en-GB">The <strong class="source-inline">ls </strong><span class="pcode-bold">-l /home/pi</span> command generates the following <a id="_idIndexMarker592"/>output that gives permissions (what you can do with them), their size, and creation dates. <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.5</em> demonstrates <span class="No-Break">this command.</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer062" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_9.05_B19624.jpg" alt="Figure 9.5 – The Raspberry Pi File Structure" width="758" height="312"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – The Raspberry Pi File Structure</p>&#13;
			<p lang="en-GB">The <strong class="source-inline">ls</strong> command has several options; for example, <strong class="source-inline">ls ~</strong> indicates a list in the home directory. In Linux, the tilda<strong class="source-inline">, ~,</strong> indicates the home directory. Similarly, <strong class="source-inline">ls –t</strong> indicates list files by date and <span class="No-Break">time created.</span></p>&#13;
			<h2 id="_idParaDest-156" lang="en-GB"><a id="_idTextAnchor165"/>File operations</h2>&#13;
			<p lang="en-GB">We now introduce some of Linux’s basic file commands. The <strong class="source-inline">pwd</strong> command looks as if it should mean <em class="italic">password</em>. Actually, it means <em class="italic">print working directory</em> and displays the contents <a id="_idIndexMarker593"/>of the current directory. It’s a “<em class="italic">where am I?</em>” command. Entering <strong class="source-inline">pwd</strong> will generate a response such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">/home/pi</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">To create a new subdirectory, you use the <strong class="source-inline">mkdir</strong> command. Typing <strong class="source-inline">mkdir</strong> <strong class="source-inline">newFolder</strong> creates a subdirectory called <strong class="source-inline">newFolder</strong> in the <span class="No-Break">current directory.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">If you enter <strong class="source-inline">mkdir /home/pi/newFolder</strong>, it will create the subdirectory <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">pi</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">One of Linux’s more confusing command names is <strong class="source-inline">cat</strong>, which lists the contents of a file. The name <strong class="source-inline">cat</strong> means <strong class="source-inline">catalog</strong>; for example, <strong class="source-inline">cat /home/pi/firstExample.txt</strong> displays the contents of the <strong class="source-inline">firstExample.txt</strong> file on the console as a <span class="No-Break">text file.</span></p>&#13;
			<p lang="en-GB"> To delete or <em class="italic">remove</em> a file, you use <strong class="source-inline">rm</strong>; for example, <strong class="source-inline">rm tempData.py</strong> deletes the <strong class="source-inline">tempData.py</strong> file in the current subdirectory. You can remove an entire directory with <strong class="source-inline">rm -r</strong>. This deletes the current directory and is not reversible. It is a dangerous command. The alternative is <strong class="source-inline">rm –d</strong>, which removes the current directory <em class="italic">only if it is empty</em> (i.e., you must first delete <span class="No-Break">its contents).</span></p>&#13;
			<p lang="en-GB">Linux has a help command, <strong class="source-inline">man</strong> (i.e., manual) that provides <a id="_idIndexMarker594"/>details of another command; for example, <strong class="source-inline">man ls</strong> would provide details of the <span class="No-Break"><strong class="source-inline">ls</strong></span><span class="No-Break"> command.</span></p>&#13;
			<p lang="en-GB">In general, when working with Raspberry Pi, most users will be using the graphical interface. However, we will be using the command-line input to set up the Raspberry Pi and assemble, debug, and execute assembly <span class="No-Break">language programs.</span></p>&#13;
			<h2 id="_idParaDest-157" lang="en-GB"><a id="_idTextAnchor166"/>Installing and updating programs and packages</h2>&#13;
			<p lang="en-GB">Having set up the RPi, you need to maintain it (i.e., install and update software). The following two commands retrieve new packages and <a id="_idIndexMarker595"/>update your software. It’s a good <a id="_idIndexMarker596"/>idea to run them occasionally to get new updates. Note that <strong class="source-inline">sudo</strong> stands for <em class="italic">superuser do</em> and is required for operations that may be restricted to the administrator because they can harm the system if used inappropriately. The term <strong class="source-inline">aptget</strong> obtains and installs packages (<strong class="source-inline">apt = Advanced </strong><span class="No-Break"><strong class="source-inline">Package Tool</strong></span><span class="No-Break">):</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>su<a id="_idTextAnchor167"/>do apt-get update        <span class="sc-comment-bg"># Downloads the packages you have in your configuration source files</span></span>&#13;
<span>sudo apt-get upgrade       <span class="sc-comment"># Updates the packages</span></span></pre>&#13;
			<p class="callout-heading" lang="en-GB">Note</p>&#13;
			<p class="callout" lang="en-GB">sudo apt-get update updates packages but does not <span class="No-Break">install them.</span></p>&#13;
			<p lang="en-GB">To install a new package on Raspberry Pi, you use the <strong class="source-inline">apt-get install</strong> command; <span class="No-Break">for example,</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">su<a id="_idTextAnchor168"/>do apt-get install vim</strong> installs the <strong class="source-inline">vim</strong> <span class="No-Break">editor package.</span></p>&#13;
			<p lang="en-GB">Linux provides a shutdown command that ends a session in an <span class="No-Break">orderly manner:</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">sudo shutdown -h now     Stop</strong> and enter the <span class="No-Break">halt state</span></p>&#13;
			<p lang="en-GB">The <strong class="source-inline">-h</strong> parameter indicates <em class="italic">enter the halt state</em>, and the <strong class="source-inline">now</strong> parameter indicates an immediate halt. A command to shut down is <strong class="source-inline">sudo shutdown -r now</strong>. To reboot Raspberry Pi, you can enter either of the following two commands. These commands have the same effect on a single-user system. You would use <strong class="source-inline">shutdown -r</strong> on a <span class="No-Break">multi-user system:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><span class="sc-source-bg">sudo shutdown -r now</span></span></pre>&#13;
			<pre class="source-code">sudo reboot</pre>&#13;
			<p lang="en-GB">However, most Raspberry Pi users will shut down Raspberry Pi using a mouse from its GUI. Indeed, the only time it’s necessary to use the text-based input mode is when assembling, linking, and debugging assembly <span class="No-Break">language programs.</span></p>&#13;
			<p lang="en-GB">You can apply a delayed shutdown; for example, sudo shutdown -h 30 will shut down the RPi after 30 minutes. You can shut down at a specific clock time with, say, sudo shutdown -h 22:30, which shuts down at 10:30 P.M. A delayed shutdown command can be rescinded (canceled) by sudo <span class="No-Break">shutdown -c.</span></p>&#13;
			<h2 id="_idParaDest-158" lang="en-GB"><a id="_idTextAnchor169"/>Creating and editing an assembly language program</h2>&#13;
			<p lang="en-GB">Let’s go through the steps needed to create an ARM program on the Raspberry Pi and then execute it before we look at the ARM processor in greater detail. Although we haven’t introduced the ARM assembly language yet, the actions of the instructions we use <span class="No-Break">are self-evident.</span></p>&#13;
			<p lang="en-GB">First, you have to create an assembly <a id="_idIndexMarker597"/>language program in <a id="_idIndexMarker598"/>text form with a <strong class="source-inline">.s</strong> file type. There are many text editors and the one you choose is a personal preference. I initially used Geany, which is an IDE for languages such as C. I later used Thonny on my desktop PC. Both Geany and Thonny are excellent tools. If you create a text file on a desktop PC (or any other device), you simply change the <strong class="source-inline">.txt</strong> extension to <strong class="source-inline">.s</strong> to make it compatible with <span class="No-Break">RPi’s assembler.</span></p>&#13;
			<p lang="en-GB"><span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.6</em> shows the initial <span class="No-Break">Geany screen:</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer063" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_9.06_B19624.jpg" alt="Figure 9.6 – Geany text editor window" width="1309" height="750"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 9.6 – Geany text editor window</p>&#13;
			<p lang="en-GB"><span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.7</em> shows a Geany window after we’ve created an ARM assembly <span class="No-Break">language program:</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer064" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_9.07_B19624.jpg" alt="Figure 9.7 – Geany window – note that add r3,r0,r1 adds r0 to r1 and puts the sum in r0" width="1132" height="663"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Geany window – note that add r3,r0,r1 adds r0 to r1 and puts the sum in r0</p>&#13;
			<p lang="en-GB">In the following program, the text in bold <a id="_idIndexMarker599"/>font indicates an <a id="_idIndexMarker600"/>assembler directive that tells the assembler about the program’s environment and how to deal with the allocation of <span class="No-Break">memory space:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>.<strong class="bold">section .text       </strong><span class="sc-comment-bold">@ .text indicates a region of code (not data)</span></span>&#13;
<span><strong class="bold">.global _start       </strong><span class="sc-comment-bold">@ .global indicates that this label is visible to external objects</span></span>&#13;
<span><strong class="bold">_start:              </strong><span class="sc-comment-bold">@ _start is the entry point to this program</span></span>&#13;
<span>   mov r0,#1         <span class="sc-comment">@ Load r0 with 1. mov copies an 8-bit value into a register</span></span>&#13;
<span>   mov r1,#2         <span class="sc-comment">@ Load r1 with 2</span></span>&#13;
<span>   add r3,r0,r1      <span class="sc-comment">@ Add r0 and r1 and put result in r3</span></span>&#13;
<span><strong class="bold">.end                 </strong><span class="sc-comment-bold">@ .end indicates the end of the program. It is optional</span></span></pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Note that ARM uses <strong class="source-inline">mov</strong> to load a literal and not <strong class="source-inline">ldr</strong> (as you <span class="No-Break">might expect).</span></p>&#13;
			<h2 id="_idParaDest-159" lang="en-GB"><a id="_idTextAnchor170"/>Assembling ARM code</h2>&#13;
			<p lang="en-GB">Before we can look at the ARM architecture in depth, we will demonstrate how you write a program and run it. The Raspberry Pi’s Debian-based <a id="_idIndexMarker601"/>operating system includes GCC, the <em class="italic">GNU Compiler Collection</em>, which can compile both C programs and assembly language programs. We do not deal with <span class="No-Break">C here.</span></p>&#13;
			<p lang="en-GB">The two GCC commands we need to assemble the source <strong class="source-inline">myProg.s</strong> text file are <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>as –<a id="_idTextAnchor171"/>o myProg.o myProg.s</span>&#13;
<span>ld –o myProg myProg.o</span></pre>&#13;
			<p lang="en-GB">The first command, <strong class="source-inline">as</strong>, takes the assembly language <em class="italic">source</em> file, <strong class="source-inline">myProg.s</strong>, and creates an <em class="italic">object</em> code file, <strong class="source-inline">myProg.o</strong>. The second command, <strong class="source-inline">ld</strong>, invokes a <em class="italic">linker</em> that uses the object file to create a binary code file, <strong class="source-inline">myProg</strong>, that can be executed. The <strong class="source-inline">-o</strong> option is necessary to build an output file. You can then run the assembled binary code program by <span class="No-Break">typing </span><span class="No-Break"><strong class="source-inline">./my<a id="_idTextAnchor172"/>Prog</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">Although a <em class="italic">single</em> assembly language program can be assembled to create binary code, programs are often written in modules (files) that are fitted together. These files may be written by different programmers or even library programs. They are individually assembled to create files that the linker combines to create the final binary code that can be executed. In this text, we do not make full use of the linker’s facilities; all assembly language programs are <span class="No-Break">single files.</span></p>&#13;
			<p lang="en-GB">Following the linking operation, an executable binary program is created. Let’s now type <span class="No-Break">the following:</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">./myProg ; </strong><span class="No-Break"><strong class="source-inline">echo $?</strong></span></p>&#13;
			<p lang="en-GB">The <strong class="source-inline">myProg</strong> binary code is executed and a message is displayed. A semicolon in Linux allows two commands to be put on the same line; the two operations are <em class="italic">execute a program </em>and <em class="italic">display </em><span class="No-Break"><em class="italic">a message</em></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The <strong class="source-inline">echo $?</strong> command prints a message from the executed program. The print command is <strong class="source-inline">echo</strong> and <strong class="source-inline">$?</strong> indicates the actual message to be printed. In this case, the <strong class="source-inline">$?</strong> command returns the exit status of the last command. You can print other messages; for example, <strong class="source-inline">$3</strong> prints the contents of <span class="No-Break">register </span><span class="No-Break"><strong class="source-inline">r3</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">Note that if a program crashes or goes into an endless loop (non-responsive), you can enter <strong class="source-inline">control-C</strong> to escape and return to the <span class="No-Break">OS level.</span></p>&#13;
			<h2 id="_idParaDest-160" lang="en-GB"><a id="_idTextAnchor173"/>Debugging assembly language</h2>&#13;
			<p lang="en-GB">We will now introduce the ARM <a id="_idIndexMarker602"/>debugger that lets you monitor the execution of a program and trace code just as we did with the simulators of <a href="B19624_06.xhtml#_idTextAnchor091"><span class="No-Break"><em class="italic">Chapter 6</em></span></a> and <a href="B19624_07.xhtml#_idTextAnchor121"><span class="No-Break"><em class="italic">Chapter 7</em></span></a><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">What we want is the ability to monitor the execution of an assembly language program, a task that we’ve already done when running Python computer simulators. We can do this with a <em class="italic">debugger</em>, called <strong class="source-inline">gdb</strong>, which is part of the GCC compiler suite. Consider the <span class="No-Break">following example:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>as -g –o myProg.o myProg.s       <span class="sc-comment"># Assemble myProg.s Note the -g parameter</span></span>&#13;
<span>ld –o myProg myProg.o            <span class="sc-comment"># Link myProg.o to create source code myProg</span></span></pre>&#13;
			<pre class="source-code">gdb myProg                       <span class="sc-comment"># Run the debugger</span></pre>&#13;
			<p lang="en-GB">The <strong class="source-inline">-g</strong> parameter in the assembler section generates information for later use by the <span class="No-Break"><strong class="source-inline">gdb</strong></span><span class="No-Break"> debugger.</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">gdb</strong> is a very powerful tool with the facilities required to debug a program. We are going to look at only these facilities that allow us to run an ARM assembly language program and observe its execution, line by line. We begin by listing some of <strong class="source-inline">gdb</strong>’s commands. These commands can be abbreviated; for example, the <strong class="source-inline">quit</strong> command can be entered as q. In <em class="italic">Table 9.1</em>, we put the required part of the command in bold, and the part of the command that can be omitted in gray, such as <span class="pcode-bold">q</span><span class="pcode-grey-text">uit</span>. Note the difference between <strong class="source-inline">next</strong> and <strong class="source-inline">step</strong>. These are the same except <a id="_idIndexMarker603"/>when they encounter a <em class="italic">function</em>. Step traces all the operations in a function, whereas next treats the function as a single instruction and does not <span class="No-Break">trace it.</span></p>&#13;
			<p lang="en-GB">When you load a program into <strong class="source-inline">gdb</strong>, nothing appears to happen. If you try to look at your assembly language code or the registers, you will get an error message. You must explicitly run the <span class="No-Break">program first.</span></p>&#13;
			<table id="table001-7" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Command</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Effect</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><span class="pcode-bold">q</span></span><span class="No-Break"><span class="pcode-grey-text">uit</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Quit: leave the gdb debugger and return to the shell. Ctrl + D also <span class="No-Break">exits gdb.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><span class="pcode-bold">l</span></span><span class="No-Break"><span class="pcode-grey-text">ist</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">List: list the program <span class="No-Break">being debugged.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><span class="pcode-bold">r</span></span><span class="No-Break"><span class="pcode-grey-text">un</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Run: execute the program. The program will run to completion or to <span class="No-Break">a breakpoint.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><span class="pcode-bold">b</span></span><span class="No-Break"><span class="pcode-grey-text">reak</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Breakpoint: Execution runs until a breakpoint is encountered. The breakpoint can be a line number, an address, or <span class="No-Break">a label.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><span class="pcode-bold">i</span></span><span class="No-Break"><span class="pcode-grey-text">nfo r</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Info: show registers. This command displays <span class="No-Break">register contents.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><span class="pcode-bold">i</span></span><span class="No-Break"><span class="pcode-grey-text">nfo b</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Info: show breakpoints. This <span class="No-Break">displays breakpoints.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><span class="pcode-bold">c</span></span><span class="No-Break"><span class="pcode-grey-text">ontinue</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Continue: resume execution after <span class="No-Break">a breakpoint.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><span class="pcode-bold">d</span></span><span class="No-Break"><span class="pcode-grey-text">elete</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Delete: remove a breakpoint. Enter <strong class="source-inline">d &lt;number&gt;</strong> to remove a <span class="No-Break">specific breakpoint.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><span class="pcode-bold">n</span></span><span class="No-Break"><span class="pcode-grey-text">ext</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Single step (execute one instruction). This does not trace <span class="No-Break">a function.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><span class="pcode-bold">s</span></span><span class="No-Break"><span class="pcode-grey-text">tep</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Single step including all the operations in <span class="No-Break">a function.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">file &lt;name&gt;</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Load a binary code file into gdb <span class="No-Break">for debugging.</span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.1 – Basic gdb commands</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Let’s write and debug an ARM program on the Raspberry Pi. We haven’t covered the ARM architecture yet. You don’t need to know a lot about the ARM to follow the example because it’s similar to the RISC architectures we simulated in <a href="B19624_06.xhtml#_idTextAnchor091"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>. The ARM is a 32-bit computer with an RSIC architecture; that is, it is a load/store computer and the only memory accesses allowed are load and store. Operations on data are register-to-register using three operands – for example, <strong class="source-inline">add r1,r2,r3</strong>. The ARM has 16 registers, <strong class="source-inline">r0</strong> to <strong class="source-inline">r15</strong>. Registers <strong class="source-inline">r0</strong> to <strong class="source-inline">r12</strong> can be treated as general-purpose (i.e., they all behave in the same way). Registers <strong class="source-inline">r13</strong>, <strong class="source-inline">r14</strong>, and <strong class="source-inline">r15</strong> have <span class="No-Break">specific functions.</span></p>&#13;
			<h3 lang="en-GB">Pseudo instructions – a key concept</h3>&#13;
			<p lang="en-GB">The ARM assembler includes <em class="italic">pseudo-instructions</em> that are not part <a id="_idIndexMarker604"/>of the ARM’s <strong class="bold">instruction set</strong> (<strong class="bold">ISA</strong>). A pseudo-instruction is a <a id="_idIndexMarker605"/>form of shorthand that is replaced by the assembler with actual instructions. For example, suppose a computer lacked a <strong class="source-inline">clr</strong> <strong class="source-inline">r0</strong> instruction that loads <strong class="source-inline">r0</strong> with <strong class="source-inline">0</strong>. A pseudo-instruction, <strong class="source-inline">clr r0</strong>, could be devised and the assembler could automatically replace it with the <strong class="source-inline">sub r0</strong>,<strong class="source-inline">r0</strong> operation, which has the <span class="No-Break">same effect.</span></p>&#13;
			<p lang="en-GB">Pseudo-instructions make the programmer’s life easier; for example, the ARM’s <strong class="source-inline">adr</strong> <span class="pcode-bold">r0</span>,<strong class="source-inline">abc</strong> pseudo-instruction loads a 32-bit address, ABC, into <strong class="source-inline">r0</strong>. Such an instruction does not exist; the assembler replaces adr with the appropriate <span class="No-Break">ARM instructions.</span></p>&#13;
			<h4 lang="en-GB">An example of an ARM program</h4>&#13;
			<p lang="en-GB">Suppose we wish to generate the sum <a id="_idIndexMarker606"/>of the cubes of numbers from 1 to 10. The following ARM code implements this algorithm. It also uses the ARM’s four-operand <em class="italic">multiply and </em><span class="No-Break"><em class="italic">accumulate</em></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">mla</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>       mov   <strong class="bold">r0</strong>,#0           <span class="sc-comment">@ Clear the total in r0</span></span>&#13;
<span>       mov   <strong class="bold">r1</strong>,#4           <span class="sc-comment">@ FOR i = 1 to 4 (count down)</span></span>&#13;
<span><strong class="bold">Next:</strong>  mul   <strong class="bold">r2</strong>,r1,r1        /* Square a number */</span>&#13;
<span>       mla   <strong class="bold">r0</strong>,r2,r1,r0     <span class="sc-comment">@ Cube the number and add to total</span></span>&#13;
<span>       subs  <strong class="bold">r1</strong>,r1,#1        <span class="sc-comment">@ Decrement counter (and set condition flags)</span></span>&#13;
<span>       bne   <strong class="bold">Next</strong>            <span class="sc-comment">@ END FOR (branch back on count not zero)</span></span></pre>&#13;
			<p lang="en-GB">The label field beginning in the first column (bold in the preceding code) provides a <em class="italic">user-defined</em> tag that must be terminated by a colon. The label field is followed by the instruction consisting of an operation and any required operands. It doesn’t matter if there is more than one space after commas in argument lists. The text following the <strong class="source-inline">@</strong> symbol is a comment field and is ignored by the assembler. The GCC compiler also supports the C language style of comments: text delimited by <strong class="source-inline">/*  */</strong> characters, as this <span class="No-Break">example shows.</span></p>&#13;
			<p lang="en-GB"><em class="italic">Table 9.2</em> describes some of the ARM’s instructions. There is only one surprise here; the <strong class="source-inline">mla</strong> <em class="italic">multiply and add instruction</em> that specifies <em class="italic">four</em> registers. It multiplies two registers together and adds a third register, and then puts the sum in a fourth register; that is, it can calculate <strong class="source-inline">A = B + </strong><span class="No-Break"><strong class="source-inline">C.D</strong></span><span class="No-Break">:</span></p>&#13;
			<table id="table002-5" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Instruction</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">ARM mnemonic</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-2">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Definition</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><span class="No-Break">Addition</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">add </strong></span><span class="No-Break"><span class="pcode-bold">r0</span></span><span class="No-Break"><strong class="source-inline">,r1,r2</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">[r0] <span class="CharOverride-1">←</span> [r1] + [<span class="No-Break">r2]</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><span class="No-Break">Subtraction</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">sub </strong></span><span class="No-Break"><span class="pcode-bold">r0</span></span><span class="No-Break"><strong class="source-inline">,r1,r2</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">[r0] <span class="CharOverride-1">←</span> [r1] - [<span class="No-Break">r2]</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><span class="No-Break">AND</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">and </strong></span><span class="No-Break"><span class="pcode-bold">r0</span></span><span class="No-Break"><strong class="source-inline">,r1,r2</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">[r0] <span class="CharOverride-1">←</span> [r1] <span class="CharOverride-1">∧</span> [<span class="No-Break">r2]</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><span class="No-Break">OR</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">orr </strong></span><span class="No-Break"><span class="pcode-bold">r0</span></span><span class="No-Break"><strong class="source-inline">,r1,r2</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">[r0] <span class="CharOverride-1">←</span> [r1] <span class="CharOverride-1">∨</span> [<span class="No-Break">r2]</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><span class="No-Break">Exclusive OR</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">eor </strong></span><span class="No-Break"><span class="pcode-bold">r0</span></span><span class="No-Break"><strong class="source-inline">,r1,r2</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">[r0] <span class="CharOverride-1">←</span> [r1] <span class="CharOverride-1">⊕</span> [<span class="No-Break">r2]</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><span class="No-Break">Multiply</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">mul </strong></span><span class="No-Break"><span class="pcode-bold">r0</span></span><span class="No-Break"><strong class="source-inline">,r1,r2</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">[r0] <span class="CharOverride-1">←</span> [r1] <span class="CharOverride-1">×</span> [<span class="No-Break">r2]</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB"><span class="No-Break">Register-to-register move</span></p>&#13;
							<p lang="en-GB"><span class="No-Break">Literal-to-register move</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">mov </strong></span><span class="No-Break"><span class="pcode-bold">r0</span></span><span class="No-Break"><strong class="source-inline">,r1</strong></span></p>&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">mov </strong></span><span class="No-Break"><span class="pcode-bold">r0</span></span><span class="No-Break"><strong class="source-inline">,#0xAB</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-4">&#13;
							<p lang="en-GB">[r0] <span class="CharOverride-1">←</span> [<span class="No-Break">r1]</span></p>&#13;
							<p lang="en-GB">[r0] <span class="CharOverride-1">←</span> 0xAB Move <span class="No-Break">8-bit literal</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><span class="No-Break">Compare</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">cmp </strong></span><span class="No-Break"><span class="pcode-bold">r1</span></span><span class="No-Break"><strong class="source-inline">,r2</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">[r1] – [<span class="No-Break">r2]</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Branch on zero <span class="No-Break">to label</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">beq label</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">[PC] <span class="CharOverride-1">←</span> label (jump to label if z = <span class="No-Break">1)</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Branch on not zero <span class="No-Break">to label</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">bne label</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">[PC] <span class="CharOverride-1">←</span> label (jump to label if z = <span class="No-Break">0)</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Multiply <span class="No-Break">and add</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">mla </strong></span><span class="No-Break"><span class="pcode-bold">r0</span></span><span class="No-Break"><strong class="source-inline">,r1,r2,r3</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">[r0] <span class="CharOverride-1">←</span> [r1] x [r2] + [<span class="No-Break">r3]</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Load register <span class="No-Break">from memory</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">ldr </strong></span><span class="No-Break"><span class="pcode-bold">r0</span></span><span class="No-Break"><strong class="source-inline">,[r1]</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">[r0] <span class="CharOverride-1">←</span> [[<span class="No-Break">r1]]</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Store register <span class="No-Break">in memory</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">str r0,</strong></span><span class="No-Break"><span class="pcode-bold">[r1]</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">[[r1]] <span class="CharOverride-1">←</span> [<span class="No-Break">r0]</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Call the <span class="No-Break">operating system</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">svc 0</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-3">&#13;
							<p lang="en-GB">Request an operation from <span class="No-Break">the OS</span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.2 – ARM data processing, data transfer, and compare instructions</p>&#13;
			<p lang="en-GB">Some computers always update condition <a id="_idIndexMarker607"/>codes after an operation. The ARM does not automatically update its status flags after an operation; you have to command a status update by appending s to the appropriate mnemonic. For example, <strong class="source-inline">add </strong><span class="pcode-bold">r1</span><strong class="source-inline">,r2,r3</strong> performs an addition without updating status flags, whereas <strong class="source-inline">add</strong><span class="pcode-bold">s</span><strong class="source-inline"> </strong><span class="pcode-bold">r1</span><strong class="source-inline">,r2,r3</strong> updates status flags. This is not yet a program. The following provides the code and assembly language directives needed to run it on the <span class="No-Break">Raspberry Pi:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>        <strong class="bold">.global _start</strong>        <span class="sc-comment">@ Provide entry point</span></span>&#13;
<span><strong class="bold">_start:</strong> mov   <strong class="bold">r0,</strong>#0           <span class="sc-comment">@ Clear the total in r0</span></span>&#13;
<span>        mov   <strong class="bold">r1,</strong>#10          <span class="sc-comment">@ FOR i = 1 to 10 (count down)</span></span>&#13;
<span>Next:   mul   <strong class="bold">r2,</strong>r1,r1        <span class="sc-comment">/* Square a number. Note the C style comment */</span></span>&#13;
<span>        mla   <strong class="bold">r0,</strong>r2,r1,r0     <span class="sc-comment">@ Cube the number and add to total</span></span>&#13;
<span>        subs  <strong class="bold">r1,</strong>r1,#1        <span class="sc-comment">@ Decrement counter (set condition flags)</span></span>&#13;
<span>        bne   Next            <span class="sc-comment">@ END FOR (branch back on count not zero)</span></span>&#13;
<span class="sc-grey" lang="en-GB">        mov   r7,#1           <span class="sc-comment">@ r7 contains 1 to indicate a leave request</span></span>&#13;
<span class="sc-grey" lang="en-GB">        svc   #0              <span class="sc-comment">@ Call operating system to exit this code</span></span></pre>&#13;
			<p lang="en-GB">We’ve added an assembly language directive, <strong class="source-inline">.global</strong>, that declares the <strong class="source-inline">_start</strong> label as being <em class="italic">visible</em> outside this fragment of code. The GCC linking process links together separately assembled modules and inserts the appropriate addresses of the labels in <span class="No-Break">the code.</span></p>&#13;
			<p lang="en-GB">By declaring a label as global, you are telling the linker that this label is visible to other modules and they can refer to it. Labels without a global directive are local to the current module and invisible to all other modules; that is, you could use the same label in two modules and there would not be <span class="No-Break">a conflict.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The <strong class="source-inline">_start</strong> label indicates the point at which execution begins. The linker and operating system deal with storing the program in memory; that is, you don’t have to worry about where it is going to be actually stored in the computer’s <span class="No-Break">physical memory.</span></p>&#13;
			<p lang="en-GB">Finally, the last two operations (shaded) provide a means of getting back to the operating system level once the code has been executed. ARM has an <strong class="source-inline">svc</strong> instruction, which stands for <em class="italic">service call</em> and is used to invoke the operating system. Most computers have an operation such as <strong class="source-inline">svc</strong> and it has many names – for example, <em class="italic">software interrupt</em>. This instruction calls the operating system and supplies one or more parameters. The parameter can be part of the instruction itself or it <a id="_idIndexMarker608"/>can be loaded into a register. When the operating system detects a service call, the parameter is read and the appropriate operation is performed. This action is entirely system dependent; that is, it is part of the operating system and not part of the <span class="No-Break">computer’s architecture.</span></p>&#13;
			<p lang="en-GB">In this case, the specific function required by the service call is pre-loaded into <strong class="source-inline">r7</strong>. This mechanism is part of the Raspberry Pi’s <span class="No-Break">operating system.</span></p>&#13;
			<p lang="en-GB">Key points to note about the assembly language program are <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">Comments are preceded by an <strong class="source-inline">@</strong> symbol (or the C language <strong class="source-inline">/*  */</strong> <span class="No-Break">book ends)</span></li>&#13;
				<li lang="en-GB">Assembler directives are preceded by <span class="No-Break">a period</span></li>&#13;
				<li lang="en-GB">Labels begin in the first column and are terminated by <span class="No-Break">a colon</span></li>&#13;
				<li lang="en-GB">An <strong class="source-inline">.end</strong> directive can be used to terminate the assembly language (<span class="No-Break">it’s optional)</span></li>&#13;
				<li lang="en-GB">The <strong class="source-inline">.global</strong> directive provides a label that indicates the entry point of <span class="No-Break">the program</span></li>&#13;
			</ul>&#13;
			<h2 id="_idParaDest-161" lang="en-GB"><a id="_idTextAnchor174"/>Using the Raspberry Pi debugger</h2>&#13;
			<p lang="en-GB">We can now run an ARM assembly language program and observe its execution, line by line, using gdb. When you load a program into gdb, nothing appears <a id="_idIndexMarker609"/>to happen. If you try to look at your assembly language code or the registers, you will get an error message. You must explicitly run the <span class="No-Break">program first.</span></p>&#13;
			<p lang="en-GB">Consider the fragment of code in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.8</em>. This is a screenshot of the program after it’s been loaded into the Geany editor. It’s just a set of instructions and directives intended to demonstrate the steps involved in creating and testing an assembly language program. Here, we are using the Geany editor. The program demonstrates the following assembly <span class="No-Break">language directives:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB"><strong class="source-inline">.data</strong><span class="CharOverride-2">    </span>Defines a memory region where variables and constants <span class="No-Break">are stored.</span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">.text</strong><span class="CharOverride-2">    </span>Defines a region of code (i.e., the <span class="No-Break">assembly language).</span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">.word</strong><span class="CharOverride-2">    </span>Allows you to store a number in memory and give the location a <span class="No-Break">symbolic address.</span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">.balign</strong><span class="CharOverride-2">  </span>Aligns code and text on a 4-byte boundary. Required because instructions are <span class="No-Break">32 bits.</span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">.asciz</strong><span class="CharOverride-2">   </span>Creates an ASCII text string terminated by zero in memory and gives it <span class="No-Break">a name.</span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">.global</strong><span class="CharOverride-2">  </span>Makes a label visible to the linker. Otherwise, it is private to <span class="No-Break">this module.</span></li>&#13;
			</ul>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The <strong class="source-inline">balign</strong> operation is required because memory is byte addressed and ARM instructions are 4 bytes long. Consequently, instruction addresses must be 0, 4, 8, 12, 16, 20, and so on. If you put data elements in memory that are not multiples of 4 bytes (32 bits) between instructions, the program will crash. The <strong class="source-inline">balign</strong> instruction pads out any data you store with zeros to ensure that the next free address is on a <span class="No-Break">4-byte boundary.</span></p>&#13;
			<p lang="en-GB">Note that the code in <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.8</em> uses a <em class="italic">pseudo-instruction</em>. The instruction <strong class="source-inline">ldr</strong> <span class="pcode-bold">r4</span><strong class="source-inline">,=Alan3</strong> loads <strong class="source-inline">r4</strong> with the 32-bit literal, <strong class="source-inline">Alan3</strong>. The assembler will automatically substitute the necessary ARM code to perform <span class="No-Break">this operation.</span></p>&#13;
			<p lang="en-GB">The next step is to assemble and link the code, which we called a4.s (I got fed up with typing long names and called the source program a4.s). We can do this with <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>pi@raspberrypi:~ $ <strong class="bold">cd Desktop</strong>                     <span class="sc-comment"># Change to Desktop directory</span></span>&#13;
<span>pi@raspberrypi:~/Desktop $ <strong class="bold">as -g -o a4.o a4.s</strong>     <span class="sc-comment"># Assemble the program a4.s</span></span>&#13;
<span>pi@raspberrypi:~/Desktop $ <strong class="bold">ld -o a4 a4.o</strong>          <span class="sc-comment"># Now link it to create executable</span></span>&#13;
<span>pi@raspberrypi:~/Desktop $ <strong class="bold">./a4 ; echo $?</strong>         <span class="sc-comment"># Run the executable program a4</span></span></pre>&#13;
			<p lang="en-GB">The text in bold is my input. These lines change the <a id="_idIndexMarker610"/>working directory to Desktop where my source program is, and then assemble and link the source program. The final line, <strong class="source-inline">./a4 ; echo $?</strong>, runs the program and prints its return value (showing it’s been successfully executed by printing <strong class="source-inline">4</strong>, the value <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">r0</strong></span><span class="No-Break">).</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer065" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_9.08_B19624.jpg" alt="Figure 9.8 – The demonstration program in the Geany editor" width="1528" height="1036"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 9.8 – The demonstration program in the Geany editor</p>&#13;
			<p lang="en-GB">The following four lines demonstrate how we call the gdb debugger and set a breakpoint. Text in bold font indicates lines entered from the keyboard. The other text is the <span class="No-Break">debugger’s output:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>pi@raspberrypi:~/Desktop <strong class="bold">$ gdb a4</strong></span>&#13;
<span>Reading symbols from a4...done.</span>&#13;
<span>(gdb) <strong class="bold">b _start</strong></span>&#13;
<span>Breakpoint 1 at 0x10074: file a4.s, line 14.</span></pre>&#13;
			<p lang="en-GB">Entering a breakpoint is done by b &lt;breakpoint&gt;, where the breakpoint is a line number or a label. Here, it’s _start. If we run the code, it executes instructions up to the breakpoint. The next few lines are <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) <strong class="bold">run</strong></span>&#13;
<span>Starting program: /home/pi/Desktop/a4</span>&#13;
<span>Breakpoint 1, _start () at a4.s:14</span>&#13;
<span>14    _start: mov r0,#4             @ Enter here (first instruction)</span></pre>&#13;
			<p lang="en-GB">Note that you can continue from a <a id="_idIndexMarker611"/>breakpoint by entering <strong class="source-inline">c</strong> (i.e., continue) and execution will continue to the <span class="No-Break">next breakpoint.</span></p>&#13;
			<p lang="en-GB">After entering a run command, the debugger begins execution and prints the next line to be executed – that is, the line labeled by _start. The gdb instruction i r (information registers) displays the ARM’s registers <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) i r</span>&#13;
<span>r0             0x0                 0</span>&#13;
<span>r1             0x0                 0</span>&#13;
<span>r2             0x0                 0</span>&#13;
<span>r3             0x0                 0</span>&#13;
<span>r4             0x0                 0</span>&#13;
<span>r5             0x0                 0</span>&#13;
<span>r6             0x0                 0</span>&#13;
<span>r7             0x0                 0</span>&#13;
<span>r8             0x0                 0</span>&#13;
<span>r9             0x0                 0</span>&#13;
<span>r10            0x0                 0</span>&#13;
<span>r11            0x0                 0</span>&#13;
<span>r12            0x0                 0</span>&#13;
<span>sp             0xbefff390          0xbefff390</span>&#13;
<span>lr             0x0                 0</span>&#13;
<span>pc             0x10074             0x10074 &lt;_start&gt;</span>&#13;
<span>cpsr           0x10                16</span></pre>&#13;
			<pre class="source-code">fpscr          0x0                 0</pre>&#13;
			<p lang="en-GB"><strong class="source-inline">cpsr</strong> and <strong class="source-inline">fpscr</strong> are both status registers that contain information about the state of <span class="No-Break">the processor.</span></p>&#13;
			<p lang="en-GB">All registers have been initialized to zero automatically by the system software, except r13, r15 (<strong class="source-inline">sp, pc</strong>), and the two status registers. We can now start tracing the code, executing instructions one by one with the step command, <strong class="source-inline">s 1</strong>. You can just hit <strong class="source-inline">enter</strong> to trace the next instruction, as the following output demonstrates. If you were to type si 2 (or s 2), you would step <span class="No-Break">two instructions:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><strong class="bold">(gdb) si 1</strong></span>&#13;
<span>15            mov r1,#9</span>&#13;
<span><strong class="bold">(gdb)</strong></span>&#13;
<span>16            add r2,r0,r1</span>&#13;
<span><strong class="bold">(gdb)</strong></span>&#13;
<span>17            sub r3,r2,#3</span>&#13;
<span><strong class="bold">(gdb)</strong></span>&#13;
<span>18            ldr r4,=Alan3         <span class="sc-comment">@ Load an address into r4</span></span>&#13;
<span><strong class="bold">(gdb)</strong></span>&#13;
<span>19            ldr r5,[r4]           <span class="sc-comment">@ And pick up a word from memory</span></span></pre>&#13;
			<p lang="en-GB">Let’s look at the registers using the i r command. We have removed registers from this list that haven’t changed to make it easier to read. Register contents <a id="_idIndexMarker612"/>are given in hex and <span class="No-Break">decimal formats:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><strong class="bold">(gdb) i r</strong></span>&#13;
<span>r0             0x4                 4</span>&#13;
<span>r1             0x9                 9</span>&#13;
<span><strong class="bold">r2             0xd                 13</strong> <span class="sc-comment">Note: r2 is expressed in hex and decimal</span></span>&#13;
<span>r3             0xa                 10</span>&#13;
<span>r4             0x200a0             131232</span>&#13;
<span>r5             0x0                 0</span>&#13;
<span>pc             0x10088             0x10088 &lt;_start+20&gt; <span class="sc-comment">Note: 20 bytes from</span> start</span></pre>&#13;
			<p lang="en-GB">Finally, we will continue stepping until the code has been executed. You can step just by using the <em class="italic">enter</em> key after the first si <span class="No-Break">1 command:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) <strong class="bold">si 1</strong></span>&#13;
<span>21            mov r7,#1             <span class="sc-comment">@ Prepare to exit</span></span>&#13;
<span>(gdb)</span>&#13;
<span>22            svc 0                 <span class="sc-comment">@ Go</span></span>&#13;
<span>(gdb)</span></pre>&#13;
			<pre class="source-code">[Inferior 1 (process 1163) exited with code 04]</pre>&#13;
			<p lang="en-GB">The gdb executes the move and supervisor <a id="_idIndexMarker613"/>call instruction and exits the simulation. What have we learned? This example demonstrates <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">How to create an ARM assembly <span class="No-Break">language program</span></li>&#13;
				<li lang="en-GB">How to assemble and <span class="No-Break">link it</span></li>&#13;
				<li lang="en-GB">How to load it into the <span class="No-Break">gdb debugger</span></li>&#13;
				<li lang="en-GB">How to set breakpoints and run the code until a breakpoint <span class="No-Break">is reached</span></li>&#13;
				<li lang="en-GB">How to display the contents of registers at any point in <span class="No-Break">a program</span></li>&#13;
				<li lang="en-GB">How to step through the code line <span class="No-Break">by line</span></li>&#13;
			</ul>&#13;
			<h3 lang="en-GB">Tracing execution and displaying memory</h3>&#13;
			<p lang="en-GB">An important facility of a debugger is the ability to step through the code and display registers while executing a program. This allows you to follow the execution <a id="_idIndexMarker614"/>of a program and detect errors. The gdb debugger incorporates this facility via its <strong class="bold">Text User Interface (TUI). </strong>You don’t need <a id="_idIndexMarker615"/>to explicitly invoke the TUI because you can use its facilities within gdb. The most important TUI facility is its ability to display a code window and a register window by entering <span class="No-Break"><strong class="source-inline">l<a id="_idTextAnchor175"/>ayout regs</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB"><span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.9</em> provides a demonstration of the TUI with three panels. The upper window is the register window (the registers that have changed <a id="_idIndexMarker616"/>are highlighted; in this case, it’s <strong class="source-inline">r7</strong>). The middle panel displays the program code, with the next instruction to be executed highlighted. Each line includes the memory address of the code in hexadecimal form and as a distance from the <span class="No-Break"><strong class="source-inline">start</strong></span><span class="No-Break"> label.</span></p>&#13;
			<p lang="en-GB">Note that the code continues after my last instruction, <strong class="source-inline">svc</strong>. This is because the disassembler reads a block of memory and displays it as code (even if it is not part of your program). In this case, the data we entered in memory with the <strong class="source-inline">.word</strong> directive is read and displayed as the corresponding ARM instruction. Remember that the debugger does not know whether a binary value in memory is an instruction or user data. If it reads a data value corresponding to an instruction op-code, it prints <span class="No-Break">that op-code.</span></p>&#13;
			<p lang="en-GB">The disassembled instructions display their address in memory in hex form; for example, the first instruction is at <strong class="source-inline">0x10074</strong>. This address is determined by Raspberry Pi’s operating system. As you can see, each instruction has an address 4 bytes greater than the previous one because the ARM is a 32-bit machine with 32-bit, or 4-byte, instructions; hence the need for the align directive that forces the next instruction or data onto a <span class="No-Break">specific boundary.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The bottommost panel contains the commands you enter. In this case, I’ve used <strong class="source-inline">si 1</strong> to step through <span class="No-Break">the instructions.</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer066" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_9.09_B19624.jpg" alt="Figure 9.9 – The TUI showing registers and memory contents" width="982" height="1113"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – The TUI showing registers and memory contents</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Let’s look at another example of an <a id="_idIndexMarker617"/>assembly language <a id="_idIndexMarker618"/>program and its debugging. This example is designed only for demonstration purposes. It doesn’t do anything useful. Our intention is to demonstrate the features of an ARM assembly language program running under the GCC assembler and the gdb debugger. <em class="italic">Table 9.3</em> gives some of GCC’s most common <span class="No-Break">assembler directives.</span></p>&#13;
			<table id="table003-3" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">GCC </strong><span class="No-Break"><strong class="bold">Assembly directive</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Action</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="pcode-bold">.</span><span class="No-Break"><span class="pcode-bold">text</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Indicates a program segment <span class="No-Break">containing code</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="pcode-bold">.</span><span class="No-Break"><span class="pcode-bold">data</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Indicates a program segment <span class="No-Break">containing data</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="pcode-bold">.</span><span class="No-Break"><span class="pcode-bold">global</span></span><span class="No-Break"><strong class="source-inline"> label</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Makes the label visible to <span class="No-Break">the linker</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="pcode-bold">.</span><span class="No-Break"><span class="pcode-bold">extern</span></span><span class="No-Break"><strong class="source-inline"> label</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Makes the label visible outside <span class="No-Break">the file</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="pcode-bold">.byte</span><strong class="source-inline"> </strong><span class="No-Break"><strong class="source-inline">byte1,byte2, …</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Defines one or more bytes of data and stores them <span class="No-Break">in memory</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="pcode-bold">.hword</span><strong class="source-inline"> </strong><span class="No-Break"><strong class="source-inline">hw1,hw2, …</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Defines 1 or more 16-bit halfwords and stores them <span class="No-Break">in memory</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="pcode-bold">.word</span><strong class="source-inline"> </strong><span class="No-Break"><strong class="source-inline">w1,w2, …</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Defines 1 or more 32-bit words and stores them <span class="No-Break">in memory</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="pcode-bold">.</span><span class="No-Break"><span class="pcode-bold">space</span></span><span class="No-Break"><strong class="source-inline"> bytes,fill</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Fills a block of memory with a given value (e.g., <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">fill</strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline">64</strong></span><span class="No-Break">,</span><span class="No-Break"><strong class="source-inline">0xFF</strong></span><span class="No-Break">)</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">.</strong><span class="No-Break"><span class="pcode-bold">balign 4</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Aligns next address to a 4-byte boundary (you can also use 2, 4, 8, <span class="No-Break">and 16)</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="pcode-bold">.ascii</span><strong class="source-inline"> "</strong><span class="No-Break"><strong class="source-inline">any string"</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Stores an ASCII string <span class="No-Break">in memory</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="pcode-bold">.asciz</span><strong class="source-inline"> "</strong><span class="No-Break"><strong class="source-inline">any string"</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Stores an ASCII string in memory terminated <span class="No-Break">by 0</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="pcode-bold">.equ</span><strong class="source-inline"> </strong><span class="No-Break"><strong class="source-inline">symbol, value</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Equates the symbolic name to its value (e.g., <strong class="source-inline">.equ </strong><span class="No-Break"><strong class="source-inline">hours 24</strong></span><span class="No-Break">)</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="pcode-bold">.</span><span class="No-Break"><span class="pcode-bold">end</span></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Marks the end of <span class="No-Break">a program</span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.3 – GCC ARM assembler directives</p>&#13;
			<p lang="en-GB">We have presented a more detailed <a id="_idIndexMarker619"/>explanation of some of the features of the program; these are of the form <strong class="source-inline">@ PRINT </strong><span class="No-Break"><strong class="source-inline">STRING @</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>                                <span class="sc-comment">@ Test function calls and memory access</span></span>&#13;
<span><a id="_idTextAnchor176"/>         .text                  <span class="sc-comment">@ Program (code) area</span></span>&#13;
<span>         .global  _start        <span class="sc-comment">@ Provide entry point and make it known to linker</span></span>&#13;
<span>         .equ     v1,0xAB       <span class="sc-comment">@ Test equate directive</span></span>&#13;
<span>_start:   mov     r0,#23        <span class="sc-comment-bg">@ Just three dummy operations for debugging</span></span>&#13;
<span>          mov     r1,#v1        <span class="sc-comment">@ ARM assembler uses # to indicate a literal</span></span>&#13;
<span>          add     r2,r0,r1</span></pre>&#13;
			<h4 lang="en-GB">@ PRINT STRING ON CONSOLE @</h4>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>          ldr     r1, =banner   <span class="sc-comment">@ Test display function (</span><span class="sc-comment-bold">this is a pseudo-instruction</span><span class="sc-comment">)</span></span>&#13;
<span>          mov     r2,#15        <span class="sc-comment">@ Number of characters to print 13 plus two newlines)</span></span>&#13;
<span>          mov     r0,#1         <span class="sc-comment">@ Tell the OS we want to print on console display</span></span>&#13;
<span>          <strong class="bold">mov     r7,#4</strong>         <span class="sc-comment-bold">@ Tell the OS we want to perform a print operation</span></span></pre>&#13;
			<pre class="source-code">          svc     0             <span class="sc-comment">@ Call the operating system to do the printing</span></pre>&#13;
			<h4 lang="en-GB">@ USING ADR @</h4>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>          adr     r3,v3              <span class="sc-comment">@ Load address of v3 into register r3 (</span><span class="sc-comment-bold">a pseudo-instruction</span><span class="sc-comment">)</span></span>&#13;
<span>          ldr     r4,[r3]            <span class="sc-comment">@ Read contents of v3 in memory</span></span>&#13;
<span>                                     <span class="sc-comment">@ Read from memory, increment and store in next location</span></span>&#13;
<span>          ldr     r0,adr_dat1        <span class="sc-comment">@ r0 is a pointer to dat1 in memory</span></span>&#13;
<span>          ldr     r1,[r0]            <span class="sc-comment">@ Load r1 with the contents of dat1</span></span>&#13;
<span>          add     r2,r1,#1           <span class="sc-comment">@ Add 1 to dat1 and put in r2</span></span>&#13;
<span>          add     r3,r0,#4           <span class="sc-comment">@ Use r3 to point to next memory location after dat1</span></span>&#13;
<span>          str     r2,[r3]            <span class="sc-comment">@</span> <span class="sc-comment">Store new data in location after dat1</span></span></pre>&#13;
			<h4 lang="en-GB">@ EXITING THE PROGRAM @</h4>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>          mov     r0,#0              <span class="sc-comment">@ Exit status code (0 indicates OK)</span></span>&#13;
<span>          mov     r7,#1              <span class="sc-comment">@ Tell the OS we want to return from this program</span></span>&#13;
<span>          svc     0                  <span class="sc-comment">@ Call the operating system to return</span></span></pre>&#13;
			<h4 lang="en-GB">@ THE ADDRESS VECTOR @</h4>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>adr_dat1: .word   dat1               <span class="sc-comment">@ Generate an address for dat1 in the memory area</span></span>&#13;
<span>v2:       .word   0xFACE             <span class="sc-comment">@ Dummy data</span></span>&#13;
<span>banner:   .ascii "\nTest printing\n" <span class="sc-comment">@ String to print. Note newlines "\n"</span></span>&#13;
<span>                                     <span class="sc-comment">@ This string has 15 characters (13 ASCII two newlines)</span></span>&#13;
<span>          .balign 4                  <span class="sc-comment">@ Align data (0 inserted because the string is 15 chars)</span></span>&#13;
<span>v3:       .word   0x1111             <span class="sc-comment">@ Dummy test data</span></span>&#13;
<span>          .space  4,0xAB             <span class="sc-comment">@ Reserve 8 bytes of storage and fill with 0xAB</span></span>&#13;
<span>          .word   0x2222</span>&#13;
<span>          .data                      <span class="sc-comment">@ Data segment</span></span>&#13;
<span>test:     .word 0xbbbb</span>&#13;
<span>dat1:     .word 0x1234</span>&#13;
<span>          .end                       <span class="sc-comment">@ End of this program</span></span></pre>&#13;
			<p lang="en-GB">This code illustrates several points – for example, the use of assembler directives such as<strong class="source-inline">.equ</strong>, which binds a symbolic name to a value. I’ve shaded <a id="_idIndexMarker620"/>interesting blocks of code so that we can <span class="No-Break">discuss them.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">We have used ARM’s pseudo-instructions. These are <strong class="source-inline">adr </strong><span class="pcode-bold">r3</span><strong class="source-inline">,v3 and ldr </strong><span class="pcode-bold">r1</span><strong class="source-inline">,=banner</strong>. These both load 32-bit addresses into a register. Such instructions don’t exist. The ARM assembler chooses real instructions to perform the <span class="No-Break">required actions.</span></p>&#13;
			<h4 lang="en-GB">@ PRINT STRING @</h4>&#13;
			<p lang="en-GB">The first block demonstrates how we can print data from an assembly program. Well, in fact, we can’t print the data but we can ask the operating system to do it for us. Most processors have an instruction called a <em class="italic">software interrupt</em> (or a system call, a trap, an exception, or an <em class="italic">extra code</em>). All these terms refer to the same thing: an instruction inserted by the programmer that invokes the operating system. In the case of ARM, it’s the svc instruction (previously called swi). When used by Linux, this instruction is called with the parameter <strong class="source-inline">0</strong> – that is <span class="No-Break"><strong class="source-inline">svc 0</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The system call is entirely operating-system-dependent and <a id="_idIndexMarker621"/>tells the operating system what it needs by passing parameters in registers. We are going to print a string of characters on the display. The Raspberry Pi OS needs the location of the string in memory to be passed in register r1, the number of characters to print in register <strong class="source-inline">r2</strong>, the type of the display in <strong class="source-inline">r0</strong>, and the operation to be performed (printing) <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">r7</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The address of the text to be printed, <strong class="source-inline">banner</strong>, is loaded into <strong class="source-inline">r1</strong> by <strong class="source-inline">ldr</strong> <span class="pcode-bold">r1</span><strong class="source-inline">,=banner</strong>. This pseudo-instruction takes an address specified by <strong class="source-inline">=&lt;address&gt;</strong>. In the program, we have used the <strong class="source-inline">.ascii</strong> directive to store the string to print in memory. The string is text with <strong class="source-inline">\n</strong> at each end, which corresponds to the newline character. Note that the newline character code is 1 byte, although it is represented in the program by <strong class="source-inline">\n</strong>. Unless a string or other data item stored in memory is a multiple of 4 bytes, you must follow it with a <strong class="source-inline">.balign 4</strong> to ensure that the next instruction falls on a <span class="No-Break">word boundary.</span></p>&#13;
			<h4 lang="en-GB">@ USING ADR @</h4>&#13;
			<p lang="en-GB">The second block demonstrates the use of an <strong class="source-inline">adr</strong> pseudo-instruction with <strong class="source-inline">adr </strong><span class="pcode-bold">r3</span><strong class="source-inline">,v3</strong>. We are going to load register <strong class="source-inline">r3</strong> with the address of a variable we’ve called <strong class="source-inline">v3</strong> and loaded into memory with a <strong class="source-inline">.word</strong> directive. One practical consideration is that when you disassemble the code, you will not see <strong class="source-inline">adr</strong>; you’ll see the actual code that the ARM assembler translated <span class="No-Break">it into.</span></p>&#13;
			<p lang="en-GB">Putting the address of the <strong class="source-inline">v3</strong> variable into a register means we can use that register as a pointer with a load instruction; for example, <strong class="source-inline">ldr </strong><span class="pcode-bold">r4</span><strong class="source-inline">,[r3]</strong> loads the value of the variable (i.e., <strong class="source-inline">0x1111</strong> ) into <strong class="source-inline">r4</strong>. If you wish to modify that variable, you might think that you could store it back in memory with <strong class="source-inline">str r5,</strong><span class="pcode-bold">[r3]</span>. Sadly not! The <strong class="source-inline">adr</strong> instruction generates code that allows you to access only the current segment of the program. That segment is read-only because it contains the code. You cannot alter memory in that segment. If you wish to modify memory, you have to use a different technique, as we will <span class="No-Break">soon see.</span></p>&#13;
			<h4 lang="en-GB">@ EXITING THE PROGRAM @</h4>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">After an assembly language program has been executed to completion, it is necessary to return to the operating system level. Register <strong class="source-inline">r7</strong> is loaded with an exit code of <strong class="source-inline">1</strong> and an <strong class="source-inline">svc 0</strong> instruction executed to call the operating system. By convention, programmers load register r0 with their own exit code before exiting. An exit code of <strong class="source-inline">0</strong> is often used to indicate all went well, and an exit code of <strong class="source-inline">1</strong> indicates <span class="No-Break">it didn’t.</span></p>&#13;
			<h4 lang="en-GB">@ THE ADDRESS VECTOR @</h4>&#13;
			<p lang="en-GB">You can’t use the <strong class="source-inline">adr</strong> pseudo-instruction to write to read/write memory that is in a different segment to the code part of a program. This dilemma exists in all <a id="_idIndexMarker622"/>code development systems and is not peculiar to the ARM GCC environment. The ARM processor will allow you to read memory and write to memory anywhere within the logically addressable memory space. However, the ARM <em class="italic">operating system</em> does not let you write to regions of read-only memory or other forbidden areas. The trick is to create a pointer to the variable and store that pointer in the <span class="No-Break">code segment.</span></p>&#13;
			<p lang="en-GB">Consider the following assembler directive. This stores a 32-bit <strong class="source-inline">dat1</strong> value in memory at location <strong class="source-inline">adr_dat1</strong>. By convention, some programmers indicate that an item is a pointer (i.e., address) by prefixing its name with a marker (typically <strong class="source-inline">adr</strong>). This is not a rule but <span class="No-Break">a convention:</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer067" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_9.10_B19624.jpg" alt="Figure 9.10 - Creating a pointer to a data value" width="1182" height="234"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 - Creating a pointer to a data value</p>&#13;
			<p lang="en-GB">We have created a name, <strong class="source-inline">adr_dat1</strong>, which is the <em class="italic">address</em> of the address of our target variable. The value stored is the address of the actual variable, <strong class="source-inline">dat1</strong>. So, when we write the instruction <strong class="source-inline">ldr r0,adr_dat1</strong>, the <em class="italic">address</em> of <strong class="source-inline">dat1</strong> is loaded in register <strong class="source-inline">r0</strong>. That is, register <strong class="source-inline">r0</strong> now points <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">dat1</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">In the data section headed by <strong class="source-inline">.data</strong>, we have <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>dat1:     .word 0x1234   <span class="sc-comment">@ The value 0x1234 is stored in memory at address dat1</span></span></pre>&#13;
			<p lang="en-GB">This stores the <strong class="source-inline">0x1234</strong> value in memory and gives it the name <strong class="source-inline">dat1</strong>. As we have seen, that name is used to create the address of the variable in the code section by <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>adr_dat1: .word   dat1</span></pre>&#13;
			<p lang="en-GB">The next step is to run the code. We’ve done this and have provided an edited output from the session (removing empty prompt lines between operations and some text) in <span class="No-Break"><em class="italic">Listing 9.1</em></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><strong class="source-inline">pi@raspberrypi:~ $ cd Desktop</strong></span>&#13;
<span><strong class="source-inline">pi@raspberrypi:~/Desktop $ as -g -o t1a.o t1a.s</strong></span>&#13;
<span><strong class="source-inline">pi@raspberrypi:~/Desktop $ ld -o t1a t1a.o</strong></span>&#13;
<span><strong class="source-inline">pi@raspberrypi:~/Desktop $ gdb</strong></span>&#13;
<span><strong class="source-inline">GNU gdb (Raspbian 8.2.1-2) 8.2.1</strong></span>&#13;
<span><strong class="source-inline">(gdb) file t1a</strong></span>&#13;
<span><strong class="source-inline">Reading symbols from t1a...done.</strong></span>&#13;
<span>(<strong class="source-inline">gdb) b _start</strong></span>&#13;
<span><strong class="source-inline">Breakpoint 1 at 0x10074: file t1a.s, line 7.</strong></span>&#13;
<span><strong class="source-inline">(gdb) r 1</strong></span>&#13;
<span><strong class="source-inline">Starting program: /home/pi/Desktop/t1a 1</strong></span>&#13;
<span><strong class="source-inline">Breakpoint 1, _start () at t1a.s:7</strong></span>&#13;
<span><strong class="source-inline">7    _start: mov     r0,#23        </strong><span class="sc-comment">@ Just three dummy operations for debugging</span></span>&#13;
<span><strong class="source-inline">(gdb) si 1</strong></span>&#13;
<span><strong class="source-inline">8            mov     r1,#v1</strong></span>&#13;
<span><strong class="source-inline">9            add     r2,r0,r1</strong></span>&#13;
<span><strong class="source-inline">11           ldr     r1,=banner   </strong><span class="sc-comment">@ Test display function (r1 has address of a string)</span></span>&#13;
<span><strong class="source-inline">12           mov     r2,#15        </strong><span class="sc-comment">@ Number of characters to print 13 plus two newlines)</span></span>&#13;
<span><strong class="source-inline">13           mov     r0,#1         </strong><span class="sc-comment">@ Tell the OS we want to print on console display</span></span>&#13;
<span><strong class="source-inline">14           mov     r7,#4         </strong><span class="sc-comment">@ Tell the OS we want to perform a print operation</span></span>&#13;
<span><strong class="source-inline">15           svc     0             </strong><span class="sc-comment">@ Call the operating system to do the printing</span></span>&#13;
<span><span class="pcode-bold">Test printing</span></span>&#13;
<span><strong class="source-inline">17           adr     r3,v3         </strong><span class="sc-comment">@ Load address of v3</span></span>&#13;
<span><strong class="source-inline">18           ldr     r4,[r3]       </strong><span class="sc-comment">@ Read its contents in memory</span></span>&#13;
<span><strong class="source-inline">21           ldr     r0,adr_dat1   </strong><span class="sc-comment">@ r0 is a pointer to dat1 in memory</span></span>&#13;
<span><strong class="source-inline">22           ldr     r1,[r0]       </strong><span class="sc-comment">@ Load r1 with the contents of data1</span></span>&#13;
<span><strong class="source-inline">23           add     r2,r1,#1      </strong><span class="sc-comment">@ Add 1 to dat1 and put in r2</span></span>&#13;
<span><strong class="source-inline">24           add     r3,r0,#4      </strong><span class="sc-comment">@ Use r3 to point to next memory location after dat1</span></span>&#13;
<span><strong class="source-inline">25           str     r2,[r3]       </strong><span class="sc-comment">@ Store new data in location after dat1</span></span>&#13;
<span><strong class="source-inline">(gdb) i r r0 r1 r2 r3</strong></span>&#13;
<span><strong class="source-inline">r0           0x200e8             131304</strong></span>&#13;
<span><strong class="source-inline">r1           0x1234              4660</strong></span>&#13;
<span><strong class="source-inline">r2           0x1235              4661</strong></span>&#13;
<span><strong class="source-inline">r3           0x200ec             131308</strong></span>&#13;
<span><strong class="source-inline">(gdb) si 1</strong></span>&#13;
<span><strong class="source-inline">28          mov    r0,#0           </strong><span class="sc-comment">@ Exit status code (indicates OK)</span></span>&#13;
<span><strong class="source-inline">29          mov    r7,#1           </strong><span class="sc-comment">@ Tell the OS we want to return from this program</span></span>&#13;
<span><strong class="source-inline">30          svc    0               </strong><span class="sc-comment">@ Call the operating system to return</span></span>&#13;
<span><strong class="source-inline">(gdb) </strong><span class="pcode-bold">x/2xw 0x200e8</span></span>&#13;
<span><strong class="source-inline">0x200e8:    0x00001234    0x00001235</strong></span>&#13;
<span><strong class="source-inline">(gdb) si 1</strong></span>&#13;
<span><strong class="source-inline">[Inferior 1 (process 7601) exited normally]</strong></span></pre>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Listing 9.1 – A debugging session</p>&#13;
			<h2 id="_idParaDest-162" lang="en-GB"><a id="_idTextAnchor177"/>Accessing memory</h2>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">We have demonstrated how you can step through a program and display registers as instructions are executed. For example, gdb lets you display the contents of registers <strong class="source-inline">r0</strong> to <strong class="source-inline">r3</strong> using the <strong class="source-inline">i r r0 r1 r2 r3</strong> command. We will now demonstrate how the contents of memory locations can <span class="No-Break">be displayed.</span></p>&#13;
			<p lang="en-GB">In <em class="italic">Listing 9.1</em>, we single-step the code through <a id="_idIndexMarker623"/>the first few instructions (memory access and store operations) and then, after line 25, we can see that the address of the <strong class="source-inline">dat3</strong> variable is <strong class="source-inline">0x200e8</strong>. Suppose we want to check that its value is <strong class="source-inline">0x1234</strong>, and that the next word location 4 bytes on, <strong class="source-inline">0x2008c</strong>, contains the <span class="No-Break"><strong class="source-inline">0x1235</strong></span><span class="No-Break"> value.</span></p>&#13;
			<p lang="en-GB">You might reasonably expect that the <strong class="source-inline">gdb</strong> command to read the memory location is <strong class="source-inline">m</strong> <strong class="source-inline">0x200c</strong>. As you can see from <em class="italic">Listing 9.1</em>, the command is the rather <span class="No-Break">less memorable:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><a id="_idTextAnchor178"/>x/2xw 0x2208    Read the contents of two memory locations</span></pre>&#13;
			<p lang="en-GB">The memory access command is <span class="pcode-bold">x/</span> and the three required parameters are <span class="pcode-bold">2xw</span>. These are <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB"><strong class="source-inline">2</strong>   The number of memory locations to <span class="No-Break">be displayed.</span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">x</strong>   The format of the data. <strong class="source-inline">x</strong> <span class="No-Break">indicates hexadecimal.</span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">w</strong>   The width of the data (number of bytes). <strong class="source-inline">w</strong> indicates a 4-byte <span class="No-Break">32-bit word.</span></li>&#13;
			</ul>&#13;
			<p lang="en-GB">The available formats are <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB"><strong class="source-inline">o</strong>   <span class="No-Break">octal</span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">d</strong>   <span class="No-Break">decimal</span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">x</strong>   <span class="No-Break">hexadecimal</span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">u</strong>   <span class="No-Break">unsigned integer</span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">s</strong>   <span class="No-Break">string</span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">b</strong>   <span class="No-Break">byte</span></li>&#13;
			</ul>&#13;
			<p lang="en-GB">The data display sizes are <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB"><strong class="source-inline">b</strong>   <span class="No-Break">byte</span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">h</strong>   halfword (<span class="No-Break">16 bits)</span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">w</strong>   word (<span class="No-Break">32 bits)</span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">g</strong>   double word (giant word of 8 bytes or <span class="No-Break">64 bits)</span></li>&#13;
			</ul>&#13;
			<p lang="en-GB">Consider <span class="No-Break">these </span><span class="No-Break"><a id="_idIndexMarker624"/></span><span class="No-Break">examples:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB"><strong class="source-inline">x/1xw 0x1234</strong>   Print one 4-byte word in hex form at <span class="No-Break">address </span><span class="No-Break"><strong class="source-inline">0x1234</strong></span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">x/6xh 0x1234</strong>   Print six 2-byte values in hex form at <span class="No-Break">address </span><span class="No-Break"><strong class="source-inline">0x1234</strong></span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">x/3db 0x1234</strong>   Print three one-byte values in decimal form at <span class="No-Break">address </span><span class="No-Break"><strong class="source-inline">0x1234</strong></span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">x/9sb 0x1234</strong>   Print nine one-byte characters in string form at <span class="No-Break">address </span><span class="No-Break"><strong class="source-inline">0x1234</strong></span></li>&#13;
			</ul>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">In the next section, we are now going to look at the ARM GCC assembler in a little more detail. For example, we will introduce the ARM’s assembler directives that control the allocation of memory to <span class="No-Break">a program.</span></p>&#13;
			<h1 id="_idParaDest-163" lang="en-GB"><a id="_idTextAnchor179"/>Features of the GCC ARM assembler</h1>&#13;
			<p lang="en-GB">We will begin this section by looking at how memory space can be reserved for constants and variables. We have already seen that <a id="_idIndexMarker625"/>literals in the ARM assembly language are prefixed by a <strong class="source-inline">#</strong> symbol. Numbers are regarded as decimal unless prefixed by <strong class="source-inline">0x</strong>, which indicates hexadecimal – for example, <strong class="source-inline">mov r0,#0x2C</strong>. ASCII characters are indicated by using single quotes, as in <span class="No-Break">this example:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>      cmp   <strong class="bold">r0</strong>,#'A'            <span class="sc-comment">@ Was it a letter 'A'?</span></span></pre>&#13;
			<p lang="en-GB">Two important assembler directives are <strong class="source-inline">.equ</strong>, which binds a name to a value, and <strong class="source-inline">.word</strong>, which allows you to preload memory with data before a program runs. The <strong class="source-inline">.equ</strong> directive is very easy to understand; it binds a numeric value to a name. Consider <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>      .equ  Tuesday, 2</span></pre>&#13;
			<p lang="en-GB">This assembly directive binds the name <strong class="source-inline">Tuesday</strong> to the value <strong class="source-inline">2</strong>. Whenever you write <strong class="source-inline">Tuesday</strong>, the assembler replaces it with <strong class="source-inline">2</strong>. The GCC ARM <strong class="source-inline">.word</strong> assembler directive reserves memory space for constants and variables; that is, it declares a variable (or constant) and initializes it. Consider the <span class="No-Break">following example:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>      .equ    Value1,12        <span class="sc-comment">@ Associate name Value1 with 12</span></span>&#13;
<span>      .equ    Value2,45        <span class="sc-comment">@ Associate name Value2 with 45</span></span>&#13;
<span>      .word   Table,Value1     <span class="sc-comment">@ Store the 32-bit word 12 in memory at address Table</span></span>&#13;
<span>      .word   Value2           <span class="sc-comment">@ Store the word 45 in memory</span></span>&#13;
<span>      .word   Value2 + 14      <span class="sc-comment">@ Store  45 + 14 = 59 in memory (you can use expressions)</span></span></pre>&#13;
			<p lang="en-GB">The <strong class="source-inline">.word</strong> directive reserves a 32-bit word (i.e., 4 bytes) of storage in memory and loads whatever value the expression to the right of <strong class="source-inline">.word</strong> yields into that location. In this case, we’ve bound <strong class="source-inline">Value1</strong> to the number <strong class="source-inline">12</strong> and, therefore, the binary value <strong class="source-inline">00000000000000000000000000001100</strong> will be stored at this location. The next memory location used is the next free location (i.e., storage directives store data in <span class="No-Break">memory sequentially).</span></p>&#13;
			<p lang="en-GB">The <em class="italic">location counter</em> is advanced by four bytes so that the next <strong class="source-inline">.word</strong> or instruction will be placed in the next word in memory. The term <em class="italic">location counter</em> refers to the pointer to the next location in memory when a program is being assembled and is similar, in concept, to the <span class="No-Break">program counter.</span></p>&#13;
			<p lang="en-GB">You don’t have to use 32-bit values in the ARM programs. The<strong class="source-inline">.byte</strong> and <strong class="source-inline">.hword</strong> assembler directives store a byte and a 16-bit halfword in memory, respectively, as in <span class="No-Break">this example:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>Q1:    .byte        25                  <span class="sc-comment">@ Store the byte 25 in memory</span></span>&#13;
<span>Q2:    .byte        42                  <span class="sc-comment">@ Store the byte 42 in memory</span></span>&#13;
<span>Tx2:   .hword       12342               <span class="sc-comment">@ Store the 16-bit halfword 12,342 in memory</span></span></pre>&#13;
			<p lang="en-GB">Although you could use <strong class="source-inline">.byte</strong> to store text strings in memory, it would be very clumsy because you would have to look up the ASCII value of each character. The GCC ARM assembler provides a simpler mechanism. The <strong class="source-inline">.ascii</strong> directive takes a string and <a id="_idIndexMarker626"/>stores each character as an 8-bit ASCII-encoded byte in consecutive memory locations. The <strong class="source-inline">.asciz</strong> command performs the same function but inserts an 8-bit binary byte of all 0s as <span class="No-Break">a terminator:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>Mess1: .ascii    "This is message 1"    <span class="sc-comment">@ Store string memory</span></span>&#13;
<span>Mess2: .asciz    "This is message 2"    <span class="sc-comment">@ Store string followed by 0</span></span>&#13;
<span>       .balign  4                       <span class="sc-comment">@ Align code on word boundary</span></span></pre>&#13;
			<p lang="en-GB">Because the ARM aligns all instructions on 32-bit word boundaries, the <strong class="source-inline">.balign 4</strong> directive is required to align whatever follows on the next word boundary (the 4 indicates a 4-byte boundary). In other words, if you store three 8-bit characters in memory, the <strong class="source-inline">.balign 4</strong> command skips a byte to force the next address to a 32-bit boundary. Note that <strong class="source-inline">.balign 2</strong> forces alignment on a halfword boundary (you can use <strong class="source-inline">.balign 16</strong>, or any other power of 2, to force the next memory access to be <span class="No-Break">appropriately aligned).</span></p>&#13;
			<p lang="en-GB">The following ARM code demonstrates storage allocation and the use of the <strong class="source-inline">.balign </strong><span class="No-Break"><strong class="source-inline">4</strong></span><span class="No-Break"> directive:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>        .global  _start                 <span class="sc-comment">@ Tell the linker where we start from</span></span>&#13;
<span>        .text                           <span class="sc-comment">@ This is a text (code) segment</span></span>&#13;
<span>_start: mov     r0,#XX                  <span class="sc-comment">@ Load r0 with 5 (i.e., XX)</span></span>&#13;
<span>        mov     r1,#P1                  <span class="sc-comment">@ Load r1 with P1 which is equated to 0x12 or 18 decimal</span></span>&#13;
<span>        add     r2,r0,r1                <span class="sc-comment">@ Just a dummy instruction</span></span>&#13;
<span>        add     r3,r2,#YY               <span class="sc-comment">@ Test equate to ASCII byte (should be 0x42 for 'B')</span></span>&#13;
<span>        adr     r4,test                 <span class="sc-comment">@ Let's load an address (i.e., location of variable test)</span></span>&#13;
<span>        ldr     r5,[r4]                 <span class="sc-comment">@ Now, access that variable which should be 0xBB)</span></span>&#13;
<span>Again:  b       Again                   <span class="sc-comment">@ Eternal endless loop (terminate here)</span></span>&#13;
<span>       .equ     XX,5                    <span class="sc-comment">@ Equate XX to 5</span></span>&#13;
<span>       .equ     P1,0x12                 <span class="sc-comment">@ Equate P1 to 0x12</span></span>&#13;
<span>       .equ     YY,'B'                  <span class="sc-comment">@ Equate YY to the ASCII value for 'B'</span></span>&#13;
<span>       .ascii   "Hello"                 <span class="sc-comment">@ Store the ASCII byte string "Hello"</span></span>&#13;
<span>       .balign  4                       <span class="sc-comment">@ Ensure code is on a 32-bit word boundary</span></span>&#13;
<span>       .ascii   "Hello"                 <span class="sc-comment">@ Store the ASCII byte string "Hello"</span></span>&#13;
<span>       .byte    0xAA                    <span class="sc-comment">@ Store the byte 0xAA in memory</span></span>&#13;
<span>test:  .byte    0xBB                    <span class="sc-comment">@ Store the byte 0xBB in memory</span></span>&#13;
<span>       .balign  2                       <span class="sc-comment">@ Ensure code is on a 16-bit halfword boundary</span></span>&#13;
<span>       .hword   0xABCD                  <span class="sc-comment">@ Store the 16-bit halfword 0xABCD in memory</span></span>&#13;
<span>last:  .word    0x12345678              <span class="sc-comment">@ Store a 32-bit hex value in memory</span></span>&#13;
<span>       .end</span></pre>&#13;
			<p lang="en-GB">Let’s assemble, link, and run this <a id="_idIndexMarker627"/>code on a Raspberry Pi using gdb. The first few lines from the terminal windows show the loading of the program, setting a breakpoint, and executing in a <span class="No-Break">single-step mode:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>pi@raspberrypi:~ $ cd Desktop</span>&#13;
<span>pi@raspberrypi:~/Desktop $ as -g -o labels.o labels.s</span>&#13;
<span>pi@raspberrypi:~/Desktop $ ld -o labels labels.o</span>&#13;
<span>pi@raspberrypi:~/Desktop $ gdb labels</span>&#13;
<span>GNU gdb (Raspbian 8.2.1-2) 8.2.1</span>&#13;
<span>Reading symbols from labels...done.</span>&#13;
<span>(gdb) b _start</span>&#13;
<span>Breakpoint 1 at 0x10054: file labels.s, line 3.</span>&#13;
<span>(gdb) run 1</span>&#13;
<span>Starting program: /home/pi/Desktop/labels 1</span>&#13;
<span>Breakpoint 1, _start () at labels.s:3</span>&#13;
<span>3    _start: mov     r0,#XX             <span class="sc-comment">@ Load r0 with 5 (i.e., XX)</span></span>&#13;
<span>(gdb) si 1</span>&#13;
<span>4            mov     r1,#P1             <span class="sc-comment">@ Load r1 with 0x12 (i.e., P1)</span></span>&#13;
<span>5            add     r2,r0,r1           <span class="sc-comment">@ Dummy instruction (r2 is 5+0x12=0x17)</span></span>&#13;
<span>6            add     r3,r2,#YY          <span class="sc-comment">@ Dummy instruction (r3 is 0x17+0x42=0x59)</span></span>&#13;
<span>7            adr     r4,test</span>&#13;
<span>8            ldr     r5,[r4]</span>&#13;
<span>Again () at labels.s:9</span>&#13;
<span>9    Again:  b       Again              <span class="sc-comment">@ Eternal endless loop (enter control-C to exit)</span></span></pre>&#13;
			<p lang="en-GB">So far, so good. Let’s see what the registers hold. We have deleted lines with registers that we’re not interested in to make the output <span class="No-Break">more readable:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) i r</span>&#13;
<span>r0             0x5                 5</span>&#13;
<span>r1             0x12                18</span>&#13;
<span>r2             0x17                23</span>&#13;
<span>r3             0x59                89 <span class="sc-comment">Note 0x59 = 0x17 + 0x42</span></span>&#13;
<span>r4             0x1007e             65662</span>&#13;
<span>r5             0xabcd00bb          2882339003</span>&#13;
<span>pc             0x1006c Current pc     0x1006c &lt;Again&gt;</span></pre>&#13;
			<p lang="en-GB">Registers <strong class="source-inline">r0</strong> to <strong class="source-inline">r3</strong> contain what we would expect (<strong class="source-inline">r3</strong> is <strong class="source-inline">0x17</strong> in <strong class="source-inline">r3</strong> plus the <strong class="source-inline">0x42</strong> code for <strong class="source-inline">'B'</strong> which <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">0x59</strong></span><span class="No-Break">).</span></p>&#13;
			<p lang="en-GB">Register r4 contains <strong class="source-inline">0x1007e</strong>, which is the address of the data called <strong class="source-inline">test</strong>: (i.e., <strong class="source-inline">0xBB</strong>) in memory. That address is used to load the <strong class="source-inline">0xBB</strong> constant into <strong class="source-inline">r5</strong>, which now contains <strong class="source-inline">0xABCD00BB</strong> and not <strong class="source-inline">0x000000BB</strong> as we expected. What <span class="No-Break">went wrong?</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The problem is that <strong class="source-inline">ldr</strong> loads a 32-bit value into a register from memory. <strong class="source-inline">0xABCD00</strong> is the word following <strong class="source-inline">0xBB</strong> plus a null byte due to the <strong class="source-inline">.balign</strong> <strong class="source-inline">2</strong> statement. We should have used a special <em class="italic">“load a byte”</em> instruction, loaded four bytes and cleared three to zero, or aligned the byte correctly in memory. The great strength of a computer is that it does what you tell it. Alas, its great weakness is that…it does <em class="italic">exactly</em> what you <span class="No-Break">tell it.</span></p>&#13;
			<p lang="en-GB">Next, we look at the data stored in memory using the <strong class="source-inline">x/7xw 0x1006c</strong> command, which displays <strong class="source-inline">7</strong> words of memory in hexadecimal form starting at address <strong class="source-inline">0x1006c</strong> (we got that address from the <strong class="source-inline">pc</strong> in the register dump). Remember that it’s the ARM’s operating system that initially sets up the <span class="No-Break">program counter:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) <strong class="bold">x/7xw 0x1006c</strong></span>&#13;
<span>0x1006c &lt;Again&gt;:    0xeafffffe 0x6c6c6548 0x0000006f 0x6c6c6548</span>&#13;
<span>0x1007c &lt;Again+16&gt;: 0x00bbaa6f 0x5678abcd 0x00001234</span></pre>&#13;
			<p lang="en-GB">We can also look at the data stored in memory <a id="_idIndexMarker628"/>in byte form using <strong class="source-inline">x/28xb 0x1006c</strong>, which displays <strong class="source-inline">7</strong> words (4 x 7 = 28 bytes) of memory in hexadecimal form starting at <span class="No-Break">address </span><span class="No-Break"><strong class="source-inline">0x1006c</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) x/28xb 0x1006c</span>&#13;
<span>0x1006c &lt;Again&gt;:      0xfe   0xff   0xff   0xea   <span class="sc-source-bg">0x48   0x65   0x6c   0x6c</span></span>&#13;
<span>0x10074 &lt;Again+8&gt;:    <span class="sc-source-bg">0x6f</span>   0x00   0x00   0x00   <span class="sc-source-bg">0x48   0x65   0x6c   0x6c</span></span>&#13;
<span>0x1007c &lt;Again+16&gt;:   <span class="sc-source-bg">0x6f</span>   0xaa   0xbb   0x00   <span class="sc-source-bg">0xcd   0xab</span>   0x78   0x56</span>&#13;
<span>0x10084 &lt;last+2&gt;:     0x34   0x12   0x00   0x00</span></pre>&#13;
			<p lang="en-GB"><span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.10</em> provides a memory map demonstrating the allocation of memory. The bold hexadecimal addresses are the 4-byte word boundaries. You can see how the <strong class="source-inline">.balign</strong> directives insert zeros as padding in memory to form the <span class="No-Break">required boundaries.</span></p>&#13;
			<p lang="en-GB">In the next section, we look at one of the key aspects of modern computer design – how a computer with a 32-bit word length can load a 32-bit value into <span class="No-Break">a register:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><span class="pcode-bold">000000010070</span>     <strong class="source-inline">48</strong>             <span class="sc-comment">ASCII H start of the sequence Hello</span></span>&#13;
<span><strong class="source-inline">000000000071</strong>     <strong class="source-inline">65</strong>             <span class="sc-comment">ASCII e</span></span>&#13;
<span><strong class="source-inline">000000000072</strong>     <strong class="source-inline">6C</strong>             <span class="sc-comment">ASCII l</span></span>&#13;
<span><strong class="source-inline">000000000073</strong>     <strong class="source-inline">6C</strong>             <span class="sc-comment">ASCII l</span></span>&#13;
<span><span class="pcode-bold">000000000074</span>     <strong class="source-inline">6F</strong>             <span class="sc-comment">ASCII o</span></span>&#13;
<span><strong class="source-inline">000000000075</strong>     <strong class="source-inline">00</strong>             <span class="sc-comment">Padded zero due to align</span></span>&#13;
<span><strong class="source-inline">000000000076</strong>     <strong class="source-inline">00</strong>             <span class="sc-comment">Padded zero due to align</span></span>&#13;
<span><strong class="source-inline">000000000077</strong>     <strong class="source-inline">0</strong>              <span class="sc-comment">Padded zero due to align</span></span>&#13;
<span><span class="pcode-bold">000000010078</span>     <strong class="source-inline">48</strong>             <span class="sc-comment">ASCII H</span></span>&#13;
<span><strong class="source-inline">000000000079</strong>     <strong class="source-inline">65</strong>             <span class="sc-comment">ASCII e</span></span>&#13;
<span><strong class="source-inline">00000000007A</strong>     <strong class="source-inline">6C</strong>             <span class="sc-comment">ASCII l</span></span>&#13;
<span><strong class="source-inline">00000000007B</strong>     <strong class="source-inline">6C</strong>             <span class="sc-comment">ASCII l</span></span>&#13;
<span><span class="pcode-bold">00000000007C</span>     <span class="pcode-bold">6C</span>             <span class="sc-comment">ASCII o</span></span>&#13;
<span><strong class="source-inline">00000000007D</strong>     <strong class="source-inline">0xAA</strong>           <span class="sc-comment">Byte 0xAA</span></span>&#13;
<span><strong class="source-inline">00000000007E</strong>     <strong class="source-inline">0xBB</strong>           <span class="sc-comment">Byte 0xBB</span></span>&#13;
<span><strong class="source-inline">00000000007F</strong>     <strong class="source-inline">00</strong>             <span class="sc-comment">Padded zero due to align</span></span>&#13;
<span><span class="pcode-bold">000000000080</span>     <strong class="source-inline">0xAB</strong>           <span class="sc-comment">First byte of 0xABCD</span></span>&#13;
<span><strong class="source-inline">000000000081</strong>     <strong class="source-inline">0xCD</strong>           <span class="sc-comment">Second byte of 0xABCD</span></span></pre>&#13;
			<p class="IMG---Caption">Figure 9.10 – Allocating data to memory – the memory map</p>&#13;
			<p lang="en-GB">We next look at a dilemma that affects <a id="_idIndexMarker629"/>all computers: how do you load a constant (literal) that is the same size as the <span class="No-Break">instruction word?</span></p>&#13;
			<h1 id="_idParaDest-164" lang="en-GB"><a id="_idTextAnchor180"/>Dealing with 32-bit literals</h1>&#13;
			<p lang="en-GB">Here, you will learn how the ARM uses a 32-bit instruction to load a 32-bit literal. A literal can’t be combined with an op-code as we have done in the simulators. We will <a id="_idIndexMarker630"/>demonstrate how the ARM uses several techniques to use a 32-bit instruction to access a <span class="No-Break">32-bit literal.</span></p>&#13;
			<p lang="en-GB">The ARM has 32-bit data words and instructions. You can’t load a 32-bit literal into an ARM register in one instruction because you can’t specify both the operation and the data in one instruction. CISC processors chain two or more instructions together; for example, a 16-bit machine might take 2 instruction words to create a 32-bit instruction containing a 16-bit operation and a 16-bit literal. Some processors load a 16-bit literal (load high) with one instruction and then load a second 16-bit literal (load low) with a second instruction. The computer then concatenates the high and low halfword 16-bit values into a <span class="No-Break">32-bit literal.</span></p>&#13;
			<p lang="en-GB">The ARM has two pseudo-instructions that can load a 32-bit value into a register by letting the assembler generate the actual code needed to do this. The pseudo-instruction <strong class="source-inline">adr</strong> (load address) has the format adr r<span class="subscript">destination</span>,label, where <strong class="source-inline">label</strong> indicates a line (address) in the program. <strong class="source-inline">adr</strong> lets the assembler generate the appropriate machine code and relieves the programmer of some <em class="italic">housekeeping</em>. The <strong class="source-inline">adr</strong> uses the ARM’s <strong class="source-inline">add</strong> or <strong class="source-inline">sub</strong> instruction together with <em class="italic">PC relative addressing</em> to generate the required address. Program counter-relative addressing specifies an address by its distance from the current instruction. The following code fragment demonstrates the use <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">adr</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>          <strong class="bold">adr    r0,someData</strong>    <span class="sc-comment">@ Setup r1 to point to someData in memory</span></span>&#13;
<span>          ldr    <strong class="bold">r1</strong>,[r0]        <span class="sc-comment">@ Read someData using the pointer in r0</span></span>&#13;
<span>          .        .</span>&#13;
<span>someData: .word  0x12345678     <span class="sc-comment">@ Here's the data</span></span></pre>&#13;
			<p lang="en-GB">The pseudo-instruction <strong class="source-inline">adr </strong><span class="pcode-bold">r0</span>,<strong class="source-inline">someData</strong> loads register <strong class="source-inline">r0</strong> with the 32-bit address of <strong class="source-inline">someData</strong> using the appropriate code generated by the assembler. You don’t normally <a id="_idIndexMarker631"/>have to know how the assembler generates the actual code to implement <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">adr</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">Another useful ARM pseudo-instruction is <strong class="source-inline">ldr</strong> <span class="pcode-bold">r1</span><strong class="source-inline">,=value</strong>. In this case, the compiler generates the code that allows register r1 to be loaded with the stated value, as in <span class="No-Break">this example:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>      ldr r2, =0x12345678       <span class="sc-comment">@ Load a 32-bit literal into r2</span></span></pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">This loads r2 with 12345678<span class="subscript">16</span>. The assembler employs a <strong class="source-inline">mov</strong> or <strong class="source-inline">mvn</strong> instruction if it can. The ARM’s unusual <em class="italic">move</em> <strong class="source-inline">not</strong> instruction takes an 8-bit literal, inverts the bits, and moves it to a register. For example <strong class="source-inline">MVN r1,#0xF0</strong> copies <strong class="source-inline">0x0F</strong> to <span class="pcode-bold">r1</span>. Alternatively, the assembler uses an <strong class="source-inline">ldr</strong><strong class="source-inline"> </strong><span class="pcode-bold">r2</span><strong class="source-inline">,[pc,#offset]</strong> instruction to access the appropriate constant 12345678<span class="subscript">16</span> that is stored in a so-called <em class="italic">literal pool</em> or <em class="italic">constant pool</em> somewhere in memory. A literal pool is one or more data items embedded <span class="No-Break">in code.</span></p>&#13;
			<p lang="en-GB">Let’s look at how pseudo-instructions are treated by the GCC assembler development system. Consider the following fragment <span class="No-Break">of code:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>        .text</span>&#13;
<span>        .global _start</span>&#13;
<span>_start: ldr    r0,=0x12345678   <span class="sc-comment">@ Load r0 with a 32-bit constant</span></span>&#13;
<span>        adr    r1,Table1        <span class="sc-comment">@ Load r1 with the address of Table1</span></span>&#13;
<span>        adr    r2,Table2        <span class="sc-comment">@ Load r2 with the address of Table2</span></span>&#13;
<span>        ldr    r3,[r1]          <span class="sc-comment">@ Load r3 with data in Table1</span></span>&#13;
<span>        ldr    r4,[r2]          <span class="sc-comment">@ Load r4 with data in Table2</span></span>&#13;
<span>        ldr    r5, =0xAAAAAAAA  <span class="sc-comment">@ Load r5 with a 32-bit constant</span></span>&#13;
<span>wait:   mov    r0,#0            <span class="sc-comment">@ Goodbye message</span></span>&#13;
<span>        mov    r7,#1            <span class="sc-comment">@ Goodbye command in r7</span></span>&#13;
<span>        svc    0                <span class="sc-comment">@ Call operating system to return</span></span>&#13;
<span>Table1: .word  0xABCDDCBA       <span class="sc-comment">@ Dummy data</span></span>&#13;
<span>Table2: .word  0xFFFFFFFF</span></pre>&#13;
			<p lang="en-GB">The following is the edited output of a gdb debugger session. The code has been executed to completion and the register contents are as follows. The righthand column displays the data in <span class="No-Break">decimal form:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>r0             0x0                 0</span>&#13;
<span>r1             0x10078             65656</span>&#13;
<span>r2             0x1007c             65660</span>&#13;
<span>r3             0xabcddcba          2882395322</span>&#13;
<span>r4             0xffffffff          4294967295</span>&#13;
<span>r5             0xaaaaaaaa          2863311530</span>&#13;
<span>pc             0x10074             0x10074 &lt;wait+8&gt;</span></pre>&#13;
			<p lang="en-GB">The pointer registers, <strong class="source-inline">r1</strong> and <strong class="source-inline">r2</strong>, have been loaded with the addresses of the two data elements in memory (i.e., Table1 and Table2). These pointers have been used to retrieve the two elements, and you can see from the debugger that the <span class="No-Break">operation worked.</span></p>&#13;
			<p lang="en-GB">The following debugger output <a id="_idIndexMarker632"/>provides a disassembly of the code. This is not what was written. The assembler has converted the three pseudo-operations into actual ARM code (in <span class="No-Break">bold font):</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>Dump of assembler code from 0x10054 to 0x10086:</span>&#13;
<span>   <strong class="bold">0x00010054 &lt;_start+0&gt;:    ldr    r0, [pc, #36]    ; 0x10080 &lt;Table2+4&gt;</strong></span>&#13;
<span>   <strong class="bold">0x00010058 &lt;_start+4&gt;:    add    r1, pc, #24</strong></span>&#13;
<span>   <strong class="bold">0x0001005c &lt;_start+8&gt;:    add    r2, pc, #24</strong></span>&#13;
<span>   0x00010060 &lt;_start+12&gt;:   ldr    r3, [r1]</span>&#13;
<span>   0x00010064 &lt;_start+16&gt;:   ldr    r4, [r2]</span></pre>&#13;
			<pre class="source-code">   0x00010068 &lt;_start+20&gt;:   ldr    r5, [pc, #20]    ; 0x10084 &lt;Table2+8&gt;</pre>&#13;
			<p lang="en-GB">The first load instruction loads register <strong class="source-inline">r0</strong> with data from memory 36 bytes from the current program counter. At that location, the assembler has stored the <strong class="source-inline">0x12345678</strong> constant to <span class="No-Break">be loaded.</span></p>&#13;
			<p lang="en-GB">The two <strong class="source-inline">adr</strong> operations generate an address by adding the distance between the pc and the data in memory. This is called <em class="italic">program counter relative addressing</em> and we will look at it in more <span class="No-Break">detail later.</span></p>&#13;
			<p lang="en-GB">Let’s look at the data in memory. We use the <strong class="source-inline">x/6xw 0x10080</strong> gdb command to display six words of memory from <span class="No-Break">address </span><span class="No-Break"><strong class="source-inline">0x10080</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) x/6xw 0x10080</span>&#13;
<span>0x10080 &lt;Table2+4&gt;:    <strong class="bold">0x12345678</strong>    0xaaaaaaaa    0x00001141    0x61656100</span>&#13;
<span>0x10090:               0x01006962    0x00000007</span></pre>&#13;
			<p lang="en-GB">This shows the <strong class="source-inline">0x12345678</strong> constant that has been loaded in memory following the program, together with the other constants <span class="No-Break">we loaded.</span></p>&#13;
			<h2 id="_idParaDest-165" lang="en-GB"><a id="_idTextAnchor181"/>A note on endianism</h2>&#13;
			<p lang="en-GB">We’ve not mentioned one topic yet - <em class="italic">endianism</em>. The term is <a id="_idIndexMarker633"/>borrowed from <em class="italic">Gulliver’s Travels</em> where the world is divided into those who eat their boiled eggs from the big end and those who eat their eggs from the little end. This divides the world into mutually hostile big enders and little enders (it is, of <span class="No-Break">course, satire).</span></p>&#13;
			<p lang="en-GB">Computers do something similar. Suppose you store the 32-bit hexadecimal value <strong class="source-inline">0x12345678</strong> in memory. If you stored this in word memory, where the address of each word differs by 1, life would be simple. But because computer memories are <em class="italic">byte-organized</em>, each memory location has an individual byte address, so successive byte addresses are <strong class="source-inline">0,1,2,3,4,5,6…</strong> and successive word addresses <span class="No-Break">are </span><span class="No-Break"><strong class="source-inline">0,4,8,12,16,20,24…</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">A consequence of byte addressing means that word 0 occupies byte addresses 0,1,2,3. Suppose we store <strong class="source-inline">0x12345678</strong> at address 0. Which end of the number do we put in first? Is it stored in bytes 0 to 3 as <strong class="source-inline">12 34 56 78</strong> or as <strong class="source-inline">78 56 </strong><span class="No-Break"><strong class="source-inline">34 12</strong></span><span class="No-Break">?</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB"><span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.4</em> illustrates three memory systems. In all three cases, memory is byte-addressed. In the 32-bit version, we have two 32-bit values representing <strong class="source-inline">0x12345678</strong> stored in memory at addresses c and <strong class="source-inline">0x1014</strong>. Notice that the individual bytes of the stored word have different byte addresses. A little-endian number is arranged so that the most significant byte, <strong class="source-inline">0x12</strong>, is stored in the lowest address of the word <strong class="source-inline">0x1010</strong>. A big-endian number is stored with the most-significant byte at the lowest <span class="No-Break">address, </span><span class="No-Break"><strong class="source-inline">0x1013</strong></span><span class="No-Break">.</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer068" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_9.11_B19624.jpg" alt="Figure 9.11 – Memory organization" width="1470" height="650"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Memory organization</p>&#13;
			<p lang="en-GB">Some computers are big-endian and <a id="_idIndexMarker634"/>some little-endian. Motorola microprocessors are big-endian and Intel is little-endian. ARM was originally little-endian, but it now has a bit in its CPSR status register that can be used to select the required version of endianism. By default, the ARM <span class="No-Break">is little-endian.</span></p>&#13;
			<p lang="en-GB">Does the endian matter? It matters in two ways. If you are building systems or interfacing systems with mixed endianism, it matters because you must ensure that the bytes are in the correct sequence when passed from one system to another. For example, the TCP/IP protocol is big-endian. Equally, if you are performing byte and word operations on data, you have to be aware of the relationship between byte and word addresses. If you store the ASCII “Mike” at word address <strong class="source-inline">0x1000</strong> and you wanted the <em class="italic">“e,”</em> it would be at <strong class="source-inline">0x1000</strong> in a big-endian system and <strong class="source-inline">0x1003</strong> in a <span class="No-Break">little-endian system.</span></p>&#13;
			<h2 id="_idParaDest-166" lang="en-GB"><a id="_idTextAnchor182"/>Bringing everything together – a final example</h2>&#13;
			<p lang="en-GB">To conclude this chapter, we provide a final example of using the Raspberry Pi to enter the ARM assembly language and run it in a debugging mode using gdb. As before, the example does not perform a useful function. Its purpose is to demonstrate addressing modes, the use of assembler directives to load data in memory, the nature of endianism, and the ability to declare variables in memory and <span class="No-Break">modify them.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">This example also demonstrates how memory <a id="_idIndexMarker635"/>data is displayed and how to use the memory display function to read data. We have used gdb and copied various screens during the debugging. These have been put together in what follows. We have removed some material (e.g., status registers and registers not accessed) and have slightly edited the format <span class="No-Break">for readability.</span></p>&#13;
			<h3 lang="en-GB">The source program</h3>&#13;
			<p lang="en-GB">The source program sets up data in memory and accesses it. We use ASCII text and numeric text as part of the demonstration. Note that an ASCII string or character using the GCC assembler requires double quotes. We also read bytes with ldrb and a halfword (16 bits) <span class="No-Break">with ldrh.</span></p>&#13;
			<p lang="en-GB">The program uses <strong class="source-inline">ldrb r5,[r3,#1]</strong> to demonstrate reading bytes from a 32-bit word that is 3 bytes on from the base address of the word <span class="No-Break">in r5.</span></p>&#13;
			<p lang="en-GB">The program contains dummy <a id="_idIndexMarker636"/>data stored in memory, such as <strong class="source-inline">0xAAAAAAAA</strong>. We do this to demonstrate how data is stored, but mainly to help with debugging. When you display data contents in memory, these dummy values provide great markers to help you read the <span class="No-Break">memory data.</span></p>&#13;
			<p lang="en-GB">Note that the word that we access in read/write memory, testRW, is in a .data section. This is initialized to <strong class="source-inline">0xFFFFFFFF</strong> and is <span class="No-Break">later modified:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>        .global _start</span>&#13;
<span>_start: adr     r0,mike        <span class="sc-comment">@ r0 points to ASCII string "Mike"</span></span>&#13;
<span>        ldr     r1,[r0]        <span class="sc-comment">@ Read the string into r1</span></span>&#13;
<span>        ldrb    r2,[r0,#3]     <span class="sc-comment">@ Read byte 3 of "Mike"</span></span>&#13;
<span>        adr     r3,test        <span class="sc-comment">@ Point to data value 0x2468FACE in memory</span></span>&#13;
<span>        ldrb    r4,[r3]        <span class="sc-comment">@ Read single byte of test. Pointer in r0</span></span>&#13;
<span>        ldrb    r5,[r3,#1]     <span class="sc-comment">@ Read single byte 1 offset</span></span>&#13;
<span>        ldrh    r6,[r3]        <span class="sc-comment">@ Read halfword of test</span></span>&#13;
<span>        ldr     r7,a_adr       <span class="sc-comment">@ r7 points at address of testRW</span></span>&#13;
<span>        ldr     r8,=0x12345678 <span class="sc-comment">@ r8 loaded with 32-bit literal 0x12345678</span></span>&#13;
<span>        str     r8,[r7]        <span class="sc-comment">@ Store r8 in read/write memory at testRW</span></span>&#13;
<span>        ldrh    r9,[r7]        <span class="sc-comment">@ Read halfword of testRW</span></span>&#13;
<span>        mvn     r10,r9         <span class="sc-comment">@ Logically negate r9</span></span>&#13;
<span>        strh    r10,[r7,#4]    <span class="sc-comment">@ Store halfword in next word after testRW</span></span>&#13;
<span>        nop                    <span class="sc-comment">@ Just a place to stop</span></span>&#13;
<span>        mov     r0,#1          <span class="sc-comment">@ Raspberry Pi exit sequence</span></span>&#13;
<span>        mov     r7,#7</span>&#13;
<span>        svc     0</span>&#13;
<span>mike:   .ascii  "Mike"         <span class="sc-comment">@ Store string as 4 ASCII characters</span></span>&#13;
<span>test:   .word   0x2468FACE     <span class="sc-comment">@ Save a word in memory</span></span>&#13;
<span>a_adr:  .word   testRW         <span class="sc-comment">@ Pointer to data in read/write memory</span></span>&#13;
<span>        .data                  <span class="sc-comment">@ Data section in read/write memory</span></span>&#13;
<span>nines:  .word   0x99999999     <span class="sc-comment">@ 0x99999999 Just dummy data</span></span>&#13;
<span>testRW: .word   0xFFFFFFFF     <span class="sc-comment">@</span></span>&#13;
<span>        .word   0x77777777     <span class="sc-comment">@ More dummy data</span></span>&#13;
<span>        .word   0xBBBBBBBB     <span class="sc-comment">@ More dummy data</span></span></pre>&#13;
			<pre class="source-code">        .end</pre>&#13;
			<p lang="en-GB">The first steps are to assemble and load the program (called endian) and invoke the gdb debugger. We use bold font to indicate input from <span class="No-Break">the keyboard:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>alan@raspberrypi:~/Desktop $ <strong class="bold">as g o endian.o endian.s</strong></span>&#13;
<span>alan@raspberrypi:~/Desktop $ <strong class="bold">ld o endian endian.o</strong></span>&#13;
<span>alan@raspberrypi:~/Desktop $ <strong class="bold">gdb endian</strong></span>&#13;
<span>GNU gdb (Raspbian 10.11.7) 10.1.90.20210103git</span></pre>&#13;
			<p lang="en-GB">We can use gdb to set a breakpoint at <strong class="source-inline">_start</strong> and then run the program to <span class="No-Break">that breakpoint:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) b _start</span>&#13;
<span>Breakpoint 1 at 0x10074: file endian.s, line 2.</span>&#13;
<span>(gdb) r</span>&#13;
<span>Starting program: /home/alan/Desktop/endian</span>&#13;
<span>Breakpoint 1, _start () at endian.s:2</span>&#13;
<span>2    _start: adr     r0,mike   <span class="sc-comment">@ r0 points to ASCII string "Mike"</span></span></pre>&#13;
			<p lang="en-GB">Let’s look at the program that is actually loaded <a id="_idIndexMarker637"/>into memory. This differs slightly from the one we wrote because pseudo-operations have been replaced by actual code. Note that the <strong class="source-inline">adr</strong> is translated into an <strong class="source-inline">add</strong> by taking the program counter and adding the distance of the required variable to the current pc to generate <span class="No-Break">its address.</span></p>&#13;
			<p lang="en-GB">The <strong class="source-inline">ldr r8,=0x12345678</strong> is translated into a load program counter relative instruction because the required constant has been loaded into memory after the end of <span class="No-Break">the program:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) <strong class="bold">disassemble</strong></span>&#13;
<span>Dump of assembler code for function _start:</span>&#13;
<span>=&gt; 0x00010074 &lt;+0&gt;:     <strong class="bold">add    r0, pc, #60</strong>    ; 0x3c</span>&#13;
<span>   0x00010078 &lt;+4&gt;:     ldr    r1, [r0]</span>&#13;
<span>   0x0001007c &lt;+8&gt;:     ldrb   r2, [r0, #3]</span>&#13;
<span>   0x00010080 &lt;+12&gt;:    <strong class="bold">add    r3, pc, #52</strong>    ; 0x34</span>&#13;
<span>   0x00010084 &lt;+16&gt;:    ldrb   r4, [r3]</span>&#13;
<span>   0x00010088 &lt;+20&gt;:    ldrb   r5, [r3, #1]</span>&#13;
<span>   0x0001008c &lt;+24&gt;:    ldrh   r6, [r3]</span>&#13;
<span>   0x00010090 &lt;+28&gt;:    ldr    r7, [pc, #40]   ; 0x100c0 &lt;a_adr&gt;</span>&#13;
<span>   0x00010094 &lt;+32&gt;:    <strong class="bold">ldr    r8, [pc, #40]</strong>   ; 0x100c4 &lt;a_adr+4&gt;</span>&#13;
<span>   0x00010098 &lt;+36&gt;:    str    r8, [r7]</span>&#13;
<span>   0x0001009c &lt;+40&gt;:    ldrh   r9, [r7]</span>&#13;
<span>   0x000100a0 &lt;+44&gt;:    mvn    r10, r9</span>&#13;
<span>   0x000100a4 &lt;+48&gt;:    strh   r10, [r7, #4]</span>&#13;
<span>   0x000100a8 &lt;+52&gt;:    nop                    ; (mov r0, r0)</span>&#13;
<span>   0x000100ac &lt;+56&gt;:    mov    r0, #1</span>&#13;
<span>   0x000100b0 &lt;+60&gt;:    mov    r7, #7</span>&#13;
<span>   0x000100b4 &lt;+64&gt;:    svc    0x00000000</span></pre>&#13;
			<pre class="source-code">End of assembler dump.</pre>&#13;
			<p lang="en-GB">This differs from the code we wrote because pseudo-operations have been replaced by actual ARM code. Note that the <strong class="source-inline">adr</strong> is translated into an <strong class="source-inline">add</strong> by taking the program counter and adding the distance of the required variable to the current pc to generate <span class="No-Break">its address.</span></p>&#13;
			<p lang="en-GB">The <strong class="source-inline">ldr r8,=0x12345678</strong> is translated into a load program counter relative instruction because the required constant has been loaded into memory after the end of <span class="No-Break">the program.</span></p>&#13;
			<p lang="en-GB">Let’s look at memory. The following shows the <a id="_idIndexMarker638"/>contents of 8 consecutive words starting with <strong class="source-inline">0x100b4</strong>, which is the address of the <strong class="source-inline">svc </strong><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break"> instruction.</span></p>&#13;
			<p lang="en-GB">Before continuing and executing the program, we will look at the contents of memory, set up by the program. Where is this data? It follows the last executable instruction, <strong class="source-inline">svc 0</strong>, which is at address <strong class="source-inline">0x000100B4</strong>. We display the eight words from the <strong class="source-inline">svc</strong> in <span class="No-Break">hexadecimal format:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) <strong class="bold">x/8wx 0x100b4</strong></span>&#13;
<span>0x100b4 &lt;_start+64&gt;:    0xef000000    0x656b694d    0x2468face    0x000200cc</span>&#13;
<span>0x100c4 &lt;a_adr+4&gt;:      0x12345678    0x99999999    0xffffffff    0x77777777</span></pre>&#13;
			<p lang="en-GB">You can see the <strong class="source-inline">0x12345678</strong> constant loaded by the assembler and some of <span class="No-Break">the markers.</span></p>&#13;
			<p lang="en-GB">We will step through the first <span class="No-Break">few instructions:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) <strong class="bold">si 1</strong></span>&#13;
<span>3          ldr   r1,[r0]       <span class="sc-comment">@ Read the string into r1</span></span>&#13;
<span>4          ldrb  r2,[r0,#3]    <span class="sc-comment">@ Read byte 3 of "Mike"</span></span>&#13;
<span>6          adr   r3,test       <span class="sc-comment">@ Point to data value 0x2468FACE in memory</span></span></pre>&#13;
			<p lang="en-GB">The next step is to look at the registers before the program runs to completion. We do this with gdb’s <strong class="source-inline">i r</strong> command. There’s not much to see yet (it’s a partial listing), as we’ve executed only the first few instructions. However, <strong class="source-inline">r0</strong> now contains a pointer to the ASCII text string <em class="italic">“Mike”</em> at address <strong class="source-inline">0x100B8</strong>. If you look back at that address, you see that it contains <strong class="source-inline">0x656b694d</strong>, which is <strong class="source-inline">ekiM</strong>. That’s what <span class="No-Break">little-endian does!</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) <strong class="bold">i r</strong></span>&#13;
<span>r0             0x100b8             65720</span>&#13;
<span>r1             0x656b694d          1701538125</span>&#13;
<span>r2             0x65                101</span>&#13;
<span>r3             0x0                 0</span>&#13;
<span>r4             0x0                 0</span>&#13;
<span>sp             0x7efff360          0x7efff360</span>&#13;
<span>lr             0x0                 0</span></pre>&#13;
			<pre class="source-code">pc             0x10080             0x10080 &lt;_start+12&gt;</pre>&#13;
			<p lang="en-GB"><span class="No-Break">Continuing </span><span class="No-Break"><a id="_idIndexMarker639"/></span><span class="No-Break">single-stepping:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) <strong class="bold">si 1</strong></span>&#13;
<span>7          ldrb    r4,[r3]          <span class="sc-comment">@ Read byte of test Pointer in r0</span></span>&#13;
<span>8          ldrb    r5,[r3,#1]       <span class="sc-comment">@ Read single byte 1 offset</span></span>&#13;
<span>9          ldrh    r6,[r3]          <span class="sc-comment">@ Read halfword of test</span></span>&#13;
<span>11         ldr     r7,a_adr         <span class="sc-comment">@ r7 points at address of testRW</span></span>&#13;
<span>12         ldr     r8,=0x12345678   <span class="sc-comment">@ r8 loaded with 32-bit 0x12345678</span></span>&#13;
<span>(gdb) i r</span>&#13;
<span><strong class="bold">r0             0x100b8             65720</strong></span>&#13;
<span><strong class="bold">r1             0x656b694d          1701538125</strong></span>&#13;
<span><strong class="bold">r2             0x65                101</strong></span>&#13;
<span><strong class="bold">r3             0x100bc             65724</strong></span>&#13;
<span><strong class="bold">r4             0xce                206</strong></span>&#13;
<span><strong class="bold">r5             0xfa                250</strong></span>&#13;
<span><strong class="bold">r6             0xface              64206</strong></span>&#13;
<span><strong class="bold">r7             0x200cc             131276</strong></span>&#13;
<span><strong class="bold">sp             0x7efff360          0x7efff360</strong></span>&#13;
<span><strong class="bold">lr             0x0                 0</strong></span>&#13;
<span><strong class="bold">pc             0x10094             0x10094 &lt;_start+32&gt;</strong></span></pre>&#13;
			<p lang="en-GB">Let’s look at the memory in the data section. Register <strong class="source-inline">r7</strong> points to the read/write data area. It starts 4 bytes before the pointer to <strong class="source-inline">testRW</strong>, in <strong class="source-inline">r7</strong> ; that is, <strong class="source-inline">0x200CC - 4 = 0x200C8</strong>. The four words beginning at that address are <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) <strong class="bold">x/4xw 0x200c8</strong></span>&#13;
<span>0x200c8:    0x99999999    0xffffffff    0x77777777    0xbbbbbbbb</span></pre>&#13;
			<p lang="en-GB">Finally, we step through the instruction until we meet the <strong class="source-inline">nop</strong> at <span class="No-Break">the end:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) <strong class="bold">si 1</strong></span>&#13;
<span>13          str    r8,[r7]       <span class="sc-comment">@ Store r8 in read/write memory at testRW</span></span>&#13;
<span>14          ldrh   r9,[r7]       <span class="sc-comment">@ Read halfword of testRW</span></span>&#13;
<span>15          mvn    r10,r9        <span class="sc-comment">@ Logically negate r9</span></span>&#13;
<span>16          strh   r10,[r7,#4]   <span class="sc-comment">@ Store halfword in next word after testRW</span></span></pre>&#13;
			<pre class="source-code">17          nop                  <span class="sc-comment">@ Just a place to stop</span></pre>&#13;
			<p lang="en-GB">Let’s take a final look at <a id="_idIndexMarker640"/>the state of <span class="No-Break">the registers:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) i r</span>&#13;
<span>r0             0x100b8             65720</span>&#13;
<span>r1             0x656b694d          1701538125</span>&#13;
<span>r2             0x65                101</span>&#13;
<span>r3             0x100bc             65724</span>&#13;
<span>r4             0xce                206</span>&#13;
<span>r5             0xfa                250</span>&#13;
<span>r6             0xface              64206</span>&#13;
<span>r7             0x200cc             131276</span>&#13;
<span>r8             0x12345678          305419896</span>&#13;
<span>r9             0x5678              22136</span>&#13;
<span>r10            0xffffa987          4294945159</span>&#13;
<span>sp             0x7efff360          0x7efff360</span>&#13;
<span>lr             0x0                 0</span>&#13;
<span>pc             0x100a8             0x100a8 &lt;_start+52&gt;</span></pre>&#13;
			<p lang="en-GB">Here’s our final look at the data memory. Note that <strong class="source-inline">0xFFFFFFFF</strong> has been replaced with the value <strong class="source-inline">0x12345678</strong> that we wrote to memory. This demonstrates how you can access data memory using <span class="No-Break">an ARM.</span></p>&#13;
			<p lang="en-GB">Note also the data value at <strong class="source-inline">0x200D0</strong> ; that is, <strong class="source-inline">0x7777a987</strong>. We have changed half the word using a <span class="No-Break">halfword load:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) <strong class="bold">x/4xw 0x200c8</strong></span>&#13;
<span>0x200c8:    0x99999999    0x12345678    0x7777a987    0xbbbbbbbb</span></pre>&#13;
			<h1 id="_idParaDest-167" lang="en-GB"><a id="_idTextAnchor183"/>Summary</h1>&#13;
			<p lang="en-GB">In this chapter, we have introduced a real computer, the Raspberry Pi. Instead of designing our own computer instruction sets, we’ve looked at the ARM microprocessor that is at the heart of the Raspberry Pi and <span class="No-Break">most smartphones.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">We introduced the basics of the Raspberry Pi and showed how to write an ARM assembly language program that can run on it. This requires an understanding of the ARM assembler and the use of the linker. We demonstrated how you can then run your ARM program instruction-by-instruction using the <span class="No-Break">gdb debugger.</span></p>&#13;
			<p lang="en-GB">One important feature of Raspberry Pi’s architecture we have encountered is the way in which data in memory is modified. You cannot use a str (store) instruction to modify data in memory. You must do it indirectly via a pointer to the address of the memory you wish to change. The following short program demonstrates this vital point. A data item in memory is read directly using an <strong class="source-inline">ldr</strong> but modified in memory using a pointer to a pointer. The key operations are <span class="No-Break">in bold:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>         .text           <span class="sc-comment">@ Code section</span></span>&#13;
<span>         .global _start</span>&#13;
<span>_start:  ldr r1,=xxx     <span class="sc-comment">@ Point to data xxx</span></span>&#13;
<span>         ldr r2,[r1]     <span class="sc-comment">@ Read the data</span></span>&#13;
<span>         <strong class="bold">adr r3,adr_xxx</strong>  <span class="sc-comment">@ Point to the address of the address of xxx</span></span>&#13;
<span>         <strong class="bold">ldr r4,[r3]</strong>     <span class="sc-comment">@ Point to the data xxx</span></span>&#13;
<span>         ldr r5,[r4]     <span class="sc-comment">@ Read the value of xxx</span></span>&#13;
<span>         add r5,r5,#1    <span class="sc-comment">@ Increment the data</span></span>&#13;
<span>         <strong class="bold">str r5,[r4]</strong>     <span class="sc-comment">@ Change xxx in memory</span></span>&#13;
<span>         mov r0,#0       <span class="sc-comment">@ Exit procedure</span></span>&#13;
<span>         mov r7,#1</span>&#13;
<span>         svc 0</span>&#13;
<span><strong class="bold">adr_xxx: .word</strong>           <span class="sc-comment">@ Pointer to data xxx</span></span>&#13;
<span>         <strong class="bold">.data</strong>           <span class="sc-comment">@ Data section</span></span>&#13;
<span><strong class="bold">xxx:     .word  0xABCD</strong>   <span class="sc-comment">@ Initialize variable xxx</span></span>&#13;
<span>         .end</span></pre>&#13;
			<p lang="en-GB">In order to demonstrate an ARM program, we have introduced the ARM’s assembly language. Mercifully, this is not too far from the language adopted by some of the simulators. Indeed, the ARM’s assembly language is not too difficult to learn, although it does incorporate some very interesting features, which we will describe in <span class="No-Break">later chapters.</span></p>&#13;
			<p lang="en-GB">In the next chapter, we return to the ARM architecture and one of its most important aspects: addressing and how data is transferred to and <span class="No-Break">from memory.</span></p>&#13;
		</div>&#13;
	</div></body></html>