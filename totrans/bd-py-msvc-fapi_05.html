<html><head></head><body>
		<div id="_idContainer033">
			<h1 id="_idParaDest-107" class="chapter-number"><a id="_idTextAnchor107"/>5</h1>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor108"/>Connecting to a Relational Database</h1>
			<p>Our previous applications have only used Python collections to hold data records instead of persistent data stores. This setup causes data wiping whenever the <strong class="bold">Uvicorn</strong> server restarts because these collections only store the data in <em class="italic">volatile memory</em>, such as <strong class="bold">RAM</strong>. From this chapter onward, we will be applying data persistency to avoid data loss and provide a platform to manage our records, even when the server is in shutdown mode.</p>
			<p>This chapter will focus on different <strong class="bold">Object Relational Mappers</strong> (<strong class="bold">ORMs</strong>) that can efficiently manage clients’ data using objects and a relational database. Object-relational mapping is a technique where SQL statements for <strong class="bold">Creating</strong><em class="italic">, </em><strong class="bold">Reading</strong><em class="italic">, </em><strong class="bold">Updating</strong><em class="italic"> and </em><strong class="bold">Deleting</strong> (<strong class="bold">CRUD</strong>) are implemented and executed in an object-oriented programming approach. ORM requires all relationships or tables to be mapped to their corresponding entity or model classes to avoid tightly coupled connections to the database platform. And these model classes are the ones that are used to connect to the database.</p>
			<p>Aside from introducing ORM, this chapter will also discuss a design pattern called <strong class="bold">Command and Query Responsibility Segregation</strong> (<strong class="bold">CQRS</strong>), which can help resolve conflicts between read and write ORM transactions at the domain level. CQRS can help minimize the running time spent by read and write SQL transactions to improve the overall performance of the application over time compared to the data modeling approach.</p>
			<p>Overall, the main objective of this chapter is to prove that the FastAPI framework supports all popular ORMs to provide applications with backend database access, which it does by using popular relational database management systems, and apply optimization to CRUD transactions using the CQRS design pattern.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Preparing for database connectivity</li>
				<li>Creating synchronous CRUD transactions using <em class="italic">SQLAlchemy</em></li>
				<li>Implementing asynchronous CRUD transactions using <em class="italic">SQLAlchemy</em></li>
				<li>Using <em class="italic">GINO</em> for asynchronous CRUD transactions</li>
				<li>Using Pony ORM for the repository layer</li>
				<li>Building the repository using Peewee</li>
				<li>Applying the CQRS design pattern</li>
			</ul>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor109"/>Technical requirements</h1>
			<p>The application prototype that’s been created for this chapter is called <em class="italic">fitness club management system</em>; it caters to membership and gym fitness operations. This prototype has administration, membership, class management, and attendance modules that utilize a <strong class="bold">PostgreSQL</strong> database as their data storage. Moreover, this uncommon application has four pieces of database connectivity that have been configured using different ORM variations to provide you with options for your applications. Also, the prototype is just a simple FastAPI application that’s been created to help you focus on the <em class="italic">data modeling features</em>, <em class="italic">data persistency</em>, and <em class="italic">query building</em> required for the discussions in this chapter. This code for this chapter can be found at <a href="https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI">https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI</a> in the <strong class="source-inline">ch05a</strong> and <strong class="source-inline">ch05b</strong> projects.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor110"/>Preparing for database connectivity</h1>
			<p>Let<a id="_idIndexMarker270"/> us consider some application-related concerns before we start discussing database connectivity in FastAPI:</p>
			<ul>
				<li>First, all the application prototypes from this chapter onward will be using PostgreSQL as the sole relational DBMS. We can download its installer from <a href="https://www.enterprisedb.com/downloads/postgres-postgresql-downloads">https://www.enterprisedb.com/downloads/postgres-postgresql-downloads</a>. </li>
				<li>Second, the <em class="italic">fitness club management system</em> prototype has an existing database called <strong class="source-inline">fcms</strong> with six tables, namely <strong class="source-inline">signup</strong>, <strong class="source-inline">login</strong>, <strong class="source-inline">profile_members</strong>, <strong class="source-inline">profile_trainers</strong>, <strong class="source-inline">attendance_member</strong>, and <strong class="source-inline">gym_class</strong>. All these tables, along with their metadata and relationships, can be seen in the following diagram:</li>
			</ul>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/Figure_5.1_B17975.jpg" alt="Figure 5.1 – The fcms tables&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The fcms tables</p>
			<p>The <a id="_idIndexMarker271"/>project folder contains a script called <strong class="source-inline">fcms_postgres.sql</strong> that installs all these schemas.</p>
			<p>Now that we’ve installed the latest version of PostgreSQL and run the <strong class="source-inline">fcms</strong> script file, let us learn about SQLAlchemy, the most widely used ORM library in the Python arena.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">This chapter will compare and contrast the features of different Python ORMs. With this experimental setup, each project will have a multitude of database connectivity, which is against the convention of having a single piece of database connectivity per project. </p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor111"/>Creating CRUD transactions using SQLAlchemy</h1>
			<p><strong class="bold">SQLAlchemy</strong> is the<a id="_idIndexMarker272"/> most popular ORM library and can establish communication between any Python-based application and database platform. It is reliable because it is continuously updated and tested to be efficient, high-performing, and accurate with its SQL reads and writes. </p>
			<p>This ORM<a id="_idIndexMarker273"/> is a boilerplated interface that aims to create a database-agnostic data layer that can connect to any database engine. But compared to other ORMs, SQLAlchemy is <a id="_idIndexMarker274"/>DBA-friendly because it can generate optimized native SQL statements. When it comes to formulating its queries, it only requires Python functions and expressions to pursue the CRUD operations.</p>
			<p>Before <a id="_idIndexMarker275"/>we start using<a id="_idIndexMarker276"/> SQLAlchemy, check whether you have the module installed in your system by using the following command:</p>
			<p class="source-code">pip list </p>
			<p>If SQLAlchemy is not in the list, install it using the <strong class="source-inline">pip</strong> command:</p>
			<p class="source-code">pip install SQLAlchemy</p>
			<p>Currently, the version being used while developing the <em class="italic">fitness club management system</em> app is <em class="italic">1.4</em>.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor112"/>Installing the database driver</h2>
			<p>SQLAlchemy will not work without the<a id="_idIndexMarker277"/> required database driver. It is mandatory to install the <strong class="source-inline">psycopg2</strong> dialect since the database of choice is PostgreSQL:</p>
			<p class="source-code">pip install psycopg2</p>
			<p>Psycopg2<a id="_idIndexMarker278"/> is a <em class="italic">DB API 2.0-c</em>ompliant PostgreSQL driver that does connection pooling and can work with multi-threaded FastAPI applications. This wrapper or dialect is also essential in building synchronous CRUD transactions for our application. Once it’s been installed, we can start looking at SQLAlchemy’s database configuration details. All the code related to SQLAlchemy can be found in the <strong class="source-inline">ch05a</strong> project.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor113"/>Setting up the database connection</h2>
			<p>To connect to any<a id="_idIndexMarker279"/> database, SQLAlchemy requires an engine that manages the connection pooling and the installed dialect. The <strong class="source-inline">create_engine()</strong> function from the <strong class="source-inline">sqlalchemy</strong> module is the source of the engine object. But to successfully derive it, <strong class="source-inline">create_engine()</strong> requires a database URL string to be configured. This URL string contains the <em class="italic">database name</em>, <em class="italic">the database API driver</em>, the <em class="italic">account credentials</em>, the <em class="italic">IP address</em> of the database server, and its <em class="italic">port</em>. The following script shows how to create the engine that will be used in our <em class="italic">fitness club management system</em> prototype:</p>
			<pre class="source-code">
from sqlalchemy import <strong class="bold">create_engine</strong>
<strong class="bold">DB_URL</strong> =   
   "<strong class="bold">postgresql</strong>://<strong class="bold">postgres</strong>:<strong class="bold">admin2255</strong>@<strong class="bold">localhost</strong>:<strong class="bold">5433</strong>/<strong class="bold">fcms</strong>"
<strong class="bold">engine</strong> = <strong class="bold">create_engine(DB_URL)</strong></pre>
			<p><strong class="source-inline">engine</strong> is a global object and must be created only once in the entire application. Its first database connection happens right after the first SQL transaction of the application because it follows the <em class="italic">lazy initialization</em> design <a id="_idIndexMarker280"/>pattern.</p>
			<p>Moreover, <strong class="source-inline">engine</strong> in the previous script is essential for creating the ORM session that will be used by SQLAlchemy to execute CRUD transactions.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor114"/>Initializing the session factory</h2>
			<p>All <a id="_idIndexMarker281"/>CRUD transactions in SQLAlchemy are driven by <em class="italic">sessions</em>. Each session manages a group of database "writes" and "reads," and it checks whether to execute them or not. For instance, it maintains a group of inserted, updated, and deleted objects, checks whether the changes are valid, and then coordinates with the SQLAlchemy core to pursue the changes to the database if all transactions have been validated. It follows the behavior of the <em class="italic">Unit of Work</em> design pattern. SQLAlchemy relies on sessions for data consistency and integrity.</p>
			<p>But before we create a session, the data layer needs a session factory that is bound to the derived engine. The ORM has a <strong class="source-inline">sessionmaker()</strong>directive from the <strong class="source-inline">sqlalchemy.orm</strong> module, which requires the <strong class="source-inline">engine</strong> object. The following script shows how to invoke <strong class="source-inline">sessionmaker()</strong>:</p>
			<pre class="source-code">
from sqlalchemy.orm import <strong class="bold">sessionmaker</strong>
<strong class="bold">engine</strong> = create_engine(DB_URL)
<strong class="bold">SessionFactory</strong> = <strong class="bold">sessionmaker(autocommit=False,</strong> 
                     <strong class="bold">autoflush=False, bind=engine)</strong></pre>
			<p>Apart from engine binding, we also need to set the session’s <strong class="source-inline">autocommit</strong> property to <strong class="source-inline">False</strong> to impose <strong class="source-inline">commit()</strong> and <strong class="source-inline">rollback()</strong> transactions. The application should be the one to flush all changes to the database, so we need to set its <strong class="source-inline">autoflush</strong> feature to <strong class="source-inline">False</strong> as well. </p>
			<p>Applications<a id="_idIndexMarker282"/> can create more than one session through the <strong class="source-inline">SessionFactory()</strong> call, but having one session per <strong class="source-inline">APIRouter</strong> is recommended.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor115"/>Defining the Base class</h2>
			<p>Next, we <a id="_idIndexMarker283"/>need to set up the <strong class="source-inline">Base</strong> class, which is crucial in mapping model classes to database tables. Although SQLAlchemy can create tables at runtime, we opted to utilize an existing schema definition for our prototype. Now, this <strong class="source-inline">Base</strong> class must be subclassed by the model classes so that the mapping to the tables will happen once the server starts. The following script shows how straightforward it is to set up this component:</p>
			<pre class="source-code">
from sqlalchemy.ext.declarative import <strong class="bold">declarative_base</strong>
<strong class="bold">Base</strong> = <strong class="bold">declarative_base()</strong></pre>
			<p>Invoking the <strong class="source-inline">declarative_base()</strong> function is the easiest way of creating the <strong class="source-inline">Base</strong> class rather than creating <strong class="source-inline">registry()</strong> to call <strong class="source-inline">generate_base()</strong>, which can also provide us with the <strong class="source-inline">Base</strong> class.</p>
			<p>Note that all these configurations are part of the <strong class="source-inline">/db_config/sqlalchemy_connect.py</strong> module of the prototype. They are bundled into one module since they are crucial in building the SQLAlchemy repository. But before<a id="_idIndexMarker284"/> we implement the CRUD transactions, we need to create the model layer using the <strong class="source-inline">Base</strong> class.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor116"/>Building the model layer</h2>
			<p>The model <a id="_idIndexMarker285"/>classes of SQLAlchemy have all been placed in the <strong class="source-inline">/models/data/sqlalchemy_models.py</strong> file of the fitness club project folder. If <strong class="source-inline">BaseModel</strong> is important to API request models, the <strong class="source-inline">Base</strong> class is essential in building the data layer. It is imported from the configuration file to define SQLAlchemy entities or models. The following code is from the module script, which shows how we can create model class definitions in SQLAlchemy ORM:</p>
			<pre class="source-code">
<strong class="bold">from sqlalchemy import Time, Boolean, Column, Integer, </strong>
    <strong class="bold">String, Float, Date, ForeignKey</strong>
<strong class="bold">from sqlalchemy.orm import relationship</strong>
<strong class="bold">from db_config.sqlalchemy_connect import Base</strong>
class Signup(<strong class="bold">Base</strong>):
    <strong class="bold">__tablename__ = "signup"</strong>
    id = <strong class="bold">Column</strong>(<strong class="bold">Integer</strong>, <strong class="bold">primary_key=True</strong>, <strong class="bold">index=True</strong>)
    username = <strong class="bold">Column</strong>(<strong class="bold">'username'</strong>, <strong class="bold">String</strong>, unique=False, 
                       index=False)
    password = <strong class="bold">Column</strong>(<strong class="bold">'password' </strong>,<strong class="bold">String</strong>, unique=False, 
                       index=False)</pre>
			<p>The <strong class="source-inline">Signup</strong> class is a sample of a SQLAlchemy model because it inherits the <strong class="source-inline">Base</strong> class’s properties. It is a mapped class because all its attributes are reflections of the column metadata of its physical table schema counterpart. The model has a <strong class="source-inline">primary_key</strong> property set to <strong class="source-inline">True</strong> because SQLAlchemy recommends each table schema have at least one primary key. The rest of the <strong class="source-inline">Column</strong> objects are mapped to column metadata that’s non-primary but can be <em class="italic">unique</em> or <em class="italic">indexed</em>. Each model class inherits the <strong class="source-inline">__tablename__</strong> property, which sets the name of the mapped table.</p>
			<p>Most importantly, we need to ensure that the data type of the class attribute matches the column type of its column counterpart in the table schema. The column attribute must have the same name as the column counterpart. Otherwise, we need to specify the actual<a id="_idIndexMarker286"/> column name in the first argument of the <strong class="source-inline">Column</strong> class, as shown in the <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong> columns of <strong class="source-inline">Signup</strong>. But most of the time, we must always make sure they are the same to avoid confusion.     </p>
			<h3>Mapping table relationships</h3>
			<p>SQLAlchemy<a id="_idIndexMarker287"/> strongly supports different types of parent-child or associative table relationships. Model classes involved in the relationship require the <strong class="source-inline">relationship()</strong> directive from the <strong class="source-inline">sqlalchemy.orm</strong> module to be utilized to establish one-to-many or one-to-one relationships among model classes. This directive creates a reference from the parent to the child class using some foreign key indicated in the table schema definition. </p>
			<p>A child model class uses the <strong class="source-inline">ForeignKey</strong> construct in its foreign key column object to link the model class to its parent’s reference key column object. This directive indicates that the values in this column should be within the values stored in the parent table’s reference column. The <strong class="source-inline">ForeignKey</strong> directive applies to both the primary and non-primary <strong class="source-inline">Column</strong> objects. The following model class defines a sample column relationship in our database schema:</p>
			<pre class="source-code">
class Login(<strong class="bold">Base</strong>): 
    <strong class="bold">__tablename__ = "login"</strong>
    
    id = <strong class="bold">Column</strong>(<strong class="bold">Integer</strong>, primary_key=True, index=True)
    username = <strong class="bold">Column</strong>(<strong class="bold">String</strong>, unique=False, index=False)
    password = <strong class="bold">Column</strong>(<strong class="bold">String</strong>, unique=False, index=False)
    date_approved = <strong class="bold">Column</strong>(<strong class="bold">Date</strong>, unique=False, index=False)
    user_type = <strong class="bold">Column</strong>(<strong class="bold">Integer</strong>, unique=False, index=False)
    
    <strong class="bold">trainers = relationship('Profile_Trainers', </strong>
         <strong class="bold">back_populates="login", uselist=False)</strong>
    <strong class="bold">members = relationship('Profile_Members', </strong>
         <strong class="bold">back_populates="login", uselist=False)</strong></pre>
			<p>This <strong class="source-inline">Login</strong> model is <a id="_idIndexMarker288"/>linked to two children, <strong class="source-inline">Profile_Trainers</strong> and <strong class="source-inline">Profile_Members</strong>, based on its configuration. Both child models have the <strong class="source-inline">ForeignKey</strong> directive in their <strong class="source-inline">id</strong> column objects, as shown in the following model definitions:</p>
			<pre class="source-code">
class Profile_Trainers(<strong class="bold">Base</strong>):
    <strong class="bold">__tablename__ = "profile_trainers"</strong>
    id = <strong class="bold">Column</strong>(<strong class="bold">Integer</strong>, <strong class="bold">ForeignKey('login.id')</strong>, 
         primary_key=True, index=True, )
    firstname = <strong class="bold">Column</strong>(<strong class="bold">String</strong>, unique=False, index=False)
    … … … … …
    … … … … …
    <strong class="bold">login = relationship('Login', </strong>
         <strong class="bold">back_populates="trainers")</strong>
    <strong class="bold">gclass = relationship('Gym_Class', </strong>
         <strong class="bold">back_populates="trainers")</strong>
    
class Profile_Members(<strong class="bold">Base</strong>): 
    <strong class="bold">__tablename__ = "profile_members"</strong>
    id = <strong class="bold">Column</strong>(<strong class="bold">Integer</strong>, <strong class="bold">ForeignKey('login.id')</strong>, 
         primary_key=True, index=True)
    firstname = <strong class="bold">Column</strong>(<strong class="bold">String</strong>, unique=False, index=False)
    lastname = <strong class="bold">Column</strong>(<strong class="bold">String</strong>, unique=False, index=False)
    age = <strong class="bold">Column</strong>(<strong class="bold">Integer</strong>, unique=False, index=False)
    … … … … … …
    … … … … … …
    trainer_id = <strong class="bold">Column</strong>(<strong class="bold">Integer</strong>, 
        <strong class="bold">ForeignKey('profile_trainers.id')</strong>, unique=False, 
        index=False)
    <strong class="bold">login = relationship('Login', back_populates="members")</strong>
    <strong class="bold">attendance = relationship('Attendance_Member', </strong>
          <strong class="bold">back_populates="members")</strong>
    <strong class="bold">gclass = relationship('Gym_Class', </strong>
          <strong class="bold">back_populates="members") </strong></pre>
			<p>The <strong class="source-inline">relationship()</strong> directive <a id="_idIndexMarker289"/>is the sole directive for creating table relationships. We need to specify some of its parameters, such as the <em class="italic">name of the child model class</em> and the <em class="italic">backreference specification</em>. The <strong class="source-inline">back_populates</strong> parameter refers to the complementary attribute names of the related model classes. This indicates the rows that need to be fetched using some relationship loading technique during join query transactions. The <strong class="source-inline">backref</strong> parameter can also be used instead of <strong class="source-inline">back_populates</strong>.</p>
			<p>On the other hand, <strong class="source-inline">relationship()</strong> can return either a <strong class="source-inline">List</strong> or scalar object, depending on the relationship type. If it is a <em class="italic">one-to-one type</em>, the parent class should set the <strong class="source-inline">useList</strong> parameter to <strong class="source-inline">False</strong> to indicate that it will return a scalar value. Otherwise, it will select a list of records from the child table. The previous <strong class="source-inline">Login</strong> class definition shows that <strong class="source-inline">Profile_Trainers</strong> and <strong class="source-inline">Profile_Members</strong> hold a one-to-one relationship with <strong class="source-inline">Login</strong> because <strong class="source-inline">Login</strong> sets its <strong class="source-inline">uselist</strong> to <strong class="source-inline">False</strong>. On the other hand, the model relationship between <strong class="source-inline">Profile_Members</strong> and <strong class="source-inline">Attendance_Member</strong> is a <em class="italic">one-to-many</em> type because <strong class="source-inline">uselist</strong> is set to <strong class="source-inline">True</strong> by default, as shown by the following definitions:</p>
			<pre class="source-code">
class Attendance_Member(<strong class="bold">Base</strong>):
    __tablename__ = "attendance_member"
    id = Column(Integer, primary_key=True, index=True)
    <strong class="bold">member_id = Column(Integer, </strong>
        <strong class="bold">ForeignKey('profile_members.id'), unique=False, </strong>
        <strong class="bold">index=False)</strong>
    timeout = Column(Time, unique=False, index=False)
    timein = Column(Time, unique=False, index=False)
    date_log = Column(Date, unique=False, index=False)
    
    <strong class="bold">members = relationship('Profile_Members', </strong>
             <strong class="bold">back_populates="attendance")</strong></pre>
			<p>While setting the <a id="_idIndexMarker290"/>model relationships, we must also consider the <em class="italic">relationship loading type</em> that these related model classes will be using during the join query transactions. We specify this detail in the <strong class="source-inline">lazy</strong> parameter of <strong class="source-inline">relationship()</strong>, which is assigned to <strong class="source-inline">select</strong> by default. This is because SQLAlchemy uses a lazy loading technique by default in retrieving join queries. However, you can modify it to use <strong class="source-inline">joined</strong> (<strong class="source-inline">lazy="joined"</strong>), <strong class="source-inline">subquery</strong> (<strong class="source-inline">lazy="subquery"</strong>), <strong class="source-inline">select in</strong> (<strong class="source-inline">lazy="selectin"</strong>), <strong class="source-inline">raise</strong> (<strong class="source-inline">lazy="raise"</strong>), or <strong class="source-inline">no</strong> (<strong class="source-inline">lazy="no"</strong>) loading. Among the options, the <strong class="source-inline">joined</strong> approach is better for <em class="italic">INNER JOIN</em> transactions.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor117"/>Implementing the repository layer</h2>
			<p>In the SQLAlchemy ORM, creating the <a id="_idIndexMarker291"/>repository layer requires the <em class="italic">model classes</em> and a <strong class="source-inline">Session</strong> object. The <strong class="source-inline">Session</strong> object, derived from the <strong class="source-inline">SessionFactory()</strong>directive, establishes all the communication to the database and manages all the model objects before the <strong class="source-inline">commit()</strong> or <strong class="source-inline">rollback()</strong> transaction. When it comes to the queries, the <strong class="source-inline">Session</strong> entity stores the result set of records in a data structure called an <em class="italic">identity map</em>, which maintains the unique identity of each data record using the primary keys. </p>
			<p>All repository <a id="_idIndexMarker292"/>transactions are <em class="italic">stateless</em>, which means the session is automatically closed after loading the model objects for insert, update, and delete transactions when the database issues a <strong class="source-inline">commit()</strong> or <strong class="source-inline">rollback()</strong> operation. We import the <strong class="source-inline">Session</strong> class from the <strong class="source-inline">sqlalchemy.orm</strong> module.</p>
			<h3>Building the CRUD transactions</h3>
			<p>Now, we can <a id="_idIndexMarker293"/>start building the repository<a id="_idIndexMarker294"/> layer of the fitness club application since we have already satisfied the requirements to build the CRUD transactions. The following <strong class="source-inline">SignupRepository</strong> class is the blueprint that will show us how to <em class="italic">insert</em>, <em class="italic">update</em>, <em class="italic">delete</em>, and <em class="italic">retrieve</em> record(s) to/from the <strong class="source-inline">signup</strong> table:</p>
			<pre class="source-code">
from typing import Dict, List, Any
<strong class="bold">from sqlalchemy.orm import Session</strong>
<strong class="bold">from models.data.sqlalchemy_models import Signup</strong>
<strong class="bold">from sqlalchemy import desc</strong>
<strong class="bold">class SignupRepository: </strong>
    
    def __init__(self, <strong class="bold">sess:Session</strong>):
        self.<strong class="bold">sess:Session</strong> = sess
    
    def <strong class="bold">insert_signup</strong>(self, signup: Signup) -&gt; bool: 
        try:
            <strong class="bold">self.sess.add(signup)</strong>
            <strong class="bold">self.sess.commit()</strong>
        except: 
            return False 
        return True</pre>
			<p>So far, <strong class="source-inline">insert_signup()</strong> is the most accurate way of persisting records to the <strong class="source-inline">signup</strong> table using SQLAlchemy. <strong class="source-inline">Session</strong> has an <strong class="source-inline">add()</strong> method, which we can invoke to add <a id="_idIndexMarker295"/>all record objects to the <a id="_idIndexMarker296"/>table, and a <strong class="source-inline">commit()</strong> transaction to finally flush all the new records into the database. The <strong class="source-inline">flush()</strong> method of <strong class="source-inline">Session</strong> is sometimes used instead of <strong class="source-inline">commit()</strong> to pursue the insertion and close <strong class="source-inline">Session</strong>, but most developers often use the latter. Note that the <strong class="source-inline">signup</strong> table contains all the gym members and trainers who want to gain access to the system. Now, the next script implements update record transaction:</p>
			<pre class="source-code">
    def <strong class="bold">update_signup</strong>(self, id:int, 
           details:Dict[str, An<a id="_idTextAnchor118"/>y]) -&gt; bool: 
       try:
             <strong class="bold">self.sess.query(Signup).</strong>
                 <strong class="bold">filter(Signup.id == id).update(details)     </strong>
             <strong class="bold">self.sess.commit() </strong>
       except: 
           return False 
       return True</pre>
			<p>The <strong class="source-inline">update_signup()</strong> provides a short, straightforward, and robust solution to updating a record in SQLAlchemy. Another possible solution is to query the record through <strong class="source-inline">self.sess.query(Signup).filter(Signup.id == id).first()</strong>, replace the attribute values of the retrieved object with the new values from the <strong class="source-inline">details</strong> dictionary, and then invoke <strong class="source-inline">commit()</strong>. This way is acceptable, but it takes three steps rather than calling the <strong class="source-inline">update()</strong> method after <strong class="source-inline">filter()</strong>, which only takes one. Next script is an implementation of a delete record transaction:</p>
			<pre class="source-code">
    def <strong class="bold">delete_signup</strong>(self, id:int) -&gt; bool: 
        try:
           <strong class="bold">signup = self.sess.query(Signup).</strong>
                  <strong class="bold">filter(Signup.id == id).delete()</strong>
           <strong class="bold">self.sess.commit()</strong>
        except: 
            return False 
        return True</pre>
			<p>On the other hand, <strong class="source-inline">delete_signup()</strong> follows the strategy of <strong class="source-inline">update_signup()</strong>, which uses <strong class="source-inline">filter()</strong> first before <strong class="source-inline">delete()</strong> is called. Another way of implementing this is to retrieve the object using <strong class="source-inline">sess.query()</strong> again and pass the retrieved object as an argument<a id="_idIndexMarker297"/> to the <strong class="source-inline">Session</strong> object’s <strong class="source-inline">delete(obj)</strong>, which is a different function. Always<a id="_idIndexMarker298"/> remember to invoke <strong class="source-inline">commit()</strong> to flush the changes. Now, the following script shows how to implement the query transactions:</p>
			<pre class="source-code">
    def <strong class="bold">get_all_signup</strong>(self):
        return <strong class="bold">self.sess.query(Signup).all()</strong> 
    def <strong class="bold">get_all_signup_where</strong>(self, username:str):
        return self.sess.
             query(Signup.username, Signup.password).
             <strong class="bold">filter(Signup.username == username)</strong>.all() 
    
    def <strong class="bold">get_all_signup_sorted_desc</strong>(self):
        return self.sess.
            query(Signup.username,Signup.password).
            <strong class="bold">order_by(desc(Signup.username))</strong>.all()
    
    def <strong class="bold">get_signup</strong>(self, id:int): 
        return <strong class="bold">self.sess.query(Signup).</strong>
             <strong class="bold">filter(Signup.id == id).one_or_none()</strong></pre>
			<p>Moreover, <strong class="source-inline">SignupRepository</strong> also highlights multiple and single records being retrieved in many forms. The <strong class="source-inline">Session</strong> object has a <strong class="source-inline">query()</strong> method, which requires <em class="italic">model class(es)</em> or <em class="italic">model column names</em> as argument(s). The function argument performs the record retrieval with column projection. For instance, the given <strong class="source-inline">get_all_signup()</strong> selects all signup records with all the columns projected in the result. If we want to include only <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong>, we can write our query as <strong class="source-inline">sess.query(Signup.username, Signup.password)</strong>, just like in the given <strong class="source-inline">get_all_signup_where()</strong>. This <strong class="source-inline">query()</strong> method also shows how to manage constraints using the <strong class="source-inline">filter()</strong> method with the appropriate conditional expressions. Filtering always comes after column projection. </p>
			<p>On the other<a id="_idIndexMarker299"/> hand, the <strong class="source-inline">Session</strong> object<a id="_idIndexMarker300"/> has an <strong class="source-inline">order_by()</strong> method that takes column names as parameters. It is performed last in the series of query transactions, before the result is extracted. The given sample, <strong class="source-inline">get_all_signup_sorted_desc()</strong>, sorts all <strong class="source-inline">Signup</strong> objects in descending order by <strong class="source-inline">username</strong>.</p>
			<p>The last portion of the <strong class="source-inline">query()</strong> builder returns the result of the transactions, whether it is a list of records or a single record. The <strong class="source-inline">all()</strong> function ends the query statement that returns multiple records, while <strong class="source-inline">first()</strong>, <strong class="source-inline">scalar()</strong>, <strong class="source-inline">one()</strong>, or <strong class="source-inline">one_or_none()</strong> can be applied if the result is a single row. In <strong class="source-inline">get_signup()</strong>, <strong class="source-inline">one_or_none()</strong> is utilized to raise an exception when no record is returned. For SQLAlchemy’s query transactions, all these functions can close the <strong class="source-inline">Session</strong> object. The repository classes for SQLAlchemy are in the <strong class="source-inline">ch05a</strong> folder’s <strong class="source-inline">/repository/sqlalchemy/signup.py</strong> module script file.</p>
			<h3>Creating the JOIN queries</h3>
			<p>For all the <a id="_idIndexMarker301"/>ORMs supported by FastAPI, only SQLAlchemy implements join queries pragmatically and functionally, just like how we implemented the previous CRUD transactions. We used almost all of the methods we need to create joins previously except for <strong class="source-inline">join()</strong>.  </p>
			<p>Let us look at <strong class="source-inline">LoginMemberRepository</strong>, which shows how we can create a join query statement in SQLAlchemy with model classes in <em class="italic">one-to-one relationships</em>:</p>
			<pre class="source-code">
<strong class="bold">class LoginMemberRepository(): </strong>
    def __init__(self, sess:Session):
        self.sess:Session = sess
    
    def <strong class="bold">join_login_members</strong>(self):
        return self.sess.
           <strong class="bold">query(Login, Profile_Members)</strong>.
             <strong class="bold">filter(Login.id == Profile_Members.id).all()</strong></pre>
			<p><strong class="source-inline">join_login_members()</strong> shows the conventional way of creating <em class="italic">JOIN</em> queries. This solution requires passing the parent and child classes as query parameters and overriding the <strong class="source-inline">ON</strong> condition through the <strong class="source-inline">filter()</strong> method. The parent model class must come first in the column projection before the child class in the <strong class="source-inline">query()</strong> builder to extract the preferred result.</p>
			<p>Another way is to use the <strong class="source-inline">select_from()</strong> function instead of <strong class="source-inline">query()</strong> to distinguish the parent class from the child. This approach is more appropriate for a <em class="italic">one-to-one</em> relationship.</p>
			<p>On the other hand, <strong class="source-inline">MemberAttendanceRepository</strong> showcases the <em class="italic">one-to-many</em> relationship between the <strong class="source-inline">Profile_Members</strong> and <strong class="source-inline">Attendance_Member</strong> model classes:</p>
			<pre class="source-code">
<strong class="bold">class MemberAttendanceRepository(): </strong>
    def __init__(self, sess:Session):
        self.sess:Session = sess
    
    def <strong class="bold">join_member_attendance</strong>(self):
        return self.sess.
           <strong class="bold">query(Profile_Members, Attendance_Member).</strong>
           <strong class="bold">join(Attendance_Member).all()</strong>
    def <strong class="bold">outer_join_member</strong>(self):
         return self.sess.
            <strong class="bold">query(Profile_Members, Attendance_Member).</strong>
            <strong class="bold">outerjoin(Attendance_Member).all()</strong></pre>
			<p><strong class="source-inline">join_member_attendance()</strong> shows the use of the <strong class="source-inline">join()</strong> method in building the <em class="italic">INNER JOIN</em> queries between <strong class="source-inline">Profile_Members</strong> and <strong class="source-inline">Attendance_Member</strong>. <strong class="source-inline">filter()</strong> is not needed anymore to build the <strong class="source-inline">ON</strong> condition because <strong class="source-inline">join()</strong> automatically detects and recognizes the <strong class="source-inline">relationship()</strong> parameters and the <strong class="source-inline">ForeignKey</strong> constructs defined at the beginning. But if there are other additional constraints, <strong class="source-inline">filter()</strong> can always be invoked, but only after the <strong class="source-inline">join()</strong> method.</p>
			<p>The <strong class="source-inline">outer_join_member()</strong> repository method implements an <em class="italic">OUTER JOIN</em> query from the one-to-many relationship. The <strong class="source-inline">outerjoin()</strong> method will extract all <strong class="source-inline">Profile_Members</strong> records <a id="_idIndexMarker302"/>mapped to their corresponding <strong class="source-inline">Attendance_Member</strong> or return <strong class="source-inline">null</strong> if there are none. </p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor119"/>Running the transactions</h2>
			<p>Now, let us<a id="_idIndexMarker303"/> apply these repository transactions to the administration-related API services of our application. Instead of using collections to store all the records, we will be utilizing the ORM’s transactions to manage the data using PostgreSQL. First, we need to import the essential components required by the repository, such as <strong class="source-inline">SessionFactory</strong>, the repository class, and the <strong class="source-inline">Signup</strong> model class. APIs such as <strong class="source-inline">Session</strong> and other <strong class="source-inline">typing</strong> APIs can only be part of the implementation for type hints. </p>
			<p>The following script shows a portion of the administrator’s API services highlighting the insertion and retrieval services for new access registration:</p>
			<pre class="source-code">
from fastapi import APIRouter, Depends
from fastapi.responses import JSONResponse
<strong class="bold">from sqlalchemy.orm import Session</strong>
<strong class="bold">from db_config.sqlalchemy_connect import SessionFactory</strong>
from repository.sqlalchemy.signup import <strong class="bold">SignupRepository</strong>,
   LoginMemberRepository, MemberAttendanceRepository
from typing import List
router = APIRouter()
<strong class="bold">def sess_db():</strong>
    <strong class="bold">db = SessionFactory()</strong>
    try:
        <strong class="bold">yield db</strong>
    finally:
        <strong class="bold">db.close()</strong></pre>
			<p>First, we <a id="_idIndexMarker304"/>need to create the <strong class="source-inline">Session</strong> instance through <strong class="source-inline">SessionFactory()</strong>, which we derived from <strong class="source-inline">sessionmaker()</strong>, since the repository layer is dependent on the session. In our application, a <strong class="source-inline">sess_db()</strong> custom generator is used to open and destroy the <strong class="source-inline">Session</strong> instance. It is injected into the API service methods to tell the <strong class="source-inline">Session</strong> instance to proceed with instantiating <strong class="source-inline">SignupRepository</strong>: </p>
			<pre class="source-code">
<strong class="bold">@router.post("/signup/add")</strong>
def add_signup(req: SignupReq, 
          <strong class="bold">sess:Session = Depends(sess_db)</strong>):
    <strong class="bold">repo:SignupRepository = SignupRepository(sess)</strong>
    <strong class="bold">signup = Signup(password= req.password, </strong>
                 <strong class="bold">username=req.username,id=req.id)</strong>
    <strong class="bold">result = repo.insert_signup(signup)</strong>
    if result == True:
        return signup
    else: 
        return JSONResponse(content={'message':'create 
                  signup problem encountered'}, 
                status_code=500)</pre>
			<p>Once<a id="_idIndexMarker305"/> instantiated, the repository can provide record insertion through <strong class="source-inline">insert_signup()</strong>, which inserts the <strong class="source-inline">Signup</strong> record. Another of its methods is <strong class="source-inline">get_all_signup()</strong>, which retrieves all login accounts for approval:</p>
			<pre class="source-code">
<strong class="bold">@router.get("/signup/list", response_model=List[SignupReq])</strong>
def list_signup(<strong class="bold">sess:Session = Depends(sess_db)</strong>):
    <strong class="bold">repo:SignupRepository = SignupRepository(sess)</strong>
    result = repo.get_all_signup()
    return result
<strong class="bold">@router.get("/signup/list/{id}", response_model=SignupReq</strong>)
def get_signup(id:int, <strong class="bold">sess:Session = Depends(create_db)</strong>): 
    <strong class="bold">repo:SignupRepository = SignupRepository(sess)</strong>
    result = repo.get_signup(id)
    return result</pre>
			<p>Both the <strong class="source-inline">get_signup()</strong> and <strong class="source-inline">list_signup()</strong> services have a <strong class="source-inline">request_model</strong> of the <strong class="source-inline">SignupReq</strong> type, which determines the expected output of the APIs. But as you may have noticed, <strong class="source-inline">get_signup()</strong> returns the <strong class="source-inline">Signup</strong> object, while <strong class="source-inline">list_signup()</strong> returns a list of <strong class="source-inline">Signup</strong> records. How is that possible? If <strong class="source-inline">request_model</strong> is used to capture the query result of the SQLAlchemy query transactions, the <strong class="source-inline">BaseModel</strong> class or request model must include a nested <strong class="source-inline">Config</strong> class with its <strong class="source-inline">orm_mode</strong> set to <strong class="source-inline">True</strong>. This built-in configuration enables type mapping and validation of <strong class="source-inline">BaseModel</strong> for the SQLAlchemy model types used by the repository, before all the record objects are filtered and stored in the request models. More information about the <strong class="source-inline">response_model</strong> parameter can be found in <a href="B17975_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Setting Up FastAPI for Starters</em>.</p>
			<p><strong class="source-inline">SignupReq</strong>, which is<a id="_idIndexMarker306"/> used by the query services of our application, is defined as follows:</p>
			<pre class="source-code">
from pydantic import BaseModel
<strong class="bold">class SignupReq(BaseModel): </strong>
    id : int 
    username: str 
    password: str 
        
    <strong class="bold">class Config:</strong>
        <strong class="bold">orm_mode = True</strong></pre>
			<p>The script shows how <strong class="source-inline">orm_mode</strong> is enabled using the equals sign (<strong class="source-inline">=</strong>) rather than the typical colon symbol (<strong class="source-inline">:</strong>), which means <strong class="source-inline">orm_mode</strong> is a configuration detail and not part of the class attribute.</p>
			<p>Overall, using <a id="_idIndexMarker307"/>SQLAlchemy for the repository layer is systematic and procedural. It is easy to map and synchronize the model classes with the schema definitions. Establishing relationships through the model classes is handy and predictable. Although there are lots of APIs and directives involved, it is still the most widely supported library for domain modeling and repository construction. Its documentation (<a href="https://docs.sqlalchemy.org/en/14/">https://docs.sqlalchemy.org/en/14/</a>) is complete and informative enough to guide developers regarding the different API classes and methods.</p>
			<p>Another feature of SQLAlchemy that’s loved by many is its capability to generate table schemas at the application level.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor120"/>Creating tables </h2>
			<p>Usually, SQLAlchemy <a id="_idIndexMarker308"/>works with the table schemas that have already been generated by the database administrator. In this project, the ORM setup started with designing the domain model classes before mapping them to the actual tables. But SQLAlchemy can auto-create table schemas at runtime for the FastAPI platform, which may be helpful during the testing or prototyping stage of the project. </p>
			<p>The <strong class="source-inline">sqlalchemy</strong> module has a <strong class="source-inline">Table()</strong> directive that can create a table object with the essential column metadata using the <strong class="source-inline">Column()</strong> method, which we used in the mapping. The following is a sample script that shows how the ORM creates the signup table at the application level:</p>
			<pre class="source-code">
<strong class="bold">from sqlalchemy import Table, Column, Integer, String, </strong>
               <strong class="bold">MetaData</strong>
from db_config.sqlalchemy_connect import <strong class="bold">engine</strong>
<strong class="bold">meta = MetaData()</strong>
signup = <strong class="bold">Table</strong>(
   '<strong class="bold">signup</strong>', <strong class="bold">meta</strong>, 
   Column('id', Integer, primary_key = True, 
          nullable=False), 
   Column('username', String, unique = False, 
          nullable = False), 
   Column('password', String, unique = False, 
          nullable = False), 
)
<strong class="bold">meta.create_all(bind=engine)</strong></pre>
			<p>Part of the schema definition is <strong class="source-inline">MetaData()</strong>, a registry that contains the necessary methods for generating the tables. When all the schema definitions are signed off, the <strong class="source-inline">create_all()</strong> method of the <strong class="source-inline">MetaData()</strong> instance is executed with the engine to create the tables. This process may sound straightforward, but we seldom pursue this DDL feature of <a id="_idIndexMarker309"/>SQLAlchemy in projects at the production stage.</p>
			<p>Now, let us explore how SQLAlchemy can be used to create asynchronous CRUD transactions for asynchronous API services. </p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor121"/>Implementing async CRUD transactions using SQLAlchemy</h1>
			<p>From <a id="_idIndexMarker310"/>version 1.4, SQLAlchemy <a id="_idIndexMarker311"/>supports <strong class="bold">asynchronous I/O </strong>(<strong class="bold">AsyncIO</strong>) features, which enables support for asynchronous connections, sessions, transactions, and database drivers. Most of the procedures for creating the repository are the same as those for the synchronous setup. The only difference is the non-direct access that the CRUD commands have with the asynchronous <strong class="source-inline">Session</strong> object. Our <strong class="source-inline">ch05b</strong> project showcases the asynchronous side of SQLAlchemy. </p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor122"/>Installing the asyncio-compliant database drivers</h2>
			<p>Before we begin<a id="_idIndexMarker312"/> setting up the database configuration, we need to install the following asyncio-compliant drivers: <strong class="source-inline">aiopg</strong> and <strong class="source-inline">asyncpg</strong>. First, we need to install <strong class="source-inline">aiopg</strong>, a library that will assist with any asynchronous access to PostgreSQL:</p>
			<p class="source-code">pip install aiopg</p>
			<p>Next, we must install <strong class="source-inline">asyncpg</strong>, which helps build PostgreSQL asynchronous transactions through Python’s AsyncIO framework:</p>
			<p class="source-code">pip install asyncpg</p>
			<p>This driver is a <em class="italic">non-database API-compliant</em> driver because it runs on top of the AsyncIO environment instead of the database API specification for synchronous database transactions.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor123"/>Setting up the database’s connection</h2>
			<p>After installing the<a id="_idIndexMarker313"/> necessary drivers, we can derive the database engine through the application’s <strong class="source-inline">create_async_engine()</strong> method, which creates an asynchronous version of SQLAlchemy’s <strong class="source-inline">Engine</strong>, known as <strong class="source-inline">AsyncEngine</strong>. This method has parameters to set such as <strong class="source-inline">future</strong>, which can enable a variety of asynchronous features during CRUD transactions when set to <strong class="source-inline">True</strong>. Also, it has an <strong class="source-inline">echo</strong> parameter that can provide us with the generated SQL queries in the server log at runtime. But the most essential is the database URL, which now reflects the asynchronous database access through calling the <strong class="source-inline">asyncpg</strong> protocol. The following is the complete script for the asynchronous connection to the PostgreSQL database:</p>
			<pre class="source-code">
<strong class="bold">from sqlalchemy.ext.asyncio import create_async_engine</strong>
DB_URL = 
  "<strong class="bold">postgresql+asyncpg</strong>://postgres:admin2255@
       localhost:5433/fcms"
<strong class="bold">engine = create_async_engine(DB_URL, future=True, </strong>
               <strong class="bold">echo=True)</strong></pre>
			<p>The additional <strong class="source-inline">"+asyncpg"</strong> detail in <strong class="source-inline">DB_URL</strong> indicates that <strong class="source-inline">psycopg2</strong> will no longer be the core database driver for PostgreSQL; instead, <strong class="source-inline">asyncpg</strong> will be used. This detail enables <strong class="source-inline">AsyncEngine</strong> to utilize <strong class="source-inline">asyncpg</strong> to establish the connection to the database. Omitting <a id="_idIndexMarker314"/>this detail will instruct the engine to recognize the <strong class="source-inline">psycopg2</strong> database API driver, which will cause problems during the CRUD transactions. </p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor124"/>Creating the session factory</h2>
			<p>Like in the synchronous<a id="_idIndexMarker315"/> version, the <strong class="source-inline">sessionmaker()</strong> directive is utilized to create the session factory with some new parameters set to enable <strong class="source-inline">AsyncSession</strong>. First, its <strong class="source-inline">expire_on_commit</strong> parameter is set to <strong class="source-inline">False</strong> to make that model instances and its attribute values accessible for the duration of the transaction, even after calling <strong class="source-inline">commit()</strong>. Unlike in the synchronous environment, all entity classes and their column objects are still accessible by other processes, even after transaction commit. Then, its <strong class="source-inline">class_</strong> parameter bears the class name <strong class="source-inline">AsyncSession</strong>, the entity that will take control of the CRUD transactions. Of course, <strong class="source-inline">sessionmaker()</strong> still needs the engine for <strong class="source-inline">AsyncConnection</strong> and its underlying asynchronous context managers. </p>
			<p>The following script shows how the session factory is derived using the <strong class="source-inline">sessionmaker()</strong> directive:</p>
			<pre class="source-code">
<strong class="bold">from sqlalchemy.ext.asyncio import AsyncSession</strong>
from sqlalchemy.orm import sessionmaker
engine = create_async_engine(DB_URL, future=True, 
               echo=True)
AsynSessionFactory = <strong class="bold">sessionmaker(engine,</strong> 
       <strong class="bold">expire_on_commit=False, class_=AsyncSession)</strong></pre>
			<p>The full <a id="_idIndexMarker316"/>configuration for the asynchronous SQLAlchemy database connection can be found in the <strong class="source-inline">/db_config/sqlalchemy_async_connect.py</strong> module script file. Let us now create the model layer.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor125"/>Creating the Base class and the model layer</h2>
			<p>Creating <a id="_idIndexMarker317"/>the <strong class="source-inline">Base</strong> class using <strong class="source-inline">declarative_base()</strong> and creating the model classes using <strong class="source-inline">Base</strong> is the same as what we did in the synchronous version. No additional<a id="_idIndexMarker318"/> parameters are needed to build the data layer for the asynchronous repository transactions.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor126"/>Building the repository layer</h2>
			<p>Implementing<a id="_idIndexMarker319"/> asynchronous CRUD transactions is entirely different from implementing synchronous ones. The ORM supports the use of the <strong class="source-inline">execute()</strong> method of the <strong class="source-inline">AsyncConnection</strong> API to run some of the built-in ORM core methods, namely <strong class="source-inline">update()</strong>, <strong class="source-inline">delete()</strong>, and <strong class="source-inline">insert()</strong>. When it comes to query transactions, the new <strong class="source-inline">select()</strong> directive from the <strong class="source-inline">sqlalchemy.future</strong> module is used instead of the core <strong class="source-inline">select()</strong> method. And since <strong class="source-inline">execute()</strong> is an <strong class="source-inline">async</strong> method, this requires that all repository transactions are <strong class="source-inline">async</strong> too to apply the <em class="italic">Async/Await</em> design pattern. The following <strong class="source-inline">AttendanceRepository</strong> uses the asynchronous type<a id="_idIndexMarker320"/> of SQLAlchemy:</p>
			<pre class="source-code">
from typing import List, Dict, Any
<strong class="bold">from sqlalchemy import update, delete, insert</strong>
<strong class="bold">from sqlalchemy.future import select</strong>
from sqlalchemy.orm import Session
from models.data.sqlalchemy_async_models import 
            Attendance_Member
<strong class="bold">class AttendanceRepository: </strong>
    
    def __init__(self, sess:Session):
        self.sess:Session = sess
    
    async def <strong class="bold">insert_attendance</strong>(self, attendance: 
           Attendance_Member) -&gt; bool: 
        try:
            <strong class="bold">sql = insert(Attendance_Member).</strong>
                   <strong class="bold">values(id=attendance.id, </strong>
                     <strong class="bold">member_id=attendance.member_id, </strong>
                     <strong class="bold">timein=attendance.timein, </strong>
                     <strong class="bold">timeout=attendance.timeout, </strong>
                     <strong class="bold">date_log=attendance.date_log</strong>)
            <strong class="bold">sql.execution_options(</strong>
                   <strong class="bold">synchronize_session="fetch")</strong>
            <strong class="bold">await self.sess.execute(sql)        </strong>
        except: 
            return False 
        return True</pre>
			<p>The given <em class="italic">asynchronous</em> <strong class="source-inline">insert_attendance()</strong> method in the preceding script shows the use of the <strong class="source-inline">insert()</strong> directive in creating an attendance log for a gym member. First, we need to pass the model class name to <strong class="source-inline">insert()</strong> to let the session know what table to access for the transaction. Afterward, it emits the <strong class="source-inline">values()</strong> method to project all the column values for insertion. Lastly, we need to call the <strong class="source-inline">execute()</strong> method to run the final <strong class="source-inline">insert()</strong> statement and automatically commit the changes since we didn’t turn off the <strong class="source-inline">autocommit</strong> parameter of <strong class="source-inline">sessionmaker()</strong> during the configuration. Do not forget to invoke <strong class="source-inline">await</strong> before running the asynchronous method because everything runs on top of the AsyncIO platform this time.    </p>
			<p>Also, you have the <a id="_idIndexMarker321"/>option to add some additional execution details before running <strong class="source-inline">execute()</strong>. One of these options is <strong class="source-inline">synchronize_session</strong>, which tells the session to always synchronize the model attribute values and the updated values from the database using the <strong class="source-inline">fetch</strong> method.</p>
			<p>Almost the same<a id="_idIndexMarker322"/> procedure is applied to the <strong class="source-inline">update_attendance()</strong> and <strong class="source-inline">delete_attendance()</strong> methods. We can run them through <strong class="source-inline">execute()</strong> and nothing else:</p>
			<pre class="source-code">
    async def <strong class="bold">update_attendance</strong>(self, id:int, 
           details:Dict[str, Any]) -&gt; bool: 
       try:
           <strong class="bold">sql = update(Attendance_Member).where(</strong>
              <strong class="bold">Attendance_Member.id == id).values(**details)</strong>
           <strong class="bold">sql.execution_options(</strong>
              <strong class="bold">synchronize_session="fetch")</strong>
           <strong class="bold">await self.sess.execute(sql)</strong>
           
       except: 
           return False 
       return True
   
    async def <strong class="bold">delete_attendance</strong>(self, id:int) -&gt; bool: 
        try:
           <strong class="bold">sql = delete(Attendance_Member).where(</strong>
                <strong class="bold">Attendance_Member.id == id)</strong>
           <strong class="bold">sql.execution_options(</strong>
                <strong class="bold">synchronize_session="fetch")</strong>
           <strong class="bold">await self.sess.execute(sql)</strong>
        except: 
            return False 
        return True</pre>
			<p>When it comes to queries, the repository class contains <strong class="source-inline">get_all_attendance()</strong>, which retrieves <a id="_idIndexMarker323"/>all the attendance records, and <strong class="source-inline">get_attendance()</strong>, which retrieves the attendance log of a particular member through its <strong class="source-inline">id</strong>. Constructing the <strong class="source-inline">select()</strong> method is a straightforward and pragmatic task since it is similar to writing a native <strong class="source-inline">SELECT</strong> statement in SQL development. First, the method needs to know what columns to project, and then it caters to some constraints if there are any. Then, it needs the <strong class="source-inline">execute()</strong> method to run the query asynchronously and extract the <strong class="source-inline">Query</strong> object. The resulting <strong class="source-inline">Query</strong> object has a <strong class="source-inline">scalars()</strong> method, which we can call to retrieve the list of records. Do not forget to close the session by calling the <strong class="source-inline">all()</strong> method. </p>
			<p><strong class="source-inline">check_attendance()</strong>, on the<a id="_idIndexMarker324"/> other hand, uses the <strong class="source-inline">scalar()</strong> method of the <strong class="source-inline">Query</strong> object to retrieve one record: a specific attendance. Aside from record retrieval, <strong class="source-inline">scalar()</strong> also closes the session:</p>
			<pre class="source-code">
    async def <strong class="bold">get_all_attendance</strong>(self):
        <strong class="bold">q = await self.sess.execute(</strong>
               <strong class="bold">select(Attendance_Member))</strong>
        return <strong class="bold">q.scalars().all()</strong>
    
    async def <strong class="bold">get_attendance</strong>(self, id:int): 
        <strong class="bold">q = await self.sess.execute(</strong>
           <strong class="bold">select(Attendance_Member).</strong>
             <strong class="bold">where(Attendance_Member.member_id == id))</strong>
        return <strong class="bold">q.scalars().all()</strong>
    async def <strong class="bold">check_attendance</strong>(self, id:int): 
        <strong class="bold">q = await self.sess.execute(</strong>
          <strong class="bold">select(Attendance_Member).</strong>
              <strong class="bold">where(Attendance_Member.id == id))</strong>
        return <strong class="bold">q.scalar()</strong>        </pre>
			<p>The repository classes for the asynchronous SQLAlchemy can be found in the <strong class="source-inline">/repository/sqlalchemy/attendance.py</strong> module script file. Now, let us apply these asynchronous transactions to<a id="_idIndexMarker325"/> pursue some attendance monitoring services for our fitness gym application.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The <strong class="source-inline">**</strong> operator in <strong class="source-inline">update_attendance()</strong> is a Python operator overload that converts a dictionary into <strong class="source-inline">kwargs</strong>. Thus, the result of <strong class="source-inline">**details</strong> is a <strong class="source-inline">kwargs</strong> argument for the <strong class="source-inline">values()</strong> method of the <strong class="source-inline">select()</strong> directive.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor127"/>Running the CRUD transactions</h2>
			<p>There two big differences <a id="_idIndexMarker326"/>between AsyncIO-driven SQLAlchemy and the database API-compliant option when creating the <strong class="source-inline">Session</strong> instance: </p>
			<ul>
				<li>First, <strong class="source-inline">AsyncSession</strong>, which was created by the <strong class="source-inline">AsyncSessionFactory()</strong> directive, needs an asynchronous <strong class="source-inline">with</strong> context manager because of the connection’s <strong class="source-inline">AsyncEngine</strong>, which needs to be closed after every <strong class="source-inline">commit()</strong> transaction. Closing the session factory is not part of the procedure in the synchronous ORM version. </li>
				<li>Second, after its creation, <strong class="source-inline">AsyncSession</strong> will only start executing all the CRUD transactions when the service calls its <strong class="source-inline">begin()</strong> method. The main reason is that <strong class="source-inline">AsyncSession</strong> can be closed and needs to be closed once the transaction has been executed. That is why another asynchronous context manager is used to manage <strong class="source-inline">AsyncSession</strong>. </li>
			</ul>
			<p>The following code shows the <strong class="source-inline">APIRouter</strong> script, which implements the services for monitoring gym <a id="_idIndexMarker327"/>member attendance using the asynchronous <strong class="source-inline">AttendanceRepository</strong>:</p>
			<pre class="source-code">
from fastapi import APIRouter
<strong class="bold">from db_config.sqlalchemy_async_connect import </strong>
          <strong class="bold">AsynSessionFactory</strong>
from repository.sqlalchemy.attendance import 
         <strong class="bold">AttendanceRepository</strong>
from models.requests.attendance import AttendanceMemberReq
from models.data.sqlalchemy_async_models import 
         <strong class="bold">Attendance_Member</strong>
router = APIRouter()
<strong class="bold">@router.post("/attendance/add")</strong>
async def <strong class="bold">add_attendance</strong>(req:AttendanceMemberReq ):
<strong class="bold">    async with AsynSessionFactory() as sess:</strong>
        <strong class="bold">async with sess.begin():</strong>
            <strong class="bold">repo = AttendanceRepository(sess)</strong>
            attendance = Attendance_Member(id=req.id,  
                member_id=req.member_id, 
                timein=req.timein, timeout=req.timeout, 
                date_log=req.date_log)
            return await repo.insert_attendance(attendance)
        
<strong class="bold">@router.patch("/attendance/update")</strong>
async def update_attendance(id:int, 
                     req:AttendanceMemberReq ):
    <strong class="bold">async with AsynSessionFactory() as sess:</strong>
        <strong class="bold">async with sess.begin():</strong>
            repo = AttendanceRepository(sess)
            attendance_dict = req.dict(exclude_unset=True)
            return await repo.update_attendance(id, 
                    attendance_dict)
<strong class="bold">@router.delete("/attendance/delete/{id}")</strong>
async def delete_attendance(id:int): 
     <strong class="bold">async with AsynSessionFactory() as sess:</strong>
        <strong class="bold">async with sess.begin():</strong>
            repo = AttendanceRepository(sess)
            return await repo.delete_attencance(id)
<strong class="bold">@router.get("/attendance/list")</strong>
async def list_attendance():
     <strong class="bold">async with AsynSessionFactory() as sess:</strong>
        <strong class="bold">async with sess.begin():</strong>
            repo = AttendanceRepository(sess)
            return await repo.get_all_attendance()</pre>
			<p>The preceding <a id="_idIndexMarker328"/>script shows no direct parameter passing between the repository class and the <strong class="source-inline">AsyncSession</strong> instance. The session must comply with the two context managers before it becomes a working one. This syntax is valid under <em class="italic">SQLAlchemy 1.4</em>, which may undergo some changes in the future with SQLAlchemy’s next releases. </p>
			<p>Other ORM platforms that have been created for asynchronous transactions are easier to use. One of these is <strong class="bold">GINO</strong>.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor128"/>Using GINO for async transactions</h1>
			<p><strong class="bold">GINO</strong>, which <a id="_idIndexMarker329"/>stands for <strong class="bold">GINO Is Not ORM</strong>, is a lightweight asynchronous ORM that runs on top of an SQLAlchemy Core and AsyncIO environment. All its APIs are asynchronous-ready so that you can build contextual database connections and transactions. It has built-in <em class="italic">JSONB</em> support so that it can convert its results into JSON objects. But there is one catch: GINO only supports PostgreSQL databases.</p>
			<p>While<a id="_idIndexMarker330"/> creating the gym fitness project, the only available stable GINO version is 1.0.1, which requires <em class="italic">SQLAlchemy 1.3</em>. Therefore, installing GINO will automatically uninstall <em class="italic">SQLAlchemy 1.4</em>, thus adding the GINO repository to the <strong class="source-inline">ch05a</strong> project to avoid any conflicts with the async version of SQLAlchemy. </p>
			<p>You can use the following command to install the latest version of GINO:</p>
			<p class="source-code">pip install gino</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor129"/>Installing the database driver</h2>
			<p>Since the only RDBMS it <a id="_idIndexMarker331"/>supports is PostgreSQL, you only need to install <strong class="source-inline">asyncpg</strong> using the <strong class="source-inline">pip</strong> command.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor130"/>Establishing the database connection</h2>
			<p>No other APIs are <a id="_idIndexMarker332"/>needed to open a connection to the database except for the <strong class="source-inline">Gino</strong> directive. We need to instantiate the class to start building the domain layer. The <strong class="source-inline">Gino</strong> class can be imported from the ORM’s <strong class="source-inline">gino</strong> module, as shown by the following script:</p>
			<pre class="source-code">
<strong class="bold">from gino import Gino</strong>
db = Gino()</pre>
			<p>Its instance is like a façade that controls all database transactions. It starts by establishing a database connection once it’s been provided with the correct PostgreSQL administrator credentials. The <a id="_idIndexMarker333"/>full GINO database connectivity script can be found in the <strong class="source-inline">/db_config/gino_connect.py</strong> script file. Let us now build the model layer.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor131"/>Building the model layer</h2>
			<p>The model class<a id="_idIndexMarker334"/> definition in GINO has similarities with SQLAlchemy when it comes to structuring, column metadata, and even the existence of the <strong class="source-inline">__tablename__</strong> property. The only difference is the superclass type because GINO uses the <strong class="source-inline">Model</strong> class from the database reference instance’s <strong class="source-inline">db</strong>. The following script shows how the <strong class="source-inline">Signup</strong> domain model is mapped to the <strong class="source-inline">signup</strong> table:</p>
			<pre class="source-code">
<strong class="bold">from db_config.gino_connect import db</strong>
class Signup(<strong class="bold">db.Model</strong>):
    <strong class="bold">__tablename__ = "signup"</strong>
    id = <strong class="bold">db.Column</strong>(<strong class="bold">db.Integer</strong>, primary_key=True, 
               index=True)
    username = <strong class="bold">db.Column</strong>(<strong class="bold">'username'</strong>,<strong class="bold">db.String</strong>, 
               unique=False, index=False)
    password = <strong class="bold">db.Column</strong>(<strong class="bold">'password'</strong>,<strong class="bold">db.String</strong>, 
               unique=False, index=False)</pre>
			<p>Like in SQLAlchemy, the <strong class="source-inline">__tablename__</strong> property is mandatory for all model classes to indicate their mapped table schema. When defining the column metadata, the <strong class="source-inline">db</strong> object has a <strong class="source-inline">Column</strong> directive that can set properties such as the <em class="italic">column type</em>, <em class="italic">primary key</em>, <em class="italic">unique</em>, <em class="italic">default</em>, <em class="italic">nullable</em>, and <em class="italic">index</em>. The column types also come from the <strong class="source-inline">db</strong> reference object, and these types are also the same for SQLAlchemy – that is, <strong class="source-inline">String</strong>, <strong class="source-inline">Integer</strong>, <strong class="source-inline">Date</strong>, <strong class="source-inline">Time</strong>, <strong class="source-inline">Unicode</strong>, and <strong class="source-inline">Float</strong>. </p>
			<p>And just in case the <a id="_idIndexMarker335"/>name of the model attribute does not match the column name, the <strong class="source-inline">Column</strong> directive has its first parameter register the name of the actual column and maps it to the model attributes. The <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong> columns are example cases of mapping the class attributes to the table’s column names.</p>
			<h3>Mapping table relationships   </h3>
			<p>At the time of<a id="_idIndexMarker336"/> writing, GINO only supports the <em class="italic">many-to-one relationship</em> by default. The <strong class="source-inline">db</strong> reference object has a <strong class="source-inline">ForeignKey</strong> directive, which establishes a foreign key relationship with the parent model. It just needs the actual reference key column and table name of the parent table to pursue the mapping. Setting the <strong class="source-inline">ForeignKey</strong> property in the <strong class="source-inline">Column</strong> object of the child model class is enough configuration to perform a <em class="italic">LEFT OUTER JOIN</em> to retrieve all the child records of the parent mode class. GINO has no <strong class="source-inline">relationship()</strong> function to address more details regarding how to fetch the child records of the parent model class. However, it has built-in loaders to automatically determine the foreign key and perform a many-to-one join query afterward. A <a id="_idIndexMarker337"/>perfect setup for this join query is the relationship configuration between the <strong class="source-inline">Profile_Trainers</strong> and <strong class="source-inline">Gym_Class</strong> model classes, as shown in the following script:</p>
			<pre class="source-code">
class <strong class="bold">Profile_Trainers</strong>(db.Model):
    __tablename__ = "profile_trainers"
    id = db.Column(db.Integer, <strong class="bold">db.ForeignKey('login.id')</strong>, 
              primary_key=True, index=True)
    firstname = db.Column(db.String, unique=False, 
              index=False)
    … … … … … …
    shift = db.Column(db.Integer, unique=False, 
              index=False)
class <strong class="bold">Gym_Class</strong>(db.Model): 
    __tablename__ = "gym_class"
    id = db.Column(db.Integer, primary_key=True, 
          index=True)
    member_id = db.Column(db.Integer, 
       <strong class="bold">db.ForeignKey('profile_members.id')</strong>, unique=False, 
         index=False)
    trainer_id = db.Column(db.Integer, 
      <strong class="bold">db.ForeignKey('profile_trainers.id')</strong>, unique=False,
         index=False)
    approved = db.Column(db.Integer, unique=False, 
       index=False)</pre>
			<p>We will have to make some changes if we need to build a query that will deal with a <em class="italic">one-to-many</em> or a <em class="italic">one-to-one relationship</em>. For the <em class="italic">LEFT OUTER JOIN</em> query to work, the parent model class must have a <strong class="source-inline">set</strong> collection defined to contain all the child records during <a id="_idIndexMarker338"/>join queries involving one-to-many relationships. For a <em class="italic">one-to-one relationship</em>, the parent only needs to instantiate the child model:</p>
			<pre class="source-code">
class <strong class="bold">Login</strong>(<strong class="bold">db.Model</strong>): 
    __tablename__ = "login"
    id = db.Column(db.Integer, primary_key=True, 
               index=True)
    username = db.Column(db.String, unique=False, 
               index=False)
    … … … … … …
    <strong class="bold">def __init__(self, **kw):</strong>
        <strong class="bold">super().__init__(**kw)</strong>
        <strong class="bold">self._child = None</strong>
    <strong class="bold">@property</strong>
    <strong class="bold">def child(self):</strong>
        <strong class="bold">return self._child</strong>
    <strong class="bold">@child.setter</strong>
    <strong class="bold">def child(self, child):</strong>
        <strong class="bold">self._child = child</strong>
class <strong class="bold">Profile_Members</strong>(db.Model): 
    __tablename__ = "profile_members"
    id = db.Column(db.Integer, <strong class="bold">db.ForeignKey('login.id')</strong>, 
          primary_key=True, index=True)
    … … … … … … 
    weight = db.Column(db.Float, unique=False, index=False)
    trainer_id = db.Column(db.Integer, 
        <strong class="bold">db.ForeignKey('profile_trainers.id')</strong>, unique=False, 
            index=False)
    
    <strong class="bold">def __init__(self, **kw):</strong>
        <strong class="bold">super().__init__(**kw)</strong>
        <strong class="bold">self._children = set()</strong>
    <strong class="bold">@property</strong>
    <strong class="bold">def children(self):</strong>
        <strong class="bold">return self._children</strong>
    <strong class="bold">@children.setter</strong>
    <strong class="bold">def children(self, child):</strong>
        <strong class="bold">self._children.add(child)</strong></pre>
			<p>This <em class="italic">set collection</em> or <em class="italic">child object</em> must be instantiated in the parent’s <strong class="source-inline">__init__()</strong> to be accessed<a id="_idIndexMarker339"/> by the ORM’s loader through the <em class="italic">children</em> or <em class="italic">child</em> <strong class="source-inline">@property</strong>, respectively. Using <strong class="source-inline">@property</strong> is the only way to manage joined records. </p>
			<p>Note that the existence of the loader APIs is proof that GINO does not support the automated relationship that SQLAlchemy has. If we want to deviate from its core setup, Python programming is needed to add some features not supported by the platform, such as the one-to-many setup between <strong class="source-inline">Profile_Members</strong> and <strong class="source-inline">Gym_Class</strong>, and between <strong class="source-inline">Login</strong> and <strong class="source-inline">Profile_Members</strong>/<strong class="source-inline">Profile_Trainers</strong>. In the previous script, notice the inclusion of a constructor and the custom <strong class="source-inline">children</strong> Python property in <strong class="source-inline">Profile_Members</strong>, as well as the custom <strong class="source-inline">child</strong> property in <strong class="source-inline">Login</strong>. This is because GINO only has a built-in <strong class="source-inline">parent</strong> property.</p>
			<p>You can find the<a id="_idIndexMarker340"/> domain models of GINO in the <strong class="source-inline">/models/data/gino_models.py</strong> script.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout"><strong class="source-inline">@property</strong> is a Python decorator that’s used to implement a getter/setter in a class. This hides an instance variable from the accessor and exposes its <em class="italic">getter</em> and <em class="italic">setter</em> property <em class="italic">fields</em>. Using <strong class="source-inline">@property</strong> is one way to implement the <em class="italic">encapsulation</em> principle in Python.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor132"/>Implementing the CRUD transactions</h2>
			<p>Let us consider the following <strong class="source-inline">TrainerRepository</strong>, which manages trainer profiles. Its <strong class="source-inline">insert_trainer()</strong> method shows the conventional way of implementing insert transactions. GINO<a id="_idIndexMarker341"/> requires its model class to call <strong class="source-inline">create()</strong>, an inherited method from the <strong class="source-inline">db</strong> reference object. All the column values are passed to the <strong class="source-inline">create()</strong> method through named parameters or as a bundle using <strong class="source-inline">kwargs</strong> before the record object is persisted. But GINO allows another insert option that uses the instance of the model derived by injecting column values into its constructor. The created instance has a method called <strong class="source-inline">create()</strong> that inserts the record object without requiring any parameters:</p>
			<pre class="source-code">
from models.data.gino_models import Profile_Members, 
           Profile_Trainers, Gym_Class
from datetime import date, time
from typing import List, Dict, Any
<strong class="bold">class TrainerRepository: </strong>
    
    async def <strong class="bold">insert_trainer</strong>(self, 
             details:Dict[str, Any]) -&gt; bool: 
        try:
            <strong class="bold">await Profile_Trainers.create(**details)</strong>
        except Exception as e: 
            print(e)
            return False 
        return True</pre>
			<p><strong class="source-inline">update_trainer()</strong> highlights how GINO updates table records. Based on the script, updating the table in the GINO way involves doing the following: </p>
			<ul>
				<li>First, it requires the <strong class="source-inline">get()</strong> class method of the model class to retrieve the record object with the <strong class="source-inline">id</strong> primary key.</li>
				<li>Second, the<a id="_idIndexMarker342"/> extracted record has an instance method called <strong class="source-inline">update()</strong> that will automatically modify the mapped row with the new data specified in its <strong class="source-inline">kwargs</strong> argument. The <strong class="source-inline">apply()</strong> method will commit the changes and close the transaction:<p class="source-code">    async def update_trainer(self, id:int, </p><p class="source-code">                 details:Dict[str, Any]) -&gt; bool: </p><p class="source-code">       try:</p><p class="source-code">            <strong class="bold">trainer = await Profile_Trainers.get(id)</strong></p><p class="source-code">            <strong class="bold">await trainer.update(**details).apply()       </strong></p><p class="source-code">       except: </p><p class="source-code">           return False </p><p class="source-code">       return True</p></li>
			</ul>
			<p>Another option is to use the SQLAlchemy <strong class="source-inline">ModelClass.update.values(ModelClass).where(expression)</strong> clause, which, when applied to <strong class="source-inline">update_trainer()</strong>, will give us this final statement: </p>
			<pre class="source-code">
Profile_Trainers.<strong class="bold">update.values(**details)</strong>.
     <strong class="bold">where(Profile_Trainers.id == id)</strong>.gino.status()</pre>
			<p>Its <strong class="source-inline">delete_trainer()</strong> also follows the same approach as the GINO <em class="italic">update</em> transaction. This transaction is a two-step process, and the last step requires calling the <strong class="source-inline">delete()</strong> instance <a id="_idIndexMarker343"/>method of the extracted record object:</p>
			<pre class="source-code">
    async def delete_trainer(self, id:int) -&gt; bool: 
        try:
           <strong class="bold">trainer = await Profile_Trainers.get(id)</strong>
           <strong class="bold">await trainer.delete()        </strong>
        except: 
            return False 
        return True</pre>
			<p>On the other hand, <strong class="source-inline">TrainerRepository</strong> has two methods, <strong class="source-inline">get_member()</strong> and <strong class="source-inline">get_all_member()</strong>, which show how GINO constructs query statements: </p>
			<ul>
				<li>The former retrieves a specific record object using its primary key through the <strong class="source-inline">get()</strong> class method of the model class </li>
				<li>The latter uses the <strong class="source-inline">gino</strong> extension of <strong class="source-inline">query</strong> to utilize the <strong class="source-inline">all()</strong> method, which retrieves the records:<p class="source-code">    async def get_all_member(self):</p><p class="source-code">        return <strong class="bold">await Profile_Trainers.query.gino.all()</strong></p><p class="source-code">    async def get_member(self, id:int): </p><p class="source-code">            return <strong class="bold">await Profile_Trainers.get(id)</strong></p></li>
			</ul>
			<p>But what translates database rows into model objects in a query’s execution is the built-in loader of GINO. If we expand further on the solution presented in <strong class="source-inline">get_all_member()</strong>, this will look like this:</p>
			<pre class="source-code">
query = db.select([Profile_Trainers])
q = query.execution_options(
         <strong class="bold">loader=ModelLoader(Profile_Trainers)</strong>)
users = await q.gino.all()</pre>
			<p>In the GINO ORM, all <a id="_idIndexMarker344"/>queries utilize <strong class="source-inline">ModelLoader</strong> to load each database record into a model object:</p>
			<pre class="source-code">
<strong class="bold">class GymClassRepository:</strong>
        
    async def join_classes_trainer(self):
        <strong class="bold">query = Gym_Class.join(Profile_Trainers).select()</strong>
        result = <strong class="bold">await query.gino.load(Gym_Class.</strong>
            <strong class="bold">distinct(Gym_Class.id).</strong>
                <strong class="bold">load(parent=Profile_Trainers)).all()</strong>
        return result 
    
    async def join_member_classes(self):
        <strong class="bold">query = Gym_Class.join(Profile_Members).select()</strong>
        result = <strong class="bold">await query.gino.load(Profile_Members.</strong>
           <strong class="bold">distinct(Profile_Members.id).</strong>
              <strong class="bold">load(add_child=Gym_Class)).all()</strong>
        return result</pre>
			<p>If the normal query requires <strong class="source-inline">ModelLoader</strong>, what is needed for the <em class="italic">JOIN</em> query transactions? GINO has no automated support for table relationships, and creating <em class="italic">JOIN</em> queries is impossible without <strong class="source-inline">ModelLoader</strong>. The <strong class="source-inline">join_classes_trainer()</strong> method implements a <em class="italic">one-to-many</em> query for <strong class="source-inline">Profile_Trainers</strong> and <strong class="source-inline">Gym_Class</strong>. The <strong class="source-inline">distinct(Gym_Class.id).load(parent=Profile_Trainers)</strong> clause in the query creates a <strong class="source-inline">ModelLoader</strong> for <strong class="source-inline">GymClass</strong>, which will merge and load the <strong class="source-inline">Profile_Trainers</strong> parent<a id="_idIndexMarker345"/> record into its child <strong class="source-inline">Gym_Class</strong>. <strong class="source-inline">join_member_classes()</strong> creates <em class="italic">one-to-many</em> joins, while <strong class="source-inline">distinct(Profile_Members.id).load(add_child=Gym_Class)</strong> creates a <strong class="source-inline">ModelLoader</strong> to build the set of <strong class="source-inline">Gym_Class</strong> records, as per the <strong class="source-inline">Profile_Members</strong> parent. </p>
			<p>On the other hand, the <em class="italic">many-to-one</em> relationship of <strong class="source-inline">Gym_Class</strong> and <strong class="source-inline">Profile_Members</strong> uses the <strong class="source-inline">load()</strong> function of <strong class="source-inline">Profile_Member</strong>, which is a different approach to <a id="_idIndexMarker346"/>matching the <strong class="source-inline">Gym_Class</strong> child records to <strong class="source-inline">Profile_Members</strong>. The following joined query is the opposite of the <em class="italic">one-to-many</em> setup because the <strong class="source-inline">Gym_Class</strong> records here are on the left-hand side while the profiles are on the right:</p>
			<pre class="source-code">
    async def join_classes_member(self):
        result = await 
<strong class="bold">          Profile_Members.load(add_child=Gym_Class)</strong>
           .query.gino.all()</pre>
			<p>So, the loader plays an important role in building queries in GINO, especially joins. Although it makes query building difficult, it still gives flexibility to many complex queries. </p>
			<p>All the repository classes for GINO can be found in the <strong class="source-inline">/repository/gino/trainers.py</strong> script.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor133"/>Running the CRUD transactions</h2>
			<p>For our <a id="_idIndexMarker347"/>repositories to run in the <strong class="source-inline">APIRouter</strong> module, we need to open the database connection by binding the <strong class="source-inline">db</strong> reference object to the actual database through <strong class="source-inline">DB_URL</strong>. It is ideal to use a dependable function for the binding procedure because the easier form of rolling out is done through <strong class="source-inline">APIRouter</strong> injection. The following script shows how to set up this database binding:</p>
			<pre class="source-code">
from fastapi import APIRouter, Depends
from fastapi.encoders import jsonable_encoder
from fastapi.responses import JSONResponse
<strong class="bold">from db_config.gino_connect import db</strong>
from models.requests.trainers import ProfileTrainersReq
from repository.gino.trainers import TrainerRepository
<strong class="bold">async def sess_db():</strong>
    <strong class="bold">await db.set_bind(</strong>
     <strong class="bold">"postgresql+asyncpg://</strong>
       <strong class="bold">postgres:admin2255@localhost:5433/fcms")</strong>
    
router = APIRouter(<strong class="bold">dependencies=[Depends(sess_db)]</strong>)
<strong class="bold">@router.patch("/trainer/update" )</strong>
async def update_trainer(id:int, req: ProfileTrainersReq): 
    mem_profile_dict = req.dict(exclude_unset=True)
    repo = TrainerRepository()
    result = await repo.update_trainer(id, 
           mem_profile_dict)
    if result == True: 
        return req 
    else: 
        return JSONResponse(
    content={'message':'update trainer profile problem 
         encountered'}, status_code=500)
 
<strong class="bold">@router.get("/trainer/list")</strong>
async def list_trainers(): 
    repo = TrainerRepository()
    return await repo.get_all_member()</pre>
			<p>The <strong class="source-inline">list_trainers()</strong> and <strong class="source-inline">update_trainer()</strong> REST services shown in the preceding code are some services of our <em class="italic">fitness club</em> application that will successfully run <strong class="source-inline">TrainerRepository</strong> after injecting <strong class="source-inline">sess_db()</strong> into <strong class="source-inline">APIRouter</strong>. GINO does not ask for many details when establishing the connection to PostgreSQL except for <strong class="source-inline">DB_URL</strong>. Always <a id="_idIndexMarker348"/>specify the <strong class="source-inline">asyncpg</strong> dialect in the URL because it is the only driver that’s supported by GINO as a synchronous ORM. </p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor134"/>Creating the tables</h2>
			<p>GINO and <a id="_idIndexMarker349"/>SQLAlchemy have the same approach to creating a table schema at the framework level. Both require the <strong class="source-inline">MetaData</strong> and <strong class="source-inline">Column</strong> directives for building the <strong class="source-inline">Table</strong> definitions. Then, an asynchronous function is preferred to derive the engine using the <strong class="source-inline">create_engine()</strong> method with our <strong class="source-inline">DB_URL</strong>. Like in SQLAlchemy, this engine plays a crucial role in building the tables through <strong class="source-inline">create_all()</strong>, but this time, it uses GINO’s <strong class="source-inline">GinoSchemaVisitor</strong> instance. The following script shows the complete implementation of how tables are generated in GINO using the AsyncIO platform:</p>
			<pre class="source-code">
from sqlalchemy import Table, Column, Integer, String, 
           <strong class="bold">MetaData</strong>, ForeignKey'
import gino
<strong class="bold">from gino.schema import GinoSchemaVisitor</strong>
<strong class="bold">metadata = MetaData()</strong>
signup = <strong class="bold">Table</strong>(
    'signup', <strong class="bold">metadata</strong>,
    <strong class="bold">Column</strong>('id', Integer, primary_key=True),
    <strong class="bold">Column</strong>('username', String),
    <strong class="bold">Column</strong>('password', String),
)
   … … … … …
<strong class="bold">async</strong> def db_create_tbl():
    <strong class="bold">engine = await gino.create_engine(DB_URL)</strong>
    <strong class="bold">await GinoSchemaVisitor(metadata).create_all(engine)</strong></pre>
			<p>As stated in <a id="_idIndexMarker350"/>SQLAlchemy, performing DDL transactions such as schema auto-generation at the start is optional because it may cause FastAPI’s performance to degrade, and even some conflicts in the existing database schema.</p>
			<p>Now, let us explore another ORM that requires custom Python coding: <strong class="bold">Pony ORM</strong>. </p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor135"/>Using Pony ORM for the repository layer</h1>
			<p>Pony ORM<a id="_idIndexMarker351"/> relies on Python syntax for building the model classes and repository transactions. This ORM only uses Python data types such as <strong class="source-inline">int</strong>, <strong class="source-inline">str</strong>, and <strong class="source-inline">float</strong>, as well as class types to implement model definitions. It applies Python <strong class="source-inline">lambda</strong> expressions to establish CRUD transactions, especially when mapping table relationships. Also, Pony <a id="_idIndexMarker352"/>heavily supports JSON conversion of record objects when reading records. On the other hand, Pony can cache the query objects, which provides faster performance than the others. The code for Pony ORM can be found in the <strong class="source-inline">ch05a</strong> project.</p>
			<p>To use Pony, we need to install it using <strong class="source-inline">pip</strong>. This is because it is a third-party platform:</p>
			<p class="source-code">pip install pony</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor136"/>Installing the database driver</h2>
			<p>Since Pony is an ORM designed to <a id="_idIndexMarker353"/>build synchronous transactions, we will need the <strong class="source-inline">psycopg2</strong> PostgreSQL driver. We can install it using the <strong class="source-inline">pip</strong> command:</p>
			<p class="source-code">pip install psycopg2</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor137"/>Creating the database’s connectivity</h2>
			<p>The approach to<a id="_idIndexMarker354"/> establishing database connectivity in Pony is simple and declarative. It only needs the <strong class="source-inline">Database</strong> directive from the <strong class="source-inline">pony.orm</strong> module to be instantiated to connect to the database using the correct database credentials. The following script is used in the <em class="italic">fitness club</em> prototype:</p>
			<pre class="source-code">
<strong class="bold">from pony.orm import  Database</strong>
db = <strong class="bold">Database</strong>("postgres", host="localhost", port="5433", 
  user="postgres", password="admin2255", database="fcms")</pre>
			<p>As you can see, the first parameter of the constructor is the <em class="italic">database dialect</em>, followed by <strong class="source-inline">kwargs</strong>, which contains all the details about the connection. The full configuration can be found in the <strong class="source-inline">/db_config/pony_connect.py</strong> script file. Now, let us create Pony's model classes.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor138"/>Defining the model classes</h2>
			<p>The <a id="_idIndexMarker355"/>created database object, <strong class="source-inline">db</strong>, is the only component needed to define a Pony <em class="italic">entity</em>, a term that refers to a model class. It has an <strong class="source-inline">Entity</strong> attribute, which is used to subclass each model class to provide the <strong class="source-inline">_table_</strong> attribute, which is responsible for the <em class="italic">table-entity</em> mapping. All entity instances are bound to <strong class="source-inline">db</strong> and mapped to the tables. The following script shows how the <strong class="source-inline">Signup</strong> class becomes an entity of the model layer:</p>
			<pre class="source-code">
<strong class="bold">from pony.orm import  Database, PrimaryKey, Required, </strong>
         <strong class="bold">Optional, Set</strong>
<strong class="bold">from db_config.pony_connect import db</strong>
from datetime import date, time
    
class Signup(<strong class="bold">db.Entity</strong>):
    <strong class="bold">_table_ = "signup"</strong>
    id = <strong class="bold">PrimaryKey</strong>(int)
    username = <strong class="bold">Required</strong>(str, unique=True, max_len=100, 
         nullable=False, column='username')
    password = <strong class="bold">Required</strong>(str, unique=Fals, max_len=100, 
         nullable=False, column='password')</pre>
			<p>The <strong class="source-inline">pony.orm</strong> module contains <strong class="source-inline">Required</strong>, <strong class="source-inline">Optional</strong>, <strong class="source-inline">PrimaryKey</strong>, or <strong class="source-inline">Set</strong> directives, which are used to create column attributes. Since each entity must have a primary<a id="_idIndexMarker356"/> key, <strong class="source-inline">PrimaryKey</strong> is used to define the column attribute of the entity. If the class has no primary key, Pony ORM will implicitly generate an <strong class="source-inline">id</strong> primary for the entity with the following definition:</p>
			<pre class="source-code">
id = <strong class="bold">PrimaryKey</strong>(int, auto=True)</pre>
			<p>On the other hand, the <strong class="source-inline">Set</strong> directive indicates relationships between entities. All these directives have a mandatory attribute column type, which declares the column value type in Python syntax (for example, <strong class="source-inline">int</strong>, <strong class="source-inline">str</strong>, <strong class="source-inline">float</strong>, <strong class="source-inline">date</strong>, or <strong class="source-inline">time</strong>) or any class type. Other column attributes include <strong class="source-inline">auto</strong>, <strong class="source-inline">max_len</strong>, <strong class="source-inline">index</strong>, <strong class="source-inline">unique</strong>, <strong class="source-inline">nullable</strong>, <strong class="source-inline">default</strong>, and <strong class="source-inline">column</strong>. Now, let us establish a relationship between model classes:</p>
			<pre class="source-code">
<strong class="bold">class Login(db.Entity): </strong>
    _table_ = "login"
    id = PrimaryKey(int)
    … … … … … …
    date_approved = Required(date)
    user_type = Required(int)
    
<strong class="bold">    trainers = Optional("Profile_Trainers", reverse="id")</strong>
<strong class="bold">    members = Optional("Profile_Members", reverse="id")</strong></pre>
			<p>The given <strong class="source-inline">Login</strong> class has two additional attributes, <strong class="source-inline">trainers</strong> and <strong class="source-inline">members</strong>, which serve as reference keys to the <strong class="source-inline">Profile_Trainers</strong> and <strong class="source-inline">Profile_Members</strong> models, respectively. In turn, these child entities have their respective class attributes pointing back at the <strong class="source-inline">Login</strong> model, establishing a relationship. These column attributes and their reference-foreign keys relationship must match the physical database schema. The following<a id="_idIndexMarker357"/> code shows examples of Pony’s child model classes:</p>
			<pre class="source-code">
<strong class="bold">class Profile_Trainers(db.Entity):</strong>
    _table_ = "profile_trainers"
<strong class="bold">    id = PrimaryKey("Login", reverse="trainers")</strong>
    firstname = Required(str)
    … … … … … …
    tenure = Required(float)
    shift = Required(int)
    
<strong class="bold">    members = Set("Profile_Members", </strong>
<strong class="bold">           reverse="trainer_id")</strong>
<strong class="bold">    gclass = Set("Gym_Class", reverse="trainer_id")</strong>
<strong class="bold">class Profile_Members(db.Entity): </strong>
    _table_ = "profile_members"
<strong class="bold">    id = PrimaryKey("Login", reverse="members")</strong>
    firstname = Required(str)
    … … … … … …
<strong class="bold">    trainer_id = Required("Profile_Trainers", </strong>
<strong class="bold">            reverse="members")</strong>
    … … … … … …</pre>
			<p>Defining the<a id="_idIndexMarker358"/> relationship attributes depends on the relationship type between the two entities. Attributes should be defined as <em class="italic">Optional(parent)</em>-<em class="italic">Required(child)</em> or <em class="italic">Optional(parent)</em>-<em class="italic">Optional(child) </em>if the relationship type is one-to-one. For one-to-many, attributes should be defined as <em class="italic">Set(parent)</em>-<em class="italic">Required(child)</em>. Finally, for many-to-one, the attributes must be defined as <em class="italic">Set(parent)</em>-<em class="italic">Set(child)</em>. </p>
			<p><strong class="source-inline">Login</strong> has a one-to-one relationship with <strong class="source-inline">Profile_Members</strong>, which explains the use of the <strong class="source-inline">Optional</strong> attribute to point to the <strong class="source-inline">id</strong> key of <strong class="source-inline">Profile_Members</strong>. The primary keys are always the reference keys in this relationship for Pony. </p>
			<p>On the other hand, the <strong class="source-inline">Profile_Trainers</strong> model has a one-to-many setup with <strong class="source-inline">Profile_Members</strong>, which explains why the <strong class="source-inline">trainer_id</strong> attribute of the former uses the <strong class="source-inline">Required</strong> directive to point to the <strong class="source-inline">Set</strong> attribute <strong class="source-inline">members</strong> of the latter. Sometimes, the framework requires backreference through the directive’s <strong class="source-inline">reverse </strong>parameter. The preceding code also depicts the same scenario between the <strong class="source-inline">Profile_Members</strong> and <strong class="source-inline">Gym_Class</strong> models, where the <strong class="source-inline">gclass</strong> attribute of <strong class="source-inline">Profile_Members</strong> is declared as a <strong class="source-inline">Set</strong> collection that contains all the enrolled gym classes of the member. The reference key can be a primary key or just a typical class attribute in this<a id="_idIndexMarker359"/> relationship. The following snippet shows the blueprint of the <strong class="source-inline">Gym_Class</strong> model:</p>
			<pre class="source-code">
<strong class="bold">class Gym_Class(db.Entity): </strong>
    _table_ = "gym_class"
    id = PrimaryKey(int)
    <strong class="bold">member_id = Required("Profile_Members", </strong>
         <strong class="bold">reverse="gclass")</strong>
    <strong class="bold">trainer_id = Required("Profile_Trainers", </strong>
         <strong class="bold">reverse="gclass")</strong>
    approved = Required(int)
<strong class="bold">db.generate_mapping()</strong></pre>
			<p>Unlike in other ORMs, Pony needs <strong class="source-inline">generate_mapping()</strong> to be executed to realize all the entity mappings to the actual tables. The method is an instance method of the <strong class="source-inline">db</strong> instance that must appear in the last part of the module script, as shown in the previous snippet, where <strong class="source-inline">Gym_Class</strong> was the last Pony model class to be defined. All the Pony model classes can be found in the <strong class="source-inline">/models/data/pony_models.py</strong> script file.</p>
			<p>Note that we can create Pony entities manually or digitally using <em class="italic">Pony ORM ER Diagram Editor</em>, which we can access at <a href="https://editor.ponyorm.com/">https://editor.ponyorm.com/</a>. The editor can provide us with both<a id="_idIndexMarker360"/> free and commercial accounts. Let us now implement the CRUD transactions.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor139"/>Implementing the CRUD transactions</h2>
			<p>CRUD <a id="_idIndexMarker361"/>transactions in Pony are session-driven. But unlike SQLAlchemy, its repository classes do not require injecting <strong class="source-inline">db_session</strong> into the repository constructor. Each transaction in Pony will not work without <strong class="source-inline">db_session</strong>. The following code shows a repository class that implements all the transactions needed to manage a list of gym members:</p>
			<pre class="source-code">
<strong class="bold">from pony.orm import db_session, left_join</strong>
from models.data.pony_models import Profile_Members, 
            Gym_Class, Profile_Trainers
from datetime import date, time
from typing import List, Dict, Any
from models.requests.members import ProfileMembersReq 
class MemberRepository: 
    
    def <strong class="bold">insert_member</strong>(self, 
            details:Dict[str, Any]) -&gt; bool: 
        try:
            <strong class="bold">with db_session:</strong>
                <strong class="bold">Profile_Members(**details)</strong>
        except: 
            return False 
        return True</pre>
			<p>In Pony, inserting<a id="_idIndexMarker362"/> a record means instantiating the model class with the injected record values. An example is <strong class="source-inline">insert_member()</strong>, which inserts a profile by instantiating the <strong class="source-inline">Profile_Members</strong> model with the injected membership details. However, the case is different when updating records, as shown in the following script:      </p>
			<pre class="source-code">
    def <strong class="bold">update_member</strong>(self, id:int, 
               details:Dict[str, Any]) -&gt; bool: 
       try:
          <strong class="bold">with db_session:</strong>
            <strong class="bold">profile = Profile_Members[id]</strong>
            <strong class="bold">profile.id = details["id"]</strong>
            … … … … … …
            <strong class="bold">profile.trainer_id = details["trainer_id"]</strong>
       except: 
           return False 
       return True</pre>
			<p>Updating a record in Pony, which is implemented in the <strong class="source-inline">update_member()</strong> script, means retrieving the record object through <em class="italic">indexing</em> using its <strong class="source-inline">id</strong>. The retrieved object is automatically converted into a JSON-able object since Pony has built-in support for JSON. Then, the new values of those attributes are overwritten as they must be changed. This <em class="italic">UPDATE</em> transaction is, again, within the bounds of <strong class="source-inline">db_session</strong>, thus automatically refreshing the record(s) after the overwrites.</p>
			<p>On the other hand, <strong class="source-inline">delete_member()</strong> of the repository class shows the same approach with <em class="italic">UPDATE</em>, except that a <strong class="source-inline">delete()</strong> class method is invoked right after retrieving the object record. The following is the script for this operation:</p>
			<pre class="source-code">
    def <strong class="bold">delete_member</strong>(self, id:int) -&gt; bool: 
        try:
           <strong class="bold">with db_session: </strong>
               <strong class="bold">Profile_Members[id].delete()</strong>
        except: 
            return False 
        return True</pre>
			<p>The delete<a id="_idIndexMarker363"/> transaction is also <strong class="source-inline">db_session</strong> bound, so invoking <strong class="source-inline">delete()</strong> automatically refreshes the table. The following code shows Pony’s implementation for query transactions:</p>
			<pre class="source-code">
    def <strong class="bold">get_all_member</strong>(self):
        <strong class="bold">with db_session:</strong>
            <strong class="bold">members = Profile_Members.select()</strong>
            <strong class="bold">result = [ProfileMembersReq.from_orm(m) </strong>
                 <strong class="bold">for m in members]</strong>
            <strong class="bold">return result</strong>
    
    def <strong class="bold">get_member</strong>(self, id:int): 
        <strong class="bold">with db_session:</strong>
            <strong class="bold">login = Login.get(lambda l: l.id == id)</strong>
            <strong class="bold">member = Profile_Members.get(</strong>
                <strong class="bold">lambda m: m.id == login)</strong>
            <strong class="bold">result = ProfileMembersReq.from_orm(member)</strong>
        return result</pre>
			<p><strong class="source-inline">get_member()</strong> retrieves a single record using the <strong class="source-inline">get()</strong> class method, which requires a <strong class="source-inline">lambda</strong> expression in its parameter. Since <strong class="source-inline">Login</strong> has a one-to-one relationship with <strong class="source-inline">Profile_Members</strong>, first, we must extract the <strong class="source-inline">Login</strong> record of the member and use the <strong class="source-inline">login</strong> object to fetch the record through the <strong class="source-inline">get()</strong> helper function of the <strong class="source-inline">Profile_Members</strong> entity. This approach is also applicable to other entities with other entity relationships. Now, <strong class="source-inline">get_all_member()</strong> retrieves a result set using the <strong class="source-inline">select()</strong> method. The <strong class="source-inline">select()</strong> method can also utilize a lambda expression if there are constraints in the retrieval operation. </p>
			<p>Pony model <a id="_idIndexMarker364"/>classes have the <strong class="source-inline">get()</strong> and <strong class="source-inline">select()</strong> methods, which both return <strong class="source-inline">Query</strong> objects that FastAPI cannot process directly. So, we need an ORM-friendly <strong class="source-inline">Pydantic</strong> model to extract the final entities from these <strong class="source-inline">Query</strong> objects. Like in SQLAlchemy, a <strong class="source-inline">ModelBase</strong> class with a nested <strong class="source-inline">Config</strong> class is required to retrieve the records from the <strong class="source-inline">Query</strong> object. The nested class must configure <strong class="source-inline">orm_mode</strong> to <strong class="source-inline">True</strong>. If relationship mappings are involved, the request model must also declare the attributes involved in the relationship and their corresponding child object converters. The method converters, decorated by Pydantic’s <strong class="source-inline">@validator</strong>, are automatically called by Pony to interpret and validate the <strong class="source-inline">Query</strong> objects into JSON-able components such as <strong class="source-inline">List</strong> or entity objects. The following code shows the request model that’s used to extract the records from <strong class="source-inline">select()</strong> through list comprehension and the <strong class="source-inline">Profile_Member dict</strong> object from <strong class="source-inline">get()</strong>:</p>
			<pre class="source-code">
from typing import List, Any
<strong class="bold">from pydantic import BaseModel, validator</strong>
<strong class="bold">class ProfileMembersReq(BaseModel): </strong>
    id: Any
    firstname: str
    lastname: str
    age: int
    height: float
    weight: float
    membership_type: str
    <strong class="bold">trainer_id: Any</strong>
    
    <strong class="bold">gclass: List</strong>
    
    <strong class="bold">@validator('gclass', pre=True, </strong>
         <strong class="bold">allow_reuse=True, check_fields=False)</strong>
    <strong class="bold">def gclass_set_to_list(cls, values):</strong>
        <strong class="bold">return [v.to_dict() for v in values]</strong>
    <strong class="bold">@validator('trainer_id', pre=True, </strong>
         <strong class="bold">allow_reuse=True, check_fields=False)</strong>
    <strong class="bold">def trainer_object_to_map(cls, values):</strong>
        <strong class="bold">return values.to_dict()</strong>
    
    <strong class="bold">class Config:</strong>
        <strong class="bold">orm_mode = True</strong></pre>
			<p>The <a id="_idIndexMarker365"/>presence of the <strong class="source-inline">gclass_set_to_list ()</strong> and <strong class="source-inline">trainer_object_to_map()</strong> converts in <strong class="source-inline">ProfileMembersReq</strong> enables data to be populated to the child objects in the <strong class="source-inline">gclass</strong> and <strong class="source-inline">trainer_id</strong> attributes, respectively. These additional features indicate why executing <strong class="source-inline">select()</strong> can already retrieve the <em class="italic">INNER JOIN</em> queries. </p>
			<p>To build <em class="italic">LEFT JOIN</em> query transactions, the ORM has a built-in directive called <strong class="source-inline">left_join()</strong>, which is used to extract the <strong class="source-inline">Query</strong> object bearing the <em class="italic">LEFT JOIN</em> raw objects through a Python generator. The following code shows another repository class that showcases the use of <strong class="source-inline">left_join()</strong>:</p>
			<pre class="source-code">
class MemberGymClassRepository:
    
    def join_member_class(self): 
      with db_session: 
        <strong class="bold">generator_args = (m for m in Profile_Members </strong>
              <strong class="bold">for g in m.gclass)</strong>
        <strong class="bold">joins = left_join(tuple_args)        </strong>
        result = [ProfileMembersReq.from_orm(m) 
              for m in joins ]
        return result</pre>
			<p>All the repository classes can be found in the <strong class="source-inline">/repository/pony/members.py</strong> script file.</p>
			<p>Now, what <a id="_idIndexMarker366"/>makes Pony faster is that it uses an <em class="italic">identity map</em>, which contains all the record objects that have been retrieved from every single query transaction. The ORM applies the <em class="italic">Identity Map</em> design pattern to apply its caching mechanism to make read and write executions fast. It only requires memory management and monitoring to avoid memory leak problems in complex and huge applications. </p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor140"/>Running the repository transactions</h2>
			<p>Since <strong class="source-inline">db_session</strong> is already <a id="_idIndexMarker367"/>managed internally, no additional requirements will be needed from Pony for the <strong class="source-inline">APIRouter</strong> script to run the repository transactions. The repository classes are directly accessed and instantiated in each of the APIs to access the CRUD transactions.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor141"/>Creating the tables</h2>
			<p>If the tables are <a id="_idIndexMarker368"/>non-existent yet, Pony can generate those tables through its entity classes. This DDL transaction is enabled when the <strong class="source-inline">create_tables</strong> parameter of the <strong class="source-inline">generate_mapping()</strong> method of <strong class="source-inline">db</strong> is set to <strong class="source-inline">True</strong>. </p>
			<p>For the most compact and simplest ORM in terms of syntax, we have <strong class="bold">Peewee</strong>.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor142"/>Building the repository using Peewee</h1>
			<p>Among the different ORMs, Peewee<a id="_idIndexMarker369"/> is the simplest and smallest in terms of ORM features and APIs. The framework is easy to understand and use; it is not comprehensive, but it has intuitive ORM syntax. Its strength is in building and executing query transactions. </p>
			<p>Peewee is not <a id="_idIndexMarker370"/>designed for asynchronous platforms, but it can work with them by using some async-related libraries that it supports. We need to install at least <em class="italic">Python 3.7</em> for Peewee to work with FastAPI, an asynchronous framework. To install Peewee, we need to execute the following command:</p>
			<p class="source-code">pip install peewee</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor143"/>Installing the database driver</h2>
			<p>The ORM<a id="_idIndexMarker371"/> needs <strong class="source-inline">psycopg2</strong> as the PostgreSQL database driver. We can install it using <strong class="source-inline">pip</strong>:</p>
			<p class="source-code">pip install psycopg2</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor144"/>Creating the database connection</h2>
			<p>For Peewee to<a id="_idIndexMarker372"/> work with FastAPI, we must build a multi-threading mechanism where Peewee can cater to more than one request transaction on the same thread, and per request can do more executions simultaneously using different local threads. This customized multi-threading component, which can be created using the <strong class="source-inline">ContextVar</strong> class, bridges Peewee to the FastAPI platform. But for Peewee to utilize these threads, we also need to customize its <strong class="source-inline">_ConnectionState</strong> with the newly created threading state, <strong class="source-inline">db_state</strong>. The following code shows how <strong class="source-inline">db_state</strong> and a custom <strong class="source-inline">_ConnectionState</strong> can be derived:</p>
			<pre class="source-code">
<strong class="bold">from peewee import _ConnectionState</strong>
<strong class="bold">from contextvars import ContextVar</strong>
db_state_default = {"closed": None, "conn": None, 
         "ctx": None, "transactions": None}
<strong class="bold">db_state = ContextVar("db_state", </strong>
          <strong class="bold">default=db_state_default.copy())</strong>
class PeeweeConnectionState(<strong class="bold">_ConnectionState</strong>):
    def __init__(self, **kwargs):
        super().__setattr__("_state", <strong class="bold">db_state</strong>)
        super().__init__(**kwargs)
    def __setattr__(self, name, value):
        self._state.get()[name] = value
    def __getattr__(self, name):
        return self._state.get()[name]</pre>
			<p>To <a id="_idIndexMarker373"/>apply the new <strong class="source-inline">db_state</strong> and <strong class="source-inline">_ConnectionState</strong> classes, cited in the preceding code as <strong class="source-inline">PeeweeConnectionState</strong>, we need to open the database connection through the <strong class="source-inline">Database</strong> class. Peewee has several variations of the <strong class="source-inline">Database</strong> class, depending on the type of database the application will choose to connect to. Since we will be using PostgreSQL, <strong class="source-inline">PostgresqlDatabase</strong> is the correct class to initialize with all the necessary database details. After establishing the connection, the <strong class="source-inline">db</strong> instance will have a <strong class="source-inline">_state</strong> attribute that will point to the <strong class="source-inline">PeeweeConnectionState</strong> instance. The following snippet shows how to connect to our <em class="italic">fitness gym</em> database’s <strong class="source-inline">fcms</strong> using the database<a id="_idIndexMarker374"/> credentials:</p>
			<pre class="source-code">
<strong class="bold">from peewee import PostgresqlDatabase</strong>
db = <strong class="bold">PostgresqlDatabase</strong>(
    'fcms',
    user='postgres',
    password='admin2255',
    host='localhost',
    port=5433, 
)
<strong class="bold">db._state = PeeweeConnectionState()</strong></pre>
			<p>The<a id="_idIndexMarker375"/> preceding code also emphasizes that the default state of the database connection must be replaced with a non-blocking one that can work with the FastAPI platform. This configuration can be found in the <strong class="source-inline">/db_config/peewee_connect.py</strong> script file. Let us now build Peewee's model layer.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor145"/>Creating the tables and the domain layer</h2>
			<p>Peewee<a id="_idIndexMarker376"/> prefers <em class="italic">auto-generating tables</em> based on its model classes, unlike other ORMs. Peewee recommends <em class="italic">reverse engineering</em>, where tables are created rather than only being mapped to existing tables. Letting the application generate the tables lessens the hassle of establishing relationships and <a id="_idIndexMarker377"/>primary keys. This ORM is unique because it has an "implied" approach to creating primary keys and foreign keys. The following script shows how Peewee model classes are defined:</p>
			<pre class="source-code">
<strong class="bold">from peewee import Model, ForeignKeyField, CharField, </strong>
<strong class="bold">   IntegerField, FloatField, DateField, TimeField</strong>
<strong class="bold">from db_config.peewee_connect import db</strong>
class Signup(Model):
<strong class="bold">    username = CharField(unique=False, index=False)</strong>
<strong class="bold">    password = CharField(unique=False, index=False)</strong>
    
<strong class="bold">    class Meta:</strong>
<strong class="bold">      database = db</strong>
<strong class="bold">      db_table = 'signup'</strong></pre>
			<p>We can’t see any primary keys in the model classes presented because the Peewee engine will create them during its schema auto-generation. The physical foreign key column and the model attribute will have the same name derived from its model name, with the <strong class="source-inline">modelname_id</strong> pattern <a id="_idIndexMarker378"/>in lowercase form. If we insist on adding the primary key for the<a id="_idIndexMarker379"/> model, a conflict will occur, making Peewee dysfunctional. We must let Peewee create the physical tables from the model classes to avoid this mishap.</p>
			<p>All model classes inherit properties from the <strong class="source-inline">Model</strong> directive of the ORM. It also has column directives such as <strong class="source-inline">IntegerField</strong>, <strong class="source-inline">FloatField</strong>, <strong class="source-inline">DateField</strong>, and <strong class="source-inline">TimeField</strong> for defining the column attributes of the model classes. Moreover, each domain class has a nested <strong class="source-inline">Meta</strong> class, which registers the references to <strong class="source-inline">database</strong> and <strong class="source-inline">db_table</strong>, which is mapped to the model class. Other properties that we can set here are <strong class="source-inline">primary_key</strong>, <strong class="source-inline">indexes</strong>, and <strong class="source-inline">constraints</strong>. </p>
			<p>The only problem in having this auto-generation is when creating table relationships. Linking the foreign key attributes of the child classes to the non-existent primary keys of the parent classes is difficult before auto-generation. For instance, the following <strong class="source-inline">Profile_Trainers</strong> model implies a <em class="italic">many-to-one</em> relationship with the <strong class="source-inline">Login</strong> class, which is only defined by the <strong class="source-inline">ForeignKeyField</strong> directive with the <strong class="source-inline">trainer</strong> backreference attribute and not by the <strong class="source-inline">login_id</strong> foreign key:</p>
			<pre class="source-code">
class Profile_Trainers(Model):
<strong class="bold">    login = ForeignKeyField(Login, </strong>
<strong class="bold">         backref="trainers", unique=True)</strong>
    … … … … … …
    shift = IntegerField(unique=False, index=False)
       
<strong class="bold">    class Meta:</strong>
<strong class="bold">      database = db</strong>
<strong class="bold">      db_table = 'profile_trainers'</strong></pre>
			<p>The <strong class="source-inline">login_id</strong> column that’s <a id="_idIndexMarker380"/>generated after auto-generation can be seen in the following screenshot:</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/Figure_5.2_B17975.jpg" alt="Figure 5.2 – The generated profile_trainers schema&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – The generated profile_trainers schema</p>
			<p>Foreign key<a id="_idIndexMarker381"/> attributes are declared using the <strong class="source-inline">ForeignKeyField</strong> directive, which accepts at least three crucial parameters:</p>
			<ul>
				<li>The parent model’s name </li>
				<li>The <strong class="source-inline">backref</strong> parameter, which references the child record (if in a <em class="italic">one-to-one</em> relationship) or a set of child objects (if in a <em class="italic">one-to-many</em> or <em class="italic">many-to-one</em> relationship)</li>
				<li>The <strong class="source-inline">unique</strong> parameter, which indicates a <em class="italic">one-to-one</em> relationship when set to <strong class="source-inline">True</strong> or <strong class="source-inline">False</strong> otherwise</li>
			</ul>
			<p>After defining all the models, including their relationships, we need to call the following methods from Peewee’s <strong class="source-inline">db</strong> instance for the table mapping to occur:</p>
			<ul>
				<li><strong class="source-inline">connect()</strong> to establish the connection </li>
				<li><strong class="source-inline">create_tables()</strong> to pursue the schema generation based on its list of model classes</li>
			</ul>
			<p>The following script <a id="_idIndexMarker382"/>shows a snapshot of the class<a id="_idIndexMarker383"/> definitions, including the call to the two <strong class="source-inline">db</strong> methods:</p>
			<pre class="source-code">
<strong class="bold">class Login(Model): </strong>
    username = CharField(unique=False, index=False)
    … … … … … …
    user_type = IntegerField(unique=False, index=False)
    
    <strong class="bold">class Meta:</strong>
      <strong class="bold">database = db</strong>
      <strong class="bold">db_table = 'login'</strong>
    
<strong class="bold">class Gym_Class(Model): </strong>
    <strong class="bold">member = ForeignKeyField(Profile_Members, </strong>
          <strong class="bold">backref="members")</strong>
    <strong class="bold">trainer = ForeignKeyField(Profile_Trainers, </strong>
          <strong class="bold">backref="trainers")</strong>
    approved = IntegerField(unique=False, index=False)
       
    class Meta:
      database = db
      db_table = 'gym_class'
<strong class="bold">db.connect()</strong>
<strong class="bold">db.create_tables([Signup, Login, Profile_Members</strong>, 
     <strong class="bold">Profile_Trainers, Attendance_Member, Gym_Class],</strong>
           <strong class="bold">safe=True)</strong></pre>
			<p>As we can see, we <a id="_idIndexMarker384"/>need to set the <strong class="source-inline">safe</strong> parameter<a id="_idIndexMarker385"/> of <strong class="source-inline">create_tables()</strong> to <strong class="source-inline">True</strong> so that Peewee will only perform schema auto-generation once during the initial server startup of the application. All the model classes for the Peewee ORM can be found in the <strong class="source-inline">/models/data/peewee_models.py</strong> script file. Now, let us implement the repository layer.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor146"/>Implementing the CRUD transactions</h2>
			<p>Creating the<a id="_idIndexMarker386"/> asynchronous connection and building the model layer for the application in the Peewee ORM is tricky, but implementing its repository layer is straightforward. All the method operations are entirely derived from its model classes. For instance, <strong class="source-inline">insert_login()</strong>, which is shown in the following snippet, shows how the <strong class="source-inline">create()</strong> static method of <strong class="source-inline">Login</strong> takes the login details for record insertion: </p>
			<pre class="source-code">
from typing import Dict, List, Any
<strong class="bold">from models.data.peewee_models import Login, </strong>
   <strong class="bold">Profile_Trainers, Gym_Class, Profile_Members</strong>
from datetime import date
class LoginRepository:
    
    def <strong class="bold">insert_login</strong>(self, id:int, user:str, passwd:str, 
          approved:date, type:int) -&gt; bool: 
        try:
            <strong class="bold">Login.create(id=id, username=user, </strong>
                <strong class="bold">password=passwd, date_approved=approved, </strong>
                <strong class="bold">user_type=type)</strong>
        except Exception as e: 
           return False 
        return True</pre>
			<p>This method <a id="_idIndexMarker387"/>can be re-implemented to perform bulk inserts, but Peewee has an alternative way to pursue multiple insertions through its <strong class="source-inline">insert_many()</strong> class method. Using <strong class="source-inline">insert_many()</strong> requires more accurate column details for mapping multiple schema values. It also needs an invocation of the <strong class="source-inline">execute()</strong> method to perform all the bulk insertions and close the operation afterward.</p>
			<p>Similarly, the <strong class="source-inline">update()</strong> class method requires the <strong class="source-inline">execute()</strong> method after filtering the record that needs updating using the <strong class="source-inline">id</strong> primary key. This is shown in the following code snippet:</p>
			<pre class="source-code">
    def <strong class="bold">update_login</strong>(self, id:int, 
              details:Dict[str, Any]) -&gt; bool: 
       try:
           <strong class="bold">query = Login.update(**details).</strong>
                  <strong class="bold">where(Login.id == id)</strong>
           <strong class="bold">query.execute()</strong>
       except: 
           return False 
       return True</pre>
			<p>When it<a id="_idIndexMarker388"/> comes to record deletion, <strong class="source-inline">delete_login()</strong> shows the easy approach – that is, by using <strong class="source-inline">delete_by_id()</strong>. But the ORM has another way, which is to retrieve the record object using the <strong class="source-inline">get()</strong> class method – for example, <strong class="source-inline">Login.get(Login.id == id)</strong> – and eventually delete the record through the <strong class="source-inline">delete_instance()</strong> instance method of the record object. The following <strong class="source-inline">delete_login()</strong> transaction shows how to utilize the <strong class="source-inline">delete_by_id()</strong> class method:</p>
			<pre class="source-code">
    def <strong class="bold">delete_login</strong>(self, id:int) -&gt; bool: 
        try:
           <strong class="bold">query = Login.delete_by_id(id)</strong>
        except: 
            return False 
        return True</pre>
			<p>The following scripts, which are for <strong class="source-inline">get_all_login()</strong> and <strong class="source-inline">get_login()</strong>, highlight how Peewee retrieves records from the database. Peewee uses its <strong class="source-inline">get()</strong> class method to retrieve a single record using the primary key; the same method was applied to its <em class="italic">UPDATE</em> transaction in the previous code snippet. Similarly, Peewee uses a class method to extract multiple records, but this time, it uses the <strong class="source-inline">select()</strong> method. The<a id="_idIndexMarker389"/> resulting object can’t be encoded by FastAPI unless it’s contained in the <strong class="source-inline">List</strong> collection, which serializes the rows of data into a list of JSON-able objects:  </p>
			<pre class="source-code">
    def <strong class="bold">get_all_login</strong>(self):
        return <strong class="bold">list(Login.select())</strong>
    
    def <strong class="bold">get_login</strong>(self, id:int): 
        return <strong class="bold">Login.get(Login.id == id)</strong></pre>
			<p>On the other hand, the following repository classes show how to create <em class="italic">JOIN</em> queries using its <strong class="source-inline">join()</strong> method: </p>
			<pre class="source-code">
<strong class="bold">from peewee import JOIN</strong>
class LoginTrainersRepository:
    
    def <strong class="bold">join_login_trainers</strong>(self): 
        return <strong class="bold">list</strong>(Profile_Trainers.
          <strong class="bold">select(Profile_Trainers, Login).join(Login)</strong>)
class MemberGymClassesRepository:
    def <strong class="bold">outer_join_member_gym</strong>(self): 
        return <strong class="bold">list</strong>(Profile_Members.
          <strong class="bold">select</strong>(Profile_Members,Gym_Class).<strong class="bold">join(Gym_Class</strong>, 
                    <strong class="bold">join_type=JOIN.LEFT_OUTER)</strong>)</pre>
			<p><strong class="source-inline">join_login_trainers()</strong> of <strong class="source-inline">LoginTrainersRepository</strong> builds the <em class="italic">INNER JOIN</em> query <a id="_idIndexMarker390"/>of the <strong class="source-inline">Profile_Trainers</strong> and <strong class="source-inline">Login</strong> objects. The leftmost model indicated in the parameter of the <strong class="source-inline">Profile_Trainers</strong> object’s <strong class="source-inline">select()</strong> directive is the parent model type, followed by its child model class in a <em class="italic">one-to-one</em> relationship. The <strong class="source-inline">select()</strong> directive emits the <strong class="source-inline">join()</strong> method with the model class type, which indicates the type of records that belong to the right-hand side of the query. The <em class="italic">ON </em>condition(s) and the foreign key constraints are optional but can be declared explicitly by adding the <strong class="source-inline">on</strong> and <strong class="source-inline">join_type</strong> attributes of the <strong class="source-inline">join()</strong> construct. An example of this query is <strong class="source-inline">outer_join_member_gym()</strong> of <strong class="source-inline">MemberGymClassesRepository</strong>, which implements a <em class="italic">LEFT OUTER JOIN</em> of <strong class="source-inline">Profile_Members</strong> and <strong class="source-inline">Gym_Class</strong> using the <strong class="source-inline">LEFT_OUTER</strong> option of the <strong class="source-inline">join_type</strong> attribute of <strong class="source-inline">join()</strong>.</p>
			<p>Joins in <a id="_idIndexMarker391"/>Peewee also need the <strong class="source-inline">list()</strong> collection to serialize the retrieved records. All the repository classes for Peewee can be found in the <strong class="source-inline">/repository/peewee/login.py</strong> script.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor147"/>Running the CRUD transaction</h2>
			<p>Since Peewee’s database connection<a id="_idIndexMarker392"/> is set at the model layer, no additional requirements are required for <strong class="source-inline">APIRouter</strong> or <strong class="source-inline">FastAPI</strong> to run the CRUD transactions. API services can easily access all the repository classes without calling methods or directives from the <strong class="source-inline">db</strong> instance.</p>
			<p>So far, we have experimented with popular ORMs to integrate a relational database into the FastAPI framework. If applying an ORM is not enough for a microservice architecture, we can utilize some design patterns that can further refine the CRUD performance, such<a id="_idIndexMarker393"/> as <strong class="bold">CQRS</strong>.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor148"/>Applying the CQRS design pattern</h1>
			<p>CQRS is a <a id="_idIndexMarker394"/>microservice design pattern responsible for segregating query transactions (<em class="italic">reads</em>) from the insert, update, and delete operations (<em class="italic">writes</em>). The separation of these two groups lessens the cohesion access to these transactions, which provides less traffic and faster performance, especially when the application becomes complex. Moreover, this design pattern creates a loose-coupling feature between the<a id="_idIndexMarker395"/> API services and the repository layer, which gives us an advantage if there are several turnovers and changes in the repository layers. </p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor149"/>Defining the handler interfaces</h2>
			<p>To pursue CQRS, we need to<a id="_idIndexMarker396"/> create the two interfaces that define the query and the command transactions. The following code shows the interfaces that will identify the <em class="italic">read</em> and <em class="italic">write</em> transactions for <strong class="source-inline">Profile_Trainers</strong>:</p>
			<pre class="source-code">
class <strong class="bold">IQueryHandler</strong>: 
    pass 
class <strong class="bold">ICommandHandler</strong>: 
    pass</pre>
			<p>Here, <strong class="source-inline">IQueryHandler</strong> and <strong class="source-inline">ICommandHandler</strong> are informal interfaces because Python does not <a id="_idIndexMarker397"/>have an actual definition of an interface.</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor150"/>Creating the command and query classes</h2>
			<p>Next, we need to<a id="_idIndexMarker398"/> implement the command and query classes. The command serves as an instruction to pursue the <em class="italic">write</em> transactions. It also carries the state of the result after they have been executed. On the other hand, the query instructs the <em class="italic">read</em> transaction to retrieve record(s) from the database and contain the result afterward. Both components are serializable classes with <em class="italic">getter/setter</em> attributes. The following code shows the script for <strong class="source-inline">ProfileTrainerCommand</strong>, which uses Python’s <strong class="source-inline">@property</strong> attribute to store the state of the <em class="italic">INSERT</em> execution:</p>
			<pre class="source-code">
from typing import Dict, Any
class <strong class="bold">ProfileTrainerCommand</strong>: 
    
    def __init__(self): 
        <strong class="bold">self._details:Dict[str,Any] = dict()</strong>
        
    <strong class="bold">@property</strong>
    def details(self):
        return self._details
    <strong class="bold">@details.setter</strong>
    def details(self, details):
        self._details = details</pre>
			<p>The <strong class="source-inline">details</strong> property will store all the column values of the trainer’s profile record that need to be persisted.</p>
			<p>The following script implements a sample <em class="italic">query</em> class:</p>
			<pre class="source-code">
class <strong class="bold">ProfileTrainerListQuery</strong>: 
    
    def __init__(self): 
        <strong class="bold">self._records:List[Profile_Trainers] = list()</strong>
        
    <strong class="bold">@property</strong>
    def records(self):
        return self._records
    <strong class="bold">@records.setter</strong>
    def records(self, records):
        self._records = records</pre>
			<p>The<a id="_idIndexMarker399"/> constructor of <strong class="source-inline">ProfileTrainerListQuery</strong> prepares a dictionary object that will contain all the retrieved records after the query transaction has been executed.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor151"/>Creating the command and query handlers</h2>
			<p>We will be using our<a id="_idIndexMarker400"/> previous interfaces to define the command and query handlers. Note that the command handler accesses and executes the repository to execute the <em class="italic">write</em> transactions, while the query handler processes the <em class="italic">read</em> transactions. These handlers serve as the façade between the API services and the repository layer. The following code shows the script for <strong class="source-inline">AddTrainerCommandHandler</strong>, which manages the <em class="italic">INSERT</em> transaction for the trainer’s profile:</p>
			<pre class="source-code">
<strong class="bold">from cqrs.handlers import ICommandHandler</strong>
<strong class="bold">from repository.gino.trainers import TrainerRepository</strong>
<strong class="bold">from cqrs.commands import ProfileTrainerCommand</strong>
class AddTrainerCommandHandler(<strong class="bold">ICommandHandler</strong>): 
    
    def __init__(self): 
        <strong class="bold">self.repo:TrainerRepository = TrainerRepository()</strong>
        
    async def handle(self, 
             <strong class="bold">command:ProfileTrainerCommand</strong>) -&gt; bool:
        <strong class="bold">result = await self.repo.</strong>
               <strong class="bold">insert_trainer(command.details)</strong>
        return result</pre>
			<p>The handler<a id="_idIndexMarker401"/> depends on <strong class="source-inline">ProfileTrainerCommand</strong> for the record values that are crucial to the asynchronous execution of its <strong class="source-inline">handle()</strong> method. </p>
			<p>The following script shows a sample implementation for a query handler:</p>
			<pre class="source-code">
<strong class="bold">class ListTrainerQueryHandler(IQueryHandler): </strong>
    def __init__(self): 
        <strong class="bold">self.repo:Trai<a id="_idTextAnchor152"/>nerRepository = TrainerRepository()</strong>
        <strong class="bold">self.query:ProfileTrainerListQuery = </strong>
             <strong class="bold">ProfileTrainerListQuery()</strong>
        
    async def handle(self) -&gt; <strong class="bold">ProfileTrainerListQuery</strong>:
        data = await self.repo.get_all_member();
        self.query.records = data
        return self.query</pre>
			<p>Query handlers <a id="_idIndexMarker402"/>return their <em class="italic">query</em> to the services and not the actual values. The <strong class="source-inline">handle()</strong> method of <strong class="source-inline">ListTrainerQueryHandler</strong> returns <strong class="source-inline">ProfileTrainerListQuery</strong>, which contains the list of records from the <em class="italic">read</em> transaction. This mechanism is one of the main objectives of applying CQRS to microservices. </p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor153"/>Accessing the handlers</h2>
			<p>CQRS, aside from <a id="_idIndexMarker403"/>managing the friction between the <em class="italic">read</em> and <em class="italic">write</em> executions, does not allow the API services to interact directly with the execution of CRUD transactions. Moreover, it streamlines and simplifies the access of the CRUD transactions by assigning only the handler that’s needed by a particular service.</p>
			<p>The following script shows how <strong class="source-inline">AddTrainerCommand</strong> is only directly associated with the <strong class="source-inline">add_trainer()</strong> service and how <strong class="source-inline">LisTrainerQueryHandler</strong> is only directly associated with the <strong class="source-inline">list_trainers()</strong> service:</p>
			<pre class="source-code">
<strong class="bold">from cqrs.commands import ProfileTrainerCommand</strong>
<strong class="bold">from cqrs.queries import ProfileTrainerListQuery</strong>
<strong class="bold">from cqrs.trainers.command.create_handlers</strong> import 
      <strong class="bold">AddTrainerCommandHandler</strong>
<strong class="bold">from cqrs.trainers.query.query_handlers import </strong>
      <strong class="bold">ListTrainerQueryHandler</strong>
router = APIRouter(dependencies=[Depends(get_db)])
<strong class="bold">@router.post("/trainer/add" )</strong>
async def add_trainer(req: ProfileTrainersReq): 
    <strong class="bold">handler = AddTrainerCommandHandler()</strong>
    <strong class="bold">mem_profile = dict()</strong>
    mem_profile["id"] = req.id
    … … … … … …
    mem_profile["shift"] = req.shift
    <strong class="bold">command = ProfileTrainerCommand()</strong>
    <strong class="bold">command.details = mem_profile</strong>
    <strong class="bold">result = await handler.handle(command)</strong>
    if result == True: 
        return req 
    else: 
        return JSONResponse(content={'message':'create 
          trainer profile problem encountered'}, 
            status_code=500)
<strong class="bold">@router.get("/trainer/list")</strong>
async def list_trainers(): 
    <strong class="bold">handler = ListTrainerQueryHandler()</strong>
    <strong class="bold">query:ProfileTrainerListQuery = await handler.handle() </strong>
    return <strong class="bold">query.records</strong></pre>
			<p>We can identify<a id="_idIndexMarker404"/> transactions that are accessed frequently in <strong class="source-inline">APIRouter</strong> through CQRS. It helps us find which transactions need performance tuning and focus, which can help us avoid performance issues when the amount of access increases. When it comes to enhancement and upgrades, the design pattern can help developers find what domain to prioritize because of the separation of aspects in the repository layer. Generally, it offers flexibility to the application when its business processes need to be revamped. All the CQRS-related scripts can be found in the <strong class="source-inline">/cqrs/</strong> project folder.</p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor154"/>Summary</h1>
			<p>Applying ORM always has advantages and disadvantages for any application. It can bloat the application with so many configurations and layers of components, and it can even slow down the application if not managed well. But ORM, in general, can help optimize query development by simplifying the constructs by using its APIs and eliminating unimportant repetitive SQL scripts. Overall, it can reduce the time and cost of software development compared to using <strong class="source-inline">cursor</strong> from <strong class="source-inline">psycopg2</strong>.</p>
			<p>In this chapter, four Python ORMs were used, studied, and experimented with to help FastAPI create its repository layer. First, there is <em class="italic">SQLAlchemy</em>, which provides a boilerplated approach to creating standard and asynchronous data persistency and query operations. Then, there is <em class="italic">GINO</em>, which uses the AsyncIO environment to implement asynchronous CRUD transactions with its handy syntax. Also, there is <em class="italic">Pony</em>, the most Pythonic among the ORMs presented because it uses hardcore Python code to build its repository transactions. Lastly, there is <em class="italic">Peewee</em>, known for its concise syntax but tricky composition for the asynchronous database connection and CRUD transactions. Each ORM has its strengths and weaknesses, but all provide a logical solution rather than applying brute-force and native SQL.</p>
			<p>If the ORM needs fine-tuning, we can add some degree of optimization by using data-related design patterns such as CQRS, which minimizes friction between the "read" and "write" CRUD transactions. </p>
			<p>This chapter has highlighted the flexibility of FastAPI when utilizing ORMs to establish a connection to a relational database such as PostgreSQL. But what if we use a NoSQL database such as MongoDB to store information? Will FastAPI perform with the same level of performance when performing CRUD to and from MongoDB? The next chapter will discuss various solutions for integrating FastAPI into MongoDB.</p>
		</div>
		<div>
			<div id="_idContainer034">
			</div>
		</div>
	</body></html>