<html><head></head><body>
		<div><h1 id="_idParaDest-107" class="chapter-number"><a id="_idTextAnchor107"/>5</h1>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor108"/>Connecting to a Relational Database</h1>
			<p>Our previous applications have only used Python collections to hold data records instead of persistent data stores. This setup causes data wiping whenever the <strong class="bold">Uvicorn</strong> server restarts because these collections only store the data in <em class="italic">volatile memory</em>, such as <strong class="bold">RAM</strong>. From this chapter onward, we will be applying data persistency to avoid data loss and provide a platform to manage our records, even when the server is in shutdown mode.</p>
			<p>This chapter will focus on different <strong class="bold">Object Relational Mappers</strong> (<strong class="bold">ORMs</strong>) that can efficiently manage clients’ data using objects and a relational database. Object-relational mapping is a technique where SQL statements for <strong class="bold">Creating</strong><em class="italic">, </em><strong class="bold">Reading</strong><em class="italic">, </em><strong class="bold">Updating</strong><em class="italic"> and </em><strong class="bold">Deleting</strong> (<strong class="bold">CRUD</strong>) are implemented and executed in an object-oriented programming approach. ORM requires all relationships or tables to be mapped to their corresponding entity or model classes to avoid tightly coupled connections to the database platform. And these model classes are the ones that are used to connect to the database.</p>
			<p>Aside from introducing ORM, this chapter will also discuss a design pattern called <strong class="bold">Command and Query Responsibility Segregation</strong> (<strong class="bold">CQRS</strong>), which can help resolve conflicts between read and write ORM transactions at the domain level. CQRS can help minimize the running time spent by read and write SQL transactions to improve the overall performance of the application over time compared to the data modeling approach.</p>
			<p>Overall, the main objective of this chapter is to prove that the FastAPI framework supports all popular ORMs to provide applications with backend database access, which it does by using popular relational database management systems, and apply optimization to CRUD transactions using the CQRS design pattern.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Preparing for database connectivity</li>
				<li>Creating synchronous CRUD transactions using <em class="italic">SQLAlchemy</em></li>
				<li>Implementing asynchronous CRUD transactions using <em class="italic">SQLAlchemy</em></li>
				<li>Using <em class="italic">GINO</em> for asynchronous CRUD transactions</li>
				<li>Using Pony ORM for the repository layer</li>
				<li>Building the repository using Peewee</li>
				<li>Applying the CQRS design pattern</li>
			</ul>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor109"/>Technical requirements</h1>
			<p>The application prototype that’s been created for this chapter is called <em class="italic">fitness club management system</em>; it caters to membership and gym fitness operations. This prototype has administration, membership, class management, and attendance modules that utilize a <code>ch05a</code> and <code>ch05b</code> projects.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor110"/>Preparing for database connectivity</h1>
			<p>Let<a id="_idIndexMarker270"/> us consider some application-related concerns before we start discussing database connectivity in FastAPI:</p>
			<ul>
				<li>First, all the application prototypes from this chapter onward will be using PostgreSQL as the sole relational DBMS. We can download its installer from <a href="https://www.enterprisedb.com/downloads/postgres-postgresql-downloads">https://www.enterprisedb.com/downloads/postgres-postgresql-downloads</a>. </li>
				<li>Second, the <em class="italic">fitness club management system</em> prototype has an existing database called <code>fcms</code> with six tables, namely <code>signup</code>, <code>login</code>, <code>profile_members</code>, <code>profile_trainers</code>, <code>attendance_member</code>, and <code>gym_class</code>. All these tables, along with their metadata and relationships, can be seen in the following diagram:</li>
			</ul>
			<div><div><img src="img/Figure_5.1_B17975.jpg" alt="Figure 5.1 – The fcms tables&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The fcms tables</p>
			<p>The <a id="_idIndexMarker271"/>project folder contains a script called <code>fcms_postgres.sql</code> that installs all these schemas.</p>
			<p>Now that we’ve installed the latest version of PostgreSQL and run the <code>fcms</code> script file, let us learn about SQLAlchemy, the most widely used ORM library in the Python arena.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">This chapter will compare and contrast the features of different Python ORMs. With this experimental setup, each project will have a multitude of database connectivity, which is against the convention of having a single piece of database connectivity per project. </p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor111"/>Creating CRUD transactions using SQLAlchemy</h1>
			<p><strong class="bold">SQLAlchemy</strong> is the<a id="_idIndexMarker272"/> most popular ORM library and can establish communication between any Python-based application and database platform. It is reliable because it is continuously updated and tested to be efficient, high-performing, and accurate with its SQL reads and writes. </p>
			<p>This ORM<a id="_idIndexMarker273"/> is a boilerplated interface that aims to create a database-agnostic data layer that can connect to any database engine. But compared to other ORMs, SQLAlchemy is <a id="_idIndexMarker274"/>DBA-friendly because it can generate optimized native SQL statements. When it comes to formulating its queries, it only requires Python functions and expressions to pursue the CRUD operations.</p>
			<p>Before <a id="_idIndexMarker275"/>we start using<a id="_idIndexMarker276"/> SQLAlchemy, check whether you have the module installed in your system by using the following command:</p>
			<pre>pip list </pre>
			<p>If SQLAlchemy is not in the list, install it using the <code>pip</code> command:</p>
			<pre>pip install SQLAlchemy</pre>
			<p>Currently, the version being used while developing the <em class="italic">fitness club management system</em> app is <em class="italic">1.4</em>.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor112"/>Installing the database driver</h2>
			<p>SQLAlchemy will not work without the<a id="_idIndexMarker277"/> required database driver. It is mandatory to install the <code>psycopg2</code> dialect since the database of choice is PostgreSQL:</p>
			<pre>pip install psycopg2</pre>
			<p>Psycopg2<a id="_idIndexMarker278"/> is a <em class="italic">DB API 2.0-c</em>ompliant PostgreSQL driver that does connection pooling and can work with multi-threaded FastAPI applications. This wrapper or dialect is also essential in building synchronous CRUD transactions for our application. Once it’s been installed, we can start looking at SQLAlchemy’s database configuration details. All the code related to SQLAlchemy can be found in the <code>ch05a</code> project.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor113"/>Setting up the database connection</h2>
			<p>To connect to any<a id="_idIndexMarker279"/> database, SQLAlchemy requires an engine that manages the connection pooling and the installed dialect. The <code>create_engine()</code> function from the <code>sqlalchemy</code> module is the source of the engine object. But to successfully derive it, <code>create_engine()</code> requires a database URL string to be configured. This URL string contains the <em class="italic">database name</em>, <em class="italic">the database API driver</em>, the <em class="italic">account credentials</em>, the <em class="italic">IP address</em> of the database server, and its <em class="italic">port</em>. The following script shows how to create the engine that will be used in our <em class="italic">fitness club management system</em> prototype:</p>
			<pre class="source-code">
from sqlalchemy import <strong class="bold">create_engine</strong>
<strong class="bold">DB_URL</strong> =   
   "<strong class="bold">postgresql</strong>://<strong class="bold">postgres</strong>:<strong class="bold">admin2255</strong>@<strong class="bold">localhost</strong>:<strong class="bold">5433</strong>/<strong class="bold">fcms</strong>"
<strong class="bold">engine</strong> = <strong class="bold">create_engine(DB_URL)</strong></pre>
			<p><code>engine</code> is a global object and must be created only once in the entire application. Its first database connection happens right after the first SQL transaction of the application because it follows the <em class="italic">lazy initialization</em> design <a id="_idIndexMarker280"/>pattern.</p>
			<p>Moreover, <code>engine</code> in the previous script is essential for creating the ORM session that will be used by SQLAlchemy to execute CRUD transactions.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor114"/>Initializing the session factory</h2>
			<p>All <a id="_idIndexMarker281"/>CRUD transactions in SQLAlchemy are driven by <em class="italic">sessions</em>. Each session manages a group of database "writes" and "reads," and it checks whether to execute them or not. For instance, it maintains a group of inserted, updated, and deleted objects, checks whether the changes are valid, and then coordinates with the SQLAlchemy core to pursue the changes to the database if all transactions have been validated. It follows the behavior of the <em class="italic">Unit of Work</em> design pattern. SQLAlchemy relies on sessions for data consistency and integrity.</p>
			<p>But before we create a session, the data layer needs a session factory that is bound to the derived engine. The ORM has a <code>sessionmaker()</code>directive from the <code>sqlalchemy.orm</code> module, which requires the <code>engine</code> object. The following script shows how to invoke <code>sessionmaker()</code>:</p>
			<pre class="source-code">
from sqlalchemy.orm import <strong class="bold">sessionmaker</strong>
<strong class="bold">engine</strong> = create_engine(DB_URL)
<strong class="bold">SessionFactory</strong> = <strong class="bold">sessionmaker(autocommit=False,</strong> 
                     <strong class="bold">autoflush=False, bind=engine)</strong></pre>
			<p>Apart from engine binding, we also need to set the session’s <code>autocommit</code> property to <code>False</code> to impose <code>commit()</code> and <code>rollback()</code> transactions. The application should be the one to flush all changes to the database, so we need to set its <code>autoflush</code> feature to <code>False</code> as well. </p>
			<p>Applications<a id="_idIndexMarker282"/> can create more than one session through the <code>SessionFactory()</code> call, but having one session per <code>APIRouter</code> is recommended.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor115"/>Defining the Base class</h2>
			<p>Next, we <a id="_idIndexMarker283"/>need to set up the <code>Base</code> class, which is crucial in mapping model classes to database tables. Although SQLAlchemy can create tables at runtime, we opted to utilize an existing schema definition for our prototype. Now, this <code>Base</code> class must be subclassed by the model classes so that the mapping to the tables will happen once the server starts. The following script shows how straightforward it is to set up this component:</p>
			<pre class="source-code">
from sqlalchemy.ext.declarative import <strong class="bold">declarative_base</strong>
<strong class="bold">Base</strong> = <strong class="bold">declarative_base()</strong></pre>
			<p>Invoking the <code>declarative_base()</code> function is the easiest way of creating the <code>Base</code> class rather than creating <code>registry()</code> to call <code>generate_base()</code>, which can also provide us with the <code>Base</code> class.</p>
			<p>Note that all these configurations are part of the <code>/db_config/sqlalchemy_connect.py</code> module of the prototype. They are bundled into one module since they are crucial in building the SQLAlchemy repository. But before<a id="_idIndexMarker284"/> we implement the CRUD transactions, we need to create the model layer using the <code>Base</code> class.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor116"/>Building the model layer</h2>
			<p>The model <a id="_idIndexMarker285"/>classes of SQLAlchemy have all been placed in the <code>/models/data/sqlalchemy_models.py</code> file of the fitness club project folder. If <code>BaseModel</code> is important to API request models, the <code>Base</code> class is essential in building the data layer. It is imported from the configuration file to define SQLAlchemy entities or models. The following code is from the module script, which shows how we can create model class definitions in SQLAlchemy ORM:</p>
			<pre class="source-code">
<strong class="bold">from sqlalchemy import Time, Boolean, Column, Integer, </strong>
    <strong class="bold">String, Float, Date, ForeignKey</strong>
<strong class="bold">from sqlalchemy.orm import relationship</strong>
<strong class="bold">from db_config.sqlalchemy_connect import Base</strong>
class Signup(<strong class="bold">Base</strong>):
    <strong class="bold">__tablename__ = "signup"</strong>
    id = <strong class="bold">Column</strong>(<strong class="bold">Integer</strong>, <strong class="bold">primary_key=True</strong>, <strong class="bold">index=True</strong>)
    username = <strong class="bold">Column</strong>(<strong class="bold">'username'</strong>, <strong class="bold">String</strong>, unique=False, 
                       index=False)
    password = <strong class="bold">Column</strong>(<strong class="bold">'password' </strong>,<strong class="bold">String</strong>, unique=False, 
                       index=False)</pre>
			<p>The <code>Signup</code> class is a sample of a SQLAlchemy model because it inherits the <code>Base</code> class’s properties. It is a mapped class because all its attributes are reflections of the column metadata of its physical table schema counterpart. The model has a <code>primary_key</code> property set to <code>True</code> because SQLAlchemy recommends each table schema have at least one primary key. The rest of the <code>Column</code> objects are mapped to column metadata that’s non-primary but can be <em class="italic">unique</em> or <em class="italic">indexed</em>. Each model class inherits the <code>__tablename__</code> property, which sets the name of the mapped table.</p>
			<p>Most importantly, we need to ensure that the data type of the class attribute matches the column type of its column counterpart in the table schema. The column attribute must have the same name as the column counterpart. Otherwise, we need to specify the actual<a id="_idIndexMarker286"/> column name in the first argument of the <code>Column</code> class, as shown in the <code>username</code> and <code>password</code> columns of <code>Signup</code>. But most of the time, we must always make sure they are the same to avoid confusion.     </p>
			<h3>Mapping table relationships</h3>
			<p>SQLAlchemy<a id="_idIndexMarker287"/> strongly supports different types of parent-child or associative table relationships. Model classes involved in the relationship require the <code>relationship()</code> directive from the <code>sqlalchemy.orm</code> module to be utilized to establish one-to-many or one-to-one relationships among model classes. This directive creates a reference from the parent to the child class using some foreign key indicated in the table schema definition. </p>
			<p>A child model class uses the <code>ForeignKey</code> construct in its foreign key column object to link the model class to its parent’s reference key column object. This directive indicates that the values in this column should be within the values stored in the parent table’s reference column. The <code>ForeignKey</code> directive applies to both the primary and non-primary <code>Column</code> objects. The following model class defines a sample column relationship in our database schema:</p>
			<pre class="source-code">
class Login(<strong class="bold">Base</strong>): 
    <strong class="bold">__tablename__ = "login"</strong>
    
    id = <strong class="bold">Column</strong>(<strong class="bold">Integer</strong>, primary_key=True, index=True)
    username = <strong class="bold">Column</strong>(<strong class="bold">String</strong>, unique=False, index=False)
    password = <strong class="bold">Column</strong>(<strong class="bold">String</strong>, unique=False, index=False)
    date_approved = <strong class="bold">Column</strong>(<strong class="bold">Date</strong>, unique=False, index=False)
    user_type = <strong class="bold">Column</strong>(<strong class="bold">Integer</strong>, unique=False, index=False)
    
    <strong class="bold">trainers = relationship('Profile_Trainers', </strong>
         <strong class="bold">back_populates="login", uselist=False)</strong>
    <strong class="bold">members = relationship('Profile_Members', </strong>
         <strong class="bold">back_populates="login", uselist=False)</strong></pre>
			<p>This <code>Login</code> model is <a id="_idIndexMarker288"/>linked to two children, <code>Profile_Trainers</code> and <code>Profile_Members</code>, based on its configuration. Both child models have the <code>ForeignKey</code> directive in their <code>id</code> column objects, as shown in the following model definitions:</p>
			<pre class="source-code">
class Profile_Trainers(<strong class="bold">Base</strong>):
    <strong class="bold">__tablename__ = "profile_trainers"</strong>
    id = <strong class="bold">Column</strong>(<strong class="bold">Integer</strong>, <strong class="bold">ForeignKey('login.id')</strong>, 
         primary_key=True, index=True, )
    firstname = <strong class="bold">Column</strong>(<strong class="bold">String</strong>, unique=False, index=False)
    … … … … …
    … … … … …
    <strong class="bold">login = relationship('Login', </strong>
         <strong class="bold">back_populates="trainers")</strong>
    <strong class="bold">gclass = relationship('Gym_Class', </strong>
         <strong class="bold">back_populates="trainers")</strong>
    
class Profile_Members(<strong class="bold">Base</strong>): 
    <strong class="bold">__tablename__ = "profile_members"</strong>
    id = <strong class="bold">Column</strong>(<strong class="bold">Integer</strong>, <strong class="bold">ForeignKey('login.id')</strong>, 
         primary_key=True, index=True)
    firstname = <strong class="bold">Column</strong>(<strong class="bold">String</strong>, unique=False, index=False)
    lastname = <strong class="bold">Column</strong>(<strong class="bold">String</strong>, unique=False, index=False)
    age = <strong class="bold">Column</strong>(<strong class="bold">Integer</strong>, unique=False, index=False)
    … … … … … …
    … … … … … …
    trainer_id = <strong class="bold">Column</strong>(<strong class="bold">Integer</strong>, 
        <strong class="bold">ForeignKey('profile_trainers.id')</strong>, unique=False, 
        index=False)
    <strong class="bold">login = relationship('Login', back_populates="members")</strong>
    <strong class="bold">attendance = relationship('Attendance_Member', </strong>
          <strong class="bold">back_populates="members")</strong>
    <strong class="bold">gclass = relationship('Gym_Class', </strong>
          <strong class="bold">back_populates="members") </strong></pre>
			<p>The <code>relationship()</code> directive <a id="_idIndexMarker289"/>is the sole directive for creating table relationships. We need to specify some of its parameters, such as the <em class="italic">name of the child model class</em> and the <em class="italic">backreference specification</em>. The <code>back_populates</code> parameter refers to the complementary attribute names of the related model classes. This indicates the rows that need to be fetched using some relationship loading technique during join query transactions. The <code>backref</code> parameter can also be used instead of <code>back_populates</code>.</p>
			<p>On the other hand, <code>relationship()</code> can return either a <code>List</code> or scalar object, depending on the relationship type. If it is a <em class="italic">one-to-one type</em>, the parent class should set the <code>useList</code> parameter to <code>False</code> to indicate that it will return a scalar value. Otherwise, it will select a list of records from the child table. The previous <code>Login</code> class definition shows that <code>Profile_Trainers</code> and <code>Profile_Members</code> hold a one-to-one relationship with <code>Login</code> because <code>Login</code> sets its <code>uselist</code> to <code>False</code>. On the other hand, the model relationship between <code>Profile_Members</code> and <code>Attendance_Member</code> is a <em class="italic">one-to-many</em> type because <code>uselist</code> is set to <code>True</code> by default, as shown by the following definitions:</p>
			<pre class="source-code">
class Attendance_Member(<strong class="bold">Base</strong>):
    __tablename__ = "attendance_member"
    id = Column(Integer, primary_key=True, index=True)
    <strong class="bold">member_id = Column(Integer, </strong>
        <strong class="bold">ForeignKey('profile_members.id'), unique=False, </strong>
        <strong class="bold">index=False)</strong>
    timeout = Column(Time, unique=False, index=False)
    timein = Column(Time, unique=False, index=False)
    date_log = Column(Date, unique=False, index=False)
    
    <strong class="bold">members = relationship('Profile_Members', </strong>
             <strong class="bold">back_populates="attendance")</strong></pre>
			<p>While setting the <a id="_idIndexMarker290"/>model relationships, we must also consider the <em class="italic">relationship loading type</em> that these related model classes will be using during the join query transactions. We specify this detail in the <code>lazy</code> parameter of <code>relationship()</code>, which is assigned to <code>select</code> by default. This is because SQLAlchemy uses a lazy loading technique by default in retrieving join queries. However, you can modify it to use <code>joined</code> (<code>lazy="joined"</code>), <code>subquery</code> (<code>lazy="subquery"</code>), <code>select in</code> (<code>lazy="selectin"</code>), <code>raise</code> (<code>lazy="raise"</code>), or <code>no</code> (<code>lazy="no"</code>) loading. Among the options, the <code>joined</code> approach is better for <em class="italic">INNER JOIN</em> transactions.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor117"/>Implementing the repository layer</h2>
			<p>In the SQLAlchemy ORM, creating the <a id="_idIndexMarker291"/>repository layer requires the <em class="italic">model classes</em> and a <code>Session</code> object. The <code>Session</code> object, derived from the <code>SessionFactory()</code>directive, establishes all the communication to the database and manages all the model objects before the <code>commit()</code> or <code>rollback()</code> transaction. When it comes to the queries, the <code>Session</code> entity stores the result set of records in a data structure called an <em class="italic">identity map</em>, which maintains the unique identity of each data record using the primary keys. </p>
			<p>All repository <a id="_idIndexMarker292"/>transactions are <em class="italic">stateless</em>, which means the session is automatically closed after loading the model objects for insert, update, and delete transactions when the database issues a <code>commit()</code> or <code>rollback()</code> operation. We import the <code>Session</code> class from the <code>sqlalchemy.orm</code> module.</p>
			<h3>Building the CRUD transactions</h3>
			<p>Now, we can <a id="_idIndexMarker293"/>start building the repository<a id="_idIndexMarker294"/> layer of the fitness club application since we have already satisfied the requirements to build the CRUD transactions. The following <code>SignupRepository</code> class is the blueprint that will show us how to <em class="italic">insert</em>, <em class="italic">update</em>, <em class="italic">delete</em>, and <em class="italic">retrieve</em> record(s) to/from the <code>signup</code> table:</p>
			<pre class="source-code">
from typing import Dict, List, Any
<strong class="bold">from sqlalchemy.orm import Session</strong>
<strong class="bold">from models.data.sqlalchemy_models import Signup</strong>
<strong class="bold">from sqlalchemy import desc</strong>
<strong class="bold">class SignupRepository: </strong>
    
    def __init__(self, <strong class="bold">sess:Session</strong>):
        self.<strong class="bold">sess:Session</strong> = sess
    
    def <strong class="bold">insert_signup</strong>(self, signup: Signup) -&gt; bool: 
        try:
            <strong class="bold">self.sess.add(signup)</strong>
            <strong class="bold">self.sess.commit()</strong>
        except: 
            return False 
        return True</pre>
			<p>So far, <code>insert_signup()</code> is the most accurate way of persisting records to the <code>signup</code> table using SQLAlchemy. <code>Session</code> has an <code>add()</code> method, which we can invoke to add <a id="_idIndexMarker295"/>all record objects to the <a id="_idIndexMarker296"/>table, and a <code>commit()</code> transaction to finally flush all the new records into the database. The <code>flush()</code> method of <code>Session</code> is sometimes used instead of <code>commit()</code> to pursue the insertion and close <code>Session</code>, but most developers often use the latter. Note that the <code>signup</code> table contains all the gym members and trainers who want to gain access to the system. Now, the next script implements update record transaction:</p>
			<pre class="source-code">
    def <strong class="bold">update_signup</strong>(self, id:int, 
           details:Dict[str, An<a id="_idTextAnchor118"/>y]) -&gt; bool: 
       try:
             <strong class="bold">self.sess.query(Signup).</strong>
                 <strong class="bold">filter(Signup.id == id).update(details)     </strong>
             <strong class="bold">self.sess.commit() </strong>
       except: 
           return False 
       return True</pre>
			<p>The <code>update_signup()</code> provides a short, straightforward, and robust solution to updating a record in SQLAlchemy. Another possible solution is to query the record through <code>self.sess.query(Signup).filter(Signup.id == id).first()</code>, replace the attribute values of the retrieved object with the new values from the <code>details</code> dictionary, and then invoke <code>commit()</code>. This way is acceptable, but it takes three steps rather than calling the <code>update()</code> method after <code>filter()</code>, which only takes one. Next script is an implementation of a delete record transaction:</p>
			<pre class="source-code">
    def <strong class="bold">delete_signup</strong>(self, id:int) -&gt; bool: 
        try:
           <strong class="bold">signup = self.sess.query(Signup).</strong>
                  <strong class="bold">filter(Signup.id == id).delete()</strong>
           <strong class="bold">self.sess.commit()</strong>
        except: 
            return False 
        return True</pre>
			<p>On the other hand, <code>delete_signup()</code> follows the strategy of <code>update_signup()</code>, which uses <code>filter()</code> first before <code>delete()</code> is called. Another way of implementing this is to retrieve the object using <code>sess.query()</code> again and pass the retrieved object as an argument<a id="_idIndexMarker297"/> to the <code>Session</code> object’s <code>delete(obj)</code>, which is a different function. Always<a id="_idIndexMarker298"/> remember to invoke <code>commit()</code> to flush the changes. Now, the following script shows how to implement the query transactions:</p>
			<pre class="source-code">
    def <strong class="bold">get_all_signup</strong>(self):
        return <strong class="bold">self.sess.query(Signup).all()</strong> 
    def <strong class="bold">get_all_signup_where</strong>(self, username:str):
        return self.sess.
             query(Signup.username, Signup.password).
             <strong class="bold">filter(Signup.username == username)</strong>.all() 
    
    def <strong class="bold">get_all_signup_sorted_desc</strong>(self):
        return self.sess.
            query(Signup.username,Signup.password).
            <strong class="bold">order_by(desc(Signup.username))</strong>.all()
    
    def <strong class="bold">get_signup</strong>(self, id:int): 
        return <strong class="bold">self.sess.query(Signup).</strong>
             <strong class="bold">filter(Signup.id == id).one_or_none()</strong></pre>
			<p>Moreover, <code>SignupRepository</code> also highlights multiple and single records being retrieved in many forms. The <code>Session</code> object has a <code>query()</code> method, which requires <em class="italic">model class(es)</em> or <em class="italic">model column names</em> as argument(s). The function argument performs the record retrieval with column projection. For instance, the given <code>get_all_signup()</code> selects all signup records with all the columns projected in the result. If we want to include only <code>username</code> and <code>password</code>, we can write our query as <code>sess.query(Signup.username, Signup.password)</code>, just like in the given <code>get_all_signup_where()</code>. This <code>query()</code> method also shows how to manage constraints using the <code>filter()</code> method with the appropriate conditional expressions. Filtering always comes after column projection. </p>
			<p>On the other<a id="_idIndexMarker299"/> hand, the <code>Session</code> object<a id="_idIndexMarker300"/> has an <code>order_by()</code> method that takes column names as parameters. It is performed last in the series of query transactions, before the result is extracted. The given sample, <code>get_all_signup_sorted_desc()</code>, sorts all <code>Signup</code> objects in descending order by <code>username</code>.</p>
			<p>The last portion of the <code>query()</code> builder returns the result of the transactions, whether it is a list of records or a single record. The <code>all()</code> function ends the query statement that returns multiple records, while <code>first()</code>, <code>scalar()</code>, <code>one()</code>, or <code>one_or_none()</code> can be applied if the result is a single row. In <code>get_signup()</code>, <code>one_or_none()</code> is utilized to raise an exception when no record is returned. For SQLAlchemy’s query transactions, all these functions can close the <code>Session</code> object. The repository classes for SQLAlchemy are in the <code>ch05a</code> folder’s <code>/repository/sqlalchemy/signup.py</code> module script file.</p>
			<h3>Creating the JOIN queries</h3>
			<p>For all the <a id="_idIndexMarker301"/>ORMs supported by FastAPI, only SQLAlchemy implements join queries pragmatically and functionally, just like how we implemented the previous CRUD transactions. We used almost all of the methods we need to create joins previously except for <code>join()</code>.  </p>
			<p>Let us look at <code>LoginMemberRepository</code>, which shows how we can create a join query statement in SQLAlchemy with model classes in <em class="italic">one-to-one relationships</em>:</p>
			<pre class="source-code">
<strong class="bold">class LoginMemberRepository(): </strong>
    def __init__(self, sess:Session):
        self.sess:Session = sess
    
    def <strong class="bold">join_login_members</strong>(self):
        return self.sess.
           <strong class="bold">query(Login, Profile_Members)</strong>.
             <strong class="bold">filter(Login.id == Profile_Members.id).all()</strong></pre>
			<p><code>join_login_members()</code> shows the conventional way of creating <em class="italic">JOIN</em> queries. This solution requires passing the parent and child classes as query parameters and overriding the <code>ON</code> condition through the <code>filter()</code> method. The parent model class must come first in the column projection before the child class in the <code>query()</code> builder to extract the preferred result.</p>
			<p>Another way is to use the <code>select_from()</code> function instead of <code>query()</code> to distinguish the parent class from the child. This approach is more appropriate for a <em class="italic">one-to-one</em> relationship.</p>
			<p>On the other hand, <code>MemberAttendanceRepository</code> showcases the <em class="italic">one-to-many</em> relationship between the <code>Profile_Members</code> and <code>Attendance_Member</code> model classes:</p>
			<pre class="source-code">
<strong class="bold">class MemberAttendanceRepository(): </strong>
    def __init__(self, sess:Session):
        self.sess:Session = sess
    
    def <strong class="bold">join_member_attendance</strong>(self):
        return self.sess.
           <strong class="bold">query(Profile_Members, Attendance_Member).</strong>
           <strong class="bold">join(Attendance_Member).all()</strong>
    def <strong class="bold">outer_join_member</strong>(self):
         return self.sess.
            <strong class="bold">query(Profile_Members, Attendance_Member).</strong>
            <strong class="bold">outerjoin(Attendance_Member).all()</strong></pre>
			<p><code>join_member_attendance()</code> shows the use of the <code>join()</code> method in building the <em class="italic">INNER JOIN</em> queries between <code>Profile_Members</code> and <code>Attendance_Member</code>. <code>filter()</code> is not needed anymore to build the <code>ON</code> condition because <code>join()</code> automatically detects and recognizes the <code>relationship()</code> parameters and the <code>ForeignKey</code> constructs defined at the beginning. But if there are other additional constraints, <code>filter()</code> can always be invoked, but only after the <code>join()</code> method.</p>
			<p>The <code>outer_join_member()</code> repository method implements an <em class="italic">OUTER JOIN</em> query from the one-to-many relationship. The <code>outerjoin()</code> method will extract all <code>Profile_Members</code> records <a id="_idIndexMarker302"/>mapped to their corresponding <code>Attendance_Member</code> or return <code>null</code> if there are none. </p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor119"/>Running the transactions</h2>
			<p>Now, let us<a id="_idIndexMarker303"/> apply these repository transactions to the administration-related API services of our application. Instead of using collections to store all the records, we will be utilizing the ORM’s transactions to manage the data using PostgreSQL. First, we need to import the essential components required by the repository, such as <code>SessionFactory</code>, the repository class, and the <code>Signup</code> model class. APIs such as <code>Session</code> and other <code>typing</code> APIs can only be part of the implementation for type hints. </p>
			<p>The following script shows a portion of the administrator’s API services highlighting the insertion and retrieval services for new access registration:</p>
			<pre class="source-code">
from fastapi import APIRouter, Depends
from fastapi.responses import JSONResponse
<strong class="bold">from sqlalchemy.orm import Session</strong>
<strong class="bold">from db_config.sqlalchemy_connect import SessionFactory</strong>
from repository.sqlalchemy.signup import <strong class="bold">SignupRepository</strong>,
   LoginMemberRepository, MemberAttendanceRepository
from typing import List
router = APIRouter()
<strong class="bold">def sess_db():</strong>
    <strong class="bold">db = SessionFactory()</strong>
    try:
        <strong class="bold">yield db</strong>
    finally:
        <strong class="bold">db.close()</strong></pre>
			<p>First, we <a id="_idIndexMarker304"/>need to create the <code>Session</code> instance through <code>SessionFactory()</code>, which we derived from <code>sessionmaker()</code>, since the repository layer is dependent on the session. In our application, a <code>sess_db()</code> custom generator is used to open and destroy the <code>Session</code> instance. It is injected into the API service methods to tell the <code>Session</code> instance to proceed with instantiating <code>SignupRepository</code>: </p>
			<pre class="source-code">
<strong class="bold">@router.post("/signup/add")</strong>
def add_signup(req: SignupReq, 
          <strong class="bold">sess:Session = Depends(sess_db)</strong>):
    <strong class="bold">repo:SignupRepository = SignupRepository(sess)</strong>
    <strong class="bold">signup = Signup(password= req.password, </strong>
                 <strong class="bold">username=req.username,id=req.id)</strong>
    <strong class="bold">result = repo.insert_signup(signup)</strong>
    if result == True:
        return signup
    else: 
        return JSONResponse(content={'message':'create 
                  signup problem encountered'}, 
                status_code=500)</pre>
			<p>Once<a id="_idIndexMarker305"/> instantiated, the repository can provide record insertion through <code>insert_signup()</code>, which inserts the <code>Signup</code> record. Another of its methods is <code>get_all_signup()</code>, which retrieves all login accounts for approval:</p>
			<pre class="source-code">
<strong class="bold">@router.get("/signup/list", response_model=List[SignupReq])</strong>
def list_signup(<strong class="bold">sess:Session = Depends(sess_db)</strong>):
    <strong class="bold">repo:SignupRepository = SignupRepository(sess)</strong>
    result = repo.get_all_signup()
    return result
<strong class="bold">@router.get("/signup/list/{id}", response_model=SignupReq</strong>)
def get_signup(id:int, <strong class="bold">sess:Session = Depends(create_db)</strong>): 
    <strong class="bold">repo:SignupRepository = SignupRepository(sess)</strong>
    result = repo.get_signup(id)
    return result</pre>
			<p>Both the <code>get_signup()</code> and <code>list_signup()</code> services have a <code>request_model</code> of the <code>SignupReq</code> type, which determines the expected output of the APIs. But as you may have noticed, <code>get_signup()</code> returns the <code>Signup</code> object, while <code>list_signup()</code> returns a list of <code>Signup</code> records. How is that possible? If <code>request_model</code> is used to capture the query result of the SQLAlchemy query transactions, the <code>BaseModel</code> class or request model must include a nested <code>Config</code> class with its <code>orm_mode</code> set to <code>True</code>. This built-in configuration enables type mapping and validation of <code>BaseModel</code> for the SQLAlchemy model types used by the repository, before all the record objects are filtered and stored in the request models. More information about the <code>response_model</code> parameter can be found in <a href="B17975_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Setting Up FastAPI for Starters</em>.</p>
			<p><code>SignupReq</code>, which is<a id="_idIndexMarker306"/> used by the query services of our application, is defined as follows:</p>
			<pre class="source-code">
from pydantic import BaseModel
<strong class="bold">class SignupReq(BaseModel): </strong>
    id : int 
    username: str 
    password: str 
        
    <strong class="bold">class Config:</strong>
        <strong class="bold">orm_mode = True</strong></pre>
			<p>The script shows how <code>orm_mode</code> is enabled using the equals sign (<code>=</code>) rather than the typical colon symbol (<code>:</code>), which means <code>orm_mode</code> is a configuration detail and not part of the class attribute.</p>
			<p>Overall, using <a id="_idIndexMarker307"/>SQLAlchemy for the repository layer is systematic and procedural. It is easy to map and synchronize the model classes with the schema definitions. Establishing relationships through the model classes is handy and predictable. Although there are lots of APIs and directives involved, it is still the most widely supported library for domain modeling and repository construction. Its documentation (<a href="https://docs.sqlalchemy.org/en/14/">https://docs.sqlalchemy.org/en/14/</a>) is complete and informative enough to guide developers regarding the different API classes and methods.</p>
			<p>Another feature of SQLAlchemy that’s loved by many is its capability to generate table schemas at the application level.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor120"/>Creating tables </h2>
			<p>Usually, SQLAlchemy <a id="_idIndexMarker308"/>works with the table schemas that have already been generated by the database administrator. In this project, the ORM setup started with designing the domain model classes before mapping them to the actual tables. But SQLAlchemy can auto-create table schemas at runtime for the FastAPI platform, which may be helpful during the testing or prototyping stage of the project. </p>
			<p>The <code>sqlalchemy</code> module has a <code>Table()</code> directive that can create a table object with the essential column metadata using the <code>Column()</code> method, which we used in the mapping. The following is a sample script that shows how the ORM creates the signup table at the application level:</p>
			<pre class="source-code">
<strong class="bold">from sqlalchemy import Table, Column, Integer, String, </strong>
               <strong class="bold">MetaData</strong>
from db_config.sqlalchemy_connect import <strong class="bold">engine</strong>
<strong class="bold">meta = MetaData()</strong>
signup = <strong class="bold">Table</strong>(
   '<strong class="bold">signup</strong>', <strong class="bold">meta</strong>, 
   Column('id', Integer, primary_key = True, 
          nullable=False), 
   Column('username', String, unique = False, 
          nullable = False), 
   Column('password', String, unique = False, 
          nullable = False), 
)
<strong class="bold">meta.create_all(bind=engine)</strong></pre>
			<p>Part of the schema definition is <code>MetaData()</code>, a registry that contains the necessary methods for generating the tables. When all the schema definitions are signed off, the <code>create_all()</code> method of the <code>MetaData()</code> instance is executed with the engine to create the tables. This process may sound straightforward, but we seldom pursue this DDL feature of <a id="_idIndexMarker309"/>SQLAlchemy in projects at the production stage.</p>
			<p>Now, let us explore how SQLAlchemy can be used to create asynchronous CRUD transactions for asynchronous API services. </p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor121"/>Implementing async CRUD transactions using SQLAlchemy</h1>
			<p>From <a id="_idIndexMarker310"/>version 1.4, SQLAlchemy <a id="_idIndexMarker311"/>supports <code>Session</code> object. Our <code>ch05b</code> project showcases the asynchronous side of SQLAlchemy. </p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor122"/>Installing the asyncio-compliant database drivers</h2>
			<p>Before we begin<a id="_idIndexMarker312"/> setting up the database configuration, we need to install the following asyncio-compliant drivers: <code>aiopg</code> and <code>asyncpg</code>. First, we need to install <code>aiopg</code>, a library that will assist with any asynchronous access to PostgreSQL:</p>
			<pre>pip install aiopg</pre>
			<p>Next, we must install <code>asyncpg</code>, which helps build PostgreSQL asynchronous transactions through Python’s AsyncIO framework:</p>
			<pre>pip install asyncpg</pre>
			<p>This driver is a <em class="italic">non-database API-compliant</em> driver because it runs on top of the AsyncIO environment instead of the database API specification for synchronous database transactions.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor123"/>Setting up the database’s connection</h2>
			<p>After installing the<a id="_idIndexMarker313"/> necessary drivers, we can derive the database engine through the application’s <code>create_async_engine()</code> method, which creates an asynchronous version of SQLAlchemy’s <code>Engine</code>, known as <code>AsyncEngine</code>. This method has parameters to set such as <code>future</code>, which can enable a variety of asynchronous features during CRUD transactions when set to <code>True</code>. Also, it has an <code>echo</code> parameter that can provide us with the generated SQL queries in the server log at runtime. But the most essential is the database URL, which now reflects the asynchronous database access through calling the <code>asyncpg</code> protocol. The following is the complete script for the asynchronous connection to the PostgreSQL database:</p>
			<pre class="source-code">
<strong class="bold">from sqlalchemy.ext.asyncio import create_async_engine</strong>
DB_URL = 
  "<strong class="bold">postgresql+asyncpg</strong>://postgres:admin2255@
       localhost:5433/fcms"
<strong class="bold">engine = create_async_engine(DB_URL, future=True, </strong>
               <strong class="bold">echo=True)</strong></pre>
			<p>The additional <code>"+asyncpg"</code> detail in <code>DB_URL</code> indicates that <code>psycopg2</code> will no longer be the core database driver for PostgreSQL; instead, <code>asyncpg</code> will be used. This detail enables <code>AsyncEngine</code> to utilize <code>asyncpg</code> to establish the connection to the database. Omitting <a id="_idIndexMarker314"/>this detail will instruct the engine to recognize the <code>psycopg2</code> database API driver, which will cause problems during the CRUD transactions. </p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor124"/>Creating the session factory</h2>
			<p>Like in the synchronous<a id="_idIndexMarker315"/> version, the <code>sessionmaker()</code> directive is utilized to create the session factory with some new parameters set to enable <code>AsyncSession</code>. First, its <code>expire_on_commit</code> parameter is set to <code>False</code> to make that model instances and its attribute values accessible for the duration of the transaction, even after calling <code>commit()</code>. Unlike in the synchronous environment, all entity classes and their column objects are still accessible by other processes, even after transaction commit. Then, its <code>class_</code> parameter bears the class name <code>AsyncSession</code>, the entity that will take control of the CRUD transactions. Of course, <code>sessionmaker()</code> still needs the engine for <code>AsyncConnection</code> and its underlying asynchronous context managers. </p>
			<p>The following script shows how the session factory is derived using the <code>sessionmaker()</code> directive:</p>
			<pre class="source-code">
<strong class="bold">from sqlalchemy.ext.asyncio import AsyncSession</strong>
from sqlalchemy.orm import sessionmaker
engine = create_async_engine(DB_URL, future=True, 
               echo=True)
AsynSessionFactory = <strong class="bold">sessionmaker(engine,</strong> 
       <strong class="bold">expire_on_commit=False, class_=AsyncSession)</strong></pre>
			<p>The full <a id="_idIndexMarker316"/>configuration for the asynchronous SQLAlchemy database connection can be found in the <code>/db_config/sqlalchemy_async_connect.py</code> module script file. Let us now create the model layer.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor125"/>Creating the Base class and the model layer</h2>
			<p>Creating <a id="_idIndexMarker317"/>the <code>Base</code> class using <code>declarative_base()</code> and creating the model classes using <code>Base</code> is the same as what we did in the synchronous version. No additional<a id="_idIndexMarker318"/> parameters are needed to build the data layer for the asynchronous repository transactions.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor126"/>Building the repository layer</h2>
			<p>Implementing<a id="_idIndexMarker319"/> asynchronous CRUD transactions is entirely different from implementing synchronous ones. The ORM supports the use of the <code>execute()</code> method of the <code>AsyncConnection</code> API to run some of the built-in ORM core methods, namely <code>update()</code>, <code>delete()</code>, and <code>insert()</code>. When it comes to query transactions, the new <code>select()</code> directive from the <code>sqlalchemy.future</code> module is used instead of the core <code>select()</code> method. And since <code>execute()</code> is an <code>async</code> method, this requires that all repository transactions are <code>async</code> too to apply the <em class="italic">Async/Await</em> design pattern. The following <code>AttendanceRepository</code> uses the asynchronous type<a id="_idIndexMarker320"/> of SQLAlchemy:</p>
			<pre class="source-code">
from typing import List, Dict, Any
<strong class="bold">from sqlalchemy import update, delete, insert</strong>
<strong class="bold">from sqlalchemy.future import select</strong>
from sqlalchemy.orm import Session
from models.data.sqlalchemy_async_models import 
            Attendance_Member
<strong class="bold">class AttendanceRepository: </strong>
    
    def __init__(self, sess:Session):
        self.sess:Session = sess
    
    async def <strong class="bold">insert_attendance</strong>(self, attendance: 
           Attendance_Member) -&gt; bool: 
        try:
            <strong class="bold">sql = insert(Attendance_Member).</strong>
                   <strong class="bold">values(id=attendance.id, </strong>
                     <strong class="bold">member_id=attendance.member_id, </strong>
                     <strong class="bold">timein=attendance.timein, </strong>
                     <strong class="bold">timeout=attendance.timeout, </strong>
                     <strong class="bold">date_log=attendance.date_log</strong>)
            <strong class="bold">sql.execution_options(</strong>
                   <strong class="bold">synchronize_session="fetch")</strong>
            <strong class="bold">await self.sess.execute(sql)        </strong>
        except: 
            return False 
        return True</pre>
			<p>The given <em class="italic">asynchronous</em> <code>insert_attendance()</code> method in the preceding script shows the use of the <code>insert()</code> directive in creating an attendance log for a gym member. First, we need to pass the model class name to <code>insert()</code> to let the session know what table to access for the transaction. Afterward, it emits the <code>values()</code> method to project all the column values for insertion. Lastly, we need to call the <code>execute()</code> method to run the final <code>insert()</code> statement and automatically commit the changes since we didn’t turn off the <code>autocommit</code> parameter of <code>sessionmaker()</code> during the configuration. Do not forget to invoke <code>await</code> before running the asynchronous method because everything runs on top of the AsyncIO platform this time.    </p>
			<p>Also, you have the <a id="_idIndexMarker321"/>option to add some additional execution details before running <code>execute()</code>. One of these options is <code>synchronize_session</code>, which tells the session to always synchronize the model attribute values and the updated values from the database using the <code>fetch</code> method.</p>
			<p>Almost the same<a id="_idIndexMarker322"/> procedure is applied to the <code>update_attendance()</code> and <code>delete_attendance()</code> methods. We can run them through <code>execute()</code> and nothing else:</p>
			<pre class="source-code">
    async def <strong class="bold">update_attendance</strong>(self, id:int, 
           details:Dict[str, Any]) -&gt; bool: 
       try:
           <strong class="bold">sql = update(Attendance_Member).where(</strong>
              <strong class="bold">Attendance_Member.id == id).values(**details)</strong>
           <strong class="bold">sql.execution_options(</strong>
              <strong class="bold">synchronize_session="fetch")</strong>
           <strong class="bold">await self.sess.execute(sql)</strong>
           
       except: 
           return False 
       return True
   
    async def <strong class="bold">delete_attendance</strong>(self, id:int) -&gt; bool: 
        try:
           <strong class="bold">sql = delete(Attendance_Member).where(</strong>
                <strong class="bold">Attendance_Member.id == id)</strong>
           <strong class="bold">sql.execution_options(</strong>
                <strong class="bold">synchronize_session="fetch")</strong>
           <strong class="bold">await self.sess.execute(sql)</strong>
        except: 
            return False 
        return True</pre>
			<p>When it comes to queries, the repository class contains <code>get_all_attendance()</code>, which retrieves <a id="_idIndexMarker323"/>all the attendance records, and <code>get_attendance()</code>, which retrieves the attendance log of a particular member through its <code>id</code>. Constructing the <code>select()</code> method is a straightforward and pragmatic task since it is similar to writing a native <code>SELECT</code> statement in SQL development. First, the method needs to know what columns to project, and then it caters to some constraints if there are any. Then, it needs the <code>execute()</code> method to run the query asynchronously and extract the <code>Query</code> object. The resulting <code>Query</code> object has a <code>scalars()</code> method, which we can call to retrieve the list of records. Do not forget to close the session by calling the <code>all()</code> method. </p>
			<p><code>check_attendance()</code>, on the<a id="_idIndexMarker324"/> other hand, uses the <code>scalar()</code> method of the <code>Query</code> object to retrieve one record: a specific attendance. Aside from record retrieval, <code>scalar()</code> also closes the session:</p>
			<pre class="source-code">
    async def <strong class="bold">get_all_attendance</strong>(self):
        <strong class="bold">q = await self.sess.execute(</strong>
               <strong class="bold">select(Attendance_Member))</strong>
        return <strong class="bold">q.scalars().all()</strong>
    
    async def <strong class="bold">get_attendance</strong>(self, id:int): 
        <strong class="bold">q = await self.sess.execute(</strong>
           <strong class="bold">select(Attendance_Member).</strong>
             <strong class="bold">where(Attendance_Member.member_id == id))</strong>
        return <strong class="bold">q.scalars().all()</strong>
    async def <strong class="bold">check_attendance</strong>(self, id:int): 
        <strong class="bold">q = await self.sess.execute(</strong>
          <strong class="bold">select(Attendance_Member).</strong>
              <strong class="bold">where(Attendance_Member.id == id))</strong>
        return <strong class="bold">q.scalar()</strong>        </pre>
			<p>The repository classes for the asynchronous SQLAlchemy can be found in the <code>/repository/sqlalchemy/attendance.py</code> module script file. Now, let us apply these asynchronous transactions to<a id="_idIndexMarker325"/> pursue some attendance monitoring services for our fitness gym application.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The <code>**</code> operator in <code>update_attendance()</code> is a Python operator overload that converts a dictionary into <code>kwargs</code>. Thus, the result of <code>**details</code> is a <code>kwargs</code> argument for the <code>values()</code> method of the <code>select()</code> directive.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor127"/>Running the CRUD transactions</h2>
			<p>There two big differences <a id="_idIndexMarker326"/>between AsyncIO-driven SQLAlchemy and the database API-compliant option when creating the <code>Session</code> instance: </p>
			<ul>
				<li>First, <code>AsyncSession</code>, which was created by the <code>AsyncSessionFactory()</code> directive, needs an asynchronous <code>with</code> context manager because of the connection’s <code>AsyncEngine</code>, which needs to be closed after every <code>commit()</code> transaction. Closing the session factory is not part of the procedure in the synchronous ORM version. </li>
				<li>Second, after its creation, <code>AsyncSession</code> will only start executing all the CRUD transactions when the service calls its <code>begin()</code> method. The main reason is that <code>AsyncSession</code> can be closed and needs to be closed once the transaction has been executed. That is why another asynchronous context manager is used to manage <code>AsyncSession</code>. </li>
			</ul>
			<p>The following code shows the <code>APIRouter</code> script, which implements the services for monitoring gym <a id="_idIndexMarker327"/>member attendance using the asynchronous <code>AttendanceRepository</code>:</p>
			<pre class="source-code">
from fastapi import APIRouter
<strong class="bold">from db_config.sqlalchemy_async_connect import </strong>
          <strong class="bold">AsynSessionFactory</strong>
from repository.sqlalchemy.attendance import 
         <strong class="bold">AttendanceRepository</strong>
from models.requests.attendance import AttendanceMemberReq
from models.data.sqlalchemy_async_models import 
         <strong class="bold">Attendance_Member</strong>
router = APIRouter()
<strong class="bold">@router.post("/attendance/add")</strong>
async def <strong class="bold">add_attendance</strong>(req:AttendanceMemberReq ):
<strong class="bold">    async with AsynSessionFactory() as sess:</strong>
        <strong class="bold">async with sess.begin():</strong>
            <strong class="bold">repo = AttendanceRepository(sess)</strong>
            attendance = Attendance_Member(id=req.id,  
                member_id=req.member_id, 
                timein=req.timein, timeout=req.timeout, 
                date_log=req.date_log)
            return await repo.insert_attendance(attendance)
        
<strong class="bold">@router.patch("/attendance/update")</strong>
async def update_attendance(id:int, 
                     req:AttendanceMemberReq ):
    <strong class="bold">async with AsynSessionFactory() as sess:</strong>
        <strong class="bold">async with sess.begin():</strong>
            repo = AttendanceRepository(sess)
            attendance_dict = req.dict(exclude_unset=True)
            return await repo.update_attendance(id, 
                    attendance_dict)
<strong class="bold">@router.delete("/attendance/delete/{id}")</strong>
async def delete_attendance(id:int): 
     <strong class="bold">async with AsynSessionFactory() as sess:</strong>
        <strong class="bold">async with sess.begin():</strong>
            repo = AttendanceRepository(sess)
            return await repo.delete_attencance(id)
<strong class="bold">@router.get("/attendance/list")</strong>
async def list_attendance():
     <strong class="bold">async with AsynSessionFactory() as sess:</strong>
        <strong class="bold">async with sess.begin():</strong>
            repo = AttendanceRepository(sess)
            return await repo.get_all_attendance()</pre>
			<p>The preceding <a id="_idIndexMarker328"/>script shows no direct parameter passing between the repository class and the <code>AsyncSession</code> instance. The session must comply with the two context managers before it becomes a working one. This syntax is valid under <em class="italic">SQLAlchemy 1.4</em>, which may undergo some changes in the future with SQLAlchemy’s next releases. </p>
			<p>Other ORM platforms that have been created for asynchronous transactions are easier to use. One of these is <strong class="bold">GINO</strong>.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor128"/>Using GINO for async transactions</h1>
			<p><strong class="bold">GINO</strong>, which <a id="_idIndexMarker329"/>stands for <strong class="bold">GINO Is Not ORM</strong>, is a lightweight asynchronous ORM that runs on top of an SQLAlchemy Core and AsyncIO environment. All its APIs are asynchronous-ready so that you can build contextual database connections and transactions. It has built-in <em class="italic">JSONB</em> support so that it can convert its results into JSON objects. But there is one catch: GINO only supports PostgreSQL databases.</p>
			<p>While<a id="_idIndexMarker330"/> creating the gym fitness project, the only available stable GINO version is 1.0.1, which requires <em class="italic">SQLAlchemy 1.3</em>. Therefore, installing GINO will automatically uninstall <em class="italic">SQLAlchemy 1.4</em>, thus adding the GINO repository to the <code>ch05a</code> project to avoid any conflicts with the async version of SQLAlchemy. </p>
			<p>You can use the following command to install the latest version of GINO:</p>
			<pre>pip install gino</pre>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor129"/>Installing the database driver</h2>
			<p>Since the only RDBMS it <a id="_idIndexMarker331"/>supports is PostgreSQL, you only need to install <code>asyncpg</code> using the <code>pip</code> command.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor130"/>Establishing the database connection</h2>
			<p>No other APIs are <a id="_idIndexMarker332"/>needed to open a connection to the database except for the <code>Gino</code> directive. We need to instantiate the class to start building the domain layer. The <code>Gino</code> class can be imported from the ORM’s <code>gino</code> module, as shown by the following script:</p>
			<pre class="source-code">
<strong class="bold">from gino import Gino</strong>
db = Gino()</pre>
			<p>Its instance is like a façade that controls all database transactions. It starts by establishing a database connection once it’s been provided with the correct PostgreSQL administrator credentials. The <a id="_idIndexMarker333"/>full GINO database connectivity script can be found in the <code>/db_config/gino_connect.py</code> script file. Let us now build the model layer.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor131"/>Building the model layer</h2>
			<p>The model class<a id="_idIndexMarker334"/> definition in GINO has similarities with SQLAlchemy when it comes to structuring, column metadata, and even the existence of the <code>__tablename__</code> property. The only difference is the superclass type because GINO uses the <code>Model</code> class from the database reference instance’s <code>db</code>. The following script shows how the <code>Signup</code> domain model is mapped to the <code>signup</code> table:</p>
			<pre class="source-code">
<strong class="bold">from db_config.gino_connect import db</strong>
class Signup(<strong class="bold">db.Model</strong>):
    <strong class="bold">__tablename__ = "signup"</strong>
    id = <strong class="bold">db.Column</strong>(<strong class="bold">db.Integer</strong>, primary_key=True, 
               index=True)
    username = <strong class="bold">db.Column</strong>(<strong class="bold">'username'</strong>,<strong class="bold">db.String</strong>, 
               unique=False, index=False)
    password = <strong class="bold">db.Column</strong>(<strong class="bold">'password'</strong>,<strong class="bold">db.String</strong>, 
               unique=False, index=False)</pre>
			<p>Like in SQLAlchemy, the <code>__tablename__</code> property is mandatory for all model classes to indicate their mapped table schema. When defining the column metadata, the <code>db</code> object has a <code>Column</code> directive that can set properties such as the <em class="italic">column type</em>, <em class="italic">primary key</em>, <em class="italic">unique</em>, <em class="italic">default</em>, <em class="italic">nullable</em>, and <em class="italic">index</em>. The column types also come from the <code>db</code> reference object, and these types are also the same for SQLAlchemy – that is, <code>String</code>, <code>Integer</code>, <code>Date</code>, <code>Time</code>, <code>Unicode</code>, and <code>Float</code>. </p>
			<p>And just in case the <a id="_idIndexMarker335"/>name of the model attribute does not match the column name, the <code>Column</code> directive has its first parameter register the name of the actual column and maps it to the model attributes. The <code>username</code> and <code>password</code> columns are example cases of mapping the class attributes to the table’s column names.</p>
			<h3>Mapping table relationships   </h3>
			<p>At the time of<a id="_idIndexMarker336"/> writing, GINO only supports the <em class="italic">many-to-one relationship</em> by default. The <code>db</code> reference object has a <code>ForeignKey</code> directive, which establishes a foreign key relationship with the parent model. It just needs the actual reference key column and table name of the parent table to pursue the mapping. Setting the <code>ForeignKey</code> property in the <code>Column</code> object of the child model class is enough configuration to perform a <em class="italic">LEFT OUTER JOIN</em> to retrieve all the child records of the parent mode class. GINO has no <code>relationship()</code> function to address more details regarding how to fetch the child records of the parent model class. However, it has built-in loaders to automatically determine the foreign key and perform a many-to-one join query afterward. A <a id="_idIndexMarker337"/>perfect setup for this join query is the relationship configuration between the <code>Profile_Trainers</code> and <code>Gym_Class</code> model classes, as shown in the following script:</p>
			<pre class="source-code">
class <strong class="bold">Profile_Trainers</strong>(db.Model):
    __tablename__ = "profile_trainers"
    id = db.Column(db.Integer, <strong class="bold">db.ForeignKey('login.id')</strong>, 
              primary_key=True, index=True)
    firstname = db.Column(db.String, unique=False, 
              index=False)
    … … … … … …
    shift = db.Column(db.Integer, unique=False, 
              index=False)
class <strong class="bold">Gym_Class</strong>(db.Model): 
    __tablename__ = "gym_class"
    id = db.Column(db.Integer, primary_key=True, 
          index=True)
    member_id = db.Column(db.Integer, 
       <strong class="bold">db.ForeignKey('profile_members.id')</strong>, unique=False, 
         index=False)
    trainer_id = db.Column(db.Integer, 
      <strong class="bold">db.ForeignKey('profile_trainers.id')</strong>, unique=False,
         index=False)
    approved = db.Column(db.Integer, unique=False, 
       index=False)</pre>
			<p>We will have to make some changes if we need to build a query that will deal with a <em class="italic">one-to-many</em> or a <em class="italic">one-to-one relationship</em>. For the <em class="italic">LEFT OUTER JOIN</em> query to work, the parent model class must have a <code>set</code> collection defined to contain all the child records during <a id="_idIndexMarker338"/>join queries involving one-to-many relationships. For a <em class="italic">one-to-one relationship</em>, the parent only needs to instantiate the child model:</p>
			<pre class="source-code">
class <strong class="bold">Login</strong>(<strong class="bold">db.Model</strong>): 
    __tablename__ = "login"
    id = db.Column(db.Integer, primary_key=True, 
               index=True)
    username = db.Column(db.String, unique=False, 
               index=False)
    … … … … … …
    <strong class="bold">def __init__(self, **kw):</strong>
        <strong class="bold">super().__init__(**kw)</strong>
        <strong class="bold">self._child = None</strong>
    <strong class="bold">@property</strong>
    <strong class="bold">def child(self):</strong>
        <strong class="bold">return self._child</strong>
    <strong class="bold">@child.setter</strong>
    <strong class="bold">def child(self, child):</strong>
        <strong class="bold">self._child = child</strong>
class <strong class="bold">Profile_Members</strong>(db.Model): 
    __tablename__ = "profile_members"
    id = db.Column(db.Integer, <strong class="bold">db.ForeignKey('login.id')</strong>, 
          primary_key=True, index=True)
    … … … … … … 
    weight = db.Column(db.Float, unique=False, index=False)
    trainer_id = db.Column(db.Integer, 
        <strong class="bold">db.ForeignKey('profile_trainers.id')</strong>, unique=False, 
            index=False)
    
    <strong class="bold">def __init__(self, **kw):</strong>
        <strong class="bold">super().__init__(**kw)</strong>
        <strong class="bold">self._children = set()</strong>
    <strong class="bold">@property</strong>
    <strong class="bold">def children(self):</strong>
        <strong class="bold">return self._children</strong>
    <strong class="bold">@children.setter</strong>
    <strong class="bold">def children(self, child):</strong>
        <strong class="bold">self._children.add(child)</strong></pre>
			<p>This <em class="italic">set collection</em> or <em class="italic">child object</em> must be instantiated in the parent’s <code>__init__()</code> to be accessed<a id="_idIndexMarker339"/> by the ORM’s loader through the <em class="italic">children</em> or <em class="italic">child</em> <code>@property</code>, respectively. Using <code>@property</code> is the only way to manage joined records. </p>
			<p>Note that the existence of the loader APIs is proof that GINO does not support the automated relationship that SQLAlchemy has. If we want to deviate from its core setup, Python programming is needed to add some features not supported by the platform, such as the one-to-many setup between <code>Profile_Members</code> and <code>Gym_Class</code>, and between <code>Login</code> and <code>Profile_Members</code>/<code>Profile_Trainers</code>. In the previous script, notice the inclusion of a constructor and the custom <code>children</code> Python property in <code>Profile_Members</code>, as well as the custom <code>child</code> property in <code>Login</code>. This is because GINO only has a built-in <code>parent</code> property.</p>
			<p>You can find the<a id="_idIndexMarker340"/> domain models of GINO in the <code>/models/data/gino_models.py</code> script.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout"><code>@property</code> is a Python decorator that’s used to implement a getter/setter in a class. This hides an instance variable from the accessor and exposes its <em class="italic">getter</em> and <em class="italic">setter</em> property <em class="italic">fields</em>. Using <code>@property</code> is one way to implement the <em class="italic">encapsulation</em> principle in Python.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor132"/>Implementing the CRUD transactions</h2>
			<p>Let us consider the following <code>TrainerRepository</code>, which manages trainer profiles. Its <code>insert_trainer()</code> method shows the conventional way of implementing insert transactions. GINO<a id="_idIndexMarker341"/> requires its model class to call <code>create()</code>, an inherited method from the <code>db</code> reference object. All the column values are passed to the <code>create()</code> method through named parameters or as a bundle using <code>kwargs</code> before the record object is persisted. But GINO allows another insert option that uses the instance of the model derived by injecting column values into its constructor. The created instance has a method called <code>create()</code> that inserts the record object without requiring any parameters:</p>
			<pre class="source-code">
from models.data.gino_models import Profile_Members, 
           Profile_Trainers, Gym_Class
from datetime import date, time
from typing import List, Dict, Any
<strong class="bold">class TrainerRepository: </strong>
    
    async def <strong class="bold">insert_trainer</strong>(self, 
             details:Dict[str, Any]) -&gt; bool: 
        try:
            <strong class="bold">await Profile_Trainers.create(**details)</strong>
        except Exception as e: 
            print(e)
            return False 
        return True</pre>
			<p><code>update_trainer()</code> highlights how GINO updates table records. Based on the script, updating the table in the GINO way involves doing the following: </p>
			<ul>
				<li>First, it requires the <code>get()</code> class method of the model class to retrieve the record object with the <code>id</code> primary key.</li>
				<li>Second, the<a id="_idIndexMarker342"/> extracted record has an instance method called <code>update()</code> that will automatically modify the mapped row with the new data specified in its <code>kwargs</code> argument. The <code>apply()</code> method will commit the changes and close the transaction:<pre>    async def update_trainer(self, id:int, 
                 details:Dict[str, Any]) -&gt; bool: 
       try:
            <strong class="bold">trainer = await Profile_Trainers.get(id)</strong>
            <strong class="bold">await trainer.update(**details).apply()       </strong>
       except: 
           return False 
       return True</pre></li>
			</ul>
			<p>Another option is to use the SQLAlchemy <code>ModelClass.update.values(ModelClass).where(expression)</code> clause, which, when applied to <code>update_trainer()</code>, will give us this final statement: </p>
			<pre class="source-code">
Profile_Trainers.<strong class="bold">update.values(**details)</strong>.
     <strong class="bold">where(Profile_Trainers.id == id)</strong>.gino.status()</pre>
			<p>Its <code>delete_trainer()</code> also follows the same approach as the GINO <em class="italic">update</em> transaction. This transaction is a two-step process, and the last step requires calling the <code>delete()</code> instance <a id="_idIndexMarker343"/>method of the extracted record object:</p>
			<pre class="source-code">
    async def delete_trainer(self, id:int) -&gt; bool: 
        try:
           <strong class="bold">trainer = await Profile_Trainers.get(id)</strong>
           <strong class="bold">await trainer.delete()        </strong>
        except: 
            return False 
        return True</pre>
			<p>On the other hand, <code>TrainerRepository</code> has two methods, <code>get_member()</code> and <code>get_all_member()</code>, which show how GINO constructs query statements: </p>
			<ul>
				<li>The former retrieves a specific record object using its primary key through the <code>get()</code> class method of the model class </li>
				<li>The latter uses the <code>gino</code> extension of <code>query</code> to utilize the <code>all()</code> method, which retrieves the records:<pre>    async def get_all_member(self):
        return <strong class="bold">await Profile_Trainers.query.gino.all()</strong>
    async def get_member(self, id:int): 
            return <strong class="bold">await Profile_Trainers.get(id)</strong></pre></li>
			</ul>
			<p>But what translates database rows into model objects in a query’s execution is the built-in loader of GINO. If we expand further on the solution presented in <code>get_all_member()</code>, this will look like this:</p>
			<pre class="source-code">
query = db.select([Profile_Trainers])
q = query.execution_options(
         <strong class="bold">loader=ModelLoader(Profile_Trainers)</strong>)
users = await q.gino.all()</pre>
			<p>In the GINO ORM, all <a id="_idIndexMarker344"/>queries utilize <code>ModelLoader</code> to load each database record into a model object:</p>
			<pre class="source-code">
<strong class="bold">class GymClassRepository:</strong>
        
    async def join_classes_trainer(self):
        <strong class="bold">query = Gym_Class.join(Profile_Trainers).select()</strong>
        result = <strong class="bold">await query.gino.load(Gym_Class.</strong>
            <strong class="bold">distinct(Gym_Class.id).</strong>
                <strong class="bold">load(parent=Profile_Trainers)).all()</strong>
        return result 
    
    async def join_member_classes(self):
        <strong class="bold">query = Gym_Class.join(Profile_Members).select()</strong>
        result = <strong class="bold">await query.gino.load(Profile_Members.</strong>
           <strong class="bold">distinct(Profile_Members.id).</strong>
              <strong class="bold">load(add_child=Gym_Class)).all()</strong>
        return result</pre>
			<p>If the normal query requires <code>ModelLoader</code>, what is needed for the <em class="italic">JOIN</em> query transactions? GINO has no automated support for table relationships, and creating <em class="italic">JOIN</em> queries is impossible without <code>ModelLoader</code>. The <code>join_classes_trainer()</code> method implements a <em class="italic">one-to-many</em> query for <code>Profile_Trainers</code> and <code>Gym_Class</code>. The <code>distinct(Gym_Class.id).load(parent=Profile_Trainers)</code> clause in the query creates a <code>ModelLoader</code> for <code>GymClass</code>, which will merge and load the <code>Profile_Trainers</code> parent<a id="_idIndexMarker345"/> record into its child <code>Gym_Class</code>. <code>join_member_classes()</code> creates <em class="italic">one-to-many</em> joins, while <code>distinct(Profile_Members.id).load(add_child=Gym_Class)</code> creates a <code>ModelLoader</code> to build the set of <code>Gym_Class</code> records, as per the <code>Profile_Members</code> parent. </p>
			<p>On the other hand, the <em class="italic">many-to-one</em> relationship of <code>Gym_Class</code> and <code>Profile_Members</code> uses the <code>load()</code> function of <code>Profile_Member</code>, which is a different approach to <a id="_idIndexMarker346"/>matching the <code>Gym_Class</code> child records to <code>Profile_Members</code>. The following joined query is the opposite of the <em class="italic">one-to-many</em> setup because the <code>Gym_Class</code> records here are on the left-hand side while the profiles are on the right:</p>
			<pre class="source-code">
    async def join_classes_member(self):
        result = await 
<strong class="bold">          Profile_Members.load(add_child=Gym_Class)</strong>
           .query.gino.all()</pre>
			<p>So, the loader plays an important role in building queries in GINO, especially joins. Although it makes query building difficult, it still gives flexibility to many complex queries. </p>
			<p>All the repository classes for GINO can be found in the <code>/repository/gino/trainers.py</code> script.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor133"/>Running the CRUD transactions</h2>
			<p>For our <a id="_idIndexMarker347"/>repositories to run in the <code>APIRouter</code> module, we need to open the database connection by binding the <code>db</code> reference object to the actual database through <code>DB_URL</code>. It is ideal to use a dependable function for the binding procedure because the easier form of rolling out is done through <code>APIRouter</code> injection. The following script shows how to set up this database binding:</p>
			<pre class="source-code">
from fastapi import APIRouter, Depends
from fastapi.encoders import jsonable_encoder
from fastapi.responses import JSONResponse
<strong class="bold">from db_config.gino_connect import db</strong>
from models.requests.trainers import ProfileTrainersReq
from repository.gino.trainers import TrainerRepository
<strong class="bold">async def sess_db():</strong>
    <strong class="bold">await db.set_bind(</strong>
     <strong class="bold">"postgresql+asyncpg://</strong>
       <strong class="bold">postgres:admin2255@localhost:5433/fcms")</strong>
    
router = APIRouter(<strong class="bold">dependencies=[Depends(sess_db)]</strong>)
<strong class="bold">@router.patch("/trainer/update" )</strong>
async def update_trainer(id:int, req: ProfileTrainersReq): 
    mem_profile_dict = req.dict(exclude_unset=True)
    repo = TrainerRepository()
    result = await repo.update_trainer(id, 
           mem_profile_dict)
    if result == True: 
        return req 
    else: 
        return JSONResponse(
    content={'message':'update trainer profile problem 
         encountered'}, status_code=500)
 
<strong class="bold">@router.get("/trainer/list")</strong>
async def list_trainers(): 
    repo = TrainerRepository()
    return await repo.get_all_member()</pre>
			<p>The <code>list_trainers()</code> and <code>update_trainer()</code> REST services shown in the preceding code are some services of our <em class="italic">fitness club</em> application that will successfully run <code>TrainerRepository</code> after injecting <code>sess_db()</code> into <code>APIRouter</code>. GINO does not ask for many details when establishing the connection to PostgreSQL except for <code>DB_URL</code>. Always <a id="_idIndexMarker348"/>specify the <code>asyncpg</code> dialect in the URL because it is the only driver that’s supported by GINO as a synchronous ORM. </p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor134"/>Creating the tables</h2>
			<p>GINO and <a id="_idIndexMarker349"/>SQLAlchemy have the same approach to creating a table schema at the framework level. Both require the <code>MetaData</code> and <code>Column</code> directives for building the <code>Table</code> definitions. Then, an asynchronous function is preferred to derive the engine using the <code>create_engine()</code> method with our <code>DB_URL</code>. Like in SQLAlchemy, this engine plays a crucial role in building the tables through <code>create_all()</code>, but this time, it uses GINO’s <code>GinoSchemaVisitor</code> instance. The following script shows the complete implementation of how tables are generated in GINO using the AsyncIO platform:</p>
			<pre class="source-code">
from sqlalchemy import Table, Column, Integer, String, 
           <strong class="bold">MetaData</strong>, ForeignKey'
import gino
<strong class="bold">from gino.schema import GinoSchemaVisitor</strong>
<strong class="bold">metadata = MetaData()</strong>
signup = <strong class="bold">Table</strong>(
    'signup', <strong class="bold">metadata</strong>,
    <strong class="bold">Column</strong>('id', Integer, primary_key=True),
    <strong class="bold">Column</strong>('username', String),
    <strong class="bold">Column</strong>('password', String),
)
   … … … … …
<strong class="bold">async</strong> def db_create_tbl():
    <strong class="bold">engine = await gino.create_engine(DB_URL)</strong>
    <strong class="bold">await GinoSchemaVisitor(metadata).create_all(engine)</strong></pre>
			<p>As stated in <a id="_idIndexMarker350"/>SQLAlchemy, performing DDL transactions such as schema auto-generation at the start is optional because it may cause FastAPI’s performance to degrade, and even some conflicts in the existing database schema.</p>
			<p>Now, let us explore another ORM that requires custom Python coding: <strong class="bold">Pony ORM</strong>. </p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor135"/>Using Pony ORM for the repository layer</h1>
			<p>Pony ORM<a id="_idIndexMarker351"/> relies on Python syntax for building the model classes and repository transactions. This ORM only uses Python data types such as <code>int</code>, <code>str</code>, and <code>float</code>, as well as class types to implement model definitions. It applies Python <code>lambda</code> expressions to establish CRUD transactions, especially when mapping table relationships. Also, Pony <a id="_idIndexMarker352"/>heavily supports JSON conversion of record objects when reading records. On the other hand, Pony can cache the query objects, which provides faster performance than the others. The code for Pony ORM can be found in the <code>ch05a</code> project.</p>
			<p>To use Pony, we need to install it using <code>pip</code>. This is because it is a third-party platform:</p>
			<pre>pip install pony</pre>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor136"/>Installing the database driver</h2>
			<p>Since Pony is an ORM designed to <a id="_idIndexMarker353"/>build synchronous transactions, we will need the <code>psycopg2</code> PostgreSQL driver. We can install it using the <code>pip</code> command:</p>
			<pre>pip install psycopg2</pre>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor137"/>Creating the database’s connectivity</h2>
			<p>The approach to<a id="_idIndexMarker354"/> establishing database connectivity in Pony is simple and declarative. It only needs the <code>Database</code> directive from the <code>pony.orm</code> module to be instantiated to connect to the database using the correct database credentials. The following script is used in the <em class="italic">fitness club</em> prototype:</p>
			<pre class="source-code">
<strong class="bold">from pony.orm import  Database</strong>
db = <strong class="bold">Database</strong>("postgres", host="localhost", port="5433", 
  user="postgres", password="admin2255", database="fcms")</pre>
			<p>As you can see, the first parameter of the constructor is the <em class="italic">database dialect</em>, followed by <code>kwargs</code>, which contains all the details about the connection. The full configuration can be found in the <code>/db_config/pony_connect.py</code> script file. Now, let us create Pony's model classes.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor138"/>Defining the model classes</h2>
			<p>The <a id="_idIndexMarker355"/>created database object, <code>db</code>, is the only component needed to define a Pony <em class="italic">entity</em>, a term that refers to a model class. It has an <code>Entity</code> attribute, which is used to subclass each model class to provide the <code>_table_</code> attribute, which is responsible for the <em class="italic">table-entity</em> mapping. All entity instances are bound to <code>db</code> and mapped to the tables. The following script shows how the <code>Signup</code> class becomes an entity of the model layer:</p>
			<pre class="source-code">
<strong class="bold">from pony.orm import  Database, PrimaryKey, Required, </strong>
         <strong class="bold">Optional, Set</strong>
<strong class="bold">from db_config.pony_connect import db</strong>
from datetime import date, time
    
class Signup(<strong class="bold">db.Entity</strong>):
    <strong class="bold">_table_ = "signup"</strong>
    id = <strong class="bold">PrimaryKey</strong>(int)
    username = <strong class="bold">Required</strong>(str, unique=True, max_len=100, 
         nullable=False, column='username')
    password = <strong class="bold">Required</strong>(str, unique=Fals, max_len=100, 
         nullable=False, column='password')</pre>
			<p>The <code>pony.orm</code> module contains <code>Required</code>, <code>Optional</code>, <code>PrimaryKey</code>, or <code>Set</code> directives, which are used to create column attributes. Since each entity must have a primary<a id="_idIndexMarker356"/> key, <code>PrimaryKey</code> is used to define the column attribute of the entity. If the class has no primary key, Pony ORM will implicitly generate an <code>id</code> primary for the entity with the following definition:</p>
			<pre class="source-code">
id = <strong class="bold">PrimaryKey</strong>(int, auto=True)</pre>
			<p>On the other hand, the <code>Set</code> directive indicates relationships between entities. All these directives have a mandatory attribute column type, which declares the column value type in Python syntax (for example, <code>int</code>, <code>str</code>, <code>float</code>, <code>date</code>, or <code>time</code>) or any class type. Other column attributes include <code>auto</code>, <code>max_len</code>, <code>index</code>, <code>unique</code>, <code>nullable</code>, <code>default</code>, and <code>column</code>. Now, let us establish a relationship between model classes:</p>
			<pre class="source-code">
<strong class="bold">class Login(db.Entity): </strong>
    _table_ = "login"
    id = PrimaryKey(int)
    … … … … … …
    date_approved = Required(date)
    user_type = Required(int)
    
<strong class="bold">    trainers = Optional("Profile_Trainers", reverse="id")</strong>
<strong class="bold">    members = Optional("Profile_Members", reverse="id")</strong></pre>
			<p>The given <code>Login</code> class has two additional attributes, <code>trainers</code> and <code>members</code>, which serve as reference keys to the <code>Profile_Trainers</code> and <code>Profile_Members</code> models, respectively. In turn, these child entities have their respective class attributes pointing back at the <code>Login</code> model, establishing a relationship. These column attributes and their reference-foreign keys relationship must match the physical database schema. The following<a id="_idIndexMarker357"/> code shows examples of Pony’s child model classes:</p>
			<pre class="source-code">
<strong class="bold">class Profile_Trainers(db.Entity):</strong>
    _table_ = "profile_trainers"
<strong class="bold">    id = PrimaryKey("Login", reverse="trainers")</strong>
    firstname = Required(str)
    … … … … … …
    tenure = Required(float)
    shift = Required(int)
    
<strong class="bold">    members = Set("Profile_Members", </strong>
<strong class="bold">           reverse="trainer_id")</strong>
<strong class="bold">    gclass = Set("Gym_Class", reverse="trainer_id")</strong>
<strong class="bold">class Profile_Members(db.Entity): </strong>
    _table_ = "profile_members"
<strong class="bold">    id = PrimaryKey("Login", reverse="members")</strong>
    firstname = Required(str)
    … … … … … …
<strong class="bold">    trainer_id = Required("Profile_Trainers", </strong>
<strong class="bold">            reverse="members")</strong>
    … … … … … …</pre>
			<p>Defining the<a id="_idIndexMarker358"/> relationship attributes depends on the relationship type between the two entities. Attributes should be defined as <em class="italic">Optional(parent)</em>-<em class="italic">Required(child)</em> or <em class="italic">Optional(parent)</em>-<em class="italic">Optional(child) </em>if the relationship type is one-to-one. For one-to-many, attributes should be defined as <em class="italic">Set(parent)</em>-<em class="italic">Required(child)</em>. Finally, for many-to-one, the attributes must be defined as <em class="italic">Set(parent)</em>-<em class="italic">Set(child)</em>. </p>
			<p><code>Login</code> has a one-to-one relationship with <code>Profile_Members</code>, which explains the use of the <code>Optional</code> attribute to point to the <code>id</code> key of <code>Profile_Members</code>. The primary keys are always the reference keys in this relationship for Pony. </p>
			<p>On the other hand, the <code>Profile_Trainers</code> model has a one-to-many setup with <code>Profile_Members</code>, which explains why the <code>trainer_id</code> attribute of the former uses the <code>Required</code> directive to point to the <code>Set</code> attribute <code>members</code> of the latter. Sometimes, the framework requires backreference through the directive’s <code>reverse </code>parameter. The preceding code also depicts the same scenario between the <code>Profile_Members</code> and <code>Gym_Class</code> models, where the <code>gclass</code> attribute of <code>Profile_Members</code> is declared as a <code>Set</code> collection that contains all the enrolled gym classes of the member. The reference key can be a primary key or just a typical class attribute in this<a id="_idIndexMarker359"/> relationship. The following snippet shows the blueprint of the <code>Gym_Class</code> model:</p>
			<pre class="source-code">
<strong class="bold">class Gym_Class(db.Entity): </strong>
    _table_ = "gym_class"
    id = PrimaryKey(int)
    <strong class="bold">member_id = Required("Profile_Members", </strong>
         <strong class="bold">reverse="gclass")</strong>
    <strong class="bold">trainer_id = Required("Profile_Trainers", </strong>
         <strong class="bold">reverse="gclass")</strong>
    approved = Required(int)
<strong class="bold">db.generate_mapping()</strong></pre>
			<p>Unlike in other ORMs, Pony needs <code>generate_mapping()</code> to be executed to realize all the entity mappings to the actual tables. The method is an instance method of the <code>db</code> instance that must appear in the last part of the module script, as shown in the previous snippet, where <code>Gym_Class</code> was the last Pony model class to be defined. All the Pony model classes can be found in the <code>/models/data/pony_models.py</code> script file.</p>
			<p>Note that we can create Pony entities manually or digitally using <em class="italic">Pony ORM ER Diagram Editor</em>, which we can access at <a href="https://editor.ponyorm.com/">https://editor.ponyorm.com/</a>. The editor can provide us with both<a id="_idIndexMarker360"/> free and commercial accounts. Let us now implement the CRUD transactions.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor139"/>Implementing the CRUD transactions</h2>
			<p>CRUD <a id="_idIndexMarker361"/>transactions in Pony are session-driven. But unlike SQLAlchemy, its repository classes do not require injecting <code>db_session</code> into the repository constructor. Each transaction in Pony will not work without <code>db_session</code>. The following code shows a repository class that implements all the transactions needed to manage a list of gym members:</p>
			<pre class="source-code">
<strong class="bold">from pony.orm import db_session, left_join</strong>
from models.data.pony_models import Profile_Members, 
            Gym_Class, Profile_Trainers
from datetime import date, time
from typing import List, Dict, Any
from models.requests.members import ProfileMembersReq 
class MemberRepository: 
    
    def <strong class="bold">insert_member</strong>(self, 
            details:Dict[str, Any]) -&gt; bool: 
        try:
            <strong class="bold">with db_session:</strong>
                <strong class="bold">Profile_Members(**details)</strong>
        except: 
            return False 
        return True</pre>
			<p>In Pony, inserting<a id="_idIndexMarker362"/> a record means instantiating the model class with the injected record values. An example is <code>insert_member()</code>, which inserts a profile by instantiating the <code>Profile_Members</code> model with the injected membership details. However, the case is different when updating records, as shown in the following script:      </p>
			<pre class="source-code">
    def <strong class="bold">update_member</strong>(self, id:int, 
               details:Dict[str, Any]) -&gt; bool: 
       try:
          <strong class="bold">with db_session:</strong>
            <strong class="bold">profile = Profile_Members[id]</strong>
            <strong class="bold">profile.id = details["id"]</strong>
            … … … … … …
            <strong class="bold">profile.trainer_id = details["trainer_id"]</strong>
       except: 
           return False 
       return True</pre>
			<p>Updating a record in Pony, which is implemented in the <code>update_member()</code> script, means retrieving the record object through <em class="italic">indexing</em> using its <code>id</code>. The retrieved object is automatically converted into a JSON-able object since Pony has built-in support for JSON. Then, the new values of those attributes are overwritten as they must be changed. This <em class="italic">UPDATE</em> transaction is, again, within the bounds of <code>db_session</code>, thus automatically refreshing the record(s) after the overwrites.</p>
			<p>On the other hand, <code>delete_member()</code> of the repository class shows the same approach with <em class="italic">UPDATE</em>, except that a <code>delete()</code> class method is invoked right after retrieving the object record. The following is the script for this operation:</p>
			<pre class="source-code">
    def <strong class="bold">delete_member</strong>(self, id:int) -&gt; bool: 
        try:
           <strong class="bold">with db_session: </strong>
               <strong class="bold">Profile_Members[id].delete()</strong>
        except: 
            return False 
        return True</pre>
			<p>The delete<a id="_idIndexMarker363"/> transaction is also <code>db_session</code> bound, so invoking <code>delete()</code> automatically refreshes the table. The following code shows Pony’s implementation for query transactions:</p>
			<pre class="source-code">
    def <strong class="bold">get_all_member</strong>(self):
        <strong class="bold">with db_session:</strong>
            <strong class="bold">members = Profile_Members.select()</strong>
            <strong class="bold">result = [ProfileMembersReq.from_orm(m) </strong>
                 <strong class="bold">for m in members]</strong>
            <strong class="bold">return result</strong>
    
    def <strong class="bold">get_member</strong>(self, id:int): 
        <strong class="bold">with db_session:</strong>
            <strong class="bold">login = Login.get(lambda l: l.id == id)</strong>
            <strong class="bold">member = Profile_Members.get(</strong>
                <strong class="bold">lambda m: m.id == login)</strong>
            <strong class="bold">result = ProfileMembersReq.from_orm(member)</strong>
        return result</pre>
			<p><code>get_member()</code> retrieves a single record using the <code>get()</code> class method, which requires a <code>lambda</code> expression in its parameter. Since <code>Login</code> has a one-to-one relationship with <code>Profile_Members</code>, first, we must extract the <code>Login</code> record of the member and use the <code>login</code> object to fetch the record through the <code>get()</code> helper function of the <code>Profile_Members</code> entity. This approach is also applicable to other entities with other entity relationships. Now, <code>get_all_member()</code> retrieves a result set using the <code>select()</code> method. The <code>select()</code> method can also utilize a lambda expression if there are constraints in the retrieval operation. </p>
			<p>Pony model <a id="_idIndexMarker364"/>classes have the <code>get()</code> and <code>select()</code> methods, which both return <code>Query</code> objects that FastAPI cannot process directly. So, we need an ORM-friendly <code>Pydantic</code> model to extract the final entities from these <code>Query</code> objects. Like in SQLAlchemy, a <code>ModelBase</code> class with a nested <code>Config</code> class is required to retrieve the records from the <code>Query</code> object. The nested class must configure <code>orm_mode</code> to <code>True</code>. If relationship mappings are involved, the request model must also declare the attributes involved in the relationship and their corresponding child object converters. The method converters, decorated by Pydantic’s <code>@validator</code>, are automatically called by Pony to interpret and validate the <code>Query</code> objects into JSON-able components such as <code>List</code> or entity objects. The following code shows the request model that’s used to extract the records from <code>select()</code> through list comprehension and the <code>Profile_Member dict</code> object from <code>get()</code>:</p>
			<pre class="source-code">
from typing import List, Any
<strong class="bold">from pydantic import BaseModel, validator</strong>
<strong class="bold">class ProfileMembersReq(BaseModel): </strong>
    id: Any
    firstname: str
    lastname: str
    age: int
    height: float
    weight: float
    membership_type: str
    <strong class="bold">trainer_id: Any</strong>
    
    <strong class="bold">gclass: List</strong>
    
    <strong class="bold">@validator('gclass', pre=True, </strong>
         <strong class="bold">allow_reuse=True, check_fields=False)</strong>
    <strong class="bold">def gclass_set_to_list(cls, values):</strong>
        <strong class="bold">return [v.to_dict() for v in values]</strong>
    <strong class="bold">@validator('trainer_id', pre=True, </strong>
         <strong class="bold">allow_reuse=True, check_fields=False)</strong>
    <strong class="bold">def trainer_object_to_map(cls, values):</strong>
        <strong class="bold">return values.to_dict()</strong>
    
    <strong class="bold">class Config:</strong>
        <strong class="bold">orm_mode = True</strong></pre>
			<p>The <a id="_idIndexMarker365"/>presence of the <code>gclass_set_to_list ()</code> and <code>trainer_object_to_map()</code> converts in <code>ProfileMembersReq</code> enables data to be populated to the child objects in the <code>gclass</code> and <code>trainer_id</code> attributes, respectively. These additional features indicate why executing <code>select()</code> can already retrieve the <em class="italic">INNER JOIN</em> queries. </p>
			<p>To build <em class="italic">LEFT JOIN</em> query transactions, the ORM has a built-in directive called <code>left_join()</code>, which is used to extract the <code>Query</code> object bearing the <em class="italic">LEFT JOIN</em> raw objects through a Python generator. The following code shows another repository class that showcases the use of <code>left_join()</code>:</p>
			<pre class="source-code">
class MemberGymClassRepository:
    
    def join_member_class(self): 
      with db_session: 
        <strong class="bold">generator_args = (m for m in Profile_Members </strong>
              <strong class="bold">for g in m.gclass)</strong>
        <strong class="bold">joins = left_join(tuple_args)        </strong>
        result = [ProfileMembersReq.from_orm(m) 
              for m in joins ]
        return result</pre>
			<p>All the repository classes can be found in the <code>/repository/pony/members.py</code> script file.</p>
			<p>Now, what <a id="_idIndexMarker366"/>makes Pony faster is that it uses an <em class="italic">identity map</em>, which contains all the record objects that have been retrieved from every single query transaction. The ORM applies the <em class="italic">Identity Map</em> design pattern to apply its caching mechanism to make read and write executions fast. It only requires memory management and monitoring to avoid memory leak problems in complex and huge applications. </p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor140"/>Running the repository transactions</h2>
			<p>Since <code>db_session</code> is already <a id="_idIndexMarker367"/>managed internally, no additional requirements will be needed from Pony for the <code>APIRouter</code> script to run the repository transactions. The repository classes are directly accessed and instantiated in each of the APIs to access the CRUD transactions.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor141"/>Creating the tables</h2>
			<p>If the tables are <a id="_idIndexMarker368"/>non-existent yet, Pony can generate those tables through its entity classes. This DDL transaction is enabled when the <code>create_tables</code> parameter of the <code>generate_mapping()</code> method of <code>db</code> is set to <code>True</code>. </p>
			<p>For the most compact and simplest ORM in terms of syntax, we have <strong class="bold">Peewee</strong>.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor142"/>Building the repository using Peewee</h1>
			<p>Among the different ORMs, Peewee<a id="_idIndexMarker369"/> is the simplest and smallest in terms of ORM features and APIs. The framework is easy to understand and use; it is not comprehensive, but it has intuitive ORM syntax. Its strength is in building and executing query transactions. </p>
			<p>Peewee is not <a id="_idIndexMarker370"/>designed for asynchronous platforms, but it can work with them by using some async-related libraries that it supports. We need to install at least <em class="italic">Python 3.7</em> for Peewee to work with FastAPI, an asynchronous framework. To install Peewee, we need to execute the following command:</p>
			<pre>pip install peewee</pre>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor143"/>Installing the database driver</h2>
			<p>The ORM<a id="_idIndexMarker371"/> needs <code>psycopg2</code> as the PostgreSQL database driver. We can install it using <code>pip</code>:</p>
			<pre>pip install psycopg2</pre>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor144"/>Creating the database connection</h2>
			<p>For Peewee to<a id="_idIndexMarker372"/> work with FastAPI, we must build a multi-threading mechanism where Peewee can cater to more than one request transaction on the same thread, and per request can do more executions simultaneously using different local threads. This customized multi-threading component, which can be created using the <code>ContextVar</code> class, bridges Peewee to the FastAPI platform. But for Peewee to utilize these threads, we also need to customize its <code>_ConnectionState</code> with the newly created threading state, <code>db_state</code>. The following code shows how <code>db_state</code> and a custom <code>_ConnectionState</code> can be derived:</p>
			<pre class="source-code">
<strong class="bold">from peewee import _ConnectionState</strong>
<strong class="bold">from contextvars import ContextVar</strong>
db_state_default = {"closed": None, "conn": None, 
         "ctx": None, "transactions": None}
<strong class="bold">db_state = ContextVar("db_state", </strong>
          <strong class="bold">default=db_state_default.copy())</strong>
class PeeweeConnectionState(<strong class="bold">_ConnectionState</strong>):
    def __init__(self, **kwargs):
        super().__setattr__("_state", <strong class="bold">db_state</strong>)
        super().__init__(**kwargs)
    def __setattr__(self, name, value):
        self._state.get()[name] = value
    def __getattr__(self, name):
        return self._state.get()[name]</pre>
			<p>To <a id="_idIndexMarker373"/>apply the new <code>db_state</code> and <code>_ConnectionState</code> classes, cited in the preceding code as <code>PeeweeConnectionState</code>, we need to open the database connection through the <code>Database</code> class. Peewee has several variations of the <code>Database</code> class, depending on the type of database the application will choose to connect to. Since we will be using PostgreSQL, <code>PostgresqlDatabase</code> is the correct class to initialize with all the necessary database details. After establishing the connection, the <code>db</code> instance will have a <code>_state</code> attribute that will point to the <code>PeeweeConnectionState</code> instance. The following snippet shows how to connect to our <em class="italic">fitness gym</em> database’s <code>fcms</code> using the database<a id="_idIndexMarker374"/> credentials:</p>
			<pre class="source-code">
<strong class="bold">from peewee import PostgresqlDatabase</strong>
db = <strong class="bold">PostgresqlDatabase</strong>(
    'fcms',
    user='postgres',
    password='admin2255',
    host='localhost',
    port=5433, 
)
<strong class="bold">db._state = PeeweeConnectionState()</strong></pre>
			<p>The<a id="_idIndexMarker375"/> preceding code also emphasizes that the default state of the database connection must be replaced with a non-blocking one that can work with the FastAPI platform. This configuration can be found in the <code>/db_config/peewee_connect.py</code> script file. Let us now build Peewee's model layer.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor145"/>Creating the tables and the domain layer</h2>
			<p>Peewee<a id="_idIndexMarker376"/> prefers <em class="italic">auto-generating tables</em> based on its model classes, unlike other ORMs. Peewee recommends <em class="italic">reverse engineering</em>, where tables are created rather than only being mapped to existing tables. Letting the application generate the tables lessens the hassle of establishing relationships and <a id="_idIndexMarker377"/>primary keys. This ORM is unique because it has an "implied" approach to creating primary keys and foreign keys. The following script shows how Peewee model classes are defined:</p>
			<pre class="source-code">
<strong class="bold">from peewee import Model, ForeignKeyField, CharField, </strong>
<strong class="bold">   IntegerField, FloatField, DateField, TimeField</strong>
<strong class="bold">from db_config.peewee_connect import db</strong>
class Signup(Model):
<strong class="bold">    username = CharField(unique=False, index=False)</strong>
<strong class="bold">    password = CharField(unique=False, index=False)</strong>
    
<strong class="bold">    class Meta:</strong>
<strong class="bold">      database = db</strong>
<strong class="bold">      db_table = 'signup'</strong></pre>
			<p>We can’t see any primary keys in the model classes presented because the Peewee engine will create them during its schema auto-generation. The physical foreign key column and the model attribute will have the same name derived from its model name, with the <code>modelname_id</code> pattern <a id="_idIndexMarker378"/>in lowercase form. If we insist on adding the primary key for the<a id="_idIndexMarker379"/> model, a conflict will occur, making Peewee dysfunctional. We must let Peewee create the physical tables from the model classes to avoid this mishap.</p>
			<p>All model classes inherit properties from the <code>Model</code> directive of the ORM. It also has column directives such as <code>IntegerField</code>, <code>FloatField</code>, <code>DateField</code>, and <code>TimeField</code> for defining the column attributes of the model classes. Moreover, each domain class has a nested <code>Meta</code> class, which registers the references to <code>database</code> and <code>db_table</code>, which is mapped to the model class. Other properties that we can set here are <code>primary_key</code>, <code>indexes</code>, and <code>constraints</code>. </p>
			<p>The only problem in having this auto-generation is when creating table relationships. Linking the foreign key attributes of the child classes to the non-existent primary keys of the parent classes is difficult before auto-generation. For instance, the following <code>Profile_Trainers</code> model implies a <em class="italic">many-to-one</em> relationship with the <code>Login</code> class, which is only defined by the <code>ForeignKeyField</code> directive with the <code>trainer</code> backreference attribute and not by the <code>login_id</code> foreign key:</p>
			<pre class="source-code">
class Profile_Trainers(Model):
<strong class="bold">    login = ForeignKeyField(Login, </strong>
<strong class="bold">         backref="trainers", unique=True)</strong>
    … … … … … …
    shift = IntegerField(unique=False, index=False)
       
<strong class="bold">    class Meta:</strong>
<strong class="bold">      database = db</strong>
<strong class="bold">      db_table = 'profile_trainers'</strong></pre>
			<p>The <code>login_id</code> column that’s <a id="_idIndexMarker380"/>generated after auto-generation can be seen in the following screenshot:</p>
			<div><div><img src="img/Figure_5.2_B17975.jpg" alt="Figure 5.2 – The generated profile_trainers schema&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – The generated profile_trainers schema</p>
			<p>Foreign key<a id="_idIndexMarker381"/> attributes are declared using the <code>ForeignKeyField</code> directive, which accepts at least three crucial parameters:</p>
			<ul>
				<li>The parent model’s name </li>
				<li>The <code>backref</code> parameter, which references the child record (if in a <em class="italic">one-to-one</em> relationship) or a set of child objects (if in a <em class="italic">one-to-many</em> or <em class="italic">many-to-one</em> relationship)</li>
				<li>The <code>unique</code> parameter, which indicates a <em class="italic">one-to-one</em> relationship when set to <code>True</code> or <code>False</code> otherwise</li>
			</ul>
			<p>After defining all the models, including their relationships, we need to call the following methods from Peewee’s <code>db</code> instance for the table mapping to occur:</p>
			<ul>
				<li><code>connect()</code> to establish the connection </li>
				<li><code>create_tables()</code> to pursue the schema generation based on its list of model classes</li>
			</ul>
			<p>The following script <a id="_idIndexMarker382"/>shows a snapshot of the class<a id="_idIndexMarker383"/> definitions, including the call to the two <code>db</code> methods:</p>
			<pre class="source-code">
<strong class="bold">class Login(Model): </strong>
    username = CharField(unique=False, index=False)
    … … … … … …
    user_type = IntegerField(unique=False, index=False)
    
    <strong class="bold">class Meta:</strong>
      <strong class="bold">database = db</strong>
      <strong class="bold">db_table = 'login'</strong>
    
<strong class="bold">class Gym_Class(Model): </strong>
    <strong class="bold">member = ForeignKeyField(Profile_Members, </strong>
          <strong class="bold">backref="members")</strong>
    <strong class="bold">trainer = ForeignKeyField(Profile_Trainers, </strong>
          <strong class="bold">backref="trainers")</strong>
    approved = IntegerField(unique=False, index=False)
       
    class Meta:
      database = db
      db_table = 'gym_class'
<strong class="bold">db.connect()</strong>
<strong class="bold">db.create_tables([Signup, Login, Profile_Members</strong>, 
     <strong class="bold">Profile_Trainers, Attendance_Member, Gym_Class],</strong>
           <strong class="bold">safe=True)</strong></pre>
			<p>As we can see, we <a id="_idIndexMarker384"/>need to set the <code>safe</code> parameter<a id="_idIndexMarker385"/> of <code>create_tables()</code> to <code>True</code> so that Peewee will only perform schema auto-generation once during the initial server startup of the application. All the model classes for the Peewee ORM can be found in the <code>/models/data/peewee_models.py</code> script file. Now, let us implement the repository layer.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor146"/>Implementing the CRUD transactions</h2>
			<p>Creating the<a id="_idIndexMarker386"/> asynchronous connection and building the model layer for the application in the Peewee ORM is tricky, but implementing its repository layer is straightforward. All the method operations are entirely derived from its model classes. For instance, <code>insert_login()</code>, which is shown in the following snippet, shows how the <code>create()</code> static method of <code>Login</code> takes the login details for record insertion: </p>
			<pre class="source-code">
from typing import Dict, List, Any
<strong class="bold">from models.data.peewee_models import Login, </strong>
   <strong class="bold">Profile_Trainers, Gym_Class, Profile_Members</strong>
from datetime import date
class LoginRepository:
    
    def <strong class="bold">insert_login</strong>(self, id:int, user:str, passwd:str, 
          approved:date, type:int) -&gt; bool: 
        try:
            <strong class="bold">Login.create(id=id, username=user, </strong>
                <strong class="bold">password=passwd, date_approved=approved, </strong>
                <strong class="bold">user_type=type)</strong>
        except Exception as e: 
           return False 
        return True</pre>
			<p>This method <a id="_idIndexMarker387"/>can be re-implemented to perform bulk inserts, but Peewee has an alternative way to pursue multiple insertions through its <code>insert_many()</code> class method. Using <code>insert_many()</code> requires more accurate column details for mapping multiple schema values. It also needs an invocation of the <code>execute()</code> method to perform all the bulk insertions and close the operation afterward.</p>
			<p>Similarly, the <code>update()</code> class method requires the <code>execute()</code> method after filtering the record that needs updating using the <code>id</code> primary key. This is shown in the following code snippet:</p>
			<pre class="source-code">
    def <strong class="bold">update_login</strong>(self, id:int, 
              details:Dict[str, Any]) -&gt; bool: 
       try:
           <strong class="bold">query = Login.update(**details).</strong>
                  <strong class="bold">where(Login.id == id)</strong>
           <strong class="bold">query.execute()</strong>
       except: 
           return False 
       return True</pre>
			<p>When it<a id="_idIndexMarker388"/> comes to record deletion, <code>delete_login()</code> shows the easy approach – that is, by using <code>delete_by_id()</code>. But the ORM has another way, which is to retrieve the record object using the <code>get()</code> class method – for example, <code>Login.get(Login.id == id)</code> – and eventually delete the record through the <code>delete_instance()</code> instance method of the record object. The following <code>delete_login()</code> transaction shows how to utilize the <code>delete_by_id()</code> class method:</p>
			<pre class="source-code">
    def <strong class="bold">delete_login</strong>(self, id:int) -&gt; bool: 
        try:
           <strong class="bold">query = Login.delete_by_id(id)</strong>
        except: 
            return False 
        return True</pre>
			<p>The following scripts, which are for <code>get_all_login()</code> and <code>get_login()</code>, highlight how Peewee retrieves records from the database. Peewee uses its <code>get()</code> class method to retrieve a single record using the primary key; the same method was applied to its <em class="italic">UPDATE</em> transaction in the previous code snippet. Similarly, Peewee uses a class method to extract multiple records, but this time, it uses the <code>select()</code> method. The<a id="_idIndexMarker389"/> resulting object can’t be encoded by FastAPI unless it’s contained in the <code>List</code> collection, which serializes the rows of data into a list of JSON-able objects:  </p>
			<pre class="source-code">
    def <strong class="bold">get_all_login</strong>(self):
        return <strong class="bold">list(Login.select())</strong>
    
    def <strong class="bold">get_login</strong>(self, id:int): 
        return <strong class="bold">Login.get(Login.id == id)</strong></pre>
			<p>On the other hand, the following repository classes show how to create <em class="italic">JOIN</em> queries using its <code>join()</code> method: </p>
			<pre class="source-code">
<strong class="bold">from peewee import JOIN</strong>
class LoginTrainersRepository:
    
    def <strong class="bold">join_login_trainers</strong>(self): 
        return <strong class="bold">list</strong>(Profile_Trainers.
          <strong class="bold">select(Profile_Trainers, Login).join(Login)</strong>)
class MemberGymClassesRepository:
    def <strong class="bold">outer_join_member_gym</strong>(self): 
        return <strong class="bold">list</strong>(Profile_Members.
          <strong class="bold">select</strong>(Profile_Members,Gym_Class).<strong class="bold">join(Gym_Class</strong>, 
                    <strong class="bold">join_type=JOIN.LEFT_OUTER)</strong>)</pre>
			<p><code>join_login_trainers()</code> of <code>LoginTrainersRepository</code> builds the <em class="italic">INNER JOIN</em> query <a id="_idIndexMarker390"/>of the <code>Profile_Trainers</code> and <code>Login</code> objects. The leftmost model indicated in the parameter of the <code>Profile_Trainers</code> object’s <code>select()</code> directive is the parent model type, followed by its child model class in a <em class="italic">one-to-one</em> relationship. The <code>select()</code> directive emits the <code>join()</code> method with the model class type, which indicates the type of records that belong to the right-hand side of the query. The <em class="italic">ON </em>condition(s) and the foreign key constraints are optional but can be declared explicitly by adding the <code>on</code> and <code>join_type</code> attributes of the <code>join()</code> construct. An example of this query is <code>outer_join_member_gym()</code> of <code>MemberGymClassesRepository</code>, which implements a <em class="italic">LEFT OUTER JOIN</em> of <code>Profile_Members</code> and <code>Gym_Class</code> using the <code>LEFT_OUTER</code> option of the <code>join_type</code> attribute of <code>join()</code>.</p>
			<p>Joins in <a id="_idIndexMarker391"/>Peewee also need the <code>list()</code> collection to serialize the retrieved records. All the repository classes for Peewee can be found in the <code>/repository/peewee/login.py</code> script.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor147"/>Running the CRUD transaction</h2>
			<p>Since Peewee’s database connection<a id="_idIndexMarker392"/> is set at the model layer, no additional requirements are required for <code>APIRouter</code> or <code>FastAPI</code> to run the CRUD transactions. API services can easily access all the repository classes without calling methods or directives from the <code>db</code> instance.</p>
			<p>So far, we have experimented with popular ORMs to integrate a relational database into the FastAPI framework. If applying an ORM is not enough for a microservice architecture, we can utilize some design patterns that can further refine the CRUD performance, such<a id="_idIndexMarker393"/> as <strong class="bold">CQRS</strong>.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor148"/>Applying the CQRS design pattern</h1>
			<p>CQRS is a <a id="_idIndexMarker394"/>microservice design pattern responsible for segregating query transactions (<em class="italic">reads</em>) from the insert, update, and delete operations (<em class="italic">writes</em>). The separation of these two groups lessens the cohesion access to these transactions, which provides less traffic and faster performance, especially when the application becomes complex. Moreover, this design pattern creates a loose-coupling feature between the<a id="_idIndexMarker395"/> API services and the repository layer, which gives us an advantage if there are several turnovers and changes in the repository layers. </p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor149"/>Defining the handler interfaces</h2>
			<p>To pursue CQRS, we need to<a id="_idIndexMarker396"/> create the two interfaces that define the query and the command transactions. The following code shows the interfaces that will identify the <em class="italic">read</em> and <em class="italic">write</em> transactions for <code>Profile_Trainers</code>:</p>
			<pre class="source-code">
class <strong class="bold">IQueryHandler</strong>: 
    pass 
class <strong class="bold">ICommandHandler</strong>: 
    pass</pre>
			<p>Here, <code>IQueryHandler</code> and <code>ICommandHandler</code> are informal interfaces because Python does not <a id="_idIndexMarker397"/>have an actual definition of an interface.</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor150"/>Creating the command and query classes</h2>
			<p>Next, we need to<a id="_idIndexMarker398"/> implement the command and query classes. The command serves as an instruction to pursue the <em class="italic">write</em> transactions. It also carries the state of the result after they have been executed. On the other hand, the query instructs the <em class="italic">read</em> transaction to retrieve record(s) from the database and contain the result afterward. Both components are serializable classes with <em class="italic">getter/setter</em> attributes. The following code shows the script for <code>ProfileTrainerCommand</code>, which uses Python’s <code>@property</code> attribute to store the state of the <em class="italic">INSERT</em> execution:</p>
			<pre class="source-code">
from typing import Dict, Any
class <strong class="bold">ProfileTrainerCommand</strong>: 
    
    def __init__(self): 
        <strong class="bold">self._details:Dict[str,Any] = dict()</strong>
        
    <strong class="bold">@property</strong>
    def details(self):
        return self._details
    <strong class="bold">@details.setter</strong>
    def details(self, details):
        self._details = details</pre>
			<p>The <code>details</code> property will store all the column values of the trainer’s profile record that need to be persisted.</p>
			<p>The following script implements a sample <em class="italic">query</em> class:</p>
			<pre class="source-code">
class <strong class="bold">ProfileTrainerListQuery</strong>: 
    
    def __init__(self): 
        <strong class="bold">self._records:List[Profile_Trainers] = list()</strong>
        
    <strong class="bold">@property</strong>
    def records(self):
        return self._records
    <strong class="bold">@records.setter</strong>
    def records(self, records):
        self._records = records</pre>
			<p>The<a id="_idIndexMarker399"/> constructor of <code>ProfileTrainerListQuery</code> prepares a dictionary object that will contain all the retrieved records after the query transaction has been executed.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor151"/>Creating the command and query handlers</h2>
			<p>We will be using our<a id="_idIndexMarker400"/> previous interfaces to define the command and query handlers. Note that the command handler accesses and executes the repository to execute the <em class="italic">write</em> transactions, while the query handler processes the <em class="italic">read</em> transactions. These handlers serve as the façade between the API services and the repository layer. The following code shows the script for <code>AddTrainerCommandHandler</code>, which manages the <em class="italic">INSERT</em> transaction for the trainer’s profile:</p>
			<pre class="source-code">
<strong class="bold">from cqrs.handlers import ICommandHandler</strong>
<strong class="bold">from repository.gino.trainers import TrainerRepository</strong>
<strong class="bold">from cqrs.commands import ProfileTrainerCommand</strong>
class AddTrainerCommandHandler(<strong class="bold">ICommandHandler</strong>): 
    
    def __init__(self): 
        <strong class="bold">self.repo:TrainerRepository = TrainerRepository()</strong>
        
    async def handle(self, 
             <strong class="bold">command:ProfileTrainerCommand</strong>) -&gt; bool:
        <strong class="bold">result = await self.repo.</strong>
               <strong class="bold">insert_trainer(command.details)</strong>
        return result</pre>
			<p>The handler<a id="_idIndexMarker401"/> depends on <code>ProfileTrainerCommand</code> for the record values that are crucial to the asynchronous execution of its <code>handle()</code> method. </p>
			<p>The following script shows a sample implementation for a query handler:</p>
			<pre class="source-code">
<strong class="bold">class ListTrainerQueryHandler(IQueryHandler): </strong>
    def __init__(self): 
        <strong class="bold">self.repo:Trai<a id="_idTextAnchor152"/>nerRepository = TrainerRepository()</strong>
        <strong class="bold">self.query:ProfileTrainerListQuery = </strong>
             <strong class="bold">ProfileTrainerListQuery()</strong>
        
    async def handle(self) -&gt; <strong class="bold">ProfileTrainerListQuery</strong>:
        data = await self.repo.get_all_member();
        self.query.records = data
        return self.query</pre>
			<p>Query handlers <a id="_idIndexMarker402"/>return their <em class="italic">query</em> to the services and not the actual values. The <code>handle()</code> method of <code>ListTrainerQueryHandler</code> returns <code>ProfileTrainerListQuery</code>, which contains the list of records from the <em class="italic">read</em> transaction. This mechanism is one of the main objectives of applying CQRS to microservices. </p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor153"/>Accessing the handlers</h2>
			<p>CQRS, aside from <a id="_idIndexMarker403"/>managing the friction between the <em class="italic">read</em> and <em class="italic">write</em> executions, does not allow the API services to interact directly with the execution of CRUD transactions. Moreover, it streamlines and simplifies the access of the CRUD transactions by assigning only the handler that’s needed by a particular service.</p>
			<p>The following script shows how <code>AddTrainerCommand</code> is only directly associated with the <code>add_trainer()</code> service and how <code>LisTrainerQueryHandler</code> is only directly associated with the <code>list_trainers()</code> service:</p>
			<pre class="source-code">
<strong class="bold">from cqrs.commands import ProfileTrainerCommand</strong>
<strong class="bold">from cqrs.queries import ProfileTrainerListQuery</strong>
<strong class="bold">from cqrs.trainers.command.create_handlers</strong> import 
      <strong class="bold">AddTrainerCommandHandler</strong>
<strong class="bold">from cqrs.trainers.query.query_handlers import </strong>
      <strong class="bold">ListTrainerQueryHandler</strong>
router = APIRouter(dependencies=[Depends(get_db)])
<strong class="bold">@router.post("/trainer/add" )</strong>
async def add_trainer(req: ProfileTrainersReq): 
    <strong class="bold">handler = AddTrainerCommandHandler()</strong>
    <strong class="bold">mem_profile = dict()</strong>
    mem_profile["id"] = req.id
    … … … … … …
    mem_profile["shift"] = req.shift
    <strong class="bold">command = ProfileTrainerCommand()</strong>
    <strong class="bold">command.details = mem_profile</strong>
    <strong class="bold">result = await handler.handle(command)</strong>
    if result == True: 
        return req 
    else: 
        return JSONResponse(content={'message':'create 
          trainer profile problem encountered'}, 
            status_code=500)
<strong class="bold">@router.get("/trainer/list")</strong>
async def list_trainers(): 
    <strong class="bold">handler = ListTrainerQueryHandler()</strong>
    <strong class="bold">query:ProfileTrainerListQuery = await handler.handle() </strong>
    return <strong class="bold">query.records</strong></pre>
			<p>We can identify<a id="_idIndexMarker404"/> transactions that are accessed frequently in <code>APIRouter</code> through CQRS. It helps us find which transactions need performance tuning and focus, which can help us avoid performance issues when the amount of access increases. When it comes to enhancement and upgrades, the design pattern can help developers find what domain to prioritize because of the separation of aspects in the repository layer. Generally, it offers flexibility to the application when its business processes need to be revamped. All the CQRS-related scripts can be found in the <code>/cqrs/</code> project folder.</p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor154"/>Summary</h1>
			<p>Applying ORM always has advantages and disadvantages for any application. It can bloat the application with so many configurations and layers of components, and it can even slow down the application if not managed well. But ORM, in general, can help optimize query development by simplifying the constructs by using its APIs and eliminating unimportant repetitive SQL scripts. Overall, it can reduce the time and cost of software development compared to using <code>cursor</code> from <code>psycopg2</code>.</p>
			<p>In this chapter, four Python ORMs were used, studied, and experimented with to help FastAPI create its repository layer. First, there is <em class="italic">SQLAlchemy</em>, which provides a boilerplated approach to creating standard and asynchronous data persistency and query operations. Then, there is <em class="italic">GINO</em>, which uses the AsyncIO environment to implement asynchronous CRUD transactions with its handy syntax. Also, there is <em class="italic">Pony</em>, the most Pythonic among the ORMs presented because it uses hardcore Python code to build its repository transactions. Lastly, there is <em class="italic">Peewee</em>, known for its concise syntax but tricky composition for the asynchronous database connection and CRUD transactions. Each ORM has its strengths and weaknesses, but all provide a logical solution rather than applying brute-force and native SQL.</p>
			<p>If the ORM needs fine-tuning, we can add some degree of optimization by using data-related design patterns such as CQRS, which minimizes friction between the "read" and "write" CRUD transactions. </p>
			<p>This chapter has highlighted the flexibility of FastAPI when utilizing ORMs to establish a connection to a relational database such as PostgreSQL. But what if we use a NoSQL database such as MongoDB to store information? Will FastAPI perform with the same level of performance when performing CRUD to and from MongoDB? The next chapter will discuss various solutions for integrating FastAPI into MongoDB.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>