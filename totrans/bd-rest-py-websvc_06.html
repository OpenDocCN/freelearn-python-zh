<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6.  Working with Models, SQLAlchemy, and Hyperlinked APIs in Flask </h1></div></div></div><p>In this chapter, we will expand the capabilities of the RESTful API that we started in the previous chapter. We will use SQLAlchemy as our ORM to work with a PostgreSQL database and we will take advantage of advanced features included in Flask and Flask-RESTful that will allow us to easily organize code for complex APIs, such as models and blueprints. In this chapter, we will:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Design a RESTful API to interact with a PostgreSQL database</li><li class="listitem" style="list-style-type: disc">Understand the tasks performed by each HTTP method</li><li class="listitem" style="list-style-type: disc">Install packages to simplify our common tasks</li><li class="listitem" style="list-style-type: disc">Create and configure the database</li><li class="listitem" style="list-style-type: disc">Write code for the models with their relationships</li><li class="listitem" style="list-style-type: disc">Use schemas to validate, serialize, and deserialize models</li><li class="listitem" style="list-style-type: disc">Combine blueprints with resourceful routing</li><li class="listitem" style="list-style-type: disc">Register the blueprint and run migrations</li><li class="listitem" style="list-style-type: disc">Create and retrieve related resources</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec71"/>Designing a RESTful API to interact with a PostgreSQL database</h1></div></div></div><p>So far, our RESTful API has performed CRUD operations on a simple dictionary that acted as a data repository. Now, we want to create a more complex RESTful API with Flask RESTful to interact with a database model that has to allow us to work with messages that are grouped into message categories. In our previous RESTful API, we used a string attribute to specify the message category for a message. In this case, we want to be able to easily retrieve all the messages that belong to a specific message category, and therefore, we will have a relationship between a message and a message category.</p><p>We must be able to perform CRUD operations on different related resources and resource collections. The following list enumerates the resources and the class name that we will create to represent the model:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Message categories (<code class="literal">Category</code> model)</li><li class="listitem" style="list-style-type: disc">Messages (<code class="literal">Message</code> model)</li></ul></div><p>The message category (<code class="literal">Category</code>) just requires an integer name, and we need the following data for a message (<code class="literal">Message</code>):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An integer identifier</li><li class="listitem" style="list-style-type: disc">A foreign key to a message category (<code class="literal">Category</code>)</li><li class="listitem" style="list-style-type: disc">A string message</li><li class="listitem" style="list-style-type: disc">The duration in seconds that will indicate the time the message has to be printed on the OLED display</li><li class="listitem" style="list-style-type: disc">The creation date and time. The timestamp will be added automatically when adding a new message to the collection</li><li class="listitem" style="list-style-type: disc">An integer counter that indicates the times the message has been printed in the OLED display</li><li class="listitem" style="list-style-type: disc">A <code class="literal">bool</code> value indicating whether the message was printed at least once on the OLED display</li></ul></div><div><div><h3 class="title"><a id="tip48"/>Tip</h3><p>We will take advantage of the many packages related to Flask RESTful and SQLAlchemy that make it easier to serialize and deserialize data, perform validations, and integrate SQLAlchemy with Flask and Flask RESTful.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec72"/>Understanding the tasks performed by each HTTP method</h1></div></div></div><p>The following table shows the HTTP verbs, the scope, and the semantics for the methods that our new API must support. Each method is composed of an HTTP verb, a scope, and all the methods have well-defined meanings for all the resources and collections:</p><div><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p>
<strong>HTTP verb</strong>
</p>
</td><td>
<p>
<strong>Scope</strong>
</p>
</td><td>
<p>
<strong>Semantics</strong>
</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Collection of message categories</p>
</td><td>
<p>Retrieve all the stored message categories in the collection and return them sorted by their name in ascending order. Each category must include the full URL for the resource. Each category must include a list with all the details for the messages that belong to the category. The messages don't have to include the category in order to avoid repeating data.</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Message category</p>
</td><td>
<p>Retrieve a single message category. The category must include the same information explained for each category when we retrieve a collection of message category.</p>
</td></tr><tr><td>
<p>
<code class="literal">POST</code>
</p>
</td><td>
<p>Collection of message categories</p>
</td><td>
<p>Create a new message category in the collection.</p>
</td></tr><tr><td>
<p>
<code class="literal">PATCH</code>
</p>
</td><td>
<p>Message category</p>
</td><td>
<p>Update the name of an existing message category.</p>
</td></tr><tr><td>
<p>
<code class="literal">DELETE</code>
</p>
</td><td>
<p>
</p><p>Message category</p><p>
</p>
</td><td>
<p>Delete an existing message category.</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Collection of messages</p>
</td><td>
<p>Retrieve all the stored messages in the collection, sorted by their message in ascending order. Each message must include its message category details, including the full URL to access the related resource. The message category details don't have to include the messages that belong to the category. The message must include the full URL to access the resource.</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Message</p>
</td><td>
<p>Retrieve a single message. The message must include the same information explained for each message when we retrieve a collection of messages.</p>
</td></tr><tr><td>
<p>
<code class="literal">POST</code>
</p>
</td><td>
<p>
</p><p>Collection of messages</p><p>
</p>
</td><td>
<p>Create a new message in the collection.</p>
</td></tr><tr><td>
<p>
<code class="literal">PATCH</code>
</p>
</td><td>
<p>Message</p>
</td><td>
<p>Update any of the following fields of an existing message: message, duration, printed_times, and printed_once.</p>
</td></tr><tr><td>
<p>
<code class="literal">DELETE</code>
</p>
</td><td>
<p>Message</p>
</td><td>
<p>Delete an existing message.</p>
</td></tr></tbody></table></div><p>In addition, our RESTful API must support the <code class="literal">OPTIONS</code> method for all the resources and collection of resources. We will use SQLAlchemy as our ORM and we will work with a PostgreSQL database. However, in case you don't want to spend time installing PostgreSQL, you can use any other database supported by SQLAlchemy, such as MySQL. In case you want the simplest database, you can work with SQLite.</p><p>In the preceding table, there are many methods and scopes. The following list enumerates the URIs for each scope mentioned in the preceding table, where <code class="literal">{id}</code> has to be replaced with the numeric id or primary key of the resource. As happened in the previous example, we want our API to differentiate collections from a single resource of the collection in the URLs. When we refer to a collection, we will use a slash (<code class="literal">/</code>) as the last character for the URL and when we refer to a single resource of the collection, we won't use a slash (<code class="literal">/</code>) as the last character for the URL:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Collection of message categories</strong>: <code class="literal">/categories/</code></li><li class="listitem" style="list-style-type: disc"><strong>Message category</strong>: <code class="literal">/category/{id}</code></li><li class="listitem" style="list-style-type: disc"><strong>Collection of messages</strong>: <code class="literal">/messages/</code></li><li class="listitem" style="list-style-type: disc"><strong>Message</strong>: <code class="literal">/message/{id}</code></li></ul></div><p>Let's consider that <code class="literal">http://localhost:5000/api/</code> is the URL for the API running on the Flask development server. We have to compose and send an HTTP request with the following HTTP verb (<code class="literal">GET</code>) and request URL (<code class="literal">http://localhost:5000/api/categories/</code>) to retrieve all the stored message categories in the collection. Each category will include a list with all the messages that belong to the category.</p><pre class="programlisting">GET http://localhost:5000/api/categories/ 
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec73"/>Installing packages to simplify our common tasks</h1></div></div></div><p>Make sure you quit Flask's development server. Remember that you just need to press <em>
<strong>Ctrl</strong>
</em> + <em>
<strong>C</strong>
</em> in the Terminal or Command Prompt window in which it is running. Now, we will install many additional packages. Make sure you have activated the virtual environment we have created in the previous chapter and we named <code class="literal">Flask01</code>. In case you created a new virtual environment to work with this example or you downloaded the sample code for the book, make sure you install the packages we used in the previous example.</p><p>After you activate the virtual environment, it is time to run commands that will be the same for either macOS, Linux, or Windows. We can install all the necessary packages with pip with a single command. However, we will run independent commands to make it easier to detect any problems in case a specific installation fails.</p><p>Now, we must run the following command to install Flask-SQLAlchemy with pip. Flask-SQLAlchemy adds support for the SQLAlchemy ORM to Flask applications. This extension simplifies executing common SQLAlchemy tasks within a Flask application. SQLAlchemy is a dependency for Flask-SQLAlchemy, and therefore, pip will install it automatically, too:</p><pre class="programlisting">
<strong>pip install Flask-SQLAlchemy</strong>
</pre><p>The last lines of the output will indicate all the packages that have been successfully installed, including <code class="literal">SQLAlchemy</code> and <code class="literal">Flask-SQLAlchemy</code>:</p><pre class="programlisting">
<strong>Installing collected packages: SQLAlchemy, Flask-SQLAlchemy</strong>
<strong>  Running setup.py install for SQLAlchemy</strong>
<strong>  Running setup.py install for Flask-SQLAlchemy</strong>
<strong>Successfully installed Flask-SQLAlchemy-2.1 SQLAlchemy-1.0.14</strong>
</pre><p>Run the following command to install Flask-Migrate with pip. Flask-Migrate uses the Alembic package to handle SQLAlchemy database migrations for Flask applications. We will use Flask-Migrate to set up our PostgreSQL database. Flask-Script is one of the dependencies for Flask-Migrate, and therefore, pip will install it automatically. Flask-Script adds support for writing external scripts in Flask, including scripts to set up a database.</p><pre class="programlisting">
<strong>pip install Flask-Migrate</strong>
</pre><p>The last lines for the output will indicate all the packages that have been successfully installed, including <code class="literal">Flask-Migrate</code> and <code class="literal">Flask-Script</code>. The other installed packages are additional dependencies:</p><pre class="programlisting">
<strong>Installing collected packages: Mako, python-editor, alembic, Flask-Script, Flask-Migrate</strong>
<strong>  Running setup.py install for Mako</strong>
<strong>  Running setup.py install for python-editor</strong>
<strong>  Running setup.py install for alembic</strong>
<strong>  Running setup.py install for Flask-Script</strong>
<strong>  Running setup.py install for Flask-Migrate</strong>
<strong>Successfully installed Flask-Migrate-2.0.0 Flask-Script-2.0.5 Mako-1.0.4 alembic-0.8.7 python-editor-1.0.1</strong>
</pre><p>Run the following command to install marshmallow with pip. Marshmallow is a lightweight library for converting complex datatypes to and from native Python datatypes. Marshmallow provides schemas that we can use to validate input data, deserialize input data to app-level objects, and serialize app-level objects to Python primitive types:</p><pre class="programlisting">
<strong>pip install marshmallow</strong>
</pre><p>The last lines for the output will indicate <code class="literal">marshmallow</code> has been successfully installed:</p><pre class="programlisting">
<strong>Installing collected packages: marshmallow</strong>
<strong>Successfully installed marshmallow-2.9.1</strong>
</pre><p>Run the following command to install Marshmallow-sqlalchemy with pip. Marshmallow-sqlalchemy provides SQLAlchemy integration with the previously installed marshmallow validation, serialization, and deserialization lightweight library:</p><pre class="programlisting">
<strong>pip install marshmallow-sqlalchemy</strong>
</pre><p>The last lines for the output will indicate <code class="literal">marshmallow-sqlalchemy</code> has been successfully installed:</p><pre class="programlisting">
<strong>Installing collected packages: marshmallow-sqlalchemy</strong>
<strong>Successfully installed marshmallow-sqlalchemy-0.10.0</strong>
</pre><p>Finally, run the following command to install Flask-Marshmallow with pip. Flask-Marshmallow integrates the previously installed <code class="literal">marshmallow</code> library with Flask applications and makes it easy to generate a URL and Hyperlink fields:</p><pre class="programlisting">
<strong>pip install Flask-Marshmallow</strong>
</pre><p>The last lines for the output will indicate <code class="literal">Flask-Marshmallow</code> has been successfully installed:</p><pre class="programlisting">
<strong>Installing collected packages: Flask-Marshmallow</strong>
<strong>Successfully installed Flask-Marshmallow-0.7.0</strong>
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec74"/>Creating and configuring the database</h1></div></div></div><p>Now, we will create the PostgreSQL database that we will use as a repository for our API. You will have to download and install a PostgreSQL database in case you aren't already running it in your computer or in a development server. You can download and install this database management system from its web page: <a class="ulink" href="http://www.postgresql.org">http://www.postgresql.org</a>. In case you are working with macOS, <code class="literal">Postgres.app</code> provides a really easy way to install and use PostgreSQL on this operating system: <a class="ulink" href="http://postgresapp.com">http://postgresapp.com</a>:</p><div><div><h3 class="title"><a id="tip49"/>Tip</h3><p>You have to make sure that the PostgreSQL bin folder is included in the <code class="literal">PATH</code> environmental variable. You should be able to execute the <code class="literal">psql</code> command-line utility from your current Terminal or Command Prompt. In case the folder isn't included in the PATH, you will receive an error indicating that the <code class="literal">pg_config</code> file cannot be found when trying to install the <code class="literal">psycopg2</code> package. In addition, you will have to use the full path to each of the PostgreSQL command-line tools we will use in the next steps.</p></div></div><p>We will use the PostgreSQL command-line tools to create a new database named <code class="literal">messages</code>. In case you already have a PostgreSQL database with this name, make sure that you use another name in all the commands and configurations. You can perform the same task with any PostgreSQL GUI tool. In case you are developing on Linux, it is necessary to run the commands as the <code class="literal">postgres</code> user. Run the following command in macOS or Windows to create a new database named <code class="literal">messages</code>. Note that the command won't produce any output:</p><pre class="programlisting">
<strong>createdb messages</strong>
</pre><p>In Linux, run the following command to use the <code class="literal">postgres</code> user:</p><pre class="programlisting">
<strong>sudo -u postgres createdb messages</strong>
</pre><p>Now, we will use the <code class="literal">psql</code> command-line tool to run some SQL statements to create a specific user that we will use in Flask and assign the necessary roles for it. In macOS or Windows, run the following command to launch psql:</p><pre class="programlisting">
<strong>psql</strong>
</pre><p>In Linux, run the following command to use the postgres user:</p><pre class="programlisting">
<strong>sudo -u psql</strong>
</pre><p>Then, run the following SQL statements and finally enter \q to exit the psql command-line tool. Replace user_name with your desired user name to use in the new database and password with your chosen password. We will use the user name and password in the Flask configuration. You don't need to run the steps in case you are already working with a specific user in PostgreSQL and you have already granted privileges to the database for the user. You will see the output indicating that the permission was granted.</p><pre class="programlisting">
<strong>CREATE ROLE user_name WITH LOGIN PASSWORD 'password';</strong>
<strong>GRANT ALL PRIVILEGES ON DATABASE messages TO user_name;</strong>
<strong>ALTER USER user_name CREATEDB;</strong>
<strong>\q</strong>
</pre><p>It is necessary to install the Psycopg 2 package (psycopg2). This package is a Python-PostgreSQL Database Adapter and SQLAlchemy will use it to interact with our recently created PostgreSQL database.</p><p>Once we made sure that the PostgreSQL <code class="literal">bin</code> folder is included in the PATH environmental variable, we just need to run the following command to install this package:</p><pre class="programlisting">
<strong>pip install psycopg2</strong>
</pre><p>The last lines of the output will indicate that the <code class="literal">psycopg2</code> package has been successfully installed:</p><pre class="programlisting">
<strong>Collecting psycopg2</strong>
<strong>Installing collected packages: psycopg2</strong>
<strong>  Running setup.py install for psycopg2</strong>
<strong>Successfully installed psycopg2-2.6.2</strong>
</pre><p>In case you are using the same virtual environment that we created for the previous example, the <code class="literal">api</code> folder already exists. If you create a new virtual environment, create a folder named <code class="literal">api</code> within the root folder for the created virtual environment.</p><p>Create a new <code class="literal">config.py</code> file within the <code class="literal">api</code> folder. The following lines show the code that declares variables that determine the configuration for Flask and SQLAlchemy. The <code class="literal">SQL_ALCHEMY_DATABASE_URI</code> variable generates an SQLAlchemy URI for the PostgreSQL database.</p><p>Make sure you specify the desired database name in the value for <code class="literal">DB_NAME</code> and that you configure the user, password, host, and port based on your PostgreSQL configuration. In case you followed the previous steps, use the settings specified in these steps. The code file for the sample is included in the <code class="literal">restful_python_chapter_06_01</code> folder:</p><pre class="programlisting">import os 
 
 
basedir = os.path.abspath(os.path.dirname(__file__)) 
DEBUG = True 
PORT = 5000 
HOST = "127.0.0.1" 
SQLALCHEMY_ECHO = False 
SQLALCHEMY_TRACK_MODIFICATIONS = True 
SQLALCHEMY_DATABASE_URI = "postgresql://{DB_USER}:{DB_PASS}@{DB_ADDR}/{DB_NAME}".format(DB_USER="user_name", DB_PASS="password", DB_ADDR="127.0.0.1", DB_NAME="messages") 
SQLALCHEMY_MIGRATE_REPO = os.path.join(basedir, 'db_repository') 
</pre><p>We will specify the module created earlier as an argument to a function that will create a <em>Flask</em> app. This way, we have one module that specifies all the values for the different configuration variables and another module that creates a <em>Flask</em> app. We will create the Flask app factory as our final step towards our new API.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec75"/>Creating models with their relationships</h1></div></div></div><p>Now, we will create the models that we can use to represent and persist the message categories, messages, and their relationships. Open the <code class="literal">api/models.py</code> file and replace its contents with the following code. The lines that declare fields related to other models are highlighted in the code listing. In case you created a new virtual environment, create a new <code class="literal">models.py</code> file within the <code class="literal">api</code> folder. The code file for the sample is included in the <code class="literal">restful_python_chapter_06_01</code> folder:</p><pre class="programlisting">from marshmallow import Schema, fields, pre_load 
from marshmallow import validate 
from flask_sqlalchemy import SQLAlchemy 
from flask_marshmallow import Marshmallow 
 
 
db = SQLAlchemy() 
ma = Marshmallow() 
 
 
class AddUpdateDelete():    
    def add(self, resource): 
        db.session.add(resource) 
        return db.session.commit() 
 
    def update(self): 
        return db.session.commit() 
 
    def delete(self, resource): 
        db.session.delete(resource) 
        return db.session.commit() 
 
 
class Message(db.Model, AddUpdateDelete): 
    id = db.Column(db.Integer, primary_key=True) 
    message = db.Column(db.String(250), unique=True, nullable=False) 
    duration = db.Column(db.Integer, nullable=False) 
    creation_date = db.Column(db.TIMESTAMP, server_default=db.func.current_timestamp(), nullable=False) 
    <strong>category_id = db.Column(db.Integer, db.ForeignKey('category.id', ondelete='CASCADE'), nullable=False) 
    category = db.relationship('Category', backref=db.backref('messages', lazy='dynamic' , order_by='Message.message'))</strong> 
    printed_times = db.Column(db.Integer, nullable=False, server_default='0') 
    printed_once = db.Column(db.Boolean, nullable=False, server_default='false') 
 
    def __init__(self, message, duration, category): 
        self.message = message 
        self.duration = duration 
        self.category = category 
 
 
class Category(db.Model, AddUpdateDelete): 
    id = db.Column(db.Integer, primary_key=True) 
    name = db.Column(db.String(150), unique=True, nullable=False) 
 
    def __init__(self, name): 
        self.name = name 
</pre><p>First, the code creates an instance of the <code class="literal">flask_sqlalchemy.SQLAlchemy</code> class named <code class="literal">db</code>. This instance will allow us to control the SQLAlchemy integration for our Flask application. In addition, the instance will provide access to all the SQLAlchemy functions and classes.</p><p>Then, the code creates an instance of the <code class="literal">flask_marshmallow.Marshmallow</code> class named <code class="literal">ma</code>. It is very important to create the <code class="literal">flask_sqlalchemy.SQLAlchemy</code> instance before the <code class="literal">Marshmallow</code> instance, and therefore, order matters in this case. Marshmallow is a wrapper class that integrates Mashmallow with a <em>Flask</em> application. The instance named <code class="literal">ma</code> will provide access to the <code class="literal">Schema</code> class, the fields defined in <code class="literal">marshmallow.fields</code>, and the Flask-specific fields declared in <code class="literal">flask_marshmallow.fields</code>. We will use them later when we declare the schemas related to our models.</p><p>The code creates the <code class="literal">AddUpdateDelete</code> class that declares the following three methods to add, update, and delete a resource through SQLAlchemy sessions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">add</code>: This method receives the object to be added in the <code class="literal">resource</code> argument and calls the <code class="literal">db.session.add</code> method with the received resource as an argument to create the object in the underlying database. Finally, the code commits the session.</li><li class="listitem" style="list-style-type: disc"><code class="literal">update</code>: This method just commits the session to persist the changes made to the objects in the underlying database.</li><li class="listitem" style="list-style-type: disc"><code class="literal">delete</code>: This method receives the object to be deleted in the <code class="literal">resource</code> argument and calls the <code class="literal">db.session.delete</code> method with the received resource as an argument to remove the object in the underlying database. Finally, the code commits the session.</li></ul></div><p>The code declares the following two models, specifically, two classes, as a subclass of both the <code class="literal">db.Model</code>, and the <code class="literal">AddUpdateDelete</code> classes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Message</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Category</code></li></ul></div><p>We specified the field types, maximum lengths, and defaults for many attributes. The attributes that represent fields without any relationship are instances of the <code class="literal">db.Column</code> class. Both models declare an <code class="literal">id</code> attribute and specify the <code class="literal">True</code> value for the <code class="literal">primary_key</code> argument to indicate it is the primary key. SQLAlchemy will use the data to generate the necessary tables in the PostgreSQL database.</p><p>The <code class="literal">Message</code> model declares the <code class="literal">category</code> field with the following line:</p><pre class="programlisting">category = db.relationship('Category', backref=db.backref('messages', lazy='dynamic', order_by='Message.message')) 
</pre><p>The previous line uses the db.relationship function to provide a many-to-one relationship to the Category model. The backref argument specifies a call to the db.backref function with 'messages' as the first value that indicates the name to use for the relation from the related Category object back to a Message object. The order_by argument specifies 'Message.message' because we want the messages for each category to be sorted by the value of the message field in ascending order.</p><p>Both models declare a constructor, that is, the <code class="literal">__init__</code> method. This constructor for the <code class="literal">Message</code> model receives many arguments and uses them to initialize the attributes with the same names: <code class="literal">message</code>, <code class="literal">duration</code>, and <code class="literal">category</code>. The constructor for the <code class="literal">Category</code> model receives a <code class="literal">name</code> argument and uses it to initialize the attribute with the same name.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec76"/>Creating schemas to validate, serialize, and deserialize models</h1></div></div></div><p>Now, we will create the Flask-Marshmallow schemas that we will use to validate, serialize, and deserialize the previously declared <code class="literal">Category</code> and <code class="literal">Message</code> models and their relationships. Open the <code class="literal">api/models.py</code> file and add the following code after the existing lines. The lines that declare the fields related to the other schemas are highlighted in the code listing. The code file for the sample is included in the <code class="literal">restful_python_chapter_06_01</code> folder:</p><pre class="programlisting">class CategorySchema(ma.Schema): 
    id = fields.Integer(dump_only=True) 
    name = fields.String(required=True, validate=validate.Length(3)) 
    url = ma.URLFor('api.categoryresource', id='&lt;id&gt;', _external=True) 
   <strong> messages = fields.Nested('MessageSchema', many=True, exclude=('category',))</strong> 
 
 class MessageSchema(ma.Schema): 
    id = fields.Integer(dump_only=True) 
    message = fields.String(required=True, validate=validate.Length(1)) 
    duration = fields.Integer() 
    creation_date = fields.DateTime() 
    category = fields.Nested(CategorySchema, only=['id', 'url', 'name'], required=True) 
    printed_times = fields.Integer() 
    printed_once = fields.Boolean() 
    url = ma.URLFor('api.messageresource', id='&lt;id&gt;', _external=True) 
 
    @pre_load 
    def process_category(self, data): 
        category = data.get('category') 
        if category: 
            if isinstance(category, dict): 
                category_name = category.get('name') 
            else: 
                category_name = category 
            category_dict = dict(name=category_name)                 
        else: 
            category_dict = {} 
        data['category'] = category_dict 
        return data 
</pre><p>The code declares the following two schemas, specifically, two subclasses of the <code class="literal">ma.Schema</code> class:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">CategorySchema</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">MessageSchema</code></li></ul></div><p>We don't use the Flask-Marshmallow features that allow us to automatically determine the appropriate type for each attribute based on the fields declared in a model because we want to use specific options for each field. We declare the attributes that represent fields as instances of the appropriate class declared in the <code class="literal">marshmallow.fields</code> module. Whenever we specify the <code class="literal">True</code> value for the <code class="literal">dump_only</code> argument, it means that we want the field to be read-only. For example, we won't be able to provide a value for the <code class="literal">id</code> field in any of the schemas. The value for this field will be automatically generated by the auto-increment primary key in the database.</p><p>The <code class="literal">CategorySchema</code> class declares the <code class="literal">name</code> attribute as an instance of <code class="literal">fields.String</code>. The <code class="literal">required</code> argument is set to <code class="literal">True</code> to specify that the field cannot be an empty string. The <code class="literal">validate</code> argument is set to <code class="literal">validate.Length(3)</code> to specify that the field must have a minimum length of 3 characters.</p><p>The class declares the <code class="literal">url</code> field with the following line:</p><pre class="programlisting">url = ma.URLFor('api.categoryresource', id='&lt;id&gt;', _external=True) 
</pre><p>The <code class="literal">url</code> attribute is an instance of the <code class="literal">ma.URLFor</code> class, and this field will output the full URL of the resource, that is, of the message category resource. The first argument is the Flask endpoint name-<code class="literal">'api.categoryresource'</code>. We will create a <code class="literal">CategoryResource</code> class later and the <code class="literal">URLFor</code> class will use it to generate the URL. The <code class="literal">id</code> argument specifies <code class="literal">'&lt;id&gt;'</code> because we want the <code class="literal">id</code> to be pulled from the object to be serialized. The <code class="literal">id</code> string enclosed within less than (<code class="literal">&lt;</code>) and greater than (<code class="literal">&gt;</code>) symbols specifies that we want the field to be pulled from the object that has to be serialized. The <code class="literal">_external</code> attribute is set to <code class="literal">True</code> because we want to generate the full URL for the resource. This way, each time we serialize a <code class="literal">Category</code>, it will include the full URL for the resource in the <code class="literal">url</code> key.</p><div><div><h3 class="title"><a id="tip50"/>Tip</h3><p>In this case, we are using our insecure API behind HTTP. In case our API is configured with HTTPS, we should set the <code class="literal">_scheme</code> argument to <code class="literal">'https'</code> when we create the <code class="literal">ma.URLFor</code> instance.</p></div></div><p>The class declares the <code class="literal">messages</code> field with the following line:</p><pre class="programlisting">messages = fields.Nested('MessageSchema', many=True, exclude=('category',)0029 
</pre><p>The <code class="literal">messages</code> attribute is an instance of the <code class="literal">marshmallow.fields.Nested</code> class, and this field will nest a collection of <code class="literal">Schema</code>, and therefore, we specify <code class="literal">True</code> for the <code class="literal">many</code> argument. The first argument specifies the name for the nested <code class="literal">Schema</code> class as a string. We declare the <code class="literal">MessageSchema</code> class after we defined the <code class="literal">CategorySchema</code> class. Thus, we specify the <code class="literal">Schema</code> class name as a string instead of using the type that we haven't defined yet.</p><p>In fact, we will end up with two objects that nest to each other, that is, we will create a two-way nesting between categories and messages. We use the <code class="literal">exclude</code> parameter with a tuple of string to indicate that we want the <code class="literal">category</code> field to be excluded from the fields that are serialized for each message. This way, we can avoid infinite recursion because the inclusion of the category field would serialize all the messages related to the category.</p><p>When we declared the <code class="literal">Message</code> model, we used the <code class="literal">db.relationship</code> function to provide a many-to-one relationship to the <code class="literal">Category</code> model. The <code class="literal">backref</code> argument specified a call to the <code class="literal">db.backref</code> function with <code class="literal">'messages'</code> as the first value that indicates the name to use for the relation from the related <code class="literal">Category</code> object back to a <code class="literal">Message</code> object. With the previously explained line, we created the messages fields that uses the same name we indicated for the <code class="literal">db.backref</code> function.</p><p>The <code class="literal">MessageSchema</code> class declares the <code class="literal">message</code> attribute as an instance of <code class="literal">fields.String</code>. The <code class="literal">required</code> argument is set to <code class="literal">True</code> to specify that the field cannot be an empty string. The <code class="literal">validate</code> argument is set to <code class="literal">validate.Length(1)</code> to specify that the field must have a minimum length of 1 character. The class declares the <code class="literal">duration</code>, <code class="literal">creation_date</code>, <code class="literal">printed_times</code> and <code class="literal">printed_once</code> fields with the corresponding classes based on the types we used in the <code class="literal">Message</code> model.</p><p>The class declares the <code class="literal">category</code> field with the following line:</p><pre class="programlisting">category = fields.Nested(CategorySchema, only=['id', 'url', 'name'], required=True) 
</pre><p>The <code class="literal">category</code> attribute is an instance of the <code class="literal">marshmallow.fields.Nested</code> class and this field will nest a single <code class="literal">CategorySchema</code>. We specify <code class="literal">True</code> for the <code class="literal">required</code> argument because a message must belong to a category. The first argument specifies the name for the nested <code class="literal">Schema</code> class. We already declared the <code class="literal">CategorySchema</code> class, and therefore, we specify <code class="literal">CategorySchema</code> as the value for the first argument. We use the only parameter with a list of string to indicate the field names that we want to be included when the nested <code class="literal">CategorySchema</code> is serialized. We want the <code class="literal">id</code>, <code class="literal">url</code>, and <code class="literal">name</code> fields to be included. We don't specify the <code class="literal">messages</code> field because we don't want the category to serialize the list of messages that belong to it.</p><p>The class declares the <code class="literal">url</code> field with the following line:</p><pre class="programlisting">url = ma.URLFor('api.messageresource', id='&lt;id&gt;', _external=True) 
</pre><p>The <code class="literal">url</code> attribute is an instance of the <code class="literal">ma.URLFor</code> class and this field will output the full URL of the resource, that is, of the message resource. The first argument is the Flask endpoint name: <code class="literal">'api.messageresource'</code>. We will create a <code class="literal">MessageResource</code> class later and the <code class="literal">URLFor</code> class will use it to generate the URL. The <code class="literal">id</code> argument specifies <code class="literal">'&lt;id&gt;'</code> because we want the <code class="literal">id</code> to be pulled from the object to be serialized. The <code class="literal">_external</code> attribute is set to <code class="literal">True</code> because we want to generate the full URL for the resource. This way, each time we serialize a <code class="literal">Message</code>, it will include the full URL for the resource in the <code class="literal">url</code> key.</p><p>The <code class="literal">MessageSchema</code> class declares a <code class="literal">process_category</code> method that uses the <code class="literal">@pre_load</code> decorator, specifically, <code class="literal">marshmallow.pre_load</code>. This decorator registers a method to invoke before deserializing an object. This way, before Marshmallow deserializes a message, the <code class="literal">process_category</code> method will be executed.</p><p>The method receives the data to be deserialized in the <code class="literal">data</code> argument and it returns the processed data. When we receive a request to <code class="literal">POST</code> a new message, the category name can be specified in a key named <code class="literal">'category'</code>. If a category with the specified name exists, we will use the existing category as the one that is related to the new message. If a category with the specified name doesn't exist, we will create a new category and then we will use this new category as the one that is related to the new message. This way, we make it easy for the user to create new messages.</p><p>The <code class="literal">data</code> argument might have a category name specified as a string for the <code class="literal">'category'</code> key. However, in other cases, the <code class="literal">'category'</code> key will include the key-value pairs with the field name and field values for an existing category. The code in the <code class="literal">process_category</code> method checks the value for the <code class="literal">'category'</code> key and returns a dictionary with the appropriate data to make it sure that we are able to deserialize a category with the appropriate key-value pairs, no matter the differences of the incoming data. Finally, the methods returned the processed dictionary. We will dive deep on the work done by the <code class="literal">process_category</code> method later when we start composing and sending HTTP requests to the API.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec77"/>Combining blueprints with resourceful routing</h1></div></div></div><p>Now, we will create the resources that compose our main building blocks for the RESTful API. First, we will create a few instances that we will use in the different resources. Then, we will create a <code class="literal">MessageResource</code> class, that we will use to represent the message resource. Create a new <code class="literal">views.py</code> file within the <code class="literal">api</code> folder and add the following lines. The code file for the sample is included in the <code class="literal">restful_python_chapter_06_01</code> folder, as shown:</p><pre class="programlisting">from flask import Blueprint, request, jsonify, make_response 
from flask_restful import Api, Resource 
from models import db, Category, CategorySchema, Message, MessageSchema 
from sqlalchemy.exc import SQLAlchemyError 
import status 
 
 
api_bp = Blueprint('api', __name__) 
category_schema = CategorySchema() 
message_schema = MessageSchema() 
api = Api(api_bp) 
 
 
class MessageResource(Resource): 
<strong>    def get(self, id):</strong> 
        message = Message.query.get_or_404(id) 
        result = message_schema.dump(message).data 
        return result 
 
   <strong> def patch(self, id):</strong> 
        message = Message.query.get_or_404(id) 
        message_dict = request.get_json(force=True) 
        if 'message' in message_dict: 
            message.message = message_dict['message'] 
        if 'duration' in message_dict: 
            message.duration = message_dict['duration'] 
        if 'printed_times' in message_dict: 
            message.printed_times = message_dict['printed_times'] 
        if 'printed_once' in message_dict: 
            message.printed_once = message_dict['printed_once'] 
        dumped_message, dump_errors = message_schema.dump(message) 
        if dump_errors: 
            return dump_errors, status.HTTP_400_BAD_REQUEST 
        validate_errors = message_schema.validate(dumped_message) 
        #errors = message_schema.validate(data) 
        if validate_errors: 
            return validate_errors, status.HTTP_400_BAD_REQUEST 
        try: 
            message.update() 
            return self.get(id) 
        except SQLAlchemyError as e: 
                db.session.rollback() 
                resp = jsonify({"error": str(e)}) 
                return resp, status.HTTP_400_BAD_REQUEST 
          
    <strong>def delete(self, id):</strong> 
        message = Message.query.get_or_404(id) 
        try: 
            delete = message.delete(message) 
            response = make_response() 
            return response, status.HTTP_204_NO_CONTENT 
        except SQLAlchemyError as e: 
                db.session.rollback() 
                resp = jsonify({"error": str(e)}) 
                return resp, status.HTTP_401_UNAUTHORIZED 
</pre><p>The first lines declare the imports and create the following instances that we will use in the different classes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">api_bp</code>: It is an instance of the <code class="literal">flask.Blueprint</code> class that will allow us to factor the Flask application into this blueprint. The first argument specifies the URL prefix on which we want to register the blueprint: <code class="literal">'api'</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">category_schema</code>: It is an instance of the <code class="literal">CategorySchema</code> class we declared in the <code class="literal">models.py</code> module. We will use <code class="literal">category_schema</code> to validate, serialize, and deserialize categories.</li><li class="listitem" style="list-style-type: disc"><code class="literal">message_schema</code>: It is an instance of the <code class="literal">MessageSchema</code> class we declared in the <code class="literal">models.py</code> module. We will use <code class="literal">message_schema</code> to validate, serialize and, deserialize categories.</li><li class="listitem" style="list-style-type: disc"><code class="literal">api</code>: It is an instance of the <code class="literal">flask_restful.Api</code> class that represents the main entry point for the application. We pass the previously created <code class="literal">flask.Blueprint</code> instance named <code class="literal">api_bp</code> as an argument to link the <code class="literal">Api</code> to the <code class="literal">Blueprint</code>.</li></ul></div><p>The <code class="literal">MessageResource</code> class is a subclass of <code class="literal">flask_restful.Resource</code> and declares the following three methods that will be called when the HTTP method with the same name arrives as a request on the represented resource:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">get</code>: This method receives the id of the message that has to be retrieved in the <code class="literal">id</code> argument. The code calls the <code class="literal">Message.query.get_or_404</code> method to return an HTTP <code class="literal">404 Not Found</code> status in case there is no message with the requested id in the underlying database. In case the message exists, the code calls the <code class="literal">message_schema.dump</code> method with the retrieved message as an argument to use the <code class="literal">MessageSchema</code> instance to serialize the <code class="literal">Message</code> instance whose <code class="literal">id</code> matches the specified <code class="literal">id</code>. The <code class="literal">dump</code> method takes the <code class="literal">Message</code> instance and applies the field filtering and output formatting specified in the <code class="literal">MessageSchema</code> class. The code returns the <code class="literal">data</code> attribute of the result returned by the <code class="literal">dump</code> method, that is, the serialized message in JSON format as the body, with the default HTTP <code class="literal">200 OK</code> status code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">delete</code>: This method receives the id of the message that has to be deleted in the <code class="literal">id</code> argument. The code calls the <code class="literal">Message.query.get_or_404</code> method to return an HTTP <code class="literal">404 Not Found</code> status in case there is no message with the requested id in the underlying database. In case the message exists, the code calls the <code class="literal">message.delete</code> method with the retrieved message as an argument to use the <code class="literal">Message</code> instance to erase itself from the database. Then, the code returns an empty response body and a <code class="literal">204 No Content</code> status code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">patch</code>: This method receives the id of the message that has to be updated or patched in the <code class="literal">id</code> argument. The code calls the <code class="literal">Message.query.get_or_404</code> method to return an HTTP <code class="literal">404 Not Found</code> status in case there is no message with the requested id in the underlying database. In case the message exists, the code calls the <code class="literal">request.get_json</code> method to retrieve the key-value pairs received as arguments with the request. The code updates specific attributes in case they have new values in the <code class="literal">message_dict</code> dictionary in the <code class="literal">Message</code> instance: <code class="literal">message</code>. Then, the code calls the <code class="literal">message_schema.dump</code> method to retrieve any errors generated when serializing the updated message. In case there were errors, the code returns the errors and an HTTP <code class="literal">400 Bad Request</code> status. If the serialization didn't generate errors, the code calls the <code class="literal">message_schema.validate</code> method to retrieve any errors generated while validating the updated message. In case there were validation errors, the code returns the validation errors and an HTTP <code class="literal">400 Bad Request</code> status. If the validation is successful, the code calls the update method for the Message instance to persist the changes in the database and returns the results of calling the previously explained <code class="literal">self.get</code> method with the id of the updated message as an argument. This way, the method returns the serialized updated message in JSON format as the body, with the default HTTP <code class="literal">200 OK</code> status code.</li></ul></div><p>Now, we will create a <code class="literal">MessageListResource</code> class that we will use to represent the collection of messages. Open the previously created <code class="literal">api/views.py</code> file and add the following lines. The code file for the sample is included in the <code class="literal">restful_python_chapter_06_01</code> folder:</p><pre class="programlisting">class MessageListResource(Resource): 
   <strong> def get(self):</strong> 
        messages = Message.query.all() 
        result = message_schema.dump(messages, many=True).data 
        return result 
 
  <strong>  def post(self):</strong> 
        request_dict = request.get_json() 
        if not request_dict: 
            response = {'message': 'No input data provided'} 
            return response, status.HTTP_400_BAD_REQUEST 
        errors = message_schema.validate(request_dict) 
        if errors: 
            return errors, status.HTTP_400_BAD_REQUEST 
        try: 
            category_name = request_dict['category']['name'] 
            category = Category.query.filter_by(name=category_name).first() 
            if category is None: 
                # Create a new Category 
                category = Category(name=category_name) 
                db.session.add(category) 
            # Now that we are sure we have a category 
            # create a new Message 
            message = Message( 
                message=request_dict['message'], 
                duration=request_dict['duration'], 
                category=category) 
            message.add(message) 
            query = Message.query.get(message.id) 
            result = message_schema.dump(query).data 
            return result, status.HTTP_201_CREATED 
        except SQLAlchemyError as e: 
            db.session.rollback() 
            resp = jsonify({"error": str(e)}) 
            return resp, status.HTTP_400_BAD_REQUEST 
</pre><p>The <code class="literal">MessageListResource</code> class is a subclass of <code class="literal">flask_restful.Resource</code> and declares the following two methods that will be called when the <code class="literal">HTTP</code> method with the same name arrives as a request on the represented resource:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">get</code>: This method returns a list with all the <code class="literal">Message</code> instances saved in the database. First, the code calls the <code class="literal">Message.query.all</code> method to retrieve all the <code class="literal">Message</code> instances persisted in the database. Then, the code calls the <code class="literal">message_schema.dump</code> method with the retrieved messages and the <code class="literal">many</code> argument set to <code class="literal">True</code> to serialize the iterable collection of objects. The <code class="literal">dump</code> method will take each <code class="literal">Message</code> instance retrieved from the database and apply the field filtering and output formatting specified the <code class="literal">MessageSchema</code> class. The code returns the <code class="literal">data</code> attribute of the result returned by the dump method, that is, the serialized messages in JSON format as the body with the default HTTP <code class="literal">200 OK</code> status code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">post</code>: This method retrieves the key-value pairs received in the JSON body, creates a new <code class="literal">Message</code> instance and persists it in the database. In case the specified category name exists, it uses the existing category. Otherwise, the method creates a new <code class="literal">Category</code> instance and associates the new message to this new category. First, the code calls the <code class="literal">request.get_json</code> method to retrieve the key-value pairs received as arguments with the request. Then, the code calls the <code class="literal">message_schema.validate</code> method to validate the new message built with the retrieved key-value pairs. Remember that the <code class="literal">MessageSchema</code> class will execute the previously explained <code class="literal">process_category</code> method before we call the validate method, and therefore, the data will be processed before the validation takes place. In case there were validation errors, the code returns the validation errors and an HTTP <code class="literal">400 Bad Request</code> status. If the validation is successful, the code retrieves the category name received in the JSON body, specifically in the value for the <code class="literal">'name'</code> key of the <code class="literal">'category'</code> key. Then, the code calls the <code class="literal">Category.query.filter_by</code> method to retrieve a category that matches the retrieved category name. If no match is found, the code creates a new <code class="literal">Category</code> with the retrieved name and persists in the database. Then, the code creates a new message with the <code class="literal">message</code>, <code class="literal">duration</code>, and the appropriate <code class="literal">Category</code> instance, and persists it in the database. Finally, the code returns the serialized saved message in JSON format as the body, with the HTTP <code class="literal">201 Created</code> status code.</li></ul></div><p>Now, we will create a <code class="literal">CategoryResource</code> class that we will use to represent a category resource. Open the previously created <code class="literal">api/views.py</code> file and add the following lines. The code file for the sample is included in the <code class="literal">restful_python_chapter_06_01</code> folder:</p><pre class="programlisting">class CategoryResource(Resource): 
   <strong> def get(self, id):</strong> 
        category = Category.query.get_or_404(id) 
        result = category_schema.dump(category).data 
        return result 
 
   <strong> def patch(self, id):</strong> 
        category = Category.query.get_or_404(id) 
        category_dict = request.get_json() 
        if not category_dict: 
            resp = {'message': 'No input data provided'} 
            return resp, status.HTTP_400_BAD_REQUEST 
        errors = category_schema.validate(category_dict) 
        if errors: 
            return errors, status.HTTP_400_BAD_REQUEST 
        try: 
            if 'name' in category_dict: 
                category.name = category_dict['name'] 
            category.update() 
            return self.get(id) 
        except SQLAlchemyError as e: 
                db.session.rollback() 
                resp = jsonify({"error": str(e)}) 
                return resp, status.HTTP_400_BAD_REQUEST 
          
   <strong> def delete(self, id):</strong> 
        category = Category.query.get_or_404(id) 
        try: 
            category.delete(category) 
            response = make_response() 
            return response, status.HTTP_204_NO_CONTENT 
        except SQLAlchemyError as e: 
                db.session.rollback() 
                resp = jsonify({"error": str(e)}) 
                return resp, status.HTTP_401_UNAUTHORIZED 
</pre><p>The <code class="literal">CategoryResource</code> class is a subclass of <code class="literal">flask_restful.Resource</code> and declares the following three methods that will be called when the <code class="literal">HTTP</code> method with the same name arrives as a request on the represented resource:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">get</code>: This method receives the id of the category that has to be retrieved in the <code class="literal">id</code> argument. The code calls the <code class="literal">Category.query.get_or_404</code> method to return an HTTP <code class="literal">404 Not Found</code> status in case there is no category with the requested id in the underlying database. In case the message exists, the code calls the <code class="literal">category_schema.dump</code> method with the retrieved category as an argument to use the <code class="literal">CategorySchema</code> instance to serialize the <code class="literal">Category</code> instance whose <code class="literal">id</code> matches the specified <code class="literal">id</code>. The <code class="literal">dump</code> method takes the <code class="literal">Category</code> instance and applies the field filtering and output formatting specified in the <code class="literal">CategorySchema</code> class. The code returns the <code class="literal">data</code> attribute of the result returned by the <code class="literal">dump</code> method, that is, the serialized message in JSON format as the body, with the default HTTP <code class="literal">200 OK</code> status code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">patch</code>: This method receives the id of the category that has to be updated or patched in the <code class="literal">id</code> argument. The code calls the <code class="literal">Category.query.get_or_404</code> method to return an HTTP <code class="literal">404 Not Found</code> status in case there is no category with the requested id in the underlying database. In case the category exists, the code calls the <code class="literal">request.get_json</code> method to retrieve the key-value pairs received as arguments with the request. The code updates just the name attribute in case it has a new value in the <code class="literal">category_dict</code> dictionary in the <code class="literal">Category</code> instance: <code class="literal">category</code>. Then, the code calls the <code class="literal">category_schema.validate</code> method to retrieve any errors generated when validating the updated category. In case there were validation errors, the code returns the validation errors and an HTTP <code class="literal">400 Bad Request</code> status. If the validation is successful, the code calls the update method for the <code class="literal">Category</code> instance to persist the changes in the database and returns the results of calling the previously explained <code class="literal">self.get</code> method with the id of the updated category as an argument. This way, the method returns the serialized updated message in JSON format as the body, with the default HTTP <code class="literal">200 OK</code> status code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">delete</code>: This method receives the id of the category that has to be deleted in the <code class="literal">id</code> argument. The code calls the <code class="literal">Category.query.get_or_404</code> method to return an HTTP <code class="literal">404 Not Found</code> status in case there is no category with the requested id in the underlying database. In case the category exists, the code calls the <code class="literal">category.delete</code> method with the retrieved category as an argument to use the <code class="literal">Category</code> instance to erase itself from the database. Then, the code returns an empty response body and a <code class="literal">204 No Content</code> status code.</li></ul></div><p>Now, we will create a <code class="literal">CategoryListResource</code> class that we will use to represent the collection of categories. Open the previously created <code class="literal">api/views.py</code> file and add the following lines. The code file for the sample is included in the <code class="literal">restful_python_chapter_06_01</code> folder:</p><pre class="programlisting">class CategoryListResource(Resource): 
    def get(self): 
        categories = Category.query.all() 
        results = category_schema.dump(categories, many=True).data 
        return results 
 
    def post(self): 
        request_dict = request.get_json() 
        if not request_dict: 
            resp = {'message': 'No input data provided'} 
            return resp, status.HTTP_400_BAD_REQUEST 
        errors = category_schema.validate(request_dict) 
        if errors: 
            return errors, status.HTTP_400_BAD_REQUEST 
        try: 
            category = Category(request_dict['name']) 
            category.add(category) 
            query = Category.query.get(category.id) 
            result = category_schema.dump(query).data 
            return result, status.HTTP_201_CREATED 
        except SQLAlchemyError as e: 
            db.session.rollback() 
            resp = jsonify({"error": str(e)}) 
            return resp, status.HTTP_400_BAD_REQUEST 
</pre><p>The <code class="literal">CategoryListResource</code> class is a subclass of <code class="literal">flask_restful.Resource</code> and declares the following two methods that will be called when the HTTP method with the same name arrives as a request on the represented resource:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">get</code>: This method returns a list with all the <code class="literal">Category</code> instances saved in the database. First, the code calls the <code class="literal">Category.query.all</code> method to retrieve all the <code class="literal">Category</code> instances persisted in the database. Then, the code calls the <code class="literal">category_schema.dump</code> method with the retrieved messages and the <code class="literal">many</code> argument set to <code class="literal">True</code> to serialize the iterable collection of objects. The <code class="literal">dump</code> method will take each <code class="literal">Category</code> instance retrieved from the database and apply the field filtering and output formatting specified the <code class="literal">CategorySchema</code> class. The code returns the <code class="literal">data</code> attribute of the result returned by the dump method, that is, the serialized messages in JSON format as the body, with the default HTTP <code class="literal">200 OK</code> status code.</li><li class="listitem" style="list-style-type: disc"><code class="literal">post</code>: This method retrieves the key-value pairs received in the JSON body, creates a new <code class="literal">Category</code> instance and persists it in the database. First, the code calls the <code class="literal">request.get_json</code> method to retrieve the key-value pairs received as arguments with the request. Then, the code calls the <code class="literal">category_schema.validate</code> method to validate the new category built with the retrieved key-value pairs. In case there were validation errors, the code returns the validation errors and an HTTP <code class="literal">400 Bad Request</code> status. If the validation is successful, the code creates a new category with the specified <code class="literal">name</code>, and persists it in the database. Finally, the code returns the serialized saved category in JSON format as the body, with the HTTP <code class="literal">201 Created</code> status code.</li></ul></div><p>The following table shows the method of our previously created classes that we want to be executed for each combination of HTTP verb and scope:</p><div><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p>
<strong>HTTP verb</strong>
</p>
</td><td>
<p>
<strong>Scope</strong>
</p>
</td><td>
<p>
<strong>Class and method</strong>
</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Collection of messages</p>
</td><td>
<p>MessageListResource.get</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Message</p>
</td><td>
<p>MessageResource.get</p>
</td></tr><tr><td>
<p>
<code class="literal">POST</code>
</p>
</td><td>
<p>Collection of messages</p>
</td><td>
<p>MessageListResource.post</p>
</td></tr><tr><td>
<p>
<code class="literal">PATCH</code>
</p>
</td><td>
<p>Message</p>
</td><td>
<p>MessageResource.patch</p>
</td></tr><tr><td>
<p>
<code class="literal">DELETE</code>
</p>
</td><td>
<p>Message</p>
</td><td>
<p>MessageResource.delete</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Collection of categories</p>
</td><td>
<p>CategoryListResource.get</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Message</p>
</td><td>
<p>CategoryResource.get</p>
</td></tr><tr><td>
<p>
<code class="literal">POST</code>
</p>
</td><td>
<p>Collection of messages</p>
</td><td>
<p>CategoryListResource.post</p>
</td></tr><tr><td>
<p>
<code class="literal">PATCH</code>
</p>
</td><td>
<p>Message</p>
</td><td>
<p>CategoryResource.patch</p>
</td></tr><tr><td>
<p>
<code class="literal">DELETE</code>
</p>
</td><td>
<p>Message</p>
</td><td>
<p>CategoryResource.delete</p>
</td></tr></tbody></table></div><p>If the request results in the invocation of a resource with an unsupported <code class="literal">HTTP</code> method, Flask-RESTful will return a response with the HTTP <code class="literal">405 Method Not Allowed</code> status code.</p><p>We must make the necessary resource routing configurations to call the appropriate methods and pass them all the necessary arguments by defining URL rules. The following lines configure the resource routing for the api. Open the <code class="literal">api/views.py</code> file created earlier and add the following lines. The code file for the sample is included in the <code class="literal">restful_python_chapter_06_01</code> folder:</p><pre class="programlisting">api.add_resource(CategoryListResource, '/categories/') 
api.add_resource(CategoryResource, '/categories/&lt;int:id&gt;') 
api.add_resource(MessageListResource, '/messages/') 
api.add_resource(MessageResource, '/messages/&lt;int:id&gt;') 
</pre><p>Each call to the <code class="literal">api.add_resource</code> method routes a URL to a resource, specifically to one of the previously declared subclasses of the <code class="literal">flask_restful.Resource</code> class. When there is a request to the API and the URL matches one of the URLs specified in the <code class="literal">api.add_resource</code> method, Flask will call the method that matches the HTTP verb in the request for the specified class.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec78"/>Registering the blueprint and running migrations</h1></div></div></div><p>Create a new <code class="literal">app.py</code> file within the <code class="literal">api</code> folder. The following lines show the code that creates a Flask application. The code file for the sample is included in the <code class="literal">restful_python_chapter_06_01</code> folder.</p><pre class="programlisting">from flask import Flask 
 
 
def create_app(config_filename): 
    app = Flask(__name__) 
    app.config.from_object(config_filename) 
 
    from models import db 
    db.init_app(app) 
 
    from views import api_bp 
    app.register_blueprint(api_bp, url_prefix='/api') 
 
    return app 
</pre><p>The code in the <code class="literal">api/app.py</code> file declares a <code class="literal">create_app</code> function that receives the configuration file name in the <code class="literal">config_filename</code> argument, set ups a <em>Flask</em> app with this configuration file, and returns the <code class="literal">app</code> object. First, the function creates the main entry point for the Flask application named <code class="literal">app</code>. Then, the code calls the <code class="literal">app.config.from_object</code> method with the <code class="literal">config_filename</code> received as an argument. This way, the Flask app uses the values that are specified in the variables defined in the Python module received as an argument to set up the settings for the <em>Flask</em> app.</p><p>The next line calls the <code class="literal">init_app</code> method for the <code class="literal">flask_sqlalchemy.SQLAlchemy</code> instance created in the <code class="literal">models</code> module named <code class="literal">db</code>. The code passes app as an argument to link the created Flask app with the SQLAlchemy instance.</p><p>The next line calls the <code class="literal">app.register_blueprint</code> method to register the blueprint created in the <code class="literal">views</code> module, named <code class="literal">api_bp</code>. The url_prefix argument is set to <code class="literal">'/api'</code> because we want the resources to be available with <code class="literal">/api</code> as a prefix. Now <code class="literal">http://localhost:5000/api/</code> is going to be the URL for the API running on the Flask development server. Finally, the function returns the <code class="literal">app</code> object.</p><p>Create a new <code class="literal">run.py</code> file within the <code class="literal">api</code> folder. The following lines show the code that uses the previously defined create_app function to create a Flask application and run it. The code file for the sample is included in the <code class="literal">restful_python_chapter_06_01</code> folder.</p><pre class="programlisting">from app import create_app 
 
 
app = create_app('config') 
 
 
if __name__ == '__main__': 
    app.run(host=app.config['HOST'], 
            port=app.config['PORT'], 
            debug=app.config['DEBUG']) 
</pre><p>The code in the <code class="literal">api/run.py</code> file calls the <code class="literal">create_app</code> function, declared in the <code class="literal">app</code> module, with <code class="literal">'config'</code> as an argument. The function will set up a <em>Flask</em> app with this module as the configuration file.</p><p>The last line just calls the <code class="literal">app.run</code> method to start the Flask application with the host, port and debug values read from the <code class="literal">config</code> module. The code starts the application by calling the <code class="literal">run</code> method to immediately launch a local server. Remember that we could also achieve the same goal using the <code class="literal">flask</code> command-line script.</p><p>Create a new <code class="literal">migrate.py</code> file within the <code class="literal">api</code> folder. The following lines show the code that use <code class="literal">flask_script</code> and <code class="literal">flask_migrate</code> to run migrations. The code file for the sample is included in the <code class="literal">restful_python_chapter_06_01</code> folder:</p><pre class="programlisting">from flask_script import Manager 
from flask_migrate import Migrate, MigrateCommand 
from models import db 
from run import app 
 
 
migrate = Migrate(app, db) 
manager = Manager(app) 
manager.add_command('db', MigrateCommand) 
 
 
if __name__ == '__main__': 
    manager.run() 
</pre><p>The code creates an instance of <code class="literal">flask_migrate.Migrate</code> with the <em>Flask</em> app created in the previously explained <code class="literal">run</code> module, <code class="literal">app</code>, and the <code class="literal">flask_sqlalchemy.SQLAlchemy</code> instance created in the models module, <code class="literal">db</code>. Then, the code creates a <code class="literal">flask_script.Manager</code> class with the Flask app as an argument and saves its reference in the <code class="literal">manager</code> variable. The next line calls the <code class="literal">add_command</code> method with <code class="literal">'db'</code> and <code class="literal">MigrateCommand</code> as arguments. The main function calls the run method for the <code class="literal">Manager</code> instance.</p><p>This way, after the extension initializes, the code adds a db group to the command-line options. The db group has many sub-commands that we will use through the <code class="literal">migrate.py</code> script.</p><p>Now, we will run the scripts to run migrations and generate the necessary tables in the PostgreSQL database. Make sure you run the scripts in the terminal or Command Prompt window in which you have activated the virtual environment and that you are located in the <code class="literal">api</code> folder.</p><p>Run the first script, that initializes migration support for the application.</p><pre class="programlisting">
<strong>python migrate.py db init</strong>
</pre><p>The following lines show the sample output generated after running the previous script. Your output will be different according to the base folder in which you have created the virtual environment:</p><pre class="programlisting">
<strong>Creating directory /Users/gaston/PythonREST/Flask02/api/migrations ... done</strong>
<strong>Creating directory /Users/gaston/PythonREST/Flask02/api/migrations/versions ... done</strong>
<strong>Generating /Users/gaston/PythonREST/Flask02/api/migrations/alembic.ini ... done</strong>
<strong>Generating /Users/gaston/PythonREST/Flask02/api/migrations/env.py ... done</strong>
<strong>Generating /Users/gaston/PythonREST/Flask02/api/migrations/README ... done</strong>
<strong>Generating /Users/gaston/PythonREST/Flask02/api/migrations/script.py.mako ... done</strong>
<strong>Please edit configuration/connection/logging settings in</strong>
<strong>'/Users/gaston/PythonREST/Flask02/api/migrations/alembic.ini' before proceeding.</strong>
</pre><p>The script generated a new <code class="literal">migrations</code> sub-folder within the <code class="literal">api</code> folder with a versions sub-folder and many other files.</p><p>Run the second script that populates the migration script with the detected changes in the models. In this case, it is the first time we populate the migration script, and therefore, the migration script will generate the tables that will persist our two models: <code class="literal">Category</code> and <code class="literal">Message</code>:</p><pre class="programlisting">
<strong>python migrate.py db migrate</strong>
</pre><p>The following lines show the sample output generated after running the previous script. Your output will be different according to the base folder in which you have created the virtual environment:</p><pre class="programlisting">
<strong>INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.</strong>
<strong>INFO  [alembic.runtime.migration] Will assume transactional DDL.</strong>
<strong>INFO  [alembic.autogenerate.compare] Detected added table 'category'</strong>
<strong>INFO  [alembic.autogenerate.compare] Detected added table 'message'</strong>
<strong>  Generating /Users/gaston/PythonREST/Flask02/api/migrations/versions/417543056ac3_.py ... done</strong>
</pre><p>The output indicates that the <code class="literal">api/migrations/versions/417543056ac3_.py</code> file includes the code to create the <code class="literal">category</code> and <code class="literal">message</code> tables. The following lines show the code for this file that was automatically generated based on the models. Note that the filename will be different in your configuration. The code file for the sample is included in the <code class="literal">restful_python_chapter_06_01</code> folder:</p><pre class="programlisting">"""empty message 
 
Revision ID: 417543056ac3 
Revises: None 
Create Date: 2016-08-08 01:05:31.134631 
 
""" 
 
# revision identifiers, used by Alembic. 
revision = '417543056ac3' 
down_revision = None 
 
from alembic import op 
import sqlalchemy as sa 
 
 
def upgrade(): 
    ### commands auto generated by Alembic - please adjust! ### 
    op.create_table('category', 
    sa.Column('id', sa.Integer(), nullable=False), 
    sa.Column('name', sa.String(length=150), nullable=False), 
    sa.PrimaryKeyConstraint('id'), 
    sa.UniqueConstraint('name') 
    ) 
    op.create_table('message', 
    sa.Column('id', sa.Integer(), nullable=False), 
    sa.Column('message', sa.String(length=250), nullable=False), 
    sa.Column('duration', sa.Integer(), nullable=False), 
    sa.Column('creation_date', sa.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=False), 
    sa.Column('category_id', sa.Integer(), nullable=False), 
    sa.Column('printed_times', sa.Integer(), server_default='0', nullable=False), 
    sa.Column('printed_once', sa.Boolean(), server_default='false', nullable=False), 
    sa.ForeignKeyConstraint(['category_id'], ['category.id'], ondelete='CASCADE'), 
    sa.PrimaryKeyConstraint('id'), 
    sa.UniqueConstraint('message') 
    ) 
    ### end Alembic commands ### 
 
 
def downgrade(): 
    ### commands auto generated by Alembic - please adjust! ### 
    op.drop_table('message') 
    op.drop_table('category') 
    ### end Alembic commands ### 
</pre><p>The code defines two functions: <code class="literal">upgrade</code> and <code class="literal">downgrade</code>. The <code class="literal">upgrade</code> function runs the necessary code to create the <code class="literal">category</code> and <code class="literal">message</code> tables by making calls to <code class="literal">alembic.op.create_table</code>. The <code class="literal">downgrade</code> function runs the necessary code to go back to the previous version.</p><p>Run the third script to upgrade the database:</p><pre class="programlisting">
<strong>python migrate.py db upgrade</strong>
</pre><p>The following lines show the sample output generated after running the previous script:</p><pre class="programlisting">
<strong>INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.</strong>
<strong>INFO  [alembic.runtime.migration] Will assume transactional DDL.</strong>
<strong>INFO  [alembic.runtime.migration] Running upgrade  -&gt; 417543056ac3, empty message</strong>
</pre><p>The previous script called the <code class="literal">upgrade</code> function defined in the automatically generated <code class="literal">api/migrations/versions/417543056ac3_.py</code> script. Don't forget that the file name will be different in your configuration.</p><p>After we run the previous scripts, we can use the PostgreSQL command line or any other application that allows us to easily verify the contents of the PostreSQL database to check the tables that the migration generated.</p><p>Run the following command to list the generated tables. In case the database name you are using is not named <code class="literal">messages</code>, make sure you use the appropriate database name.</p><pre class="programlisting">
<strong>psql --username=user_name --dbname=messages --command="\dt"</strong>
</pre><p>The following lines show the output with all the generated table names:</p><pre class="programlisting">
<strong>                    List of relations</strong>
<strong> Schema |      Name       | Type  |   Owner   </strong>
<strong>--------+-----------------+-------+-----------</strong>
<strong> public | alembic_version | table | user_name</strong>
<strong> public | category        | table | user_name</strong>
<strong> public | message         | table | user_name</strong>
<strong>(3 rows)</strong>
</pre><p>SQLAlchemy generated the tables, the unique constraints, and the foreign keys based on the information included in our models.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">category</code>: Persists the <code class="literal">Category</code> model.</li><li class="listitem" style="list-style-type: disc"><code class="literal">message</code>: Persists the <code class="literal">Message</code> model.</li></ul></div><p>The following command will allow you to check the contents of the four tables after we compose and send HTTP requests to the RESTful API and make CRUD operations to the two tables. The commands assume that you are running PostgreSQL on the same computer in which you are running the command:</p><pre class="programlisting">
<strong>psql --username=user_name --dbname=messages --command="SELECT * FROM category;"</strong>
<strong>psql --username=user_name --dbname=messages --command="SELECT * FROM message;"</strong>
</pre><div><div><h3 class="title"><a id="tip51"/>Tip</h3><p>Instead of working with the PostgreSQL command-line utility, you can use a GUI tool to check the contents of the PostgreSQL database. You also use also the database tools included in your favorite IDE to check the contents for the SQLite database.</p></div></div><p>Alembic generated an additional table named <code class="literal">alembic_version</code> that saves the version number for the database in the <code class="literal">version_num</code> column. This table makes is possible for the migration scripts to retrieve the current version of the database and upgrade or downgrade it based on our needs.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec79"/>Creating and retrieving related resources</h1></div></div></div><p>Now, we can run the <code class="literal">api/run.py</code> script that launches Flask's development. Execute the following command in the api folder.</p><pre class="programlisting">
<strong>python run.py</strong>
</pre><p>The following lines show the output after we execute the preceding command. The development server is listening at port <code class="literal">5000</code>.</p><pre class="programlisting">
<strong> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</strong>
<strong> * Restarting with stat</strong>
<strong> * Debugger is active!</strong>
<strong> * Debugger pin code: 198-040-402</strong>
</pre><p>Now, we will use the HTTPie command or its curl equivalents to compose and send HTTP requests to the API. We will use JSON for the requests that require additional data. Remember that you can perform the same tasks with your favorite GUI-based tool.</p><p>First, we will compose and send HTTP requests to create two message categories:</p><pre class="programlisting">
<strong>http POST :5000/api/categories/ name='Information'</strong>
<strong>http POST :5000/api/categories/ name='Warning'</strong>
</pre><p>The following are the equivalent <code class="literal">curl</code> commands:</p><pre class="programlisting">
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"Information"}' :5000/api/categories/</strong>
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"Warning"}' :5000/api/categories/</strong>
</pre><p>The preceding commands will compose and send two <code class="literal">POST</code> HTTP requests with the specified JSON key-value pair. The requests specify <code class="literal">/api/categories/</code>, and therefore, they will match the <code class="literal">'/api'url_prefix</code> for the <code class="literal">api_bp</code> blueprint. Then, the request will match the <code class="literal">'/categories/'</code> URL route for the <code class="literal">CategoryList</code> resource and run the <code class="literal">CategoryList.post</code> method. The method doesn't receive arguments because the URL route doesn't include any parameters. As the HTTP verb for the request is <code class="literal">POST</code>, Flask calls the <code class="literal">post</code> method. If the two new <code class="literal">Category</code> instances were successfully persisted in the database, the two calls will return an <code class="literal">HTTP 201 Created</code> status code and the recently persisted <code class="literal">Category</code> serialized to JSON in the response body. The following lines show an example response for the two HTTP requests, with the new <code class="literal">Category</code> objects in the JSON responses.</p><p>Note that the responses include the URL, <code class="literal">url</code>, for the created categories. The <code class="literal">messages</code> array is empty in both cases because there aren't messages related to each new category yet:</p><pre class="programlisting">
<strong>HTTP/1.0 201 CREATED</strong>
<strong>Content-Length: 116</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Mon, 08 Aug 2016 05:26:58 GMT</strong>
<strong>Server: Werkzeug/0.11.10 Python/3.5.1</strong>
<strong>{</strong>
<strong>    "id": 1, </strong>
<strong>    "messages": [], </strong>
<strong>    "name": "Information", </strong>
<strong>    "url": "http://localhost:5000/api/categories/1"</strong>
<strong>}</strong>
<strong>HTTP/1.0 201 CREATED</strong>
<strong>Content-Length: 112</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Mon, 08 Aug 2016 05:27:05 GMT</strong>
<strong>Server: Werkzeug/0.11.10 Python/3.5.1</strong>
<strong>{</strong>
<strong>    "id": 2, </strong>
<strong>    "messages": [], </strong>
<strong>    "name": "Warning", </strong>
<strong>    "url": "http://localhost:5000/api/categories/2"</strong>
<strong>}</strong>
</pre><p>Now, we will compose and send HTTP requests to create two messages that belong to the first message category we recently created: <code class="literal">Information</code>. We will specify the <code class="literal">category</code> key with the name of the desired message category. The database table that persists the <code class="literal">Message</code> model will save the value of the primary key of the related <code class="literal">Category</code> whose name value matches the one we provide:</p><pre class="programlisting">
<strong>http POST :5000/api/messages/ message='Checking temperature sensor' duration=5 category="Information"</strong>
<strong>http POST :5000/api/messages/ message='Checking light sensor' duration=8 category="Information"</strong>
</pre><p>The following are the equivalent <code class="literal">curl</code> commands:</p><pre class="programlisting">
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":" Checking temperature sensor", "category":"Information"}' :5000/api/messages/</strong>
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":" Checking light sensor", "category":"Information"}' :5000/api/messages/</strong>
</pre><p>The first command will compose and send the following HTTP request: <code class="literal">POST http://localhost:5000/api/messages/</code> with the following JSON key-value pairs:</p><pre class="programlisting">{  
    "message": "Checking temperature sensor",  
    "category": "Information" 
} 
</pre><p>The second command will compose and send the same HTTP request with the following JSON key-value pairs:</p><pre class="programlisting">{  
    "message": "Checking light sensor",  
    "category": "Information" 
} 
</pre><p>The requests specify <code class="literal">/api/categories/</code>, and therefore, they will match the <code class="literal">'/api'url_prefix</code> for the <code class="literal">api_bp</code> blueprint. Then, the request will match the <code class="literal">'/messages/'</code> URL route for the <code class="literal">MessageList</code> resource and run the <code class="literal">MessageList.post</code> method. The method doesn't receive arguments because the URL route doesn't include any parameters. As the HTTP verb for the request is <code class="literal">POST</code>, Flask calls the <code class="literal">post</code> method. The the <code class="literal">MessageSchema.process_category</code> method will process the data for the category and the <code class="literal">MessageListResource.post</code> method will retrieve the <code class="literal">Category</code> that matches the specified category name from the database, to use it as the related category for the new message. If the two new <code class="literal">Message</code> instances were successfully persisted in the database, the two calls will return an <code class="literal">HTTP 201 Created</code> status code and the recently persisted <code class="literal">Message</code> serialized to JSON in the response body. The following lines show an example response for the two HTTP requests, with the new <code class="literal">Message</code> objects in the JSON responses. Note that the responses include the URL, <code class="literal">url</code>, for the created messages. In addition, the response includes the <code class="literal">id</code>, <code class="literal">name</code>, and <code class="literal">url</code> for the related category.</p><pre class="programlisting">
<strong>HTTP/1.0 201 CREATED</strong>
<strong>Content-Length: 369</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Mon, 08 Aug 2016 15:18:43 GMT</strong>
<strong>Server: Werkzeug/0.11.10 Python/3.5.1</strong>
<strong>{</strong>
<strong>    "category": {</strong>
<strong>        "id": 1, </strong>
<strong>        "name": "Information", </strong>
<strong>        "url": "http://localhost:5000/api/categories/1"</strong>
<strong>    }, </strong>
<strong>    "creation_date": "2016-08-08T12:18:43.260474+00:00", </strong>
<strong>    "duration": 5, </strong>
<strong>    "id": 1, </strong>
<strong>    "message": "Checking temperature sensor", </strong>
<strong>    "printed_once": false, </strong>
<strong>    "printed_times": 0, </strong>
<strong>    "url": "http://localhost:5000/api/messages/1"</strong>
<strong>}</strong>
<strong>HTTP/1.0 201 CREATED</strong>
<strong>Content-Length: 363</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Mon, 08 Aug 2016 15:27:30 GMT</strong>
<strong>Server: Werkzeug/0.11.10 Python/3.5.1</strong>
<strong>{</strong>
<strong>    "category": {</strong>
<strong>        "id": 1, </strong>
<strong>        "name": "Information", </strong>
<strong>        "url": "http://localhost:5000/api/categories/1"</strong>
<strong>    }, </strong>
<strong>    "creation_date": "2016-08-08T12:27:30.124511+00:00", </strong>
<strong>    "duration": 8, </strong>
<strong>    "id": 2, </strong>
<strong>    "message": "Checking light sensor", </strong>
<strong>    "printed_once": false, </strong>
<strong>    "printed_times": 0, </strong>
<strong>    "url": "http://localhost:5000/api/messages/2"</strong>
<strong>}</strong>
</pre><p>We can run the preceding commands to check the contents of the tables that the migrations created in the PostgreSQL database. We will notice that the <code class="literal">category_id</code> column for the <code class="literal">message</code> table saves the value of the primary key of the related row in the <code class="literal">category</code> table. The <code class="literal">MessageSchema</code> class uses a <code class="literal">fields.Nested</code> instance to render the <code class="literal">id</code>, <code class="literal">url</code> and name fields for the related <code class="literal">Category</code>. The following screenshot shows the contents for the <code class="literal">category</code> and the <code class="literal">message</code> table in a PostgreSQL database after running the HTTP requests:</p><p>
</p><div><img src="img/image_06_001.jpg" alt="Creating and retrieving related resources"/></div><p>
</p><p>Now, we will compose and send an HTTP request to retrieve the category that contains two messages, that is the category resource whose id or primary key is equal to <code class="literal">1</code>. Don't forget to replace <code class="literal">1</code> with the primary key value of the category whose name is equal to <code class="literal">'Information'</code> in your configuration:</p><pre class="programlisting">
<strong>http :5000/api/categories/1</strong>
</pre><p>The following is the equivalent curl command:</p><pre class="programlisting">
<strong>curl -iX GET :5000/api/categories/1</strong>
</pre><p>The preceding command will compose and send a <code class="literal">GET</code> HTTP request. The request has a number after <code class="literal">/api/categories/</code>, and therefore, it will match <code class="literal">'/categories/&lt;int:id&gt;'</code> and run the <code class="literal">CategoryResource.get</code> method, that is, the <code class="literal">get</code> method for the <code class="literal">CategoryResource</code> class. If a <code class="literal">Category</code> instance with the specified id exists in the database, the call to the method will will return an <code class="literal">HTTP200 OK</code> status code and the <code class="literal">Category</code> instance serialized to JSON in the response body. The <code class="literal">CategorySchema</code> class uses a <code class="literal">fields.Nested</code> instance to render all the fields for all the messages related to the category excepting the category field. The following lines show a sample response:</p><pre class="programlisting">
<strong>HTTP/1.0 200 OK</strong>
<strong>Content-Length: 1078</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Mon, 08 Aug 2016 16:09:10 GMT</strong>
<strong>Server: Werkzeug/0.11.10 Python/3.5.1</strong>
<strong>{</strong>
<strong>    "id": 1, </strong>
<strong>    "messages": [</strong>
<strong>        {</strong>
<strong>            "category": {</strong>
<strong>                "id": 1, </strong>
<strong>                "name": "Information", </strong>
<strong>                "url": "http://localhost:5000/api/categories/1"</strong>
<strong>            }, </strong>
<strong>            "creation_date": "2016-08-08T12:27:30.124511+00:00", </strong>
<strong>            "duration": 8, </strong>
<strong>            "id": 2, </strong>
<strong>            "message": "Checking light sensor", </strong>
<strong>            "printed_once": false, </strong>
<strong>            "printed_times": 0, </strong>
<strong>            "url": "http://localhost:5000/api/messages/2"</strong>
<strong>        }, </strong>
<strong>        {</strong>
<strong>            "category": {</strong>
<strong>                "id": 1, </strong>
<strong>                "name": "Information", </strong>
<strong>                "url": "http://localhost:5000/api/categories/1"</strong>
<strong>            }, </strong>
<strong>            "creation_date": "2016-08-08T12:18:43.260474+00:00", </strong>
<strong>            "duration": 5, </strong>
<strong>            "id": 1, </strong>
<strong>            "message": "Checking temperature sensor", </strong>
<strong>            "printed_once": false, </strong>
<strong>            "printed_times": 0, </strong>
<strong>            "url": "http://localhost:5000/api/messages/1"</strong>
<strong>        }</strong>
<strong>    ], </strong>
<strong>    "name": "Information", </strong>
<strong>    "url": "http://localhost:5000/api/categories/1"</strong>
<strong>}</strong>
</pre><p>Now, we will compose and send a <code class="literal">POST</code> HTTP request to create a message related to a category name that doesn't exist: <code class="literal">'Error'</code>:</p><pre class="programlisting">
<strong>http POST :5000/api/messages/ message='Temperature sensor error' duration=10 category="Error"</strong>
</pre><p>The following are the equivalent curl commands:</p><pre class="programlisting">
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":" Temperature sensor error", "category":"Error"}' :5000/api/messages/</strong>
</pre><p>The <code class="literal">CategoryListResource.post</code> method won't be able to retrieve a <code class="literal">Category</code> instance whose <code class="literal">name</code> is equal to the specified value, and therefore, the method will create a new <code class="literal">Category</code>, save it and use it as the related category for the new message. The following lines show an example response for the HTTP request, with the new <code class="literal">Message</code> object in the JSON responses and the details for the new <code class="literal">Category</code> object related to the message:</p><pre class="programlisting">
<strong>HTTP/1.0 201 CREATED</strong>
<strong>Content-Length: 361</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Mon, 08 Aug 2016 17:20:22 GMT</strong>
<strong>Server: Werkzeug/0.11.10 Python/3.5.1</strong>
<strong>{</strong>
<strong>    "category": {</strong>
<strong>        "id": 3, </strong>
<strong>        "name": "Error", </strong>
<strong>        "url": "http://localhost:5000/api/categories/3"</strong>
<strong>    }, </strong>
<strong>    "creation_date": "2016-08-08T14:20:22.103752+00:00", </strong>
<strong>    "duration": 10, </strong>
<strong>    "id": 3, </strong>
<strong>    "message": "Temperature sensor error", </strong>
<strong>    "printed_once": false, </strong>
<strong>    "printed_times": 0, </strong>
<strong>    "url": "http://localhost:5000/api/messages/3"</strong>
<strong>}</strong>
</pre><p>We can run the commands explained earlier to check the contents of the tables that the migrations created in the PostgreSQL database. We will notice that we have a new row in the category table with the recently added category when we created a new message. The following screenshot shows the contents for the <code class="literal">category</code> and <code class="literal">message</code> tables in a PostgreSQL database after running the HTTP requests:</p><p>
</p><div><img src="img/image_06_002.jpg" alt="Creating and retrieving related resources"/></div><p>
</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec80"/>Test your knowledge</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Marshmallow is:<div><ol class="orderedlist arabic"><li class="listitem">A lightweight library for converting complex datatypes to and from native Python datatypes.</li><li class="listitem">An ORM .</li><li class="listitem">A lightweight web framework that replaces Flask.</li></ol></div><p>
</p></li><li class="listitem">SQLAlchemy is:<div><ol class="orderedlist arabic"><li class="listitem">A lightweight library for converting complex datatypes to and from native Python datatypes.</li><li class="listitem">An ORM .</li><li class="listitem">A lightweight web framework that replaces Flask.</li></ol></div><p>
</p></li><li class="listitem">The <code class="literal">marshmallow.pre_load</code> decorator:<div><ol class="orderedlist arabic"><li class="listitem">Registers a method to run after any instance of the <code class="literal">MessageSchema</code> class is created.</li><li class="listitem">Registers a method to invoke after serializing an object.</li><li class="listitem">Registers a method to invoke before deserializing an object.</li></ol></div><p>
</p></li><li class="listitem">The <code class="literal">dump</code> method for any instance of a Schema subclass:<div><ol class="orderedlist arabic"><li class="listitem">Routes URLs to Python primitives.</li><li class="listitem">Persists the instance or collection of instances passed as an argument to the database.</li><li class="listitem">Takes the instance or collection of instances passed as an argument and applies the field filtering and output formatting specified in the Schema subclass to the instance or collection of instances.</li></ol></div><p>
</p></li><li class="listitem">When we declare an attribute as an instance of the <code class="literal">marshmallow.fields.Nested</code> class:<div><ol class="orderedlist arabic"><li class="listitem">The field will nest a single <code class="literal">Schema</code> or a collection of <code class="literal">Schema</code> based on the value for the <code class="literal">many</code> argument.</li><li class="listitem">The field will nest a single <code class="literal">Schema</code>. If we want to nest a collection of <code class="literal">Schema</code>, we have to use an instance of the <code class="literal">marshmallow.fields.NestedCollection</code> class.</li><li class="listitem">The field will nest a collection of <code class="literal">Schema</code>. If we want to nest a single <code class="literal">Schema</code>, we have to use an instance of the <code class="literal">marshmallow.fields.NestedSingle</code> class.</li></ol></div><p>
</p></li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec81"/>Summary</h1></div></div></div><p>In this chapter, we expanded the capabilities of the previous version of the RESTful API that we created in the previous chapter. We used SQLAlchemy as our ORM to work with a PostgreSQL database. We installed many packages to simplify many common tasks, wrote code for the models and their relationships, and worked with schemas to validate, serialize, and deserialize these models.</p><p>We combined blueprints with resourceful routing and were able to generate the database from the models. We composed and sent many HTTP requests to our RESTful API and analyzed how each HTTP request was processed in our code and how the models persisted in the database tables.</p><p>Now that we built a complex API with Flask, Flask-RESTful, and SQLAlchemy, we will use additional features and add security and authentication, which is what we are going to discuss in the next chapter.</p></div></body></html>