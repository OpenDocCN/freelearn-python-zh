<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-188"><a id="_idTextAnchor221"/>10</h1>
<h1 id="_idParaDest-189"><a id="_idTextAnchor222"/>Integrating the React Frontend with the Flask Backend</h1>
<p>This chapter represents a critical point in our quest to build a full stack web application. In this chapter, you will be introduced to a set of instructions on how to connect a Flask web server to a React frontend. You will learn how to pass form entries from the React frontend to the Flask backend. And after<a id="_idIndexMarker706"/> this integration, you can be officially called a <strong class="bold">full stack </strong><strong class="bold">web developer</strong>.</p>
<p>React web applications usually have a sleek look and feel and are regarded as the Rolls-Royce of modern frontend web application applications. React has an intuitive user-interface-focused library, capable of powering production-grade web and mobile applications with ease.</p>
<p>The robust React ecosystem coupled with React’s tools and libraries facilitates end-to-end web development. When you combine React’s incredible component-based design pattern with a minimalist lightweight Flask framework, you get a rich web application that can withstand the test of time and scale at large.</p>
<p>This chapter will help you understand the dynamics of integrating React, a frontend library, and Flask, a backend framework, in developing valuable software products. You will also learn how React handles forms with the Flask backend in this chapter.</p>
<p>Ever since the advent of the web, there has been a need for more dynamic and responsive forms in web applications. We will explore server-side handling of form elements, validation, and security concerns.</p>
<p>In this chapter, we’ll cover the following topics:</p>
<ul>
<li>The <em class="italic">Bizza</em> application structure</li>
<li>Configuring the React frontend</li>
<li>Making the Flask backend ready</li>
<li>Handling forms in React and Flask</li>
<li>Troubleshooting tips for the React frontend and the Flask backend</li>
</ul>
<h1 id="_idParaDest-190"><a id="_idTextAnchor223"/>Technical requirements</h1>
<p>The complete code for this chapter is available on GitHub at: <a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter10">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter10</a>.</p>
<h1 id="_idParaDest-191"><a id="_idTextAnchor224"/>The Bizza application structure</h1>
<p>In this section, we will go deeper into<a id="_idIndexMarker707"/> the structure of the application we will build in this book. As stated previously, we will name the fictitious web app <em class="italic">Bizza</em>, a conference event web application.</p>
<p>This <em class="italic">Bizza</em> web app will serve as the digital hub for a conference event for speakers from the information technology industry, providing a myriad of features and functionalities that enhance the speakers’ and attendees’ overall experience. Let’s delve into the <em class="italic">Bizza</em> application structure.</p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor225"/>Application overview</h2>
<p><em class="italic">Bizza</em> is a fictitious data-driven event<a id="_idIndexMarker708"/> application that allows subject experts in the information technology industry to share their insights and experiences, providing valuable knowledge to enhance event attendees’ skills.</p>
<p><em class="italic">Bizza</em> lets you see a list of speakers and workshop schedules with details. This site lets users register and browse for a workshop. Essentially, the application<a id="_idIndexMarker709"/> will have the following functionalities:</p>
<ul>
<li>A home page that displays event speakers and available event schedules with locations and subjects</li>
<li>A registration form for event attendees</li>
<li>A registration form for speakers with a subject of interest</li>
<li>A page for users to log in to the application</li>
<li>A page containing the names and details of speakers</li>
</ul>
<p>Next, we will delve into the <em class="italic">Bizza</em> app and break it down into its frontend and backend components. By doing so, we will gain a comprehensive understanding of the distinct roles and functionalities that each component serves within the app.</p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor226"/>Breaking down the code structure into frontend and backend</h2>
<p>In the world of software development, frontend and backend are like the yin and yang – opposites but complementing each other to provide a harmonious digital experience. <em class="italic">Yin and yang</em> is a Chinese <a id="_idIndexMarker710"/>philosophical concept that describes opposite but interconnected forces.</p>
<p>In a nutshell, breaking down an application into its frontend and backend components provides a clear separation<a id="_idIndexMarker711"/> of concerns, promotes code reusability and portability, enables scalability and performance optimization, and fosters collaboration and parallel development. This approach ultimately contributes to the overall success of the web application development process.</p>
<p>The practice of separating frontend and backend components in software development started to gain prominence in the late 1990s and early 2000s, with the rise of web-based applications. During this time, web technologies were evolving in the blink of an eye, and the need for scalable and modular applications became apparent.</p>
<p>The introduction of JavaScript frameworks such as jQuery in the early 2000s enabled more dynamic and interactive user interfaces in the frontend. This led to a clearer distinction between the presentation layer (frontend) and the data processing layer (backend) of web applications.</p>
<p>With the emergence of <strong class="bold">single-page applications</strong> (<strong class="bold">SPAs</strong>) and the proliferation of JavaScript frameworks<a id="_idIndexMarker712"/> and libraries such as AngularJS, React, and Vue.js, the separation between the frontend and the backend became more standardized and widely adopted. SPAs shifted the responsibility of rendering and managing the UI to the client side, while the backend APIs handled data retrieval and manipulation.</p>
<p>Now that we have discussed the key reasons for breaking down the code structure, let’s examine the frontend and backend components of the <em class="italic">Bizza</em> web application.</p>
<p>The following code structure represents the high-end level code split between the frontend and the backend. This allows us to separate concerns and improve code reusability:</p>
<pre class="source-code">bizza/├── backend/
├── frontend/</pre>
<h3>Frontend structure</h3>
<p>First, let’s<a id="_idIndexMarker713"/> provide an overview of the detailed <code>frontend</code> structure:</p>
<pre class="source-code">frontend/├── node_modules
├── package.json
├── public
    ├──favicon.ico
├──index.html
├── src
    ├──components/
    ├──pages/
    ├──hooks/
    ├──assets/
    └──App.js
    └──App.css
    └──index.js
    └──index.css
    └──setupTests.js
├──.gitignore
├──.prettierrc
├──package-lock.json
├──package.json
├──README.md</pre>
<p>The preceding frontend code structure comprises majorly of <code>node_modules</code>, <code>package.json</code>, <code>public</code>, <code>src</code>, <code>.gitignore</code>, <code>.prettierrc</code>, <code>package-lock.json</code>, and <code>README.md</code>.</p>
<p>Let’s quickly break down the major <a id="_idIndexMarker714"/>directories and files:</p>
<ul>
<li><code>node_modules</code>: This directory contains all the packages (libraries and frameworks) that your application depends on. These packages are listed in the <code>dependencies</code> and <code>devDependencies</code> sections of the <code>package.json</code> file.</li>
<li><code>package.json</code>: This file contains metadata about your application, including its name, version, and dependencies. It also includes scripts you can use to build, test, and run your application.</li>
<li><code>public</code>: This directory contains static assets that your application will use, such as the favicon and the main HTML file (<code>index.html</code>).</li>
<li><code>src</code>: This directory contains the source code for your application. It is organized into subdirectories for components, pages, hooks, and assets. The <code>src</code> directories are critical to the design pattern adopted for the React frontend. The <code>components</code> folders contain all the components we intend to use in the <em class="italic">Bizza</em> app, <code>pages</code> contains the presentational component of the app, <code>hook</code> contains custom hooks, and finally, the <code>assets</code> folder contains all the assets, such as <code>images</code>, <code>logos</code>, and <code>svg</code>, that are used in the application.</li>
<li><code>.gitignore</code>: This file tells Git which files and directories to ignore when you commit your code to a repository.</li>
<li><code>.prettierrc</code>: This file specifies the configuration options for the Prettier code formatter. Prettier is a popular code formatting tool that enforces a consistent style across your code base. It is typically placed in the <code>root</code> directory of a JavaScript project and contains JSON syntax to define the formatting rules.</li>
<li><code>package-lock.json</code>: This file records the exact versions of all the packages that your application depends on, as well as any packages those packages depend on. It ensures that your application uses the same versions of its dependencies every<a id="_idIndexMarker715"/> time it is installed.</li>
<li><code>README.md</code>: This file contains documentation for your application, such as instructions to install and run it.</li>
</ul>
<h3>Backend structure</h3>
<p>Next, we will examine how<a id="_idIndexMarker716"/> the backend will be structured:</p>
<pre class="source-code">backend/├── app.py
├── models
├── config
│   ├── config.py
├── .flaskenv
├── requirements.txt</pre>
<p>The preceding represents the files and directories structure for the Flask backend application.</p>
<p>Let’s break down the directories and files:</p>
<ul>
<li><code>app.py</code>: This file contains the main code for your backend application, including routes and logic to handle HTTP requests.</li>
<li><code>models</code>: This directory contains modules of each of the model definitions for database models.</li>
<li><code>config</code>: This directory contains a configuration options file for the application, such as database connection strings or secret keys.</li>
<li><code>.flaskenv</code>: This file contains environment variables that are specific to the Flask application.</li>
<li><code>requirements.txt</code>: This file lists the packages that the application depends on, including any third-party libraries. You can use this file to install the necessary dependencies by running <code>pip install -</code><code>r requirements.txt</code>.</li>
</ul>
<p>Next, we will see how to <a id="_idIndexMarker717"/>configure the React frontend and prepare it to consume the backend API services.</p>
<h1 id="_idParaDest-194"><a id="_idTextAnchor227"/>Configuring the React frontend for API consumption</h1>
<p>In this section, you will <a id="_idIndexMarker718"/>configure the frontend React app to communicate with the backend Flask server by setting up a proxy in React to consume the API from the Flask server.</p>
<p>In order to configure the React proxy for API consumption, you will need to update the <code>proxy</code> field in the <code>package.json</code> file of the frontend React app. The <code>proxy</code> field allows you to specify a URL that will be used as the base for all API requests made from the React app.</p>
<p>Let’s update the <code>package.json</code> file:</p>
<ol>
<li>Open the <code>package.json</code> file in the <code>project</code> directory using a text editor, and then add a <code>proxy</code> field to the <code>package.json</code> file and set it to the URL of your Flask server:<pre class="source-code">{  "name": "bizza",  "version": "0.1.0",  "proxy": "http://localhost:5000"}</pre></li>
<li>Next, you will need to make HTTP requests to the Flask server from the React frontend. We will use the <code>Fetch()</code> method is an alternative to Axios.<p class="list-inset">Axios is a JavaScript library that allows you to make HTTP requests from the browser. It is a promise-based library that uses modern techniques to make it easy to work with asynchronous requests. With Axios, you can make HTTP requests to retrieve data from a server, submit form data, or send data to a server.</p><p class="list-inset">Axios supports a <a id="_idIndexMarker720"/>number of different request methods, such as <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, and <code>PATCH</code>, and it can handle both JSON and XML data formats. Axios is popular among developers because it has a simple and straightforward API, making it easy to use for both beginners and experienced developers.</p><p class="list-inset">Axios also has a number of features that make it flexible and powerful, such as the automatic transformation of data, support for interceptors (which allow you to modify requests or responses before they are sent or received), and the ability to cancel requests.</p></li>
<li>You can install Axios by running the following command in your terminal:<pre class="source-code"><strong class="bold">npm install axios</strong></pre><p class="list-inset">Once Axios is installed, you can use it to make HTTP requests to the Flask server from the React frontend.</p></li>
<li>Make sure that both the frontend React app and the backend Flask server run on separate ports. By default, the React <a id="_idIndexMarker721"/>development server runs on port <code>3000</code>, while the Flask development server runs on port <code>5000</code>.</li>
</ol>
<p>Next, you will need to define routes and functions in the Flask backend to handle HTTP requests coming from the React frontend.</p>
<h1 id="_idParaDest-195"><a id="_idTextAnchor228"/>Making Flask backend-ready</h1>
<p>In the <em class="italic">Setting up the development environment with Flask</em> section of <a href="B18554_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Full Stack Ready with React and Flask</em>, we set up the development environment for the Flask server. Ensure your virtual environment is activated. You can do so by running the following commands:</p>
<ul>
<li><strong class="bold">For Mac/Linux</strong>:<pre class="source-code"><strong class="bold">source venv/bin/activate</strong></pre></li>
<li><strong class="bold">For Windows</strong>:<pre class="source-code"><strong class="bold">Venv/Scripts/activate</strong></pre></li>
</ul>
<p>Your virtual environment should now be activated, and your terminal prompt should be prefixed with the name of the virtual <a id="_idIndexMarker722"/>environment (for example, <code>(</code><code>venv) $</code>).</p>
<p>Next, let’s dive straight into defining an event registration route, with its function as part of the requirements for Bizza application model. </p>
<p>Let’s add a model to handle registrations for event attendees. You will later use it to accept requests from the React frontend in the next section, where we will handle form inputs in React and Flask.</p>
<p>The <code>app.py</code> file in the root directory of your application is still the main entry point for the Flask application. Update <code>app.py</code> with the following code snippet to define the model and endpoint to handle the event registration:</p>
<pre class="source-code">class EventRegistration(db.Model):    __tablename__ = 'attendees'
    id = db.Column(db.Integer, primary_key=True)
    first_name = db.Column(db.String(100), unique=True, nullable=False)
    last_name = db.Column(db.String(100), unique=True, nullable=False)
    email = db.Column(db.String(100), unique=True, nullable=False)
    phone = db.Column(db.String(100), unique=True, nullable=False)
    job_title = db.Column(db.String(100), unique=True, nullable=False)
    company_name = db.Column(db.String(100), unique=True,         nullable=False)
    company_size = db.Column(db.String(50), unique=True,         nullable=False)
    subject = db.Column(db.String(250), nullable=False)
def format(self):
    return {
        'id': self.id,
        'first_name': self.first_name,
        'last_name': self.last_name,
        'email': self.email,
        'phone': self.phone,
        'job_title': self.job_title,
        'company_name': self.job_title,
        'company_size': self.company_size,
        'subject': self.subject
    }</pre>
<p>In the preceding <a id="_idIndexMarker723"/>snippet, the <code>EventRegistration</code> class represents a model for event registration in a database. </p>
<p>The <code>__tablename__</code> attribute specifies the name of the table in the database that this model is stored in. The <code>db.Model</code> class is a base class for all models in <code>Flask-SQLAlchemy</code>, and the <code>db.Column</code> <a id="_idIndexMarker724"/>objects define the fields of the model, each with a type and some additional options.</p>
<p>The <code>format</code> method returns a dictionary representation of the model instance, with keys corresponding to the field names and values corresponding to the field values.</p>
<p>Now, let’s define the route or endpoint, <code>/api/v1/events-registration</code>:</p>
<pre class="source-code">@app.route("/api/v1/events-registration", methods=['POST'])def add_attendees():
    if request.method == 'POST':
        first_name = request.get_json().get('first_name')
        last_name = request.get_json().get('last_name')
        email = request.get_json().get('email')
        phone = request.get_json().get('phone')
        job_title = request.get_json().get('job_title')
        company_name = request.get_json().get('company_name')
        company_size = request.get_json().get('company_size')
        subject = request.get_json().get('subject')
        if first_name and last_name and email and phone and subject:
            all_attendees = EventRegistration.query.filter_by(
                email=email).first()
            if all_attendees:
                return jsonify(message="Email address already                     exists!"), 409
            else:
                new_attendee = EventRegistration(
                    first_name = first_name,
                    last_name = last_name,
                    email = email,
                    phone = phone,
                    job_title = job_title,
                    company_name = company_name,
                    company_size = company_size,
                    subject = subject
                )
                db.session.add(new_attendee)
                db.session.commit()
                return jsonify({
                    'success': True,
                    'new_attendee': new_attendee.format()
                }), 201
        else:
            return jsonify({'error': 'Invalid input'}), 400</pre>
<p>The <code>/api/v1/events-registration</code> endpoint function handles an HTTP <code>POST</code> request to the <code>/api/v1/events-registration</code> route. This endpoint allows users to register for events by providing their <a id="_idIndexMarker725"/>name, email address, phone number, and subject.</p>
<p>The endpoint function first checks that the request method is indeed <code>POST</code>, and then extracts the name, email, phone, and subject values from the request body, which is expected to be in JSON format. </p>
<p>Next, the function checks that all of the required input values (<code>first_name</code>,<code> last_name,</code> <code>email</code>, <code>phone</code>, and <code>subject</code>) are present. If they are, it checks whether there is already an attendee with the same email address in the database. If there is, it returns a JSON response, with a message indicating that the email address is already in use, and an HTTP <code>409</code> status code (conflict).</p>
<p>If the email address is not in use, the function creates a new <code>EventRegistration</code> object with the input values, adds it to the database session, and commits the changes to the database. It then returns a JSON response with a success message and the details of the new attendee, along with an HTTP <code>201</code> status code (created).</p>
<p>If any of the required input values is missing, the function returns a JSON response with an error message and an HTTP <code>400</code> status code (bad request). Now, let’s update the database and add an <code>eventregistration</code> table to it. The <code>eventregistration</code> table will accept all the entries for the event registrations.</p>
<p> The following steps create the <code>eventregistration</code> table in the database. In the terminal of the <code>project</code> directory, enter the following commands: </p>
<pre class="console">flask shellfrom app import db, EventRegistration
db.create_all()</pre>
<p>Alternatively, you can continue to use migration tools:</p>
<pre class="console">flask db migrate –m "events attendee table added"flask db upgrade</pre>
<p>With any of these options, the backend will contain the new table. </p>
<p>Execute <code>flask run</code> in the <a id="_idIndexMarker726"/>terminal to start the Flask development server on <code>localhost</code> using the default port (<code>5000</code>).</p>
<p>That’s it! The backend is now ready to receive form entries from the React frontend. Let’s design the form component in React and submit the form entries to the Flask backend.</p>
<h1 id="_idParaDest-196"><a id="_idTextAnchor229"/>Handling forms in React and Flask</h1>
<p>Handling forms in a React <a id="_idIndexMarker727"/>frontend and a Flask backend is a common pattern in web <a id="_idIndexMarker728"/>development. In this pattern, the React frontend sends HTTP requests to the Flask backend to submit or retrieve form data.</p>
<p>On the React frontend side, you can use a<a id="_idIndexMarker729"/> form component to render a form and handle form submissions. You can use controlled components, such as <code>input</code>, <code>textarea</code>, and <code>select</code>, to control the form values and update the component state as a user inputs data.</p>
<p>When the user submits the form, you can use an event handler to prevent the default form submission behavior and send an HTTP request to the Flask backend using a library such as Axios. In this section, we will work with the Axios library.</p>
<p>On the Flask backend side, you can define a route to handle the HTTP request and retrieve the form data from the request object. You can then process the form data and return a response to the frontend.</p>
<p>The <code>EventRegistration</code> component provides a simple form for non-authenticated users to register for an event in the frontend of the <em class="italic">Bizza</em> app. The form includes fields for the user’s name, email <a id="_idIndexMarker730"/>address, phone number, and subject – the topic or title of the event they register for.</p>
<p>Let’s dive into the React form<a id="_idIndexMarker731"/> implementation that will work with the Flask backend:</p>
<ol>
<li>In the project directory and inside the <code>components</code> folder, create <code>EventRegistration/EventRegistration.jsx</code>.</li>
<li>Add the following <a id="_idIndexMarker732"/>code snippet to the <code>EventRegistration.jsx</code> file:<pre class="source-code">import React, { useState, useEffect } from 'react';import axios from 'axios';const EventRegistration = () =&gt; {  // Initial form values  const initialValues = {    firstname: '',    lastname: '',    email: '',    phone: '',    job_title: '',    company_name: '',    company_size: '',    subject: '' };  // State variables  const [formValues, setFormValues] =    useState(initialValues); // Stores the form field                                values  const [formErrors, setFormErrors] = useState({});// Stores the form field for the validation errors  const [isSubmitted, setIsSubmitted] =    useState(false); // Tracks whether the form has                        been submitted{/* Rest of the form can be found at the GitHub link - https://github.com/PacktPublishing/Full-Stack-Flask-Web-Development-with-React/tree/main/Chapter-10/ */}            &lt;div id="btn-section"&gt;              &lt;button&gt;Join Now&lt;/button&gt;            &lt;/div&gt;        &lt;/form&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/&gt;);};export default EventRegistration;
POST</strong> request to the <code>/api/v1/events-registration</code> route with the form data. It then updates the component’s state with the response from the server and displays a success or error message to the user.</pre><p class="list-inset">The <code>EventRegistration</code> component also includes a <code>validate</code> function that checks the form values for errors, and an <code>onChangeHandler</code> function that updates the form<a id="_idIndexMarker736"/> values as the user types.</p></li>
</ol>
<p>Let’s discuss the component <a id="_idIndexMarker737"/>state variables used in the preceding code:</p>
<ul>
<li><code>formValues</code>: This is an<a id="_idIndexMarker738"/> object that stores the current values of the form fields (name, email, phone, and subject)</li>
<li><code>formErrors</code>: This is an object that stores any errors found in the form values</li>
<li><code>response</code>: This is an object that stores the response from the server after the form is submitted</li>
<li><code>feedback</code>: This is a string that stores a feedback message to display to the user (for example, <strong class="bold">Registration successful!</strong>)</li>
<li><code>status</code>: This is a string that stores the status of the form submission (for example, <strong class="bold">success</strong> or <strong class="bold">error</strong>)</li>
</ul>
<p>We then define the following functions:</p>
<ul>
<li><code>validate</code>: This is a function that accepts the form values and returns an object with any errors found in the values.</li>
<li><code>onChangeHandler</code>: This is a function that updates the <code>formValues</code> state variable as the <code>user</code> types in the form fields.</li>
<li><code>handleSubmit</code>: This is a function that is called when the form is submitted. It prevents the default form submission behavior, calls the <code>validate</code> function to check for errors, and then sends the form data to the server using the <code>sendEventData</code> function. It also updates the feedback and status state variables based on the response from the server.</li>
<li><code>sendEventData</code>: This is an <code>async</code> function that sends an HTTP <code>POST</code> request to the <code>/api/v1/events-registration</code> route with the form data and updates the response state variable with the response from the server.</li>
</ul>
<p>The <code>EventRegistration</code> component also has a <code>useEffect</code> hook that calls the <code>sendEventData</code> function when the <code>formValues</code> state variable changes. Finally, the <code>EventRegistration</code> component renders a form element with the form fields and displays the feedback message<a id="_idIndexMarker739"/> and status to the user.</p>
<p>Now, start the React <a id="_idIndexMarker740"/>frontend with <code>npm start</code> and submit your form entries. Make sure the Flask server is running as well. With any development process, issues <a id="_idIndexMarker741"/>and bugs are bound to arise. We will explore some valuable troubleshooting tips to help you debug and fix issues during the integration of the React frontend and the Flask backend.</p>
<h1 id="_idParaDest-197"><a id="_idTextAnchor230"/>Troubleshooting tips for the React frontend and the Flask backend</h1>
<p>Integrating a React frontend with<a id="_idIndexMarker742"/> a Flask backend can be a powerful combination to build dynamic and scalable web applications. However, like any integration, it<a id="_idIndexMarker743"/> can come with its own set of unavoidable challenges. Troubleshooting issues that arise during the React-Flask integration process requires a systematic approach to identify and resolve problems effectively.</p>
<p>This section will discuss how you can resolve some of the issues that you may encounter while integrating the frontend with the backend. By following these tips, you will be able to diagnose and resolve common problems that may arise during the development and deployment of your application.</p>
<p>Let’s dive into the troubleshooting tips for the React frontend and the Flask backend integration:</p>
<ul>
<li><strong class="bold">Verifying the </strong><strong class="bold">Flask setup</strong>:<ul><li>Ensure that Flask is properly configured and running on the server</li>
<li>Check the Flask server<a id="_idIndexMarker744"/> console for any error messages or exceptions that may indicate misconfigurations</li>
<li>Confirm that the necessary<a id="_idIndexMarker745"/> Flask packages and dependencies are installed</li>
<li>Verify that<a id="_idIndexMarker746"/> the Flask server is accessible and responding to requests by testing basic endpoints</li>
</ul></li>
<li><strong class="bold">Checking the </strong><strong class="bold">React configuration</strong>:<ul><li>Ensure that the React<a id="_idIndexMarker747"/> application is correctly configured and running</li>
<li>Confirm that the necessary dependencies and packages are installed in the React project</li>
<li>Inspect the console logs in the browser’s developer tools for any JavaScript errors or warnings that may indicate issues with the frontend setup</li>
<li>Ensure that the proxy attribute is added to <code>package.json</code> and points to the Flask server address – for example, <code>http://127.0.0.1:5000</code></li>
</ul></li>
<li><strong class="bold">Investigate </strong><strong class="bold">network requests</strong>:<ul><li>Use the browser's developer tools <a id="_idIndexMarker748"/>to inspect network requests made by the React application</li>
<li>Verify that the requests are sent to the correct Flask endpoints</li>
<li>Check the network response status codes to identify any server-side errors</li>
<li>Inspect the response payloads to ensure that data is transmitted correctly</li>
<li>Pay attention to <strong class="bold">Cross-Origin Resource Sharing</strong> (<strong class="bold">CORS</strong>) issues if the React frontend and<a id="_idIndexMarker749"/> the Flask backend are hosted on different domains or ports</li>
</ul></li>
</ul>
<p>By following these troubleshooting <a id="_idIndexMarker750"/>tips, you will be equipped with the necessary knowledge to efficiently diagnose and resolve issues in the React-Flask integration. This will ensure a smooth and robust integration for your web application.</p>
<h1 id="_idParaDest-198"><a id="_idTextAnchor231"/>Summary</h1>
<p>In this chapter, we discussed extensively the application code structure and a few key steps required to integrate a React frontend with a Flask backend. First, you will need to set up the frontend to communicate with the backend, using an HTTP client library, and handle forms and user input.</p>
<p>Then, you will need to set up the Flask backend with the necessary routes and functions to handle the requests from the frontend and process the form data. Finally, you will need to test the entire application to ensure that it works correctly and as expected.</p>
<p>With these steps, you can successfully integrate a React frontend with a Flask backend for your web application. In the next chapter, we will scale up the React-Flask interactions by creating more tables. These tables will have relationships, and we will be able to fetch and display data.</p>
</div>
</body></html>