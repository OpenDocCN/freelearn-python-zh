- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Building an IoT Weather Indicator
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建物联网天气指示器
- en: 'In this chapter, we will learn about servo motors and LEDs and then use this
    knowledge, along with our understanding of the Raspberry Pi and web services,
    to create a practical project: an IoT weather indicator.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习伺服电机和LED，然后利用这些知识，结合我们对树莓派和网络服务的理解，来创建一个实际项目：一个物联网天气指示器。
- en: The weather indicator will draw weather information from a web service and then
    use a pointer attached to the servo motor to indicate suitable attire based on
    the current outdoor conditions. It will include an LED that turns on when it’s
    raining and blinks on and off if there is a thunderstorm. The configuration that
    you’ll use to create this application may be used for other applications, such
    as a water quality monitor or a traffic density monitor.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 该天气指示器将从网络服务中获取天气信息，然后使用连接到伺服电机的指针来根据当前的户外条件指示合适的着装。它将包括一个在下雨时开启并在雷暴时闪烁的LED。您用于创建此应用程序的配置可能用于其他应用程序，例如水质监测器或交通密度监测器。
- en: We’ll start by looking at servo motors, which will help us understand what they
    are and how we may use them in our IoT applications. Then, we’ll focus on LEDs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从查看伺服电机开始，这将帮助我们了解它们是什么以及我们如何在物联网应用程序中使用它们。然后，我们将专注于LED。
- en: Following that, we’ll begin constructing a physical stand to house the components
    for our application. This will be the second specially designed stand for the
    Raspberry Pi that we will build for this book and the first one that features
    a motor.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们将开始构建一个物理支架来容纳我们应用程序的组件。这将是我们为本书构建的第二个专门设计的树莓派支架，也是第一个带有电机的支架。
- en: While the usage of the SenseHAT case, as discussed in *Chapters 1* and *2*,
    was optional, it is recommended to build this stand for the weather indicator.
    This construction will represent our first foray into creating a tangible, physical
    entity, or more specifically, an Internet of Things (IoT) *thing*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在第1章和第2章中讨论的SenseHAT外壳的使用是可选的，但建议为天气指示器构建此支架。这个构建将代表我们第一次尝试创建一个有形的、物理的实体，或者更具体地说，是一个物联网（IoT）*事物*。
- en: 'Once our stand has been assembled, we’ll dive into coding. Our goal will be
    to extract information from the **OpenWeatherMap** web service and utilize it
    to dictate the position of the needle affixed to our servo motor based on the
    temperature and wind speed. We will also adjust the LED’s behavior according to
    certain weather conditions. By implementing these processes, we will illustrate
    how real-world data can be transformed into physical movements, bridging the gap
    between the digital and mechanical worlds:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的设备组装完成，我们就会开始编码。我们的目标是从**OpenWeatherMap**网络服务中提取信息，并利用它来根据温度和风速来控制我们伺服电机上固定针的位置。我们还将根据某些天气条件调整LED的行为。通过实施这些过程，我们将展示如何将现实世界的数据转化为物理运动，架起数字世界和机械世界之间的桥梁：
- en: '![Figure 3.1 – Connecting our weather indicator to a web service](img/B21282_03_1.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 将我们的天气指示器连接到网络服务](img/B21282_03_1.jpg)'
- en: Figure 3.1 – Connecting our weather indicator to a web service
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 将我们的天气指示器连接到网络服务
- en: 'In this chapter, we will explore the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Looking into servo motors
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索伺服电机
- en: Exploring LEDs
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索LED
- en: Controlling servo motors and LEDs using Python
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python控制伺服电机和LED
- en: Building the weather indicator stand
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建天气指示器支架
- en: Developing code for our application
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的应用程序开发代码
- en: Let’s begin!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You’ll need the following to complete this chapter:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章，您需要以下物品：
- en: The Raspberry Pi 5 4/8 GB model is preferred, but the Raspberry Pi 4B with either
    4 GB or 8 GB may be used (the figures in this book show the Raspberry Pi 4B model).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议使用树莓派5 4/8 GB型号，但也可以使用带有4 GB或8 GB的树莓派4B（本书中的图示显示的是树莓派4B型号）。
- en: The latest Raspberry Pi operating system with Thonny pre-installed.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有预装Thonny的最新树莓派操作系统。
- en: A keyboard, mouse, and monitor.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘、鼠标和显示器。
- en: 1x SG90 servo motor.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个SG90伺服电机。
- en: 1x LED (single color).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个LED（单色）。
- en: 1x 220 Ohm resistor.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个220欧姆电阻。
- en: ½ inch PVC pipe.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ½英寸PVC管。
- en: Jumper wires with connectors for the Raspberry Pi’s **general-purpose input/output**
    (**GPIO**) port.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于树莓派**通用输入/输出**（**GPIO**）端口的跳线带连接器。
- en: Access to a 3D printer or 3D printing service for the custom stand.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于定制支架的3D打印机或3D打印服务。
- en: A general knowledge of programming. We will be using the Python programming
    language in this book.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GitHub repository for this chapter is located at [https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter3](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter3).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Looking into servo motors
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Servo motors** are widely used in robotics, automation, and other applications
    where precise control of angular movement is required. Hooking up servo motors
    to the Raspberry Pi is a straightforward process that offers exciting possibilities
    for various projects. The Raspberry Pi provides a suitable platform to interface
    and control servo motors. In this section, we will investigate servo motors in
    more detail.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the GPIO port
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The GPIO port on the Raspberry Pi allows for direct hardware interaction, making
    it a key tool for hands-on projects. It allows us to connect devices, sensors,
    and circuits, allowing for real-world applications such as robotics or alarm systems
    to be created. By utilizing these pins, we can design and build projects that
    interact with the physical world. We will cover the GPIO port in more depth in
    [*Chapter 5*](B21282_05.xhtml#_idTextAnchor080). For now, it is enough to know
    that we can simply connect devices such as servo motors and LEDs to the GPIO port
    using female jumper connectors.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: We will start by hooking up an SG90 servo motor to our Raspberry Pi 5 using
    the GPIO port.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the SG90 servo motor to our Raspberry Pi
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SG90 servo motor is a popular and widely used micro-servo motor due to its
    compact size, versatility, precise control, and ease of use. When connecting the
    SG90 servo motor to our Raspberry Pi, it is necessary to modify the wire alignment
    within the female 3-prong connector. This connector is commonly known as the **JR-style
    servo connector** or simply **servo connector** and is initially wired with the
    power (+5V) and GND wires in reverse order from what is required for our Raspberry
    Pi.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Referring to *Figure 3**.2*, we can adjust the wiring by performing the following
    steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: First, identify the three wires in the connector – red (power), brown (ground),
    and orange (signal).
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, gently pull the wires from the connector while holding the plastic housing
    up using a sharp object such as an Xacto knife.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, rearrange them so that the red (power) wire is at one end, the brown
    (GND) wire is in the middle, and the orange (signal) wire is at the opposite end
    of the red wire:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Changing the wiring order for the SG90 servo](img/B21282_03_2.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Changing the wiring order for the SG90 servo
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'With the wiring in the correct order, we can connect the servo motor directly
    to our Raspberry Pi. Using the diagram in *Figure 3**.3* as a reference, connect
    the female 3-prong connector to the +5V, GND, and GPIO 14 pins of the Raspberry
    Pi:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Connecting our servo to the Raspberry Pi](img/B21282_03_3.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 将我们的伺服电机连接到Raspberry Pi](img/B21282_03_3.jpg)'
- en: Figure 3.3 – Connecting our servo to the Raspberry Pi
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 将我们的伺服电机连接到Raspberry Pi
- en: An alternate method for connecting our servo
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 连接我们的伺服电机的另一种方法
- en: For those of us who would rather not modify the existing connector of the servo,
    we may use three male-to-female jumper wires instead, with the male end inserted
    into the connector and the female end inserted into the GPIO port on the Raspberry
    Pi.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不想修改伺服电机现有连接器的人来说，我们可以使用三根公对母跳线代替，公端插入连接器，母端插入Raspberry Pi的GPIO端口。
- en: With our servo motor connected to our Raspberry Pi, let’s investigate what servo
    motors are and how we may use them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的伺服电机连接到我们的Raspberry Pi后，让我们来研究伺服电机是什么以及我们如何使用它们。
- en: Understanding servo motors
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解伺服电机
- en: Servo motors consist of a **direct current** (**DC**) motor, a control circuit,
    and a feedback mechanism for maintaining the angular position of the output shaft.
    Robotics, toys, and radio-controlled cars are some of the applications where servos
    are predominantly used.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服电机由一个**直流**（**DC**）电机、一个控制电路以及一个用于维持输出轴角位置的反馈机制组成。机器人、玩具和遥控汽车是伺服电机主要应用的一些领域。
- en: 'Servo motors stand out for their exceptional precision in controlling the position
    of the motor thanks to their closed-loop feedback mechanism. This mechanism constantly
    monitors the motor’s actual position and adjusts it so that it matches the desired
    position, ensuring accurate and reliable performance. *Figure 3**.4* shows the
    popular SG90 servo motor:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服电机因其闭环反馈机制在控制电机位置方面的卓越精度而脱颖而出。该机制不断监控电机的实际位置，并调整它以匹配所需位置，确保准确可靠的性能。*图3.4*展示了流行的SG90伺服电机：
- en: '![Figure 3.4 – SG90 servo motor](img/B21282_03_4.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – SG90伺服电机](img/B21282_03_4.jpg)'
- en: Figure 3.4 – SG90 servo motor
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – SG90伺服电机
- en: The range of movement for servo motors can vary, depending on the model. Some
    servos are designed for 180-degree movement, making them ideal for limited-range
    applications such as controlling robot joints or stabilizing camera gimbals. Other
    servos are capable of full 360-degree rotation, which makes them suitable for
    continuous motion applications, such as steering mechanisms or pan-tilt camera
    systems.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服电机的运动范围可能因型号而异。一些伺服电机设计为180度运动，这使得它们非常适合范围受限的应用，如控制机器人关节或稳定相机云台。其他伺服电机能够实现完整的360度旋转，这使得它们适用于连续运动应用，如转向机构或俯仰倾斜相机系统。
- en: 'The angle control of servos is achieved through **pulse-width modulation**
    (**PWM**). PWM involves sending varying pulse widths to the servo, akin to adjusting
    a volume knob to control sound level; in servos, these pulses dictate the arm’s
    position. Different brands of servo have different maximum and minimum values
    to determine the angle of the servo needle. *Figure 3**.5* demonstrates the relationship
    between PWM and the position of a 180-degree servo:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服电机的角度控制是通过**脉冲宽度调制**（**PWM**）实现的。PWM涉及向伺服电机发送不同脉冲宽度，类似于调整音量旋钮来控制音量；在伺服电机中，这些脉冲决定了臂的位置。不同品牌的伺服电机有不同的最大和最小值，用于确定伺服针的角度。*图3.5*展示了PWM与180度伺服电机位置之间的关系：
- en: '![Figure 3.5 – PWM and servo position](img/B21282_03_5.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – PWM和伺服位置](img/B21282_03_5.jpg)'
- en: Figure 3.5 – PWM and servo position
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – PWM和伺服位置
- en: Armed with our knowledge of the essentials of servo motors and their connection
    to the Raspberry Pi 5, we’ll turn our attention to LEDs. Our exploration will
    cover how they function and the steps to incorporate them into our project, providing
    an additional layer of visual feedback.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了伺服电机的基本原理及其与Raspberry Pi 5的连接方法后，我们将把注意力转向LED。我们的探索将涵盖它们的工作原理以及将它们纳入我们项目的步骤，从而提供额外的视觉反馈层。
- en: Exploring LEDs
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索LED
- en: LEDs were first developed in the early 1960s. The first LEDs were red and were
    first used as indicators in seven-segment displays. Today, LEDs are virtually
    everywhere – from indicator lights on our electronic devices and home appliances
    to the screens of our televisions and smartphones.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: LED最初在20世纪60年代初被开发出来。最早的LED是红色的，最初用于七段显示屏的指示器。如今，LED几乎无处不在——从我们的电子设备和家用电器上的指示灯到电视和智能手机的屏幕。
- en: An LED is a simple semiconductor device. It has two leads – an anode (positive)
    and a cathode (negative). When a forward current passes through the diode from
    the anode to the cathode, it emits light. The color of the light depends on the
    materials that are used to make the diode and can range from infrared to ultraviolet,
    including all the colors of the visible spectrum.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: LED是一种简单的半导体器件。它有两个引脚——阳极（正极）和阴极（负极）。当正向电流从阳极通过二极管流向阴极时，它会发光。光的颜色取决于制造二极管所使用的材料，可以从红外到紫外，包括所有可见光谱的颜色。
- en: 'LEDs come in various types, including single-color LEDs, RGB LEDs, which are
    capable of producing a multitude of colors, infrared LEDs, which are used in remote
    controls and night-vision systems, and bi-color LEDs, which can emit two different
    colors. *Figure 3**.6* shows an array of LEDs ranging from a single-colored red
    to a seven-colored flash LED (second from left) to an RGB (second from right)
    LED capable of displaying any color. For our weather indicator, we will be using
    a single-colored LED. The color doesn’t matter:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: LED有多种类型，包括单色LED、RGB LED，能够产生多种颜色，红外LED，用于遥控器和夜视系统，以及双色LED，可以发出两种不同的颜色。*图3.6*显示了从单色红色到七色闪光LED（从左数第二）再到能够显示任何颜色的RGB
    LED（从右数第二）的LED阵列。对于我们的天气指示器，我们将使用单色LED。颜色不重要：
- en: '![Figure 3.6 – LEDs in various formats](img/B21282_03_6.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – 各种格式的LED](img/B21282_03_6.jpg)'
- en: Figure 3.6 – LEDs in various formats
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 各种格式的LED
- en: Now that we have a basic understanding of LEDs, it’s time to connect an LED
    to our Raspberry Pi.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对LED有了基本的了解，是时候将LED连接到我们的树莓派上了。
- en: Connecting an LED to our Raspberry Pi
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将LED连接到我们的树莓派
- en: Connecting an LED to a Raspberry Pi requires us to carefully consider voltage
    requirements – exceeding the voltage can cause the LED to burn out. To do this,
    we must solder a resistor to one end of the LED before connecting it to the GPIO
    port with jumper wires. Since the Raspberry Pi’s GPIO pins output at a higher
    voltage than most LEDs can handle directly, the inclusion of the resistor is essential
    to regulate the voltage, ensuring that the LED operates correctly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将LED连接到树莓派需要我们仔细考虑电压要求——电压过高可能会导致LED烧毁。为此，我们必须在将LED通过跳线连接到GPIO端口之前，将其一端焊接上一个电阻。由于树莓派的GPIO引脚输出的电压高于大多数LED可以直接处理的电压，因此加入电阻对于调节电压至关重要，以确保LED正确运行。
- en: '*Figure 3**.7* shows the materials that we need to connect our LED to the GPIO
    port on the Raspberry Pi – an LED, two jumper wires with female ends (brown and
    red), shrink tubing, and a 220 Ohm resistor:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.7*显示了连接我们的LED到树莓派GPIO端口的所需材料——一个LED、两根带有雌性端子的跳线（棕色和红色）、热缩管和一个220欧姆电阻：'
- en: '![Figure 3.7 – The parts that are required to connect our LED to the Raspberry
    Pi](img/B21282_03_7.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 连接我们的LED到树莓派所需的部件](img/B21282_03_7.jpg)'
- en: Figure 3.7 – The parts that are required to connect our LED to the Raspberry
    Pi
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 连接我们的LED到树莓派所需的部件
- en: 'To connect our LED to our Raspberry Pi, we must do the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的LED连接到我们的树莓派，我们必须执行以下操作：
- en: 'Start by soldering the resistor to the anode (positive) or longer leg of the
    LED (see *A* in *Figure 3**.8*):'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将电阻焊接在LED的正极（阳极）或较长的腿上（见图3.8中的*A*）：
- en: '![Figure 3.8 – Soldering a resistor and jumper wires to our LED](img/B21282_03_8.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – 将电阻和跳线焊接到我们的LED上](img/B21282_03_8.jpg)'
- en: Figure 3.8 – Soldering a resistor and jumper wires to our LED
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 将电阻和跳线焊接到我们的LED上
- en: Then, splice and solder the brown jumper wire onto the cathode (negative) leg
    of the LED (see *B* in *Figure 3**.8*).
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将棕色跳线焊接在LED的负极（阴极）腿上（见图3.8中的*B*）。
- en: Next, splice and solder the red jumper wire onto the other end of the resistor.
    We may consider the extra length created by the resistor and shorten the red wire
    accordingly (see *B* in *Figure 3**.8*).
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将红色跳线焊接在电阻的另一端。我们可以考虑电阻产生的额外长度，并相应地缩短红色电线（见图3.8中的*B*）。
- en: To strengthen the new connections and provide additional electrical insulation,
    apply heat shrink tubing over the soldered wires and resistor (see *C* in *Figure
    3**.8*).
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了加强新的连接并提供额外的电气绝缘，在焊接的电线和电阻上应用热缩管（见图3.8中的*C*）。
- en: 'Using the jumper wires, attach the brown wire to GPIO GND on the Raspberry
    Pi and the red wire to GPIO 25 (see *Figure 3**.9*):'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用跳线，将棕色电线连接到树莓派的GPIO GND，将红色电线连接到GPIO 25（见图3.9）：
- en: '![Figure 3.9 – Wiring up our servo and LED to the Raspberry Pi](img/B21282_03_9.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – 将我们的伺服电机和LED连接到Raspberry Pi](img/B21282_03_9.jpg)'
- en: Figure 3.9 – Wiring up our servo and LED to the Raspberry Pi
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – 将我们的伺服电机和LED连接到Raspberry Pi
- en: Now that we’ve wired up our servo and LED components, let’s write some code
    so that we can control our components through Python.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经连接了伺服电机和LED组件，让我们编写一些代码，以便我们可以通过Python控制我们的组件。
- en: Controlling servo motors and LEDs using Python
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python控制伺服电机和LED
- en: Having successfully connected the servo motor and LED to our Raspberry Pi, we’ll
    start writing the Python control code. To facilitate this, we will be using the
    **GPIO Zero Python library**, a powerful tool for Raspberry Pi GPIO programming.
    Our first step in this process will be to set up a Python virtual environment
    so that we can develop our code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 成功将伺服电机和LED连接到我们的Raspberry Pi后，我们将开始编写Python控制代码。为了便于操作，我们将使用**GPIO Zero Python库**，这是一个用于Raspberry
    Pi GPIO编程的强大工具。在此过程中的第一步将是设置一个Python虚拟环境，以便我们可以开发我们的代码。
- en: Setting up our development environment
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的开发环境
- en: 'Just like we did in [*Chapter 2*](B21282_02.xhtml#_idTextAnchor031), we will
    use a Python virtual environment for our development. As there are libraries that
    only work with the root installation of Python, we will use system packages in
    our Python virtual environment. To do this, follow these steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在[*第二章*](B21282_02.xhtml#_idTextAnchor031)中所做的那样，我们将为我们的开发使用Python虚拟环境。由于有一些库只能与Python的根安装一起工作，因此我们将使用系统包在我们的Python虚拟环境中。为此，请按照以下步骤操作：
- en: On our Raspberry Pi 5, open a Terminal application.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的Raspberry Pi 5上，打开一个终端应用程序。
- en: 'To store our project files, create a new directory by running the following
    command:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要存储我们的项目文件，创建一个新的目录，运行以下命令：
- en: '[PRE0]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, navigate to the new directory:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，导航到新目录：
- en: '[PRE1]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a new Python virtual environment for our project:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的项目创建一个新的Python虚拟环境：
- en: '[PRE2]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: source ch3-env/bin/activate
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: source ch3-env/bin/activate
- en: '[PRE3]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Install the extra packages that are required for our code with the following
    command:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装我们代码所需的额外包：
- en: '[PRE4]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: exit
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 退出
- en: '[PRE5]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With our project folder created, our Python virtual environment set up and activated,
    and the `requests` package installed, we may now start writing code. We will start
    by controlling the servo motor through Python code using the Terminal.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建项目文件夹、设置并激活Python虚拟环境以及安装`requests`包之后，我们现在可以开始编写代码。我们将首先通过Python代码使用终端控制伺服电机。
- en: Using GPIO Zero to control a servo
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GPIO Zero控制伺服电机
- en: GPIO Zero is a Python library for controlling the GPIO pins on the Raspberry
    Pi. It was created in 2016 by Ben Nuttall and Dave Jones of the Raspberry Pi Foundation.
    GPIO Zero provides a user-friendly and high-level interface, making it easier
    to work with GPIO, including controlling LEDs, buttons, servos, and more. It comes
    pre-installed with the latest Raspberry Pi operating system.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO Zero是一个用于控制Raspberry Pi上GPIO引脚的Python库。它是由Raspberry Pi基金会的Ben Nuttall和Dave
    Jones于2016年创建的。GPIO Zero提供了一个用户友好的高级接口，使得与GPIO一起工作更加容易，包括控制LED、按钮、伺服电机等。它随最新的Raspberry
    Pi操作系统预安装。
- en: 'The `Servo` class is a part of GPIO Zero and provides a way to control a servo
    motor. To test our servo motor’s connection to our Raspberry Pi, follow these
    steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Servo`类是GPIO Zero的一部分，提供了一种控制伺服电机的方法。为了测试我们的伺服电机与Raspberry Pi的连接，请按照以下步骤操作：'
- en: 'Open a Terminal window and navigate to our project folder by running the following
    command:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，通过运行以下命令导航到我们的项目文件夹：
- en: '[PRE6]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'ch3-env virtual environment and launch Python with the following command:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用以下命令启动ch3-env虚拟环境并运行Python：
- en: '[PRE7]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: from gpiozero import Servo
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: from gpiozero import Servo
- en: 'Servo class provides several useful methods to control a servo motor. To set
    the servo to the minimum position, run the following command:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 伺服类提供了几个有用的方法来控制伺服电机。要将伺服设置到最小位置，运行以下命令：
- en: '[PRE8]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After executing this command, we should notice that our servo motor has pivoted
    completely to one side. To move our servo motor to the middle position, we can
    use the following Python command:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此命令后，我们应该注意到我们的伺服电机已经完全转向一侧。为了将我们的伺服电机移动到中间位置，我们可以使用以下Python命令：
- en: '[PRE11]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After executing this command, we should observe that our servo motor has moved
    to the mid position. For the final test, we’ll move our servo motor to the maximum
    position:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此命令后，我们应该观察到我们的伺服电机已经移动到中间位置。对于最终测试，我们将把伺服电机移动到最大位置：
- en: '[PRE12]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We should observe that our servo motor moves to the maximum position (we shouldn’t
    be alarmed if the motor doesn’t move as far to the maximum position as it does
    to the minimum position as we will calibrate the motor later in this chapter).
    To close our servo connection, run the following command:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Why is the servo motor jittering?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: We may observe jittering from our SG90 servo motor when it’s controlled through
    GPIO Zero. A multitude of factors may contribute to this issue, ranging from the
    power provided to the servo via the GPIO port, to potential mechanical problems
    with the servo, or even software-related issues within the library. Although an
    investigation into these causes falls outside the scope of this project, we must
    acknowledge the potential for motor jittering. A straightforward solution involves
    closing the connection to the servo using the `servo.close()` command after setting
    its position.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: With our servo motor tested, we can focus on the LED. In the next section, we
    will write some code to control the status of our LED using the GPIO library.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Using GPIO Zero to control an LED
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `LED` class is a part of the GPIO Zero library and provides a simple interface
    to control an LED. We can use this class to control our LED. To test the connection
    of our LED, follow these steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open a new Terminal window and navigate to our project folder with the
    following command:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: source ch3-env/bin/activate
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Launch Python by running the following command:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: from gpiozero import LED
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'LED class provides several useful methods to control an LED. To turn on the
    LED, type the following:'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After executing this command, we should notice that our LED has turned on.
    For the next test, we’ll turn our LED off by running the following Python command:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After executing this command, we should observe that our LED has turned off.
    For the final test, we’ll blink our LED:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We should observe that our LED starts blinking. To stop this and turn the LED
    off, run the following command:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Should we encounter issues during testing, there could be several potential
    causes:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '**Incorrect wiring**: Incorrect wiring is among the most common problems. It’s
    crucial to verify our connections and ensure we’ve wired the correct GPIO pin
    according to our Python script.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Issues with the power supply**: Power supply inadequacies might also lead
    to issues. While the Raspberry Pi’s GPIO pins may not supply adequate power for
    certain servos, especially under load, causing the servo to act unpredictably,
    our SG90 servo and LED shouldn’t face this issue, given they have a lower power
    demand.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software**: Software-related issues could also pose problems. Keeping the
    Raspberry Pi OS and GPIO Zero library up to date is an essential preventative
    measure.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Components**: Issues could lie within the components themselves. By testing
    them with a known, functioning device, we can either confirm or rule out this
    possibility.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we’ve tested our servo and LED components alongside the corresponding
    code, we can construct the stand that will house our project.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经测试了我们的伺服和LED组件以及相应的代码，我们可以构建一个支架来容纳我们的项目。
- en: Building the weather indicator stand
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建天气指示支架
- en: In this section, our focus will shift to assembling the stand for our weather
    indicator. While it’s not imperative for running the code, building the stand
    is highly recommended as it adds a tangible, real-world aspect to our project,
    bringing the *thing* in IoT to life.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们的重点将转向组装天气指示支架。虽然运行代码不是必需的，但构建支架强烈推荐，因为它为我们的项目增添了有形、现实世界的元素，使物联网中的“事物”栩栩如生。
- en: While this book does not provide a comprehensive guide on 3D printing, we will
    briefly outline the key steps involved in fabricating the stand. We’ll be using
    a standard **fused deposition modeling** (**FDM**) printer, ideally one with a
    print size such as the “Ender-3” (220mm x 220mm x 250mm). Our material of choice
    for this exercise is **polylactic acid** (**PLA**) since it’s known for its ease
    of use and suitability for beginners. Alternatively, **polyethylene terephthalate
    glycol-modified** (**PETG**) is also a great option, offering enhanced strength
    and flexibility. We’ll go through the basics of printing and assembling the stand
    components here.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这本书并没有提供关于3D打印的全面指南，但我们将简要概述制造支架的关键步骤。我们将使用标准的**熔融沉积建模**（**FDM**）打印机，理想情况下是像“Ender-3”这样的打印机（220mm
    x 220mm x 250mm）。在这个练习中，我们选择**聚乳酸**（**PLA**）作为材料，因为它易于使用，非常适合初学者。另外，**聚对苯二甲酸乙二醇酯改性**（**PETG**）也是一个很好的选择，它提供了增强的强度和灵活性。在这里，我们将介绍打印和组装支架组件的基本知识。
- en: Should I print in PLA or PETG?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该打印PLA还是PETG？
- en: When deciding whether to print in PLA or PETG, there are several factors for
    us to consider. PLA is known for its ease of use, making it a popular choice for
    beginners. It prints at lower temperatures, doesn’t warp as easily as other materials,
    and generally provides more precise details. PETG is known for its strength and
    flexibility, which surpasses that of PLA. PETG prints at a higher temperature
    than PLA and has excellent layer adhesion, resulting in more robust prints. However,
    PETG can be more challenging to print with due to its tendency to string or ooze.
    For the weather indicator stand we built for this chapter, PLA was used. This
    was because printing was done directly on a glass plate and PETG tends to stick
    too well to glass, potentially resulting in damage being done to the build plate
    upon removing the print.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当决定是否打印PLA或PETG时，我们需要考虑几个因素。PLA因其易于使用而闻名，是初学者的热门选择。它以较低的温度打印，不像其他材料那样容易变形，并且通常提供更精确的细节。PETG以其强度和灵活性而闻名，超过了PLA。PETG的打印温度高于PLA，并且具有出色的层间粘合性，从而产生更坚固的打印件。然而，由于PETG有拉丝或滴漏的倾向，打印起来可能更具挑战性。对于本章中我们构建的天气指示支架，我们使用了PLA。这是因为打印是在玻璃板上直接进行的，而PETG容易粘附在玻璃上，可能会在移除打印件时损坏构建板。
- en: For those of us who do not have access to a 3D printer or prefer not to print
    the parts ourselves, using a 3D printing service such as Shapeways ([https://www.shapeways.com](https://www.shapeways.com))
    is a convenient alternative.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些没有3D打印机或者不愿意自己打印部件的人来说，使用Shapeways（[https://www.shapeways.com](https://www.shapeways.com)）等3D打印服务是一个方便的替代方案。
- en: Now that we’ve covered the options for obtaining our 3D-printed parts, either
    by printing them ourselves or using a service, let’s move on to the next crucial
    phase of our project – assembling the weather indicator stand.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了获取3D打印部件的选项，无论是自己打印还是使用服务，让我们继续进行项目的下一个关键阶段——组装天气指示支架。
- en: Assembling the weather indicator stand
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组装天气指示支架
- en: As mentioned previously, the weather indicator stand has been engineered to
    be composed of components produced via an FDM 3D printer. Unlike the SenseHAT
    case and stand from *Chapters 1* and *2*, the design approach for this weather
    indicator stand is built with a *plate-like* configuration. This method effectively
    eliminates thin horizontal walls, a structural vulnerability that’s frequently
    found in parts created with FDM technology.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，天气指示支架已被设计成由FDM 3D打印机生产的组件组成。与第1章和第2章中的SenseHAT外壳和支架不同，这个天气指示支架的设计方法是采用**板状**配置。这种方法有效地消除了在FDM技术制造的部件中常见的薄水平墙，这是一种结构上的弱点。
- en: Finding the files for 3D printing
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找3D打印的文件
- en: The 3D model files for the parts, which have been specifically designed for
    3D printing, can be downloaded from the `Build Files` directory in this chapter’s
    GitHub repository. Please note that these files are provided in the .stl format
    only, not in other 3D model file formats.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 针对特定3D打印的部件的3D模型文件可以从本章GitHub仓库的“构建文件”目录中下载。请注意，这些文件仅提供.stl格式，不提供其他3D模型文件格式。
- en: Before we start constructing our stand, let’s look at the parts.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建我们的支架之前，让我们看看这些部件。
- en: Identifying the parts
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别部件
- en: '*Figure 3**.10* shows the parts that make up the weather indicator stand. All
    the parts, except for the base, were printed on an FDM 3D printer. Two additional
    parts – a half-inch PVC pipe and the front sticker – aren’t shown:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.10*显示了组成气象指示器支架的部件。所有部件，除了底座外，都是使用FDM 3D打印机打印的。另外两个部件——半英寸PVC管和前贴纸——未显示：'
- en: '![Figure 3.10 – Parts of the weather indicator stand](img/B21282_03_10.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10 – 气象指示器支架部件](img/B21282_03_10.jpg)'
- en: Figure 3.10 – Parts of the weather indicator stand
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – 气象指示器支架部件
- en: 'Let’s take a closer look at each part:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看每个部件：
- en: '**Base**: The base serves as the foundation for our stand. It’s the component
    where the **pipe base** is fastened. While the base is an integral part of the
    design, it can be considered optional, depending on the specific installation.
    For instance, the stand could be attached directly to a table, wall, or even a
    ceiling, offering flexible positioning based on individual preferences and requirements.
    The base displayed in *Figure 3**.10* was created out of 20mm pine wood using
    a CNC router (a computer-controlled cutting machine that’s used for cutting various
    hard materials, such as wood), although a 3D printer may be used to make this
    part as well.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**底座**：底座作为支架的基础。这是固定**管状底座**的组件。虽然底座是设计的一部分，但它可以根据具体的安装情况被认为是可选的。例如，支架可以直接固定在桌子上、墙上，甚至天花板上，根据个人偏好和需求提供灵活的定位。图3.10中显示的底座是用20毫米松木通过CNC路由器（一种用于切割各种硬材料的计算机控制切割机）制作的，尽管也可以使用3D打印机来制作这个部件。'
- en: '**Back plate and front plate**: These halves, when glued together, form the
    stand’s plate. The division into halves aligns with the need for a flat surface
    in 3D printing, given the plate’s lack of an inherent flat side. The plate is
    the main component of our stand as it holds the servo motor, arrow, and Raspberry
    Pi, which is attached to the back. The plate has been designed to hold either
    a Raspberry Pi, a Raspberry Pi Zero, or a Raspberry Pi Pico W.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后板和前板**：这些半块粘合在一起形成支架的板。将它们分成两半是为了适应3D打印时需要平坦表面的需求，因为板本身没有固有的平坦面。板是我们支架的主要组件，因为它支撑着伺服电机、箭头和连接在背面的Raspberry
    Pi。板被设计成可以容纳Raspberry Pi、Raspberry Pi Zero或Raspberry Pi Pico W。'
- en: '**Plate hook**: Designed to be compatible with GoPro series stands, the hook
    provides the main connection of the plate on the stand. Of note here is the deliberate
    printing orientation and built-in support of the plate hook to eliminate line
    adhesion issues that would cause the plate hook to break apart if printed in the
    traditional flat side down (see *Figure 3**.11*):'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**板钩**：设计成与GoPro系列支架兼容，该钩子提供了板上板的主要连接。值得注意的是，板钩的故意打印方向和内置支撑消除了如果以传统平放方式打印（见图3.11）可能会导致的线粘附问题：'
- en: '![Figure 3.11 – Plate hook print orientation](img/B21282_03_11.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11 – 板钩打印方向](img/B21282_03_11.jpg)'
- en: Figure 3.11 – Plate hook print orientation
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – 板钩打印方向
- en: '**Pipe base and plate bracket**: These two components hold the ½ inch PVC pipe
    (not shown). The pipe base attaches the PVC pipe to the base and the plate bracket
    attaches the PVC pipe to the plate hook.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管状底座和板支架**：这两个组件固定了1/2英寸PVC管（未显示）。管状底座将PVC管固定到底座上，板支架将PVC管固定到板钩上。'
- en: '**8mm LED holder**: We utilize the LED holder to fasten the LED onto the front
    of the main plate face.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**8mm LED固定器**：我们使用LED固定器将LED固定在主板面的前面。'
- en: '**Arrow**: The arrow is connected to the servo motor and acts as the analog
    needle for our weather indicator application.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**箭头**：箭头连接到伺服电机，作为我们气象指示应用中的模拟指针。'
- en: '**Alignment tool**: This tool acts as a guide that aligns the back plate and
    front plate correctly during gluing, ensuring they are properly aligned to avoid
    any issues when installing the servo motor.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对齐工具**：这个工具在粘合时作为引导，确保后板和前板正确对齐，避免安装伺服电机时出现任何问题。'
- en: '**PVC pipe (not shown)**: The stand features a half-inch PVC pipe serving as
    its stem or central support. This design offers the flexibility to adjust the
    stand’s height according to our needs. In situations where the base is unnecessary,
    such as when securing it to a table, wall, or ceiling, we can easily set the stand’s
    height to the desired level.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Silhouette` file and a `.svg` file with the cut lines in the `Build Files`
    folder of our GitHub repository.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**M5 20mm bolt and M5 nut (not shown)**: To fasten the plate to the pedestal
    portion of the stand, we use a 20mm M5 bolt and corresponding M5 nut.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the parts identified, let’s start by creating the main plate for our stand.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Assembling the plate
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The plate or face of the weather indicator stand is created by gluing the front
    plate and back plate together. To assemble the plate, follow these steps:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'First, apply epoxy glue to the flat side of one of the plates (see *A* in *Figure
    3**.12*). When applying glue, it’s crucial to avoid spreading glue near the servo
    or LED openings. It’s recommended to apply glue right to the boundaries of the
    plate:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Assembling the plate](img/B21282_03_12.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Assembling the plate
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: After applying glue, put the flat sides of the plates together. Using the alignment
    tool, ensure that the plates are aligned with each other (see *B* in *Figure 3**.12*).
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the plates have been aligned, remove the alignment tool.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should it be needed, use clamps on the plates to prevent any space from forming
    between them. Let the glue dry before proceeding (see *C* in *Figure 3**.12*).
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the plates have dried, apply epoxy glue to the flat part of the hook and
    place it in the groove on the back of the plate (see *D* in *Figure 3**.12*).
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the glue has dried, paint the plate if you wish.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To finish off the assembly, print and cut out the face sticker and apply it
    to the front of the plate inside the ridges (see *A* and *B* in *Figure* *3**.13*,
    respectively):'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Plate face sticker](img/B21282_03_13.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – Plate face sticker
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: With the main plate constructed, it is now time to build the pedestal, which
    will hold the main plate.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Assembling the pedestal
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The pedestal portion of our stand includes the base, the pipe base, the PVC
    pipe, and the plate bracket. To assemble the pedestal, follow these steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by inserting the PVC pipe (cut to a desired length) into the pipe base
    (see *A* in *Figure 3**.14*):'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Assembling the pedestal](img/B21282_03_14.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – Assembling the pedestal
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Then, secure the pipe base to the base, table, wall, or ceiling as desired (see
    *B* in *Figure 3**.14*).
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To finish assembling the pedestal, insert the plate bracket into the top of
    the PVC pipe (see *C* in *Figure 3**.14*).
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pay attention when assembling the pedestal as variations in the manufacturer’s
    PVC pipe could result in an improper fit or difficulty when inserting it into
    the pedestal parts. If the pipe fits too loosely, it is recommended to apply epoxy
    glue to securely attach the pipe. Conversely, if the pipe is too thick to fit
    properly, we have two options: either sand down the insides of the pipe base or
    plate bracket or sand the outside of the pipe to achieve a proper and snug fit.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to be aware that in our example, the components of the pedestal
    were coated with flat black spray paint, so any additional thickness resulting
    from the paint should be considered.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: With the pedestal components constructed, we’re ready to integrate our electronic
    components into our weather indicator stand.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Raspberry Pi, servo, and LED
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With our plate and pedestal constructed, the last thing we must do before putting
    the stand together is install our Raspberry Pi, servo motor, and LED onto the
    plate and wire all these components together.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, follow these steps:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing 10mm M2.5 bolts, fasten our Raspberry Pi to the base of the plate,
    ensuring it aligns correctly with the appropriate stand-offs (see *A* in *Figure
    3**.15*).
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the aid of a hot glue gun (preferred) or epoxy glue, secure our SG90 servo
    to the rear side of the plate. To do this, align the front structure of the SG90
    with the hole present in the plate (see *B* in *Figure 3**.15*):'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Installing the Raspberry Pi, servo, and LED](img/B21282_03_15.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – Installing the Raspberry Pi, servo, and LED
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Referring to the wiring diagrams in *Figure 3**.3* and *Figure 3**.9*, wire
    up our servo motor and LED to the GPIO port of the Raspberry Pi (see *C* in *Figure
    3**.15*).
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With our Raspberry Pi wired up, it’s time to put the LED in place. Start by
    threading the LED through the LED hole in the plate (see *A* in *Figure 3**.16*):'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.16 – Putting our LED in place](img/B21282_03_16.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – Putting our LED in place
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Then, thread the LED through the LED holder and push the holder into the LED
    hole in the front of the plate (see *B* in *Figure 3**.16*).
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our plate fully wired and all the components securely fastened, we can
    attach the plate to the pedestal.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the plate to the pedestal
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By attaching the plate to the pedestal, we will have finished constructing our
    weather indicator stand.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete our stand, follow these steps:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by aligning the hook on the back of the plate with the plate bracket
    on the pedestal (*A* in *Figure 3**.17*):'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.17 – Attaching the plate to the pedestal](img/B21282_03_17.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 – Attaching the plate to the pedestal
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Then, insert a 20mm M5 bolt and fasten it with an M5 nut (see the red rectangle
    in *A* in *Figure 3**.17*).
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, make any final adjustments to the angle of the plate before tightening
    the bolt fully (see *B* in *Figure 3**.17*).
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With that, we’ve finished assembling our weather indicator stand. This setup
    could be repurposed for many other IoT applications, including monitoring traffic
    conditions or tracking fluid levels in industrial environments.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Our next step is to write the code that will retrieve weather data from a web
    service and use it to control the servo motor and LED. Now is also the best time
    to introduce the arrow into our setup as it needs to be calibrated before it can
    be used in our code.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Developing code for our application
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will connect our Raspberry Pi to the `OpenWeatherMap.org`
    web service and use the data to control the position of the needle on our weather
    indicator. For this, we need to use the API key we received from `OpenWeatherMap.org`
    when we set up an account in [*Chapter 2*](B21282_02.xhtml#_idTextAnchor031).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this section, our Raspberry Pi, once mounted, will remain connected
    to a monitor, keyboard, and mouse. When the moment arrives to set up our weather
    indicator independently, all we’ll need is a power source and a means to remotely
    access the Raspberry Pi via SSH. Discussing how to configure a Raspberry Pi so
    that it can operate in *headless* mode falls outside the scope of this chapter.
    However, detailed instructions for this setup can easily be found through various
    online resources. Helpful starting points include the official Raspberry Pi documentation,
    technology-focused forums such as Stack Overflow, and dedicated Raspberry Pi community
    websites and blogs.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'We will follow the software architecture laid out in *Figure 3**.18* for our
    code. At the heart of our architecture is the `WeatherData` class. We will use
    this class to connect to the OpenWeatherMap web service:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 – Software architecture for our weather indicator](img/B21282_03_18.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: Figure 3.18 – Software architecture for our weather indicator
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'The `WeatherData` class fetches and processes weather data from the OpenWeatherMap
    API, while the `WeatherDashboard` class controls the display mechanisms: a needle
    indicator controlled by a servo motor and an LED that changes state based on the
    weather conditions.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: These two classes work together, with `WeatherData` fetching and processing
    data, which is then used by `WeatherDashboard` to adjust the display. To keep
    the data current, the `update_dashboard()` function is set to run in an infinite
    loop, refreshing weather data and updating the display every 30 minutes.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: To address the unique hardware constraint of the servo motor – that is, its
    tendency to jitter if the connection is not closed after a move – we’ll create
    a fresh instance of `WeatherDashboard` (and consequently, a new `Servo` instance)
    with every cycle of the loop. While this approach may not be the most common in
    software design, it’s a practical solution that successfully solves the servo
    jitter issue by *reopening* the connection with each new instance.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin by calibrating the arrow’s (or needle’s) position for optimal application
    performance before we create our `WeatherData` and `WeatherDashboard` classes.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Calibrating the needle
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can use our weather indicator application, we must calibrate the
    needle (or the position of the arrow). To do so, follow these steps:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Close any open Terminals, open a new Terminal window, and navigate to our project
    folder by running the following command:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: source ch3-env/bin/activate
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Launch Python with the following command:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: from gpiozero import Servo
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: servo = Servo(14)
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, set the servo to the mid position with the following command:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using the picture of the face of our weather indicator, install the arrow into
    the servo in the mid position.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the needle (arrow) in place, let’s do some testing. We will start by moving
    the needle to the minimum position with the following command:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We are now ready to write code to control the needle and LED on our weather
    indicator. We will start with the `WeatherData` class.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Creating the WeatherData class
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `WeatherData` class is designed to pull weather information for a given
    city using the OpenWeatherMap API, after which it will process this data to calculate
    servo and LED values based on the temperature, wind speed, and weather conditions.
    When initialized with a city name, the class fetches the weather data for that
    city and stores the temperature, weather conditions, and wind speed. It also provides
    methods, `getServoValue()` and `getLEDValue()`, to determine the output for the
    servo motor and LED, respectively, based on the retrieved weather data.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch Thonny by clicking on the **Menu** icon in the Raspberry Pi taskbar,
    navigating to the **Programming** category, and selecting **Thonny** (*Figure
    3**.19*):'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.19 – Opening Thonny from the main menu](img/B21282_03_19.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: Figure 3.19 – Opening Thonny from the main menu
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: By default, Thonny uses the Raspberry Pi’s built-in version of Python. For our
    project, we will use the Python virtual environment we just created. To start,
    we need to view the project files by clicking on **View** and selecting **Files**
    if it isn’t already selected.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `ch3-env` directory.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, right-click on the folder and select **Activate** **virtual environment**.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once inside Thonny, create a new tab by selecting **File** and then **New**
    or by hitting *Ctrl* + *N* on your keyboard.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s start our code by entering our imports:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, `import requests` imports the `requests` library from Python, which is
    used to send HTTP requests, such as GET and POST requests, to interact with APIs
    or web services (refer to [*Chapter 2*](B21282_02.xhtml#_idTextAnchor031), for
    clarification on HTTP requests).
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, define our class name, `WeatherData`, and our class variables:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Our constructor takes one parameter, `city`. Make the call to the OpenWeatherMap
    web service in the constructor (when an instance of the `WeatherData` class is
    created):'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let’s take a closer look at our code:'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`self.city = city`: saves the city name to the object’s property'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`api_key = ''xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx''`: Sets the OpenWeatherMap API
    key'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`base_url = "http://api.openweathermap.org/data/2.5/weather"`: Sets the base
    URL for the OpenWeatherMap API'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`complete_url = f"{base_url}?q={self.city}&appid={api_key}&units=metric"`:
    Formats the full API URL with the city and API key'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`response = requests.get(complete_url)`: Sends a GET request to the API and
    saves the response'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data = response.json()`: Converts the API response from JSON format into a
    Python dictionary'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if data["cod"] != "404"`: Checks whether the API response is not a 404 error,
    which would indicate that the city was not found'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.temperature = main["temp"]`: Saves the current temperature in the city
    to the object’s property'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.weather_conditions = weather[0]["main"]`: Saves the current weather conditions
    in the city to the object’s property'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.wind_speed = wind["speed"]`: Saves the current wind speed in the city
    to the object’s property'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By making the call to the OpenWeatherMap web service and setting the instance
    variables, all that’s left for our code to do is convert weather data into values
    for our servo motor and LED. We’ll start with the servo motor value and the `getServoValue()`
    method:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here’s a breakdown of our code:'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First, the method checks whether the temperature (`self.temperature`) is less
    than `0`. If the temperature is below zero, `temp_factor` is set to `0`. This
    means that if the temperature is negative, there will be no contribution to the
    final servo value.
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we check whether the temperature is greater than `30`. If this is true,
    then `temp_factor` is set to `1`.
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the temperature falls between 0 and 30 degrees Celsius, then we normalize
    the temperature data. Normalization is the process of bringing or converting values
    into a common range. In this case, the temperature data is being scaled to a range
    of 0 to 1, assuming the temperature is within the range of 0 to 30 degrees Celsius.
    By dividing the temperature by 30, any temperature value within this range is
    proportionally scaled down to a fraction between 0 and 1\. For example, if the
    temperature is 15 degrees Celsius, `temp_factor` will be 0.5\. This normalization
    allows the method to process temperatures consistently, irrespective of their
    actual value.
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`wind_factor = self.wind_speed / 20` calculates the wind factor by normalizing
    the wind speed. Like the temperature normalization process, this line of code
    is used to convert the wind speed into a value within a range of 0 to 1\. The
    wind speed is assumed to be within a range of 0 to 20 kilometers per hour. For
    example, if the wind speed is 10 kilometers per hour, `wind_factor` will be 0.5\.
    Normalization is particularly useful when combining or comparing different types
    of data, such as wind speed and temperature in this case.'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to calculate `servo_value` using both the temperature and wind
    factors. Specifically, it creates a dampening effect on temperature due to wind
    speed, representing a wind chill factor. The formula reduces the temperature factor
    (`temp_factor`) by one-twentieth of the wind factor (`wind_factor`), thereby signifying
    that for every 5% increase in wind speed, the temperature’s impact decreases by
    1%. This is based on our discretionary assumption that wind speed has a cooling
    effect. After this adjustment for wind chill, the resulting value is transformed
    to fit into the range of -1 to 1, which is suitable for the servo’s operation.
    It multiplies the value by 2, shifting the range from 0 to 1 to 0 to 2, and subtracts
    one to adjust the range to -1 to 1\. Finally, the result is negated to account
    for the servo’s directionality (as we discovered when calibrating the needle).
    The calculated `servo_value` represents the position of the servo as per the adjusted
    temperature and wind speed readings.
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, our method returns `servo_value`, which is a value between -1 and 1
    based on temperature, and then adjusted for wind speed. This value is ready to
    be used as input to the servo’s value property in the GPIO Zero library.
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The second method within the `WeatherData` class is utilized to determine the
    operational state of the LED, which varies based on the current weather conditions.
    More specifically, the LED is programmed to flash during a thunderstorm, remain
    solidly illuminated in the event of rain, and be switched off when the weather
    conditions are neither a thunderstorm nor rain. We call this method `getLEDValue()`:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here, the `getLEDValue()` method designates specific values to different weather
    conditions: it returns `2` for thunderstorms, `1` for rain, and `0` for other
    conditions. These values are then utilized to control the LED’s behavior – blinking
    for thunderstorms (`2`), a steady one for rain (`1`), and off for clear weather
    (`0`).'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To test out our program directly, include the following code:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let’s take a closer look:'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`if __name__=="__main__"`: This is the entry point for the program. It is only
    executed when the script is run directly, not when it is imported as a module
    in another script:'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`weather = WeatherData(''Toronto'')`: This creates an object of the `WeatherData`
    class, initializing it with the `''Toronto''` string. We may enter a city of our
    choice. To verify whether the city we are interested in has data available, we
    can enter it into the search box on the OpenWeatherMap website ([https://openweathermap.org/](https://openweathermap.org/)).'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print(weather.getServoValue())`: This is a function call to the `getServoValue()`
    method of the `weather` object. This method calculates a value based on the temperature
    and wind speed data for Toronto and then prints this value to the console.'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print(weather.getLEDValue())`: This calls the `getLEDValue()` method of the
    weather object, which sets a flag based on the weather conditions (thunderstorm,
    rain, or other) for Toronto. This flag determines the state of an LED (flashing,
    on, or off or 2, 1, or 0, respectively) and the method returns this state. The
    state is then printed to the console.'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Save the code and name the file `WeatherData.py`. Run the code by clicking
    the green run button, hitting *F5* on your keyboard, or clicking on the **Run**
    menu option at the top and then **Run current script** (*Figure 3**.20*):'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![  Figure 3.20 – Running a script in Thonny](img/B21282_03_20.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
- en: Figure 3.20 – Running a script in Thonny
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see a response similar to the following:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.21 – Output from running WeatherData.py](img/B21282_03_21.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: Figure 3.21 – Output from running WeatherData.py
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `WeatherData` class written and tested, it’s time to move on to the
    code that controls the weather indicator: the `WeatherDashboard` class.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Creating the WeatherDashboard class
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `WeatherDashboard` class is integral to the operation of the weather indicator
    as it’s responsible for controlling the position of the needle and the state of
    the LED. This class utilizes the `WeatherData` class to gather and interpret weather
    data, which is then utilized to guide the operation of the physical display. The
    position of the servo, which dictates the position of the needle, is determined
    by the temperature and wind speed, while the LED state is indicative of specific
    weather conditions, such as rain or thunderstorms.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'To create this class, follow these steps:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Inside Thonny, activate the `ch3-env` virtual environment if it hasn’t been
    already.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, create a new tab by selecting **File** and then **New** or by hitting
    *Ctrl* + *N* on your keyboard (*Figure 3**.22*):'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.22 – Creating a new file in Thonny](img/B21282_03_22.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
- en: Figure 3.22 – Creating a new file in Thonny
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start with our imports:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, we do the following:'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We start by importing the `Servo` and `LED` classes from the `gpiozero` library.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we import the `sleep` function from the `time` module.
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we import the `WeatherData` class to fetch weather condition data and
    derive the control values for the servo motor and the LED accordingly.
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the imports added, define the class and the class variables:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, we have the following:'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`servoCorrection = 0.5`: This line declares a class-level variable called `servoCorrection`
    and assigns it a value of `0.5`. This is used to adjust the minimum and maximum
    pulse widths for the servo motor.'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxPW = (2.0 + servoCorrection) / 1000`: This line calculates and sets the
    maximum pulse width (`maxPW`) that can be provided to the servo motor. It’s computed
    by adding `2.0` to the `servoCorrection` variable and then dividing the result
    by `1000` to convert it into seconds – the servo motor expects pulse widths in
    seconds.'
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minPW = (1.0 - servoCorrection) / 1000`: Like the previous line, this line
    calculates and sets the minimum pulse width (`minPW`) for the servo motor. It
    subtracts `servoCorrection` from `1.0` and then divides the result by `1000` for
    the same reason as before.'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create our `Servo` and `LED` instance objects while initializing the `WeatherDashboard`
    class:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let’s take a closer look at the code:'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`self.city = city`: This line sets an instance variable, `city`, equal to the
    `city` argument that’s passed when the instance of the class is created. This
    variable represents the city for which weather data will be fetched.'
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.servo = Servo(servo_pin, min_pulse_width=self.minPW, max_pulse_width=self.maxPW)`:
    This line creates a `Servo` object from the GPIO Zero library. The `servo_pin`
    argument specifies the GPIO pin that the servo is connected to. `min_pulse_width=self.minPW`
    and `max_pulse_width=self.maxPW` set the minimum and maximum pulse widths for
    the servo using class variables.'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.led = LED(led_pin)`: This line creates an `LED` object from the GPIO
    Zero library. The `led_pin` argument indicates the GPIO pin the LED is connected
    to. This LED will be controlled based on the weather conditions that have been
    fetched for the specified city.'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `update_status()` method of the `WeatherDashboard` class grabs the latest
    weather information and updates the status of the needle and LED accordingly:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here’s what’s going on in our code:'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`weather_data = WeatherData(self.city)`: This creates an instance of the `WeatherData`
    class using the city that was specified when `WeatherDashboard` was instantiated.
    This object is used to fetch weather data for the city.'
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.servo.value = weather_data.getServoValue()`: This calls the `getServoValue()`
    method on the `weather_data` object to get the value for the servo, based on the
    weather conditions. This value is then set as the new position for the servo motor.'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`led_status = weather_data.getLEDValue()`: This calls the `getLEDValue()` method
    on the `weather_data` object to get the value for the LED status, based on the
    weather conditions.'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The conditional block sets the LED’s status based on the `led_status` value.
    If `led_status` is `0`, it signifies calm weather conditions without any rainfall
    or thunderstorms, so the LED is turned off (`self.led.off()`). If `led_status`
    is `1`, this indicates rain, resulting in the LED being turned on (`self.led.on()`).
    For an `led_status` value of `2`, which is specific to thunderstorm conditions,
    the LED will blink (`self.led.blink()`), representing the intermittent nature
    of thunder and lightning. This value is returned by the `getLEDValue()` method
    in the `WeatherData` class when it detects thunderstorm conditions.
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final method in our `WeatherDashboard` class, `closeServo(),` simply closes
    the `Servo` instance that we created in our class. This is done to keep the servo
    motor from jittering:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Finally, save the code and call it `WeatherDashboard.py`.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We won’t run our code just yet, as we need to add a new method to the file (but
    not the class). We will use this method to create a new `WeatherDashboard` object
    and update the position of the needle and the state of the LED.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Adding the updateDashboard() function and main methods
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `update_dashboard()` function is a standalone function that is defined in
    the same Python file (`WeatherDashboard.py`) as the `WeatherDashboard` class,
    yet sits outside of it. It serves as an interface to encapsulate the process of
    updating the state of the weather dashboard. The reason for creating the `update_dashboard()`
    function is to help in overcoming issues related to servo motor jittering as it
    provides a controlled way to frequently create a fresh instance of the `WeatherDashboard`
    class, thereby *reopening* the `Servo` object connection each time an update to
    the dashboard is made.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'In Thonny, open the `WeatherDashboard.py` file and add the following method
    to the bottom:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let’s take a closer look:'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, we define the `update_dashboard(city, servo_pin, led_pin)` function
    to take three arguments: the city for which the weather data is required, the
    PIN for the servo motor, and the PIN for the LED.'
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Within this function, an instance of the `WeatherDashboard` class, named `weather_dashboard`,
    is created using the given city, servo PIN, and LED PIN as inputs.
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, the `update_status()` method of the `WeatherDashboard` instance is called.
    This method fetches the current weather data for the specified city, determines
    the servo and LED values based on this data, sets the servo’s position, and sets
    the LED’s state (off, on, or blinking) accordingly.
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The program then pauses for 2 seconds using the `sleep(2)` statement. This pause
    ensures that the servo has enough time to move to its new position and that the
    LED displays its new state before any further actions are taken.
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the `closeServo()` method of the `WeatherDashboard` instance is called.
    This method is responsible for closing the connection to the servo motor, which
    is done to avoid potential issues with the servo, such as jittering.
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will add code that only runs when the `WeatherDashboard.py` file is
    executed in Python. We will use this code to run our weather indicator continuously:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let’s take a closer look:'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This block of code will only run when this script (`WeatherDashboard.py`) is
    executed directly based on `if __name__ == "``__main__":`.
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we set the `city`, `servo_pin`, and `led_pin` variables to `Toronto`,
    `14`, and `25`, respectively. Each reader may put in the city of their choice.
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `while True:` loop will continuously execute the code inside it, essentially
    making the script run forever, or until it is stopped manually.
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the loop, the `update_dashboard()` function is called with the `city`,
    `servo_pin`, and `led_pin` values as arguments. This function updates the weather
    dashboard, effectively getting the new weather data and controlling the servo
    and LED accordingly.
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: After updating the dashboard, the script goes into sleep mode for 1,800 seconds,
    or 30 minutes (`sleep(1800)`). This means that the weather dashboard updates every
    30 minutes.
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: After the sleep period, the loop starts over, updating the dashboard again.
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Resave the code and call it `WeatherData.py`.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run our code by clicking the green run button, hitting *F5* on your keyboard,
    or clicking on the **Run** menu option at the top and then **Run** **current script**.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the script is up and running, we’ll see that the position of the needle
    and the state of the LED reflect the current temperature, wind speed, and weather
    conditions accurately.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We may operate our weather indicator application independently, without the
    need for a keyboard, mouse, or monitor to be connected. *Figure 3**.23* shows
    a practical example of how our application advises us on what to wear based on
    the weather in Toronto at the time the photo was taken, also indicating that there’s
    no need for an umbrella:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.23 – It looks like T-shirt weather in Toronto today](img/B21282_03_23.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
- en: Figure 3.23 – It looks like T-shirt weather in Toronto today
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: From the position of the needle on our weather indicator in *Figure 3**.23*,
    we can conclude that it is T-shirt weather in Toronto today.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we developed a weather indicator application, a tool that’s
    designed to provide advice on clothing choices based on current weather conditions.
    This innovative project combined coding expertise with physical component design,
    manifesting not just on a computer screen, but in a real-world, tangible form.
    Central to this was the creation of a custom stand for our weather indicator,
    made from 3D-printed parts. This stand, which was designed to house the LED and
    the servo motor, contributed both practical functionality and aesthetic appeal
    to our project, successfully bridging the gap between the digital and physical
    worlds.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'The lessons learned and the skills gained on this journey have wide-ranging
    applications. To illustrate, envision a new undertaking: a project that utilizes
    environmental sensors to track indoor climate conditions such as temperature,
    humidity, and air quality. The core principles we’ve mastered – from acquiring
    and interpreting data to interacting with hardware components – can be directly
    employed in such a scenario.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Also, it is easy to imagine adding more functionality to our weather indicator.
    For example, imagine replacing our LED with an RGB LED capable of a myriad of
    colors. We could use these different colors and various flashing patterns to indicate
    other types of weather conditions or warnings.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we added to our expertise in Python programming by focusing
    on interfacing with web services for data acquisition and analysis. In parallel,
    we ventured into the world of hardware interfaces, creating a tangible, physical
    component: our custom weather indicator stand.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: With our newly acquired skills, we are poised to tackle a variety of complex
    problems. As demonstrated in our weather indicator project, being able to integrate
    web services, Python programming, and physical components can result in practical
    applications that significantly impact daily life. Whether advising on clothing
    choices based on weather conditions or envisaging new applications such as indoor
    climate monitoring, our abilities have proven versatile and invaluable.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll construct an IoT display with a Raspberry Pi 7-inch
    touchscreen that presents real-time weather and traffic. This will involve exploring
    various screen types and creating a multifunctional dashboard, enhancing our skills
    in Raspberry Pi applications and IoT project development.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
