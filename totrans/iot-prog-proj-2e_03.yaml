- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building an IoT Weather Indicator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about servo motors and LEDs and then use this
    knowledge, along with our understanding of the Raspberry Pi and web services,
    to create a practical project: an IoT weather indicator.'
  prefs: []
  type: TYPE_NORMAL
- en: The weather indicator will draw weather information from a web service and then
    use a pointer attached to the servo motor to indicate suitable attire based on
    the current outdoor conditions. It will include an LED that turns on when it’s
    raining and blinks on and off if there is a thunderstorm. The configuration that
    you’ll use to create this application may be used for other applications, such
    as a water quality monitor or a traffic density monitor.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by looking at servo motors, which will help us understand what they
    are and how we may use them in our IoT applications. Then, we’ll focus on LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: Following that, we’ll begin constructing a physical stand to house the components
    for our application. This will be the second specially designed stand for the
    Raspberry Pi that we will build for this book and the first one that features
    a motor.
  prefs: []
  type: TYPE_NORMAL
- en: While the usage of the SenseHAT case, as discussed in *Chapters 1* and *2*,
    was optional, it is recommended to build this stand for the weather indicator.
    This construction will represent our first foray into creating a tangible, physical
    entity, or more specifically, an Internet of Things (IoT) *thing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once our stand has been assembled, we’ll dive into coding. Our goal will be
    to extract information from the **OpenWeatherMap** web service and utilize it
    to dictate the position of the needle affixed to our servo motor based on the
    temperature and wind speed. We will also adjust the LED’s behavior according to
    certain weather conditions. By implementing these processes, we will illustrate
    how real-world data can be transformed into physical movements, bridging the gap
    between the digital and mechanical worlds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Connecting our weather indicator to a web service](img/B21282_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Connecting our weather indicator to a web service
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Looking into servo motors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling servo motors and LEDs using Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the weather indicator stand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing code for our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You’ll need the following to complete this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi 5 4/8 GB model is preferred, but the Raspberry Pi 4B with either
    4 GB or 8 GB may be used (the figures in this book show the Raspberry Pi 4B model).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latest Raspberry Pi operating system with Thonny pre-installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A keyboard, mouse, and monitor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1x SG90 servo motor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1x LED (single color).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1x 220 Ohm resistor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ½ inch PVC pipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper wires with connectors for the Raspberry Pi’s **general-purpose input/output**
    (**GPIO**) port.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to a 3D printer or 3D printing service for the custom stand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A general knowledge of programming. We will be using the Python programming
    language in this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GitHub repository for this chapter is located at [https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter3](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter3).
  prefs: []
  type: TYPE_NORMAL
- en: Looking into servo motors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Servo motors** are widely used in robotics, automation, and other applications
    where precise control of angular movement is required. Hooking up servo motors
    to the Raspberry Pi is a straightforward process that offers exciting possibilities
    for various projects. The Raspberry Pi provides a suitable platform to interface
    and control servo motors. In this section, we will investigate servo motors in
    more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the GPIO port
  prefs: []
  type: TYPE_NORMAL
- en: The GPIO port on the Raspberry Pi allows for direct hardware interaction, making
    it a key tool for hands-on projects. It allows us to connect devices, sensors,
    and circuits, allowing for real-world applications such as robotics or alarm systems
    to be created. By utilizing these pins, we can design and build projects that
    interact with the physical world. We will cover the GPIO port in more depth in
    [*Chapter 5*](B21282_05.xhtml#_idTextAnchor080). For now, it is enough to know
    that we can simply connect devices such as servo motors and LEDs to the GPIO port
    using female jumper connectors.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by hooking up an SG90 servo motor to our Raspberry Pi 5 using
    the GPIO port.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the SG90 servo motor to our Raspberry Pi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SG90 servo motor is a popular and widely used micro-servo motor due to its
    compact size, versatility, precise control, and ease of use. When connecting the
    SG90 servo motor to our Raspberry Pi, it is necessary to modify the wire alignment
    within the female 3-prong connector. This connector is commonly known as the **JR-style
    servo connector** or simply **servo connector** and is initially wired with the
    power (+5V) and GND wires in reverse order from what is required for our Raspberry
    Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'Referring to *Figure 3**.2*, we can adjust the wiring by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, identify the three wires in the connector – red (power), brown (ground),
    and orange (signal).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, gently pull the wires from the connector while holding the plastic housing
    up using a sharp object such as an Xacto knife.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, rearrange them so that the red (power) wire is at one end, the brown
    (GND) wire is in the middle, and the orange (signal) wire is at the opposite end
    of the red wire:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Changing the wiring order for the SG90 servo](img/B21282_03_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Changing the wiring order for the SG90 servo
  prefs: []
  type: TYPE_NORMAL
- en: 'With the wiring in the correct order, we can connect the servo motor directly
    to our Raspberry Pi. Using the diagram in *Figure 3**.3* as a reference, connect
    the female 3-prong connector to the +5V, GND, and GPIO 14 pins of the Raspberry
    Pi:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Connecting our servo to the Raspberry Pi](img/B21282_03_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Connecting our servo to the Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: An alternate method for connecting our servo
  prefs: []
  type: TYPE_NORMAL
- en: For those of us who would rather not modify the existing connector of the servo,
    we may use three male-to-female jumper wires instead, with the male end inserted
    into the connector and the female end inserted into the GPIO port on the Raspberry
    Pi.
  prefs: []
  type: TYPE_NORMAL
- en: With our servo motor connected to our Raspberry Pi, let’s investigate what servo
    motors are and how we may use them.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding servo motors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Servo motors consist of a **direct current** (**DC**) motor, a control circuit,
    and a feedback mechanism for maintaining the angular position of the output shaft.
    Robotics, toys, and radio-controlled cars are some of the applications where servos
    are predominantly used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Servo motors stand out for their exceptional precision in controlling the position
    of the motor thanks to their closed-loop feedback mechanism. This mechanism constantly
    monitors the motor’s actual position and adjusts it so that it matches the desired
    position, ensuring accurate and reliable performance. *Figure 3**.4* shows the
    popular SG90 servo motor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – SG90 servo motor](img/B21282_03_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – SG90 servo motor
  prefs: []
  type: TYPE_NORMAL
- en: The range of movement for servo motors can vary, depending on the model. Some
    servos are designed for 180-degree movement, making them ideal for limited-range
    applications such as controlling robot joints or stabilizing camera gimbals. Other
    servos are capable of full 360-degree rotation, which makes them suitable for
    continuous motion applications, such as steering mechanisms or pan-tilt camera
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The angle control of servos is achieved through **pulse-width modulation**
    (**PWM**). PWM involves sending varying pulse widths to the servo, akin to adjusting
    a volume knob to control sound level; in servos, these pulses dictate the arm’s
    position. Different brands of servo have different maximum and minimum values
    to determine the angle of the servo needle. *Figure 3**.5* demonstrates the relationship
    between PWM and the position of a 180-degree servo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – PWM and servo position](img/B21282_03_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – PWM and servo position
  prefs: []
  type: TYPE_NORMAL
- en: Armed with our knowledge of the essentials of servo motors and their connection
    to the Raspberry Pi 5, we’ll turn our attention to LEDs. Our exploration will
    cover how they function and the steps to incorporate them into our project, providing
    an additional layer of visual feedback.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring LEDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LEDs were first developed in the early 1960s. The first LEDs were red and were
    first used as indicators in seven-segment displays. Today, LEDs are virtually
    everywhere – from indicator lights on our electronic devices and home appliances
    to the screens of our televisions and smartphones.
  prefs: []
  type: TYPE_NORMAL
- en: An LED is a simple semiconductor device. It has two leads – an anode (positive)
    and a cathode (negative). When a forward current passes through the diode from
    the anode to the cathode, it emits light. The color of the light depends on the
    materials that are used to make the diode and can range from infrared to ultraviolet,
    including all the colors of the visible spectrum.
  prefs: []
  type: TYPE_NORMAL
- en: 'LEDs come in various types, including single-color LEDs, RGB LEDs, which are
    capable of producing a multitude of colors, infrared LEDs, which are used in remote
    controls and night-vision systems, and bi-color LEDs, which can emit two different
    colors. *Figure 3**.6* shows an array of LEDs ranging from a single-colored red
    to a seven-colored flash LED (second from left) to an RGB (second from right)
    LED capable of displaying any color. For our weather indicator, we will be using
    a single-colored LED. The color doesn’t matter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – LEDs in various formats](img/B21282_03_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – LEDs in various formats
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of LEDs, it’s time to connect an LED
    to our Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting an LED to our Raspberry Pi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Connecting an LED to a Raspberry Pi requires us to carefully consider voltage
    requirements – exceeding the voltage can cause the LED to burn out. To do this,
    we must solder a resistor to one end of the LED before connecting it to the GPIO
    port with jumper wires. Since the Raspberry Pi’s GPIO pins output at a higher
    voltage than most LEDs can handle directly, the inclusion of the resistor is essential
    to regulate the voltage, ensuring that the LED operates correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.7* shows the materials that we need to connect our LED to the GPIO
    port on the Raspberry Pi – an LED, two jumper wires with female ends (brown and
    red), shrink tubing, and a 220 Ohm resistor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – The parts that are required to connect our LED to the Raspberry
    Pi](img/B21282_03_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – The parts that are required to connect our LED to the Raspberry
    Pi
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect our LED to our Raspberry Pi, we must do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by soldering the resistor to the anode (positive) or longer leg of the
    LED (see *A* in *Figure 3**.8*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Soldering a resistor and jumper wires to our LED](img/B21282_03_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Soldering a resistor and jumper wires to our LED
  prefs: []
  type: TYPE_NORMAL
- en: Then, splice and solder the brown jumper wire onto the cathode (negative) leg
    of the LED (see *B* in *Figure 3**.8*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, splice and solder the red jumper wire onto the other end of the resistor.
    We may consider the extra length created by the resistor and shorten the red wire
    accordingly (see *B* in *Figure 3**.8*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To strengthen the new connections and provide additional electrical insulation,
    apply heat shrink tubing over the soldered wires and resistor (see *C* in *Figure
    3**.8*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using the jumper wires, attach the brown wire to GPIO GND on the Raspberry
    Pi and the red wire to GPIO 25 (see *Figure 3**.9*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Wiring up our servo and LED to the Raspberry Pi](img/B21282_03_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Wiring up our servo and LED to the Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve wired up our servo and LED components, let’s write some code
    so that we can control our components through Python.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling servo motors and LEDs using Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having successfully connected the servo motor and LED to our Raspberry Pi, we’ll
    start writing the Python control code. To facilitate this, we will be using the
    **GPIO Zero Python library**, a powerful tool for Raspberry Pi GPIO programming.
    Our first step in this process will be to set up a Python virtual environment
    so that we can develop our code.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our development environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like we did in [*Chapter 2*](B21282_02.xhtml#_idTextAnchor031), we will
    use a Python virtual environment for our development. As there are libraries that
    only work with the root installation of Python, we will use system packages in
    our Python virtual environment. To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: On our Raspberry Pi 5, open a Terminal application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To store our project files, create a new directory by running the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, navigate to the new directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new Python virtual environment for our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: source ch3-env/bin/activate
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the extra packages that are required for our code with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: exit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With our project folder created, our Python virtual environment set up and activated,
    and the `requests` package installed, we may now start writing code. We will start
    by controlling the servo motor through Python code using the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Using GPIO Zero to control a servo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GPIO Zero is a Python library for controlling the GPIO pins on the Raspberry
    Pi. It was created in 2016 by Ben Nuttall and Dave Jones of the Raspberry Pi Foundation.
    GPIO Zero provides a user-friendly and high-level interface, making it easier
    to work with GPIO, including controlling LEDs, buttons, servos, and more. It comes
    pre-installed with the latest Raspberry Pi operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Servo` class is a part of GPIO Zero and provides a way to control a servo
    motor. To test our servo motor’s connection to our Raspberry Pi, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a Terminal window and navigate to our project folder by running the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'ch3-env virtual environment and launch Python with the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: from gpiozero import Servo
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Servo class provides several useful methods to control a servo motor. To set
    the servo to the minimum position, run the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After executing this command, we should notice that our servo motor has pivoted
    completely to one side. To move our servo motor to the middle position, we can
    use the following Python command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After executing this command, we should observe that our servo motor has moved
    to the mid position. For the final test, we’ll move our servo motor to the maximum
    position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should observe that our servo motor moves to the maximum position (we shouldn’t
    be alarmed if the motor doesn’t move as far to the maximum position as it does
    to the minimum position as we will calibrate the motor later in this chapter).
    To close our servo connection, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Why is the servo motor jittering?
  prefs: []
  type: TYPE_NORMAL
- en: We may observe jittering from our SG90 servo motor when it’s controlled through
    GPIO Zero. A multitude of factors may contribute to this issue, ranging from the
    power provided to the servo via the GPIO port, to potential mechanical problems
    with the servo, or even software-related issues within the library. Although an
    investigation into these causes falls outside the scope of this project, we must
    acknowledge the potential for motor jittering. A straightforward solution involves
    closing the connection to the servo using the `servo.close()` command after setting
    its position.
  prefs: []
  type: TYPE_NORMAL
- en: With our servo motor tested, we can focus on the LED. In the next section, we
    will write some code to control the status of our LED using the GPIO library.
  prefs: []
  type: TYPE_NORMAL
- en: Using GPIO Zero to control an LED
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `LED` class is a part of the GPIO Zero library and provides a simple interface
    to control an LED. We can use this class to control our LED. To test the connection
    of our LED, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open a new Terminal window and navigate to our project folder with the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: source ch3-env/bin/activate
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Launch Python by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: from gpiozero import LED
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'LED class provides several useful methods to control an LED. To turn on the
    LED, type the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After executing this command, we should notice that our LED has turned on.
    For the next test, we’ll turn our LED off by running the following Python command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After executing this command, we should observe that our LED has turned off.
    For the final test, we’ll blink our LED:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should observe that our LED starts blinking. To stop this and turn the LED
    off, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Should we encounter issues during testing, there could be several potential
    causes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Incorrect wiring**: Incorrect wiring is among the most common problems. It’s
    crucial to verify our connections and ensure we’ve wired the correct GPIO pin
    according to our Python script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Issues with the power supply**: Power supply inadequacies might also lead
    to issues. While the Raspberry Pi’s GPIO pins may not supply adequate power for
    certain servos, especially under load, causing the servo to act unpredictably,
    our SG90 servo and LED shouldn’t face this issue, given they have a lower power
    demand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software**: Software-related issues could also pose problems. Keeping the
    Raspberry Pi OS and GPIO Zero library up to date is an essential preventative
    measure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Components**: Issues could lie within the components themselves. By testing
    them with a known, functioning device, we can either confirm or rule out this
    possibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we’ve tested our servo and LED components alongside the corresponding
    code, we can construct the stand that will house our project.
  prefs: []
  type: TYPE_NORMAL
- en: Building the weather indicator stand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, our focus will shift to assembling the stand for our weather
    indicator. While it’s not imperative for running the code, building the stand
    is highly recommended as it adds a tangible, real-world aspect to our project,
    bringing the *thing* in IoT to life.
  prefs: []
  type: TYPE_NORMAL
- en: While this book does not provide a comprehensive guide on 3D printing, we will
    briefly outline the key steps involved in fabricating the stand. We’ll be using
    a standard **fused deposition modeling** (**FDM**) printer, ideally one with a
    print size such as the “Ender-3” (220mm x 220mm x 250mm). Our material of choice
    for this exercise is **polylactic acid** (**PLA**) since it’s known for its ease
    of use and suitability for beginners. Alternatively, **polyethylene terephthalate
    glycol-modified** (**PETG**) is also a great option, offering enhanced strength
    and flexibility. We’ll go through the basics of printing and assembling the stand
    components here.
  prefs: []
  type: TYPE_NORMAL
- en: Should I print in PLA or PETG?
  prefs: []
  type: TYPE_NORMAL
- en: When deciding whether to print in PLA or PETG, there are several factors for
    us to consider. PLA is known for its ease of use, making it a popular choice for
    beginners. It prints at lower temperatures, doesn’t warp as easily as other materials,
    and generally provides more precise details. PETG is known for its strength and
    flexibility, which surpasses that of PLA. PETG prints at a higher temperature
    than PLA and has excellent layer adhesion, resulting in more robust prints. However,
    PETG can be more challenging to print with due to its tendency to string or ooze.
    For the weather indicator stand we built for this chapter, PLA was used. This
    was because printing was done directly on a glass plate and PETG tends to stick
    too well to glass, potentially resulting in damage being done to the build plate
    upon removing the print.
  prefs: []
  type: TYPE_NORMAL
- en: For those of us who do not have access to a 3D printer or prefer not to print
    the parts ourselves, using a 3D printing service such as Shapeways ([https://www.shapeways.com](https://www.shapeways.com))
    is a convenient alternative.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered the options for obtaining our 3D-printed parts, either
    by printing them ourselves or using a service, let’s move on to the next crucial
    phase of our project – assembling the weather indicator stand.
  prefs: []
  type: TYPE_NORMAL
- en: Assembling the weather indicator stand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned previously, the weather indicator stand has been engineered to
    be composed of components produced via an FDM 3D printer. Unlike the SenseHAT
    case and stand from *Chapters 1* and *2*, the design approach for this weather
    indicator stand is built with a *plate-like* configuration. This method effectively
    eliminates thin horizontal walls, a structural vulnerability that’s frequently
    found in parts created with FDM technology.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the files for 3D printing
  prefs: []
  type: TYPE_NORMAL
- en: The 3D model files for the parts, which have been specifically designed for
    3D printing, can be downloaded from the `Build Files` directory in this chapter’s
    GitHub repository. Please note that these files are provided in the .stl format
    only, not in other 3D model file formats.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start constructing our stand, let’s look at the parts.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the parts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Figure 3**.10* shows the parts that make up the weather indicator stand. All
    the parts, except for the base, were printed on an FDM 3D printer. Two additional
    parts – a half-inch PVC pipe and the front sticker – aren’t shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Parts of the weather indicator stand](img/B21282_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Parts of the weather indicator stand
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at each part:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base**: The base serves as the foundation for our stand. It’s the component
    where the **pipe base** is fastened. While the base is an integral part of the
    design, it can be considered optional, depending on the specific installation.
    For instance, the stand could be attached directly to a table, wall, or even a
    ceiling, offering flexible positioning based on individual preferences and requirements.
    The base displayed in *Figure 3**.10* was created out of 20mm pine wood using
    a CNC router (a computer-controlled cutting machine that’s used for cutting various
    hard materials, such as wood), although a 3D printer may be used to make this
    part as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Back plate and front plate**: These halves, when glued together, form the
    stand’s plate. The division into halves aligns with the need for a flat surface
    in 3D printing, given the plate’s lack of an inherent flat side. The plate is
    the main component of our stand as it holds the servo motor, arrow, and Raspberry
    Pi, which is attached to the back. The plate has been designed to hold either
    a Raspberry Pi, a Raspberry Pi Zero, or a Raspberry Pi Pico W.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plate hook**: Designed to be compatible with GoPro series stands, the hook
    provides the main connection of the plate on the stand. Of note here is the deliberate
    printing orientation and built-in support of the plate hook to eliminate line
    adhesion issues that would cause the plate hook to break apart if printed in the
    traditional flat side down (see *Figure 3**.11*):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Plate hook print orientation](img/B21282_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – Plate hook print orientation
  prefs: []
  type: TYPE_NORMAL
- en: '**Pipe base and plate bracket**: These two components hold the ½ inch PVC pipe
    (not shown). The pipe base attaches the PVC pipe to the base and the plate bracket
    attaches the PVC pipe to the plate hook.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**8mm LED holder**: We utilize the LED holder to fasten the LED onto the front
    of the main plate face.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Arrow**: The arrow is connected to the servo motor and acts as the analog
    needle for our weather indicator application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alignment tool**: This tool acts as a guide that aligns the back plate and
    front plate correctly during gluing, ensuring they are properly aligned to avoid
    any issues when installing the servo motor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PVC pipe (not shown)**: The stand features a half-inch PVC pipe serving as
    its stem or central support. This design offers the flexibility to adjust the
    stand’s height according to our needs. In situations where the base is unnecessary,
    such as when securing it to a table, wall, or ceiling, we can easily set the stand’s
    height to the desired level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Silhouette` file and a `.svg` file with the cut lines in the `Build Files`
    folder of our GitHub repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**M5 20mm bolt and M5 nut (not shown)**: To fasten the plate to the pedestal
    portion of the stand, we use a 20mm M5 bolt and corresponding M5 nut.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the parts identified, let’s start by creating the main plate for our stand.
  prefs: []
  type: TYPE_NORMAL
- en: Assembling the plate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The plate or face of the weather indicator stand is created by gluing the front
    plate and back plate together. To assemble the plate, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, apply epoxy glue to the flat side of one of the plates (see *A* in *Figure
    3**.12*). When applying glue, it’s crucial to avoid spreading glue near the servo
    or LED openings. It’s recommended to apply glue right to the boundaries of the
    plate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Assembling the plate](img/B21282_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Assembling the plate
  prefs: []
  type: TYPE_NORMAL
- en: After applying glue, put the flat sides of the plates together. Using the alignment
    tool, ensure that the plates are aligned with each other (see *B* in *Figure 3**.12*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the plates have been aligned, remove the alignment tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should it be needed, use clamps on the plates to prevent any space from forming
    between them. Let the glue dry before proceeding (see *C* in *Figure 3**.12*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the plates have dried, apply epoxy glue to the flat part of the hook and
    place it in the groove on the back of the plate (see *D* in *Figure 3**.12*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the glue has dried, paint the plate if you wish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To finish off the assembly, print and cut out the face sticker and apply it
    to the front of the plate inside the ridges (see *A* and *B* in *Figure* *3**.13*,
    respectively):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Plate face sticker](img/B21282_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – Plate face sticker
  prefs: []
  type: TYPE_NORMAL
- en: With the main plate constructed, it is now time to build the pedestal, which
    will hold the main plate.
  prefs: []
  type: TYPE_NORMAL
- en: Assembling the pedestal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The pedestal portion of our stand includes the base, the pipe base, the PVC
    pipe, and the plate bracket. To assemble the pedestal, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by inserting the PVC pipe (cut to a desired length) into the pipe base
    (see *A* in *Figure 3**.14*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Assembling the pedestal](img/B21282_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – Assembling the pedestal
  prefs: []
  type: TYPE_NORMAL
- en: Then, secure the pipe base to the base, table, wall, or ceiling as desired (see
    *B* in *Figure 3**.14*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To finish assembling the pedestal, insert the plate bracket into the top of
    the PVC pipe (see *C* in *Figure 3**.14*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pay attention when assembling the pedestal as variations in the manufacturer’s
    PVC pipe could result in an improper fit or difficulty when inserting it into
    the pedestal parts. If the pipe fits too loosely, it is recommended to apply epoxy
    glue to securely attach the pipe. Conversely, if the pipe is too thick to fit
    properly, we have two options: either sand down the insides of the pipe base or
    plate bracket or sand the outside of the pipe to achieve a proper and snug fit.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to be aware that in our example, the components of the pedestal
    were coated with flat black spray paint, so any additional thickness resulting
    from the paint should be considered.
  prefs: []
  type: TYPE_NORMAL
- en: With the pedestal components constructed, we’re ready to integrate our electronic
    components into our weather indicator stand.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Raspberry Pi, servo, and LED
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With our plate and pedestal constructed, the last thing we must do before putting
    the stand together is install our Raspberry Pi, servo motor, and LED onto the
    plate and wire all these components together.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing 10mm M2.5 bolts, fasten our Raspberry Pi to the base of the plate,
    ensuring it aligns correctly with the appropriate stand-offs (see *A* in *Figure
    3**.15*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the aid of a hot glue gun (preferred) or epoxy glue, secure our SG90 servo
    to the rear side of the plate. To do this, align the front structure of the SG90
    with the hole present in the plate (see *B* in *Figure 3**.15*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Installing the Raspberry Pi, servo, and LED](img/B21282_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – Installing the Raspberry Pi, servo, and LED
  prefs: []
  type: TYPE_NORMAL
- en: Referring to the wiring diagrams in *Figure 3**.3* and *Figure 3**.9*, wire
    up our servo motor and LED to the GPIO port of the Raspberry Pi (see *C* in *Figure
    3**.15*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With our Raspberry Pi wired up, it’s time to put the LED in place. Start by
    threading the LED through the LED hole in the plate (see *A* in *Figure 3**.16*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.16 – Putting our LED in place](img/B21282_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – Putting our LED in place
  prefs: []
  type: TYPE_NORMAL
- en: Then, thread the LED through the LED holder and push the holder into the LED
    hole in the front of the plate (see *B* in *Figure 3**.16*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our plate fully wired and all the components securely fastened, we can
    attach the plate to the pedestal.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the plate to the pedestal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By attaching the plate to the pedestal, we will have finished constructing our
    weather indicator stand.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete our stand, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by aligning the hook on the back of the plate with the plate bracket
    on the pedestal (*A* in *Figure 3**.17*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.17 – Attaching the plate to the pedestal](img/B21282_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 – Attaching the plate to the pedestal
  prefs: []
  type: TYPE_NORMAL
- en: Then, insert a 20mm M5 bolt and fasten it with an M5 nut (see the red rectangle
    in *A* in *Figure 3**.17*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, make any final adjustments to the angle of the plate before tightening
    the bolt fully (see *B* in *Figure 3**.17*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With that, we’ve finished assembling our weather indicator stand. This setup
    could be repurposed for many other IoT applications, including monitoring traffic
    conditions or tracking fluid levels in industrial environments.
  prefs: []
  type: TYPE_NORMAL
- en: Our next step is to write the code that will retrieve weather data from a web
    service and use it to control the servo motor and LED. Now is also the best time
    to introduce the arrow into our setup as it needs to be calibrated before it can
    be used in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Developing code for our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will connect our Raspberry Pi to the `OpenWeatherMap.org`
    web service and use the data to control the position of the needle on our weather
    indicator. For this, we need to use the API key we received from `OpenWeatherMap.org`
    when we set up an account in [*Chapter 2*](B21282_02.xhtml#_idTextAnchor031).
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this section, our Raspberry Pi, once mounted, will remain connected
    to a monitor, keyboard, and mouse. When the moment arrives to set up our weather
    indicator independently, all we’ll need is a power source and a means to remotely
    access the Raspberry Pi via SSH. Discussing how to configure a Raspberry Pi so
    that it can operate in *headless* mode falls outside the scope of this chapter.
    However, detailed instructions for this setup can easily be found through various
    online resources. Helpful starting points include the official Raspberry Pi documentation,
    technology-focused forums such as Stack Overflow, and dedicated Raspberry Pi community
    websites and blogs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will follow the software architecture laid out in *Figure 3**.18* for our
    code. At the heart of our architecture is the `WeatherData` class. We will use
    this class to connect to the OpenWeatherMap web service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 – Software architecture for our weather indicator](img/B21282_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.18 – Software architecture for our weather indicator
  prefs: []
  type: TYPE_NORMAL
- en: 'The `WeatherData` class fetches and processes weather data from the OpenWeatherMap
    API, while the `WeatherDashboard` class controls the display mechanisms: a needle
    indicator controlled by a servo motor and an LED that changes state based on the
    weather conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: These two classes work together, with `WeatherData` fetching and processing
    data, which is then used by `WeatherDashboard` to adjust the display. To keep
    the data current, the `update_dashboard()` function is set to run in an infinite
    loop, refreshing weather data and updating the display every 30 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: To address the unique hardware constraint of the servo motor – that is, its
    tendency to jitter if the connection is not closed after a move – we’ll create
    a fresh instance of `WeatherDashboard` (and consequently, a new `Servo` instance)
    with every cycle of the loop. While this approach may not be the most common in
    software design, it’s a practical solution that successfully solves the servo
    jitter issue by *reopening* the connection with each new instance.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin by calibrating the arrow’s (or needle’s) position for optimal application
    performance before we create our `WeatherData` and `WeatherDashboard` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Calibrating the needle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can use our weather indicator application, we must calibrate the
    needle (or the position of the arrow). To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Close any open Terminals, open a new Terminal window, and navigate to our project
    folder by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: source ch3-env/bin/activate
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Launch Python with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: from gpiozero import Servo
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: servo = Servo(14)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, set the servo to the mid position with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using the picture of the face of our weather indicator, install the arrow into
    the servo in the mid position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the needle (arrow) in place, let’s do some testing. We will start by moving
    the needle to the minimum position with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are now ready to write code to control the needle and LED on our weather
    indicator. We will start with the `WeatherData` class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the WeatherData class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `WeatherData` class is designed to pull weather information for a given
    city using the OpenWeatherMap API, after which it will process this data to calculate
    servo and LED values based on the temperature, wind speed, and weather conditions.
    When initialized with a city name, the class fetches the weather data for that
    city and stores the temperature, weather conditions, and wind speed. It also provides
    methods, `getServoValue()` and `getLEDValue()`, to determine the output for the
    servo motor and LED, respectively, based on the retrieved weather data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch Thonny by clicking on the **Menu** icon in the Raspberry Pi taskbar,
    navigating to the **Programming** category, and selecting **Thonny** (*Figure
    3**.19*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.19 – Opening Thonny from the main menu](img/B21282_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.19 – Opening Thonny from the main menu
  prefs: []
  type: TYPE_NORMAL
- en: By default, Thonny uses the Raspberry Pi’s built-in version of Python. For our
    project, we will use the Python virtual environment we just created. To start,
    we need to view the project files by clicking on **View** and selecting **Files**
    if it isn’t already selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `ch3-env` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, right-click on the folder and select **Activate** **virtual environment**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once inside Thonny, create a new tab by selecting **File** and then **New**
    or by hitting *Ctrl* + *N* on your keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s start our code by entering our imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `import requests` imports the `requests` library from Python, which is
    used to send HTTP requests, such as GET and POST requests, to interact with APIs
    or web services (refer to [*Chapter 2*](B21282_02.xhtml#_idTextAnchor031), for
    clarification on HTTP requests).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, define our class name, `WeatherData`, and our class variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our constructor takes one parameter, `city`. Make the call to the OpenWeatherMap
    web service in the constructor (when an instance of the `WeatherData` class is
    created):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s take a closer look at our code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`self.city = city`: saves the city name to the object’s property'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`api_key = ''xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx''`: Sets the OpenWeatherMap API
    key'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`base_url = "http://api.openweathermap.org/data/2.5/weather"`: Sets the base
    URL for the OpenWeatherMap API'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`complete_url = f"{base_url}?q={self.city}&appid={api_key}&units=metric"`:
    Formats the full API URL with the city and API key'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`response = requests.get(complete_url)`: Sends a GET request to the API and
    saves the response'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data = response.json()`: Converts the API response from JSON format into a
    Python dictionary'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if data["cod"] != "404"`: Checks whether the API response is not a 404 error,
    which would indicate that the city was not found'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.temperature = main["temp"]`: Saves the current temperature in the city
    to the object’s property'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.weather_conditions = weather[0]["main"]`: Saves the current weather conditions
    in the city to the object’s property'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.wind_speed = wind["speed"]`: Saves the current wind speed in the city
    to the object’s property'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By making the call to the OpenWeatherMap web service and setting the instance
    variables, all that’s left for our code to do is convert weather data into values
    for our servo motor and LED. We’ll start with the servo motor value and the `getServoValue()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s a breakdown of our code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First, the method checks whether the temperature (`self.temperature`) is less
    than `0`. If the temperature is below zero, `temp_factor` is set to `0`. This
    means that if the temperature is negative, there will be no contribution to the
    final servo value.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we check whether the temperature is greater than `30`. If this is true,
    then `temp_factor` is set to `1`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If the temperature falls between 0 and 30 degrees Celsius, then we normalize
    the temperature data. Normalization is the process of bringing or converting values
    into a common range. In this case, the temperature data is being scaled to a range
    of 0 to 1, assuming the temperature is within the range of 0 to 30 degrees Celsius.
    By dividing the temperature by 30, any temperature value within this range is
    proportionally scaled down to a fraction between 0 and 1\. For example, if the
    temperature is 15 degrees Celsius, `temp_factor` will be 0.5\. This normalization
    allows the method to process temperatures consistently, irrespective of their
    actual value.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`wind_factor = self.wind_speed / 20` calculates the wind factor by normalizing
    the wind speed. Like the temperature normalization process, this line of code
    is used to convert the wind speed into a value within a range of 0 to 1\. The
    wind speed is assumed to be within a range of 0 to 20 kilometers per hour. For
    example, if the wind speed is 10 kilometers per hour, `wind_factor` will be 0.5\.
    Normalization is particularly useful when combining or comparing different types
    of data, such as wind speed and temperature in this case.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to calculate `servo_value` using both the temperature and wind
    factors. Specifically, it creates a dampening effect on temperature due to wind
    speed, representing a wind chill factor. The formula reduces the temperature factor
    (`temp_factor`) by one-twentieth of the wind factor (`wind_factor`), thereby signifying
    that for every 5% increase in wind speed, the temperature’s impact decreases by
    1%. This is based on our discretionary assumption that wind speed has a cooling
    effect. After this adjustment for wind chill, the resulting value is transformed
    to fit into the range of -1 to 1, which is suitable for the servo’s operation.
    It multiplies the value by 2, shifting the range from 0 to 1 to 0 to 2, and subtracts
    one to adjust the range to -1 to 1\. Finally, the result is negated to account
    for the servo’s directionality (as we discovered when calibrating the needle).
    The calculated `servo_value` represents the position of the servo as per the adjusted
    temperature and wind speed readings.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, our method returns `servo_value`, which is a value between -1 and 1
    based on temperature, and then adjusted for wind speed. This value is ready to
    be used as input to the servo’s value property in the GPIO Zero library.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The second method within the `WeatherData` class is utilized to determine the
    operational state of the LED, which varies based on the current weather conditions.
    More specifically, the LED is programmed to flash during a thunderstorm, remain
    solidly illuminated in the event of rain, and be switched off when the weather
    conditions are neither a thunderstorm nor rain. We call this method `getLEDValue()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, the `getLEDValue()` method designates specific values to different weather
    conditions: it returns `2` for thunderstorms, `1` for rain, and `0` for other
    conditions. These values are then utilized to control the LED’s behavior – blinking
    for thunderstorms (`2`), a steady one for rain (`1`), and off for clear weather
    (`0`).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To test out our program directly, include the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s take a closer look:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`if __name__=="__main__"`: This is the entry point for the program. It is only
    executed when the script is run directly, not when it is imported as a module
    in another script:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`weather = WeatherData(''Toronto'')`: This creates an object of the `WeatherData`
    class, initializing it with the `''Toronto''` string. We may enter a city of our
    choice. To verify whether the city we are interested in has data available, we
    can enter it into the search box on the OpenWeatherMap website ([https://openweathermap.org/](https://openweathermap.org/)).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print(weather.getServoValue())`: This is a function call to the `getServoValue()`
    method of the `weather` object. This method calculates a value based on the temperature
    and wind speed data for Toronto and then prints this value to the console.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print(weather.getLEDValue())`: This calls the `getLEDValue()` method of the
    weather object, which sets a flag based on the weather conditions (thunderstorm,
    rain, or other) for Toronto. This flag determines the state of an LED (flashing,
    on, or off or 2, 1, or 0, respectively) and the method returns this state. The
    state is then printed to the console.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Save the code and name the file `WeatherData.py`. Run the code by clicking
    the green run button, hitting *F5* on your keyboard, or clicking on the **Run**
    menu option at the top and then **Run current script** (*Figure 3**.20*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![  Figure 3.20 – Running a script in Thonny](img/B21282_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.20 – Running a script in Thonny
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see a response similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.21 – Output from running WeatherData.py](img/B21282_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.21 – Output from running WeatherData.py
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `WeatherData` class written and tested, it’s time to move on to the
    code that controls the weather indicator: the `WeatherDashboard` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the WeatherDashboard class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `WeatherDashboard` class is integral to the operation of the weather indicator
    as it’s responsible for controlling the position of the needle and the state of
    the LED. This class utilizes the `WeatherData` class to gather and interpret weather
    data, which is then utilized to guide the operation of the physical display. The
    position of the servo, which dictates the position of the needle, is determined
    by the temperature and wind speed, while the LED state is indicative of specific
    weather conditions, such as rain or thunderstorms.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create this class, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside Thonny, activate the `ch3-env` virtual environment if it hasn’t been
    already.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, create a new tab by selecting **File** and then **New** or by hitting
    *Ctrl* + *N* on your keyboard (*Figure 3**.22*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.22 – Creating a new file in Thonny](img/B21282_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.22 – Creating a new file in Thonny
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start with our imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We start by importing the `Servo` and `LED` classes from the `gpiozero` library.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we import the `sleep` function from the `time` module.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we import the `WeatherData` class to fetch weather condition data and
    derive the control values for the servo motor and the LED accordingly.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the imports added, define the class and the class variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we have the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`servoCorrection = 0.5`: This line declares a class-level variable called `servoCorrection`
    and assigns it a value of `0.5`. This is used to adjust the minimum and maximum
    pulse widths for the servo motor.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxPW = (2.0 + servoCorrection) / 1000`: This line calculates and sets the
    maximum pulse width (`maxPW`) that can be provided to the servo motor. It’s computed
    by adding `2.0` to the `servoCorrection` variable and then dividing the result
    by `1000` to convert it into seconds – the servo motor expects pulse widths in
    seconds.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minPW = (1.0 - servoCorrection) / 1000`: Like the previous line, this line
    calculates and sets the minimum pulse width (`minPW`) for the servo motor. It
    subtracts `servoCorrection` from `1.0` and then divides the result by `1000` for
    the same reason as before.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create our `Servo` and `LED` instance objects while initializing the `WeatherDashboard`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s take a closer look at the code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`self.city = city`: This line sets an instance variable, `city`, equal to the
    `city` argument that’s passed when the instance of the class is created. This
    variable represents the city for which weather data will be fetched.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.servo = Servo(servo_pin, min_pulse_width=self.minPW, max_pulse_width=self.maxPW)`:
    This line creates a `Servo` object from the GPIO Zero library. The `servo_pin`
    argument specifies the GPIO pin that the servo is connected to. `min_pulse_width=self.minPW`
    and `max_pulse_width=self.maxPW` set the minimum and maximum pulse widths for
    the servo using class variables.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.led = LED(led_pin)`: This line creates an `LED` object from the GPIO
    Zero library. The `led_pin` argument indicates the GPIO pin the LED is connected
    to. This LED will be controlled based on the weather conditions that have been
    fetched for the specified city.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `update_status()` method of the `WeatherDashboard` class grabs the latest
    weather information and updates the status of the needle and LED accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s what’s going on in our code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`weather_data = WeatherData(self.city)`: This creates an instance of the `WeatherData`
    class using the city that was specified when `WeatherDashboard` was instantiated.
    This object is used to fetch weather data for the city.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.servo.value = weather_data.getServoValue()`: This calls the `getServoValue()`
    method on the `weather_data` object to get the value for the servo, based on the
    weather conditions. This value is then set as the new position for the servo motor.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`led_status = weather_data.getLEDValue()`: This calls the `getLEDValue()` method
    on the `weather_data` object to get the value for the LED status, based on the
    weather conditions.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The conditional block sets the LED’s status based on the `led_status` value.
    If `led_status` is `0`, it signifies calm weather conditions without any rainfall
    or thunderstorms, so the LED is turned off (`self.led.off()`). If `led_status`
    is `1`, this indicates rain, resulting in the LED being turned on (`self.led.on()`).
    For an `led_status` value of `2`, which is specific to thunderstorm conditions,
    the LED will blink (`self.led.blink()`), representing the intermittent nature
    of thunder and lightning. This value is returned by the `getLEDValue()` method
    in the `WeatherData` class when it detects thunderstorm conditions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final method in our `WeatherDashboard` class, `closeServo(),` simply closes
    the `Servo` instance that we created in our class. This is done to keep the servo
    motor from jittering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, save the code and call it `WeatherDashboard.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We won’t run our code just yet, as we need to add a new method to the file (but
    not the class). We will use this method to create a new `WeatherDashboard` object
    and update the position of the needle and the state of the LED.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the updateDashboard() function and main methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `update_dashboard()` function is a standalone function that is defined in
    the same Python file (`WeatherDashboard.py`) as the `WeatherDashboard` class,
    yet sits outside of it. It serves as an interface to encapsulate the process of
    updating the state of the weather dashboard. The reason for creating the `update_dashboard()`
    function is to help in overcoming issues related to servo motor jittering as it
    provides a controlled way to frequently create a fresh instance of the `WeatherDashboard`
    class, thereby *reopening* the `Servo` object connection each time an update to
    the dashboard is made.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Thonny, open the `WeatherDashboard.py` file and add the following method
    to the bottom:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s take a closer look:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, we define the `update_dashboard(city, servo_pin, led_pin)` function
    to take three arguments: the city for which the weather data is required, the
    PIN for the servo motor, and the PIN for the LED.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Within this function, an instance of the `WeatherDashboard` class, named `weather_dashboard`,
    is created using the given city, servo PIN, and LED PIN as inputs.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, the `update_status()` method of the `WeatherDashboard` instance is called.
    This method fetches the current weather data for the specified city, determines
    the servo and LED values based on this data, sets the servo’s position, and sets
    the LED’s state (off, on, or blinking) accordingly.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The program then pauses for 2 seconds using the `sleep(2)` statement. This pause
    ensures that the servo has enough time to move to its new position and that the
    LED displays its new state before any further actions are taken.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the `closeServo()` method of the `WeatherDashboard` instance is called.
    This method is responsible for closing the connection to the servo motor, which
    is done to avoid potential issues with the servo, such as jittering.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will add code that only runs when the `WeatherDashboard.py` file is
    executed in Python. We will use this code to run our weather indicator continuously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s take a closer look:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This block of code will only run when this script (`WeatherDashboard.py`) is
    executed directly based on `if __name__ == "``__main__":`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we set the `city`, `servo_pin`, and `led_pin` variables to `Toronto`,
    `14`, and `25`, respectively. Each reader may put in the city of their choice.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `while True:` loop will continuously execute the code inside it, essentially
    making the script run forever, or until it is stopped manually.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the loop, the `update_dashboard()` function is called with the `city`,
    `servo_pin`, and `led_pin` values as arguments. This function updates the weather
    dashboard, effectively getting the new weather data and controlling the servo
    and LED accordingly.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: After updating the dashboard, the script goes into sleep mode for 1,800 seconds,
    or 30 minutes (`sleep(1800)`). This means that the weather dashboard updates every
    30 minutes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: After the sleep period, the loop starts over, updating the dashboard again.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Resave the code and call it `WeatherData.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run our code by clicking the green run button, hitting *F5* on your keyboard,
    or clicking on the **Run** menu option at the top and then **Run** **current script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the script is up and running, we’ll see that the position of the needle
    and the state of the LED reflect the current temperature, wind speed, and weather
    conditions accurately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We may operate our weather indicator application independently, without the
    need for a keyboard, mouse, or monitor to be connected. *Figure 3**.23* shows
    a practical example of how our application advises us on what to wear based on
    the weather in Toronto at the time the photo was taken, also indicating that there’s
    no need for an umbrella:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.23 – It looks like T-shirt weather in Toronto today](img/B21282_03_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.23 – It looks like T-shirt weather in Toronto today
  prefs: []
  type: TYPE_NORMAL
- en: From the position of the needle on our weather indicator in *Figure 3**.23*,
    we can conclude that it is T-shirt weather in Toronto today.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we developed a weather indicator application, a tool that’s
    designed to provide advice on clothing choices based on current weather conditions.
    This innovative project combined coding expertise with physical component design,
    manifesting not just on a computer screen, but in a real-world, tangible form.
    Central to this was the creation of a custom stand for our weather indicator,
    made from 3D-printed parts. This stand, which was designed to house the LED and
    the servo motor, contributed both practical functionality and aesthetic appeal
    to our project, successfully bridging the gap between the digital and physical
    worlds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lessons learned and the skills gained on this journey have wide-ranging
    applications. To illustrate, envision a new undertaking: a project that utilizes
    environmental sensors to track indoor climate conditions such as temperature,
    humidity, and air quality. The core principles we’ve mastered – from acquiring
    and interpreting data to interacting with hardware components – can be directly
    employed in such a scenario.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, it is easy to imagine adding more functionality to our weather indicator.
    For example, imagine replacing our LED with an RGB LED capable of a myriad of
    colors. We could use these different colors and various flashing patterns to indicate
    other types of weather conditions or warnings.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we added to our expertise in Python programming by focusing
    on interfacing with web services for data acquisition and analysis. In parallel,
    we ventured into the world of hardware interfaces, creating a tangible, physical
    component: our custom weather indicator stand.'
  prefs: []
  type: TYPE_NORMAL
- en: With our newly acquired skills, we are poised to tackle a variety of complex
    problems. As demonstrated in our weather indicator project, being able to integrate
    web services, Python programming, and physical components can result in practical
    applications that significantly impact daily life. Whether advising on clothing
    choices based on weather conditions or envisaging new applications such as indoor
    climate monitoring, our abilities have proven versatile and invaluable.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll construct an IoT display with a Raspberry Pi 7-inch
    touchscreen that presents real-time weather and traffic. This will involve exploring
    various screen types and creating a multifunctional dashboard, enhancing our skills
    in Raspberry Pi applications and IoT project development.
  prefs: []
  type: TYPE_NORMAL
