- en: Lists and Pointer Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will have already seen lists in Python. They are convenient and powerful.
    Normally, any time you need to store something in a list, you use python's built-in
    list implementation. In this chapter, however, we are more interested in understanding
    how lists work. So we are going to study list internals. As you will notice, there
    are different types of lists.
  prefs: []
  type: TYPE_NORMAL
- en: Python's list implementation is designed to be powerful and to encompass several
    different use cases. We are going to be a bit more strict in our definition of
    what a list is.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a node is very important to lists. We shall discuss them in this
    chapter, but this concept will, in different forms, come back throughout the rest
    of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The focus of this chapter will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand pointers in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Treating the concept of nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing singly, doubly, and circularly linked lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we are going to deal quite a bit with pointers. So it may be
    useful to remind ourselves what these are. To begin with, imagine that you have
    a house that you want to sell. Lacking time, you contact an agent to find interested
    buyers. So you pick up your house and take it over to the agent, who will in turn
    carry the house to anybody who may want to buy it. Ludicrous, you say? Now imagine
    that you have a few Python functions that work with images. So you pass high-resolution
    image data between your functions.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you don't carry your house around. What you would do is write the
    address of the house down on a piece of scrap paper and hand it over to the agent.
    The house remains where it is, but the note containing the directions to the house
    is passed around. You might even write it down on several pieces of paper. Each
    one is small enough to fit in your wallet, but they all point to the same house.
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, things are not very different in Python land. Those large image
    files remain in one single place in memory. What you do is create variables that
    hold the locations of those images in memory. These variables are small and can
    easily be passed around between different functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is the big benefit of pointers: they allow you to point to a potentially
    large segment of memory with just a simple memory address.'
  prefs: []
  type: TYPE_NORMAL
- en: Support for pointers exists in your computer's hardware, where it is known as
    indirect addressing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, you don''t manipulate pointers directly, unlike in some other languages,
    such as C or Pascal. This has led some people to think that pointers aren''t used
    in Python. Nothing could be further from the truth. Consider this assignment in
    the Python interactive shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We would normally say that `s` is a variable of the type set. That is, `s` is
    a set. This is not strictly true, however. The variable `s` is rather a reference
    (a "safe" pointer) to a set. The set constructor creates a set somewhere in memory
    and returns the memory location where that set starts. This is what gets stored
    in `s`.
  prefs: []
  type: TYPE_NORMAL
- en: Python hides this complexity from us. We can safely assume that `s` is a set
    and that everything works fine.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An array is a sequential list of data. Being sequential means that each element
    is stored right after the previous one in memory. If your array is really big
    and you are low on memory, it could be impossible to find large enough storage
    to fit your entire array. This will lead to problems.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the flip side of the coin is that arrays are very fast. Since each
    element follows from the previous one in memory, there is no need to jump around
    between different memory locations. This can be a very important point to take
    into consideration when choosing between a list and an array in your own real-world
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the latter parts of [Chapter 2](ee04d80f-97b1-4a1b-b61f-8a830c0b78c5.xhtml),
    *Python Data Types and Structures*, we looked at the array data type and discovered
    the various operations that could be performed on it.
  prefs: []
  type: TYPE_NORMAL
- en: Pointer structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contrary to arrays, pointer structures are lists of items that can be spread
    out in memory. This is because each item contains one or more links to other items
    in the structure. What type of links these are dependent on the type of structure
    we have. If we are dealing with linked lists, then we will have links to the next
    (and possibly previous) items in the structure. In the case of a tree, we have
    parent-child links as well as sibling links. In a tile-based game where the game
    map is built up of hexes, each node will have links to up to six adjacent map
    cells.
  prefs: []
  type: TYPE_NORMAL
- en: There are several benefits with pointer structures. First of all, they don't
    require sequential storage space. Second, they can start small and grow arbitrarily
    as you add more nodes to the structure.
  prefs: []
  type: TYPE_NORMAL
- en: As noted in [Chapter 2](ee04d80f-97b1-4a1b-b61f-8a830c0b78c5.xhtml), *Python
    Data Types and Structures*, however, this comes at a cost. If you have a list
    of integers, each node is going to take up the space of an integer, as well as
    an additional integer for storing the pointer to the next node.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the heart of lists (and several other data structures) is the concept of
    a node. Before we go any further, let us consider this idea for a while.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, we shall create a few strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now you have three variables, each with a unique name, a type, and a value.
    What we do not have is a way of saying in which way the variables relate to each
    other. Nodes allow us to do this. A node is a container of data, together with
    one or more links to other nodes. A link is a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: A simple type of node is one that only has a link to the next node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, knowing what we do about pointers, we realize that this is not entirely
    true. The string is not really stored in the node, but is rather a pointer to
    the actual string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Thus the storage requirement for this simple node is two memory addresses. The
    data attribute of the nodes are pointers to the strings `eggs` and `ham`.
  prefs: []
  type: TYPE_NORMAL
- en: Finding endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have created three nodes: one containing **eggs**, one **ham**, and another
    **spam**. The **eggs** node points to the **ham** node, which in turn points to
    the **spam** node. But what does the **spam** node point to? Since this is the
    last element in the list, we need to make sure its next member has a value that
    makes this clear.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we make the last element point to nothing then we make this fact clear.
    In python, we will use the special value `None` to denote nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last node has its next point pointing to None. As such it is the last node
    in the chain of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a simple node implementation of what we have discussed so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Do not confuse the concept of a node with Node.js, a server-side technology
    implemented in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The `next` pointer is initialized to `None`, meaning that unless you change
    the value of `next`, the node is going to be an end-point. This is a good idea,
    so that we do not forget to terminate the list properly.
  prefs: []
  type: TYPE_NORMAL
- en: You can add other things to the `node` class as you see fit. Just make sure
    that you keep in mind the distinction between node and data. If your node is going
    to contain customer data, then create a `Customer` class and put all the data
    there.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing you may want to do is implement the `__str__` method so that it calls
    the `__str__` method of the contained object is called when the node object is
    passed to print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Other node types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have assumed nodes that have a pointer to the next node. This is probably
    the simplest type of node. However, depending on our requirements, we can create
    a number of other types of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes we want to go from A to B, but at the same time from B to A. In that
    case, we add a previous pointer in addition to the next pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the figure, we let both the last and the first nodes point
    to `None`, to indicate that we have reached they form the boundary of our list
    end-point. The first node’s previous pointer points to None since it has no predecessor,
    just as the last item’s next pointer points to `None` because it no successor
    node.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might also be creating tiles for a tile-based game. In such a case, instead
    of previous and next, you might use north, south, east, and west. There are more
    types of pointers, but the principle is the same. Tiles at the end of the map
    will point to `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can take this as far as you need to. If you need to be able to move north-west,
    north-east, south-east, and south-west as well, all you have to do is add these
    pointers to your `node` class.
  prefs: []
  type: TYPE_NORMAL
- en: Singly linked lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A singly linked list is a list with only one pointer between two successive
    nodes. It can only be traversed in a single direction, that is, you can go from
    the first node in the list to the last node, but you cannot move from the last
    node to the first node.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can actually use the `node` class that we created earlier to implement a
    very simple singly linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we link the nodes together so that they form a *chain*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To traverse the list, you could do something like the following. We start by
    setting the variable `current` to the first item in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the loop we print out the current element after which we set current to point
    to the next element in the list. We keep doing this until we have reached the
    end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are, however, several problems with this simplistic list implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: It requires too much manual work by the programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is too error-prone (this is a consequence of the first point)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Too much of the inner workings of the list is exposed to the programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to address all these issues in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Singly linked list class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A list is clearly a separate concept from a node. So we start by creating a
    very simple class to hold our list. We will start with a constructor that holds
    a reference to the very first node in the list. Since this list is initially empty,
    we will start by setting this reference to `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Append operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first operation that we need to perform is to append items to the list.
    This operation is sometimes called an insert operation. Here we get a chance to
    hide away the `Node` class. The user of our `list` class should really never have
    to interact with Node objects. These are purely for internal use.
  prefs: []
  type: TYPE_NORMAL
- en: 'A first shot at an `append()` method may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We encapsulate data in a node, so that it now has the next pointer attribute.
    From here we check if there are any existing nodes in the list (that is, does
    `self.tail` point to a Node). If there is none, we make the new node the first
    node of the list; otherwise, find the insertion point by traversing the list to
    the last node, updating the next pointer of the last node to the new node.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can append a few items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'List traversal will work more or less like before. You will get the first element
    of the list from the list itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A faster append operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a big problem with the append method in the previous section: it has
    to traverse the entire list to find the insertion point. This may not be a problem
    when there are just a few items in the list, but wait until you need to add thousands
    of items. Each append will be slightly slower than the previous one. A **O**(n)
    goes to prove how slow our current implementation of the `append` method will
    actually be.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, we will store, not only a reference to the first node in the list,
    but also a reference to the last node. That way, we can quickly append a new node
    at the end of the list. The worst case running time of the append operation is
    now reduced from **O**(n) to **O**(1). All we have to do is make sure the previous
    last node points to the new node, that is about to be appended to the list. Here
    is our updated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Take note of the convention being used. The point at which we append new nodes
    is through `self.head`. The `self.tail` variable points to the first node in the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the size of the list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We would like to be able to get the size of the list by counting the number
    of nodes. One way we could do this is by traversing the entire list and increasing
    a counter as we go along:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This works, but list traversal is potentially an expensive operation that we
    should avoid when we can. So instead, we shall opt for another rewrite of the
    method. We add a size member to the `SinglyLinkedList` class, initializing it
    to 0 in the constructor. Then we increment size by one in the `append` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Because we are now only reading the size attribute of the node object, and not
    using a loop to count the number of nodes in the list, we get to reduce the worst
    case running time from **O**(n) to **O**(1).
  prefs: []
  type: TYPE_NORMAL
- en: Improving list traversal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you notice how we traverse our list. That one place where we are still exposed
    to the `node` class. We need to use `node.data` to get the contents of the node
    and `node.next` to get the next node. But we mentioned earlier that client code
    should never need to interact with Node objects. We can achieve this by creating
    a method that returns a generator. It looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now list traversal is much simpler and looks a lot better as well. We can completely
    ignore the fact that there is anything called a Node outside of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice that since the `iter()` method yields the data member of the node, our
    client code doesn't need to worry about that at all.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common operation that you would need to be able to do on a list is to
    delete nodes. This may seem simple, but we'd first have to decide how to select
    a node for deletion. Is it going to be by an index number or by the data the node
    contains? Here we will choose to delete a node by the data it contains.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a figure of a special case considered when deleting a node
    from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When we want to delete a node that is between two other nodes, all we have to
    do is make the previous node directly to the successor of its next node. That
    is, we simply cut the node to be deleted out of the chain as in the preceding
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation of the `delete()` method may look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It should take a **O**(n) to delete a node.
  prefs: []
  type: TYPE_NORMAL
- en: List search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We may also need a way to check whether a list contains an item. This method
    is fairly easy to implement thanks to the `iter()` method we previously wrote.
    Each pass of the loop compares the current data to the data being searched for.
    If a match is found, `True` is returned, or else `False` is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Clearing a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We may want a quick way to clear a list. Fortunately for us, this is very simple.
    All we do is clear the pointers `head` and `tail` by setting them to `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In one fell swoop, we orphan all the nodes at the `tail` and `head` pointers
    of the list. This has a ripple effect of orphaning all the nodes in between.
  prefs: []
  type: TYPE_NORMAL
- en: Doubly linked lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a solid grounding on what a singly linked list is and the kind
    of operations that can be performed on it, we shall now turn our focus one notch
    higher to the topic of doubly linked lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'A doubly linked list is somehow similar to a singly linked list in that we
    make use of the same fundamental idea of stringing nodes together. In a Singly
    linked list, there exists one link between each successive node. A node in a doubly
    linked list has two pointers: a pointer to the next node and a pointer to the
    previous node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A node in a singly linked list can only determine the next node associated with
    it. But the referenced node or next node has no way of telling who is doing the
    referencing. The flow of direction is **only one way**.
  prefs: []
  type: TYPE_NORMAL
- en: In a doubly linked list, we add to each node the ability to not only reference
    the next node but also the previous node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the nature of the linkages that exist between two successive
    nodes for better understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With the existence of two pointers that point to the next and previous nodes,
    doubly linked lists become equipped with certain capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Doubly linked lists can be traversed in any direction. Depending on the operation
    being performed, a node within a doubly linked list can easily refer to its previous
    node where necessary without having to designate a variable to keep track of that
    node. Because a Singly linked list can only be traversed in one direction it may
    sometimes mean moving to the start or beginning of the list in order to effect
    certain changes buried within the list.
  prefs: []
  type: TYPE_NORMAL
- en: Since there is immediate access to both next and previous nodes, deletion operations
    are much easier to perform, as you will see later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A doubly linked list node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Python code that creates a class to capture what a doubly linked list node
    is includes in its initializing method, the `prev`, `next`, and `data` instance
    variables. When a node is newly created, all these variables default to `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `prev` variable holds a reference to the previous node, while the `next`
    variable continues to hold a reference to the next node.
  prefs: []
  type: TYPE_NORMAL
- en: Doubly linked list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is still important to create a class that captures the data that our functions
    will be operating on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For the purposes of enhancing the `size` method, we also set the `count` instance
    variable to 0\. `head` and `tail` will point to the head and tail of the list
    when we begin to insert nodes into the list.
  prefs: []
  type: TYPE_NORMAL
- en: We adopt a new convention where `self.head` points to the beginner node of the
    list and `self.tail` points to the latest node added to the list. This is contrary
    to the convention we used in the singly linked list. There are no fixed rules
    as to the naming of the head and tail node pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Doubly linked lists also need to provide functions that return the size of the
    list, inserts into the list, and also deletes nodes from the list. We will be
    examining some of the code to do this. Let's commence with the `append` operation.
  prefs: []
  type: TYPE_NORMAL
- en: Append operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During an `append` operation, it is important to check whether the `head` is
    `None`. If it is `None`, it means that the list is empty and should have the `head`
    set pointing to the just-created node. The `tail` of the list is also pointed
    at the new node through the head. By the end of these series of steps, `head`
    and `tail` will now be pointing to the same node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The following diagram illustrates the head and tail pointers of the doubly linked
    list when a new node is added to an empty list.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `else` part of the algorithm is only executed if the list is not empty.
    The new node''s previous variable is set to the tail of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The tail''s next pointer (or variable) is set to the new node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we update the tail pointer to point to the new node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Since an `append` operation increases the number of nodes by one, we increase
    the counter by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'A visual representation of the `append` operation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delete operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike the singly linked list, where we needed to keep track of the previously
    encountered node anytime we traversed the whole length of the list, the doubly
    linked list avoids that whole step. This is made possible by the use of the previous
    pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm for removing nodes from a doubly linked list caters for basically
    four scenarios before deletion of a node is completed. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: When the search item is not found at all
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the search item is found at the very beginning of the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the search item is found at the tail end of the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the search item is found somewhere in the middle of the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The node to be removed is identified when its `data` instance variable matches
    the data that is passed to the method to be used in the search for the node. If
    a matching node is found and subsequently removed, the variable `node_deleted`
    is set to `True`. Any other outcome results in `node_deleted` being set to `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the `delete` method, the `current` variable is set to the head of the list
    (that is, it points to the `self.head` of the list). A set of `if... else` statements
    are then used to search the various parts of the list to find the node with the
    specified data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `head` node is searched first. Since `current` is pointing at `head`, if
    `current` is None, it is presumed that the list has no nodes for a search to even
    begin to find the node to be removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if `current` (which now points to head) contains the very data being
    searched for, then `self.head` is set to point to the `current` next node. Since
    there is no node behind head now, `self.head.prev` is set to `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar strategy is adopted if the node to be removed is located at the tail
    end of the list. This is the third statement that searches for the possibility
    that the node to be removed might be located at the end of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, the algorithm to find and remove a node loops through the list of nodes.
    If a matching node is found, `current`''s previous node is connected to current''s
    next node. After that step, `current`''s next node is connected to previous node
    of `current`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `node_delete` variable is then checked after all the `if-else` statements
    has been evaluated. If any of the `if-else` statements changed this variable,
    then it means a node has been deleted from the list. The count variable is therefore
    decremented by 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example of deleting a node that is buried within a list, assume the existence
    of three nodes, A, B, and C. To delete node B in the middle of the list, we will
    essentially make A point to C as its next node, while making C point to A as its
    previous node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After such an operation, we end up with the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_04_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: List search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The search algorithm is similar to that of the `search` method in a singly
    linked list. We call the internal method `iter()` to return the data in all the
    nodes. As we loop through the data, each is matched against the data passed into
    the `contain` method. If there is a match, we return `True`, or else we return
    `False` to symbolize that no match was found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Our doubly linked list has a **O**(1) for the `append` operation and **O**(n)
    for the `delete` operation.
  prefs: []
  type: TYPE_NORMAL
- en: Circular lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A circular list is a special case of a linked list. It is a list where the endpoints
    are connected. That is, the last node in the list points back to the first node.
    Circular lists can be based on both singly and doubly linked lists. In the case
    of a doubly linked circular list, the first node also needs to point to the last
    node.
  prefs: []
  type: TYPE_NORMAL
- en: Here we are going to look at an implementation of a singly linked circular list.
    It should be straightforward to implement a doubly linked circular list, once
    you have grasped the basic concepts.
  prefs: []
  type: TYPE_NORMAL
- en: We can reuse the `node` class that we created in the section on singly linked
    lists. As a matter of fact, we can reuse most parts of the `SinglyLinkedList`
    class as well. So we are going to focus on the methods where the circular list
    implementation differs from the normal singly linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Appending elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we append an element to the circular list, we need to make sure that the
    new node points back to the tail node. This is demonstrated in the following code.
    There is one extra line as compared to the singly linked list implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Deleting an element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We may think that we can follow the same principle as for append and simply
    make sure the head points to the tail. This would give us the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As previously, there is just a single line that needs to change. It is only
    when we remove the tail node that we need to make sure that the head node is updated
    to point to the new tail node.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a serious problem with this code. In the case of a circular
    list, we cannot loop until current becomes `None`, since that will never happen.
    If you delete an existing node, you wouldn't see this, but try deleting a nonexistent
    node and you will get stuck in an indefinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'We thus need to find a different way to control the `while` loop. We cannot
    check whether current has reached head, because then it will never check the last
    node. But we could use `prev`, since it lags behind current by one node. There
    is a special case, however. The very first loop iteration, `current` and `prev`,
    will point to the same node, namely the tail node. We want to ensure that the
    loop does run here, since we need to take the one node list into consideration.
    The updated `delete` method now looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Iterating through a circular list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You do not need to modify the `iter()` method. It will work perfectly well
    for our circular list. But you do need to put in an exit condition when you are
    iterating through the circular list, otherwise your program will get stuck in
    a loop. Here is a way you could do this, by using a counter variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Once we have printed out 1,000 elements, we break out of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at linked lists. We have studied the concepts
    that underlie lists, such as nodes and pointers to other nodes. We implemented
    the major operations that occur on these types of list and saw how their worst
    case running times compare.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we are going to look at two other data structures that
    are usually implemented using lists: stacks and queues.'
  prefs: []
  type: TYPE_NORMAL
