<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Paint Application</h1>
                </header>
            
            <article>
                
<p class="mce-root">We used the Canvas widget to define a custom widget in <a href="73aef6b5-11e2-4cb9-bb4a-5c96bf81dfcc.xhtml">Chapter 5</a>, <em>Building an Audio Player</em>. The Canvas widget is truly one of Tkinter's highlights. It is an incredibly powerful and flexible widget. Let's, therefore, devote most of this chapter to looking at the Canvas widget in detail.</p>
<p class="mce-root">We will now develop a paint application. The application will let the user draw freehand lines, straight lines, circles, rectangles, arcs, and other polygons. It will also let the user define new complex shapes.</p>
<p class="mce-root">In addition to exploring the Canvas widget, we will also develop a tiny GUI framework on top of the Tkinter interface. As you will see, frameworks are a great way to maximize code reuse. This makes them a powerful tool for <strong>Rapid </strong><strong>Application Development (RAD)</strong>.</p>
<p class="mce-root">Some of the key learning objectives for this chapter are as follows:</p>
<ul>
<li class="mce-root">Master the Canvas widget API</li>
<li class="mce-root">Learn to build and use custom GUI frameworks for maximum code reuse and rapid application development</li>
<li class="mce-root">Learn to use the <kbd>colorchooser</kbd> module of Tkinter </li>
<li class="mce-root">Learn to use the ttk ComboBox widget</li>
<li class="mce-root">Get to know available widget methods</li>
<li class="mce-root">Reinforce things that we have learned in previous projects</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Overview of the application</h1>
                </header>
            
            <article>
                
<p>In its final form, our paint application would look as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="469" src="assets/caaa69fc-faea-49ba-ab31-c4950c8a1e36.png" width="546"/></div>
<div class="packt_infobox">There are no external library requirements for this chapter, so let's dive into the code.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a tiny framework</h1>
                </header>
            
            <article>
                
<p>So why do we need another framework on top of Tkinter? If we need to build just a single program, we need not build a framework. However, if we find ourselves writing the same boilerplate code over and over again, a framework is what we need. That is, a framework is a tool that lets us easily generate generic and often-used patterns with ease.</p>
<p>Consider, for example, menus used in programs. A menu is such a common element in most programs, yet we need to handcraft each menu item every time we sit down to write a program. What if we could further abstract to simplify menu generation?</p>
<p>This is where frameworks come in handy.</p>
<p>Say you have a program that has 10 different top-level menus. Say each of the top-level menus has five menu items. We will have to then write 50 lines of code simply to display these 50 menu items. You have to link each of them manually to other commands besides having to set tons of options for each of them.</p>
<p>If we keep doing this for all our widgets, our GUI programming becomes an exercise in typing. Every extra line of code that you write adds to the program complexity, making it more difficult for someone else to read, maintain, modify, and/or debug the code.</p>
<p>This is where using a custom framework comes to our aid. Let's develop a tiny framework that makes menu generation easy for us.</p>
<p>We create a file, <kbd>framework.py</kbd>, and create a new class, <kbd>Framework</kbd>, to the file. Every class that uses this framework must inherit from this class and should pass the root window as an argument to this class by calling the super method as follows:</p>
<pre>super().__init__(root)</pre>
<p>This will make all methods defined in the <kbd>Framework</kbd> class available to the inheriting class.</p>
<p>We will now define a method, <kbd>build_menu</kbd>, which takes a tuple in an expected format as input and automatically creates the menu for us. Let's define an arbitrary rule that each group of menu items must be represented by a single entry in a tuple.</p>
<p>Furthermore, we come up with a rule that each item in the tuple must be presented in the following format:</p>
<pre>'Top Level Menu Name – Menu Item Name / Accelrator /Commandcallback/Underlinenumber'</pre>
<p><kbd>MenuSeparator</kbd> is denoted by a string <kbd>'sep'</kbd>.</p>
<p>An alternative representation of menu definition could be specifying it as a tuple instead of a string definition, which is like asking the user to already split the definition rather than us having to extract the menu definition from a string.</p>
<p>For instance, passing this tuple as an argument to the <kbd>build_menu</kbd> method should <span>generate three menus as shown in the following code</span>:</p>
<pre>menu_items = (<br/>'File - &amp;New/Ctrl+N/self.new_file, &amp;Open/Ctrl+O/self.open_file',<br/>'Edit - Undo/Ctrl+Z/self.undo', <br/>'sep',<br/>'Options/Ctrl+T/self.options',<br/>'About - About//self.about'<br/>)</pre>
<p>Take a look at the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/178dbd61-7fd6-4922-8257-8deab81bf4b2.png"/></div>
<p>The first item of the string (before dash (<kbd>-</kbd>)) represents the top-level menu button. Each subsequent part of the string separated by a forward slash (<kbd>/</kbd>)  represents one menu item, its accelerator key, and the attached command callback.<br/>
The position of the ampersand symbol (<kbd>&amp;</kbd>) represents the position of the shortcut key to be underlined. If we encounter the string <kbd>sep</kbd>, we add a menu separator. </p>
<p>Now that we have defined the rules, the code for <kbd>build_menu</kbd> is as follows: (see the <kbd>framework.py</kbd> code):</p>
<pre>def build_menu(self, menu_definition):<br/>  menu_bar = tk.Menu(self.root)<br/>  for definition in menu_definition:<br/>    menu = tk.Menu(menu_bar, tearoff=0)<br/>    top_level_menu, pull_down_menus = definition.split('-')<br/>    menu_items = map(str.strip, pull_down_menus.split(','))<br/>    for item in menu_items:<br/>      self._add_menu_command(menu, item)<br/>    menu_bar.add_cascade(label=top_level_menu, menu=menu)<br/>  self.root.config(menu=menu_bar)<br/><br/>def _add_menu_command(self, menu, item):<br/>  if item == 'sep':<br/>    menu.add_separator()<br/>  else:<br/>    menu_label, accelrator_key, command_callback =item.split('/')<br/>    try:<br/>      underline = menu_label.index('&amp;')<br/>      menu_label = menu_label.replace('&amp;', '', 1)<br/>    except ValueError:<br/>      underline = None<br/>    menu.add_command(label=menu_label,underline=underline, <br/>      accelerator=accelrator_key,<br/>        command=eval(command_callback))</pre>
<p>The description of the code is as follows:</p>
<ul>
<li>The method, <kbd>build_menu</kbd>, operates on a tuple by the name <kbd>menu_definition</kbd>, which must specify all desired menus and menu items in the exact format, as previously discussed.</li>
<li>It iterates through each item in the tuple, splitting the item based on the dash (<kbd>–</kbd>) delimiter, building the top-menu button for each item left to the dash (<kbd>-</kbd> ) delimiter.</li>
<li>It then splits the second part of the string based on the comma (<kbd>,</kbd>) delimiter.</li>
<li>It then iterates through this second part, creating menu items for each of the parts, adding the accelerator key, command callback, and underline key using another method, <kbd>_add_menu_command</kbd>.</li>
<li>The <kbd>_add_menu_command</kbd> method iterates through the string and adds a separator if it finds the string <kbd>sep</kbd>. If not, it next searches for an ampersand (<kbd>&amp;</kbd>) in the string. If it finds one, it calculates its index position and assigns it to the underline variable. It then replaces the ampersand value with an empty string, because we do not want to display the ampersand in our menu item.</li>
<li>If an ampersand is not found in a string, the code assigns <kbd>None</kbd> to the underline variable.</li>
<li>Finally, the code adds a command callback, accelerator key, and underline value to the menu item. Note that our framework adds only the accelerator key label. It is the developer's responsibility to bind events to the bound keys.</li>
</ul>
<p>Our demonstration of making GUI frameworks ends here. We can now use this method to define literally hundreds of menus simply by adding one new line for each group of menus.</p>
<p>However, this is a rather rudimentary framework. The rules for defining items are completely arbitrary. The choice of delimiters means that we can no longer use the dash (<kbd>-</kbd>), slash (<kbd>/</kbd>), and ampersand (<kbd>&amp;</kbd>) characters that we have used as delimiters in any menus that we define using this framework.</p>
<p>Our framework does not lay down rules for any other widgets. In fact, this definition is not even sufficient to generate other types of menu such as cascading menus, check button menus, or radio button menus. We will, however, not extend the framework further, as it is sufficient to have developed the concept behind framework design and usage and that is all we need to use in our paint application.</p>
<p>We have also included a small test in the <kbd>framework.py</kbd> file. If you execute the file as a standalone program, it should pop up a window and define some menus for testing.</p>
<div class="packt_tip">Fully-fledged frameworks use more <span class="packt_screen">structured markup languages</span> to represent rules. <span class="packt_screen">XML</span> is one of the most popular choices for writing GUI frameworks. You can find an example of a full-blown XML-based <span class="packt_screen">Tkinter RAD </span>(<span class="packt_screen">tkRAD</span>) framework here: <a href="https://github.com/muxuezi/tkRAD">https://github.com/muxuezi/tkRAD</a>. A simple menu implementation using the preceding framework can be seen here:<a href="https://github.com/muxuezi/tkRAD/blob/master/xml/rad_xml_menu.py"> https://github.com/muxuezi/tkRAD/blob/master/xml/rad_xml_menu.py</a>.</div>
<p>Using a framework for smaller programs may be overkill, but they are invaluable assets for large programs. Hopefully, you should now be able to appreciate the benefits of using frameworks for larger programs.</p>
<p>Now that we have the code for <kbd>build_menu</kbd>, we can extend it to add as many menu items as required without having to write repetitive and similar code for each of them.</p>
<p>This ends our first iteration. We will use this tiny framework to define the menu for our drawing program in the next step.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up a broad GUI structure</h1>
                </header>
            
            <article>
                
<p>Let's now set up the broad GUI elements of our program. We will create a <kbd>PaintApplication</kbd> class in <kbd>6.01.py</kbd>. Since we want to draw the menu using our framework, we import the framework into our file and inherit from the <kbd>Framework</kbd> class as follows:</p>
<pre>import framework<br/><br/>class PaintApplication(<strong>framework.Framework</strong>):<br/>  <br/>  def __init__(self, root):<br/>    <strong>super().__init__(root)</strong><br/>    self.create_gui()</pre>
<p>The <kbd>__init__</kbd> method calls another method, <kbd>create_gui</kbd>, which is responsible for creating the basic GUI structure for our program.</p>
<p>The <kbd>create_gui</kbd> method simply delegates the task to five separate methods, each being responsible for creating one section of the GUI as follows (see code <kbd>6.01.py</kbd>):</p>
<pre>def create_gui(self):<br/>  self.create_menu()<br/>  self.create_top_bar()<br/>  self.create_tool_bar()<br/>  self.create_drawing_canvas()<br/>  self.bind_menu_accelrator_keys()</pre>
<p>These five methods together build a structure as shown in the following screenshot (see code <kbd>6.01.py</kbd>):</p>
<div class="CDPAlignCenter CDPAlign"><img height="236" src="assets/453f9f3d-5ab0-4f15-ab85-cb14575c2383.png" width="234"/></div>
<p>We have written similar code in all previous chapters, hence we will not reproduce the code for these five methods here. Note, however, a few things about the code in <kbd>6.01.py</kbd>:</p>
<ul>
<li>Since we want to use the framework, we inherit from the <kbd>Framework</kbd> class and call its <kbd>__init__</kbd> method using <kbd><kbd>super()</kbd></kbd></li>
<li>The <kbd>create_menu</kbd> method specifies the tuple for our menu definition and calls the <kbd>build_menu</kbd> method defined earlier in our framework</li>
</ul>
<p>We define a lot of empty methods that will be implemented later. Each empty method is added as a command callback to individual menu items. The empty methods defined here are:</p>
<pre>on_new_file_menu_clicked()<br/>on_save_menu_clicked()<br/>on_save_as_menu_clicked()<br/>on_close_menu_clicked()<br/>on_canvas_zoom_out_menu_clicked()<br/>on_canvas_zoom_in_menu_clicked()<br/>on_undo_menu_clicked()<br/>on_about_menu_clicked() </pre>
<p>This gives us a broad GUI structure for our program. Next, we will look at interacting with the drawing canvas.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dealing with mouse events</h1>
                </header>
            
            <article>
                
<p>When we draw in a paint program, we use a mouse as the primary input device.</p>
<p>There are primarily two kinds of mouse event that cause changes on the drawing canvas and are therefore of interest: </p>
<ul>
<li>Click and release</li>
<li>Click, drag, and release</li>
</ul>
<p>There is also a third event in which we have limited interest—the mouse movements with no buttons clicked. Our interest is limited there since an unclicked motion normally does not cause any changes on the canvas.</p>
<p>We ignore right-click and wheel-scroll as we will not be using them in our program.</p>
<p>In both the preceding cases, we need to know where the mouse was first clicked and where it was released. For click and release, this could be the same location. For click, drag, and release this will normally be different locations.</p>
<p>Accordingly, we define four attributes to keep track of the coordinates for these two locations (see code <kbd>6.02.py</kbd>):</p>
<pre>start_x, start_y = 0, 0<br/>end_x, end_y = 0, 0</pre>
<p>Our immediate goal then is to bind our mouse events in such a way that any click or drag gives us the value of these four start and end coordinates.</p>
<p>The coordinates of the Canvas widget begin at the top-left corner ((<kbd>0, 0</kbd>) is the top-corner). </p>
<p>The Canvas widget uses two coordinate systems:</p>
<ul>
<li><span>The <strong>window coordinate system</strong>, which is always <kbd>0, 0</kbd> for the leftmost corner, no matter where you scroll down or up the canvas</span></li>
<li>The <strong>canvas coordinate system</strong>, which specifies where the items are actually drawn on the canvas</li>
</ul>
<p>We will mostly be interested in the canvas coordinate system, but mouse events emit data on the window coordinate system. To convert from the window coordinate system to the canvas coordinate system we can use the following methods:</p>
<pre> canvas_x = canvas.canvasx(event.x)<br/> canvas_y = canvas.canvasy(event.y) </pre>
<p>Let's now modify our <kbd>__init__</kbd> method to also call a method, <kbd>bind_mouse</kbd>. We define the <kbd>bind_mouse</kbd> method as follows (see code <kbd>6.02.py</kbd>):</p>
<pre>def bind_mouse(self):<br/>  self.canvas.bind("&lt;Button-1&gt;", self.on_mouse_button_pressed)<br/>  self.canvas.bind( "&lt;Button1-Motion&gt;", <br/>                   self.on_mouse_button_pressed_motion)<br/>  self.canvas.bind( "&lt;Button1-ButtonRelease&gt;",  <br/>    self.on_mouse_button_released)<br/>  self.canvas.bind("&lt;Motion&gt;", self.on_mouse_unpressed_motion)<br/> </pre>
<p>We then define the first three methods that were bound just now. We ignore the unpressed motion for now by making an empty method. Remember that we are interested in getting the start and end coordinates, which are acquired as follows (see code <kbd>6.02.py</kbd>):</p>
<pre>def on_mouse_button_pressed(self, event):<br/>  self.start_x = self.end_x = self.canvas.canvasx(event.x)<br/>  self.start_y = self.end_y = self.canvas.canvasy(event.y)<br/>  print("start_x, start_y = ", self.start_x, self.start_y)<br/><br/>def on_mouse_button_pressed_motion(self, event):<br/>  self.end_x = self.canvas.canvasx(event.x)<br/>  self.end_y = self.canvas.canvasy(event.y)<br/>  <br/>def on_mouse_button_released(self, event):<br/>  self.end_x = self.canvas.canvasx(event.x)<br/>  self.end_y = self.canvas.canvasy(event.y)<br/>  print("end_x, end_y = ", self.end_x, self.end_y)</pre>
<p>We have temporarily added two <kbd>print</kbd> statements to show these four values on the console (see code <kbd>6.02.py</kbd>).</p>
<p>Now that we have the location of the start and end mouse events, we can act upon those events to do all kinds of activities on the canvas.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding toolbar buttons</h1>
                </header>
            
            <article>
                
<p>Next, we need to add 16 buttons to the left toolbar. Furthermore, depending on which button is clicked, different options would show up in the top bar as shown here:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/09a714e8-a7fb-4040-9a3a-2eebacdd4b95.png"/></div>
<p>We do not want our code structure to be too bloated by conditional logic to switch among these 16 functions. Therefore, we will call these methods dynamically.</p>
<p>We first begin by defining a tuple of all 16 function names (see code <kbd>6.01.py</kbd>):</p>
<pre>tool_bar_functions = (<br/> "draw_line", "draw_oval", "draw_rectangle", "draw_arc",<br/> "draw_triangle", "draw_star", "draw_irregular_line",<br/> "draw_super_shape", "draw_text", "delete_item",<br/> "fill_item", "duplicate_item", "move_to_top",<br/> "drag_item", "enlarge_item_size", "reduce_item_size"<br/> )</pre>
<p>Doing so ensures that we do not have to call each method explicitly from our code. We can instead use the index of the tuple to retrieve the method name and call it dynamically using the following:</p>
<pre> getattr(self, self.toolbar_functions[index]) </pre>
<p>This makes sense here because we would eventually add more features to our drawing program by simply extending the <kbd>toolbar_functions</kbd> tuple.</p>
<p>We further define an attribute, <kbd>selected_tool_bar_function</kbd>, which will keep track of which button was last clicked. We initialize it to the first button ( <kbd>draw_line</kbd> ) as follows:</p>
<pre>selected_tool_bar_function = tool_bar_functions[0] </pre>
<p>Next, we create a folder named <kbd>icons</kbd> and add icons for all these 16 toolbar buttons. The icons have been named the same as the corresponding function name. </p>
<p>Maintaining this consistency allows us to use the same tuple to loop over and build our toolbar buttons. This style of programming is what you could call programming using <strong>conventions over configuration</strong>.</p>
<p>We next create the method that makes the actual buttons (see code <kbd>6.03.py</kbd>):</p>
<pre>def create_tool_bar_buttons(self):<br/>  for index, name in enumerate(self.tool_bar_functions):<br/>    icon = tk.PhotoImage(file='icons/' + name + '.gif')<br/>    self.button = tk.Button(self.tool_bar, image=icon, command=<strong>lambda</strong><br/><strong>                 index=index: self.on_tool_bar_button_clicked(index)</strong>)<br/>    self.button.grid(row=index // 2, column=1 + index % 2, sticky='nsew')<br/>    self.button.image = icon</pre>
<p>The preceding code creates all the buttons and adds command callbacks to the buttons as highlighted. We accordingly define the command callback as follows (see code <kbd>6.03.py</kbd>):</p>
<pre>def on_tool_bar_button_clicked(self, button_index):<br/>  self.selected_tool_bar_function = self.tool_bar_functions[button_index]<br/>  self.remove_options_from_top_bar()<br/>  self.display_options_in_the_top_bar()</pre>
<p>The preceding method sets the value of <kbd>selected_tool_bar_function</kbd>. Next, it calls two methods that are defined as follows (see code <kbd>6.03.py</kbd>):</p>
<pre>def remove_options_from_top_bar(self):<br/>  for child in self.top_bar.winfo_children():<br/>    child.destroy()</pre>
<p>We need to remove any existing options currently displaying in the top bar before we can display options for the newly selected button. The <kbd>winfo_children</kbd> method used just now returns a list of all widgets that are children of this widget.</p>
<p>Now that we have removed all items from the top bar, we define the selected tool icon on the top bar:</p>
<pre>def display_options_in_the_top_bar(self):<br/>  self.show_selected_tool_icon_in_top_bar(self.selected_tool_bar_function)</pre>
<p>Currently, this method only calls one other method to display the selected tool icon in the top bar. We will, however, use this method as the central place for adding options to the top bar later in the chapter.</p>
<p>We do not discuss the <kbd>show_selected_tool_icon_in_top_bar</kbd> method here as it simply adds a label with an icon to the top bar (see code <kbd>6.03.py</kbd>):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/889c4325-4549-4330-b166-e8127b7fe0e7.png"/></div>
<p>Now, if you go and run the code <kbd>6.03.py</kbd>, it should display all 16 buttons in the left toolbar. Furthermore, clicking on any one of the buttons should display the selected button in the top bar, as shown in the preceding screenshot.</p>
<div class="packt_infobox">The <kbd>winfo_children()</kbd> method used earlier is an example of widget methods that are available to be called on all widgets. Several useful widget methods are defined in Tkinter.<br/>
In addition to the widget methods that are available on all widgets, some methods are only available on the top-level window. You can get a list of all such available methods and their descriptions by typing the following in your Python 3 console:<br/>
<ul>
<li><kbd><strong>&gt;&gt;&gt; import tkinter</strong></kbd></li>
<li><kbd><strong>&gt;&gt;&gt; help (tkinter.Misc)</strong></kbd></li>
<li><kbd><strong>&gt;&gt;&gt; help (tkinter.Wm)</strong></kbd></li>
</ul>
These are available online at <a href="http://effbot.org/tkinterbook/widget.htm">http://effbot.org/tkinterbook/widget.htm</a> and at <a href="http://effbot.org/tkinterbook/wm.htm">http://effbot.org/tkinterbook/wm.htm</a>.<br/>
You are encouraged to take a look at all these available methods.</div>
<p>Next, we will extend our program to actually draw items on the canvas.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Drawing items on the canvas</h1>
                </header>
            
            <article>
                
<p>Objects added to the canvas are called <strong>items</strong>. New items are added to the canvas using different create methods such as <kbd>create_line</kbd>, <kbd>create_arc</kbd>, <kbd>create_oval</kbd>, <kbd>create_rectangle</kbd>, <kbd>create_polygon</kbd>, <kbd>create_text</kbd>, <kbd>create_bitmap</kbd>, and <kbd>create_image</kbd>.</p>
<p>Items added to the canvas are placed in a stack. New items are added on top of items already on the canvas. Every time you add an item using one of the various create methods, it returns a unique item handle or an item ID that is a unique integer. This item handle can be used to refer to and manipulate the added item.</p>
<p>In addition to an item handle, items can have the following item specifiers:</p>
<ul>
<li><kbd>tags</kbd> are specifiers that we can add to one or more items</li>
<li><kbd>ALL</kbd> (or the string all) matches all items on the canvas</li>
<li>CURRENT (or <kbd>current</kbd>) matches the item under the mouse pointer if any</li>
</ul>
<p>We can use any of the preceding item specifiers for methods that act on canvas items.</p>
<p>To add a tag to an item, you specify the tag (which is a string) as its configurable option, either at the time of creating the object or later using the <kbd>itemconfig</kbd> method or the <kbd>addtag_withtag</kbd> method, as follows:</p>
<pre>canvas.create_rectangle(10, 10, 50, 50, tags="foo")<br/>canvas.itemconfig(item_specifier, tags="spam")<br/>canvas.addtag_withtag("spam", "baz")</pre>
<p>You can add multiple tags to an item at once by passing in the tags as a tuple of strings, as follows:</p>
<pre>canvas.itemconfig(item_specifier, tags=("tag_A", "tag_B"))</pre>
<p>To get all tags associated with an item handle, use <kbd>gettags</kbd> as follows:</p>
<pre>canvas.gettags(item_handle)</pre>
<p>This returns a tuple of all tags associated with that item handle.</p>
<p>To get the item handles for all items that have a given tag, use <kbd>find_withtag</kbd>:</p>
<pre>canvas.find_withtag("spam")</pre>
<p>This returns a tuple of item handles for all items with a tag of spam.</p>
<p>Given this information, let's code the functionality for the first six buttons, as shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/ee68d097-34fc-4234-9390-1c6051bc4948.png"/></div>
<p>More specifically, we will code the functionality for the following function names that we have already defined earlier in the tuple <kbd>tool_bar_functions</kbd>:  <kbd>"draw_line"</kbd>, <kbd>"draw_oval"</kbd>, <kbd>"draw_rectangle"</kbd>, <kbd>"draw_arc"</kbd>, and <kbd>"draw_triangle", "draw_star"</kbd></p>
<p><br/>
Here's the code for <kbd>draw_ line</kbd> (see code <kbd>6.04.py</kbd>):</p>
<pre>def draw_line(self):<br/>  self.current_item = self.canvas.create_line(self.start_x, <br/>    self.start_y, self.end_x,                                <br/>      self.end_y, fill=self.fill, width=self.width, arrow=self.arrow, <br/>        dash=self.dash)</pre>
<p>This uses the <kbd>create_line</kbd> method and draws a line from the start <em>x</em>, <em>y</em> coordinates to the end <em>x</em>, <em>y</em> coordinates. We have defined four new attributes for handling four different properties of the line:</p>
<ul>
<li>
<p><kbd>fill</kbd>: Line color. Default is <kbd>black</kbd>, initialized as red in our program.</p>
</li>
<li>
<p><kbd>width</kbd>: Default is <kbd>1</kbd>, initialized as <kbd>2</kbd> in our program.</p>
</li>
<li>
<p><kbd>arrow</kbd>: Default is <kbd>None</kbd>. The available choices are: <kbd>None</kbd>, <kbd>First</kbd>, <kbd>Last</kbd>, <kbd>Both</kbd>.</p>
</li>
<li>
<p><kbd>dash</kbd>: A <kbd>dash</kbd> pattern, which is a list of segment lengths. Only the odd segments are drawn.</p>
</li>
</ul>
<p>We will later provide options for changing these four values from the top bar and hence these have been added as class attributes.</p>
<p>Also note that since <kbd>create_line</kbd> (and all create methods) return the item handle for the created item, we store it in an attribute named <kbd>current_item</kbd>. This gives us access to the last created item, which we will soon put to good use.</p>
<p>Next, here's the code for <kbd>draw_ oval</kbd> (see code <kbd>6.04.py</kbd>):</p>
<pre>def draw_oval(self):<br/> self.current_item = self.canvas.create_oval(self.start_x, <br/>   self.start_y, self.end_x,  <br/>     self.end_y, outline=self.outline, fill=self.fill,width=self.width)</pre>
<p>This is identical to the code for <kbd>draw_line</kbd>, except that we added a new attribute named outline that takes care of the outline color.</p>
<p>We will not discuss the code for <kbd>create_rectangle</kbd> and <kbd>create_arc</kbd>, which are almost identical to the code of <kbd>draw_oval</kbd> discussed here (see code <kbd>6.04.py</kbd>).</p>
<p>Let's now discuss the <kbd>create_polygon</kbd> method. This method can be used to create all sorts of interesting shapes. Let's begin with the simple case of drawing an equilateral triangle (see code <kbd>6.04.py</kbd>):</p>
<pre>def draw_triangle(self):<br/>  dx = self.end_x - self.start_x<br/>  dy = self.end_y - self.start_y<br/>  z = complex(dx, dy)<br/>  radius, angle0 = cmath.polar(z)<br/>  edges = 3<br/>  points = list()<br/>  for edge in range(edges):<br/>    angle = angle0 + edge * (2 * math.pi) / edges<br/>    points.append(self.start_x + radius * math.cos(angle))<br/>    points.append(self.start_y + radius * math.sin(angle))<br/>  self.current_item = self.canvas.create_polygon(points, <br/>    outline=self.outline,  <br/>      fill=self.fill, width=self.width)</pre>
<p>The preceding code first converts the changes in the <em>x</em>, <em>y</em> coordinates from the Cartesian coordinate system to the polar coordinates represented by an angle and a radius. It then calculates the <em>x</em>, <em>y</em> coordinates for all three edges of the triangle using the following formula:</p>
<pre>x = r*cosσ and y = r*sinσ </pre>
<p>Once we have the x, y coordinates for all three vertices of the triangle, we call the <kbd>create_polygon</kbd> method to draw the triangle.<br/>
Let's now use the <kbd>create_polygon</kbd> method to make stars. A star (and many other polygons) can be thought of as a collection of points or spokes on two concentric circles, as shown in the following figure:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="243" src="assets/b7a716e9-86ca-45b5-9edc-3230898586b4.png" width="245"/></div>
<p>The star shown in the preceding figure has five spokes. We will later allow the user to change the number of spokes. Therefore, let's start by defining a class attribute as follows:</p>
<pre>number_of_spokes = 5</pre>
<p class="mce-root">The shape of the star is also determined by the ratio of the radius of the inner circle to the radius of the outer circle, as in the preceding figure. This is called the <strong>spoke ratio</strong>. This ratio is 2 for a standard star. Changing this ratio can also produce all sorts of interesting star shapes. However, we will keep it at <kbd>2</kbd> for our example. Given these rules, the code for <kbd>draw_star</kbd> is defined as follows (see code <kbd>6.04.py</kbd>):</p>
<pre><br/> def draw_star(self):<br/>   dx = self.end_x - self.start_x<br/>   dy = self.end_y - self.start_y<br/>   z = complex(dx, dy)<br/>   radius_out, angle0 = cmath.polar(z)<br/>   radius_in = radius_out / 2 # this is the spoke ratio<br/>   points = list()<br/>   for edge in range(self.number_of_spokes):<br/>      # outer circle angle<br/>      angle = angle0 + edge * (2 * math.pi) / self.number_of_spokes  <br/>      # x coordinate (outer circle)<br/>      points.append(self.start_x + radius_out * math.cos(angle)) <br/>      # y coordinate (outer circle)<br/>      points.append(self.start_y + radius_out * math.sin(angle)) <br/>      # inner circle angle<br/>      angle += math.pi / self.number_of_spokes<br/>      # x coordinate (inner circle)<br/>      points.append(self.start_x + radius_in * math.cos(angle))<br/>      # y coordinate (inner circle)<br/>      points.append(self.start_y + radius_in * math.sin(angle))<br/>   self.current_item = self.canvas.create_polygon(points, outline=self.outline, fill=self.fill, width=self.width)</pre>
<p>The preceding code is heavily commented for you to understand. This is very similar to the code we used to draw triangles.</p>
<p>Now, instead of having points on one circle (as for triangles), we have points on two circles. We again use the same technique to first convert the <em>x</em>, <em>y</em> coordinates from mouse events to polar coordinates. Once we have the polar coordinates, it is easy to move the points in the circle.</p>
<p>We then move the points by a given angle and change back to Cartesian coordinates. We keep appending all the points to an empty list called <strong>points</strong>. Once we have all the points, the last line calls the <kbd>create_polygon</kbd> method of the canvas object to draw the star.<br/>
Now we have all the methods to create these six shapes. But they need to be called from somewhere for the drawing to happen. And we have already decided that they would be called dynamically.</p>
<p>Accordingly, we define a method, <kbd>execute_selected_method</kbd>, which takes the string for the selected toolbar function, converts the string into a callable function, and executes it dynamically.</p>
<p class="mce-root">The code is as follows (see code <kbd>6.04.py</kbd>):</p>
<pre>def execute_selected_method(self):<br/>  self.current_item = None<br/>  func = getattr(self, self.selected_tool_bar_function, <br/>    self.function_not_defined)<br/>  func()</pre>
<p>This method, <kbd>getattr</kbd>, provides a reference to a method from the given string at runtime. A second argument provides a fallback mechanism whereby if the method object from the first argument is not found, a reference to the second method is provided.</p>
<p>This helps us gracefully handle situations where a dynamically created method does not exist. We simply define the fallback method as an empty method to handle those cases (see code <kbd>6.04.py</kbd>):</p>
<pre>def function_not_defined(self):<br/>   pass</pre>
<p>So now we have a method to execute the selected method dynamically. Where do we plug in this method?</p>
<p>Since the drawing must begin when the mouse is clicked, we call the <kbd>execute_selected_method</kbd> method once from the <kbd>on_mouse_button_pressed</kbd> method.</p>
<p>The drawing must continue while the mouse is dragged in a clicked position. So we call this method again from the <kbd>on_mouse_button_pressed_motion</kbd> method.</p>
<p>However, although we want to keep the last drawn object during the mouse motion, we want to remove all other items except for the last drawn item. We therefore modify <kbd>on_mouse_button_pressed_motion</kbd> as follows (see code <kbd>6.04.py</kbd>):</p>
<pre>def on_mouse_button_pressed_motion(self, event):<br/>  self.end_x = self.canvas.canvasx(event.x)<br/>  self.end_y = self.canvas.canvasy(event.y)<br/>  self.canvas.delete(self.current_item)<br/>  self.execute_selected_method()</pre>
<p>Now, if you run <kbd>6.04.py</kbd>, the top six buttons on the toolbar should function as shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="254" src="assets/d5ad7fda-4953-41b4-bd99-c123934d08ed.png" width="426"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a color palette</h1>
                </header>
            
            <article>
                
<p>We can now draw basic shapes in our paint program. However, we still cannot change the colors of these shapes. Before we allow users to change colors, we must provide a way for them to select colors.</p>
<p>We will, therefore, provide a color chooser, letting the user select two different colors: the foreground color and the background color.</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="189" src="assets/54e3e6b6-85b9-4f36-ac1e-50396b64626c.png" width="427"/></div>
<p>While we are at it, let's also add a label showing the <em>x</em>, <em>y</em> coordinate of the mouse over the canvas, as highlighted in the preceding screenshot.</p>
<p>Let's begin with the color palette. The two color palettes are nothing but two small rectangle items placed on a canvas. To show these two rectangles, we define a method, <kbd>create_color_palette</kbd> and call it from the existing <kbd>create_gui</kbd> method.</p>
<p>The code for <kbd>create_color_palette</kbd> is as follows (see code <kbd>6.05.py</kbd>):</p>
<pre>def create_color_palette(self):<br/>  self.color_palette = Canvas(self.tool_bar, height=55, width=55)<br/>  self.color_palette.grid(row=10, column=1, columnspan=2, pady=5, padx=3)<br/>  self.background_palette = self.color_palette.create_rectangle( 15, <br/>    15, 48, 48,       <br/>      outline=self.background, fill=self.background)<br/>  self.foreground_palette = self.color_palette.create_rectangle(<br/>    1, 1, 33, 33, outline=self.foreground, fill=self.foreground)<br/>  self.bind_color_palette()</pre>
<p>The method ends by calling a method named <kbd>bind_color_palette</kbd>, which is defined as follows (see code <kbd>6.05.py</kbd>):</p>
<pre>def bind_color_palette(self):<br/>   self.color_palette.tag_bind(self.background_palette, <br/>                              "&lt;Button-1&gt;", self.set_background_color)<br/>   self.color_palette.tag_bind(self.foreground_palette, <br/>                              "&lt;Button-1&gt;", self.set_foreground_color)</pre>
<p>The preceding code simply binds the mouse click to two not yet defined methods, <kbd>set_background_color</kbd>, and <kbd>set_foreground_color</kbd>, using the <kbd>tag_bind</kbd> method of the Canvas widget.</p>
<p>Here's the signature of the <kbd>tag_bind</kbd> method:</p>
<pre>tag_bind(item, event=None, callback, add=None)</pre>
<p>The method adds an event binding to all matching items. Note that the bindings apply to the items, not the tag. For example, if you add the existing tag to new items after a call to <kbd>tag_bind,</kbd> the new items will not automatically bind to the event.</p>
<p>Next, let's define the method that actually opens a color picker and sets the foreground and background colors based on user-selected colors.</p>
<p>Tkinter comes with a built-in <kbd>colorchooser</kbd> module that we import into our namespace as follows (see code <kbd>6.06.py</kbd>):</p>
<pre>from tkinter import colorchooser</pre>
<p>To open a color chooser, we need to call its <kbd>askcolor</kbd> method, as shown here:</p>
<pre>def get_color_from_chooser(self, initial_color, color_type="a"):<br/>  color = colorchooser.<strong>askcolor</strong>(color=initial_color, title="select {}            <br/>                                    color".format(color_type))[-1]<br/>  if color:<br/>    return color<br/>  else:  # dialog has been cancelled<br/>    return initial_color</pre>
<p>Upon clicking <span class="packt_screen">OK</span>, the color chooser returns a tuple of the form: </p>
<pre>((217.84765625, 12.046875, 217.84765625), '#d90cd9') </pre>
<p>Where the first item of the tuple is another tuple comprising the RGB values of the chosen color and the last item of the tuple represents the hexadecimal color code of the chosen color, if the <span class="packt_screen">Cancel</span> button is clicked, it returns <kbd>None</kbd>.</p>
<p>We then use the preceding method to set the foreground and background colors as follows:</p>
<pre>def set_foreground_color(self, event=None):<br/>  self.foreground = self.get_color_from_chooser(self.foreground, <br/>    "foreground")<br/>  self.color_palette.itemconfig(self.foreground_palette, width=0, <br/>    fill=self.foreground)<br/> <br/>def set_background_color(self, event=None):<br/>  self.background = self.get_color_from_chooser( self.background,  <br/>    "background")<br/>  self.color_palette.itemconfig(self.background_palette, width=0, <br/>    fill=self.background)</pre>
<p>This concludes coding the color chooser for our paint program. However, note that the colors you choose will simply change the value of the foreground and background attributes. It will not change the color of items drawn on the canvas. We will do that in a separate iteration.</p>
<p>Finally, let's define the methods that show the current mouse position in a label.</p>
<p>We create two new methods (see code <kbd>6.05.py</kbd>):</p>
<pre>def create_current_coordinate_label(self):<br/>  self.current_coordinate_label = Label(self.tool_bar, text='x:0\ny: 0 ')<br/>  self.current_coordinate_label.grid( row=13, column=1, columnspan=2, <br/>    pady=5, padx=1, sticky='w')<br/> <br/>def show_current_coordinates(self, event=None):<br/>  x_coordinate = event.x<br/>  y_coordinate = event.y<br/>  coordinate_string = "x:{0}\ny:{1}".format(x_coordinate, y_coordinate)<br/>  self.current_coordinate_label.config(text=coordinate_string)</pre>
<p>And we call the <kbd>show_current_coordinates</kbd> from our existing <kbd>on_mouse_unpressed_motion</kbd> method as follows (see code <kbd>6.05.py</kbd>): </p>
<pre>def on_mouse_unpressed_motion(self, event):<br/> self.show_current_coordinates(event)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding top bar options for draw methods</h1>
                </header>
            
            <article>
                
<p>Each of the 16 toolbar buttons can have its own option. Just like we called the functions related to the toolbar buttons dynamically, we will again call methods to display options for the top bar dynamically.</p>
<p>So we decide that the method for handling the top bar options would be named by appending the string <kbd>_options</kbd> to the existing method.</p>
<p>Suppose we want to display the options for the <kbd>draw_line</kbd> method, it would be defined in the method called <kbd>draw_line_options</kbd>. Similarly, we have to define methods such as <kbd>draw_arc_options</kbd>, <kbd>draw_star_options</kbd>, and others.</p>
<p>We achieve this dynamic call in the <kbd>display_options_in_the_top_bar</kbd> method as follows (see code <kbd>6.06.py</kbd>):</p>
<pre>def display_options_in_the_top_bar(self):<br/>  self.show_selected_tool_icon_in_top_bar(self.selected_tool_bar_function)<br/>  options_function_name = <br/>    "{}_options".format(self.selected_tool_bar_function)<br/>  func = getattr(self, options_function_name, self.function_not_defined)<br/>  func()</pre>
<p>Now, with that code in place, every time a toolbar button is clicked the program will look for a method named by appending the <kbd>_options</kbd> string to the current method related to the button. If it finds one, it will be executed. If not found, the fallback function <kbd>function_not_defined</kbd> will be called, which is an empty method to silently ignore the absence of a method.</p>
<p>The Canvas widget lets you specify the fill color, outline color, and border width for most shapes as their configurable options.</p>
<p>In addition to these, the Canvas widget also has several other configurable options for many of these basic shapes. For instance, for a line, you can specify whether it will have an arrowhead shape at the end or it will be dashed.</p>
<p>We need to display the following top options for the first six buttons:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/6f0f28f9-1107-41cd-9a4b-da0391babbc5.png"/></div>
<p>As can be seen, we need to create Combobox widgets for fill, outline, width, arrow, and dash. We first import the <kbd>ttk</kbd> module into our namespace and then create the Combobox widget as shown in the following code (see code <kbd>6.06.py</kbd>):</p>
<pre>def create_fill_options_combobox(self):<br/>  Label(self.top_bar, text='Fill:').pack(side="left")<br/>  self.fill_combobox = ttk.Combobox(self.top_bar, state='readonly', <br/>    width=5)<br/>  self.fill_combobox.pack(side="left")<br/>  self.fill_combobox['values'] = ('none', 'fg', 'bg', 'black', 'white')<br/>  self.fill_combobox.bind('&lt;&lt;ComboboxSelected&gt;&gt;', self.set_fill)<br/>  self.fill_combobox.set(self.fill)</pre>
<p>The ttk Combobox widget binds to another method called <kbd>set_fill</kbd>, which is defined as follows (<kbd>6.06.py</kbd>): </p>
<pre>def set_fill(self, event=None):<br/>  fill_color = self.fill_combobox.get()<br/>  if fill_color == 'none':<br/>    self.fill = '' # transparent<br/>  elif fill_color == 'fg':<br/>    self.fill = self.foreground<br/>  elif fill_color == 'bg':<br/>   self.fill = self.background<br/>  else:<br/>   self.fill = fill_color</pre>
<p>We define a similar <kbd>combobox</kbd> for the <kbd>width</kbd>, <kbd>outline</kbd>, <kbd>arrow</kbd>, and <kbd>dash</kbd> properties. We also define a <kbd>combobox</kbd> to allow the user to change the number of spokes in the star. </p>
<p>Since the code for all these methods is pretty similar to the code we have just discussed, we do not explore it here (<kbd>6.06.py</kbd>)<em>.</em><br/>
Finally, we add the required comboboxes to each of the six options methods as follows:</p>
<pre>def draw_line_options(self):<br/>  self.create_fill_options_combobox()<br/>  self.create_width_options_combobox()<br/>  self.create_arrow_options_combobox()<br/>  self.create_dash_options_combobox() </pre>
<p>There's similar code for all the other five toolbar buttons (see code <kbd>6.06.py</kbd>).</p>
<p>Now, if you run code <kbd>6.06.py</kbd>, it should display options for the first six buttons.</p>
<p>When you change the options, the change is reflected in all subsequent drawings on the canvas.</p>
<p>However, there is a small bug in our code. What if someone has chosen the fill color as the foreground color? And then they change the foreground color from the color palette. Although this changes the value of the foreground attribute, it does not change the value of the fill attribute. Our program will keep using the old foreground value for fill.</p>
<p>In order to fix this bug, we modify the code for <kbd>set_background_color</kbd> and <kbd>set_foreground_color</kbd> to call two new methods:</p>
<pre>def try_to_set_fill_after_palette_change(self):<br/>  try:<br/>    self.set_fill()<br/>  except:<br/>    pass<br/> <br/>def try_to_set_outline_after_palette_change(self):<br/>  try:<br/>   self.set_outline()<br/>  except:<br/>   pass<br/> </pre>
<p>The two methods are kept in a <kbd>try…except</kbd> block because not every toolbar button will have a fill and outline options <kbd>combobox</kbd>. Even if a toolbar button has the fill or outline <kbd>combobox</kbd>, it may not be selected to use the foreground or background color.</p>
<p>Lastly, since we want the <kbd>draw_line</kbd> options to populate the top bar immediately when the program starts, we add the following two lines to the <kbd>create_gui</kbd> method (see the <kbd>6.06.py</kbd> code):</p>
<pre>self.show_selected_tool_icon_in_top_bar("draw_line")<br/>self.draw_line_options() </pre>
<p>This concludes this iteration. We will add functionality to a few other toolbar buttons in the next iteration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Drawing irregular lines and super shapes</h1>
                </header>
            
            <article>
                
<p>Let's now add the capability to draw irregular or continuous free-flowing lines. We will also add the ability to draw a variety of interesting shapes on the drawing canvas, as shown here:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="303" src="assets/ba682999-dcd5-4bab-9997-8d476a59be74.png" width="559"/></div>
<p>As a reminder, all our buttons are linked to dynamically call functions defined in our <kbd>tool_bar_functions</kbd> tuple. Furthermore, we can specify unique options for a given function by adding the <kbd>_options</kbd> string to the function name.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Drawing irregular lines</h1>
                </header>
            
            <article>
                
<p>To add the capability to draw irregular lines, we just need to define the method named <kbd>draw_irregular_line</kbd>. To specify options that appear in the top bar, we need to define the method named <kbd>draw_irregular_line_options</kbd>.</p>
<p>We define the <kbd>draw_irregular_line</kbd> method as follows (see code <kbd>6.07.py</kbd>):</p>
<pre>def draw_irregular_line(self):<br/> self.current_item = self.canvas.create_line(<br/>   self.start_x, self.start_y, self.end_x, self.end_y, fill=self.fill, <br/>     width=self.width)<br/> self.canvas.bind("&lt;B1-Motion&gt;", self.draw_irregular_line_update_x_y)<br/><br/>def draw_irregular_line_update_x_y(self, event=None):<br/> self.start_x, self.start_y = self.end_x, self.end_y<br/> self.end_x, self.end_y = event.x, event.y<br/> self.draw_irregular_line()</pre>
<p>The preceding code is similar to the code for <kbd>draw_line</kbd>, except that it adds an extra line that binds mouse-clicked movements to a new method that replaces the start <em>x</em>, <em>y</em> coordinates with the end <em>x</em>, <em>y</em> coordinates and again calls back the <kbd>draw_irregular_line</kbd> method, thereby drawing in a continuous manner.</p>
<p>The options that show in the top bar are defined using the following method (see code <kbd>6.07.py</kbd>):</p>
<pre>def draw_irregular_line_options(self):<br/>  self.create_fill_options_combobox()<br/>  self.create_width_options_combobox() </pre>
<p>Now we can draw irregular lines on the canvas. However, since we have modified the mouse binding, all other methods will also start to draw in a continuous manner. </p>
<p>We, therefore, need to rebind the buttons back to their original bindings. We do that by modifying <kbd>on_tool_bar_button_clicked</kbd> to call <kbd>bind_mouse</kbd>, which then restores the mouse binding to its original behavior.</p>
<div class="packt_infobox">Adding an event binding to more than one method wipes away the previous binding, whereby the new binding replaces any existing binding.<br/>
Alternatively, you can use <kbd>add="+"</kbd> as an additional argument to keep more than one binding to the same event, as follows:<br/>
<kbd>mywidget.bind("&lt;SomeEvent&gt;", method1, add="+")</kbd><br/>
<kbd>mywidget.bind("&lt;SameEvent&gt;", method2, add="+")</kbd></div>
<p>This will bind the same event to <kbd>method1</kbd> and <kbd>method2</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Drawing super shapes</h1>
                </header>
            
            <article>
                
<p>We call these shapes super shapes because we can build many interesting shapes using a single mathematical formula called <strong>Super Formula</strong>. See <a href="https://en.wikipedia.org/wiki/Superformula">https://en.wikipedia.org/wiki/Superformula</a> for more details on the formula.</p>
<p>The super formula takes six input arguments: <kbd>a</kbd>, <kbd>b</kbd>, <kbd>m</kbd>, <kbd>n1</kbd>, <kbd>n2</kbd>, and <kbd>n3</kbd>. Varying these five arguments produces varied shapes found in nature such as the shapes of shells, starfish, flowers, and more.</p>
<p>We do not get into why or how this formula works. All we do is write a method that, given these five arguments, returns the coordinates for unique shapes. We then pass these coordinates to our <kbd>create_polygon</kbd> method to create these shapes on the canvas. The method that returns these points is defined as follows (see code <kbd>6.07.py</kbd>):</p>
<pre>def get_super_shape_points(self, a, b, m, n1, n2, n3):<br/>  # https://en.wikipedia.org/wiki/Superformula<br/>  points = []<br/>  for i in self.float_range(0, 2 * math.pi, 0.01):<br/>   raux = (abs(1 / a * abs(math.cos(m * i / 4))) ** n2 + \<br/>           abs(1 / b * abs(math.sin(m * i / 4))) ** n3)<br/>   r = abs(raux) ** (-1 / n1)<br/>   x = self.end_x + r * math.cos(i)<br/>   y = self.end_y + r * math.sin(i)<br/>   points.extend((x, y))<br/>return points</pre>
<p>The method uses a custom-defined <kbd>float_range</kbd> method, since Python's built-in range method does not allow for float step sizes. The <kbd>float_range</kbd> generator method is defined as follows:</p>
<pre>def float_range(self, x, y, step):<br/>  while x &lt; y:<br/>   yield x<br/>   x += step</pre>
<p>Next, we define the <kbd>draw_super_shape</kbd> method, which creates a polygon with the calculated points (see code <kbd>6.07.py</kbd>):</p>
<pre>def draw_super_shape(self):<br/>  points = self.get_super_shape_points <br/>    (*super_shapes[self.selected_super_shape])<br/>  self.current_item = self.canvas.create_polygon(points, <br/>    outline=self.outline,  <br/>      fill=self.fill, width=self.width)</pre>
<p>Now we want to provide a different set of five parameters to the super formula. We define a new file named <kbd>supershapes.py</kbd> with a dictionary named <kbd>super_shapes</kbd><em> </em><em>with</em> different shapes represented by a shape name and five parameters as follows:</p>
<pre>super_shapes = {<br/> "shape A": (1.5, 1.5, 5, 2, 7, 7),<br/> "shape B": (1.5, 1.5, 3, 5, 18, 18),<br/> "shape C": (1.4, 1.4, 4, 2, 4, 13),<br/> "shape D": (1.6, 1.6, 7, 3, 4, 17),<br/> "shape E": (1.9, 1.9, 7, 3, 6, 6),<br/> "shape F": (4, 4, 19, 9, 14, 11),<br/> "shape G": (12, 12, 1, 15, 20, 3),<br/> "shape H": (1.5, 1.5, 8, 1, 1, 8),<br/> "shape I": (1.2, 1.2, 8, 1, 5, 8),<br/> "shape J": (8, 8, 3, 6, 6, 6),<br/> "shape K": (8, 8, 2, 1, 1, 1),<br/> "shape L": (1.1, 1.1, 16, 0.5, 0.5, 16)<br/> }</pre>
<p>We also define an attribute (see code <kbd>6.07.py</kbd>):</p>
<pre>selected_super_shape = "shape A" </pre>
<p>Next, we define a <kbd>combobox</kbd> to let the user select from among the shapes defined previously (<kbd>6.07.py</kbd>): </p>
<pre>def create_super_shapes_options_combobox(self):<br/>  Label(self.top_bar, text='Select shape:').pack(side="left")<br/>  self.super_shape_combobox = ttk.Combobox(self.top_bar, <br/>    state='readonly', width=8)<br/>  self.super_shape_combobox.pack(side="left")<br/>  self.super_shape_combobox['values'] = sorted(tuple(shape for shape in  <br/>    super_shapes.keys()))<br/>  self.super_shape_combobox.bind('&lt;&lt;ComboboxSelected&gt;&gt;', <br/>    self.set_selected_super_shape)<br/>  self.super_shape_combobox.set(self.selected_super_shape)</pre>
<p>And we define a method that sets the selected shape for the value of <kbd>selected_super_shape</kbd> (see code <kbd>6.07.py</kbd>):</p>
<pre>def set_selected_super_shape(self, event=None):<br/>  self.selected_super_shape = self.super_shape_combobox.get()</pre>
<p>Finally, we define the <kbd>draw_super_shapes_options</kbd> that shows all of the options we want to show in the top option bar (see code <kbd>6.07.py</kbd>):</p>
<pre>def draw_super_shape_options(self):<br/>  self.create_super_shapes_options_combobox()<br/>  self.create_fill_options_combobox()<br/>  self.create_outline_options_combobox()<br/>  self.create_width_options_combobox()</pre>
<p>This concludes the iteration. You can now run <kbd><em>6.07.py</em></kbd> and draw irregular lines as well as all of the super shapes that we have defined in the <kbd>supershapes.py</kbd> file. In fact, you can extend the <kbd>super_shapes</kbd> dictionary to add many more shapes simply by changing the values for the five parameters. You can look at <a href="https://en.wikipedia.org/wiki/Superformula">https://en.wikipedia.org/wiki/Superformula</a> for values of parameters that create interesting shapes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding functionality to the remaining buttons</h1>
                </header>
            
            <article>
                
<p><br/>
We will now code the features related to the remaining toolbar buttons:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/06165595-3c77-46e0-814f-956f4ac6326d.png"/></div>
<p>Specifically, we will code the following functions: <kbd>draw_text</kbd>, <kbd>delete_item</kbd>, <kbd>fill_item</kbd>, <kbd>duplicate_item</kbd>, <kbd>move_to_top</kbd>, <kbd>drag_item</kbd>, <kbd>enlarge_item_size</kbd>, and <kbd>reduce_item_size</kbd>.</p>
<p>Let's start with the code for <kbd>draw_text</kbd>. When a user clicks on the <kbd>draw_text</kbd> button, we want to show the following options in the top bar:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/7f2e7aeb-8e78-4705-bf80-ea7f455c42a6.png"/></div>
<p>The user can enter text in the textbox and specify its font size and fill color. Once the user presses the <span class="packt_screen">Go</span> button, the text appears on the center of the canvas.</p>
<p>Let us, therefore, define the <kbd>draw_text_options</kbd> method as follows (see code <kbd>6.08.py</kbd>):</p>
<pre>def draw_text_options(self):<br/>  Label(self.top_bar, text='Text:').pack(side="left")<br/>  self.text_entry_widget = Entry(self.top_bar, width=20)<br/>  self.text_entry_widget.pack(side="left")<br/>  Label(self.top_bar, text='Font size:').pack(side="left")<br/>  self.font_size_spinbox = Spinbox(self.top_bar, from_=14, to=100, width=3)<br/>  self.font_size_spinbox.pack(side="left")<br/>  self.create_fill_options_combobox()<br/>  self.create_text_button = Button(self.top_bar,                  <br/>    text="Go", command=self.on_create_text_button_clicked)<br/>  self.create_text_button.pack(side="left", padx=5)</pre>
<p>The preceding code is self-explanatory. The <span class="packt_screen">Go</span> button is attached to a command callback named <kbd>on_create_text_button_clicked</kbd>, which is defined as follows <span>(see code </span><kbd>6.08.py</kbd><span>)</span>: </p>
<pre>def on_create_text_button_clicked(self):<br/>  entered_text = self.text_entry_widget.get()<br/>  center_x = self.canvas.winfo_width()/2<br/>  center_y = self.canvas.winfo_height()/2<br/>  font_size = self.font_size_spinbox.get()<br/>  self.canvas.create_text(center_x, center_y, font=("", font_size),   <br/>    text=entered_text, fill=self.fill)</pre>
<p>Our <kbd>draw_text</kbd> method is now functional. Next, let's code the <kbd>delete_item</kbd> method.</p>
<p>The operations that we want to do now are slightly different from their predecessors. Earlier, we were creating items on the canvas. Now we have to target items already present on the canvas.</p>
<p>The item that needs to be targeted is the one on which the user clicks with their mouse. Fortunately, getting the item handle for the item under the mouse is very easy using the current tag.</p>
<p>Accordingly, the code for <kbd>delete_item</kbd> is as follows (see code <kbd>6.08.py</kbd>):</p>
<pre>def delete_item(self):<br/>  self.current_item = None<br/>  self.canvas.delete("current") </pre>
<p>Now, if you select the <span class="packt_screen">Delete</span> button from the toolbar and click on any item on the canvas, that item is deleted.</p>
<p>Next, let's code the <kbd>fill_item</kbd> and <kbd>fill_item_options</kbd> methods (see code <kbd>6.08.py</kbd>):</p>
<pre>def fill_item(self):<br/>  try:<br/>    self.canvas.itemconfig("current", fill=self.fill, outline=self.outline)<br/>  except TclError:<br/>     self.canvas.itemconfig("current", fill=self.fill)</pre>
<p>We had to use a <kbd>try…except</kbd> block because some canvas items such as lines and text do not have an outline option:</p>
<pre>def fill_item_options(self):<br/>  self.create_fill_options_combobox()<br/>  self.create_outline_options_combobox()</pre>
<p>Next, we code the <kbd>duplicate_item</kbd> method. In order to duplicate an item we need to know three things:</p>
<ul>
<li>Type of item—if the item is a <kbd>line</kbd><span>, </span><kbd>oval</kbd><span>, </span><kbd>arc</kbd><span>, </span><kbd>rectangle</kbd><span>, or </span><kbd>polygon</kbd></li>
<li>The coordinates for the item</li>
<li>The configurations of the item</li>
</ul>
<p>We can get the type of item as a string using the type method as follows: <kbd>canvas.type(item_specifier)</kbd></p>
<p>This returns a string such as <kbd>line</kbd>, <kbd>oval</kbd>, <kbd>arc</kbd>, <kbd>rectangle</kbd>, or <kbd>polygon</kbd>. In order to recreate an item of the same type, we need to append the string <kbd>create_</kbd> to the returned type and call the method.</p>
<p>The coordinates of a given item can be obtained by calling the coordinates method as follows: </p>
<div><kbd><kbd>coordinates = canvas.coords("item_specifier")</kbd></kbd></div>
<p>The configurations for an item can be obtained as a dictionary using the following command: </p>
<div><kbd>canvas.itemconfig(item_specifier)</kbd></div>
<p>This returns all the configurations for an item, whether specified or not specified. For example, here's a sample of a dictionary returned by calling the preceding method on a canvas item:</p>
<pre>{'outline': ('outline', '', '', 'black', 'red'), 'outlinestipple':<br/> ('outlinestipple', '', '', '', ''), 'activestipple':<br/> ('activestipple', '', '', '', ''), 'state': ('state', '', '',<br/> '', ''), 'offset': ('offset', '', '', '0,0', '0,0'),<br/> 'activefill': ('activefill', '', '', '', ''), 'disabledwidth':<br/> ('disabledwidth', '', '', '0.0', '0'), 'disabledoutlinestipple':<br/> ('disabledoutlinestipple', '', '', '', ''), 'outlineoffset':<br/> ('outlineoffset', '', '', '0,0', '0,0'), 'width': ('width', '',<br/> '', '1.0', '2.0'), 'disabledfill': ('disabledfill', '', '', '',<br/> ''), 'disabledoutline': ('disabledoutline', '', '', '', ''),<br/> 'dash': ('dash', '', '', '', ''), 'disableddash':<br/> ('disableddash', '', '', '', ''), 'disabledstipple':<br/> ('disabledstipple', '', '', '', ''), 'tags': ('tags', '', '',<br/> '', 'current'), 'stipple': ('stipple', '', '', '', ''),<br/> 'activewidth': ('activewidth', '', '', '0.0', '0.0'),<br/> 'activedash': ('activedash', '', '', '', ''), 'dashoffset':<br/> ('dashoffset', '', '', '0', '0'), 'activeoutlinestipple':<br/> ('activeoutlinestipple', '', '', '', ''), 'activeoutline':<br/> ('activeoutline', '', '', '', ''), 'fill': ('fill', '', '', '',<br/> 'red')}</pre>
<p>Clearly, we do not require those configuration values that are empty or zero. We, therefore, write a method that filters out all unnecessary configurations:</p>
<pre>def get_all_configurations_for_item(self):<br/>  configuration_dict = {}<br/>  for key, value in self.canvas.itemconfig("current").items():<br/>      if value[-1] and value[-1] not in ["0", "0.0", "0,0", "current"]:<br/>         configuration_dict[key] = value[-1]<br/> return configuration_dict</pre>
<p class="mce-root">Now that we know how to fetch all required elements to duplicate a canvas item, here's the code for <kbd>duplicate_item</kbd> (see code <kbd>6.08.py</kbd>):</p>
<pre>def duplicate_item(self):<br/>  try:<br/>     function_name = "create_" + self.canvas.type("current")<br/>  except TypeError:<br/>     return<br/>  coordinates = tuple(map(lambda i: i+10, self.canvas.coords("current")))<br/>  configurations = self.get_all_configurations_for_item()<br/>   self.canvas_function_wrapper(function_name, coordinates, configurations)</pre>
<p>Finally, the last line calls a <kbd>wrapper</kbd> function that actually runs the function that duplicates the canvas item (see code <kbd>6.08.py</kbd>):</p>
<pre>def canvas_function_wrapper(self, function_name, *arg, **kwargs):<br/>  func = getattr(self.canvas, function_name)<br/>  func(*arg, **kwargs) </pre>
<p>Now, if you create an item, select the <span class="packt_screen">duplicate item</span> button, and click on the item, a duplicate item is created. However, since we do not want the duplicate item to be created exactly on top of the existing item, we offset its coordinates by <kbd>10</kbd> pixels from the coordinates of the item being duplicated. This offsetting is done in the line:</p>
<pre>coordinates = tuple(map(lambda i: i+10, self.canvas.coords("current")))</pre>
<p>Now, if you create an item on the canvas, select the <span class="packt_screen">duplicate item</span> button, and click on the item, its duplicate is created at an offset of <kbd>10</kbd> pixels from the original item.</p>
<p>Next, we code the <kbd>move_to_top</kbd> method. We have already discussed that items added to the canvas are added on top of each other. What if we want to move an item previously added to the canvas? The following figure shows what it means to move an item on top of another:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="83" src="assets/c7f21151-ab49-479a-b1f3-632fe00dc550.png" width="200"/></div>
<p>We use the <kbd>tag_raise</kbd> and <kbd>tag_lower</kbd> methods to move items higher and lower in the stack. We use <kbd>tag_raise</kbd> to define the <kbd>move_to_top</kbd> method as follows (see code <kbd>6.08.py</kbd>):</p>
<pre>def move_to_top(self):<br/>  self.current_item = None<br/>  self.canvas.tag_raise("current")</pre>
<p>The preceding code raises the clicked item highest up in the item's stack.</p>
<div class="packt_infobox">When you draw multiple items on the canvas, the items are placed in a stack. By default, new items get added on top of items previously drawn on the canvas. You can, however, change the stacking order using:<br/>
<kbd>canvas.tag_raise(item)</kbd>.<br/>
If multiple items match, they are all moved, with their relative order preserved. However, this method will not change the stacking order for any new window item that you draw within the canvas.<br/>
Then there are the <kbd>find_above</kbd> and <kbd>find_below</kbd> methods that you can use to find items above or below an item in the canvas stacking order.</div>
<p>Next, we will define the <kbd>drag_item</kbd> method. This method uses the move method to change the coordinates of a given item (see code <kbd>6.08.py</kbd>):</p>
<pre>def drag_item(self):<br/> self.canvas.move("current", self.end_x - self.start_x, self.end_y -  self.start_y)<br/> self.canvas.bind("&lt;B1-Motion&gt;", self.drag_item_update_x_y)<br/><br/>def drag_item_update_x_y(self, event):<br/> self.start_x, self.start_y = self.end_x, self.end_y<br/> self.end_x, self.end_y = event.x, event.y<br/> self.drag_item()</pre>
<p class="mce-root">Since we want the drag to occur continuously and not as a jump from one place to another, we temporarily bind the mouse binding to update the start and end coordinates like we did when we defined the <kbd>draw_irregular_line</kbd> method.</p>
<p class="mce-root">Finally, we define two methods to enlarge and reduce item size. We will use the <kbd>canvas.scale</kbd> method to increase and reduce item size by 20%:</p>
<pre>def enlarge_item_size(self):<br/>  self.current_item = None<br/>  if self.canvas.find_withtag("current"):<br/>    self.canvas.scale("current", self.end_x, self.end_y, 1.2, 1.2)<br/>    self.canvas.config(scrollregion=self.canvas.bbox(tk.ALL))<br/><br/>def reduce_item_size(self):<br/>  self.current_item = None<br/>  if self.canvas.find_withtag("current"):<br/>    self.canvas.scale("current", self.end_x, self.end_y, .8, .8)<br/>    self.canvas.config(scrollregion=self.canvas.bbox(tk.ALL))</pre>
<p>Note that, immediately upon item resize, we reconfigure the scroll region option to update the scroll bar.</p>
<div class="packt_infobox">The <kbd>bbox</kbd> method returns the bounding box for an item. The syntax is:  <kbd>.canvas.bbox(item_specifier)</kbd>. This returns the bounding box as a tuple of length 4. If the item-specifier is omitted, the bounding box for all items is returned.</div>
<p>Note that bounding box values are approximate and may differ from the real value by a few pixels.</p>
<p>This concludes the iteration. All the buttons in the left toolbar are now functional (see code <kbd>6.08.py</kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding functionality to menu items</h1>
                </header>
            
            <article>
                
<p>Recall that, at the time of creating our menu using the <kbd>Framework</kbd> class, we created empty methods that were linked to our menu items. We will now modify those empty methods to make them functional (see code <kbd>6.09.py</kbd> )</p>
<p><span class="packt_screen">File</span> | <span class="packt_screen">New Menu</span>:</p>
<p>The canvas delete method can be used to delete an item, given an item-specifier. Here we use <kbd>ALL</kbd> to delete all items from the canvas:</p>
<pre>def on_new_file_menu_clicked(self, event=None):<br/>  self.start_new_project()<br/><br/>def start_new_project(self):<br/>  self.canvas.delete(ALL)<br/>  self.canvas.config(bg="#ffffff")<br/>  self.root.title('untitled')</pre>
<p><span class="packt_screen">File</span> | <span class="packt_screen">Save</span>, <span class="packt_screen">File</span> | <span class="packt_screen">Save As</span>:</p>
<p>Tkinter lets you save canvas objects as a postscript file using the command <kbd>postscript()</kbd>. Note, however, that the resulting postscript file cannot save images or any widgets embedded on the canvas. Furthermore, note that the pickling of Tkinter widgets or saving to <kbd>.jpg</kbd> or <kbd>.png</kbd> formats is not possible. This is one of the major limitations of Tkinter.</p>
<p>Here's the code for the save and save as features (see code <kbd>6.09.py</kbd>): </p>
<pre>def actual_save(self):<br/>  self.canvas.postscript(file=self.file_name, colormode='color')<br/>  self.root.title(self.file_name)</pre>
<p>We do not discuss the <span class="packt_screen">Close</span> and <span class="packt_screen">About</span> menu as we have coded similar menus in all our previous projects <span>(see code </span><kbd>6.09.py</kbd><span>)</span>. </p>
<p><span class="packt_screen">Edit</span> | <span class="packt_screen">Undo</span>:</p>
<p>Recall that all items added to the canvas are stored in a stack. We can access the stack using the canvas command:</p>
<pre>canvas.find("all") </pre>
<p>Using this, we implement a very basic undo operation, which lets us delete the last drawn item on the canvas.</p>
<p>Accordingly, the code for adding the undo feature is as follows (see code <kbd>6.09.py</kbd>):</p>
<pre>def on_undo_menu_clicked(self, event=None):<br/>   self.undo()<br/><br/>def undo(self):<br/>  items_stack = list(self.canvas.find("all"))<br/>  try:<br/>    last_item_id = items_stack.pop()<br/>  except IndexError:<br/>    return<br/>  self.canvas.delete(last_item_id)<br/> </pre>
<p>Note that this will not undo any styling changes such as changes in color, width, outline, and so on. In fact, it will only be able to delete the last item from the stack.</p>
<p>We can implement a fully-fledged undo stack by saving all actions in a suitable data structure, but that would be an exercise worth its own chapter.</p>
<p>In addition to the find method we used here, the Canvas widget has a method named:</p>
<pre>find_closest(x, y, halo=None, start=None) </pre>
<p>It returns the item handle for the item closest to the given position on the canvas. This means that if there is only one item on the canvas, it will be selected regardless of how near or how far you click from it.</p>
<p>If, on the other hand, you want objects only within a certain area, you can use:</p>
<pre>find_overlapping(x1, y1, x2, y2) </pre>
<p>This returns all items that overlap the given rectangle, or that are completely enclosed by it. </p>
<p>Now that we have a hold on the item to be manipulated, we can proceed to do whatever we want with the item.<br/>
For a complete list of canvas methods, please see <a href="http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/canvas-methods.html">http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/canvas-methods.html</a>.<br/>
<span class="packt_screen">View</span> | <span class="packt_screen">Zoom in</span>, <span class="packt_screen">View</span> | <span class="packt_screen">Zoom out</span>:</p>
<p>Finally, we define these two methods using the <kbd>canvas.scale</kbd> method. We have already used the scale methods earlier to enlarge and reduce individual items. Here, we simply use the method on the <kbd>ALL</kbd> item-specifier, as in the following code <span>(see code </span><kbd>6.09.py</kbd><span>)</span>: </p>
<pre>def canvas_zoom_in(self):<br/>  self.canvas.scale("all", 0, 0, 1.2, 1.2)<br/>  self.canvas.config(scrollregion=self.canvas.bbox(ALL))</pre>
<p>That concludes the iteration and the chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>To summarize, in this chapter, we began by creating a custom GUI framework on top of Tkinter.</p>
<p>We saw how GUI frameworks can be used to generate boilerplate code for our programs, thereby ensuring maximum code reuse and rapid application development.</p>
<p>Next, we explored the Canvas widget in detail. We saw how to create various canvas items. Then, we saw how we could manipulate the attributes of these canvas items using tag or ID.</p>
<p>We saw the <kbd>colorchooser</kbd> module of Tkinter in action. We worked with the ttk Combobox widget. We also looked at common methods that are available on all Tkinter widgets.</p>
<p>We also saw the benefits of writing programs that use convention over configuration to ease the logical flow of the program.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QA section</h1>
                </header>
            
            <article>
                
<p>Before you proceed to the next chapter, make sure you can answer these questions to your<br/>
satisfaction:</p>
<ul>
<li><span>What are software frameworks?  Why are they used?</span></li>
<li>When is it beneficial to use software frameworks instead of writing code from scratch?</li>
<li>What is a structured markup language? Can you a list a few of them?</li>
<li>What is the convention over configuration<span> </span><span>software design paradigm?</span></li>
<li>What are tags used for in the context of  Tkinter's Canvas widget?</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p class="mce-root">Read the complete documentation for the Tkinter Canvas widget. You can find the documentation by typing the following command in a Python command shell:</p>
<pre><strong>&gt;&gt;&gt; import tkinter</strong><br/><strong>&gt;&gt;&gt;  help(tkinter.Canvas)</strong></pre>


            </article>

            
        </section>
    </body></html>