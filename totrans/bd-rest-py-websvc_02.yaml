- en: Chapter 2.  Working with Class-Based Views and Hyperlinked APIs in Django
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。在Django中使用基于类的视图和超链接API工作
- en: 'In this chapter, we will expand the capabilities of the RESTful API that we
    started in the previous chapter. We will change the ORM settings to work with
    a more powerful PostgreSQL database and we will take advantage of the advanced
    features included in Django REST Framework that allow us to reduce the boilerplate
    code for complex APIs, such as class-based views. We will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将扩展我们在上一章中开始的RESTful API的功能。我们将更改ORM设置以使用更强大的PostgreSQL数据库，并利用Django
    REST Framework中包含的先进功能，这些功能允许我们减少复杂API（如基于类的视图）的样板代码。我们将：
- en: Use model serializers to eliminate duplicate code
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型序列化器来消除重复代码
- en: Work with wrappers to write API views
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包装器编写API视图
- en: Use the default parsing and rendering options and move beyond JSON
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认解析和渲染选项，并超越JSON
- en: Browse the API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览API
- en: Design a RESTful API to interact with a complex PostgreSQL database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个RESTful API以与复杂的PostgreSQL数据库交互
- en: Understand the tasks performed by each `HTTP` method
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解每个`HTTP`方法执行的任务
- en: Declare relationships with the models
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明与模型的关系
- en: Manage serialization and deserialization with relationships and hyperlinks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用关系和超链接管理序列化和反序列化
- en: Create class based views and use generic classes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基于类的视图并使用通用类
- en: Work with endpoints for the API
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与API端点一起工作
- en: Create and retrieve related resources
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和检索相关资源
- en: Using model serializers to eliminate duplicate code
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模型序列化器来消除重复代码
- en: The `GameSerializer` class declares many attributes with the same names that
    we used in the `Game` model and repeats information, such as the types and the
    `max_length` values. The `GameSerializer` class is a subclass of `rest_framework.serializers.Serializer`,
    it declares attributes that we manually mapped to the appropriate types and overrides
    the `create` and `update` methods.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameSerializer`类声明了许多与我们在`Game`模型中使用的相同名称的属性，并重复了信息，例如类型和`max_length`值。`GameSerializer`类是`rest_framework.serializers.Serializer`的子类，它声明了我们将手动映射到适当类型的属性，并重写了`create`和`update`方法。'
- en: Now, we will create a new version of the `GameSerializer` class that will inherit
    from the `rest_framework.serializers.ModelSerializer` class. The `ModelSerializer`
    class automatically populates both set of default fields and a set of default
    validators. In addition, the class provides default implementations for the `create`
    and `update` methods.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个新版本的`GameSerializer`类，该类将继承自`rest_framework.serializers.ModelSerializer`类。`ModelSerializer`类自动填充了一组默认字段和一组默认验证器。此外，该类还为`create`和`update`方法提供了默认实现。
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In case you have any experience with Django Web Framework, you will notice that
    the `Serializer` and `ModelSerializer` classes are similar to the `Form` and `ModelForm`
    classes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有Django Web框架的经验，你会注意到`Serializer`和`ModelSerializer`类与`Form`和`ModelForm`类相似。
- en: 'Now, go to the `gamesapi/games` folder and open the `serializers.py` file.
    Replace the code in this file with the following code, that declares the new version
    of the `GameSerializer` class. The code file for the sample is included in the
    `restful_python_chapter_02_01` folder:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前往`gamesapi/games`文件夹并打开`serializers.py`文件。将此文件中的代码替换为以下代码，该代码声明了`GameSerializer`类的新版本。示例代码文件包含在`restful_python_chapter_02_01`文件夹中：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The new `GameSerializer` class declares a `Meta` inner class that declares
    two attributes: `model` and `fields`. The `model` attribute specifies the model
    related to the serializer, that is, the `Game` class. The `fields` attribute specifies
    a tuple of string whose values indicate the field names that we want to include
    in the serialization from the related model.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`GameSerializer`类声明了一个`Meta`内部类，该类声明了两个属性：`model`和`fields`。`model`属性指定与序列化器相关的模型，即`Game`类。`fields`属性指定一个字符串元组，其值表示我们想要从相关模型中包含在序列化中的字段名称。
- en: There is no need to override either `create` or `update` methods because the
    generic behavior will be enough in this case. The `ModelSerializer` superclass
    provides implementations for both methods.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，无需重写`create`或`update`方法，因为通用行为就足够了。`ModelSerializer`超类为这两种方法提供了实现。
- en: We have reduced the boilerplate code that we didn't require in the `GameSerializer`
    class. We just needed to specify the desired set of fields in a tuple. Now, the
    types related to the game fields are included only in the `Game` class.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经减少了在 `GameSerializer` 类中不需要的样板代码。我们只需要在元组中指定所需的字段集。现在，与游戏字段相关的类型仅包含在 `Game`
    类中。
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Press *Ctrl + C* to quit Django''s development server and execute the following
    command to start it again:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 按 *Ctrl + C* 退出 Django 开发服务器，并执行以下命令重新启动它：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Working with wrappers to write API views
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用包装器编写 API 视图
- en: Our code in the `games/views.py` file declared a `JSONResponse` class and two
    function-based views. These functions returned `JSONResponse` when it was necessary
    to return JSON data and a `django.Http.Response.HttpResponse` instance when the
    response was just of an HTTP status code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `games/views.py` 文件中的代码声明了一个 `JSONResponse` 类和两个基于函数的视图。这些函数在需要返回 JSON 数据时返回
    `JSONResponse`，而在响应只是 HTTP 状态码时返回 `django.Http.Response.HttpResponse` 实例。
- en: 'No matter the accepted content type specified in the HTTP request header, the
    view functions always provide the same content in the response body-JSON. Run
    the following two commands to retrieve all the games with different values for
    the `Accept` request header-`text/html` and `application/json` :'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 无论 HTTP 请求头中指定的接受内容类型如何，视图函数始终在响应体中提供相同的内容-JSON。运行以下两个命令以检索具有不同 `Accept` 请求头值（`text/html`
    和 `application/json`）的所有游戏：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following are the equivalent curl commands:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 curl 命令：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding commands will compose and send the following HTTP request: `GET
    http://localhost:8000/games/`. The first command defines the `text/html` value
    for the `Accept` request header. The second command defines the `application/json`
    value for the `Accept` request header.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将组成并发送以下 HTTP 请求：`GET http://localhost:8000/games/`。第一个命令为 `Accept` 请求头定义了
    `text/html` 值。第二个命令为 `Accept` 请求头定义了 `application/json` 值。
- en: 'You will notice that both the commands produce the same results, and therefore,
    the view functions don''t take into account the value specified for the `Accept`
    request header in the HTTP requests. The header response for both commands will
    include the following line:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这两个命令产生了相同的结果，因此视图函数没有考虑 HTTP 请求头中指定的 `Accept` 值。这两个命令的响应头将包括以下行：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The second request specified that it will only accept `text/html` but the response
    included a JSON body, that is, `application/json` content. Thus, our first version
    of the RESTful API is not prepared to render content other from JSON. We will
    make some changes to enable the API to render other contents.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个请求指定它只接受 `text/html`，但响应中包含了 JSON 主体，即 `application/json` 内容。因此，我们的第一个版本的
    RESTful API 没有准备好渲染除 JSON 之外的内容。我们将进行一些更改，以使 API 能够渲染其他内容。
- en: Whenever we have doubts about the methods supported by a resource or resource
    collection in a RESTful API, we can compose and send an HTTP request with the
    `OPTIONS` HTTP verb and the URL for the resource or resource collection. If the
    RESTful API implements the OPTIONS HTTP verb for a resource or resource collection,
    it provides a comma-separated list of HTTP verbs or methods that it supports as
    a value for the `Allow` header in the response. In addition, the response header
    will include additional information about other supported options, such as the
    content type it is capable of parsing from the request and the content type it
    is capable of rendering on the response.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时我们对 RESTful API 中资源或资源集合支持的方法有疑问，我们都可以使用 `OPTIONS` HTTP 动词和资源或资源集合的 URL
    组成并发送 HTTP 请求。如果 RESTful API 为资源或资源集合实现了 `OPTIONS` HTTP 动词，它会在响应的 `Allow` 头中提供一个以逗号分隔的
    HTTP 动词或方法列表，作为其支持值的列表。此外，响应头还将包括有关其他支持选项的附加信息，例如它能够从请求中解析的内容类型以及它能够在响应中呈现的内容类型。
- en: 'For example, if we want to know the HTTP verbs that the games collection supports,
    we can run the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想知道游戏集合支持哪些 HTTP 动词，我们可以运行以下命令：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following is the equivalent curl command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 curl 命令：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The previous command will compose and send the following HTTP request: `OPTIONS
    http://localhost:8000/games/`. The request will match and run the `views.game_list`
    function, that is, the `game_list` function declared within the `games/views.py`
    file. This function only runs the code when the `request.method` is equal to `''GET''`
    or `''POST''`. In this case, `request.method` is equal to `''OPTIONS''`, and therefore,
    the function won''t run any code and won''t return any response, specifically,
    it won''t return an `HttpResponse` instance. As a result, we will see the following
    `Internal Server Error` listed in Django''s development server console output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送以下HTTP请求：`OPTIONS http://localhost:8000/games/`。请求将匹配并运行`views.game_list`函数，即`games/views.py`文件中声明的`game_list`函数。此函数仅在`request.method`等于`'GET'`或`'POST'`时运行代码。在这种情况下，`request.method`等于`'OPTIONS'`，因此，该函数不会运行任何代码，也不会返回任何响应，特别是，它不会返回`HttpResponse`实例。因此，我们将在Django开发服务器控制台输出中看到以下`Internal
    Server Error`：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following lines show the header for the output that also includes a detailed
    HTML document with detailed information about the error because the debug mode
    is activated for Django. We receive a `500 Internal Server Error` status code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了输出头部，其中还包括一个包含关于错误详细信息的HTML文档，因为Django的调试模式已激活。我们收到`500 Internal Server
    Error`状态码：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Obviously, we want to provide a more consistent API and we want to provide an
    accurate response when we receive a request with the `OPTIONS` verbs for either
    a game resource or the games collection.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们希望提供一个更一致的API，并且我们希望在收到对游戏资源或游戏集合的`OPTIONS`动词请求时提供准确的响应。
- en: If we compose and send an HTTP request with the `OPTIONS` verb for a game resource,
    we will see the same error and we will have a similar response because the `views.game_detail`
    function only runs the code when the `request.method` is equal to `'GET'`, `'PUT'`,
    or `'DELETE'`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`OPTIONS`动词向游戏资源发送一个HTTP请求，我们将看到相同的错误，并且会有类似的响应，因为`views.game_detail`函数仅在`request.method`等于`'GET'`、`'PUT'`或`'DELETE'`时运行代码。
- en: 'The following commands will produce the explained error when we try to see
    the options offered for the game resource whose id or primary key is equal to
    `3`. Don''t forget to replace `3` with a primary key value of an existing game
    in your configuration:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将在我们尝试查看id或主键等于`3`的游戏资源的选项时产生解释性错误。别忘了将`3`替换为你配置中现有游戏的某个主键值：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following is the equivalent curl command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的curl命令：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We just need to make a few changes in the `games/views.py` file to solve the
    issues we have been analyzing for our RESTful API. We will use the `@api_view`
    decorator, declared in `rest_framework.decorators`, for our function-based views.
    This decorator allows us to specify the HTTP verbs that our function can process.
    If the request that has to be processed by the view function has an HTTP verb
    that isn't included in the string list specified as the `http_method_names` argument
    for the `@api_view` decorator, the default behavior returns a `405 Method Not
    Allowed` status code. This way, we make sure that whenever we receive an HTTP
    verb that isn't considered within our function view, we won't generate an unexpected
    error as the decorator handles the response for the unsupported HTTP verbs or
    methods.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在`games/views.py`文件中做一些修改，以解决我们一直在分析的问题，以解决我们的RESTful API。我们将使用在`rest_framework.decorators`中声明的`@api_view`装饰器来处理基于函数的视图。此装饰器允许我们指定我们的函数可以处理的HTTP动词。如果需要由视图函数处理的请求的HTTP动词不包括在作为`@api_view`装饰器的`http_method_names`参数指定的字符串列表中，则默认行为返回`405
    Method Not Allowed`状态码。这样，我们确保每当收到不在我们的函数视图中考虑的HTTP动词时，我们不会生成意外的错误，因为装饰器处理了不受支持的HTTP动词或方法。
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Under the hoods, the `@api_view` decorator is a wrapper that converts a function-based
    views  into a subclass of the `rest_framework.views.APIView` class. This class
    is the base class for all views in Django REST Framework. As we might guess, in
    case we want to work with class-based view, we can create classes that inherit
    from this class and we will have the same benefits that we analyzed for the function-based
    views that use the decorator. We will work with class-based views in the forthcoming
    examples.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`@api_view`装饰器是一个包装器，它将基于函数的视图转换为`rest_framework.views.APIView`类的子类。这个类是Django
    REST Framework中所有视图的基类。正如我们可能猜测的那样，如果我们想使用基于类的视图，我们可以创建从该类继承的类，我们将获得与使用装饰器的基于函数的视图相同的优势。我们将在接下来的示例中使用基于类的视图。
- en: In addition, as we specify a string list with the supported HTTP verbs, the
    decorator automatically builds the response for the `OPTIONS` HTTP verb with the
    supported methods and parser and render capabilities. Our actual version of the
    API is just capable of rendering JSON as its output. The usage of the decorator
    makes sure that we always receive an instance of the `rest_framework.request.Request`
    class in the `request` argument when Django calls our view function. The decorator
    also handles the `ParserError` exceptions when our function views access the `request.data`
    attribute that might cause parsing problems.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们指定了一个支持HTTP动词的字符串列表，装饰器会自动为支持的HTTP动词`OPTIONS`构建响应，包括支持的方法、解析器和渲染能力。我们实际的API版本仅能够渲染JSON作为其输出。装饰器的使用确保了在Django调用我们的视图函数时，我们总是接收到`rest_framework.request.Request`类的实例。装饰器还处理当我们的函数视图访问可能引起解析问题的`request.data`属性时可能发生的`ParserError`异常。
- en: Using the default parsing and rendering options and move beyond JSON
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用默认的解析和渲染选项，超越JSON
- en: The `APIView` class specifies default settings for each view that we can override
    by specifying appropriate values in the `gamesapi/settings.py` file or by overriding
    the class attributes in subclasses. As previously explained, the usage of the
    `APIView` class under the hoods makes the decorator apply these default settings.
    Thus, whenever we use the decorator, the default parser classes and the default
    renderer classes will be associated with the function views.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`APIView`类为每个视图指定默认设置，我们可以通过在`gamesapi/settings.py`文件中指定适当的值或在子类中覆盖类属性来覆盖这些设置。如前所述，`APIView`类在内部使用使装饰器应用这些默认设置。因此，每次我们使用装饰器时，默认解析器类和默认渲染器类都将与函数视图相关联。'
- en: 'By default, the value for the `DEFAULT_PARSER_CLASSES` is the following tuple
    of classes:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`DEFAULT_PARSER_CLASSES`的值是以下类元组：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When we use the decorator, the API will be able to handle any of the following
    content types through the appropriate parsers when accessing the `request.data`
    attribute:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用装饰器时，API将能够通过适当的解析器处理访问`request.data`属性时可能使用的以下任何内容类型：
- en: '`application/json`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application/json`'
- en: '`application/x-www-form-urlencoded`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application/x-www-form-urlencoded`'
- en: '`multipart/form-data`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multipart/form-data`'
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When we access the `request.data` attribute in the functions, Django REST Framework
    examines the value for the `Content-Type` header in the incoming request and determines
    the appropriate parser to parse the request content. If we use the previously
    explained default values, the Django REST Framework will be able to parse the
    previously listed content types. However, it is extremely important that the request
    specifies the appropriate value in the `Content-Type` header.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在函数中访问`request.data`属性时，Django REST Framework会检查传入请求中的`Content-Type`头部的值，并确定适当的解析器来解析请求内容。如果我们使用之前解释的默认值，Django
    REST Framework将能够解析之前列出的内容类型。然而，请求在`Content-Type`头部指定适当的值是极其重要的。
- en: 'We have to remove the usage of the `rest_framework.parsers.JSONParser` class
    in the functions to make it possible to be able to work with all the configured
    parsers and stop working with a parser that only works with JSON. The `game_list`
    function executes the following two lines when `request.method` is equal to `''POST''`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在函数中移除对`rest_framework.parsers.JSONParser`类的使用，以便能够使用所有配置的解析器，并停止使用仅适用于JSON的解析器。当`request.method`等于`'POST'`时，`game_list`函数执行以下两行代码：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will remove the first line that uses the `JSONParser` and we will pass `request.data`
    as the data argument for the `GameSerializer`. The following line will replace
    the previous lines:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将移除使用`JSONParser`的第一行，并将`request.data`作为`GameSerializer`的数据参数传递。以下行将替换之前的行：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `game_detail` function executes the following two lines when `request.method`
    is equal to `''PUT''`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当`request.method`等于`'PUT'`时，`game_detail`函数执行以下两行代码：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will make the same edits done for the code in the `game_list` function.
    We will remove the first line that uses the `JSONParser` and we will pass `request.data`
    as the data argument for the `GameSerializer`. The following line will replace
    the previous lines:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对`game_list`函数中的代码进行相同的编辑。我们将移除使用`JSONParser`的第一行，并将`request.data`作为数据参数传递给`GameSerializer`。以下行将替换之前的行：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'By default, the value for the `DEFAULT_RENDERER_CLASSES` is the following tuple
    of classes:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`DEFAULT_RENDERER_CLASSES`的值是以下类元组：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we use the decorator, the API will be able to render the following content
    types in the response, through the appropriate renderers, when working with the
    `rest_framework.response.Response` object:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用装饰器时，API将能够通过适当的渲染器在响应中渲染以下内容类型，当与`rest_framework.response.Response`对象一起工作时：
- en: '`application/json`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application/json`'
- en: '`text/html`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text/html`'
- en: By default, the value for the `DEFAULT_CONTENT_NEGOTIATION_CLASS` is the `rest_framework.negotiation.DefaultContentNegotiation`
    class. When we use the decorator, the API will use this content negotiation class
    to select the appropriate renderer for the response based on the incoming request.
    This way, when a request specifies that it will accept `text/html`, the content
    negotiation class selects the `rest_framework.renderers.BrowsableAPIRenderer`
    to render the response and generate `text/html` instead of `application/json`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`DEFAULT_CONTENT_NEGOTIATION_CLASS`的值是`rest_framework.negotiation.DefaultContentNegotiation`类。当我们使用装饰器时，API将使用此内容协商类根据传入的请求选择适当的渲染器。这样，当请求指定它将接受`text/html`时，内容协商类选择`rest_framework.renderers.BrowsableAPIRenderer`来渲染响应并生成`text/html`而不是`application/json`。
- en: We have to replace the usage of both the `JSONResponse` and `HttpResponse` classes
    in the functions with the `rest_framework.response.Response` class. The `Response`
    class uses the previously explained content negotiation features, renders the
    received data into the appropriate content type, and returns it to the client.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在函数中替换`JSONResponse`和`HttpResponse`类的使用，使用`rest_framework.response.Response`类。`Response`类使用之前解释的内容协商功能，将接收到的数据渲染到适当的内容类型，并将其返回给客户端。
- en: 'Now, go to the `gamesapi/games` folder and open the `views.py` file. Replace
    the code in this file with the following code that removes the `JSONResponse`
    class and uses the `@api_view` decorator for the functions and the `rest_framework.response.Response`
    class. The modified lines are highlighted. The code file for the sample is included
    in the `restful_python_chapter_02_02` folder:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前往`gamesapi/games`文件夹并打开`views.py`文件。将此文件中的代码替换为以下代码，该代码移除了`JSONResponse`类，并使用`@api_view`装饰器为函数和`rest_framework.response.Response`类。修改的行已突出显示。示例代码文件包含在`restful_python_chapter_02_02`文件夹中：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After you save the preceding changes, run the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 保存上述更改后，运行以下命令：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The previous command will compose and send the following HTTP request: `OPTIONS
    http://localhost:8000/games/`. The request will match and run the `views.game_list`
    function, that is, the `game_list` function declared within the `games/views.py`
    file. We added the `@api_view` decorator to this function, and therefore, it is
    now capable of determining the supported HTTP verbs, parsing, and rendering capabilities.
    The following lines show the output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送以下HTTP请求：`OPTIONS http://localhost:8000/games/`。请求将匹配并运行`views.game_list`函数，即`games/views.py`文件中声明的`game_list`函数。我们为此函数添加了`@api_view`装饰器，因此它现在能够确定支持的HTTP动词、解析和渲染能力。以下行显示了输出：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The response header includes an `Allow` key with a comma-separated list of
    HTTP verbs supported by the resource collection as its value: `GET, POST, OPTIONS`.
    As our request didn''t specify the allowed content type, the function rendered
    the response with the default `application/json` content type. The response body
    specifies the `Content-type` that the resource collection parses and the `Content-type`
    that it renders.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 响应头包含一个`Allow`键，其值为资源集合支持的HTTP动词的逗号分隔列表：`GET, POST, OPTIONS`。由于我们的请求没有指定允许的内容类型，函数以默认的`application/json`内容类型渲染了响应。响应体指定了资源集合解析和渲染的`Content-type`。
- en: Run the following command to compose and send an HTTP request with the `OPTIONS`
    verb for a game resource. Don't forget to replace `3` with a primary key value
    of an existing game in your configuration.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以使用`OPTIONS`动词为游戏资源组合并发送HTTP请求。别忘了将`3`替换为配置中现有游戏的主键值。
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following is the equivalent curl command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的curl命令：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding command will compose and send the following HTTP request: `OPTIONS
    http://localhost:8000/games/3/`. The request will match and run the `views.game_detail`
    function, that is, the `game_detail` function declared within the `games/views.py`
    file. We also added the `@api_view` decorator to this function, and therefore,
    it is capable of determining the supported HTTP verbs, parsing, and rendering
    capabilities. The following lines show the output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将编写并发送以下HTTP请求：`OPTIONS http://localhost:8000/games/3/`。该请求将匹配并运行`views.game_detail`函数，即`games/views.py`文件中声明的`game_detail`函数。我们还为此函数添加了`@api_view`装饰器，因此它能够确定支持的HTTP动词、解析和渲染能力。以下行显示了输出：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The response header includes an `Allow` key with a comma-separated list of
    HTTP verbs supported by the resource as its value: `GET, POST, OPTIONS, PUT`.
    The response body specifies the content-type that the resource parses and the
    content-type that it renders, with the same contents received in the previous
    `OPTIONS` request applied to a resource collection, that is, to a games collection.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 响应头包括一个`Allow`键，其值为资源支持的HTTP动词的逗号分隔列表：`GET, POST, OPTIONS, PUT`。响应体指定了资源解析和渲染的内容类型，与之前收到的`OPTIONS`请求中应用于资源集合（即游戏集合）的相同内容。
- en: 'In [Chapter 1](ch01.html "Chapter 1. Developing RESTful APIs with Django"),
    *Developing RESTful APIs with Django*, when we composed and sent POST and PUT
    commands, we had to use the use the `-H "Content-Type: application/json"` option
    to tell curl to send the data specified after the `-d` option as `application/json`
    instead of the default `application/x-www-form-urlencoded`. Now, in addition to
    `application/json`, our API is capable of parsing `application/x-www-form-urlencoded`
    and `multipart/form-data` data specified in the `POST` and `PUT` requests. Thus,
    we can compose and send a POST command that sends the data as `application/x-www-form-urlencoded`,
    with the changes made to our API.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '在[第1章](ch01.html "第1章。使用Django开发RESTful API") *使用Django开发RESTful API* 中，当我们编写并发送POST和PUT命令时，我们必须使用`-H
    "Content-Type: application/json"`选项来告诉curl将`-d`选项之后指定的数据作为`application/json`发送，而不是默认的`application/x-www-form-urlencoded`。现在，除了`application/json`之外，我们的API还能够解析`POST`和`PUT`请求中指定的`application/x-www-form-urlencoded`和`multipart/form-data`数据。因此，我们可以编写并发送一个POST命令，将数据作为`application/x-www-form-urlencoded`发送，并且对API所做的更改已经生效。'
- en: 'We will compose and send an HTTP request to create a new game. In this case,
    we will use the -f option for HTTPie, that serializes data items from the command
    line as form fields and sets the `Content-Type` header key to the `application/x-www-form-urlencoded`
    value:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写并发送一个HTTP请求来创建一个新的游戏。在这种情况下，我们将使用HTTPie的-f选项，该选项将命令行中的数据项序列化为表单字段，并将`Content-Type`头键设置为`application/x-www-form-urlencoded`值：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following is the equivalent curl command. Note that we don''t use the `-H`
    option and curl will send the data in the default `application/x-www-form-urlencoded`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的curl命令。请注意，我们不使用`-H`选项，curl将以默认的`application/x-www-form-urlencoded`发送数据：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The previous commands will compose and send the following HTTP request: `POST
    http://localhost:8000/games/` with the `Content-Type` header key set to the `application/x-www-form-urlencoded`
    value and the following data:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将编写并发送以下HTTP请求：`POST http://localhost:8000/games/`，并将`Content-Type`头键设置为`application/x-www-form-urlencoded`值，以及以下数据：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The request specifies `/games/`, and therefore, it will match `''^games/$''`
    and run the `views.game_list` function, that is, the updated `game_detail` function
    declared within the `games/views.py` file. As the HTTP verb for the request is
    `POST`, the `request.method` property is equal to `''POST''`, and therefore, the
    function will execute the code that creates a `GameSerializer` instance and passes
    `request.data` as the data argument for its creation. The `rest_framework.parsers.FormParser`
    class will parse the data received in the request, the code creates a new `Game`
    and, if the data is valid, it saves the new `Game`. If the new `Game` was successfully
    persisted in the database, the function returns an `HTTP 201 Created` status code
    and the recently persisted `Game` serialized to JSON in the response body. The
    following lines show an example response for the HTTP request, with the new `Game`
    object in the JSON response:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请求指定`/games/`，因此，它将匹配`'^games/$'`并运行`views.game_list`函数，即`games/views.py`文件中声明的更新后的`game_detail`函数。由于请求的HTTP动词是`POST`，`request.method`属性等于`'POST'`，因此，该函数将执行创建`GameSerializer`实例的代码，并将`request.data`作为其创建的数据参数。`rest_framework.parsers.FormParser`类将解析请求中接收到的数据，代码创建一个新的`Game`对象，如果数据有效，则将其保存。如果新的`Game`对象成功持久化到数据库中，该函数返回`HTTP
    201 Created`状态码，并在响应体中将最近持久化的`Game`对象序列化为JSON。以下行显示了HTTP请求的示例响应，其中包含JSON响应中的新`Game`对象：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can run the following command after we make the changes in the code, to
    see what happens when we compose and send an HTTP request with an HTTP verb that
    is not supported:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在对代码进行更改后运行以下命令，以查看当我们使用不被支持的HTTP动词组成并发送HTTP请求时会发生什么：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The previous command will compose and send the following HTTP request: `PUT
    http://localhost:8000/games/`. The request will match and try to run the `views.game_list`
    function, that is, the `game_list` function declared within the `games/views.py`
    file. The `@api_view` decorator we added to this function doesn''t include `''PUT''`
    in the string list with the allowed HTTP verbs, and therefore, the default behavior
    returns a `405 Method Not Allowed` status code. The following lines show the output
    along with the response from the previous request. A JSON content provides a `detail`
    key with a string value, which indicates that the `PUT` method is not allowed:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组成并发送以下HTTP请求：`PUT http://localhost:8000/games/`。请求将匹配并尝试运行`views.game_list`函数，即`games/views.py`文件中声明的`game_list`函数。我们添加到这个函数的`@api_view`装饰器不包括`'PUT'`在允许的HTTP动词的字符串列表中，因此，默认行为返回`405
    Method Not Allowed`状态码。以下行显示了输出以及之前请求的响应。一个JSON内容提供了一个`detail`键，其字符串值指示`PUT`方法不被允许：
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Browsing the API
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览API
- en: With the recent edits, we made it possible for our API to use the default content
    renderers configured in Django REST Framework, and therefore, our API is capable
    of rendering the `text/html` content. We can take advantage of the browsable API,
    a feature included in Django REST Framework that generates human-friendly HTML
    output for each resource whenever the request specifies `text/html` as the value
    for the `Content-type` key in the request header.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过最近的编辑，我们使我们的API能够使用Django REST Framework中配置的默认内容渲染器，因此，我们的API能够渲染`text/html`内容。我们可以利用可浏览的API，这是Django
    REST Framework中包含的一个特性，它会在请求指定请求头中的`Content-type`键值为`text/html`时，为每个资源生成人类友好的HTML输出。
- en: Whenever we enter a URL for an API resource in a web browser, the browser will
    require an HTML response, and therefore, Django REST Framework will provide an
    HTML response built with Bootstrap ([http://getbootstrap.com](http://getbootstrap.com)).
    This response will include a section that displays the resource content in JSON,
    buttons to perform different requests, and forms to submit data to the resources.
    As everything in Django REST Framework, we can customize the templates and themes
    used to generate the browsable API.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们在一个网络浏览器中输入API资源的URL时，浏览器将需要一个HTML响应，因此，Django REST Framework将提供一个使用Bootstrap构建的HTML响应([http://getbootstrap.com](http://getbootstrap.com))。此响应将包括一个显示资源内容的JSON部分，执行不同请求的按钮，以及提交数据到资源的表单。正如Django
    REST Framework中的所有内容一样，我们可以自定义用于生成可浏览API的模板和主题。
- en: 'Open a web browser and enter `http://localhost:8000/games/`. The browsable
    API will compose and send a `GET` request to `/games/` and will display the results
    of its execution, that is, the headers and the JSON games list. The following
    screenshot shows the rendered web page after entering the URL in a web browser
    with the resource description-**Game List**:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个网络浏览器并输入`http://localhost:8000/games/`。可浏览的API将编写并发送一个对`/games/`的`GET`请求，并将显示其执行结果，即头部信息和JSON游戏列表。以下截图显示了在网页浏览器中输入URL后的渲染网页，其中包含资源描述-**游戏列表**：
- en: '![Browsing the API](img/image_02_001.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![浏览API](img/image_02_001.jpg)'
- en: Tip
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you decide to browse the API in a web browser running on another computer
    or device connected to the LAN, remember that you have to use the development
    computer's assigned IP address instead of `localhost`. For example, if the computer's
    assigned IPv4 IP address is `192.168.1.106`, instead of `http://localhost:8000/games/`,
    you should use `http://192.168.1.106:8000/games/`. Of course, you can also use
    the host name instead of the IP address.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定在另一台运行在局域网内的计算机或设备上的网络浏览器中浏览API，请记住你必须使用开发计算机分配的IP地址而不是`localhost`。例如，如果计算机分配的IPv4
    IP地址是`192.168.1.106`，那么你应该使用`http://192.168.1.106:8000/games/`而不是`http://localhost:8000/games/`。当然，你也可以使用主机名而不是IP地址。
- en: The browsable API uses the information about the allowed methods for a resource
    to provide us with buttons to run these methods. At the right-hand side of the
    resource description, the browsable API shows an **OPTIONS** button and a **GET**
    drop-down button. The **OPTIONS** button allows us to make an `OPTIONS` request
    to `/games/`, that is, to the current resource. The **GET** drop-down button allows
    us to make a `GET` request to `/games/` again. If we click on or tap the down
    arrow, we can select the **json** option and the browsable API will display the
    raw JSON result of a `GET` request to `/games/` without the headers.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 可浏览的API使用有关资源允许的方法的信息，为我们提供按钮来运行这些方法。在资源描述的右侧，可浏览的API显示了一个**OPTIONS**按钮和一个**GET**下拉按钮。**OPTIONS**按钮允许我们向`/games/`发送一个`OPTIONS`请求，即当前资源。**GET**下拉按钮允许我们再次向`/games/`发送一个`GET`请求。如果我们点击或轻触向下箭头，我们可以选择**json**选项，可浏览的API将显示`GET`请求的原始JSON结果，而不显示头部信息。
- en: 'At the bottom of the rendered web page, the browsable API provides us some
    control to generate a `POST` request to `/games/`. The **Media type** dropdown
    allows us to select between the configured supported parsers for our API:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染的网页底部，可浏览的API为我们提供了一些控制，以生成对`/games/`的`POST`请求。**媒体类型**下拉菜单允许我们在为我们的API配置的解析器之间进行选择：
- en: '`application/json`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application/json`'
- en: '`application/x-www-form-urlencoded`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application/x-www-form-urlencoded`'
- en: '`multipart/form-data`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multipart/form-data`'
- en: 'The **Content** textbox allows us to specify the data to be sent to the `POST`
    request formatted as specified in the **Media type** dropdown. Select **application/json**
    in the **Media type** dropdown and enter the following JSON content in the **Content**
    textbox:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容**文本框允许我们指定要发送到`POST`请求的数据，格式与**媒体类型**下拉菜单中指定的一致。在**媒体类型**下拉菜单中选择**application/json**，并在**内容**文本框中输入以下JSON内容：'
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Click or tap on `POST`. The browsable API will compose and send a `POST` request
    to `/games/` with the previously specified data as JSON, and we will see the results
    of the call in the web browser.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 点击或轻触`POST`。可浏览的API将编写并发送一个包含之前指定数据的`POST`请求到`/games/`，我们将在网络浏览器中看到调用结果。
- en: 'The following screenshot shows a web browser displaying the HTTP status code
    `201 Created` in the response and the previously explained dropdown and textbox
    with the `POST` button to allow us to continue composing and sending `POST` requests
    to `/games/`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了一个网页浏览器在响应中显示了HTTP状态码`201 Created`，以及之前解释过的下拉菜单和带有`POST`按钮的文本框，允许我们继续编写并发送对`/games/`的`POST`请求：
- en: '![Browsing the API](img/image_02_002.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![浏览API](img/image_02_002.jpg)'
- en: Now, enter the URL for an existing game resource, such as `http://localhost:8000/games/2/`.
    Make sure you replace 2 with the id or primary key of an existing game in the
    previously rendered **Games List**. The browsable API will compose and send a
    `GET` request to `/games/2/` and will display the results of its execution, that
    is, the headers and the JSON data for the game.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入现有游戏资源的URL，例如`http://localhost:8000/games/2/`。确保将2替换为之前渲染的**游戏列表**中现有游戏的id或主键。可浏览的API将编写并发送一个对`/games/2/`的`GET`请求，并将显示其执行结果，即游戏的头部和JSON数据。
- en: The following screenshot shows the rendered web page after entering the URL
    in a web browser with the resource description-**Game Detail:**
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在网页浏览器中输入URL后渲染的网页，其中包含资源描述-**游戏详情**：
- en: '![Browsing the API](img/image_02_003.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![浏览API](img/image_02_003.jpg)'
- en: Tip
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The browsable API feature allows us to easily check how the API works and to
    compose and send HTTP requests with different methods to any web browser that
    has access to our LAN. We will take advantage of the additional features included
    in the browsable API, such as HTML forms that allow us to easily create new resources,
    later, after we build a new RESTful API with Python and Django REST Framework.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 可浏览的API功能使我们能够轻松检查API的工作方式，并向任何可以访问我们局域网的浏览器发送不同方法的HTTP请求。我们将利用可浏览API中包含的附加功能，例如HTML表单，它允许我们轻松创建新资源，在我们使用Python和Django
    REST框架构建新的RESTful API之后。
- en: Designing a RESTful API to interact with a complex PostgreSQL database
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一个与复杂的PostgreSQL数据库交互的RESTful API
- en: So far, our RESTful API has performed CRUD operations on a single database table.
    Now, we want to create a more complex RESTful API with Django REST Framework to
    interact with a complex database model that has to allow us to register player
    scores for played games that are grouped into game categories. In our previous
    RESTful API, we used a string field to specify the game category for a game. In
    this case, we want to be able to easily retrieve all the games that belong to
    a specific game category, and therefore, we will have a relationship between a
    game and a game category.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的RESTful API已经在单个数据库表上执行了CRUD操作。现在，我们想要使用Django REST框架创建一个更复杂的RESTful
    API，以与一个复杂的数据库模型交互，该模型必须允许我们为分组到游戏类别的已玩游戏注册玩家分数。在我们的上一个RESTful API中，我们使用一个字符串字段来指定游戏的类别。在这种情况下，我们希望能够轻松检索属于特定游戏类别的所有游戏，因此，我们将有一个游戏和游戏类别之间的关系。
- en: 'We should be able to perform CRUD operations on different related resources
    and resource collections. The following list enumerates the resources and the
    model names that we will use to represent them in Django REST Framework:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能够在不同的相关资源和资源集合上执行CRUD操作。以下列表列出了我们将使用以在Django REST框架中表示它们的资源和模型名称：
- en: Game categories (`GameCategory` model)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏类别（`GameCategory`模型）
- en: Games (`Game` model)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏（`Game`模型）
- en: Players (`Player` model)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家（`Player`模型）
- en: Player scores (`PlayerScore` model)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家分数（`PlayerScore`模型）
- en: 'The game category (`GameCategory`) just requires a name, and we need the following
    data for a game (`Game`):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏类别（`GameCategory`）只需要一个名称，而对于游戏（`Game`），我们需要以下数据：
- en: A foreign key to a game category (`GameCategory`)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向游戏类别（`GameCategory`）的外键
- en: A name
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名称
- en: A release date
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布日期
- en: A bool value indicating whether the game was played at least once by a player
    or not
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔值，表示游戏是否至少被玩家玩过一次
- en: A timestamp with the date and time in which the game was inserted in the database
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个时间戳，表示游戏被插入数据库的日期和时间
- en: 'We need the following data for a player (`Player`):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于玩家（`Player`），我们需要以下数据：
- en: A gender value
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个性别值
- en: A name
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名称
- en: A timestamp with the date and time in which the player was inserted in the database
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个时间戳，表示玩家被插入数据库的日期和时间
- en: 'We need the following data for the score achieved by a player (`PlayerScore`):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于玩家获得的分数（`PlayerScore`），我们需要以下数据：
- en: A foreign key to a player (`Player`)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向玩家（`Player`）的外键
- en: A foreign key to a game (`Game`)
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向游戏（`Game`）的外键
- en: A score value
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个分数值
- en: A date in which the score value was achieved by the player
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家获得分数值的日期
- en: Tip
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We will take advantage of all the resources and their relationships to analyze
    different options that Django REST Framework provides us when working with related
    resources. Instead of building an API that uses the same configuration to display
    related resources, we will use diverse configurations that will allow us to select
    the most appropriate options based on the particular requirements of the APIs
    that we are developing.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用所有资源和它们之间的关系来分析Django REST框架在处理相关资源时为我们提供的不同选项。我们不会构建使用相同配置来显示相关资源的API，而是将使用不同的配置，这将允许我们根据我们正在开发的API的特定要求选择最合适的选项。
- en: Understanding the tasks performed by each HTTP method
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解每个HTTP方法执行的任务
- en: The following table shows the HTTP verbs, the scope, and the semantics for the
    methods that our new API must support. Each method is composed by an HTTP verb
    and a scope and all the methods have well-defined meanings for all the resources
    and collections.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了我们的新API必须支持的HTTP动词、作用域和语义。每个方法由一个HTTP动词和一个作用域组成，并且所有方法对所有资源和集合都有明确的含义。
- en: '| **HTTP verb** | **Scope** | **Semantics** |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP动词** | **作用域** | **语义** |'
- en: '| `GET` | Collection of game categories | Retrieve all the stored game categories
    in the collection, sorted by their name in ascending order. Each game category
    must include a list of URLs for each game resource that belongs to the category.
    |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 游戏类别集合 | 获取集合中所有存储的游戏类别，按名称升序排序。每个游戏类别必须包括属于该类别的每个游戏资源的URL列表。 |'
- en: '| `GET` | Game category | Retrieve a single game category. The game category
    must include a list of URLs for each game resource that belongs to the category.
    |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 游戏类别 | 获取单个游戏类别。游戏类别必须包括属于该类别的每个游戏资源的URL列表。 |'
- en: '| `POST` | Collection of game categories | Create a new game category in the
    collection. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 游戏类别集合 | 在集合中创建一个新的游戏类别。 |'
- en: '| `PUT` | Game category | Update an existing game category. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 游戏类别 | 更新现有的游戏类别。 |'
- en: '| `PATCH` | Game category | Update one or more fields of an existing game category.
    |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 游戏类别 | 更新现有游戏类别的多个字段。 |'
- en: '| `DELETE` | Game category | Delete an existing game category. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 游戏类别 | 删除现有的游戏类别。 |'
- en: '| `GET` | Collection of games | Retrieve all the stored games in the collection,
    sorted by their name in ascending order. Each game must include its game category
    description. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 游戏集合 | 获取集合中所有存储的游戏，按名称升序排序。每个游戏必须包括其游戏类别描述。 |'
- en: '| `GET` | Game | Retrieve a single game. The game must include its game category
    description. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 游戏 | 获取单个游戏。游戏必须包括其游戏类别描述。 |'
- en: '| `POST` | Collection of games | Create a new game in the collection. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 游戏集合 | 在集合中创建一个新的游戏。 |'
- en: '| `PUT` | Game category | Update an existing game. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 游戏类别 | 更新现有游戏。 |'
- en: '| `PATCH` | Game category | Update one or more fields of an existing game.
    |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 游戏类别 | 更新现有游戏的多个字段。 |'
- en: '| `DELETE` | Game category | Delete an existing game. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 游戏类别 | 删除现有的游戏。 |'
- en: '| `GET` | Collection of players | Retrieve all the stored players in the collection,
    sorted by their name in ascending order. Each player must include a list of the
    registered scores, sorted by score in descending order. The list must include
    all the details for the score achieved by the player and its related game. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 玩家集合 | 获取集合中所有存储的玩家，按名称升序排序。每个玩家必须包括按分数降序排序的已注册分数列表。列表必须包括玩家获得的分数及其相关游戏的详细信息。
    |'
- en: '| `GET` | Player | Retrieve a single player. The player must include a list
    of the registered scores, sorted by score in descending order. The list must include
    all the details for the score achieved by the player and its related game. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 玩家 | 获取单个玩家。玩家必须包括按分数降序排序的已注册分数列表。列表必须包括玩家获得的分数及其相关游戏的详细信息。 |'
- en: '| `POST` | Collection of players | Create a new player in the collection. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 玩家集合 | 在集合中创建一个新的玩家。 |'
- en: '| `PUT` | Player | Update an existing player. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 玩家 | 更新现有的玩家。 |'
- en: '| `PATCH` | Player | Update one or more fields of an existing player. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 玩家 | 更新现有玩家的多个字段。 |'
- en: '| `DELETE` | Player | Delete an existing player. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 玩家 | 删除现有的玩家。 |'
- en: '| `GET` | Collection of scores | Retrieve all the stored scores in the collection,
    sorted by score in descending order. Each score must include the player''s name
    that achieved the score and the game''s name. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 分数集合 | 获取集合中所有存储的分数，按分数降序排序。每个分数必须包括获得分数的玩家姓名和游戏名称。 |'
- en: '| `GET` | Score | Retrieve a single score. The score must include the player''s
    name that achieved the score and the game''s name. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 分数 | 获取单个分数。该分数必须包括获得分数的玩家姓名和游戏名称。 |'
- en: '| `POST` | Collection of scores | Create a new score in the collection. The
    score must be related to an existing player and an existing game. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 分数集合 | 在集合中创建一个新的分数。该分数必须与现有玩家和现有游戏相关。 |'
- en: '| `PUT` | Score | Update an existing score. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 分数 | 更新现有的分数。 |'
- en: '| `PATCH` | Score | Update one or more fields of an existing score. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 分数 | 更新现有分数的多个字段。 |'
- en: '| `DELETE` | Score | Delete an existing score. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 分数 | 删除现有的分数。 |'
- en: We want our API to be able to update a single field for an existing resource,
    and therefore, we will provide an implementation for the `PATCH` method. The `PUT`
    method is meant to replace an entire resource and the `PATCH` method is meant
    to apply a delta to an existing resource. In addition, our RESTful API must support
    the `OPTIONS` method for all the resources and collection of resources.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的 API 能够更新现有资源的单个字段，因此我们将提供一个 `PATCH` 方法的实现。`PUT` 方法旨在替换整个资源，而 `PATCH`
    方法旨在对现有资源应用增量。此外，我们的 RESTful API 必须支持所有资源及其集合的 `OPTIONS` 方法。
- en: We don't want to spend time choosing and configuring the most appropriate ORM,
    as seen in our previous API; we just want to finish the RESTful API as soon as
    possible to start interacting with it. We will use all the features and reusable
    elements included in Django REST Framework to make it easy to build our API. We
    will work with a PostgreSQL database. However, in case you don't want to spend
    time installing PostgreSQL, you can skip the changes we make in Django REST Framework
    ORM configuration and continue working with the default SQLite database.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想花费时间选择和配置最合适的 ORM，就像我们在之前的 API 中看到的那样；我们只想尽快完成 RESTful API 以开始与之交互。我们将使用
    Django REST Framework 中包含的所有功能和可重用元素，以简化我们的 API 构建。我们将使用 PostgreSQL 数据库。然而，如果你不想花费时间安装
    PostgreSQL，你可以跳过我们在 Django REST Framework ORM 配置中做出的更改，并继续使用默认的 SQLite 数据库。
- en: 'In the preceding table, we have a huge number of methods and scopes. The following
    list enumerates the URIs for each scope mentioned in the table, where `{id}` has
    to be replaced with the numeric id or the primary key of the resource:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表中，我们有许多方法和作用域。以下列表列出了表中提到的每个作用域的 URI，其中 `{id}` 需要替换为资源的数字 ID 或主键：
- en: '**Collection of game categories**: `/game-categories/`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏类别集合**: `/game-categories/`'
- en: '**Game category**: `/game-category/{id}/`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏类别**: `/game-category/{id}/`'
- en: '**Collection of games**: `/games/`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏集合**: `/games/`'
- en: '**Game**: `/game/{id}/`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏**: `/game/{id}/`'
- en: '**Collection of players**: `/players/`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家集合**: `/players/`'
- en: '**Player**: `/player/{id}/`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家**: `/player/{id}/`'
- en: '**Collection of scores**: `/player-scores/`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分数集合**: `/player-scores/`'
- en: '**Score**: `/player-score/{id}/`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分数**: `/player-score/{id}/`'
- en: 'Let''s consider that `http://localhost:8000/` is the URL for the API running
    on the Django development server. We have to compose and send an HTTP request
    with the following HTTP verb (`GET`) and request URL (`http://localhost:8000/game-categories/`)
    to retrieve all the stored game categories in the collection:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设 `http://localhost:8000/` 是运行在 Django 开发服务器上的 API 的 URL。我们必须使用以下 HTTP 动词
    (`GET`) 和请求 URL (`http://localhost:8000/game-categories/`) 来组合和发送一个 HTTP 请求，以检索存储在集合中的所有游戏类别：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Declaring relationships with the models
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明与模型的关系
- en: Make sure you quit the Django's development server. Remember that you just need
    to press ***Ctrl*** + ***C*** in the terminal or command-prompt window in which
    it is running. Now, we will create the models that we are going to use to represent
    and persist the game categories, games, players and scores, and their relationships.
    Open the `games/models.py` file and replace its contents with the following code.
    The lines that declare fields related to other models are highlighted in the code
    listing. The code file for the sample is included in the `restful_python_chapter_02_03`
    folder.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已退出 Django 的开发服务器。记住，你只需在运行开发服务器的终端或命令提示符窗口中按 ***Ctrl*** + ***C*** 即可。现在，我们将创建我们将要用来表示和持久化游戏类别、游戏、玩家和分数及其关系的模型。打开
    `games/models.py` 文件，并用以下代码替换其内容。声明与其他模型相关字段的行在代码列表中突出显示。示例代码文件包含在 `restful_python_chapter_02_03`
    文件夹中。
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding code declares the following four models, specifically four classes
    as subclasses of the `django.db.models.Model` class:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码声明了以下四个模型，具体是四个作为 `django.db.models.Model` 类子类的类：
- en: '`GameCategory`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameCategory`'
- en: '`Game`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Game`'
- en: '`Player`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Player`'
- en: '`PlayerScore`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerScore`'
- en: Django automatically adds an auto-increment integer primary key column named
    `id` when it creates the database table related to each model. We specified the
    field types, maximum lengths, and defaults for many attributes. Each class declares
    a `Meta` inner class that declares an ordering attribute. The `Meta` inner class
    declared within the `PlayerScore` class specifies `'-score'` as the value of the
    `ordering` tuple, with a dash as a prefix of the field name and ordered by `score`
    in descending order, instead of the default ascending order.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Django 在创建与每个模型相关的数据库表时自动添加一个名为 `id` 的自增整数主键列。我们指定了许多属性的字段类型、最大长度和默认值。每个类声明一个
    `Meta` 内部类，该类声明一个排序属性。在 `PlayerScore` 类中声明的 `Meta` 内部类指定 `'-score'` 作为 `ordering`
    元组的值，以字段名前缀的形式使用连字符，并按 `score` 降序排序，而不是默认的升序排序。
- en: The `GameCategory`, `Game`, and `Player` classes declare the `__str__` method
    that returns the contents of the `name` attribute that provides the name or title
    for each of these models. So, Django will call this method whenever it has to
    provide a human-readable representation for the model.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameCategory`、`Game` 和 `Player` 类声明了 `__str__` 方法，该方法返回 `name` 属性的内容，为这些模型中的每个提供名称或标题。因此，Django
    在需要为模型提供人类可读表示时将调用此方法。'
- en: 'The `Game` model declares the `game_category` field with the following line:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game` 模型使用以下行声明了 `game_category` 字段：'
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding line uses the django.db.models.ForeignKey class to provide a many-to-one
    relationship to the GameCategory model. The 'games' value specified for the related_name
    argument creates a backwards relation from the GameCategory model to the Game
    model. This value indicates the name to be used for the relation from the related
    GameCategory object back to a Game object. Now, we will be able to access all
    the games that belong to a specific game category. Whenever we delete a game category,
    we want all the games that belong to this category to be deleted too, and therefore,
    we specified the models.CASCADE value for the on_delete argument.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行使用 `django.db.models.ForeignKey` 类为 `GameCategory` 模型提供多对一关系。为相关名参数指定的 `'games'`
    值创建了一个从 `GameCategory` 模型到 `Game` 模型的反向关系。此值表示从相关的 `GameCategory` 对象返回到 `Game`
    对象所使用的名称。现在，我们将能够访问属于特定游戏类别的所有游戏。每当删除一个游戏类别时，我们希望属于此类别的所有游戏也被删除，因此，我们为 `on_delete`
    参数指定了 `models.CASCADE` 值。
- en: 'The `PlayerScore` model declares the `player` field with the following line:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerScore` 模型使用以下行声明了 `player` 字段：'
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding line uses the django.db.models.ForeignKey class to provide a many-to-one
    relationship to the Player model. The 'scores' value specified for the related_name
    argument creates a backwards relation from the Player model to the PlayerScore
    model. This value indicates the name to be used for the relation from the related
    Player object back to a PlayerScore object. Now, we will be able to access all
    the scores archive by a specific player. Whenever we delete a player, we want
    all the scores achieved by this player to be deleted too, and therefore, we specified
    the models.CASCADE value for the on_delete argument.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行使用 `django.db.models.ForeignKey` 类为 `Player` 模型提供多对一关系。为相关名参数指定的 `'scores'`
    值创建了一个从 `Player` 模型到 `PlayerScore` 模型的反向关系。此值表示从相关的 `Player` 对象返回到 `PlayerScore`
    对象所使用的名称。现在，我们将能够访问特定玩家归档的所有分数。每当删除一个玩家时，我们希望此玩家所获得的所有分数也被删除，因此，我们为 `on_delete`
    参数指定了 `models.CASCADE` 值。
- en: 'The `PlayerScore` model declares the `game` field with the following line:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerScore` 模型使用以下行声明了 `game` 字段：'
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding line uses the django.db.models.ForeignKey class to provide a many-to-one
    relationship to the Game model. In this case, we don't create a backwards relation
    because we don't need it. Thus, we don't specify a value for the related_name
    argument. Whenever we delete a game, we want all the registered scores for this
    game to be deleted too, and therefore, we specified the models.CASCADE value for
    the on_delete argument.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行使用 `django.db.models.ForeignKey` 类为 `Game` 模型提供多对一关系。在这种情况下，我们不创建反向关系，因为我们不需要它。因此，我们不指定相关名参数的值。每当删除一个游戏时，我们希望删除此游戏的所有已注册分数，因此，我们为
    `on_delete` 参数指定了 `models.CASCADE` 值。
- en: In case you created a new virtual environment to work with this example or you
    downloaded the sample code for the book, you don't need to delete any existing
    database. However, in case you are making changes to the code for our previous
    API example, you have to delete the gamesapi/db.sqlite3 file and the games/migrations
    folder.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为处理此示例创建了新的虚拟环境或下载了本书的示例代码，您不需要删除任何现有数据库。然而，如果您正在修改我们之前的API示例中的代码，您必须删除gamesapi/db.sqlite3文件和games/migrations文件夹。
- en: Then, it is necessary to create the initial migration for the new models we
    recently coded. We just need to run the following Python scripts and we will also
    synchronize the database for the first time. As we learned from our previous example
    API, by default, Django uses an SQLite database. In this example, we will be working
    with a PostgreSQL database. However, in case you want to use SQLite, you can skip
    the steps related to PostgreSQL, its configuration in Django, and jump to the
    migrations generation command.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要为最近编写的新的模型创建初始迁移。我们只需运行以下Python脚本，我们还将首次同步数据库。正如我们从之前的示例API中学到的那样，默认情况下，Django使用SQLite数据库。在这个例子中，我们将使用PostgreSQL数据库。但是，如果您想使用SQLite，可以跳过与PostgreSQL相关的步骤，包括在Django中的配置，并跳转到迁移生成命令。
- en: You will have to download and install a PostgreSQL database in case you aren't
    already running it in your computer or in a development server. You can download
    and install this database management system from its web page-[http://www.postgresql.org](http://www.postgresql.org).
    In case you are working with macOS, `Postgres.app` provides an easy way to install
    and use PostgreSQL on this operating system-[http://postgresapp.com](http://postgresapp.com).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在计算机或开发服务器上尚未运行PostgreSQL数据库，您将需要下载并安装它。您可以从其网页-[http://www.postgresql.org](http://www.postgresql.org)下载并安装此数据库管理系统。如果您在macOS上工作，`Postgres.app`提供了一个在操作系统上安装和使用PostgreSQL的简单方法-[http://postgresapp.com](http://postgresapp.com)。
- en: Tip
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You have to make sure that the PostgreSQL bin folder is included in the `PATH`
    environmental variable. You should be able to execute the `psql` command-line
    utility from your current terminal or command prompt. In case the folder isn't
    included in the PATH, you will receive an error indicating that the `pg_config`
    file cannot be found when trying to install the `psycopg2` package. In addition,
    you will have to use the full path to each of the PostgreSQL command-line tools
    we will use in the subsequent steps.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须确保PostgreSQL bin文件夹包含在`PATH`环境变量中。您应该能够从当前的终端或命令提示符中执行`psql`命令行实用程序。如果文件夹未包含在PATH中，当尝试安装`psycopg2`包时，您将收到一个错误，指示找不到`pg_config`文件。此外，您将不得不使用后续步骤中我们将使用的每个PostgreSQL命令行工具的完整路径。
- en: 'We will use the PostgreSQL command-line tools to create a new database named
    `games`. In case you already have a PostgreSQL database with this name, make sure
    that you use another name in all the commands and configurations. You can perform
    the same task with any PostgreSQL GUI tool. In case you are developing on Linux,
    it is necessary to run the commands as the `postgres` user. Run the following
    command in macOS or Windows to create a new database named `games`. Note that
    the command won''t produce any output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用PostgreSQL命令行工具创建一个名为`games`的新数据库。如果您已经有一个同名PostgreSQL数据库，请确保在所有命令和配置中使用另一个名称。您可以使用任何PostgreSQL
    GUI工具执行相同的任务。如果您在Linux上开发，必须以`postgres`用户身份运行命令。在macOS或Windows上运行以下命令以创建一个名为`games`的新数据库。请注意，该命令不会产生任何输出：
- en: '[PRE37]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In Linux, run the following command to use the `postgres` user:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，运行以下命令以使用`postgres`用户：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we will use the `psql` command-line tool to run some SQL statements to
    create a specific user that we will use in Django and assign the necessary roles
    for it. In macOS or Windows, run the following command to launch `psql`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用`psql`命令行工具运行一些SQL语句来创建我们将用于Django的特定用户，并为其分配必要的角色。在macOS或Windows上，运行以下命令以启动`psql`：
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In macOS, you might need to run the following command to launch psql with the
    `postgres` in case the previous command doesn''t work, as it will depend on the
    way in which you installed PostgreSQL:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上，如果您发现之前的命令不起作用，可能需要运行以下命令以使用`postgres`启动psql，这取决于您安装PostgreSQL的方式：
- en: '[PRE40]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In Linux, run the following command to use the `postgres` user.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，运行以下命令以使用`postgres`用户。
- en: '[PRE41]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, run the following SQL statements and finally enter `\q` to exit the psql
    command-line tool. Replace `user_name` with your desired user name to use in the
    new database and password with your chosen password. We will use the username
    and password in the Django configuration. You don''t need to run the steps if you
    are already working with a specific user in PostgreSQL and you have already granted
    privileges to the database for the user:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下SQL语句，最后输入`\q`退出psql命令行工具。将`user_name`替换为您在新的数据库中希望使用的用户名，将密码替换为您选择的密码。我们将使用Django配置中的用户名和密码。如果您已经在PostgreSQL中与特定用户一起工作，并且已经为该用户授予了数据库权限，则不需要运行这些步骤：
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The default SQLite database engine and the database file name are specified
    in the `gamesapi/settings.py` Python file. In case you decide to work with PostgreSQL
    instead of SQLite for this example, replace the declaration of the `DATABASES`
    dictionary with the following lines. The nested dictionary maps the database named
    `default` with the `django.db.backends.postgresql` database engine, the desired
    database name, and its settings. In this case, we will create a database named
    `games`. Make sure you specify the desired database name in the value for the
    `''NAME''` key and that you configure the user, password, host, and port based
    on your PostgreSQL configuration. In case you followed the previous steps, use
    the settings specified in these steps:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的SQLite数据库引擎和数据库文件名在`gamesapi/settings.py`Python文件中指定。如果您决定使用PostgreSQL而不是SQLite进行此示例，请将`DATABASES`字典的声明替换为以下行。嵌套字典将名为`default`的数据库映射到`django.db.backends.postgresql`数据库引擎、所需的数据库名称及其设置。在这种情况下，我们将创建一个名为`games`的数据库。请确保在`'NAME'`键的值中指定所需的数据库名称，并根据您的PostgreSQL配置配置用户、密码、主机和端口。如果您遵循了之前的步骤，请使用这些步骤中指定的设置：
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In case you decided to use PostgreSQL, after making the preceding changes, it
    is necessary to install the Psycopg 2 package (psycopg2). This package is a Python-PostgreSQL
    Database Adapter and Django uses it to interact with a PostgreSQL database.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定使用PostgreSQL，在做出上述更改后，有必要安装Psycopg 2包（psycopg2）。此包是Python-PostgreSQL数据库适配器，Django使用它来与PostgreSQL数据库交互。
- en: 'In macOS installations, we have to make sure that the PostgreSQL bin folder
    is included in the `PATH` environmental variable. For example, in case the path
    to the bin folder is `/Applications/Postgres.app/Contents/Versions/latest/bin`,
    we must execute the following command to add this folder to the `PATH` environmental
    variable:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS安装中，我们必须确保PostgreSQL的bin文件夹包含在`PATH`环境变量中。例如，如果bin文件夹的路径是`/Applications/Postgres.app/Contents/Versions/latest/bin`，我们必须执行以下命令将此文件夹添加到`PATH`环境变量中：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once we have made sure that the PostgreSQL `bin` folder is included in the
    PATH environmental variable, we just need to run the following command to install
    this package:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确认PostgreSQL的`bin`文件夹已包含在PATH环境变量中，我们只需运行以下命令即可安装此包：
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The last lines of the output will indicate that the `psycopg2` package has
    been successfully installed:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后一行将指示`psycopg2`包已成功安装：
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, run the following Python script to generate the migrations that will allow
    us to synchronize the database for the first time:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下Python脚本以生成允许我们首次同步数据库的迁移：
- en: '[PRE47]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following lines show the output generated after running the previous command:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了运行上一条命令后生成的输出：
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output indicates that the `gamesapi/games/migrations/0001_initial.py` file
    includes the code to create the `Game`, `GameCategory`, `Player` , and `PlayerScore`
    models. The following lines show the code for this file that was automatically
    generated by Django. The code file for the sample is included in the `restful_python_chapter_02_03`
    folder:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明`gamesapi/games/migrations/0001_initial.py`文件包含了创建`Game`、`GameCategory`、`Player`和`PlayerScore`模型的代码。以下行显示了由Django自动生成的此文件的代码。示例的代码文件包含在`restful_python_chapter_02_03`文件夹中：
- en: '[PRE49]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The preceding code defines a subclass of the `django.db.migrations.Migration`
    class named `Migration` that defines an `operations` list with many `migrations.CreateModel`.
    Each `migrations.CreateModel` will create the table for each of the related models.
    Note that Django has automatically added an `id` field for each of the models.
    The `operations` are executed in the same order in which they appear in the list.
    The code creates `Game`, `GameCategory`, `Player`, `PlayerScore`, and finally
    adds the `game_category` field to `Game` with the foreign key to `GameCategory`
    because it created the `Game` model before the `GameCategory` model. The code
    creates the foreign keys for `PlayerScore` when it creates the model:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个名为`Migration`的`django.db.migrations.Migration`类的子类，该类定义了一个包含许多`migrations.CreateModel`的`operations`列表。每个`migrations.CreateModel`将为每个相关模型创建一个表。请注意，Django已经为每个模型自动添加了一个`id`字段。`operations`按列表中出现的顺序执行。该代码创建了`Game`、`GameCategory`、`Player`、`PlayerScore`表，并最终将`game_category`字段添加到`Game`中，该字段具有指向`GameCategory`的外键，因为它在创建`GameCategory`模型之前创建了`Game`模型。当创建模型时，它为`PlayerScore`创建了外键：
- en: Now, run the following Python script to apply all the generated migrations.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下Python脚本以应用所有生成的迁移。
- en: '[PRE50]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following lines show the output generated after running the previous command:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了运行上一个命令后的输出：
- en: '[PRE51]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: After we run the previous command, we can use the PostgreSQL command line or
    any other application that allows us to easily check the contents of the PostreSQL
    database to check the tables that Django generated. In case you are working with
    SQLite, we have already learned how to check the tables in [Chapter 1](ch01.html
    "Chapter 1. Developing RESTful APIs with Django"), *Developing RESTful APIs with
    Django*.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行上一个命令后，我们可以使用PostgreSQL命令行或任何允许我们轻松检查PostreSQL数据库内容的其他应用程序来检查Django生成的表。如果你正在使用SQLite，我们已经在[第1章](ch01.html
    "第1章。使用Django开发RESTful API")*使用Django开发RESTful API*中学习了如何检查表。
- en: 'Run the following command to list the generated tables:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以列出生成的表：
- en: '[PRE52]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following lines show the output with all the generated table names:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了所有生成的表名的输出：
- en: '[PRE53]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As seen in our previous example, Django uses the `games_` prefix for the following
    four table names related to the `games` application. Django''s integrated ORM
    generated these tables and the foreign keys, based on the information included
    in our models:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个示例所示，Django使用`games_`前缀为与`games`应用相关的以下四个表名。Django的集成ORM根据我们模型中包含的信息生成了这些表和外键：
- en: '`games_game`: Persists the `Game` model'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`games_game`: 持久化`Game`模型'
- en: '`games_gamecategory`: Persists the `GameCategory` model'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`games_gamecategory`: 持久化`GameCategory`模型'
- en: '`games_player`: Persists the `Player` model'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`games_player`: 持久化`Player`模型'
- en: '`games_playerscore`: Persists the `PlayerScore` model'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`games_playerscore`: 持久化`PlayerScore`模型'
- en: The following command will allow you to check the contents of the four tables
    after we compose and send HTTP requests to the RESTful API and make CRUD operations
    to the four tables. The commands assume that you are running PostgreSQL on the
    same computer in which you are running the command.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将在我们向RESTful API发送HTTP请求并执行对四个表的CRUD操作后允许您检查四个表的内容。这些命令假设您正在同一台运行命令的计算机上运行PostgreSQL。
- en: '[PRE54]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Tip
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Instead of working with the PostgreSQL command-line utility, you can use a GUI
    tool to check the contents of the PostgreSQL database. You can also use the database
    tools included in your favorite IDE to check the contents for the SQLite database.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用PostgreSQL命令行工具外，您还可以使用GUI工具来检查PostgreSQL数据库的内容。您还可以使用您最喜欢的IDE中包含的数据库工具来检查SQLite数据库的内容。
- en: Django generates additional tables that it requires to support the web framework
    and the authentication features that we will use later.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Django生成了一些额外的表，这些表是它支持Web框架和我们将要使用的认证功能所必需的。
- en: Managing serialization and deserialization with relationships and hyperlinks
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用关系和超链接管理序列化和反序列化
- en: Our new RESTful Web API has to be able to serialize and deserialize the `GameCategory`,
    `Game`, `Player`, and `PlayerScore` instances into JSON representations. In this
    case, we also have to pay special attention to the relationships between the different
    models when we create the serializer classes to manage serialization to JSON and
    deserialization from JSON.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的RESTful Web API必须能够将`GameCategory`、`Game`、`Player`和`PlayerScore`实例序列化和反序列化为JSON表示。在这种情况下，我们还需要在创建序列化器类以管理JSON序列化和反序列化时特别注意不同模型之间的关系。
- en: In our last version of the previous API, we created a subclass of the `rest_framework.serializers.ModelSerializer`
    class to make it easier to generate a serializer and reduce boilerplate code.
    In this case, we will also declare a class that inherits from `ModelSerializer`,
    but the other classes will inherit from the `rest_framework.serializers.HyperlinkedModelSerializer`
    class.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前版本的API中，我们创建了一个`rest_framework.serializers.ModelSerializer`类的子类，以便更容易生成序列化器并减少样板代码。在这种情况下，我们也将声明一个继承自`ModelSerializer`的类，但其他类将继承自`rest_framework.serializers.HyperlinkedModelSerializer`类。
- en: The `HyperlinkedModelSerializer` is a type of `ModelSerializer` that uses hyperlinked
    relationships instead of primary key relationships, and therefore, it represents
    the realationships to other model instances with hyperlinks instead of primary
    key values. In addition, the `HyperlinkedModelSerializer` generated a field named
    `url` with the URL for the resource as its value. As seen in the case of `ModelSerializer`,
    the `HyperlinkedModelSerializer` class provides default implementations for the
    `create` and `update` methods.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`HyperlinkedModelSerializer`是一种`ModelSerializer`类型，它使用超链接关系而不是主键关系，因此它使用超链接而不是主键值来表示与其他模型实例的关系。此外，`HyperlinkedModelSerializer`生成一个名为`url`的字段，其值为资源的URL。正如在`ModelSerializer`的案例中看到的那样，`HyperlinkedModelSerializer`类为`create`和`update`方法提供了默认实现。'
- en: 'Now, go to the `gamesapi/games` folder and open the `serializers.py` file.
    Replace the code in this file with the following code that declares the required
    imports and the `GameCategorySerializer` class. We will add more classes to this
    file later. The code file for the sample is included in the `restful_python_chapter_02_03`
    folder:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到`gamesapi/games`文件夹，并打开`serializers.py`文件。用以下代码替换此文件中的代码，以声明所需的导入和`GameCategorySerializer`类。我们稍后将在该文件中添加更多类。示例代码文件包含在`restful_python_chapter_02_03`文件夹中：
- en: '[PRE55]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `GameCategorySerializer` class is a subclass of the `HyperlinkedModelSerializer`
    class. The `GameCategorySerializer` class declares a `games` attribute as an instance
    of `serializers.HyperlinkedRelatedField` with `many` and `read_only` equal to
    `True` because it is a one-to-many relationship and it is read-only. We use the
    `games` name that we specified as the `related_name` string value when we created
    the `game_category` field as a `models.ForeignKey` instance in the `Game` model.
    This way, the `games` field will provide us with an array of hyperlinks to each
    game that belong to the game category. The `view_name` value is '`game-detail`'
    because we want the browsable API feature to use the game detail view to render
    the hyperlink when the user clicks or taps on it.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameCategorySerializer`类是`HyperlinkedModelSerializer`类的子类。`GameCategorySerializer`类声明了一个`games`属性，它是一个`serializers.HyperlinkedRelatedField`实例，`many`和`read_only`都设置为`True`，因为它是一对多关系且只读。我们使用在创建`Game`模型中的`game_category`字段时指定的`related_name`字符串值`''games''`。这样，`games`字段将为我们提供指向属于游戏类别的每个游戏的超链接数组。`view_name`的值是`''game-detail''`，因为我们希望可浏览的API功能使用游戏详情视图来渲染超链接，当用户点击或轻触时。'
- en: 'The `GameCategorySerializer` class declares a `Meta` inner class that declares
    two attributes: `model` and `fields`. The `model` attribute specifies the model
    related to the serializer, that is, the `GameCategory` class. The `fields` attribute
    specifies a tuple of string whose values indicates the field names that we want
    to include in the serialization from the related model. We want to include both
    the primary key and the URL, and therefore, the code specified both `''pk''` and
    `''url''` as members of the tuple. There is no need to override either the `create` ,
    or `update` method because the generic behavior will be enough in this case. The
    `HyperlinkedModelSerializer` superclass provides implementations for both methods.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameCategorySerializer`类声明了一个`Meta`内部类，该类声明了两个属性：`model`和`fields`。`model`属性指定了与序列化器相关的模型，即`GameCategory`类。`fields`属性指定了一个字符串元组，其值表示我们想要包含在序列化中的相关模型的字段名称。我们希望包含主键和URL，因此代码指定了元组的成员`''pk''`和`''url''`。在这种情况下，没有必要重写`create`或`update`方法，因为通用行为将足够。`HyperlinkedModelSerializer`超类提供了这两个方法的实现。'
- en: 'Now, add the following code to the `serializers.py` file to declare the `GameSerializer`
    class. The code file for the sample is included in the `restful_python_chapter_02_03`
    folder:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将以下代码添加到`serializers.py`文件中，以声明`GameSerializer`类。示例代码文件包含在`restful_python_chapter_02_03`文件夹中：
- en: '[PRE56]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `GameSerializer` class is a subclass of the `HyperlinkedModelSerializer`
    class. The `GameSerializer` class declares a `game_category` attribute as an instance
    of `serializers.SlugRelatedField` with its `queryset` argument set to `GameCategory.objects.all()`
    and its `slug_field` argument set to `'name'`. A `SlugRelatedField` is a read-write
    field that represents the target of the relationship by a unique slug attribute,
    that is, the description. We created the `game_category` field as a `models.ForeignKey`
    instance in the `Game` model and we want to display the game category's name as
    the description (slug field) for the related `GameCategory`. Thus, we specified
    `'name'` as the `slug_field`. In case it is necessary to display the possible
    options for the related game category in a form in the browsable API, Django will
    use the expression specified in the `queryset` argument to retrieve all the possible
    instances and display their specified slug field.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameSerializer` 类是 `HyperlinkedModelSerializer` 类的子类。`GameSerializer` 类声明了一个
    `game_category` 属性，它是一个 `serializers.SlugRelatedField` 的实例，其 `queryset` 参数设置为
    `GameCategory.objects.all()`，其 `slug_field` 参数设置为 `''name''`。`SlugRelatedField`
    是一个读写字段，它通过唯一的 slug 属性（即描述）表示关系的目标。我们已在 `Game` 模型中创建了一个 `game_category` 字段，并希望将游戏类别的名称作为相关
    `GameCategory` 的描述（slug 字段）显示。因此，我们指定了 `''name''` 作为 `slug_field`。如果需要在可浏览的 API
    中的表单中显示相关游戏类别的可能选项，Django 将使用在 `queryset` 参数中指定的表达式检索所有可能的实例，并显示它们指定的 slug 字段。'
- en: 'The `GameCategorySerializer` class declares a `Meta` inner class that declares
    two attributes: `model` and `fields`. The `model` attribute specifies the model
    related to the serializer, that is, the `Game` class. The `fields` attribute specifies
    a tuple of string whose values indicate the field names that we want to include
    in the serialization from the related model. We just want to include the URL,
    and therefore, the code specified both `''url''` as a member of the tuple. The
    `game_category` field will specify the `name` field for the related `GameCategory`.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameCategorySerializer` 类声明了一个 `Meta` 内部类，该类声明了两个属性：`model` 和 `fields`。`model`
    属性指定了与序列器相关的模型，即 `Game` 类。`fields` 属性指定了一个字符串元组，其值表示我们希望在序列化相关模型时包含的字段名称。我们只想包含
    URL，因此代码将 `''url''` 作为元组的一个成员。`game_category` 字段将指定相关 `GameCategory` 的 `name`
    字段。'
- en: 'Now, add the following code to the `serializers.py` file to declare the `ScoreSerializer`
    class. The code file for the sample is included in the `restful_python_chapter_02_03`
    folder:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将以下代码添加到 `serializers.py` 文件中，以声明 `ScoreSerializer` 类。示例代码文件包含在 `restful_python_chapter_02_03`
    文件夹中：
- en: '[PRE57]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `ScoreSerializer` class is a subclass of the `HyperlinkedModelSerializer`
    class. We will use the `ScoreSerializer` class to serialize `PlayerScore` instances
    related to a `Player`, that is, to display all the scores for a specific player
    when we serialize a `Player`. We want to display all the details for the related
    `Game` but we don't include the related `Player` because the `Player` will use
    this `ScoreSerializer` serializer.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScoreSerializer` 类是 `HyperlinkedModelSerializer` 类的子类。我们将使用 `ScoreSerializer`
    类来序列化与 `Player` 相关的 `PlayerScore` 实例，即在我们序列化 `Player` 时显示特定玩家的所有分数。我们希望显示相关 `Game`
    的所有详细信息，但不包括相关 `Player`，因为 `Player` 将使用此 `ScoreSerializer` 序列器。'
- en: The `ScoreSerializer` class declares a `game` attribute as an instance of the
    previously coded `GameSerializer` class. We created the `game` field as a `models.ForeignKey`
    instance in the `PlayerScore` model and we want to serialize the same data for
    the game that we coded in the `GameSerializer` class.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScoreSerializer` 类声明了一个 `game` 属性，它是一个之前编写的 `GameSerializer` 类的实例。我们在 `PlayerScore`
    模型中创建了一个 `game` 字段，作为 `models.ForeignKey` 实例，并希望序列化与 `GameSerializer` 类中编写的游戏相同的数据。'
- en: 'The `ScoreSerializer` class declares a `Meta` inner class that declares two
    attributes: `model` and `fields`. The `model` attribute specifies the model related
    to the serializer, that is, the `PlayerScore` class. As previously explain, we
    don''t include the `''player''` field name in the `fields` tuple of string to
    avoid serializing the player again. We will use a `PlayerSerializer` as a master
    and the `ScoreSerializer` as the detail.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScoreSerializer` 类声明了一个 `Meta` 内部类，该类声明了两个属性：`model` 和 `fields`。`model` 属性指定了与序列器相关的模型，即
    `PlayerScore` 类。正如之前解释的那样，我们不在 `fields` 字符串元组中包含 `''player''` 字段名称，以避免再次序列化玩家。我们将使用
    `PlayerSerializer` 作为主序列器，而将 `ScoreSerializer` 作为详细序列器。'
- en: 'Now, add the following code to the `serializers.py` file to declare the `PlayerSerializer`
    class. The code file for the sample is included in the `restful_python_chapter_02_03`
    folder:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将以下代码添加到`serializers.py`文件中，以声明`PlayerSerializer`类。示例代码文件包含在`restful_python_chapter_02_03`文件夹中：
- en: '[PRE58]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `PlayerSerializer` class is a subclass of the `HyperlinkedModelSerializer`
    class. We will use the `PlayerSerializer` class to serialize `Player` instances
    and we will use the previously declared `ScoreSerializer` class to serialize all
    the `PlayerScore` instances related to the `Player`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerSerializer`类是`HyperlinkedModelSerializer`类的子类。我们将使用`PlayerSerializer`类来序列化`Player`实例，并使用之前声明的`ScoreSerializer`类来序列化与`Player`相关的所有`PlayerScore`实例。'
- en: The `PlayerSerializer` class declares a `scores` attribute as an instance of
    the previously coded `ScoreSerializer` class. The `many` argument is set to `True`
    because it is a one-to-many relationship. We use the `scores` name that we specified
    as the `related_name` string value when we created the `player` field as a `models.ForeignKey`
    instance in the `PlayerScore` model. This way, the `scores` field will render
    each `PlayerScore` that belongs to the `Player` using the previously declared
    `ScoreSerializer`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerSerializer`类声明了一个`scores`属性，作为之前编写的`ScoreSerializer`类的实例。`many`参数设置为`True`，因为它是一对多关系。我们使用在创建`PlayerScore`模型中的`player`字段时指定的`scores`名称作为`related_name`字符串值。这样，`scores`字段将使用之前声明的`ScoreSerializer`渲染属于`Player`的每个`PlayerScore`。'
- en: The `Player` model declared `gender` as an instance of `models.CharField` with
    the `choices` attribute set to the `Player.GENDER_CHOICES` string tuple. The `ScoreSerializer`
    class declares a `gender` attribute as an instance of `serializers.ChoiceField`
    with the `choices` argument set to the `Player.GENDER_CHOICES` string tuple. In
    addition, the class declares a `gender_description` attribute with `read_only`
    set to `True` and the `source` argument set to `'get_gender_display'`. The `source`
    string is built with `get_` followed by the field name, `gender`, and `_display`.
    This way, the read-only `gender_description` attribute will render the description
    for the gender choices instead of the single char stored values.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player`模型将`gender`声明为`models.CharField`的实例，其`choices`属性设置为`Player.GENDER_CHOICES`字符串元组。`ScoreSerializer`类声明一个`gender`属性，作为`serializers.ChoiceField`的实例，其`choices`参数设置为`Player.GENDER_CHOICES`字符串元组。此外，该类还声明了一个`gender_description`属性，将`read_only`设置为`True`，并将`source`参数设置为`''get_gender_display''`。`source`字符串是通过`get_`后跟字段名`gender`和`_display`构建的。这样，只读的`gender_description`属性将渲染性别选择的描述，而不是存储的单个字符值。'
- en: 'The `ScoreSerializer` class declares a `Meta` inner class that declares two
    attributes: `model` and `fields`. The `model` attribute specifies the model related
    to the serializer, that is, the `PlayerScore` class. As previously explained,
    we don''t include the `''player''` field name in the `fields` tuple of string
    to avoid serializing the player again. We will use a `PlayerSerializer` as a master
    and the `ScoreSerializer` as the detail.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScoreSerializer`类声明了一个`Meta`内部类，该类声明了两个属性：`model`和`fields`。`model`属性指定与序列化器相关的模型，即`PlayerScore`类。如前所述，我们不在`fields`字符串元组中包含`''player''`字段名，以避免再次序列化玩家。我们将使用`PlayerSerializer`作为主序列化器，将`ScoreSerializer`作为详细信息序列化器。'
- en: 'Finally, add the following code to the `serializers.py` file to declare the
    `PlayerScoreSerializer` class. The code file for the sample is included in the
    `restful_python_chapter_02_03` folder:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将以下代码添加到`serializers.py`文件中，以声明`PlayerScoreSerializer`类。示例代码文件包含在`restful_python_chapter_02_03`文件夹中：
- en: '[PRE59]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `PlayerScoreSerializer` class is a subclass of the `HyperlinkedModelSerializer`
    class. We will use the `PlayerScoreSerializer` class to serialize `PlayerScore`
    instances. Previously, we created the `ScoreSerializer` class to serialize `PlayerScore`
    instances as the detail of a player. We will use the new `PlayerScoreSerializer`
    class when we want to display the related player's name and the related game's
    name. In the other `serializer` class, we didn't include any information related
    to the player and we included all the details for the game.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerScoreSerializer`类是`HyperlinkedModelSerializer`类的子类。我们将使用`PlayerScoreSerializer`类来序列化`PlayerScore`实例。之前，我们创建了`ScoreSerializer`类来序列化`PlayerScore`实例作为玩家的详细信息。当我们想要显示相关玩家的姓名和相关游戏的名称时，我们将使用新的`PlayerScoreSerializer`类。在其他`serializer`类中，我们没有包含任何与玩家相关的信息，并包含了游戏的全部详细信息。'
- en: The `PlayerScoreSerializer` class declares a `player` attribute as an instance
    of `serializers.SlugRelatedField` with its `queryset` argument set to `Player.objects.all()`
    and its `slug_field` argument set to `'name'`. We created the `player` field as
    a `models.ForeignKey` instance in the `PlayerScore` model and we want to display
    the player's name as the description (slug field) for the related `Player`. Thus,
    we specified `'name'` as the `slug_field`. In case it is necessary to display
    the possible options for the related game category in a form in the browsable
    API, Django will use the expression specified in the `queryset` argument to retrieve
    all the possible players and display their specified slug field.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerScoreSerializer` 类声明了一个 `player` 属性，它是一个 `serializers.SlugRelatedField`
    的实例，其 `queryset` 参数设置为 `Player.objects.all()`，其 `slug_field` 参数设置为 `''name''`。我们在
    `PlayerScore` 模型中创建了一个 `player` 字段作为 `models.ForeignKey` 实例，并希望将玩家名称（slug 字段）作为相关
    `Player` 的描述（slug 字段）显示。因此，我们指定了 `''name''` 作为 `slug_field`。如果需要在可浏览的 API 中的表单中显示相关游戏类别的可能选项，Django
    将使用在 `queryset` 参数中指定的表达式检索所有可能的玩家并显示他们指定的 slug 字段。'
- en: The `PlayerScoreSerializer` class declares a `game` attribute as an instance
    of `serializers.SlugRelatedField` with its `queryset` argument set to `Game.objects.all()`
    and its `slug_field` argument set to `'name'`. We created the `game` field as
    a `models.ForeignKey` instance in the `PlayerScore` model and we want to display
    the game's name as the description (slug field) for the related `Game`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerScoreSerializer` 类声明了一个 `game` 属性，它是一个 `serializers.SlugRelatedField`
    的实例，其 `queryset` 参数设置为 `Game.objects.all()`，其 `slug_field` 参数设置为 `''name''`。我们在
    `PlayerScore` 模型中创建了一个 `game` 字段作为 `models.ForeignKey` 实例，并希望将游戏名称（slug 字段）作为相关
    `Game` 的描述（slug 字段）显示。'
- en: Creating class-based views and using generic classes
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基于类的视图和使用通用类
- en: 'This time, we will write our API views by declaring class-based views, instead
    of function-based views. We might code classes that inherit from the `rest_framework.views.APIView`
    class and declare methods with the same names than the HTTP verbs we want to process:
    `get`, `post`, `put`, `patch`, `delete`, and so on. These methods receive a `request`
    argument as happened with the functions that we created for the views. However,
    this approach would require us to write a lot of code. Instead, we can take advantage
    of a set of generic views that we can use as our base classes for our class-based
    views to reduce the required code to the minimum and take advantage of the behavior
    that has been generalized in Django REST Framework.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将通过声明基于类的视图来编写我们的 API 视图，而不是基于函数的视图。我们可能会编写继承自 `rest_framework.views.APIView`
    类的类，并声明与我们要处理的 HTTP 动词（`get`、`post`、`put`、`patch`、`delete` 等）具有相同名称的方法。这些方法接收一个
    `request` 参数，就像我们为视图创建的函数一样。然而，这种方法将需要我们编写大量代码。相反，我们可以利用一组通用视图，我们可以将它们用作我们基于类的视图的基础类，以将所需的代码量减少到最小，并利用
    Django REST Framework 中已泛化的行为。
- en: 'We will create subclasses of the two following generic class views declared
    in `rest_framework.generics`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建 `rest_framework.generics` 中声明的两个通用类视图的子类：
- en: '`ListCreateAPIView`: Implements the `get` method that retrieves a listing of
    a queryset and the `post` method that creates a model instance.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListCreateAPIView`：实现了 `get` 方法，用于检索查询集的列表，以及 `post` 方法，用于创建模型实例。'
- en: '`RetrieveUpdateDestroyAPIView`: Implements the `get`, `put`, `patch`, and `delete`
    methods to retreive, completely update, partially update or delete a model instance.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RetrieveUpdateDestroyAPIView`：实现了 `get`、`put`、`patch` 和 `delete` 方法，用于检索、完全更新、部分更新或删除模型实例。'
- en: 'Those two generic views are composed by combining reusable bits of behavior
    in Django REST Framework implemented as mixin classes declared in `rest_framework.mixins`.
    We can create a class that uses multiple inheritance and combine the features
    provided by many of these mixin classes. The following line shows the declaration
    of the `ListCreateAPIView` class as the composition of `ListModelMixin`, `CreateModelMixin`
    and `rest_framework.generics.GenericAPIView`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个通用视图是通过组合 Django REST Framework 中实现的 mixin 类的可重用行为来构成的，这些 mixin 类在 `rest_framework.mixins`
    中声明。我们可以创建一个使用多继承的类，结合许多这些 mixin 类提供的功能。以下行显示了 `ListCreateAPIView` 类的声明，作为 `ListModelMixin`、`CreateModelMixin`
    和 `rest_framework.generics.GenericAPIView` 的组合：
- en: '[PRE60]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The following line shows the declaration of the `RetrieveUpdateDestroyAPIView`
    class as the composition of `RetrieveModelMixin`, `UpdateModelMixin`, `DestroyModelMixin`
    and `rest_framework.generics.GenericAPIView`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了 `RetrieveUpdateDestroyAPIView` 类的声明，它是 `RetrieveModelMixin`、`UpdateModelMixin`、`DestroyModelMixin`
    和 `rest_framework.generics.GenericAPIView` 的组合：
- en: '[PRE61]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now, we will create a Django class based views that will use the previously
    explained generic classes and the serializer classes to return JSON representations
    for each HTTP request that our API will handle. We will just have to specify a
    `queryset` that retrieves all the objects in the `queryset` attribute and the
    serializer class in the `serializer_class` attribute for each subclass that we
    declare. The generic classes will do the rest for us. In addition, we will declare
    a `name` attribute with the string name we will use to identify the view.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个 Django 类视图，它将使用之前解释过的通用类和序列化器类来为我们的 API 将要处理的每个 HTTP 请求返回 JSON 表示。我们只需指定一个
    `queryset`，它检索 `queryset` 属性中的所有对象，并在每个声明的子类中指定 `serializer_class` 属性。通用类将为我们完成剩余的工作。此外，我们还将声明一个
    `name` 属性，使用该字符串名称来识别视图。
- en: Taking advantage of generic class based views
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用基于通用类的视图
- en: 'Go to the `gamesapi/games` folder and open the `views.py` file. Replace the
    code in this file with the following code that declares the required imports and
    the class based views. We will add more classes to this file later. The code file
    for the sample is included in the `restful_python_chapter_02_03` folder:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 `gamesapi/games` 文件夹并打开 `views.py` 文件。用以下代码替换此文件中的代码，该代码声明所需的导入和类视图。我们稍后会向此文件添加更多类。示例的代码文件包含在
    `restful_python_chapter_02_03` 文件夹中：
- en: '[PRE62]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The following table summarizes the methods that each class-based view is going
    to process:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了每个基于类的视图将要处理的方法：
- en: '| **Scope** | **Class based view name** | **HTTP verbs that it will process**
    |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| **范围** | **类视图名称** | **它将处理的 HTTP 动词** |'
- en: '| Collection of game categories-`/game-categories/` | `GameCategoryList` |
    `GET` and `POST` |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 游戏类别集合-`/game-categories/` | `GameCategoryList` | `GET` 和 `POST` |'
- en: '| Game category-`/game-category/{id}/` | `GameCategoryDetail` | `GET`, `PUT`,
    `PATCH` and `DELETE` |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 游戏类别-`/game-category/{id}/` | `GameCategoryDetail` | `GET`, `PUT`, `PATCH`
    和 `DELETE` |'
- en: '| Collection of games-`/games/` | `GameList` | `GET` and `POST` |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| 游戏集合-`/games/` | `GameList` | `GET` 和 `POST` |'
- en: '| Game-`/game/{id}/` | `GameDetail` | `GET`, `PUT`, `PATCH` and `DELETE` |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 游戏-`/game/{id}/` | `GameDetail` | `GET`, `PUT`, `PATCH` 和 `DELETE` |'
- en: '| Collection of players-`/players/` | `PlayerList` | `GET` and `POST` |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 玩家集合-`/players/` | `PlayerList` | `GET` 和 `POST` |'
- en: '| Player-`/player/{id}/` | `PlayerDetail` | `GET`, `PUT`, `PATCH` and `DELETE`
    |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 玩家-`/player/{id}/` | `PlayerDetail` | `GET`, `PUT`, `PATCH` 和 `DELETE` |'
- en: '| Collection of scores-`/player-scores/` | PlayerScoreList | `GET` and `POST`
    |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 分数集合-`/player-scores/` | PlayerScoreList | `GET` 和 `POST` |'
- en: '| Score-`/player-score/{id}/` | PlayerScoreDetail | `GET`, `PUT`, `PATCH` and
    `DELETE` |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 分数-`/player-score/{id}/` | PlayerScoreDetail | `GET`, `PUT`, `PATCH` 和 `DELETE`
    |'
- en: In addition, we will be able to execute the `OPTIONS` HTTP verb on any of the
    scopes.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将能够在任何范围内执行 `OPTIONS` HTTP 动词。
- en: Working with endpoints for the API
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 API 的端点一起工作
- en: We want to create an endpoint for the root of our API to make it easier to browse
    the API with the browsable API feature and understand how everything works. Add
    the following code to the `views.py` file to declare the `ApiRoot` class. The
    code file for the sample is included in the `restful_python_chapter_02_03` folder.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望为 API 的根创建一个端点，以便更容易地使用可浏览的 API 功能浏览 API 并了解其工作原理。将以下代码添加到 `views.py` 文件中，以声明
    `ApiRoot` 类。示例的代码文件包含在 `restful_python_chapter_02_03` 文件夹中。
- en: '[PRE63]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `ApiRoot` class is a subclass of the `rest_framework.generics.GenericAPIView`
    class and declares the get method. The `GenericAPIView` class is the base class
    for all the other generic views. The `ApiRoot` class defines the `get` method
    that returns a `Response` object with key-value pairs of string that provide a
    descriptive name for the view and its URL, generated with the `rest_framework.reverse.reverse`
    function. This URL resolver function returns a fully qualified URL for the view.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApiRoot` 类是 `rest_framework.generics.GenericAPIView` 类的子类，并声明了 `get` 方法。`GenericAPIView`
    类是所有其他通用视图的基类。`ApiRoot` 类定义了返回 `Response` 对象的 `get` 方法，该对象包含字符串键值对，为视图及其 URL 提供描述性名称，该
    URL 由 `rest_framework.reverse.reverse` 函数生成。此 URL 解析函数返回视图的完全限定 URL。'
- en: 'Go to the `gamesapi/games` folder and open the `urls.py` file. Replace the
    code in this file with the following code. The following lines show the code for
    this file that defines the URL patterns that specifies the regular expressions
    that have to be matched in the request to run a specific method for a class-based
    view defined in the `views.py` file. Instead of specifying a function that represents
    a view we call the `as_view` method for the class-based view. We use the `as_view`
    method. The code file for the sample is included in the `restful_python_chapter_02_03`
    folder:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 前往`gamesapi/games`文件夹并打开`urls.py`文件。用以下代码替换此文件中的代码。以下行显示了此文件的代码，该代码定义了URL模式，该模式指定了请求中必须匹配的正则表达式，以便运行在`views.py`文件中定义的基于类的视图的特定方法。我们不是指定表示视图的函数，而是调用基于类的视图的`as_view`方法。我们使用`as_view`方法。示例代码文件包含在`restful_python_chapter_02_03`文件夹中：
- en: '[PRE64]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: When we coded our previous version of the API, we replaced the code in the `urls.py`
    file in the `gamesapi` folder, specifically, the `gamesapi/urls.py` file. We made
    the necessary changes to define the root URL configuration and include the URL
    pattern declared in the previously coded `games/urls.py` file.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写我们之前的API版本时，我们在`gamesapi`文件夹中的`urls.py`文件中替换了代码，具体来说，是`gamesapi/urls.py`文件。我们对根URL配置进行了必要的修改，并包含了之前编写的`games/urls.py`文件中声明的URL模式。
- en: 'Now, we can launch Django''s development server to compose and send HTTP requests
    to our still unsecure, yet much more complex Web API (we will definitely add security
    later). Execute any of the following two commands based on your needs to access
    the API in other devices or computers connected to your LAN. Remember that we
    analyzed the difference between them in [Chapter 1](ch01.html "Chapter 1. Developing
    RESTful APIs with Django"), *Developing RESTful APIs with Django*:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动Django的开发服务器，以编写和发送HTTP请求到我们仍然不安全的，但更加复杂的Web API（我们肯定会稍后添加安全性）。根据您的需求执行以下两个命令之一，以在其他连接到您的局域网的设备或计算机上访问API。请记住，我们在[第1章](ch01.html
    "第1章。使用Django开发RESTful API")中分析了它们之间的差异，*使用Django开发RESTful API*：
- en: '[PRE65]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: After we run any of the previous commands, the development server will start
    listening at port `8000`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行之前的任何命令后，开发服务器将开始监听端口`8000`。
- en: 'Open a web browser and enter `http://localhost:8000/` or the appropriate URL
    in case you are using another computer or device to access the browsable API.
    The browsable API will compose and send a `GET` request to `/` and will display
    the results of its execution, that is, the headers and the JSON response from
    the execution of the `get` method defined in the `ApiRoot` class within the `views.py`
    file. The following screenshot shows the rendered web page after entering the
    URL in a web browser with the resource description: **Api Root**.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个网页浏览器并输入`http://localhost:8000/`或您使用另一台计算机或设备访问可浏览API的适当URL。可浏览的API将编写并发送一个`GET`请求到`/`，并将显示其执行的输出结果，即从`views.py`文件中定义的`ApiRoot`类执行的`get`方法的头部和JSON响应。以下截图显示了在网页浏览器中输入URL后的渲染网页，资源描述为：**API根**。
- en: The API Root provides us hyperlinks to see the list of game categories, games,
    players, and scores. This way, it becomes extremely easy to access the lists and
    perform operations on the different resources through the browsable API. In addition,
    when we visit the other URLs, the breadcrumb will allow us to go back to the **Api
    Root**.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: API根提供了查看游戏类别、游戏、玩家和得分的超链接。这样，通过可浏览的API访问列表并执行不同资源上的操作变得极其容易。此外，当我们访问其他URL时，面包屑导航将允许我们返回到**API根**。
- en: In this new version of the API, we worked with the generic views that provide
    many featured under the hoods, and therefore, the browsable API will provide us
    additional features compared with the previous version. Click or tap on the URL
    on the right-hand side of **game-categories**. In case you are browsing in localhost,
    the URL will be `http://localhost:8000/game-categories/`. The browsable API will
    render the web page for the **Game Category List**.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个API的新版本中，我们使用了提供许多功能的通用视图，因此，可浏览的API将比之前的版本提供更多功能。点击或轻触**游戏类别**右侧的URL。如果你在本地主机上浏览，URL将是`http://localhost:8000/game-categories/`。可浏览的API将渲染**游戏类别列表**的网页。
- en: 'At the bottom of the rendered web page, the browsable API provides us some
    controls to generate a `POST` request to `/game-categories/`. In this case, by
    default, the browsable API displays the HTML form tab with an automatically generated
    form that we can use to generate a POST request without having to deal with the
    raw data as we did in our previous version. The HTML forms make it easy to generate
    requests to test our API. The following screenshot shows the HTML form to create
    a new game category:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染的网页底部，可浏览的API为我们提供了一些控件来生成一个`POST`请求到`/game-categories/`。在这种情况下，默认情况下，可浏览的API显示HTML表单标签，其中包含一个自动生成的表单，我们可以使用它来生成POST请求，而无需像我们之前版本那样处理原始数据。HTML表单使得生成测试API的请求变得容易。以下截图显示了创建新游戏类别的HTML表单：
- en: '![Working with endpoints for the API](img/image_02_004.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![处理API端点](img/image_02_004.jpg)'
- en: 'We just need to enter the desired name, **3D RPG**, in the **Name** textbox
    and click or tap on **POST** to create a new game category. The browsable API
    will compose and send a `POST` request to `/game-categories/` with the previously
    specified data and we will see the results of the call in the web browser. The
    following screenshot shows a web browser displaying the HTTP status code `201
    Created` in the response and the previously explained HTML form with the **POST**
    button to allow us to continue composing and sending `POST` requests to `/game-categories/`:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需在**名称**文本框中输入所需的名称，**3D RPG**，然后点击或轻触**POST**按钮来创建一个新的游戏类别。可浏览的API将组合并发送一个`POST`请求到`/game-categories/`，并在网页浏览器中显示调用结果。以下截图显示了网页浏览器显示的HTTP状态码`201
    Created`以及之前解释的带有**POST**按钮的HTML表单，允许我们继续在`/game-categories/`上组合和发送`POST`请求：
- en: '![Working with endpoints for the API](img/image_02_005.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![处理API端点](img/image_02_005.jpg)'
- en: Now, click on the URL displayed as a value for the url key in the JSON data
    displayed for the game category, such as `http://localhost:8000/game-categories/3/`.
    Make sure you replace 2 with the id or primary key of an existing game category
    in the previously rendered **Games List**. The browsable API will compose and
    send a `GET` request to `/game-categories/3/` and will display the results of
    its execution, that is, the headers and the JSON data for the game category. The
    web page will display a **DELETE** button because we are working with the **Game
    Category Detail** view.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击显示在JSON数据中url键值的URL，例如`http://localhost:8000/game-categories/3/`。确保将2替换为之前渲染的**游戏列表**中现有游戏类别的id或主键。可浏览的API将组合并发送一个`GET`请求到`/game-categories/3/`，并将显示其执行结果，即游戏类别的头部和JSON数据。网页将显示一个**删除**按钮，因为我们正在处理**游戏类别详情**视图。
- en: Tip
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We can use the breadcrumb to go back to the Api Root and start creating games
    related to a game category, players, and finally scores related to a game and
    a player. We can do all this with easy to use HTML forms and the browsable API
    feature.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用面包屑导航回到API根目录，并开始创建与游戏类别、玩家和最终与游戏及玩家相关的分数相关的游戏。我们可以通过易于使用的HTML表单和可浏览的API功能完成所有这些操作。
- en: Creating and retrieving related resources
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和检索相关资源
- en: Now, we will use the HTTPie command or its curl equivalents to compose and send
    HTTP requests to the API. We will use JSON for the requests that require additional
    data. Remember that you can perform the same tasks with your favorite GUI-based
    tool or with the browsable API.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用HTTPie命令或其curl等价物来组合并发送HTTP请求到API。我们将使用JSON进行需要额外数据的请求。记住，你可以使用你喜欢的基于GUI的工具或使用可浏览的API执行相同的任务。
- en: First, we will compose and send an HTTP request to create a new game category.
    Remember that we used the browsable API to create a game category named `'3D RPG'`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将组合并发送一个HTTP请求来创建一个新的游戏类别。记住，我们使用可浏览的API创建了一个名为`'3D RPG'`的游戏类别。
- en: '[PRE66]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE67]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The preceding command will compose and send a `POST` HTTP request with the
    specified JSON key-value pair. The request specifies `/game-categories/`, and
    therefore, it will match `''^game-categories/$''` and run the `post` method for
    the `views.GameCategoryList` class-based view. Remember that the method is defined
    in the `ListCreateAPIView` superclass and it ends up calling the create method
    defined in `mixins.CreateModelMixin`. If the new `GameCategory` instance was successfully
    persisted in the database, the call to the method will return an `HTTP 201 Created`
    status code and the recently persisted `GameCategory` serialized to JSON in the
    response body. The following line shows a sample response for the HTTP request
    with the new `GameCategory` object in the JSON response. The response doesn''t
    include the header. Note that the response includes both the primary key, `pk`,
    and the url, `url`, for the created category. The `games` array is empty because
    there aren''t games related to the new category yet:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将组合并发送一个带有指定 JSON 键值对的 `POST` HTTP 请求。请求指定 `/game-categories/`，因此它将匹配 `'^game-categories/$'`
    并运行 `views.GameCategoryList` 类视图的 `post` 方法。请记住，该方法是在 `ListCreateAPIView` 超类中定义的，并最终调用在
    `mixins.CreateModelMixin` 中定义的创建方法。如果新的 `GameCategory` 实例成功持久化到数据库中，对该方法的调用将返回
    `HTTP 201 Created` 状态码，并将最近持久化的 `GameCategory` 序列化为 JSON 的响应体。以下一行显示了带有新 `GameCategory`
    对象的 HTTP 请求的样本响应。响应不包括头部信息。请注意，响应包括创建的类别的 `pk` 和 `url`。`games` 数组为空，因为没有与新类别相关的游戏：
- en: '[PRE68]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, we will compose and send HTTP requests to create two games that belong
    to the first category we recently created: `3D RPG`. We will specify the `game_category`
    value with the name of the desired `game category`. However, the database table
    that persists the `Game` model will save the value of the primary key of the related
    `GameCategory` whose name value matches the one we provide:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将组合并发送 HTTP 请求来创建属于我们最近创建的第一个类别 `3D RPG` 的两个游戏。我们将指定 `game_category` 的值为所需的
    `game category` 名称。然而，持久化 `Game` 模型的数据库表将保存与提供的名称值匹配的相关 `GameCategory` 的主键值：
- en: '[PRE69]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The following are the equivalent `curl` commands:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE70]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The previous commands will compose and send two `POST` HTTP requests with the
    specified JSON key-value pairs. The request specifies `/games/`, and therefore,
    it will match `''^games/$''` and run the `post` method for the `views.GameList`
    class-based view. The following lines show sample responses for the two HTTP requests
    with the new `Game` objects in the JSON responses. The responses don''t include
    the headers. Note that the response includes only the url, `url`, for the created
    games and doesn''t include the primary key. The value for `game_category` is the
    `name` for the related `GameCategory`:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送两个带有指定 JSON 键值对的 `POST` HTTP 请求。请求指定 `/games/`，因此它将匹配 `'^games/$'`
    并运行 `views.GameList` 类视图的 `post` 方法。以下几行显示了两个 HTTP 请求的样本响应，其中包含 JSON 响应中的新 `Game`
    对象。响应不包括头部信息。请注意，响应只包括创建的游戏的 `url`，不包括主键。`game_category` 的值是相关 `GameCategory`
    的 `name`：
- en: '[PRE71]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We can run the previously explained commands to check the contents of the tables
    that Django created in the PostgreSQL database. We will notice that the `game_category_id`
    column for the `games_game` table saves the value of the primary key of the related
    row in the `games_game_category` table. The `GameSerializer` class uses the `SlugRelatedField`
    to display the name value for the related `GameCategory`. The following screenshot
    shows the contents of the `games_game_category` and the `games_game` table in
    a PostgreSQL database after running the HTTP requests:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行之前解释过的命令来检查 Django 在 PostgreSQL 数据库中创建的表的内容。我们会注意到，`games_game` 表的 `game_category_id`
    列保存了 `games_game_category` 表中相关行的主键值。`GameSerializer` 类使用 `SlugRelatedField` 来显示相关
    `GameCategory` 的名称值。以下截图显示了在运行 HTTP 请求后 PostgreSQL 数据库中 `games_game_category`
    和 `games_game` 表的内容：
- en: '![Creating and retrieving related resources](img/image_02_006.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![创建和检索相关资源](img/image_02_006.jpg)'
- en: 'Now, we will compose and send an HTTP request to retrieve the game category
    that is contains two games, that is the game category resource whose id or primary
    key is equal to `3`. Don''t forget to replace `3` with the primary key value of
    the game whose name is equal to `''3D RPG''` in your configuration:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将组合并发送一个 HTTP 请求来检索包含两个游戏的游戏类别，即 ID 或主键等于 `3` 的游戏类别资源。不要忘记将 `3` 替换为您配置中名称等于
    `'3D RPG'` 的游戏的主键值：
- en: '[PRE72]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The following is the equivalent curl command:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 curl 命令：
- en: '[PRE73]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/game-categories/3/`. The request has a number after `/game-categories/`,
    and therefore, it will match `''^game-categories/(?P<pk>[0-9]+)/$''` and run the
    `get` method for the `views.GameCategoryDetail` class based view. Remember that
    the method is defined in the `RetrieveUpdateDestroyAPIView` superclass and it
    ends up calling the `retrieve` method defined in `mixins.RetrieveModelMixin`.
    The following lines show a sample response for the HTTP request, with the `GameCategory`
    object and the hyperlinks of the related games in the JSON response:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将编写并发送以下 HTTP 请求：`GET http://localhost:8000/game-categories/3/`。请求在 `/game-categories/`
    后面有一个数字，因此它将匹配 `'^game-categories/(?P<pk>[0-9]+)/$'` 并运行基于 `views.GameCategoryDetail`
    类视图的 `get` 方法。请记住，该方法是在 `RetrieveUpdateDestroyAPIView` 超类中定义的，并最终调用在 `mixins.RetrieveModelMixin`
    中定义的 `retrieve` 方法。以下几行显示了 HTTP 请求的样本响应，其中包含 JSON 响应中的 `GameCategory` 对象和相关游戏的超链接：
- en: '[PRE74]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The `GameCategorySerializer` class defined the `games` attribute as a `HyperlinkedRelatedField`,
    and therefore, the serializer renders the URL for each related `Game` instance
    in the value for the `games` array. If we view the results in a web browser through
    the browsable API, we will be able to click or tap on the hyperlink to see the
    details for each game.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameCategorySerializer` 类将 `games` 属性定义为 `HyperlinkedRelatedField`，因此序列化器会在
    `games` 数组的值中渲染每个相关 `Game` 实例的 URL。如果我们通过可浏览的 API 在网页浏览器中查看结果，我们将能够点击或轻触超链接以查看每个游戏的详细信息。'
- en: 'Now, we will compose and send a `POST` HTTP request to create a game related
    to a game category name that doesn''t exist: `''Virtual reality''`:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送一个创建与不存在游戏类别名称相关的游戏的 `POST` HTTP 请求：`'Virtual reality'`：
- en: '[PRE75]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The following is the equivalent curl command:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 curl 命令：
- en: '[PRE76]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Django won''t be able to retrieve a `GameCategory` instance whose `name` is
    equal to the specified value, and therefore, we will receive a `400 Bad Request`
    status code in the response header and a message related to the value specified
    in for `game_category` in the JSON body. The following lines show a sample response:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: Django 无法检索一个 `name` 等于指定值的 `GameCategory` 实例，因此我们将在响应头部收到 `400 Bad Request`
    状态码，并在 JSON 体的 `game_category` 中指定相关消息。以下几行显示了样本响应：
- en: '[PRE77]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, we will compose and send HTTP requests to create two players:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送 HTTP 请求来创建两个玩家：
- en: '[PRE78]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The following are the equivalent `curl` commands:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE79]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The previous commands will compose and send two `POST` HTTP requests with the
    specified JSON key-value pairs. The request specifies `/players/`, and therefore,
    it will match `''^players/$''` and run the `post` method for the `views.PlayerList`
    class based view. The following lines show sample responses for the two HTTP requests
    with the new `Player` objects in the JSON responses. The responses don''t include
    the headers. Notice that the response includes only the url, `url`, for the created
    players and doesn''t include the primary key. The value for `gender_description`
    is the choice description for the `gender` char. The `scores` array is empty because
    there aren''t scores related to each new player yet:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将编写并发送两个带有指定 JSON 键值对的 `POST` HTTP 请求。请求指定 `/players/`，因此它将匹配 `'^players/$'`
    并运行 `views.PlayerList` 类视图的 `post` 方法。以下几行显示了两个 HTTP 请求的样本响应，其中包含 JSON 响应中的新 `Player`
    对象。响应不包括头部信息。注意，响应仅包括创建的玩家的 `url`，而不包括主键。`gender_description` 的值是 `gender` 字段的选项描述。`scores`
    数组为空，因为没有与每个新玩家相关的分数：
- en: '[PRE80]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, we will compose and send HTTP requests to create four scores:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送 HTTP 请求来创建四个分数：
- en: '[PRE81]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The following are the equivalent curl commands:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 curl 命令：
- en: '[PRE82]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The previous commands will compose and send four `POST` HTTP requests with the
    specified JSON key-value pairs. The request specifies `/player-scores/`, and therefore,
    it will match `'^player-scores/$'` and run the `post` method for the `views.PlayerScoreList`
    class based view. The following lines show sample responses for the four HTTP
    requests with the new `Player` objects in the JSON responses. The responses don't
    include the headers.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将编写并发送四个带有指定 JSON 键值对的 `POST` HTTP 请求。请求指定 `/player-scores/`，因此它将匹配 `'^player-scores/$'`
    并运行 `views.PlayerScoreList` 类视图的 `post` 方法。以下几行显示了四个 HTTP 请求的样本响应，其中包含 JSON 响应中的新
    `Player` 对象。响应不包括头部信息。
- en: 'Django REST Framework uses the `PlayerScoreSerializer` class to generate the
    JSON response. Thus, the value for `game` is the name for the related `Game` instance
    and the value for `player` is the name for the related `Player` instance. The
    `PlayerScoreSerializer` class used `SlugRelatedField` for both fields:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Django REST Framework使用`PlayerScoreSerializer`类来生成JSON响应。因此，`game`的值是相关`Game`实例的名称，而`player`的值是相关`Player`实例的名称。`PlayerScoreSerializer`类为这两个字段都使用了`SlugRelatedField`：
- en: '[PRE83]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We can run the previously explained commands to check the contents of the tables
    that Django created in the PostgreSQL database. We will notice that the `game_id`
    column for the `games_playerscore` table saves the value of the primary key of
    the related row in the `games_game` table. In addition, the `player_id` column
    for the `games_playerscore` table saves the value of the primary key of the related
    row in the `games_player` table. The following screenshot shows the contents for
    the `games_game_category`, `games_game`, `games_player` and `games_playerscore`
    tables in a PostgreSQL database after running the HTTP requests:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行之前解释的命令来检查Django在PostgreSQL数据库中创建的表的内容。我们会注意到`games_playerscore`表的`game_id`列保存了`games_game`表中相关行的主键值。此外，`games_playerscore`表的`player_id`列保存了`games_player`表中相关行的主键值。以下截图显示了在运行HTTP请求后，PostgreSQL数据库中`games_game_category`、`games_game`、`games_player`和`games_playerscore`表的内容：
- en: '![Creating and retrieving related resources](img/image_02_007.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![创建和检索相关资源](img/image_02_007.jpg)'
- en: 'Now, we will compose and send an HTTP request to retrieve a specific player
    that contains two scores, which is the player resource whose id or primary key
    is equal to `3`. Don''t forget to replace `3` with the primary key value of the
    player whose name is equal to `''Kevin''` in your configuration:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将组合并发送一个HTTP请求来检索包含两个分数的特定玩家，该玩家的id或主键等于`3`。不要忘记将`3`替换为配置中名称等于`'Kevin'`的玩家的主键值：
- en: '[PRE84]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The following is the equivalent curl command:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的curl命令：
- en: '[PRE85]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/players/3/`. The request has a number after `/players/`,
    and therefore, it will match `''^players/(?P<pk>[0-9]+)/$''` and run the `get`
    method for the `views.PlayerDetail` class based view. Remember that the method
    is defined in the `RetrieveUpdateDestroyAPIView` superclass and it ends up calling
    the `retrieve` method defined in `mixins.RetrieveModelMixin`. The following lines
    show a sample response for the HTTP request, with the `Player` object, the related
    `PlayerScore` objects and the `Game` object related to each `PlayerScore` object
    in the JSON response:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送以下HTTP请求：`GET http://localhost:8000/players/3/`。请求在`/players/`之后有一个数字，因此，它将匹配`'^players/(?P<pk>[0-9]+)/$'`并运行`views.PlayerDetail`类的视图方法。记住，该方法是在`RetrieveUpdateDestroyAPIView`超类中定义的，并且最终调用在`mixins.RetrieveModelMixin`中定义的`retrieve`方法。以下行显示了HTTP请求的示例响应，其中包含`Player`对象、相关的`PlayerScore`对象以及与每个`PlayerScore`对象相关的`Game`对象，在JSON响应中：
- en: '[PRE86]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `PlayerSerializer` class defined the `scores` attribute as a `ScoreSerializer`
    with `many` equal to `True`, and therefore, this serializer renders each score
    related to the player. The `ScoreSerializer` class defined the `game` attribute
    as a `GameSerializer`, and therefore, this serializer renders each game related
    to the score. If we view the results in a web browser through the browsable API,
    we will be able to click or tap on the hyperlink of each of the related resources.
    However, in this case, we also see all their details without having to follow
    the hyperlink.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerSerializer`类将`scores`属性定义为具有`many=True`的`ScoreSerializer`，因此，这个序列化器渲染与玩家相关的每个分数。`ScoreSerializer`类将`game`属性定义为`GameSerializer`，因此，这个序列化器渲染与分数相关的每个游戏。如果我们通过可浏览的API在网页浏览器中查看结果，我们将能够点击或轻触每个相关资源的超链接。然而，在这种情况下，我们还可以看到所有它们的详细信息，而无需跟随超链接。'
- en: Test your knowledge
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'Under the hoods, the `@api_view` decorator is:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内部，`@api_view` 装饰器是：
- en: A wrapper that converts a function-based view into a subclass of the `rest_framework.views.APIView`
    class.
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个将基于函数的视图转换为`rest_framework.views.APIView`类子类的包装器。
- en: A wrapper that converts a function-based view into a serializer.
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个将基于函数的视图转换为序列化器的包装器。
- en: A wrapper that converts a function-based view into a subclass of the `rest_framework.views.api_view`
    class.
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个将基于函数的视图转换为`rest_framework.views.api_view`类子类的包装器。
- en: 'The browsable API, a feature included in Django REST Framework that:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可浏览的API，这是Django REST Framework中包含的一个特性：
- en: Generates human-friendly JSON output for each resource whenever the request
    specifies `application/json` as the value for the `Content-type` key in the request
    header.
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当请求指定请求头中的`Content-type`键值为`application/json`时，为每个资源生成人类友好的JSON输出。
- en: Generates human-friendly HTML output for each resource whenever the request
    specifies `text/html` as the value for the `Content-type` key in the request header.
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当请求指定请求头中的`Content-type`键值为`text/html`时，为每个资源生成人类友好的HTML输出。
- en: Generates human-friendly HTML output for each resource whenever the request
    specifies `application/json` as the value for the `Content-type` key in the request
    header.
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当请求指定请求头中的`Content-type`键值为`application/json`时，为每个资源生成人类友好的JSON输出。
- en: 'The `rest_framework.serializers.ModelSerializer` class:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rest_framework.serializers.ModelSerializer`类：'
- en: Automatically populates both a set of default constraints and a set of default
    parsers.
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动填充一组默认约束和一组默认解析器。
- en: populates both a set of default fields but doesn't automatically populate a
    set of default validators.
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动填充一组默认字段，但不会自动填充一组默认验证器。
- en: Automatically populates both a set of default fields but doesn't automatically
    populate a set of default validators. Automatically populates both a set of default
    fields and a set of default validators.
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动填充一组默认字段，但不会自动填充一组默认验证器。自动填充一组默认字段和一组默认验证器。
- en: 'The `rest_framework.serializers.ModelSerializer` class:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rest_framework.serializers.ModelSerializer`类：'
- en: Provides default implementations for the `get` and `patch` methods.
  id: totrans-405
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`get`和`patch`方法提供默认实现。
- en: Provides default implementations for the `get` and `put` methods.
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`get`和`put`方法提供默认实现。
- en: Provides default implementations for the `create` and `update` methods.
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`create`和`update`方法提供默认实现。
- en: 'The `Serializer` and `ModelSerializer` classes in Django REST Framework are
    similar to the following two classes in Django Web Framework:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Django REST Framework中的`Serializer`和`ModelSerializer`类类似于Django Web Framework中的以下两个类：
- en: '`Form` and `ModelForm` classes.'
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Form`和`ModelForm`类。'
- en: '`View` and `ModelView` classes.'
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`View`和`ModelView`类。'
- en: '`Controller` and `ModelController` classes.'
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Controller`和`ModelController`类。'
- en: Summary
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took advantage of the various features included in Django
    REST Framework that allowed us to eliminate duplicate code and build our API reusing
    generalized behaviors. We used model serializers, wrappers, default parsing, and
    rendering options, class based views, and generic classes.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们利用了Django REST Framework中包含的各种特性，这些特性使我们能够消除重复代码并重用通用行为来构建我们的API。我们使用了模型序列化器、包装器、默认解析和渲染选项、基于类的视图和通用类。
- en: We used the browsable API feature and we designed a RESTful API that interacted
    with a complex PostgreSQL database. We declared relationships with the models,
    managed serialization and deserialization with relationships, and hyperlinks.
    Finally, we created and retrieved related resources and we understood how things
    work under the hoods.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了可浏览的API特性，并设计了一个与复杂的PostgreSQL数据库交互的RESTful API。我们声明了与模型的关联，使用关系管理序列化和反序列化，以及超链接。最后，我们创建了相关资源并检索了它们，我们理解了内部的工作原理。
- en: Now that we have built a complex API with Django REST Framework, we will use
    additional abstractions included in the framework to improve our API, we will
    add security and authentication, which is what we are going to discuss in the
    next chapter.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用Django REST Framework构建了一个复杂的API，我们将使用框架中包含的额外抽象来改进我们的API，我们将添加安全和认证，这是我们将在下一章讨论的内容。
