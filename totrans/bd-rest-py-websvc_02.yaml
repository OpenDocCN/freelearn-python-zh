- en: Chapter 2.  Working with Class-Based Views and Hyperlinked APIs in Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will expand the capabilities of the RESTful API that we
    started in the previous chapter. We will change the ORM settings to work with
    a more powerful PostgreSQL database and we will take advantage of the advanced
    features included in Django REST Framework that allow us to reduce the boilerplate
    code for complex APIs, such as class-based views. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Use model serializers to eliminate duplicate code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with wrappers to write API views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the default parsing and rendering options and move beyond JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browse the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design a RESTful API to interact with a complex PostgreSQL database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the tasks performed by each `HTTP` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare relationships with the models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage serialization and deserialization with relationships and hyperlinks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create class based views and use generic classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with endpoints for the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and retrieve related resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using model serializers to eliminate duplicate code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `GameSerializer` class declares many attributes with the same names that
    we used in the `Game` model and repeats information, such as the types and the
    `max_length` values. The `GameSerializer` class is a subclass of `rest_framework.serializers.Serializer`,
    it declares attributes that we manually mapped to the appropriate types and overrides
    the `create` and `update` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will create a new version of the `GameSerializer` class that will inherit
    from the `rest_framework.serializers.ModelSerializer` class. The `ModelSerializer`
    class automatically populates both set of default fields and a set of default
    validators. In addition, the class provides default implementations for the `create`
    and `update` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In case you have any experience with Django Web Framework, you will notice that
    the `Serializer` and `ModelSerializer` classes are similar to the `Form` and `ModelForm`
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go to the `gamesapi/games` folder and open the `serializers.py` file.
    Replace the code in this file with the following code, that declares the new version
    of the `GameSerializer` class. The code file for the sample is included in the
    `restful_python_chapter_02_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The new `GameSerializer` class declares a `Meta` inner class that declares
    two attributes: `model` and `fields`. The `model` attribute specifies the model
    related to the serializer, that is, the `Game` class. The `fields` attribute specifies
    a tuple of string whose values indicate the field names that we want to include
    in the serialization from the related model.'
  prefs: []
  type: TYPE_NORMAL
- en: There is no need to override either `create` or `update` methods because the
    generic behavior will be enough in this case. The `ModelSerializer` superclass
    provides implementations for both methods.
  prefs: []
  type: TYPE_NORMAL
- en: We have reduced the boilerplate code that we didn't require in the `GameSerializer`
    class. We just needed to specify the desired set of fields in a tuple. Now, the
    types related to the game fields are included only in the `Game` class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Press *Ctrl + C* to quit Django''s development server and execute the following
    command to start it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Working with wrappers to write API views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our code in the `games/views.py` file declared a `JSONResponse` class and two
    function-based views. These functions returned `JSONResponse` when it was necessary
    to return JSON data and a `django.Http.Response.HttpResponse` instance when the
    response was just of an HTTP status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter the accepted content type specified in the HTTP request header, the
    view functions always provide the same content in the response body-JSON. Run
    the following two commands to retrieve all the games with different values for
    the `Accept` request header-`text/html` and `application/json` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the equivalent curl commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding commands will compose and send the following HTTP request: `GET
    http://localhost:8000/games/`. The first command defines the `text/html` value
    for the `Accept` request header. The second command defines the `application/json`
    value for the `Accept` request header.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that both the commands produce the same results, and therefore,
    the view functions don''t take into account the value specified for the `Accept`
    request header in the HTTP requests. The header response for both commands will
    include the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The second request specified that it will only accept `text/html` but the response
    included a JSON body, that is, `application/json` content. Thus, our first version
    of the RESTful API is not prepared to render content other from JSON. We will
    make some changes to enable the API to render other contents.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we have doubts about the methods supported by a resource or resource
    collection in a RESTful API, we can compose and send an HTTP request with the
    `OPTIONS` HTTP verb and the URL for the resource or resource collection. If the
    RESTful API implements the OPTIONS HTTP verb for a resource or resource collection,
    it provides a comma-separated list of HTTP verbs or methods that it supports as
    a value for the `Allow` header in the response. In addition, the response header
    will include additional information about other supported options, such as the
    content type it is capable of parsing from the request and the content type it
    is capable of rendering on the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to know the HTTP verbs that the games collection supports,
    we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send the following HTTP request: `OPTIONS
    http://localhost:8000/games/`. The request will match and run the `views.game_list`
    function, that is, the `game_list` function declared within the `games/views.py`
    file. This function only runs the code when the `request.method` is equal to `''GET''`
    or `''POST''`. In this case, `request.method` is equal to `''OPTIONS''`, and therefore,
    the function won''t run any code and won''t return any response, specifically,
    it won''t return an `HttpResponse` instance. As a result, we will see the following
    `Internal Server Error` listed in Django''s development server console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the header for the output that also includes a detailed
    HTML document with detailed information about the error because the debug mode
    is activated for Django. We receive a `500 Internal Server Error` status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, we want to provide a more consistent API and we want to provide an
    accurate response when we receive a request with the `OPTIONS` verbs for either
    a game resource or the games collection.
  prefs: []
  type: TYPE_NORMAL
- en: If we compose and send an HTTP request with the `OPTIONS` verb for a game resource,
    we will see the same error and we will have a similar response because the `views.game_detail`
    function only runs the code when the `request.method` is equal to `'GET'`, `'PUT'`,
    or `'DELETE'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands will produce the explained error when we try to see
    the options offered for the game resource whose id or primary key is equal to
    `3`. Don''t forget to replace `3` with a primary key value of an existing game
    in your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We just need to make a few changes in the `games/views.py` file to solve the
    issues we have been analyzing for our RESTful API. We will use the `@api_view`
    decorator, declared in `rest_framework.decorators`, for our function-based views.
    This decorator allows us to specify the HTTP verbs that our function can process.
    If the request that has to be processed by the view function has an HTTP verb
    that isn't included in the string list specified as the `http_method_names` argument
    for the `@api_view` decorator, the default behavior returns a `405 Method Not
    Allowed` status code. This way, we make sure that whenever we receive an HTTP
    verb that isn't considered within our function view, we won't generate an unexpected
    error as the decorator handles the response for the unsupported HTTP verbs or
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Under the hoods, the `@api_view` decorator is a wrapper that converts a function-based
    views  into a subclass of the `rest_framework.views.APIView` class. This class
    is the base class for all views in Django REST Framework. As we might guess, in
    case we want to work with class-based view, we can create classes that inherit
    from this class and we will have the same benefits that we analyzed for the function-based
    views that use the decorator. We will work with class-based views in the forthcoming
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, as we specify a string list with the supported HTTP verbs, the
    decorator automatically builds the response for the `OPTIONS` HTTP verb with the
    supported methods and parser and render capabilities. Our actual version of the
    API is just capable of rendering JSON as its output. The usage of the decorator
    makes sure that we always receive an instance of the `rest_framework.request.Request`
    class in the `request` argument when Django calls our view function. The decorator
    also handles the `ParserError` exceptions when our function views access the `request.data`
    attribute that might cause parsing problems.
  prefs: []
  type: TYPE_NORMAL
- en: Using the default parsing and rendering options and move beyond JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `APIView` class specifies default settings for each view that we can override
    by specifying appropriate values in the `gamesapi/settings.py` file or by overriding
    the class attributes in subclasses. As previously explained, the usage of the
    `APIView` class under the hoods makes the decorator apply these default settings.
    Thus, whenever we use the decorator, the default parser classes and the default
    renderer classes will be associated with the function views.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the value for the `DEFAULT_PARSER_CLASSES` is the following tuple
    of classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use the decorator, the API will be able to handle any of the following
    content types through the appropriate parsers when accessing the `request.data`
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '`application/json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application/x-www-form-urlencoded`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multipart/form-data`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we access the `request.data` attribute in the functions, Django REST Framework
    examines the value for the `Content-Type` header in the incoming request and determines
    the appropriate parser to parse the request content. If we use the previously
    explained default values, the Django REST Framework will be able to parse the
    previously listed content types. However, it is extremely important that the request
    specifies the appropriate value in the `Content-Type` header.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to remove the usage of the `rest_framework.parsers.JSONParser` class
    in the functions to make it possible to be able to work with all the configured
    parsers and stop working with a parser that only works with JSON. The `game_list`
    function executes the following two lines when `request.method` is equal to `''POST''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will remove the first line that uses the `JSONParser` and we will pass `request.data`
    as the data argument for the `GameSerializer`. The following line will replace
    the previous lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `game_detail` function executes the following two lines when `request.method`
    is equal to `''PUT''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will make the same edits done for the code in the `game_list` function.
    We will remove the first line that uses the `JSONParser` and we will pass `request.data`
    as the data argument for the `GameSerializer`. The following line will replace
    the previous lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the value for the `DEFAULT_RENDERER_CLASSES` is the following tuple
    of classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use the decorator, the API will be able to render the following content
    types in the response, through the appropriate renderers, when working with the
    `rest_framework.response.Response` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`application/json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text/html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, the value for the `DEFAULT_CONTENT_NEGOTIATION_CLASS` is the `rest_framework.negotiation.DefaultContentNegotiation`
    class. When we use the decorator, the API will use this content negotiation class
    to select the appropriate renderer for the response based on the incoming request.
    This way, when a request specifies that it will accept `text/html`, the content
    negotiation class selects the `rest_framework.renderers.BrowsableAPIRenderer`
    to render the response and generate `text/html` instead of `application/json`.
  prefs: []
  type: TYPE_NORMAL
- en: We have to replace the usage of both the `JSONResponse` and `HttpResponse` classes
    in the functions with the `rest_framework.response.Response` class. The `Response`
    class uses the previously explained content negotiation features, renders the
    received data into the appropriate content type, and returns it to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go to the `gamesapi/games` folder and open the `views.py` file. Replace
    the code in this file with the following code that removes the `JSONResponse`
    class and uses the `@api_view` decorator for the functions and the `rest_framework.response.Response`
    class. The modified lines are highlighted. The code file for the sample is included
    in the `restful_python_chapter_02_02` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After you save the preceding changes, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send the following HTTP request: `OPTIONS
    http://localhost:8000/games/`. The request will match and run the `views.game_list`
    function, that is, the `game_list` function declared within the `games/views.py`
    file. We added the `@api_view` decorator to this function, and therefore, it is
    now capable of determining the supported HTTP verbs, parsing, and rendering capabilities.
    The following lines show the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The response header includes an `Allow` key with a comma-separated list of
    HTTP verbs supported by the resource collection as its value: `GET, POST, OPTIONS`.
    As our request didn''t specify the allowed content type, the function rendered
    the response with the default `application/json` content type. The response body
    specifies the `Content-type` that the resource collection parses and the `Content-type`
    that it renders.'
  prefs: []
  type: TYPE_NORMAL
- en: Run the following command to compose and send an HTTP request with the `OPTIONS`
    verb for a game resource. Don't forget to replace `3` with a primary key value
    of an existing game in your configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will compose and send the following HTTP request: `OPTIONS
    http://localhost:8000/games/3/`. The request will match and run the `views.game_detail`
    function, that is, the `game_detail` function declared within the `games/views.py`
    file. We also added the `@api_view` decorator to this function, and therefore,
    it is capable of determining the supported HTTP verbs, parsing, and rendering
    capabilities. The following lines show the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The response header includes an `Allow` key with a comma-separated list of
    HTTP verbs supported by the resource as its value: `GET, POST, OPTIONS, PUT`.
    The response body specifies the content-type that the resource parses and the
    content-type that it renders, with the same contents received in the previous
    `OPTIONS` request applied to a resource collection, that is, to a games collection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 1](ch01.html "Chapter 1. Developing RESTful APIs with Django"),
    *Developing RESTful APIs with Django*, when we composed and sent POST and PUT
    commands, we had to use the use the `-H "Content-Type: application/json"` option
    to tell curl to send the data specified after the `-d` option as `application/json`
    instead of the default `application/x-www-form-urlencoded`. Now, in addition to
    `application/json`, our API is capable of parsing `application/x-www-form-urlencoded`
    and `multipart/form-data` data specified in the `POST` and `PUT` requests. Thus,
    we can compose and send a POST command that sends the data as `application/x-www-form-urlencoded`,
    with the changes made to our API.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will compose and send an HTTP request to create a new game. In this case,
    we will use the -f option for HTTPie, that serializes data items from the command
    line as form fields and sets the `Content-Type` header key to the `application/x-www-form-urlencoded`
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command. Note that we don''t use the `-H`
    option and curl will send the data in the default `application/x-www-form-urlencoded`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `POST
    http://localhost:8000/games/` with the `Content-Type` header key set to the `application/x-www-form-urlencoded`
    value and the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The request specifies `/games/`, and therefore, it will match `''^games/$''`
    and run the `views.game_list` function, that is, the updated `game_detail` function
    declared within the `games/views.py` file. As the HTTP verb for the request is
    `POST`, the `request.method` property is equal to `''POST''`, and therefore, the
    function will execute the code that creates a `GameSerializer` instance and passes
    `request.data` as the data argument for its creation. The `rest_framework.parsers.FormParser`
    class will parse the data received in the request, the code creates a new `Game`
    and, if the data is valid, it saves the new `Game`. If the new `Game` was successfully
    persisted in the database, the function returns an `HTTP 201 Created` status code
    and the recently persisted `Game` serialized to JSON in the response body. The
    following lines show an example response for the HTTP request, with the new `Game`
    object in the JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the following command after we make the changes in the code, to
    see what happens when we compose and send an HTTP request with an HTTP verb that
    is not supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will compose and send the following HTTP request: `PUT
    http://localhost:8000/games/`. The request will match and try to run the `views.game_list`
    function, that is, the `game_list` function declared within the `games/views.py`
    file. The `@api_view` decorator we added to this function doesn''t include `''PUT''`
    in the string list with the allowed HTTP verbs, and therefore, the default behavior
    returns a `405 Method Not Allowed` status code. The following lines show the output
    along with the response from the previous request. A JSON content provides a `detail`
    key with a string value, which indicates that the `PUT` method is not allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Browsing the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the recent edits, we made it possible for our API to use the default content
    renderers configured in Django REST Framework, and therefore, our API is capable
    of rendering the `text/html` content. We can take advantage of the browsable API,
    a feature included in Django REST Framework that generates human-friendly HTML
    output for each resource whenever the request specifies `text/html` as the value
    for the `Content-type` key in the request header.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we enter a URL for an API resource in a web browser, the browser will
    require an HTML response, and therefore, Django REST Framework will provide an
    HTML response built with Bootstrap ([http://getbootstrap.com](http://getbootstrap.com)).
    This response will include a section that displays the resource content in JSON,
    buttons to perform different requests, and forms to submit data to the resources.
    As everything in Django REST Framework, we can customize the templates and themes
    used to generate the browsable API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a web browser and enter `http://localhost:8000/games/`. The browsable
    API will compose and send a `GET` request to `/games/` and will display the results
    of its execution, that is, the headers and the JSON games list. The following
    screenshot shows the rendered web page after entering the URL in a web browser
    with the resource description-**Game List**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Browsing the API](img/image_02_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you decide to browse the API in a web browser running on another computer
    or device connected to the LAN, remember that you have to use the development
    computer's assigned IP address instead of `localhost`. For example, if the computer's
    assigned IPv4 IP address is `192.168.1.106`, instead of `http://localhost:8000/games/`,
    you should use `http://192.168.1.106:8000/games/`. Of course, you can also use
    the host name instead of the IP address.
  prefs: []
  type: TYPE_NORMAL
- en: The browsable API uses the information about the allowed methods for a resource
    to provide us with buttons to run these methods. At the right-hand side of the
    resource description, the browsable API shows an **OPTIONS** button and a **GET**
    drop-down button. The **OPTIONS** button allows us to make an `OPTIONS` request
    to `/games/`, that is, to the current resource. The **GET** drop-down button allows
    us to make a `GET` request to `/games/` again. If we click on or tap the down
    arrow, we can select the **json** option and the browsable API will display the
    raw JSON result of a `GET` request to `/games/` without the headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the rendered web page, the browsable API provides us some
    control to generate a `POST` request to `/games/`. The **Media type** dropdown
    allows us to select between the configured supported parsers for our API:'
  prefs: []
  type: TYPE_NORMAL
- en: '`application/json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application/x-www-form-urlencoded`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multipart/form-data`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Content** textbox allows us to specify the data to be sent to the `POST`
    request formatted as specified in the **Media type** dropdown. Select **application/json**
    in the **Media type** dropdown and enter the following JSON content in the **Content**
    textbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Click or tap on `POST`. The browsable API will compose and send a `POST` request
    to `/games/` with the previously specified data as JSON, and we will see the results
    of the call in the web browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a web browser displaying the HTTP status code
    `201 Created` in the response and the previously explained dropdown and textbox
    with the `POST` button to allow us to continue composing and sending `POST` requests
    to `/games/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Browsing the API](img/image_02_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, enter the URL for an existing game resource, such as `http://localhost:8000/games/2/`.
    Make sure you replace 2 with the id or primary key of an existing game in the
    previously rendered **Games List**. The browsable API will compose and send a
    `GET` request to `/games/2/` and will display the results of its execution, that
    is, the headers and the JSON data for the game.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows the rendered web page after entering the URL
    in a web browser with the resource description-**Game Detail:**
  prefs: []
  type: TYPE_NORMAL
- en: '![Browsing the API](img/image_02_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The browsable API feature allows us to easily check how the API works and to
    compose and send HTTP requests with different methods to any web browser that
    has access to our LAN. We will take advantage of the additional features included
    in the browsable API, such as HTML forms that allow us to easily create new resources,
    later, after we build a new RESTful API with Python and Django REST Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a RESTful API to interact with a complex PostgreSQL database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our RESTful API has performed CRUD operations on a single database table.
    Now, we want to create a more complex RESTful API with Django REST Framework to
    interact with a complex database model that has to allow us to register player
    scores for played games that are grouped into game categories. In our previous
    RESTful API, we used a string field to specify the game category for a game. In
    this case, we want to be able to easily retrieve all the games that belong to
    a specific game category, and therefore, we will have a relationship between a
    game and a game category.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should be able to perform CRUD operations on different related resources
    and resource collections. The following list enumerates the resources and the
    model names that we will use to represent them in Django REST Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: Game categories (`GameCategory` model)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Games (`Game` model)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Players (`Player` model)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Player scores (`PlayerScore` model)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The game category (`GameCategory`) just requires a name, and we need the following
    data for a game (`Game`):'
  prefs: []
  type: TYPE_NORMAL
- en: A foreign key to a game category (`GameCategory`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A release date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bool value indicating whether the game was played at least once by a player
    or not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A timestamp with the date and time in which the game was inserted in the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need the following data for a player (`Player`):'
  prefs: []
  type: TYPE_NORMAL
- en: A gender value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A timestamp with the date and time in which the player was inserted in the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need the following data for the score achieved by a player (`PlayerScore`):'
  prefs: []
  type: TYPE_NORMAL
- en: A foreign key to a player (`Player`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A foreign key to a game (`Game`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A score value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A date in which the score value was achieved by the player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will take advantage of all the resources and their relationships to analyze
    different options that Django REST Framework provides us when working with related
    resources. Instead of building an API that uses the same configuration to display
    related resources, we will use diverse configurations that will allow us to select
    the most appropriate options based on the particular requirements of the APIs
    that we are developing.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the tasks performed by each HTTP method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following table shows the HTTP verbs, the scope, and the semantics for the
    methods that our new API must support. Each method is composed by an HTTP verb
    and a scope and all the methods have well-defined meanings for all the resources
    and collections.
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP verb** | **Scope** | **Semantics** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Collection of game categories | Retrieve all the stored game categories
    in the collection, sorted by their name in ascending order. Each game category
    must include a list of URLs for each game resource that belongs to the category.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Game category | Retrieve a single game category. The game category
    must include a list of URLs for each game resource that belongs to the category.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Collection of game categories | Create a new game category in the
    collection. |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | Game category | Update an existing game category. |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Game category | Update one or more fields of an existing game category.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Game category | Delete an existing game category. |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Collection of games | Retrieve all the stored games in the collection,
    sorted by their name in ascending order. Each game must include its game category
    description. |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Game | Retrieve a single game. The game must include its game category
    description. |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Collection of games | Create a new game in the collection. |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | Game category | Update an existing game. |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Game category | Update one or more fields of an existing game.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Game category | Delete an existing game. |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Collection of players | Retrieve all the stored players in the collection,
    sorted by their name in ascending order. Each player must include a list of the
    registered scores, sorted by score in descending order. The list must include
    all the details for the score achieved by the player and its related game. |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Player | Retrieve a single player. The player must include a list
    of the registered scores, sorted by score in descending order. The list must include
    all the details for the score achieved by the player and its related game. |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Collection of players | Create a new player in the collection. |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | Player | Update an existing player. |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Player | Update one or more fields of an existing player. |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Player | Delete an existing player. |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Collection of scores | Retrieve all the stored scores in the collection,
    sorted by score in descending order. Each score must include the player''s name
    that achieved the score and the game''s name. |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Score | Retrieve a single score. The score must include the player''s
    name that achieved the score and the game''s name. |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Collection of scores | Create a new score in the collection. The
    score must be related to an existing player and an existing game. |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | Score | Update an existing score. |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Score | Update one or more fields of an existing score. |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Score | Delete an existing score. |'
  prefs: []
  type: TYPE_TB
- en: We want our API to be able to update a single field for an existing resource,
    and therefore, we will provide an implementation for the `PATCH` method. The `PUT`
    method is meant to replace an entire resource and the `PATCH` method is meant
    to apply a delta to an existing resource. In addition, our RESTful API must support
    the `OPTIONS` method for all the resources and collection of resources.
  prefs: []
  type: TYPE_NORMAL
- en: We don't want to spend time choosing and configuring the most appropriate ORM,
    as seen in our previous API; we just want to finish the RESTful API as soon as
    possible to start interacting with it. We will use all the features and reusable
    elements included in Django REST Framework to make it easy to build our API. We
    will work with a PostgreSQL database. However, in case you don't want to spend
    time installing PostgreSQL, you can skip the changes we make in Django REST Framework
    ORM configuration and continue working with the default SQLite database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding table, we have a huge number of methods and scopes. The following
    list enumerates the URIs for each scope mentioned in the table, where `{id}` has
    to be replaced with the numeric id or the primary key of the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Collection of game categories**: `/game-categories/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game category**: `/game-category/{id}/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collection of games**: `/games/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game**: `/game/{id}/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collection of players**: `/players/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player**: `/player/{id}/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collection of scores**: `/player-scores/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Score**: `/player-score/{id}/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s consider that `http://localhost:8000/` is the URL for the API running
    on the Django development server. We have to compose and send an HTTP request
    with the following HTTP verb (`GET`) and request URL (`http://localhost:8000/game-categories/`)
    to retrieve all the stored game categories in the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Declaring relationships with the models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure you quit the Django's development server. Remember that you just need
    to press ***Ctrl*** + ***C*** in the terminal or command-prompt window in which
    it is running. Now, we will create the models that we are going to use to represent
    and persist the game categories, games, players and scores, and their relationships.
    Open the `games/models.py` file and replace its contents with the following code.
    The lines that declare fields related to other models are highlighted in the code
    listing. The code file for the sample is included in the `restful_python_chapter_02_03`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code declares the following four models, specifically four classes
    as subclasses of the `django.db.models.Model` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GameCategory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Game`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Player`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PlayerScore`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django automatically adds an auto-increment integer primary key column named
    `id` when it creates the database table related to each model. We specified the
    field types, maximum lengths, and defaults for many attributes. Each class declares
    a `Meta` inner class that declares an ordering attribute. The `Meta` inner class
    declared within the `PlayerScore` class specifies `'-score'` as the value of the
    `ordering` tuple, with a dash as a prefix of the field name and ordered by `score`
    in descending order, instead of the default ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: The `GameCategory`, `Game`, and `Player` classes declare the `__str__` method
    that returns the contents of the `name` attribute that provides the name or title
    for each of these models. So, Django will call this method whenever it has to
    provide a human-readable representation for the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Game` model declares the `game_category` field with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line uses the django.db.models.ForeignKey class to provide a many-to-one
    relationship to the GameCategory model. The 'games' value specified for the related_name
    argument creates a backwards relation from the GameCategory model to the Game
    model. This value indicates the name to be used for the relation from the related
    GameCategory object back to a Game object. Now, we will be able to access all
    the games that belong to a specific game category. Whenever we delete a game category,
    we want all the games that belong to this category to be deleted too, and therefore,
    we specified the models.CASCADE value for the on_delete argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PlayerScore` model declares the `player` field with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line uses the django.db.models.ForeignKey class to provide a many-to-one
    relationship to the Player model. The 'scores' value specified for the related_name
    argument creates a backwards relation from the Player model to the PlayerScore
    model. This value indicates the name to be used for the relation from the related
    Player object back to a PlayerScore object. Now, we will be able to access all
    the scores archive by a specific player. Whenever we delete a player, we want
    all the scores achieved by this player to be deleted too, and therefore, we specified
    the models.CASCADE value for the on_delete argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PlayerScore` model declares the `game` field with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line uses the django.db.models.ForeignKey class to provide a many-to-one
    relationship to the Game model. In this case, we don't create a backwards relation
    because we don't need it. Thus, we don't specify a value for the related_name
    argument. Whenever we delete a game, we want all the registered scores for this
    game to be deleted too, and therefore, we specified the models.CASCADE value for
    the on_delete argument.
  prefs: []
  type: TYPE_NORMAL
- en: In case you created a new virtual environment to work with this example or you
    downloaded the sample code for the book, you don't need to delete any existing
    database. However, in case you are making changes to the code for our previous
    API example, you have to delete the gamesapi/db.sqlite3 file and the games/migrations
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Then, it is necessary to create the initial migration for the new models we
    recently coded. We just need to run the following Python scripts and we will also
    synchronize the database for the first time. As we learned from our previous example
    API, by default, Django uses an SQLite database. In this example, we will be working
    with a PostgreSQL database. However, in case you want to use SQLite, you can skip
    the steps related to PostgreSQL, its configuration in Django, and jump to the
    migrations generation command.
  prefs: []
  type: TYPE_NORMAL
- en: You will have to download and install a PostgreSQL database in case you aren't
    already running it in your computer or in a development server. You can download
    and install this database management system from its web page-[http://www.postgresql.org](http://www.postgresql.org).
    In case you are working with macOS, `Postgres.app` provides an easy way to install
    and use PostgreSQL on this operating system-[http://postgresapp.com](http://postgresapp.com).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have to make sure that the PostgreSQL bin folder is included in the `PATH`
    environmental variable. You should be able to execute the `psql` command-line
    utility from your current terminal or command prompt. In case the folder isn't
    included in the PATH, you will receive an error indicating that the `pg_config`
    file cannot be found when trying to install the `psycopg2` package. In addition,
    you will have to use the full path to each of the PostgreSQL command-line tools
    we will use in the subsequent steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the PostgreSQL command-line tools to create a new database named
    `games`. In case you already have a PostgreSQL database with this name, make sure
    that you use another name in all the commands and configurations. You can perform
    the same task with any PostgreSQL GUI tool. In case you are developing on Linux,
    it is necessary to run the commands as the `postgres` user. Run the following
    command in macOS or Windows to create a new database named `games`. Note that
    the command won''t produce any output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In Linux, run the following command to use the `postgres` user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will use the `psql` command-line tool to run some SQL statements to
    create a specific user that we will use in Django and assign the necessary roles
    for it. In macOS or Windows, run the following command to launch `psql`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In macOS, you might need to run the following command to launch psql with the
    `postgres` in case the previous command doesn''t work, as it will depend on the
    way in which you installed PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In Linux, run the following command to use the `postgres` user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the following SQL statements and finally enter `\q` to exit the psql
    command-line tool. Replace `user_name` with your desired user name to use in the
    new database and password with your chosen password. We will use the username
    and password in the Django configuration. You don''t need to run the steps if you
    are already working with a specific user in PostgreSQL and you have already granted
    privileges to the database for the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The default SQLite database engine and the database file name are specified
    in the `gamesapi/settings.py` Python file. In case you decide to work with PostgreSQL
    instead of SQLite for this example, replace the declaration of the `DATABASES`
    dictionary with the following lines. The nested dictionary maps the database named
    `default` with the `django.db.backends.postgresql` database engine, the desired
    database name, and its settings. In this case, we will create a database named
    `games`. Make sure you specify the desired database name in the value for the
    `''NAME''` key and that you configure the user, password, host, and port based
    on your PostgreSQL configuration. In case you followed the previous steps, use
    the settings specified in these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In case you decided to use PostgreSQL, after making the preceding changes, it
    is necessary to install the Psycopg 2 package (psycopg2). This package is a Python-PostgreSQL
    Database Adapter and Django uses it to interact with a PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In macOS installations, we have to make sure that the PostgreSQL bin folder
    is included in the `PATH` environmental variable. For example, in case the path
    to the bin folder is `/Applications/Postgres.app/Contents/Versions/latest/bin`,
    we must execute the following command to add this folder to the `PATH` environmental
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have made sure that the PostgreSQL `bin` folder is included in the
    PATH environmental variable, we just need to run the following command to install
    this package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines of the output will indicate that the `psycopg2` package has
    been successfully installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following Python script to generate the migrations that will allow
    us to synchronize the database for the first time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output generated after running the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The output indicates that the `gamesapi/games/migrations/0001_initial.py` file
    includes the code to create the `Game`, `GameCategory`, `Player` , and `PlayerScore`
    models. The following lines show the code for this file that was automatically
    generated by Django. The code file for the sample is included in the `restful_python_chapter_02_03`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code defines a subclass of the `django.db.migrations.Migration`
    class named `Migration` that defines an `operations` list with many `migrations.CreateModel`.
    Each `migrations.CreateModel` will create the table for each of the related models.
    Note that Django has automatically added an `id` field for each of the models.
    The `operations` are executed in the same order in which they appear in the list.
    The code creates `Game`, `GameCategory`, `Player`, `PlayerScore`, and finally
    adds the `game_category` field to `Game` with the foreign key to `GameCategory`
    because it created the `Game` model before the `GameCategory` model. The code
    creates the foreign keys for `PlayerScore` when it creates the model:'
  prefs: []
  type: TYPE_NORMAL
- en: Now, run the following Python script to apply all the generated migrations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output generated after running the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: After we run the previous command, we can use the PostgreSQL command line or
    any other application that allows us to easily check the contents of the PostreSQL
    database to check the tables that Django generated. In case you are working with
    SQLite, we have already learned how to check the tables in [Chapter 1](ch01.html
    "Chapter 1. Developing RESTful APIs with Django"), *Developing RESTful APIs with
    Django*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to list the generated tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output with all the generated table names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As seen in our previous example, Django uses the `games_` prefix for the following
    four table names related to the `games` application. Django''s integrated ORM
    generated these tables and the foreign keys, based on the information included
    in our models:'
  prefs: []
  type: TYPE_NORMAL
- en: '`games_game`: Persists the `Game` model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`games_gamecategory`: Persists the `GameCategory` model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`games_player`: Persists the `Player` model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`games_playerscore`: Persists the `PlayerScore` model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following command will allow you to check the contents of the four tables
    after we compose and send HTTP requests to the RESTful API and make CRUD operations
    to the four tables. The commands assume that you are running PostgreSQL on the
    same computer in which you are running the command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of working with the PostgreSQL command-line utility, you can use a GUI
    tool to check the contents of the PostgreSQL database. You can also use the database
    tools included in your favorite IDE to check the contents for the SQLite database.
  prefs: []
  type: TYPE_NORMAL
- en: Django generates additional tables that it requires to support the web framework
    and the authentication features that we will use later.
  prefs: []
  type: TYPE_NORMAL
- en: Managing serialization and deserialization with relationships and hyperlinks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our new RESTful Web API has to be able to serialize and deserialize the `GameCategory`,
    `Game`, `Player`, and `PlayerScore` instances into JSON representations. In this
    case, we also have to pay special attention to the relationships between the different
    models when we create the serializer classes to manage serialization to JSON and
    deserialization from JSON.
  prefs: []
  type: TYPE_NORMAL
- en: In our last version of the previous API, we created a subclass of the `rest_framework.serializers.ModelSerializer`
    class to make it easier to generate a serializer and reduce boilerplate code.
    In this case, we will also declare a class that inherits from `ModelSerializer`,
    but the other classes will inherit from the `rest_framework.serializers.HyperlinkedModelSerializer`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The `HyperlinkedModelSerializer` is a type of `ModelSerializer` that uses hyperlinked
    relationships instead of primary key relationships, and therefore, it represents
    the realationships to other model instances with hyperlinks instead of primary
    key values. In addition, the `HyperlinkedModelSerializer` generated a field named
    `url` with the URL for the resource as its value. As seen in the case of `ModelSerializer`,
    the `HyperlinkedModelSerializer` class provides default implementations for the
    `create` and `update` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go to the `gamesapi/games` folder and open the `serializers.py` file.
    Replace the code in this file with the following code that declares the required
    imports and the `GameCategorySerializer` class. We will add more classes to this
    file later. The code file for the sample is included in the `restful_python_chapter_02_03`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `GameCategorySerializer` class is a subclass of the `HyperlinkedModelSerializer`
    class. The `GameCategorySerializer` class declares a `games` attribute as an instance
    of `serializers.HyperlinkedRelatedField` with `many` and `read_only` equal to
    `True` because it is a one-to-many relationship and it is read-only. We use the
    `games` name that we specified as the `related_name` string value when we created
    the `game_category` field as a `models.ForeignKey` instance in the `Game` model.
    This way, the `games` field will provide us with an array of hyperlinks to each
    game that belong to the game category. The `view_name` value is '`game-detail`'
    because we want the browsable API feature to use the game detail view to render
    the hyperlink when the user clicks or taps on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `GameCategorySerializer` class declares a `Meta` inner class that declares
    two attributes: `model` and `fields`. The `model` attribute specifies the model
    related to the serializer, that is, the `GameCategory` class. The `fields` attribute
    specifies a tuple of string whose values indicates the field names that we want
    to include in the serialization from the related model. We want to include both
    the primary key and the URL, and therefore, the code specified both `''pk''` and
    `''url''` as members of the tuple. There is no need to override either the `create` ,
    or `update` method because the generic behavior will be enough in this case. The
    `HyperlinkedModelSerializer` superclass provides implementations for both methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following code to the `serializers.py` file to declare the `GameSerializer`
    class. The code file for the sample is included in the `restful_python_chapter_02_03`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `GameSerializer` class is a subclass of the `HyperlinkedModelSerializer`
    class. The `GameSerializer` class declares a `game_category` attribute as an instance
    of `serializers.SlugRelatedField` with its `queryset` argument set to `GameCategory.objects.all()`
    and its `slug_field` argument set to `'name'`. A `SlugRelatedField` is a read-write
    field that represents the target of the relationship by a unique slug attribute,
    that is, the description. We created the `game_category` field as a `models.ForeignKey`
    instance in the `Game` model and we want to display the game category's name as
    the description (slug field) for the related `GameCategory`. Thus, we specified
    `'name'` as the `slug_field`. In case it is necessary to display the possible
    options for the related game category in a form in the browsable API, Django will
    use the expression specified in the `queryset` argument to retrieve all the possible
    instances and display their specified slug field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `GameCategorySerializer` class declares a `Meta` inner class that declares
    two attributes: `model` and `fields`. The `model` attribute specifies the model
    related to the serializer, that is, the `Game` class. The `fields` attribute specifies
    a tuple of string whose values indicate the field names that we want to include
    in the serialization from the related model. We just want to include the URL,
    and therefore, the code specified both `''url''` as a member of the tuple. The
    `game_category` field will specify the `name` field for the related `GameCategory`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following code to the `serializers.py` file to declare the `ScoreSerializer`
    class. The code file for the sample is included in the `restful_python_chapter_02_03`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `ScoreSerializer` class is a subclass of the `HyperlinkedModelSerializer`
    class. We will use the `ScoreSerializer` class to serialize `PlayerScore` instances
    related to a `Player`, that is, to display all the scores for a specific player
    when we serialize a `Player`. We want to display all the details for the related
    `Game` but we don't include the related `Player` because the `Player` will use
    this `ScoreSerializer` serializer.
  prefs: []
  type: TYPE_NORMAL
- en: The `ScoreSerializer` class declares a `game` attribute as an instance of the
    previously coded `GameSerializer` class. We created the `game` field as a `models.ForeignKey`
    instance in the `PlayerScore` model and we want to serialize the same data for
    the game that we coded in the `GameSerializer` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ScoreSerializer` class declares a `Meta` inner class that declares two
    attributes: `model` and `fields`. The `model` attribute specifies the model related
    to the serializer, that is, the `PlayerScore` class. As previously explain, we
    don''t include the `''player''` field name in the `fields` tuple of string to
    avoid serializing the player again. We will use a `PlayerSerializer` as a master
    and the `ScoreSerializer` as the detail.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following code to the `serializers.py` file to declare the `PlayerSerializer`
    class. The code file for the sample is included in the `restful_python_chapter_02_03`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `PlayerSerializer` class is a subclass of the `HyperlinkedModelSerializer`
    class. We will use the `PlayerSerializer` class to serialize `Player` instances
    and we will use the previously declared `ScoreSerializer` class to serialize all
    the `PlayerScore` instances related to the `Player`.
  prefs: []
  type: TYPE_NORMAL
- en: The `PlayerSerializer` class declares a `scores` attribute as an instance of
    the previously coded `ScoreSerializer` class. The `many` argument is set to `True`
    because it is a one-to-many relationship. We use the `scores` name that we specified
    as the `related_name` string value when we created the `player` field as a `models.ForeignKey`
    instance in the `PlayerScore` model. This way, the `scores` field will render
    each `PlayerScore` that belongs to the `Player` using the previously declared
    `ScoreSerializer`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Player` model declared `gender` as an instance of `models.CharField` with
    the `choices` attribute set to the `Player.GENDER_CHOICES` string tuple. The `ScoreSerializer`
    class declares a `gender` attribute as an instance of `serializers.ChoiceField`
    with the `choices` argument set to the `Player.GENDER_CHOICES` string tuple. In
    addition, the class declares a `gender_description` attribute with `read_only`
    set to `True` and the `source` argument set to `'get_gender_display'`. The `source`
    string is built with `get_` followed by the field name, `gender`, and `_display`.
    This way, the read-only `gender_description` attribute will render the description
    for the gender choices instead of the single char stored values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ScoreSerializer` class declares a `Meta` inner class that declares two
    attributes: `model` and `fields`. The `model` attribute specifies the model related
    to the serializer, that is, the `PlayerScore` class. As previously explained,
    we don''t include the `''player''` field name in the `fields` tuple of string
    to avoid serializing the player again. We will use a `PlayerSerializer` as a master
    and the `ScoreSerializer` as the detail.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the following code to the `serializers.py` file to declare the
    `PlayerScoreSerializer` class. The code file for the sample is included in the
    `restful_python_chapter_02_03` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `PlayerScoreSerializer` class is a subclass of the `HyperlinkedModelSerializer`
    class. We will use the `PlayerScoreSerializer` class to serialize `PlayerScore`
    instances. Previously, we created the `ScoreSerializer` class to serialize `PlayerScore`
    instances as the detail of a player. We will use the new `PlayerScoreSerializer`
    class when we want to display the related player's name and the related game's
    name. In the other `serializer` class, we didn't include any information related
    to the player and we included all the details for the game.
  prefs: []
  type: TYPE_NORMAL
- en: The `PlayerScoreSerializer` class declares a `player` attribute as an instance
    of `serializers.SlugRelatedField` with its `queryset` argument set to `Player.objects.all()`
    and its `slug_field` argument set to `'name'`. We created the `player` field as
    a `models.ForeignKey` instance in the `PlayerScore` model and we want to display
    the player's name as the description (slug field) for the related `Player`. Thus,
    we specified `'name'` as the `slug_field`. In case it is necessary to display
    the possible options for the related game category in a form in the browsable
    API, Django will use the expression specified in the `queryset` argument to retrieve
    all the possible players and display their specified slug field.
  prefs: []
  type: TYPE_NORMAL
- en: The `PlayerScoreSerializer` class declares a `game` attribute as an instance
    of `serializers.SlugRelatedField` with its `queryset` argument set to `Game.objects.all()`
    and its `slug_field` argument set to `'name'`. We created the `game` field as
    a `models.ForeignKey` instance in the `PlayerScore` model and we want to display
    the game's name as the description (slug field) for the related `Game`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating class-based views and using generic classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This time, we will write our API views by declaring class-based views, instead
    of function-based views. We might code classes that inherit from the `rest_framework.views.APIView`
    class and declare methods with the same names than the HTTP verbs we want to process:
    `get`, `post`, `put`, `patch`, `delete`, and so on. These methods receive a `request`
    argument as happened with the functions that we created for the views. However,
    this approach would require us to write a lot of code. Instead, we can take advantage
    of a set of generic views that we can use as our base classes for our class-based
    views to reduce the required code to the minimum and take advantage of the behavior
    that has been generalized in Django REST Framework.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create subclasses of the two following generic class views declared
    in `rest_framework.generics`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ListCreateAPIView`: Implements the `get` method that retrieves a listing of
    a queryset and the `post` method that creates a model instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RetrieveUpdateDestroyAPIView`: Implements the `get`, `put`, `patch`, and `delete`
    methods to retreive, completely update, partially update or delete a model instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Those two generic views are composed by combining reusable bits of behavior
    in Django REST Framework implemented as mixin classes declared in `rest_framework.mixins`.
    We can create a class that uses multiple inheritance and combine the features
    provided by many of these mixin classes. The following line shows the declaration
    of the `ListCreateAPIView` class as the composition of `ListModelMixin`, `CreateModelMixin`
    and `rest_framework.generics.GenericAPIView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line shows the declaration of the `RetrieveUpdateDestroyAPIView`
    class as the composition of `RetrieveModelMixin`, `UpdateModelMixin`, `DestroyModelMixin`
    and `rest_framework.generics.GenericAPIView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will create a Django class based views that will use the previously
    explained generic classes and the serializer classes to return JSON representations
    for each HTTP request that our API will handle. We will just have to specify a
    `queryset` that retrieves all the objects in the `queryset` attribute and the
    serializer class in the `serializer_class` attribute for each subclass that we
    declare. The generic classes will do the rest for us. In addition, we will declare
    a `name` attribute with the string name we will use to identify the view.
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of generic class based views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go to the `gamesapi/games` folder and open the `views.py` file. Replace the
    code in this file with the following code that declares the required imports and
    the class based views. We will add more classes to this file later. The code file
    for the sample is included in the `restful_python_chapter_02_03` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table summarizes the methods that each class-based view is going
    to process:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Scope** | **Class based view name** | **HTTP verbs that it will process**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Collection of game categories-`/game-categories/` | `GameCategoryList` |
    `GET` and `POST` |'
  prefs: []
  type: TYPE_TB
- en: '| Game category-`/game-category/{id}/` | `GameCategoryDetail` | `GET`, `PUT`,
    `PATCH` and `DELETE` |'
  prefs: []
  type: TYPE_TB
- en: '| Collection of games-`/games/` | `GameList` | `GET` and `POST` |'
  prefs: []
  type: TYPE_TB
- en: '| Game-`/game/{id}/` | `GameDetail` | `GET`, `PUT`, `PATCH` and `DELETE` |'
  prefs: []
  type: TYPE_TB
- en: '| Collection of players-`/players/` | `PlayerList` | `GET` and `POST` |'
  prefs: []
  type: TYPE_TB
- en: '| Player-`/player/{id}/` | `PlayerDetail` | `GET`, `PUT`, `PATCH` and `DELETE`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Collection of scores-`/player-scores/` | PlayerScoreList | `GET` and `POST`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Score-`/player-score/{id}/` | PlayerScoreDetail | `GET`, `PUT`, `PATCH` and
    `DELETE` |'
  prefs: []
  type: TYPE_TB
- en: In addition, we will be able to execute the `OPTIONS` HTTP verb on any of the
    scopes.
  prefs: []
  type: TYPE_NORMAL
- en: Working with endpoints for the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to create an endpoint for the root of our API to make it easier to browse
    the API with the browsable API feature and understand how everything works. Add
    the following code to the `views.py` file to declare the `ApiRoot` class. The
    code file for the sample is included in the `restful_python_chapter_02_03` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `ApiRoot` class is a subclass of the `rest_framework.generics.GenericAPIView`
    class and declares the get method. The `GenericAPIView` class is the base class
    for all the other generic views. The `ApiRoot` class defines the `get` method
    that returns a `Response` object with key-value pairs of string that provide a
    descriptive name for the view and its URL, generated with the `rest_framework.reverse.reverse`
    function. This URL resolver function returns a fully qualified URL for the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `gamesapi/games` folder and open the `urls.py` file. Replace the
    code in this file with the following code. The following lines show the code for
    this file that defines the URL patterns that specifies the regular expressions
    that have to be matched in the request to run a specific method for a class-based
    view defined in the `views.py` file. Instead of specifying a function that represents
    a view we call the `as_view` method for the class-based view. We use the `as_view`
    method. The code file for the sample is included in the `restful_python_chapter_02_03`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: When we coded our previous version of the API, we replaced the code in the `urls.py`
    file in the `gamesapi` folder, specifically, the `gamesapi/urls.py` file. We made
    the necessary changes to define the root URL configuration and include the URL
    pattern declared in the previously coded `games/urls.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can launch Django''s development server to compose and send HTTP requests
    to our still unsecure, yet much more complex Web API (we will definitely add security
    later). Execute any of the following two commands based on your needs to access
    the API in other devices or computers connected to your LAN. Remember that we
    analyzed the difference between them in [Chapter 1](ch01.html "Chapter 1. Developing
    RESTful APIs with Django"), *Developing RESTful APIs with Django*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: After we run any of the previous commands, the development server will start
    listening at port `8000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a web browser and enter `http://localhost:8000/` or the appropriate URL
    in case you are using another computer or device to access the browsable API.
    The browsable API will compose and send a `GET` request to `/` and will display
    the results of its execution, that is, the headers and the JSON response from
    the execution of the `get` method defined in the `ApiRoot` class within the `views.py`
    file. The following screenshot shows the rendered web page after entering the
    URL in a web browser with the resource description: **Api Root**.'
  prefs: []
  type: TYPE_NORMAL
- en: The API Root provides us hyperlinks to see the list of game categories, games,
    players, and scores. This way, it becomes extremely easy to access the lists and
    perform operations on the different resources through the browsable API. In addition,
    when we visit the other URLs, the breadcrumb will allow us to go back to the **Api
    Root**.
  prefs: []
  type: TYPE_NORMAL
- en: In this new version of the API, we worked with the generic views that provide
    many featured under the hoods, and therefore, the browsable API will provide us
    additional features compared with the previous version. Click or tap on the URL
    on the right-hand side of **game-categories**. In case you are browsing in localhost,
    the URL will be `http://localhost:8000/game-categories/`. The browsable API will
    render the web page for the **Game Category List**.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the rendered web page, the browsable API provides us some
    controls to generate a `POST` request to `/game-categories/`. In this case, by
    default, the browsable API displays the HTML form tab with an automatically generated
    form that we can use to generate a POST request without having to deal with the
    raw data as we did in our previous version. The HTML forms make it easy to generate
    requests to test our API. The following screenshot shows the HTML form to create
    a new game category:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with endpoints for the API](img/image_02_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We just need to enter the desired name, **3D RPG**, in the **Name** textbox
    and click or tap on **POST** to create a new game category. The browsable API
    will compose and send a `POST` request to `/game-categories/` with the previously
    specified data and we will see the results of the call in the web browser. The
    following screenshot shows a web browser displaying the HTTP status code `201
    Created` in the response and the previously explained HTML form with the **POST**
    button to allow us to continue composing and sending `POST` requests to `/game-categories/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with endpoints for the API](img/image_02_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, click on the URL displayed as a value for the url key in the JSON data
    displayed for the game category, such as `http://localhost:8000/game-categories/3/`.
    Make sure you replace 2 with the id or primary key of an existing game category
    in the previously rendered **Games List**. The browsable API will compose and
    send a `GET` request to `/game-categories/3/` and will display the results of
    its execution, that is, the headers and the JSON data for the game category. The
    web page will display a **DELETE** button because we are working with the **Game
    Category Detail** view.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use the breadcrumb to go back to the Api Root and start creating games
    related to a game category, players, and finally scores related to a game and
    a player. We can do all this with easy to use HTML forms and the browsable API
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and retrieving related resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will use the HTTPie command or its curl equivalents to compose and send
    HTTP requests to the API. We will use JSON for the requests that require additional
    data. Remember that you can perform the same tasks with your favorite GUI-based
    tool or with the browsable API.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will compose and send an HTTP request to create a new game category.
    Remember that we used the browsable API to create a game category named `'3D RPG'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will compose and send a `POST` HTTP request with the
    specified JSON key-value pair. The request specifies `/game-categories/`, and
    therefore, it will match `''^game-categories/$''` and run the `post` method for
    the `views.GameCategoryList` class-based view. Remember that the method is defined
    in the `ListCreateAPIView` superclass and it ends up calling the create method
    defined in `mixins.CreateModelMixin`. If the new `GameCategory` instance was successfully
    persisted in the database, the call to the method will return an `HTTP 201 Created`
    status code and the recently persisted `GameCategory` serialized to JSON in the
    response body. The following line shows a sample response for the HTTP request
    with the new `GameCategory` object in the JSON response. The response doesn''t
    include the header. Note that the response includes both the primary key, `pk`,
    and the url, `url`, for the created category. The `games` array is empty because
    there aren''t games related to the new category yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will compose and send HTTP requests to create two games that belong
    to the first category we recently created: `3D RPG`. We will specify the `game_category`
    value with the name of the desired `game category`. However, the database table
    that persists the `Game` model will save the value of the primary key of the related
    `GameCategory` whose name value matches the one we provide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the equivalent `curl` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send two `POST` HTTP requests with the
    specified JSON key-value pairs. The request specifies `/games/`, and therefore,
    it will match `''^games/$''` and run the `post` method for the `views.GameList`
    class-based view. The following lines show sample responses for the two HTTP requests
    with the new `Game` objects in the JSON responses. The responses don''t include
    the headers. Note that the response includes only the url, `url`, for the created
    games and doesn''t include the primary key. The value for `game_category` is the
    `name` for the related `GameCategory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the previously explained commands to check the contents of the tables
    that Django created in the PostgreSQL database. We will notice that the `game_category_id`
    column for the `games_game` table saves the value of the primary key of the related
    row in the `games_game_category` table. The `GameSerializer` class uses the `SlugRelatedField`
    to display the name value for the related `GameCategory`. The following screenshot
    shows the contents of the `games_game_category` and the `games_game` table in
    a PostgreSQL database after running the HTTP requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and retrieving related resources](img/image_02_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will compose and send an HTTP request to retrieve the game category
    that is contains two games, that is the game category resource whose id or primary
    key is equal to `3`. Don''t forget to replace `3` with the primary key value of
    the game whose name is equal to `''3D RPG''` in your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/game-categories/3/`. The request has a number after `/game-categories/`,
    and therefore, it will match `''^game-categories/(?P<pk>[0-9]+)/$''` and run the
    `get` method for the `views.GameCategoryDetail` class based view. Remember that
    the method is defined in the `RetrieveUpdateDestroyAPIView` superclass and it
    ends up calling the `retrieve` method defined in `mixins.RetrieveModelMixin`.
    The following lines show a sample response for the HTTP request, with the `GameCategory`
    object and the hyperlinks of the related games in the JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The `GameCategorySerializer` class defined the `games` attribute as a `HyperlinkedRelatedField`,
    and therefore, the serializer renders the URL for each related `Game` instance
    in the value for the `games` array. If we view the results in a web browser through
    the browsable API, we will be able to click or tap on the hyperlink to see the
    details for each game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will compose and send a `POST` HTTP request to create a game related
    to a game category name that doesn''t exist: `''Virtual reality''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Django won''t be able to retrieve a `GameCategory` instance whose `name` is
    equal to the specified value, and therefore, we will receive a `400 Bad Request`
    status code in the response header and a message related to the value specified
    in for `game_category` in the JSON body. The following lines show a sample response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will compose and send HTTP requests to create two players:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the equivalent `curl` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send two `POST` HTTP requests with the
    specified JSON key-value pairs. The request specifies `/players/`, and therefore,
    it will match `''^players/$''` and run the `post` method for the `views.PlayerList`
    class based view. The following lines show sample responses for the two HTTP requests
    with the new `Player` objects in the JSON responses. The responses don''t include
    the headers. Notice that the response includes only the url, `url`, for the created
    players and doesn''t include the primary key. The value for `gender_description`
    is the choice description for the `gender` char. The `scores` array is empty because
    there aren''t scores related to each new player yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will compose and send HTTP requests to create four scores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the equivalent curl commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The previous commands will compose and send four `POST` HTTP requests with the
    specified JSON key-value pairs. The request specifies `/player-scores/`, and therefore,
    it will match `'^player-scores/$'` and run the `post` method for the `views.PlayerScoreList`
    class based view. The following lines show sample responses for the four HTTP
    requests with the new `Player` objects in the JSON responses. The responses don't
    include the headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Django REST Framework uses the `PlayerScoreSerializer` class to generate the
    JSON response. Thus, the value for `game` is the name for the related `Game` instance
    and the value for `player` is the name for the related `Player` instance. The
    `PlayerScoreSerializer` class used `SlugRelatedField` for both fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the previously explained commands to check the contents of the tables
    that Django created in the PostgreSQL database. We will notice that the `game_id`
    column for the `games_playerscore` table saves the value of the primary key of
    the related row in the `games_game` table. In addition, the `player_id` column
    for the `games_playerscore` table saves the value of the primary key of the related
    row in the `games_player` table. The following screenshot shows the contents for
    the `games_game_category`, `games_game`, `games_player` and `games_playerscore`
    tables in a PostgreSQL database after running the HTTP requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and retrieving related resources](img/image_02_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will compose and send an HTTP request to retrieve a specific player
    that contains two scores, which is the player resource whose id or primary key
    is equal to `3`. Don''t forget to replace `3` with the primary key value of the
    player whose name is equal to `''Kevin''` in your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/players/3/`. The request has a number after `/players/`,
    and therefore, it will match `''^players/(?P<pk>[0-9]+)/$''` and run the `get`
    method for the `views.PlayerDetail` class based view. Remember that the method
    is defined in the `RetrieveUpdateDestroyAPIView` superclass and it ends up calling
    the `retrieve` method defined in `mixins.RetrieveModelMixin`. The following lines
    show a sample response for the HTTP request, with the `Player` object, the related
    `PlayerScore` objects and the `Game` object related to each `PlayerScore` object
    in the JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The `PlayerSerializer` class defined the `scores` attribute as a `ScoreSerializer`
    with `many` equal to `True`, and therefore, this serializer renders each score
    related to the player. The `ScoreSerializer` class defined the `game` attribute
    as a `GameSerializer`, and therefore, this serializer renders each game related
    to the score. If we view the results in a web browser through the browsable API,
    we will be able to click or tap on the hyperlink of each of the related resources.
    However, in this case, we also see all their details without having to follow
    the hyperlink.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Under the hoods, the `@api_view` decorator is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A wrapper that converts a function-based view into a subclass of the `rest_framework.views.APIView`
    class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A wrapper that converts a function-based view into a serializer.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A wrapper that converts a function-based view into a subclass of the `rest_framework.views.api_view`
    class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The browsable API, a feature included in Django REST Framework that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generates human-friendly JSON output for each resource whenever the request
    specifies `application/json` as the value for the `Content-type` key in the request
    header.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Generates human-friendly HTML output for each resource whenever the request
    specifies `text/html` as the value for the `Content-type` key in the request header.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Generates human-friendly HTML output for each resource whenever the request
    specifies `application/json` as the value for the `Content-type` key in the request
    header.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `rest_framework.serializers.ModelSerializer` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Automatically populates both a set of default constraints and a set of default
    parsers.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: populates both a set of default fields but doesn't automatically populate a
    set of default validators.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Automatically populates both a set of default fields but doesn't automatically
    populate a set of default validators. Automatically populates both a set of default
    fields and a set of default validators.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `rest_framework.serializers.ModelSerializer` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provides default implementations for the `get` and `patch` methods.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Provides default implementations for the `get` and `put` methods.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Provides default implementations for the `create` and `update` methods.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Serializer` and `ModelSerializer` classes in Django REST Framework are
    similar to the following two classes in Django Web Framework:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Form` and `ModelForm` classes.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`View` and `ModelView` classes.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Controller` and `ModelController` classes.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took advantage of the various features included in Django
    REST Framework that allowed us to eliminate duplicate code and build our API reusing
    generalized behaviors. We used model serializers, wrappers, default parsing, and
    rendering options, class based views, and generic classes.
  prefs: []
  type: TYPE_NORMAL
- en: We used the browsable API feature and we designed a RESTful API that interacted
    with a complex PostgreSQL database. We declared relationships with the models,
    managed serialization and deserialization with relationships, and hyperlinks.
    Finally, we created and retrieved related resources and we understood how things
    work under the hoods.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have built a complex API with Django REST Framework, we will use
    additional abstractions included in the framework to improve our API, we will
    add security and authentication, which is what we are going to discuss in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
