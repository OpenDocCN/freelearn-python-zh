- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Server-Side Development Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B20997_05.xhtml#_idTextAnchor238), *Basic Server-Side Development*,
    you learned how to write methods for a model class, how to extend methods from
    inherited models, and how to work with record sets. This chapter will deal with
    more advanced topics, such as working with the environment of a record set, calling
    a method upon a button click, and working with `onchange` methods. The recipes
    in this chapter will help you manage more complex business problems. You will
    learn how to create an understanding by incorporating visual elements and clarifying
    the process of creating interactive features within Odoo’s application development
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the user that performs an action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling a method with a modified context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing raw SQL queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a wizard to guide the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining `onchange` methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `onchange` methods on the server side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining `onchange` with the `compute` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a model based on a SQL view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding custom Settings options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing `init` hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you’ll require the Odoo online platform.
  prefs: []
  type: TYPE_NORMAL
- en: All the code used in this chapter can be downloaded from this book’s GitHub
    repository at [https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Changing the user that performs an action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing business logic code, you may have to perform some actions with
    a different security context. A typical case is performing an action with `superuser`
    rights, bypassing security checks. Such a requirement arises when business requirements
    necessitate operating on records for which users do not have security access rights.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how to allow normal users to create the `room` record
    by using `sudo()`. Put simply, we will allow users to create `room` by themselves,
    even if they do not have the right to create a assign the `room` record.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For easier understanding, we will add a new model to manage the hostel room.
    We will add a new model called `hostel.student`. You can refer to the following
    definition to add this model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You will need to add a form view, an action, and a menu item to see this new
    model from the user interface. You will also need to add security rules for the
    hostel so that they can issue the hostel student. Please refer to [*Chapter 3*](B20997_03.xhtml#_idTextAnchor083),
    *Creating Odoo Add-On Modules*, if you don’t know how to add these things.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can use the ready-made initial module from our GitHub code
    examples to save time. This module is available in the `Chapter08/00_initial_module`
    folder. The GitHub code examples are available at [https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter08/00_initial_module](https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter08/00_initial_module).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have tested the module, you will find that only users who have `hostel.room`
    access rights can mark a room as a manager. Non-hostel users cannot create a room
    by themselves; they need to ask a manager user:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This user has **Hostel Manager** access rights, which means they can create
    **Hostel** **Room** records:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.1 – This user has Hostel Manager access rights](img/B20997_08_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – This user has Hostel Manager access rights
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following screenshot, **Hostel Manager** can also create room
    records:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Hostel Manager can create room records](img/B20997_08_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Hostel Manager can create room records
  prefs: []
  type: TYPE_NORMAL
- en: 'This user has **Hostel User** access rights:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.3 – This user has Hostel User access rights](img/B20997_08_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – This user has Hostel User access rights
  prefs: []
  type: TYPE_NORMAL
- en: 'They can only see **Hostel** **Room** records:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Hostel User can see only Hostel Room records](img/B20997_08_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Hostel User can see only Hostel Room records
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that we want to add a new feature so that non-hostel users can create
    a room by themselves, for themselves. We will do this without giving them the
    access rights for the `hostel.room` model.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s learn how to let normal hostel users student.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `action_assign_room()` method to the `hostel.room` model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the method, ensure that we are acting on a single record:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Raise a warning if a student is not paid (make sure you have imported `UserError`
    at the top):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the empty recordset of `hostel.room` as a superuser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new `room` record with the appropriate values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To trigger this method from the user interface, add the button to the student
    form view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Restart the server and update `my_hostel` to apply the given changes. After
    the update, you will see an **Assign Room** button on the student form view, as
    shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.5 – The Assign Room button on the student form view](img/B20997_08_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – The Assign Room button on the student form view
  prefs: []
  type: TYPE_NORMAL
- en: When you click on that, a new room record will be created. This will also work
    for non-hostel users. You can test this by accessing Odoo as a demo user.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first three steps, we added a new method called `action_assign_room()`.
    This method will be called when the user clicks on the **Assign Room** button
    on the student form view.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 4*, we used `sudo()`. This method returns a new recordset with a modified
    `environment` in which the user has `superuser` rights. When `recordset` is called
    with `sudo()`, the environment will modify the `environment` attribute to `su`,
    which indicates the `superuser` state of the environment. You can access its status
    via `recordset.env.su`. All method calls through this `sudo` recordset are made
    with superuser privileges. To get a better idea of this, remove `.sudo()` from
    the method and then click on the `Access Error` and the user will no longer have
    access to the model. Simply using `sudo()` will bypass all security rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need a specific user, you can pass a recordset containing either that
    user or the database ID of the user, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet allows you to search for rooms that are visible using the
    `public` user.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using `sudo()`, you can bypass the access rights and security record rules.
    Sometimes, you can access multiple records that are meant to be isolated, such
    as records from different companies in multi-company environments. The `sudo()`
    recordset bypasses all the security rules of Odoo.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not careful, records that are searched for in this environment may
    be linked to any company present in the database, which means that you may be
    leaking information to a user; worse, you may be silently corrupting the database
    by linking records that belong to different companies.
  prefs: []
  type: TYPE_NORMAL
- en: When using `sudo()`, exercise caution to avoid unintended consequences, such
    as inadvertently linking records from different companies. Ensure proper data
    segregation and consider the potential impact on data integrity and security rules
    before bypassing access rights.
  prefs: []
  type: TYPE_NORMAL
- en: Important tip
  prefs: []
  type: TYPE_NORMAL
- en: When using `sudo()`, always double-check to ensure that your calls to `search()`
    do not rely on the standard record rules to filter the results.
  prefs: []
  type: TYPE_NORMAL
- en: Without using `sudo()`, `search()` calls would respect standard record rules,
    potentially restricting access to records based on user permissions. This could
    lead to incomplete or inaccurate search results, affecting data visibility and
    application functionality.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Check out these references for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about environments, refer to the *Obtaining an empty
    recordset for a model* recipe in [*Chapter 5*](B20997_05.xhtml#_idTextAnchor238),
    *Basic* *Server-Side Development*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information about access control lists and record rules, check out
    [*Chapter 10*](B20997_10.xhtml#_idTextAnchor549), *Security Access*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling a method with a modified context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`context` is part of the environment of a recordset. It is used to pass extra
    information, such as the time zone and the language of the user, from the user
    interface. You can also use the context to pass the parameters specified in the
    actions. Several methods in the standard Odoo add-ons use the context to adapt
    their business logic based on these context values. It is sometimes necessary
    to modify the context on a `recordset` value to get the desired results from a
    method call or the desired value for a computed field.'
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how to change the behavior of a method based on values
    in the environmental context.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use the `my_hostel` module from the previous recipe.
    On the form view of the `hostel.room` model, we will add a button to remove room
    members. If a regular resident of a hostel removes other occupants from their
    assigned room without permission or authorization, it could create disruptions
    and issues within the accommodation. Note that we already have the same button
    in the form view of the room, but here, we will explore context usage in Odoo,
    gaining insights into how it influences system operations and outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add a button, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `hostel.room`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `action_remove_room_members()` method to the `hostel.room` model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the method to change the context of the environment
    and call the method to remove the room members:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `action_remove_room()` method of the `hostel.student` model so that
    a different behavior is exhibited:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Odoo, to modify behavior influenced by context, we did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Identified the target behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defined the contextual parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adapted the relevant code sections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tested the changes thoroughly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensured compatibility across modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In *Step 1*, we removed the room members.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 2*, we added a new button, **Remove Room Members**. The user will use
    this button to **Remove** **the Members**.
  prefs: []
  type: TYPE_NORMAL
- en: In *Steps 3* and *4*, we added a method that will be called when the user clicks
    on the **Remove Room** **Members** button.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 5*, we called `student.with_context()` with some keyword arguments.
    This returns a new version of the `room_id` recordset with an updated context.
    We are adding one key to the context here, `is_hostel_room=True`, but you can
    add multiple keys if you want. We used `sudo()` here.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 6*, we checked whether the context had a positive value for the `is_hostel_room`
    key.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when the hostel room removes room members in the student form view, the
    `room` recordset is `False`.
  prefs: []
  type: TYPE_NORMAL
- en: This is just a simple example of a modified context, but you can use any method,
    such as `create()`, `write()`, `unlink()`, and so on. You can also use any custom
    method based on your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is also possible to pass a dictionary to `with_context()`. In this case,
    the dictionary is used as the new context, which overwrites the current one. So,
    *Step 5* can also be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to the following recipes to learn more about contexts in Odoo:'
  prefs: []
  type: TYPE_NORMAL
- en: The *Obtaining an empty recordset for a model* recipe in [*Chapter 5*](B20997_05.xhtml#_idTextAnchor238),
    *Basic Server-Side Development*, explains what the environment is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Passing parameters to forms and actions – context* recipe in [*Chapter
    9*](B20997_09.xhtml#_idTextAnchor446), *Backend Views*, explains how to modify
    the context in action definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Search for records* recipe in [*Chapter 5*](B20997_05.xhtml#_idTextAnchor238),
    *Basic Server-Side Development*, explains active records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing raw SQL queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time, you can perform the operations you want by using Odoo’s ORM
    – for example, you can use the `search()` method to fetch records. However, sometimes,
    you need more; either you cannot express what you want using the domain syntax
    (for which some operations are tricky, if not downright impossible) or your query
    requires several calls to `search()`, which ends up being inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows you how to use raw SQL queries to get the name and amount
    a user keeps in a particular room.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use the `my_hostel` module from the previous recipe.
    For simplicity, we will just print the results in a log, but in real scenarios,
    you will need to use the query result in your business logic. In [*Chapter 9*](B20997_09.xhtml#_idTextAnchor446),
    *Backend Views*, we will display the result of this query in the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get information about the name and amount a user keeps in a particular room,
    you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `action_category_with_amount()` method to `hostel.room`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the method, write the following SQL query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fetch the result and log it (make sure you have imported `logger`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a button in the form view of the `hostel.room` mode to trigger our method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Don’t forget to import `logger` in this file. Then, restart and update the `my_hostel`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Step 1*, we added the `action_category_with_amount()` method, which will
    be called when the user clicks on the **Log Category With** **Amount.** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Step 2*, we declared a SQL **SELECT** query. This will return the category
    that states the amount in a hostel room. If you run this query in the PostgreSQL
    CLI, you will get a result based on your room data. Here is the sample date based
    on my database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In *Step 4*, we called the `execute()` method on the database cursor stored
    in `self.env.cr`. This sends the query to PostgreSQL and executes it.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 5*, we used the `fetchall()` method of the cursor to retrieve a list
    of rows selected by the query. This method returns a list of rows. In my case,
    this is `[('Single Room', 3000)]`. From the form of the query we execute, we know
    that each row will have exactly two values, the first being `name` and the other
    being the amount a user holds in a particular room. Then, we simply log it.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6*, we added an `Add` button to handle user actions.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you are executing an `UPDATE` query, you need to manually invalidate the
    cache since Odoo ORM’s cache is unaware of the changes you made with the `UPDATE`
    query. To invalidate the cache, you can use `self.invalidate_cache()`.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The object in `self.env.cr` is a thin wrapper around a `psycopg2` cursor. The
    following methods are the ones that you will want to use most of the time:'
  prefs: []
  type: TYPE_NORMAL
- en: '`execute(query, params)`: This executes the SQL query with the parameters marked
    as `%s` in the query substituted with the values in `params`, which is a tuple'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Never do the substitution yourself; always use formatting options such as `%s`.
    If you use a technique such as string concatenation, it can make the code vulnerable
    to SQL injection.
  prefs: []
  type: TYPE_NORMAL
- en: '`fetchone()`: This returns one row from the database, wrapped in a tuple (even
    if only one column has been selected by the query)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetchall()`: This returns all the rows from the database as a list of tuples'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dictfetchall()`: This returns all the rows from the database as a list of
    dictionaries mapping column names to values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Be very careful when dealing with raw SQL queries:'
  prefs: []
  type: TYPE_NORMAL
- en: You are bypassing all the security of the application. Ensure that you call
    `search([('id', 'in', tuple(ids)])` with any list of IDs you are retrieving to
    filter out records to which the user has no access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any modifications you are making are bypassing the constraints set by the add-on
    modules, except the `NOT NULL`, `UNIQUE`, and `FOREIGN KEY` constraints, which
    are enforced at the database level. This is also the case for any computed field
    recomputation triggers, so you may end up corrupting the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid the `INSERT/UPDATE` query – inserting or updating records via queries
    will not run any business logic written by overriding the `create()` and `write()`
    methods. It will not update stored compute fields and the ORM constraints will
    be bypassed too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For access rights management, refer to [*Chapter 10*](B20997_10.xhtml#_idTextAnchor549),
    *Security Access*.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a wizard to guide the user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Using abstract models for reusable model features* recipe in [*Chapter
    4*](B20997_04.xhtml#_idTextAnchor118), *Application Models*, the `models.TransientModel`
    base class was introduced. This class has a lot in common with normal models,
    except that the records of transient models are periodically cleaned up in the
    database, hence the name transient. These are used to create wizards or dialogue
    boxes, which are filled in the user interface by the users and are generally used
    to perform actions on the persistent records of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use the `my_hostel` module from the previous recipes.
    This recipe will add a new wizard. With this wizard, the user will be assigned
    the room.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to add a new wizard for updating the assign room and hostel
    records:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new transient model to the module with the following definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `callback` method that performs the action on the transient model.
    Add the following code to the `AssignRoomStudentWizard` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a form view for the model. Add the following view definition to the
    module views:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an action and a menu entry to display the wizard. Add the following
    declarations to the module menu file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add access rights for `assign.room.student.wizard` in the `ir.model.access.csv`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Update the `my_hostel` module to apply the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Step 1*, we defined a new model. It is no different from other models, apart
    from the base class, which is `TransientModel` instead of `Model`. Both `TransientModel`
    and `Model` share a common base class, called `BaseModel`, and if you check the
    source code of Odoo, you will see that 99% of the work is in `BaseModel` and that
    both `Model` and `TransientModel` are almost empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only things that change for the `TransientModel` records are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Records are periodically removed from the database so that the tables for transient
    models do not grow over time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are not allowed to define `one2many` fields on a `TransientModel` instance
    that refers to a normal model as this will add a column on the persistent model
    that links to transient data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use *many2many* relations in this case. You can, of course, use *one2many* fields
    if the related model in *one2many* is also `TransientModel`.
  prefs: []
  type: TYPE_NORMAL
- en: We define one field in the model for storing the room. We can add other scalar
    fields so that we can record a scheduled return date, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 2*, we added the code to the wizard class that will be called when
    the button defined in *Step 3* is clicked on. This code reads the values from
    the wizard and updates the `hostel.student` record.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 3*, we defined a view for our wizard. Refer to the *Document-style
    forms* recipe in [*Chapter 9*](B20997_09.xhtml#_idTextAnchor446), *Backend Views*,
    for details. The important point here is the button in the footer; the `type`
    attribute is set to `'object'`, which means that when the user clicks on the button,
    the method with the name specified by the name attribute of the button will be
    called.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Step 4*, we ensured that we had an entry point for our wizard in the menu
    of the application. We use `target=''new''` in the action so that the form view
    is displayed as a dialogue box over the current form. Refer to the *Adding a menu
    item and window action* recipe in [*Chapter 9*](B20997_09.xhtml#_idTextAnchor446),
    *Backend Views*, for details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Wizard for assigning a room to a student](img/B20997_08_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Wizard for assigning a room to a student
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 5*, we added access rights for the `assign.room.student.wizard` model.
    With this, the manager user will get full rights to the `assign.room.student.wizard`
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Before Odoo v14, `TransientModel` didn’t require any access rules. Anyone can
    create a record, and they can only access records created by themselves. With
    Odoo v14, access rights are compulsory for `TransientModel`.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are some tips to enhance your wizards.
  prefs: []
  type: TYPE_NORMAL
- en: Using the context to compute default values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The wizard we are presenting requires the user to fill in the name of the member
    in the form. There is a feature of the web client that we can use to save some
    typing. When an action is executed, `context` is updated with some values that
    can be used by wizards:'
  prefs: []
  type: TYPE_NORMAL
- en: '`active_model`: This is the name of the model related to the action. This is
    generally the model being displayed onscreen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`active_id`: This indicates that a single record is active and provides the
    ID of that record.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`active_ids`: If several records are selected, this will be a list containing
    the IDs. This happens when several items are selected in a tree view when the
    action is triggered. In a form view, you get `[active_id]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`active_domain`: This is an additional domain on which the wizard will operate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These values can be used to compute the default values of the model or even
    directly in the method called by the button. To improve on the example in this
    recipe, if we had a button displayed on the form view of a `hostel.room` model
    to launch the wizard, the context of the creation of the wizard would contain
    `{''active_model'': ''hostel.room'', ''active_id'': <hostel_room_id>}`. In that
    case, you could define the `room_id` field to get a default value computed by
    the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Wizards and code reuse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In *Step 2*, we can add `self.ensure_one()` at the beginning of the method,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We recommend using v17 in this recipe. It will allow us to reuse the wizard
    from other parts of the code by creating records for the wizard and putting them
    in a single recordset (refer to the *Combining recordsets* recipe in [*Chapter
    5*](B20997_05.xhtml#_idTextAnchor238), *Basic Server-Side Development*, to see
    how to do this) before calling `add_room_in_student()` on the recordset. Here,
    the code is trivial, and you don’t need to jump through all those hoops to record
    that some rooms have been assigned by different students. However, in an Odoo
    instance, some operations are much more complex, and it is always nice to have
    a wizard available that does the right thing. When using these wizards, ensure
    that you check the source code for any possible use of the `active_model/active_id/active_ids`
    keys from the context. If this is the case, you need to pass a custom context
    (refer to the *Calling a method with a modified* *context* recipe).
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting the user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The method in *Step 2* doesn’t return anything. This will cause the wizard
    dialogue to be closed after the action is performed. Another possibility is to
    have the method return a dictionary with the fields of `ir.action`. In this case,
    the web client will process the action as if a menu entry had been clicked on
    by the user. The `get_formview_action()` method defined in the `BaseModel` class
    can be used to achieve this. For instance, if we wanted to display the form view
    of the hostel room, we could have written the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This builds a list of rooms that have rooms from this wizard (in practice, there
    will only be one such room when the wizard is called from the user interface)
    and creates a dynamic action, which displays the room with the specified IDs.
  prefs: []
  type: TYPE_NORMAL
- en: The *redirecting the user* technique can be used to create a wizard that must
    perform several steps one after the other. Each step in the wizard can use the
    values of the previous steps by providing a **Next** button. This will call a
    method defined on the wizard that updates some fields on the wizard, returns an
    action that will redisplay the same updated wizard, and gets ready for the next
    step.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Please refer to the following recipes for more details:'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *Document-style forms* recipe in [*Chapter 9*](B20997_09.xhtml#_idTextAnchor446),
    *Backend Views*, for more details on defining a view for a wizard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand more about views and calling server-side methods, refer to the
    *Adding a menu item and window action* recipe in [*Chapter 9*](B20997_09.xhtml#_idTextAnchor446),
    *Backend Views*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more details on creating records for the wizard and putting them in a single
    recordset, refer to the *Combining recordsets* recipe in [*Chapter 5*](B20997_05.xhtml#_idTextAnchor238),
    *Basic* *Server-Side Development*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining onchange methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing business logic, it is often the case that some fields are interrelated.
    We looked at how to specify constraints between fields in the *Adding constraint
    validations to a model* recipe in [*Chapter 4*](B20997_04.xhtml#_idTextAnchor118),
    *Application Models*. This recipe illustrates a slightly different concept. Here,
    `onchange` methods are called when a field is modified in the user interface to
    update the values of other fields of the record in the web client, usually in
    a form view.
  prefs: []
  type: TYPE_NORMAL
- en: We will illustrate this by providing a wizard similar to the one defined in
    the *Writing a wizard to guide the user* recipe, but that can be used to record
    duration returns. When a date is set in the form view, the duration is updated
    for the student. While we are demonstrating `onchange` methods on `Model`, these
    features are also available on normal `Transient` models.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use the `my_hostel` module from the *Writing a form
    to guide the user* recipe of this chapter. We will create a hostel student and
    add an `onchange` method that will auto-fill the duration when a user selects
    a discharge date or admission date field.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also want to prepare your work by defining the following model for
    the form view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you will need to define a view. These steps will be left as an exercise
    for you to carry out.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To automatically populate the duration to return when the user is changed,
    you need to add an `onchange` method in the `HostelStudent` step, with the following
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An `onchange` method uses the `@api.onchange` decorator, which is passed the
    names of the fields that change and will thus trigger the call to the method.
    In our case, we say that whenever `admission_date` or `discharge_date` is modified
    in the user interface, the method must be called.
  prefs: []
  type: TYPE_NORMAL
- en: In the body of the method, we calculated the duration, and we used an attribute
    assignment to update the `duration` attribute of the from view.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen in this recipe, the basic use of `onchange` methods is to compute
    new values for fields when some other fields are changed in the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the body of the method, you get access to the fields that are displayed
    in the current view of the record, but not necessarily all the fields of the model.
    This is because `onchange` methods can be called while the record is being created
    in the user interface before it is stored in the database! Inside an `onchange`
    method, `self` is in a special state, denoted by the fact that `self.id` is not
    an integer, but an instance of `odoo.models.NewId`. Therefore, you must not make
    any changes to the database in an `onchange` method since the user may end up
    canceling the creation of the record, which will not roll back any changes made
    by the `onchange` method during the process of editing.
  prefs: []
  type: TYPE_NORMAL
- en: Calling onchange methods on the server side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `onchange` method has a limitation: it will not be invoked when you are
    performing operations on the server side. `onchange` is only invoked automatically
    when the dependent operations are performed through the Odoo user interface. Yet,
    in several cases, these `onchange` methods must be called because they update
    important fields in the created or updated record. Of course, you can do the required
    computation yourself, but this is not always possible since the `onchange` method
    can be added or modified by a third-party add-on module that’s been installed
    on the instance that you don’t know about.'
  prefs: []
  type: TYPE_NORMAL
- en: This recipe explains how to call the `onchange` methods on a record by manually
    invoking the `onchange` method before creating a record.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Changing the user that performs an action* recipe, we added a **Return
    Room** button so that users can update the room and hostel by themselves. We now
    want to do the same for returning the room and hostel; we will just use the **Assign
    Room** return wizard.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will manually update a record of the `hostel.room` model.
    To do this, you need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `Form` from the `tests` utility in the `hostel.student.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `return_room` method in the `hostel.room` model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get an empty recordset for `assign.room.student.wizard`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a wizard `Form` block, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Trigger `onchange` by assigning a room and then return the updated value of
    `room_id`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For an explanation of *Steps 1* to *3*, refer to the *Creating new records*
    recipe in [*Chapter 5*](B20997_05.xhtml#_idTextAnchor238), *Basic* *Server-Side
    Development*.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 4*, we created a virtual form to handle onchange specifications, such
    as the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 5* contains the full logic to return the room and hostel. In the first
    line, we assigned `room_id` in the wizard. Then, we called the `save()` method
    of the form, which returned a wizard record. After that, we called the `add_room_in_student()`
    method to execute the logic to return the updated room and hostel.'
  prefs: []
  type: TYPE_NORMAL
- en: The `onchange` method is mostly invoked from the user interface. But in this
    recipe, we have learned how to use/trigger the business logic of the `onchange`
    method on the server side. This way, we can create records without bypassing any
    business logic.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to learn more about creating and updating records, refer to the
    *Creating new records* and *Updating the values of recordset records* recipes
    in [*Chapter 5*](B20997_05.xhtml#_idTextAnchor238), *Basic* *Server-Side Development*.
  prefs: []
  type: TYPE_NORMAL
- en: Defining onchange with the compute method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last two recipes, we saw how to define and call the `onchange` method.
    We also saw its limitation, which is that it can only be invoked automatically
    from the user interface. As a solution to this problem, Odoo v13 introduced a
    new way to define `onchange` behavior. In this recipe, we will learn how to use
    the `compute` method to produce behavior similar to that of the `onchange` method.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use the `my_hostel` module from the previous recipe.
    We will replace the `onchange` method of `hostel.student` with the `compute` method.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to modify the `onchange` method with the `compute` method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace `api.onchange` in the `onchange_duration()` method with `depends`,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `compute` parameter in the definition of the field, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Upgrade the `my_hostel` module to apply the code, then test the return duration
    form to see the change.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functionally, our computed `onchange` works like the normal `onchange` method.
    The only difference is that now, `onchange` will be trigged upon backend changes
    too.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 1*, we replaced `@api.onchange` with `@api.depends`. This is required
    to recompute the method when the field value changes.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 2*, we registered the `compute` method with the field. As you may have
    noticed, we used `readonly=False` with the `compute` field definition. By default,
    `compute` methods are read-only, but by setting `readonly=False`, we are making
    sure that the field is editable and can be stored.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn more about computed fields, refer to the *Adding computed fields to
    a model* recipe in [*Chapter 4*](B20997_04.xhtml#_idTextAnchor118), *Application
    Models*.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a model based on a SQL view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working on the design of an *add-on* module, we model the data in classes
    that are then mapped to database tables by Odoo’s ORM. We apply some well-known
    design principles, such as *separation of concerns* and *data normalization*.
    However, at later stages of the module design, it can be useful to aggregate data
    from several models in a single table and to maybe perform some operations on
    them on the way, especially for reporting or producing dashboards. To make this
    easier, and to make use of the full power of the underlying `PostgreSQL` database
    engine in Odoo, it is possible to define a read-only model backed by a PostgreSQL
    view, rather than a table.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will reuse the room model from the *Writing a wizard to guide
    the user* recipe in this chapter, and we will create a new model to make it easier
    to gather availability about rooms and authors.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use the `my_hostel` module from the previous recipe.
    We will create a new model called `hostel.room.availability` to hold the availability
    data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a new model backed by a PostgreSQL view, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new model with the `_auto` class attribute set to `False`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the fields you want to see in the model, setting them as `readonly`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `init()` method to create the view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can now define views for the new model. A pivot view is especially useful
    to explore data (refer to [*Chapter 9*](B20997_09.xhtml#_idTextAnchor446), *Backend
    Views*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don’t forget to define some access rules for the new model (take a look at [*Chapter
    10*](B20997_10.xhtml#_idTextAnchor549), *Security Access*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Normally, Odoo will create a new table for the model you are defining by using
    the field definitions for the columns. This is because, in the `BaseModel` class,
    the `_auto` attribute defaults to `True`. In *Step 1*, by setting this class attribute
    to `False`, we tell Odoo that we will manage this by ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 2*, we defined some fields that will be used by Odoo to generate a
    table. We took care to flag them as `readonly=True` so that the views do not enable
    modifications that you will not be able to save since PostgreSQL views are read-only.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 3*, we defined the `init()` method. This method normally does nothing;
    it is called after `_auto_init()` (which is responsible for table creation when
    `_auto = True` but does nothing otherwise), and we use it to create a new SQL
    view (or to update the existing view in the case of a module upgrade). The view
    creation query must create a view with column names that match the field names
    of the model.
  prefs: []
  type: TYPE_NORMAL
- en: Important tip
  prefs: []
  type: TYPE_NORMAL
- en: It is a common mistake to forget to rename the columns in the view definition
    query. This will cause an error message when Odoo cannot find the column.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we also need to provide an `integer column` value called `ID` that
    contains unique values.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is also possible to have some computed and related fields on such models.
    The only restriction is that the fields cannot be stored (and therefore, you cannot
    use them to group records or search).
  prefs: []
  type: TYPE_NORMAL
- en: If you need to group by base user, you need to store the field by adding it
    to the view definition, rather than using a related field.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn more, take a look at the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about UI views for user actions, refer to [*Chapter 9*](B20997_09.xhtml#_idTextAnchor446),
    *Backend Views*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a better understanding of access control and record rules, take a look at
    [*Chapter 10*](B20997_10.xhtml#_idTextAnchor549), *Security Access*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding custom Settings options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Odoo, you can provide optional features through the **Settings** options.
    The user can enable or disable this option at any time. We will illustrate how
    to create **Settings** options in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous recipes, we added buttons so that hostel users can click and return
    rooms. This is not the case for every hostel; however, we will create a `my_hostel`
    module from the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create custom **Settings** options, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new field by inheriting the `res.config.settings` model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add this field to the existing `xpath` (for more details, refer to [*Chapter
    9*](B20997_09.xhtml#_idTextAnchor446), *Backend Views*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add some actions and a menu for **Settings**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Restart the server and update the `my_hostel` module to apply the changes,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.7 – The hostel user access right settings option to enable and disable
    this feature](img/B20997_08_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – The hostel user access right settings option to enable and disable
    this feature
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Odoo, all settings options are added in the `res.config.settings` model.
    `res.config.settings` is a transient model. In *Step 1*, we created a new security
    group. We will use this group to create the **Hide** and **Show** buttons.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2*, we added a new `Boolean` field in the `res.config.settings` model
    by inheriting it. We added an `implied_group` attribute with a value of `my_hostel.group_hostel_user`.
    This group will be assigned to all `odoo` users when the admin enables or disables
    options with the `Boolean` field.
  prefs: []
  type: TYPE_NORMAL
- en: '`base.res_config_settings_view_form`.'
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 3*, we added our option to the user interface by inheriting this setting
    from the view. We used `xpath` to add our `setting` option. We will cover this
    in more detail in [*Chapter 9*](B20997_09.xhtml#_idTextAnchor446), *Backend Views*.
    In the form definition, you will find that the attribute data-key value of this
    option will be your module name. This is only needed when you are adding a whole
    new tab in `xpath`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Step 4*, we added an action and a menu to access the configuration options
    from the user interface. You will need to pass the `{''module'': ''my_hostel''}`
    context from the action to open the `my_hostel` module by default when the menu
    is clicked.'
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 5*, we added `my_hostel.group_hostel_user` groups to the buttons. Because
    of this group, the **Hostel User** and **Return** buttons will be hidden or shown,
    based on the **Settings** options.
  prefs: []
  type: TYPE_NORMAL
- en: After this, you will see a separate `Boolean` field to enable or disable the
    `implied_group` to or from all `odoo` users. Because we added the groups to buttons,
    the buttons will be displayed if the user has groups and will be hidden if the
    user doesn’t have groups. We will look at security groups in detail in [*Chapter
    10*](B20997_10.xhtml#_idTextAnchor549), *Security Access*.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few other ways to manage the `install` or `uninstall` them through
    various options. To do this, you will need to add a `Boolean` field with the name
    of the module prefixed with `module_`. If, for example, we create a new module
    called `my_hostel_extras`, you will need to add a `Boolean` field, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: When you enable or disable this option, `odoo` will `install` or `uninstall`
    the `my_hostel_extras` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to manage settings is to use system parameters. Such data is stored
    in the `ir.config_parameter` model. Here’s how you can create system-wide global
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `config_parameter` attribute in the fields will ensure the user data is
    stored in `digest.default_digest_emails` key.
  prefs: []
  type: TYPE_NORMAL
- en: Settings options are used to make your application generic. These options give
    freedom to users and allow them to enable or disable features on the fly. When
    you convert a feature into options, you can serve more customers with one module
    and your customers can enable the feature whenever they like.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing init hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B20997_06.xhtml#_idTextAnchor319), *Managing Module Data*,
    you learned how to add, update, and delete records from XML or CSV files. Sometimes,
    however, the business case is complex, and it can’t be solved using data files.
    In such cases, you can use the `init` hook from the manifest file to perform the
    operations you want.
  prefs: []
  type: TYPE_NORMAL
- en: Complex business cases may require dynamic initialization of data beyond standard
    XML or CSV files. Examples include integrating with external systems, performing
    complex calculations, or configuring records based on runtime conditions, facilitated
    by the `init` hook in the manifest file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the same `my_hostel` module from the previous recipe. For simplicity,
    in this recipe, we will just create some room records through `post_init_hook`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add `post_init_hook`, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Register the hook in the `__manifest__.py` file with the `post_init_hook` key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `add_room_hook()` method to the `__init__.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Step 1*, we registered `post_init_hook` in the manifest file with the `add_room_hook`
    value. This means that after the module is installed, Odoo will look for the `add_room_hook`
    method in `__init__.py`. The `post_init_hook` value receives the environment as
    an argument, showcasing an instance of the `add_room_hook` function that executes
    after module installation.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 2*, we declared the `add_room_hook()` method, which will be called
    after the module is installed. We created two records from this method. In real-life
    scenarios, you can write complex business logic here.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we looked at `post_init_hook`, but Odoo supports two more
    hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pre_init_hook`: This hook will be invoked when you start installing a module.
    It is the opposite of `post_init_hook`; it will be invoked after installing the
    current module:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Register the hook in the `__manifest__.py` file with the `pre_init_hook` key:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `pre_init_hook_hostel()` method to the `__init__.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`uninstall_hook`: This hook will be invoked when you uninstall the module.
    This is mostly used when your module needs a garbage-collection mechanism:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Register the hook in the `__manifest__.py` file with the `uninstall_hook` key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `uninstall_hook_user()` method to the `__init__.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Hooks are functions that run before, after, or in place of existing code. Hooks
    – functions that are displayed as strings – are contained in the `__init__ .py`
    file of an Odoo module.
  prefs: []
  type: TYPE_NORMAL
