- en: Chapter 7. Power of APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter takes you on a journey to the interesting world of APIs. APIs are
    a critical part of the business world today. Tasks like querying data, exchanging
    information across services amongst others rely on web APIs and Webhooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing your own REST APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating social media marketing with Twitter APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to Webhooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Webhooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating lead management with Webhooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: APIs have become absolutely indispensable in the world driven by the Internet.
    Every web application that you must have interacted with uses an API on the backend
    to implement its core functionality--Amazon, Google, Twitter, you name it! What's
    more, you see all these applications thrive on APIs. Amazon uses it to drive its
    payment transactions and Google for showing you all the fancy maps. APIs are so
    essential to business that you hear the word API right from CEOs to managers,
    all the way to software developers. In general, using an API is a fundamental
    way of enabling different software to talk to each other. Operating system operations
    are also performed with APIs. They have been absolutely critical from the very
    beginning of computing.
  prefs: []
  type: TYPE_NORMAL
- en: But what are APIs and how are they useful? How to develop APIs of our own? How
    do they find their way into business process automation? We'll find answers to
    all these questions in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with a more familiar and older web term: web service. Web services
    are essentially the key points of integration between different applications hosted
    across platforms and built on different languages using independent systems. Web
    services communicate with each other via WWW and typically involve two parties:
    one that exposes a set of APIs, also known as the server, and another that calls
    or consumes the server APIs, also known as consumers or clients. Web services
    are independent of the client implementation and thus work well with browsers,
    mobile phones, or just any software that can make an API call.'
  prefs: []
  type: TYPE_NORMAL
- en: 'They use different protocols for communication, with different messaging and
    URI contracts. The most common implementations of web services are:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP-based **REST** (**Representation State Transfer**) web service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOAP-based (**Simple Object Access Protocol**) web service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML **RPC** (**Remote Procedure Call**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Messaging formats that have been commonly used for these services are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JSON** (**JavaScript Object Notation**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XML** (**eXtensible Markup Language**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web services are at the very core of web applications today and hence need to
    provide good performance; they need to be scalable and reliable.
  prefs: []
  type: TYPE_NORMAL
- en: Right, so in this chapter, we'll cover HTTP-based REST APIs. You'll understand
    how to develop RESTful web services with Python in detail. You'll also learn how
    clients automate their business processes using RESTful web services.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that there are different terminologies available for referring to APIs,
    for example, the HTTP API, Web API, and so on. I suggest you read about them for
    better clarity. However, essentially, at their core APIs are integration points
    between two services in an application or between multiple servers/services across
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at multiple Python modules, mentioned in the following
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`flask` ([http://flask.pocoo.org/](http://flask.pocoo.org/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`twython` ([https://twython.readthedocs.io/en/latest/](https://twython.readthedocs.io/en/latest/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytz` ([https://pypi.python.org/pypi/pytz](https://pypi.python.org/pypi/pytz))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django` ([https://www.djangoproject.com/](https://www.djangoproject.com/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django-rest-hooks` ([https://github.com/zapier/django-rest-hooks](https://github.com/zapier/django-rest-hooks))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing your own REST APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Representational State Transfer** (**REST**) has gained lot of preference
    and popularity in the community and is virtually the default architectural style
    for designing and implementing RESTful web services.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that there are other possible implementations of web services for which
    you can follow the SOAP and XML-RPC way, these are not within the scope of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll learn how to implement a simple RESTful web service using
    the Python flask micro framework. We'll implement a user service for user management,
    which is an imperative aspect of any web application.
  prefs: []
  type: TYPE_NORMAL
- en: The REST architecture is designed to fit with the HTTP protocol and has the
    notion of resources, that is, **Uniform Resource Identifiers** (**URIs**). Clients
    send requests to these URIs with different HTTP request methods and get back the
    state of the affected resources as a response.
  prefs: []
  type: TYPE_NORMAL
- en: So what are we waiting for? Let's design and implement the user web service.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s begin by defining our model--**user**. Our user resource would be typically
    identified by these attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`id`: A unique ID to identify the user'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username`: The name of the user used in the application'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`: The e-mail address of the user for e-mail notifications'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`: To check whether the user is active or verified'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Designing REST APIs involves identifying resources (URIs) and verbs (HTTP methods)
    that take action on the user model. We need to perform actions such as creating
    a new user, updating certain attributes of the user, getting a user or list of
    users, or if needed deleting a user. We also need to relate our actions to HTTP
    verbs and have to define CRUD operations for our service. **CRUD** means performing
    the **Create, Read, Update, and Delete** operations on a user model. The following
    table shows exactly what we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **URI** | **Method** | **Action** |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `http://v1/users/` | `GET` | To get a list of available users |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `http://v1/users/` | `POST` | To create a new user |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `http://v1/users/1/` | `GET` | To get details of an existing user with ID
    equal to 1 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `http:///v1/users/1/` | `PUT`/`DELETE` | To update or remove the user with
    ID equal to 1 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Now let's write the code to implement the RESTful user service. We start by
    creating a virtual environment. I hope we all know about `virtualenv`, but for
    beginners virtual environment is a tool that isolates Python modules. This helps
    in resolving issues related to permissions; it also helps to avoid polluting the
    global Python installation and to manage versions of the same module used across
    applications. If you don't have `virtualenv` on your system, you can install it
    using Python `pip` or download it from [https://pypi.python.org/pypi/virtualenv](https://pypi.python.org/pypi/virtualenv).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have `virtualenv` installed, we need to activate it using a simple
    command. As you can see in the second line in the following, the `virtualenv`
    user has been activated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s go ahead and install `flask` in our virtual environment. We do this
    with the help of Python `pip` using the `pip install flask` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you look at the installation logs, we seem to have installed `flask` along
    with the template engines `Jinja2` and `Werkzeug`, a WSGI utility that supports
    multiple operations, such as cookie handling, file uploads, and request/response
    objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Okay good! We have `flask` installed and the environment is nicely set up.
    Let''s write a minimalistic web application and name it `app.py`. The code for
    our web service looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you run the app, you will see the Flask server running on port 5000:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you try to access the server on port 5000, you will see what we intended:![How
    to do it...](img/image_08_001.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Great! Now let''s improve on this to implement the user REST APIs. We first
    implement HTTP''s `GET` on the `/v1/users/` resource. In the following code, we
    implement a `flask` route with the `get_users()` API to return all the users in
    JSON format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we rerun the app (if you're using an editor such as PyCharm, it will itself
    reload the app for you every time you save your code), our `flask` route gets
    loaded; we can now make an HTTP `GET` request on the `/v1/users/` API. The output
    of the request will yield the response, as seen in the next screenshot. Hey, cool!
    We wrote our first resource for the RESTful user service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice the header section of the response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Content-Type` is application/JSON (we''ll talk about message formats later
    in the chapter)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Server is Werkzeug on which Flask is based
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Date refers to when the server responded to the request
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The response body has the following:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An output with the users key containing information for all the users
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Information about a user consists of desired attributes such as ID, username,
    e-mail, and account status
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The response format is JSON, as indicated in the headers
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we use the RESTED plugin of Firefox to make these requests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_002.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Nice! We have the first URI implemented as part of user service. Now let''s
    quickly go ahead and implement the next resource. Here, we need to get the user
    based on the ID. The following `flask` route will do the job for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we defined a `flask` route with the API `get_user(id)`,
    which takes the user ID as an argument. When we make an HTTP `GET` request on
    this URI, the `get_user()` API gets invoked; it internally looks up all the available
    users to locate the user with the desired ID. If the user is found, the user record
    is returned in JSON format; if not, the server sends an HTTP 404 response. Here's
    a screenshot illustrating this:![How to do it...](img/image_08_003.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You want users to sign up on your web application, right? So let''s write a
    `flask` route that will help create a new user. The following code performs this
    operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now if you make an HTTP `POST` request on the `/v1/users/` resource and pass
    user information to the body, you''ll be able to create a new user. By default,
    the status of the user will be inactive (`''active'': False`); you can make it
    `''active'': False` when the user verifies her/his e-mail address:![How to do
    it...](img/B05370_08_56.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'OK! Now let''s quickly look at the REST APIs that will edit the user details
    and delete the user if needed. The following flask route will edit the user details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now if we perform the HTTP `PUT` operation on the `/v1/users/:id/` resource
    with the changed data, we should be able to update the user information. In the
    following screenshot, the request body contains the new e-mail address that needs
    to be updated for user ID equal to `1`. When we make an HTTP `PUT` request, the
    information gets updated and we have the new e-mail address for the user:![How
    to do it...](img/B05370_08_78.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The only operation pending now is to implement the `DELETE` operation. We can
    use this operation to delete a user. But you might ask, "Why would I delete the
    user?" So you can have your own implementation of `DELETE`; possibly, you can
    make the user inactive (by setting the `active` attribute to `False`). But for
    the sake of this discussion, let's delete the user for the heck of it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code deletes the user based on the user ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `DELETE` operation typically returns the status code **204 NO CONTENT**,
    which is shown in the following screenshot:![How to do it...](img/image_08_008.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cool! So we have our RESTful user service completely implemented and up-and-running.
    Great!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REST is an architectural style of the WWW. It consists of a coordinated set
    of components where the focus is on component roles and interactions between data
    elements rather than the implementation. Its purpose is to make the Web more scalable,
    portable, and reliable, and improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The REST architecture works according to the following constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client-server**: A **Uniform Resource Locator** (**URL**) separates the REST
    API from the client. Servers are not concerned about the user interface or the
    state; as a result, REST APIs are more scalable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateless**: This means every request is independent and has no connection
    to the previous request or client. The client must contain all the necessary information
    to complete the request, and the session state remains with the client and hence
    is not stored on the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cacheable**: RESTful web service can cache or not cache responses. Services
    must let the clients know whether the response is cached. This helps improve the
    performance of the system as some requests may no longer be needed based on the
    cache expiry time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layered system**: A client may or may not directly interact with the server;
    they can always have intermediary servers such as caches or load balancers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uniform resource**: Each REST resource should be independent; this allows
    you to have a separation of concerns, and it decouples the architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code on demand**: The server can provide code for clients to execute in their
    context. This is an optional requirement though.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GET` and `HEAD` methods are examples of safe methods as they don't change
    the state of the resource. The `PUT`/`DELETE` methods are idempotent. This means
    clients can make multiple similar calls to the resource and the resource will
    behave in the exact same way; of course, the response itself will have been changed
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Cool! So now we're in a position to create our own RESTful APIs. We can now
    host these on the Internet for our customers to use or implement functionalities
    in our web applications. Nice work!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We looked at the fundamentals of the REST architecture and learned how to design
    a RESTful web service. We were helped by the Flask micro framework and learned
    how to write our own REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we'll see how the clients, due to their needs, consume REST
    APIs. We will also learn about using REST APIs to automate business processes.
  prefs: []
  type: TYPE_NORMAL
- en: Automating social media marketing with Twitter APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Joy is a marketing manager of a world-known consumer brand. She handles the
    content marketing portfolio of the company and heavily relies on blogs and social
    media to showcase the company's product line and create a buzz in the market.
  prefs: []
  type: TYPE_NORMAL
- en: Without doubt, she has a few problems! Some of the products that she markets
    have been designed differently for different markets, so she has to work across
    time zones to make sure her content gets published at the right time. She also
    feels the need to repeat her posts just to make sure she reaches the majority
    of her customers; this would also help in improving brand recognition.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you carefully analyze her situation, Joy has two issues. One, she has to
    ensure her social media content is posted at the right time, based on her customer
    market. So if her product is being sold in Australia, she needs to make sure that
    her tweets are posted as per the Australian time when her customers are most likely
    to view them. Second, to get more traction for her product announcements, such
    as a weekend offer, she may want to repeat a few tweets at a later point in time.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK! Now that we understand her problem, let''s try to devise a solution. Looks
    like we need to take care of the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: We should provide her with the capability of posting tweets in an automated
    fashion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Her tweets should go at a desired time, even if Joy is asleep
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should also provide the capability of scheduling repeat tweets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'REST APIs to the rescue! Twitter has a fabulous set of REST APIs that can be
    used by the users for playing with Twitter data, user information, and of course
    posting tweets. You can also perform multiple operations such as uploading images,
    querying timelines, and sending direct messages. Wow! That''s cool! But lets not
    get distracted and instead move on to the problem at hand:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s see how we can post tweets using Python even without logging
    in to Twitter. To post tweets, we will use a Python library called `twython`.
    So let''s install `twython` using our friend, the Python `pip`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: But before we can start playing with our Twitter account, we'd need to register
    an app with Twitter. This makes sure that Twitter is aware of our API calls and
    considers them legitimate. We can register an app by navigating to [https://apps.twitter.com/](https://apps.twitter.com/)
    and clicking on **Create New App**. You can fill in the details as shown in the
    following screenshot and create your app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Please note a few things about the details you need to fill in:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The application name is unique across all the users on Twitter, so try to make
    it really unique to you, but at the same time keep it simple
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Make a description that exactly defines your use case so you remember it later
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Fill in your website name; keep it short
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A callback URL is only needed if you want Twitter to send data to you about
    your authentication, which is not needed for this exercise
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_009.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: You also need to get your App Key and App Secret, and for that you need OAuth
    Token and OAuth Token Secret. These are needed essentially to authenticate your
    API calls with Twitter, or else Twitter will reject your REST API calls as malicious.
    You will get these details by clicking on your newly created app and browsing
    to the **Keys and Access Tokens** tab at the top of your page. You can also navigate
    to `https://apps.twitter.com/app/<app_id>/keys/` to get these details:![How to
    do it...](img/image_08_010.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'OK! Let''s write some of the code and check whether we''re good to work with
    Twitter''s REST APIs. The following code makes a call to the Twitter timeline
    REST API and pulls the details of the topmost tweet on your timeline. Here we
    perform an HTTP `GET` operation on the [https://dev.twitter.com/rest/reference/get/statuses/home_timeline](https://dev.twitter.com/rest/reference/get/statuses/home_timeline)
    REST API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding code snippet is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_011.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: That's cool! We get all the essential details from the post on our timeline.
    Looks like we're all set then with respect to the Twitter App and Keys.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s try to tweet with the status''s REST API by posting data to it.
    The REST API used here is [https://dev.twitter.com/rest/reference/post/statuses/update](https://dev.twitter.com/rest/reference/post/statuses/update).
    The following Python code will make a `POST` request on this REST resource and
    create a tweet on behalf of my account on Twitter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After running the preceding code, I looked at Twitter, and voilà! I had a tweet
    under my name in an automated manner. Here''s a screenshot of the tweet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_012.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: So we have solved the first problem for Joy. The tweet can be posted on her
    behalf even when she is unavailable or can't log in to the Internet, and this
    can be done using the preceding Python code snippet. But she can't schedule her
    tweet as per the Australian time zone yet. Hmm, let's look at resolving the scheduling
    problem now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before we look at how to schedule tweets, we will install a module that will
    be very useful for the next recipe. We will install `pytz`. It helps us work with
    time zones and will be helpful in solving Joy''s problem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To solve the scheduling problem, we need two things. First, we need a configuration
    that can be used to decide the content, time, and time zone of the tweet. Second,
    we need a runner program that will use this configuration to post a tweet on Twitter.
    Now let''s look at the following code, which does exactly what we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows. Here''s the first iteration:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_013.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Here''s the second iteration:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_014.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Here''s the actual tweet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_015.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Cool! So we have what Joy needs. An automated tweet with the right content at
    the right time for the right audiences across the globe. Woohoo!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding code snippets, we have two files. We have `tweet_config.py`,
    and it contains a configuration dictionary that is used to specify the content
    and schedule of the tweets. It also mentions the time zone in which the tweets
    need to be posted.
  prefs: []
  type: TYPE_NORMAL
- en: The second file `scheduled_tweets.py` is a runner program. It looks at the configuration
    every minute and checks whether there is any tweet scheduled for the given minute
    of the day.
  prefs: []
  type: TYPE_NORMAL
- en: When the runner program, `scheduled_tweets.py`, runs, it checks whether there
    are any messages scheduled. In iteration 1, the runner program doesn't find anything
    that it needs to work on; it just returns the current day and time of the time
    zone.
  prefs: []
  type: TYPE_NORMAL
- en: In iteration 2, it does find that there is a tweet scheduled in the Australian
    time zone, Sydney to be precise, at 13:25 hours on August 27;^, since the time
    matched, it posted a tweet. Of course, the example taken here is a very crude
    one. We might want to schedule Cron jobs instead of an endless while loop. But
    hey, this was an example to bring home the point about automatically scheduled
    tweets.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we automated the marketing process for Joy. Now she can not
    only tweet when she is is asleep, but also schedule tweets for different time
    zones and with different content. Now that's the power of automation.
  prefs: []
  type: TYPE_NORMAL
- en: '"But hey, this is just one social media platform; what about Facebook?" you
    might ask. Yes, we have a trick up our sleeves. Twitter provides apps for connecting
    you to multiple services, including Facebook. So configure an app for your account
    so that every tweet that you post also gets posted on Facebook. This is how the
    configuration looks. It posts your original tweets and retweets them on your Facebook
    profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image_08_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Remember the first message that we posted about Python antigravity? Yes, it
    actually got posted on the Facebook wall as well. Look at the source next to the
    date and time of the tweet; yes it''s Twitter! Perhaps, Twitter uses Facebook
    APIs to automate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image_08_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An introduction to Webhooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last section, we understood how to design and develop REST APIs and
    how to leverage REST APIs to our benefit by taking an example of Twitter/Facebook
    automation. Let''s look at another amazing piece: Webhooks. A Webhook is an HTTP
    callback--an HTTP `POST` request to a user-defined URL (implemented as an HTTP
    API) when a favorable event occurs. Webhooks are often referred to as reverse
    APIs and are used for real-time communication or integration across services.
    But before we go deeper, let''s understand a bit about polling.'
  prefs: []
  type: TYPE_NORMAL
- en: You might have seen applications polling for long hours to check whether an
    event has occurred so that they can perform some follow-up action for the event.
    Take a real-world example. You go to a self-service restaurant and order your
    favorite pizza for lunch. The guy at the counter gives you an order number and
    tells you to watch the token machine for your order number so that you can collect
    your pizza. While everybody around is busy eating, you are hungry and tend to
    watch this token machine every 5 seconds hoping to see your order number flash
    on it. Now this is polling. You are polling the token machine. In the API world,
    the client would be polling the pizza place API to check the status of the order.
  prefs: []
  type: TYPE_NORMAL
- en: Wouldn't it be simple enough for the guy at the service counter to shout the
    order number when its ready? So after placing your order, you could get busy checking
    your official e-mails. When the service guy calls out your order number, you can
    collect your pizza from the delivery counter. This makes sure that your time is
    better utilized. Now this is a Webhook. When a favorable event occurs (your order
    is ready), you get a callback (the service guy shouts your order number) on your
    URL (in this case, your ears) that is literally listening and responding to callbacks.
    In the API world, you'd register your URL (the HTTP API) that gets called by the
    pizza place when your order is ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'Webhooks can be used for three main purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Receiving data in real time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving data and pushing it on to another service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving the data and then processing and returning it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can think of many different ways of using Webhooks in the preceding three
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: If you think of polling and Webhooks, they both use APIs for integration needs.
    While polling is a client-driven integration technique, Webhooks are server-driven.
    Polling is very inefficient in the sense that the client keeps making server API
    calls to check the state of the resource (in our example, an order resource) with
    the help of a time stamp. Polling can happen every *x* minutes, *x* hours, or
    even *x* seconds to become more real time, but I think you get the inefficiencies
    associated with polling. On the other hand, Webhooks post data back to the callback
    URIs in the case of a favorable event. This is much more efficient than constant
    polling, but the flip side is you end up developing APIs on the client side, so
    your client tends to behave like a server itself.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Webhooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this knowledge, let's get started and implement Webhooks in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use a famous Python web framework called **Django**.
    It allows you to use multiple plugins that get simply plugged in. Here, we will
    use the `django-rest-hooks` plugin developed by Zapier for implementing Webhooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s gets started and install the required packages. We install `Django==1.10`
    and `django-rest-hooks==1.3.1` using our favorite tool, Python `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OK, let''s create a Django app. We do this with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's configure Django to use the `rest_hooks` module in the app. We do
    this by adding `rest_hooks` to `bookstore/settings.py` under `INSTALLED_APPS`.
    We also add our app book to this list. Add an event, namely `user.signup`, to
    `settings.py` by using the constant `HOOK_EVENTS`. We haven't tied the event `user.signup`
    to any action here, so it's none. This is how `settings.py` should look like:![How
    to do it...](img/image_08_018.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s register this event to a callback URL. But before we go there,
    navigate to the root of your project and run this command to initialize your Django
    models:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the models are initialized, go to the database shell and run the following
    Python code snippets. They will create a user in the Django user table and register
    a Webhook for this user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add a file called `urls.py` to the Book app and add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following methods to `book/views.py` to create Django views:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, include these URLs in the project under `bookstore.urls.py` like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now run the Django server as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From your browser, go to `http://localhost:8000/event/` and look at your server
    logs. You will see that the registered Webhook got invoked, which means an HTTP
    `POST` request was sent to the target URL `http://localhost:8000/hook/` along
    with the payload, which contains all of the information we configured in the view.
    The server logs look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Cool! Did you look at it? We invoked the /event URL, which in turn posted the
    required information to the target URL, which was registered for the event `user.signup`
    in our Webhook.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to custom Webhooks, one could also develop RESTful Webhooks. RESTful
    Webhooks support subscription, notification, and publication actions through a
    RESTful interface. RESTful Webhooks must support four event types, namely `ACCESSED`,
    `CREATED`, `UPDATED`, and `DELETED`, which correspond to four HTTP verbs; notifications
    should be sent for the actions that get applied to the resource. For instance,
    when a resource gets created, an event gets generated; with this, the Webhook
    must be triggered and the target URL should be posted. In our example, we can
    define two more hook events, namely `book.added` and `book.deleted`, along with
    actions such as `book.Book.added` or `book.Book.deleted`. When we do a `book.save()`
    action on the model, the `book.added` event gets triggered, and if we have a hook
    defined for this event for the user, the HTTP `POST` request will be called on
    the target URL.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding code snippets, we first defined an event in the `settings.py`
    file. The event was named `user.signup`. Since it was a custom event, it had no
    action defined.
  prefs: []
  type: TYPE_NORMAL
- en: We then created a new user `chetan` in the `auth_user` table using the default
    Django user model.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we defined a Webhook for the the user `chetan`. This Webhook was configured
    for the event `user.signup`, and the target URL was set to `http://localhost:8000/hook/`.
  prefs: []
  type: TYPE_NORMAL
- en: We also defined two views in our Django app. The first view event was responsible
    for firing the Webhook for the corresponding user and event and for sending the
    payload information. The second view Webhook was defined for the target URL.
  prefs: []
  type: TYPE_NORMAL
- en: We then ran the Django development server and navigated to `http://localhost:8000/event/`,
    which posted the payload information to the target URL, namely `http://localhost:8000/hook/`.
    The target URL received all of the payload data, such as the username, e-mail,
    and the time when the signup happened.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we looked at polling and Webhooks, which are other forms of
    integration on the Web that use APIs. We learned inefficiencies with polling and
    how Webhooks were much more useful. In the preceding recipe, we covered a custom
    event useful for user signup as I wanted it to explain the concept in a generic
    way. The coverage was brief, so I would like you to study more about RESTful Webhooks
    as they present a powerful use case for automation. With this understanding, let's
    see what problems Oliver has and how we can help him.
  prefs: []
  type: TYPE_NORMAL
- en: Automating lead management with Webhooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Oliver is Joy''s colleague and works in the marketing department. He is responsible
    for the user onboarding process. His primary responsibility includes:'
  prefs: []
  type: TYPE_NORMAL
- en: Sending a welcome e-mail to users who sign up on your website
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a lead record for the new signee into the CRM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Previously, it was easy for him to perform these two tasks manually since the
    signups on the site were minimal. But with the growing popularity of the website,
    he has begun to see an upsurge in the number of signups on a daily basis. Without
    doubt, he sees this as a highly time-consuming activity that can be easily automated.
    Can you help Oliver?
  prefs: []
  type: TYPE_NORMAL
- en: If we carefully analyze the problem, Oliver's main issue is integration across
    services. The two services that he needs to integrate the signup are e-mail and
    CRM. He needs to track a signup event and take an action on this event. Webhooks
    are a perfect solution for this use case. Let's see how we can help Oliver automate
    his task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the same Django project to solve this problem. We will also use
    an external service, Zapier, and see how it helps make things so much easier.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Terminal, go to the Django project''s root directory and run the Python
    `manage.py` shell command to log in to the DB shell. Here, update our user `chetan`
    with the e-mail address. This can be achieved with the following set of commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now create an account with the Zapier app by navigating to [https://zapier.com/](https://zapier.com/).
    Once you have the account created, click on **MAKE A ZAP!** to reach **Choose
    App** and click on **Webhooks** under the **BUILT-IN APPS** section:![How to do
    it...](img/image_08_019.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you select a Webhook, you will get a screen to create a **TRIGGER** and
    **ACTION** on the left-hand pane. On the right-hand side, select the **Catch Hook**
    option. Click on **Save + Continue**. Refer to the following screenshot:![How
    to do it...](img/image_08_020.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will get the page to provide a JSON key that you want to select from
    the payload. This is an optional step and can be ignored. Click on **Continue**
    to reach the next step. Here, you'll get a custom Webhook URL. Copy this URL;
    it will act as a target URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now go back to your Django project and navigate to the DB shell. Create a new
    hook with the same event `user.signup` and target the URL that you received from
    Zapier in the earlier step. The commands will look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the Django development server with the `runserver` command of Python `manage.py`.
    Once the server is running, go to `http://localhost:8000/event/`; this will make
    a callback request to the target URL obtained from Zapier. You can verify this
    by going to Zapier again and looking at **Test this Step** on the left pane, under
    the **Catch Hook** section:![How to do it...](img/image_08_021.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cool! We now have the trigger set up. Let's set up the action. For this, go
    to your left-hand pane and click on **Set up this step** under **ACTION**. Choose
    Gmail from the list of apps that will show up on the right-hand side of the screen:![How
    to do it...](img/image_08_022.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you click on **Gmail**, you get the next option to select an action, such
    as **Create Draft** or **Send Email**. Click on **Send Email** and activate your
    e-mail account by allowing Zapier to access it. The following screenshots will
    show you how to perform these steps:![How to do it...](img/image_08_023.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the next screenshot, we allow Zapier to access the Gmail app:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_024.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: OK! Now the only thing pending is to create the e-mail template. Our template
    contains the **To** e-mail address, subject, and body. Zapier gives you a nice
    option to configure your template. If you have already tested your trigger by
    posting data to the target URL, you will see a set of options on the extreme right
    of every field in the e-mail template. In the next two screenshots, I have **Data
    Email** in the **To** field, **Welcome Data Username!** in the **Subject** field,
    and **Your Signup made our day!** as the e-mail body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following screenshot shows a dropdown of all the available options from
    the payload that the target URL received in the **Test this Step** section of
    the trigger. I have just shown the username. Look how the field name **To** of
    the template can chose **Data Username** from the payload:![How to do it...](img/image_08_025.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The e-mail template with all the necessary fields configured can be seen in
    the following screenshot. We have configured the **To**, subject, and body parts
    of the e-mail in Zapier:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_026.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: That's it! Click on **Continue** at the bottom of this screen; Zapier will test
    your action and you're done. The following screenshot shows the confirmation of
    success!![How to do it...](img/image_08_027.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now if you check your e-mail, you should have received a test e-mail from Zapier,
    which was used for testing the Zapier action. The contents of the e-mail are the
    way we wanted them to be. Pretty cool! So now when anyone signs up on Oliver's
    product website, the view will `POST` the signee's information as the payload
    to Zapier's Webhook (the target URL), and Zapier will automate the e-mail part.![How
    to do it...](img/image_08_028.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Zapier provides us with a feature to create custom Webhooks. It has integration
    with almost all the apps under the sun, such as Gmail, Trello, Slack, and so on.
    We just created a Webhook as a trigger and followed it up with an action from
    Gmail.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a user signs up (new user creation), the Django app will `POST` the
    user's data as the payload to the Zapier target URL, which we got when we created
    a trigger in Zapier.
  prefs: []
  type: TYPE_NORMAL
- en: Once Zapier receives the payload data to the target URL, it checks the action
    and finds that it has to send an e-mail to a Gmail account. Zapier is also intelligent
    enough to get the data from the payload and send the e-mail to the user's e-mail
    address; it also allows configuration of the e-mail's subject and body.
  prefs: []
  type: TYPE_NORMAL
- en: Fantastic! Oliver is happy! And what about step 2? Well, it's another Zapier
    trigger with either the Salesforce or Pipedrive CRM to create a lead record in
    the CRM. A walk in the park!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at automating user onboarding with a user signup
    event. We took an example of Zapier as it's the best possible way to automate
    apps. If we had not done this, we would have ended up understanding the APIs provided
    by all these apps and writing code for all of them ourselves, an activity which
    may not be the core of your product or service.
  prefs: []
  type: TYPE_NORMAL
- en: Well that's it, folks! Hope you enjoyed this piece of automation and I'm sure
    you will definitely implement this in your organization.
  prefs: []
  type: TYPE_NORMAL
