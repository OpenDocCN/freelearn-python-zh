- en: Chapter 7. Power of APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. API的力量
- en: This chapter takes you on a journey to the interesting world of APIs. APIs are
    a critical part of the business world today. Tasks like querying data, exchanging
    information across services amongst others rely on web APIs and Webhooks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带你进入有趣的API世界。API是当今商业世界的一个关键部分。查询数据、在服务之间交换信息等任务都依赖于Web API和Webhooks。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Designing your own REST APIs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计你自己的REST API
- en: Automating social media marketing with Twitter APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Twitter API自动化社交媒体营销
- en: An introduction to Webhooks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webhooks简介
- en: Implementing Webhooks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现Webhooks
- en: Automating lead management with Webhooks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Webhooks自动化潜在客户管理
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: APIs have become absolutely indispensable in the world driven by the Internet.
    Every web application that you must have interacted with uses an API on the backend
    to implement its core functionality--Amazon, Google, Twitter, you name it! What's
    more, you see all these applications thrive on APIs. Amazon uses it to drive its
    payment transactions and Google for showing you all the fancy maps. APIs are so
    essential to business that you hear the word API right from CEOs to managers,
    all the way to software developers. In general, using an API is a fundamental
    way of enabling different software to talk to each other. Operating system operations
    are also performed with APIs. They have been absolutely critical from the very
    beginning of computing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在由互联网驱动的世界中，API变得绝对不可或缺。你必须与之交互的每个网络应用程序都在其后端使用API来实现其核心功能——亚马逊、谷歌、推特，等等！更重要的是，你看到所有这些应用程序都是基于API繁荣起来的。亚马逊用它来驱动其支付交易，谷歌用它来显示所有这些花哨的地图。API对商业如此重要，以至于从CEO到经理，再到软件开发者，你都能听到API这个词。总的来说，使用API是使不同的软件相互通信的基本方式。操作系统操作也是通过API执行的。它们从一开始就是至关重要的。
- en: But what are APIs and how are they useful? How to develop APIs of our own? How
    do they find their way into business process automation? We'll find answers to
    all these questions in this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但API是什么？它们有什么用？我们如何开发自己的API？它们是如何进入业务流程自动化的？在本章中，我们将找到所有这些问题的答案。
- en: 'We start with a more familiar and older web term: web service. Web services
    are essentially the key points of integration between different applications hosted
    across platforms and built on different languages using independent systems. Web
    services communicate with each other via WWW and typically involve two parties:
    one that exposes a set of APIs, also known as the server, and another that calls
    or consumes the server APIs, also known as consumers or clients. Web services
    are independent of the client implementation and thus work well with browsers,
    mobile phones, or just any software that can make an API call.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个更熟悉且更古老的网络术语开始：网络服务。网络服务本质上是在不同平台和不同语言上使用独立系统托管的不同应用程序之间的集成关键点。网络服务通过WWW相互通信，通常涉及两方：一方暴露一组API，也称为服务器，另一方调用或消费服务器API，也称为消费者或客户端。网络服务独立于客户端实现，因此与浏览器、手机或任何可以发起API调用的软件都很好地协同工作。
- en: 'They use different protocols for communication, with different messaging and
    URI contracts. The most common implementations of web services are:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 它们使用不同的协议进行通信，有不同的消息和URI合约。最常见网络服务的实现包括：
- en: HTTP-based **REST** (**Representation State Transfer**) web service
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于HTTP的**REST**（**表示状态转移**）网络服务
- en: SOAP-based (**Simple Object Access Protocol**) web service
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于SOAP的（**简单对象访问协议**）网络服务
- en: XML **RPC** (**Remote Procedure Call**)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML **RPC**（**远程过程调用**）
- en: 'Messaging formats that have been commonly used for these services are:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务常用的消息格式包括：
- en: '**JSON** (**JavaScript Object Notation**)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON**（**JavaScript对象表示法**）'
- en: '**XML** (**eXtensible Markup Language**)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XML**（**可扩展标记语言**）'
- en: Web services are at the very core of web applications today and hence need to
    provide good performance; they need to be scalable and reliable.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的网络应用程序的核心是网络服务，因此需要提供良好的性能；它们需要可扩展和可靠。
- en: Right, so in this chapter, we'll cover HTTP-based REST APIs. You'll understand
    how to develop RESTful web services with Python in detail. You'll also learn how
    clients automate their business processes using RESTful web services.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对了，所以在本章中，我们将介绍基于HTTP的REST API。你将详细了解如何使用Python开发RESTful网络服务。你还将学习客户端如何使用RESTful网络服务自动化他们的业务流程。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that there are different terminologies available for referring to APIs,
    for example, the HTTP API, Web API, and so on. I suggest you read about them for
    better clarity. However, essentially, at their core APIs are integration points
    between two services in an application or between multiple servers/services across
    applications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at multiple Python modules, mentioned in the following
    list:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '`flask` ([http://flask.pocoo.org/](http://flask.pocoo.org/))'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`twython` ([https://twython.readthedocs.io/en/latest/](https://twython.readthedocs.io/en/latest/))'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytz` ([https://pypi.python.org/pypi/pytz](https://pypi.python.org/pypi/pytz))'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django` ([https://www.djangoproject.com/](https://www.djangoproject.com/))'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django-rest-hooks` ([https://github.com/zapier/django-rest-hooks](https://github.com/zapier/django-rest-hooks))'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing your own REST APIs
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Representational State Transfer** (**REST**) has gained lot of preference
    and popularity in the community and is virtually the default architectural style
    for designing and implementing RESTful web services.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that there are other possible implementations of web services for which
    you can follow the SOAP and XML-RPC way, these are not within the scope of this
    chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll learn how to implement a simple RESTful web service using
    the Python flask micro framework. We'll implement a user service for user management,
    which is an imperative aspect of any web application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The REST architecture is designed to fit with the HTTP protocol and has the
    notion of resources, that is, **Uniform Resource Identifiers** (**URIs**). Clients
    send requests to these URIs with different HTTP request methods and get back the
    state of the affected resources as a response.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: So what are we waiting for? Let's design and implement the user web service.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s begin by defining our model--**user**. Our user resource would be typically
    identified by these attributes:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`id`: A unique ID to identify the user'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username`: The name of the user used in the application'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`: The e-mail address of the user for e-mail notifications'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`: To check whether the user is active or verified'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Designing REST APIs involves identifying resources (URIs) and verbs (HTTP methods)
    that take action on the user model. We need to perform actions such as creating
    a new user, updating certain attributes of the user, getting a user or list of
    users, or if needed deleting a user. We also need to relate our actions to HTTP
    verbs and have to define CRUD operations for our service. **CRUD** means performing
    the **Create, Read, Update, and Delete** operations on a user model. The following
    table shows exactly what we need:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **URI** | **Method** | **Action** |'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `http://v1/users/` | `GET` | To get a list of available users |'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `http://v1/users/` | `POST` | To create a new user |'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `http://v1/users/1/` | `GET` | To get details of an existing user with ID
    equal to 1 |'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `http:///v1/users/1/` | `PUT`/`DELETE` | To update or remove the user with
    ID equal to 1 |'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `http:///v1/users/1/` | `PUT`/`DELETE` | 更新或删除ID等于1的用户 |'
- en: Now let's write the code to implement the RESTful user service. We start by
    creating a virtual environment. I hope we all know about `virtualenv`, but for
    beginners virtual environment is a tool that isolates Python modules. This helps
    in resolving issues related to permissions; it also helps to avoid polluting the
    global Python installation and to manage versions of the same module used across
    applications. If you don't have `virtualenv` on your system, you can install it
    using Python `pip` or download it from [https://pypi.python.org/pypi/virtualenv](https://pypi.python.org/pypi/virtualenv).
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们编写代码来实现RESTful用户服务。我们首先创建一个虚拟环境。我希望我们所有人都知道`virtualenv`，但对于初学者来说，虚拟环境是一个隔离Python模块的工具。这有助于解决与权限相关的问题；它还有助于避免污染全局Python安装，并管理跨应用使用的同一模块的版本。如果你系统上没有`virtualenv`，你可以使用Python的`pip`安装它，或者从[https://pypi.python.org/pypi/virtualenv](https://pypi.python.org/pypi/virtualenv)下载它。
- en: '[PRE0]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once we have `virtualenv` installed, we need to activate it using a simple
    command. As you can see in the second line in the following, the `virtualenv`
    user has been activated:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们安装了`virtualenv`，我们需要使用简单的命令来激活它。正如你在下面的第二行中看到的，`virtualenv`用户已经被激活：
- en: '[PRE1]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s go ahead and install `flask` in our virtual environment. We do this
    with the help of Python `pip` using the `pip install flask` command:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续在虚拟环境中安装`flask`。我们使用Python的`pip`通过`pip install flask`命令来完成此操作：
- en: '[PRE2]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you look at the installation logs, we seem to have installed `flask` along
    with the template engines `Jinja2` and `Werkzeug`, a WSGI utility that supports
    multiple operations, such as cookie handling, file uploads, and request/response
    objects.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你查看安装日志，我们会发现我们似乎已经安装了`flask`以及模板引擎`Jinja2`和`Werkzeug`，这是一个支持多种操作的WSGI实用工具，例如处理cookie、文件上传和请求/响应对象。
- en: 'Okay good! We have `flask` installed and the environment is nicely set up.
    Let''s write a minimalistic web application and name it `app.py`. The code for
    our web service looks like this:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的！我们已经安装了`flask`，环境也设置得很好。让我们编写一个简约的Web应用程序，命名为`app.py`。我们的Web服务代码如下：
- en: '[PRE3]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you run the app, you will see the Flask server running on port 5000:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你运行应用程序，你会看到Flask服务器正在5000端口上运行：
- en: '[PRE4]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you try to access the server on port 5000, you will see what we intended:![How
    to do it...](img/image_08_001.jpg)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你尝试访问5000端口的服务器，你会看到我们预期的效果：![如何操作...](img/image_08_001.jpg)
- en: 'Great! Now let''s improve on this to implement the user REST APIs. We first
    implement HTTP''s `GET` on the `/v1/users/` resource. In the following code, we
    implement a `flask` route with the `get_users()` API to return all the users in
    JSON format:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太好了！现在让我们改进这个来实现用户REST API。我们首先在`/v1/users/`资源上实现HTTP的`GET`。在以下代码中，我们实现了一个`flask`路由，名为`get_users()`
    API，以返回所有用户的JSON格式：
- en: '[PRE5]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we rerun the app (if you're using an editor such as PyCharm, it will itself
    reload the app for you every time you save your code), our `flask` route gets
    loaded; we can now make an HTTP `GET` request on the `/v1/users/` API. The output
    of the request will yield the response, as seen in the next screenshot. Hey, cool!
    We wrote our first resource for the RESTful user service.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们重新运行应用程序（如果你使用的是PyCharm等编辑器，每次你保存代码时，它都会自动重新加载应用程序），我们的`flask`路由就会被加载；我们现在可以在`/v1/users/`
    API上发出HTTP `GET`请求。请求的输出将产生响应，如下一张截图所示。嘿，太酷了！我们为RESTful用户服务编写了第一个资源。
- en: 'Notice the header section of the response:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意响应的头部部分：
- en: '`Content-Type` is application/JSON (we''ll talk about message formats later
    in the chapter)'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content-Type`是application/JSON（我们将在本章后面讨论消息格式）'
- en: Server is Werkzeug on which Flask is based
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器是基于Werkzeug的Flask
- en: Date refers to when the server responded to the request
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期指的是服务器响应请求的时间
- en: 'The response body has the following:'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应体包含以下内容：
- en: An output with the users key containing information for all the users
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含所有用户信息的`users`键输出
- en: Information about a user consists of desired attributes such as ID, username,
    e-mail, and account status
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于用户的信息包括所需的属性，如ID、用户名、电子邮件和账户状态
- en: The response format is JSON, as indicated in the headers
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 响应格式是JSON，如头部所示
- en: Note
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we use the RESTED plugin of Firefox to make these requests.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们使用Firefox的RESTED插件来发送这些请求。
- en: '![How to do it...](img/image_08_002.jpg)'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/image_08_002.jpg)'
- en: 'Nice! We have the first URI implemented as part of user service. Now let''s
    quickly go ahead and implement the next resource. Here, we need to get the user
    based on the ID. The following `flask` route will do the job for us:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太好了！我们已经将第一个 URI 作为用户服务的一部分实现了。现在让我们快速继续实现下一个资源。在这里，我们需要根据 ID 获取用户。以下 `flask`
    路由将为我们完成这项工作：
- en: '[PRE6]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we defined a `flask` route with the API `get_user(id)`,
    which takes the user ID as an argument. When we make an HTTP `GET` request on
    this URI, the `get_user()` API gets invoked; it internally looks up all the available
    users to locate the user with the desired ID. If the user is found, the user record
    is returned in JSON format; if not, the server sends an HTTP 404 response. Here's
    a screenshot illustrating this:![How to do it...](img/image_08_003.jpg)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了一个 `flask` 路由，其 API 为 `get_user(id)`，它接受用户 ID 作为参数。当我们对这个 URI 发起
    HTTP `GET` 请求时，`get_user()` API 被调用；它内部查找所有可用的用户以定位到具有所需 ID 的用户。如果找到用户，则将用户记录以
    JSON 格式返回；如果没有找到，服务器发送 HTTP 404 响应。以下是一个说明此过程的截图：![如何操作...](img/image_08_003.jpg)
- en: 'You want users to sign up on your web application, right? So let''s write a
    `flask` route that will help create a new user. The following code performs this
    operation:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您希望用户在您的网络应用程序上注册，对吧？所以让我们编写一个 `flask` 路由，它将帮助创建一个新的用户。以下代码执行此操作：
- en: '[PRE7]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now if you make an HTTP `POST` request on the `/v1/users/` resource and pass
    user information to the body, you''ll be able to create a new user. By default,
    the status of the user will be inactive (`''active'': False`); you can make it
    `''active'': False` when the user verifies her/his e-mail address:![How to do
    it...](img/B05370_08_56.jpg)'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在如果您在 `/v1/users/` 资源上发起一个 HTTP `POST` 请求并将用户信息传递到请求体中，您将能够创建一个新的用户。默认情况下，用户的状
    态将是未激活（`''active'': False`）；当用户验证她的/他的电子邮件地址时，您可以将其设置为 `''active'': False`：![如何操作...](img/B05370_08_56.jpg)'
- en: 'OK! Now let''s quickly look at the REST APIs that will edit the user details
    and delete the user if needed. The following flask route will edit the user details:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好吧！现在让我们快速看一下将编辑用户详情并在需要时删除用户的 REST API。以下 Flask 路由将编辑用户详情：
- en: '[PRE8]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now if we perform the HTTP `PUT` operation on the `/v1/users/:id/` resource
    with the changed data, we should be able to update the user information. In the
    following screenshot, the request body contains the new e-mail address that needs
    to be updated for user ID equal to `1`. When we make an HTTP `PUT` request, the
    information gets updated and we have the new e-mail address for the user:![How
    to do it...](img/B05370_08_78.jpg)
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在如果我们对 `/v1/users/:id/` 资源执行 HTTP `PUT` 操作并传递更改后的数据，我们应该能够更新用户信息。在以下截图中，请求体包含需要更新为用户
    ID 等于 `1` 的新电子邮件地址。当我们发起 HTTP `PUT` 请求时，信息得到更新，我们有了用户的新电子邮件地址：![如何操作...](img/B05370_08_78.jpg)
- en: The only operation pending now is to implement the `DELETE` operation. We can
    use this operation to delete a user. But you might ask, "Why would I delete the
    user?" So you can have your own implementation of `DELETE`; possibly, you can
    make the user inactive (by setting the `active` attribute to `False`). But for
    the sake of this discussion, let's delete the user for the heck of it.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在唯一待定的操作是实现 `DELETE` 操作。我们可以使用这个操作来删除一个用户。但您可能会问，“我为什么要删除用户？”所以您可以为 `DELETE`
    操作实现自己的实现；可能的话，您可以通过将 `active` 属性设置为 `False` 来使用户未激活。但为了这次讨论，让我们随意删除用户。
- en: 'The following code deletes the user based on the user ID:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码根据用户 ID 删除用户：
- en: '[PRE9]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `DELETE` operation typically returns the status code **204 NO CONTENT**,
    which is shown in the following screenshot:![How to do it...](img/image_08_008.jpg)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DELETE` 操作通常返回状态码 **204 NO CONTENT**，如下截图所示：![如何操作...](img/image_08_008.jpg)'
- en: Cool! So we have our RESTful user service completely implemented and up-and-running.
    Great!
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太棒了！所以我们已经完全实现了 RESTful 用户服务并使其运行。太好了！
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: REST is an architectural style of the WWW. It consists of a coordinated set
    of components where the focus is on component roles and interactions between data
    elements rather than the implementation. Its purpose is to make the Web more scalable,
    portable, and reliable, and improve performance.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: REST 是万维网的一种架构风格。它由一组协调的组件组成，其中重点在于组件角色和数据元素之间的交互，而不是实现。其目的是使网络更具可扩展性、可移植性和可靠性，并提高性能。
- en: 'The REST architecture works according to the following constraints:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: REST 架构根据以下约束工作：
- en: '**Client-server**: A **Uniform Resource Locator** (**URL**) separates the REST
    API from the client. Servers are not concerned about the user interface or the
    state; as a result, REST APIs are more scalable.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端-服务器**：**统一资源定位符**（**URL**）将REST API与客户端分开。服务器不关心用户界面或状态；因此，REST API更具可扩展性。'
- en: '**Stateless**: This means every request is independent and has no connection
    to the previous request or client. The client must contain all the necessary information
    to complete the request, and the session state remains with the client and hence
    is not stored on the server.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：这意味着每个请求都是独立的，并且与之前的请求或客户端没有关联。客户端必须包含完成请求所需的所有信息，会话状态保持在客户端，因此不会存储在服务器上。'
- en: '**Cacheable**: RESTful web service can cache or not cache responses. Services
    must let the clients know whether the response is cached. This helps improve the
    performance of the system as some requests may no longer be needed based on the
    cache expiry time.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可缓存**：RESTful网络服务可以缓存或不缓存响应。服务必须让客户端知道响应是否被缓存。这有助于提高系统的性能，因为某些请求可能不再需要，基于缓存过期时间。'
- en: '**Layered system**: A client may or may not directly interact with the server;
    they can always have intermediary servers such as caches or load balancers.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分层系统**：客户端可能直接与服务器交互，也可能不直接交互；它们始终可以拥有中介服务器，如缓存或负载均衡器。'
- en: '**Uniform resource**: Each REST resource should be independent; this allows
    you to have a separation of concerns, and it decouples the architecture.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一资源**：每个REST资源应该是独立的；这允许你有一个关注点的分离，并且解耦了架构。'
- en: '**Code on demand**: The server can provide code for clients to execute in their
    context. This is an optional requirement though.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按需代码**：服务器可以为客户端提供在其上下文中执行的代码。这是一个可选的要求。'
- en: The `GET` and `HEAD` methods are examples of safe methods as they don't change
    the state of the resource. The `PUT`/`DELETE` methods are idempotent. This means
    clients can make multiple similar calls to the resource and the resource will
    behave in the exact same way; of course, the response itself will have been changed
    as well.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`和`HEAD`方法是安全方法的例子，因为它们不会改变资源的状态。`PUT`/`DELETE`方法是幂等的。这意味着客户端可以对资源进行多次类似的调用，资源将以完全相同的方式表现；当然，响应本身也会发生变化。'
- en: Cool! So now we're in a position to create our own RESTful APIs. We can now
    host these on the Internet for our customers to use or implement functionalities
    in our web applications. Nice work!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们处于创建自己的RESTful API的位置。我们可以在互联网上托管这些API，供我们的客户使用，或在我们的网络应用程序中实现功能。做得好！
- en: There's more...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We looked at the fundamentals of the REST architecture and learned how to design
    a RESTful web service. We were helped by the Flask micro framework and learned
    how to write our own REST APIs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了REST架构的基础，并学习了如何设计RESTful网络服务。我们得到了Flask微框架的帮助，并学习了如何编写我们自己的REST API。
- en: In the next recipe, we'll see how the clients, due to their needs, consume REST
    APIs. We will also learn about using REST APIs to automate business processes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个菜谱中，我们将看到客户端如何根据其需求消费REST API。我们还将学习如何使用REST API来自动化业务流程。
- en: Automating social media marketing with Twitter APIs
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Twitter API自动化社交媒体营销
- en: Joy is a marketing manager of a world-known consumer brand. She handles the
    content marketing portfolio of the company and heavily relies on blogs and social
    media to showcase the company's product line and create a buzz in the market.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 乔伊是一家世界知名消费品牌的营销经理。她负责公司的内容营销组合，并严重依赖博客和社交媒体来展示公司的产品线并在市场上制造轰动。
- en: Without doubt, she has a few problems! Some of the products that she markets
    have been designed differently for different markets, so she has to work across
    time zones to make sure her content gets published at the right time. She also
    feels the need to repeat her posts just to make sure she reaches the majority
    of her customers; this would also help in improving brand recognition.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，她有几个问题！她所营销的一些产品针对不同的市场设计不同，因此她必须跨越时区工作，以确保她的内容在正确的时间发布。她还觉得有必要重复发布帖子，以确保她能够接触到大多数客户；这也有助于提高品牌知名度。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: If you carefully analyze her situation, Joy has two issues. One, she has to
    ensure her social media content is posted at the right time, based on her customer
    market. So if her product is being sold in Australia, she needs to make sure that
    her tweets are posted as per the Australian time when her customers are most likely
    to view them. Second, to get more traction for her product announcements, such
    as a weekend offer, she may want to repeat a few tweets at a later point in time.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细分析她的情况，Joy有两个问题。一是，她必须确保她的社交媒体内容在正确的时间发布，基于她的客户市场。所以如果她的产品在澳大利亚销售，她需要确保她的推文在澳大利亚时间发布，那时她的客户最有可能查看。二是，为了使她的产品公告（如周末优惠）获得更多关注，她可能希望在稍后的时间重复几条推文。
- en: 'OK! Now that we understand her problem, let''s try to devise a solution. Looks
    like we need to take care of the following points:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！现在我们了解了她的问题，让我们尝试制定一个解决方案。看起来我们需要注意以下要点：
- en: We should provide her with the capability of posting tweets in an automated
    fashion
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该提供她自动发布推文的 capability
- en: Her tweets should go at a desired time, even if Joy is asleep
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 她的推文应该在期望的时间发布，即使 Joy 睡着了
- en: We should also provide the capability of scheduling repeat tweets
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还应该提供安排重复推文的 capability
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'REST APIs to the rescue! Twitter has a fabulous set of REST APIs that can be
    used by the users for playing with Twitter data, user information, and of course
    posting tweets. You can also perform multiple operations such as uploading images,
    querying timelines, and sending direct messages. Wow! That''s cool! But lets not
    get distracted and instead move on to the problem at hand:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: REST APIs 来拯救！Twitter 提供了一套令人惊叹的 REST APIs，用户可以使用这些 API 来玩转 Twitter 数据、用户信息，当然还有发布推文。你还可以执行多个操作，如上传图片、查询时间线、发送私信。哇！太酷了！但让我们不要分心，而是继续解决手头的这个问题：
- en: 'First, let''s see how we can post tweets using Python even without logging
    in to Twitter. To post tweets, we will use a Python library called `twython`.
    So let''s install `twython` using our friend, the Python `pip`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们如何使用 Python 发布推文，即使不登录到 Twitter。要发布推文，我们将使用一个名为 `twython` 的 Python
    库。所以让我们使用我们的朋友 Python `pip` 安装 `twython`：
- en: '[PRE10]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: But before we can start playing with our Twitter account, we'd need to register
    an app with Twitter. This makes sure that Twitter is aware of our API calls and
    considers them legitimate. We can register an app by navigating to [https://apps.twitter.com/](https://apps.twitter.com/)
    and clicking on **Create New App**. You can fill in the details as shown in the
    following screenshot and create your app.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但在我们开始玩转我们的 Twitter 账户之前，我们需要在 Twitter 上注册一个应用程序。这确保了 Twitter 了解我们的 API 调用，并认为它们是合法的。我们可以通过导航到
    [https://apps.twitter.com/](https://apps.twitter.com/) 并点击 **Create New App**
    来注册一个应用程序。你可以填写以下截图所示的详细信息并创建你的应用程序。
- en: 'Please note a few things about the details you need to fill in:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意你需要填写的一些细节：
- en: The application name is unique across all the users on Twitter, so try to make
    it really unique to you, but at the same time keep it simple
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序名称在 Twitter 的所有用户中是唯一的，所以尽量让它对你来说非常独特，但同时也要保持简单
- en: Make a description that exactly defines your use case so you remember it later
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作一个精确定义你的 use case 的描述，这样你以后就能记住它
- en: Fill in your website name; keep it short
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填写你的网站名称；保持简短
- en: A callback URL is only needed if you want Twitter to send data to you about
    your authentication, which is not needed for this exercise
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当你想让 Twitter 发送有关你的 authentication 的数据给你时，才需要回调 URL，而这在这个练习中不是必需的
- en: '![How to do it...](img/image_08_009.jpg)'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/image_08_009.jpg)'
- en: You also need to get your App Key and App Secret, and for that you need OAuth
    Token and OAuth Token Secret. These are needed essentially to authenticate your
    API calls with Twitter, or else Twitter will reject your REST API calls as malicious.
    You will get these details by clicking on your newly created app and browsing
    to the **Keys and Access Tokens** tab at the top of your page. You can also navigate
    to `https://apps.twitter.com/app/<app_id>/keys/` to get these details:![How to
    do it...](img/image_08_010.jpg)
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要获取你的 App Key 和 App Secret，为此你需要 OAuth Token 和 OAuth Token Secret。这些基本上是用于验证你的
    API 调用与 Twitter，否则 Twitter 会拒绝你的 REST API 调用，认为它是恶意行为。你可以通过点击你新创建的应用程序并浏览到页面顶部的
    **Keys and Access Tokens** 选项卡来获取这些详细信息：![如何做...](img/image_08_010.jpg)
- en: 'OK! Let''s write some of the code and check whether we''re good to work with
    Twitter''s REST APIs. The following code makes a call to the Twitter timeline
    REST API and pulls the details of the topmost tweet on your timeline. Here we
    perform an HTTP `GET` operation on the [https://dev.twitter.com/rest/reference/get/statuses/home_timeline](https://dev.twitter.com/rest/reference/get/statuses/home_timeline)
    REST API:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的！让我们写一些代码，检查我们是否可以与Twitter的REST API一起工作。以下代码调用Twitter时间轴REST API，并获取您时间轴上最顶部推文的详细信息。在这里，我们对[https://dev.twitter.com/rest/reference/get/statuses/home_timeline](https://dev.twitter.com/rest/reference/get/statuses/home_timeline)
    REST API执行HTTP `GET`操作：
- en: '[PRE11]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面代码片段的输出如下：
- en: '![How to do it...](img/image_08_011.jpg)'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/image_08_011.jpg)'
- en: That's cool! We get all the essential details from the post on our timeline.
    Looks like we're all set then with respect to the Twitter App and Keys.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这很酷！我们从时间轴上的帖子中获取所有必要的信息。看起来在Twitter应用和密钥方面我们已经准备好了。
- en: 'Now let''s try to tweet with the status''s REST API by posting data to it.
    The REST API used here is [https://dev.twitter.com/rest/reference/post/statuses/update](https://dev.twitter.com/rest/reference/post/statuses/update).
    The following Python code will make a `POST` request on this REST resource and
    create a tweet on behalf of my account on Twitter:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试通过向它发送数据来使用状态REST API进行推文。这里使用的REST API是[https://dev.twitter.com/rest/reference/post/statuses/update](https://dev.twitter.com/rest/reference/post/statuses/update)。以下Python代码将对这个REST资源发起`POST`请求，并在我的推特账户上创建一条推文：
- en: '[PRE12]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After running the preceding code, I looked at Twitter, and voilà! I had a tweet
    under my name in an automated manner. Here''s a screenshot of the tweet:'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在运行前面的代码后，我查看了推特，哇！我的名字下自动出现了一条推文。以下是这条推文的截图：
- en: '![How to do it...](img/image_08_012.jpg)'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/image_08_012.jpg)'
- en: So we have solved the first problem for Joy. The tweet can be posted on her
    behalf even when she is unavailable or can't log in to the Internet, and this
    can be done using the preceding Python code snippet. But she can't schedule her
    tweet as per the Australian time zone yet. Hmm, let's look at resolving the scheduling
    problem now.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们已经为乔伊解决了第一个问题。即使她不在或无法登录互联网，也可以代表她发布推文。这可以通过前面的Python代码片段完成。但她还不能按照澳大利亚时区安排她的推文。嗯，让我们现在看看如何解决调度问题。
- en: 'Before we look at how to schedule tweets, we will install a module that will
    be very useful for the next recipe. We will install `pytz`. It helps us work with
    time zones and will be helpful in solving Joy''s problem:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们查看如何安排推文之前，我们将安装一个对下一个菜谱非常有用的模块。我们将安装`pytz`。它帮助我们处理时区，并将有助于解决乔伊的问题：
- en: '[PRE13]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To solve the scheduling problem, we need two things. First, we need a configuration
    that can be used to decide the content, time, and time zone of the tweet. Second,
    we need a runner program that will use this configuration to post a tweet on Twitter.
    Now let''s look at the following code, which does exactly what we need:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决调度问题，我们需要两样东西。首先，我们需要一个配置，可以用来决定推文的内容、时间和时区。其次，我们需要一个运行程序，将使用这个配置在推特上发布推文。现在让我们看看以下代码，它正好是我们需要的：
- en: '[PRE14]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of the preceding code is as follows. Here''s the first iteration:'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面代码的输出如下。这是第一次迭代：
- en: '![How to do it...](img/image_08_013.jpg)'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/image_08_013.jpg)'
- en: 'Here''s the second iteration:'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是第二次迭代：
- en: '![How to do it...](img/image_08_014.jpg)'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/image_08_014.jpg)'
- en: 'Here''s the actual tweet:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是实际的推文：
- en: '![How to do it...](img/image_08_015.jpg)'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/image_08_015.jpg)'
- en: Cool! So we have what Joy needs. An automated tweet with the right content at
    the right time for the right audiences across the globe. Woohoo!
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太酷了！所以我们有了乔伊需要的东西。一条自动推文，在正确的时间，向全球的正确受众推送正确的内容。哇哦！
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the preceding code snippets, we have two files. We have `tweet_config.py`,
    and it contains a configuration dictionary that is used to specify the content
    and schedule of the tweets. It also mentions the time zone in which the tweets
    need to be posted.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们有两个文件。我们有`tweet_config.py`，它包含一个配置字典，用于指定推文的内容和安排。它还提到了需要发布推文的时区。
- en: The second file `scheduled_tweets.py` is a runner program. It looks at the configuration
    every minute and checks whether there is any tweet scheduled for the given minute
    of the day.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个文件`scheduled_tweets.py`是一个运行程序。它每分钟检查一次配置，看看当天是否有安排的推文。
- en: When the runner program, `scheduled_tweets.py`, runs, it checks whether there
    are any messages scheduled. In iteration 1, the runner program doesn't find anything
    that it needs to work on; it just returns the current day and time of the time
    zone.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行程序`scheduled_tweets.py`运行时，它会检查是否有任何安排的消息。在迭代1中，运行程序没有找到需要处理的内容；它只是返回当前时区的日期和时间。
- en: In iteration 2, it does find that there is a tweet scheduled in the Australian
    time zone, Sydney to be precise, at 13:25 hours on August 27;^, since the time
    matched, it posted a tweet. Of course, the example taken here is a very crude
    one. We might want to schedule Cron jobs instead of an endless while loop. But
    hey, this was an example to bring home the point about automatically scheduled
    tweets.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代2中，它确实发现有一个在澳大利亚时区，即悉尼，8月27日13:25安排的推文；^，因为时间匹配，它发布了一条推文。当然，这里采用的例子非常简单。我们可能想要安排Cron作业而不是无休止的while循环。但是嘿，这是一个为了说明自动安排推文这一点的例子。
- en: In this section, we automated the marketing process for Joy. Now she can not
    only tweet when she is is asleep, but also schedule tweets for different time
    zones and with different content. Now that's the power of automation.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们自动化了Joy的营销过程。现在她不仅可以在睡觉时发推文，还可以为不同的时区和不同的内容安排推文。这就是自动化的力量。
- en: '"But hey, this is just one social media platform; what about Facebook?" you
    might ask. Yes, we have a trick up our sleeves. Twitter provides apps for connecting
    you to multiple services, including Facebook. So configure an app for your account
    so that every tweet that you post also gets posted on Facebook. This is how the
    configuration looks. It posts your original tweets and retweets them on your Facebook
    profile:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: “但是嘿，这只是一个社交媒体平台；那Facebook呢？”你可能想知道。是的，我们这里有一个小技巧。Twitter提供了连接你到多个服务的应用程序，包括Facebook。所以为你的账户配置一个应用程序，以便你发布的每条推文也会被发布在Facebook上。这是配置看起来像什么。它发布你的原始推文，并在你的Facebook个人资料上转发它们：
- en: '![How it works...](img/image_08_016.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/image_08_016.jpg)'
- en: 'Remember the first message that we posted about Python antigravity? Yes, it
    actually got posted on the Facebook wall as well. Look at the source next to the
    date and time of the tweet; yes it''s Twitter! Perhaps, Twitter uses Facebook
    APIs to automate this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们最初发布的关于Python反重力（antigravity）的消息吗？是的，它实际上也被发布在了Facebook墙上。看看推文日期和时间旁边的源代码；是的，那是Twitter！也许，Twitter使用Facebook
    API来自动化这个过程：
- en: '![How it works...](img/image_08_017.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/image_08_017.jpg)'
- en: An introduction to Webhooks
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Webhooks简介
- en: 'In the last section, we understood how to design and develop REST APIs and
    how to leverage REST APIs to our benefit by taking an example of Twitter/Facebook
    automation. Let''s look at another amazing piece: Webhooks. A Webhook is an HTTP
    callback--an HTTP `POST` request to a user-defined URL (implemented as an HTTP
    API) when a favorable event occurs. Webhooks are often referred to as reverse
    APIs and are used for real-time communication or integration across services.
    But before we go deeper, let''s understand a bit about polling.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解了如何设计和开发REST API，以及如何通过Twitter/Facebook自动化的例子来利用REST API为我们带来好处。让我们看看另一个令人惊叹的部分：Webhooks。Webhook是一种HTTP回调——当发生有利事件时，向用户定义的URL（实现为HTTP
    API）发送的HTTP `POST`请求。Webhooks通常被称为反向API，用于跨服务的实时通信或集成。但在我们深入之前，让我们了解一下轮询。
- en: You might have seen applications polling for long hours to check whether an
    event has occurred so that they can perform some follow-up action for the event.
    Take a real-world example. You go to a self-service restaurant and order your
    favorite pizza for lunch. The guy at the counter gives you an order number and
    tells you to watch the token machine for your order number so that you can collect
    your pizza. While everybody around is busy eating, you are hungry and tend to
    watch this token machine every 5 seconds hoping to see your order number flash
    on it. Now this is polling. You are polling the token machine. In the API world,
    the client would be polling the pizza place API to check the status of the order.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能见过应用程序长时间轮询以检查是否发生了某个事件，以便它们可以对该事件执行一些后续操作。以一个现实世界的例子来说明。你去了自助餐厅，为午餐点了一份你最喜欢的披萨。柜台上的那个人给你一个订单号，并告诉你去观察那个标记机，以便你可以领取你的披萨。当周围的人都忙着吃饭时，你饿了，每隔5秒钟就会看一次这个标记机，希望看到你的订单号在上面闪烁。现在这就是轮询。你正在轮询这个标记机。在API世界中，客户端会轮询披萨店的API来检查订单的状态。
- en: Wouldn't it be simple enough for the guy at the service counter to shout the
    order number when its ready? So after placing your order, you could get busy checking
    your official e-mails. When the service guy calls out your order number, you can
    collect your pizza from the delivery counter. This makes sure that your time is
    better utilized. Now this is a Webhook. When a favorable event occurs (your order
    is ready), you get a callback (the service guy shouts your order number) on your
    URL (in this case, your ears) that is literally listening and responding to callbacks.
    In the API world, you'd register your URL (the HTTP API) that gets called by the
    pizza place when your order is ready.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Webhooks can be used for three main purposes:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Receiving data in real time
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving data and pushing it on to another service
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving the data and then processing and returning it
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can think of many different ways of using Webhooks in the preceding three
    scenarios.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: If you think of polling and Webhooks, they both use APIs for integration needs.
    While polling is a client-driven integration technique, Webhooks are server-driven.
    Polling is very inefficient in the sense that the client keeps making server API
    calls to check the state of the resource (in our example, an order resource) with
    the help of a time stamp. Polling can happen every *x* minutes, *x* hours, or
    even *x* seconds to become more real time, but I think you get the inefficiencies
    associated with polling. On the other hand, Webhooks post data back to the callback
    URIs in the case of a favorable event. This is much more efficient than constant
    polling, but the flip side is you end up developing APIs on the client side, so
    your client tends to behave like a server itself.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Webhooks
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this knowledge, let's get started and implement Webhooks in this recipe.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use a famous Python web framework called **Django**.
    It allows you to use multiple plugins that get simply plugged in. Here, we will
    use the `django-rest-hooks` plugin developed by Zapier for implementing Webhooks.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s gets started and install the required packages. We install `Django==1.10`
    and `django-rest-hooks==1.3.1` using our favorite tool, Python `pip`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How to do it...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OK, let''s create a Django app. We do this with the following commands:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, let's configure Django to use the `rest_hooks` module in the app. We do
    this by adding `rest_hooks` to `bookstore/settings.py` under `INSTALLED_APPS`.
    We also add our app book to this list. Add an event, namely `user.signup`, to
    `settings.py` by using the constant `HOOK_EVENTS`. We haven't tied the event `user.signup`
    to any action here, so it's none. This is how `settings.py` should look like:![How
    to do it...](img/image_08_018.jpg)
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s register this event to a callback URL. But before we go there,
    navigate to the root of your project and run this command to initialize your Django
    models:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once the models are initialized, go to the database shell and run the following
    Python code snippets. They will create a user in the Django user table and register
    a Webhook for this user:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now add a file called `urls.py` to the Book app and add this code:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the following methods to `book/views.py` to create Django views:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Also, include these URLs in the project under `bookstore.urls.py` like this:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now run the Django server as follows:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'From your browser, go to `http://localhost:8000/event/` and look at your server
    logs. You will see that the registered Webhook got invoked, which means an HTTP
    `POST` request was sent to the target URL `http://localhost:8000/hook/` along
    with the payload, which contains all of the information we configured in the view.
    The server logs look like this:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Cool! Did you look at it? We invoked the /event URL, which in turn posted the
    required information to the target URL, which was registered for the event `user.signup`
    in our Webhook.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Similar to custom Webhooks, one could also develop RESTful Webhooks. RESTful
    Webhooks support subscription, notification, and publication actions through a
    RESTful interface. RESTful Webhooks must support four event types, namely `ACCESSED`,
    `CREATED`, `UPDATED`, and `DELETED`, which correspond to four HTTP verbs; notifications
    should be sent for the actions that get applied to the resource. For instance,
    when a resource gets created, an event gets generated; with this, the Webhook
    must be triggered and the target URL should be posted. In our example, we can
    define two more hook events, namely `book.added` and `book.deleted`, along with
    actions such as `book.Book.added` or `book.Book.deleted`. When we do a `book.save()`
    action on the model, the `book.added` event gets triggered, and if we have a hook
    defined for this event for the user, the HTTP `POST` request will be called on
    the target URL.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding code snippets, we first defined an event in the `settings.py`
    file. The event was named `user.signup`. Since it was a custom event, it had no
    action defined.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: We then created a new user `chetan` in the `auth_user` table using the default
    Django user model.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Later, we defined a Webhook for the the user `chetan`. This Webhook was configured
    for the event `user.signup`, and the target URL was set to `http://localhost:8000/hook/`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: We also defined two views in our Django app. The first view event was responsible
    for firing the Webhook for the corresponding user and event and for sending the
    payload information. The second view Webhook was defined for the target URL.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: We then ran the Django development server and navigated to `http://localhost:8000/event/`,
    which posted the payload information to the target URL, namely `http://localhost:8000/hook/`.
    The target URL received all of the payload data, such as the username, e-mail,
    and the time when the signup happened.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we looked at polling and Webhooks, which are other forms of
    integration on the Web that use APIs. We learned inefficiencies with polling and
    how Webhooks were much more useful. In the preceding recipe, we covered a custom
    event useful for user signup as I wanted it to explain the concept in a generic
    way. The coverage was brief, so I would like you to study more about RESTful Webhooks
    as they present a powerful use case for automation. With this understanding, let's
    see what problems Oliver has and how we can help him.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Automating lead management with Webhooks
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Oliver is Joy''s colleague and works in the marketing department. He is responsible
    for the user onboarding process. His primary responsibility includes:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Sending a welcome e-mail to users who sign up on your website
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a lead record for the new signee into the CRM
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Previously, it was easy for him to perform these two tasks manually since the
    signups on the site were minimal. But with the growing popularity of the website,
    he has begun to see an upsurge in the number of signups on a daily basis. Without
    doubt, he sees this as a highly time-consuming activity that can be easily automated.
    Can you help Oliver?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: If we carefully analyze the problem, Oliver's main issue is integration across
    services. The two services that he needs to integrate the signup are e-mail and
    CRM. He needs to track a signup event and take an action on this event. Webhooks
    are a perfect solution for this use case. Let's see how we can help Oliver automate
    his task.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the same Django project to solve this problem. We will also use
    an external service, Zapier, and see how it helps make things so much easier.
    Let''s get started:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Terminal, go to the Django project''s root directory and run the Python
    `manage.py` shell command to log in to the DB shell. Here, update our user `chetan`
    with the e-mail address. This can be achieved with the following set of commands:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now create an account with the Zapier app by navigating to [https://zapier.com/](https://zapier.com/).
    Once you have the account created, click on **MAKE A ZAP!** to reach **Choose
    App** and click on **Webhooks** under the **BUILT-IN APPS** section:![How to do
    it...](img/image_08_019.jpg)
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you select a Webhook, you will get a screen to create a **TRIGGER** and
    **ACTION** on the left-hand pane. On the right-hand side, select the **Catch Hook**
    option. Click on **Save + Continue**. Refer to the following screenshot:![How
    to do it...](img/image_08_020.jpg)
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will get the page to provide a JSON key that you want to select from
    the payload. This is an optional step and can be ignored. Click on **Continue**
    to reach the next step. Here, you'll get a custom Webhook URL. Copy this URL;
    it will act as a target URL.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now go back to your Django project and navigate to the DB shell. Create a new
    hook with the same event `user.signup` and target the URL that you received from
    Zapier in the earlier step. The commands will look as follows:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Run the Django development server with the `runserver` command of Python `manage.py`.
    Once the server is running, go to `http://localhost:8000/event/`; this will make
    a callback request to the target URL obtained from Zapier. You can verify this
    by going to Zapier again and looking at **Test this Step** on the left pane, under
    the **Catch Hook** section:![How to do it...](img/image_08_021.jpg)
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cool! We now have the trigger set up. Let's set up the action. For this, go
    to your left-hand pane and click on **Set up this step** under **ACTION**. Choose
    Gmail from the list of apps that will show up on the right-hand side of the screen:![How
    to do it...](img/image_08_022.jpg)
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you click on **Gmail**, you get the next option to select an action, such
    as **Create Draft** or **Send Email**. Click on **Send Email** and activate your
    e-mail account by allowing Zapier to access it. The following screenshots will
    show you how to perform these steps:![How to do it...](img/image_08_023.jpg)
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the next screenshot, we allow Zapier to access the Gmail app:'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_024.jpg)'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: OK! Now the only thing pending is to create the e-mail template. Our template
    contains the **To** e-mail address, subject, and body. Zapier gives you a nice
    option to configure your template. If you have already tested your trigger by
    posting data to the target URL, you will see a set of options on the extreme right
    of every field in the e-mail template. In the next two screenshots, I have **Data
    Email** in the **To** field, **Welcome Data Username!** in the **Subject** field,
    and **Your Signup made our day!** as the e-mail body.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following screenshot shows a dropdown of all the available options from
    the payload that the target URL received in the **Test this Step** section of
    the trigger. I have just shown the username. Look how the field name **To** of
    the template can chose **Data Username** from the payload:![How to do it...](img/image_08_025.jpg)
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The e-mail template with all the necessary fields configured can be seen in
    the following screenshot. We have configured the **To**, subject, and body parts
    of the e-mail in Zapier:'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_026.jpg)'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: That's it! Click on **Continue** at the bottom of this screen; Zapier will test
    your action and you're done. The following screenshot shows the confirmation of
    success!![How to do it...](img/image_08_027.jpg)
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now if you check your e-mail, you should have received a test e-mail from Zapier,
    which was used for testing the Zapier action. The contents of the e-mail are the
    way we wanted them to be. Pretty cool! So now when anyone signs up on Oliver's
    product website, the view will `POST` the signee's information as the payload
    to Zapier's Webhook (the target URL), and Zapier will automate the e-mail part.![How
    to do it...](img/image_08_028.jpg)
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Zapier provides us with a feature to create custom Webhooks. It has integration
    with almost all the apps under the sun, such as Gmail, Trello, Slack, and so on.
    We just created a Webhook as a trigger and followed it up with an action from
    Gmail.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a user signs up (new user creation), the Django app will `POST` the
    user's data as the payload to the Zapier target URL, which we got when we created
    a trigger in Zapier.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Once Zapier receives the payload data to the target URL, it checks the action
    and finds that it has to send an e-mail to a Gmail account. Zapier is also intelligent
    enough to get the data from the payload and send the e-mail to the user's e-mail
    address; it also allows configuration of the e-mail's subject and body.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Fantastic! Oliver is happy! And what about step 2? Well, it's another Zapier
    trigger with either the Salesforce or Pipedrive CRM to create a lead record in
    the CRM. A walk in the park!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at automating user onboarding with a user signup
    event. We took an example of Zapier as it's the best possible way to automate
    apps. If we had not done this, we would have ended up understanding the APIs provided
    by all these apps and writing code for all of them ourselves, an activity which
    may not be the core of your product or service.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Well that's it, folks! Hope you enjoyed this piece of automation and I'm sure
    you will definitely implement this in your organization.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
