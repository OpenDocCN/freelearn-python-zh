- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interactive Python Interpreters
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a working Python installation, we need to run some code. The
    most obvious way is to create a Python file and execute it. Often, it can be faster
    to interactively develop code from an interactive Python interpreter, however.
    While the standard Python interpreter is already quite powerful, many enhancements
    and alternatives are available.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The alternative interpreters/shells offer features such as:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Smart autocompletion
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntax highlighting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and loading sessions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic indenting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphing/charting output
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternative interpreters:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bpython`'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ptpython`'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ipython`'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jupyter`'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How to enhance interpreters
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python interpreter
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard Python interpreter is already fairly powerful, but more options
    are available through customization. First, let’s start with a `'Hello world!'`.
    Because the interpreter uses REPL, all output will be automatically printed and
    we can simply create a string.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes interactive interpreters are referred to as **REPL**. This stands
    for **Read-Eval-Print-Loop**. This effectively means that all of your statements
    will be executed and printed to your screen immediately.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to start the interpreter; after that, we can type our commands:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That was easy enough. And note that we didn’t have to use `print('Hello world!')`
    to show the output.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Many interpreters have only limited support for Windows. While they all work
    to some degree, your experience will be better with Linux or OS X systems. I recommend
    trying them from a (virtual) Linux/Unix machine at least once to experience the
    full range of features.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the interpreter
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As our first enhancement, we will add a few convenient shortcuts to the scope
    of the interpreter. Instead of having to type `import pprint; pprint.pprint(...)`
    to pretty-print our output, it would be useful to use `pp(...)` instead without
    having to run an `import` statement every time we start our interpreter. To do
    this, we will create a Python file that will be executed every time we run Python.
    On Linux and OS X systems, I would recommend ~`/.config/python/init.py`; on Windows,
    something like `C:\Users\rick\AppData\Local\Python\init.py` might be more suitable.
    Within this file, we can add regular Python code that will be executed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Python won’t find the file automatically; you need to tell Python where to
    look for the file by using the `PYTHONSTARTUP` environment variable. On Linux
    and OS X, you can change the `~/.zshrc`, `~/.bashrc` file, or whatever your shell
    has, and add:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This file is automatically executed every time you open a new shell session.
    So, once you open a new shell session, you are done.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: If you want to activate this for your current shell, you can also run the export
    line above in your current shell.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, you need to find the Advanced System Settings and change the environment
    variables on that screen.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can add these lines to the file to make pretty print (`pprint`/`pp`)
    and pretty format (`pformat`/`pf`) available by default:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When we run the Python interpreter, now we will have `pp` and `pf` available
    in our scope:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With a few of these minor changes, you can make your life a lot easier. You
    could modify your `sys.path` to include a directory with custom libraries, for
    example. And you can also change your prompt using the `sys.ps1` and `sys.ps2`
    variables. To illustrate, we’ll look at the interpreter before our changes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And now we will modify `sys.ps1` and `sys.ps2` and run the exact same code
    again:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The configuration above shows that you can easily change the interpreter to
    a slightly different output if you wish. For consistency purposes, however, it
    might be better to keep it the same.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Enabling and enhancing autocompletion
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most useful additions to the interpreter is the `rlcompleter` module.
    This module enables tab-activated autocompletion in your interpreter and is automatically
    activated if the `readline` module is available.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rlcompleter` module depends on the availability of the `readline` module,
    which is not bundled with Python on Windows systems. Luckily, an alternative can
    be installed easily:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It would be very useful to add some extra options to the autocompletion. First,
    look at the default output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, the tab completion for "`.`" works perfectly, but the tab completion
    for "`[`" does nothing. It would be useful to know the available items, so now
    we will work on adding that feature. It should be noted that this example uses
    a few techniques that are explained in later chapters, but that shouldn’t matter
    for now:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That was quite a bit of code, and if you look carefully, you’ll notice multiple
    potential bugs in this limited example. I’m just trying to show a working example
    here without introducing too much complexity, so several edge cases are not considered.
    To make the script work, we need to store it in the `PYTHONSTARTUP` file as we
    discussed earlier. You should see the result from `print()` after opening the
    interpreter so you can verify whether the script was loaded. With this addition,
    we can now complete dictionary keys as well:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Naturally, you could expand this to include colors, other completions, and many
    more useful features.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Since this completion calls `object.keys()`, there is a potential risk here.
    This code could be dangerous if, for some reason, the `object.keys()` method code
    is not safe to execute. Perhaps you are running on an external library, or your
    code has overridden the `keys()` method to execute a heavy database function.
    And if `object.keys()` is a generator that is exhausted after executing once,
    you won’t have any results when running your actual code afterward.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `eval()` function can be dangerous to execute on unknown code.
    In this case, `eval()` is only executing the line we typed ourselves, so that
    is less of an issue here.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Alternative interpreters
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have seen some of the features of the regular Python interpreter,
    let’s look at some enhanced alternatives. There are many options available, but
    we will limit ourselves to the most popular ones here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '`bpython`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ptpython`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ipython`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jupyter` (web-based `ipython`)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: bpython
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `bpython` interpreter is a `curses` interface for the Python interpreter
    that offers many useful features, while still being very similar to the regular
    Python interpreter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The `curses` library allows you to create a fully functioning **text-based user
    interface** (**TUI**). A TUI gives you full control over where you want to write
    to the screen. The regular Python interpreter is a **command-line interface**
    (**CLI**), which normally only allows you to append to the screen. With a TUI,
    you can write to any position on the screen, making its features somewhat comparable
    to a **graphical user interface** (**GUI**).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Some key features of `bpython`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: As-you-type autocompletion (as opposed to tab completion with `rlcompleter`)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In-line syntax highlighting while typing
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic function parameter documentation
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A undo/rewind feature that removes the last line
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy reloading of imported modules, so your external code changes can be tested
    without restarting the interpreter
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick changing of code in an external editor (convenient for multiline functions/code
    blocks)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to save the session to file/pastebin
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most of these features work fully automatically and transparently for you.
    Before we can start with `bpython`, we need to install it. A simple `pip install`
    should suffice:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To illustrate the automatically enabled features, here is the output of the
    code we used for the regular Python interpreter completion:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you ran this code on your own system, you would see highlighting as well
    as the intermediate states of autocompletion. I encourage you to give it a try;
    the preceding excerpt does not show enough.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Rewinding your session
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As for the more advanced features, let’s give those a try as well. First, let’s
    start with the rewind feature. While it appears to simply remove the last line,
    in the background it actually replays your entire history, except for the last
    line. This means that if your code is not safe to be run more than once, it can
    cause errors. The following code illustrates the usage and limitations of the
    rewind feature:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now if we press *Ctrl* + *R* to “rewind” the last line, we get the following
    output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the last line is gone now, but that’s not all; the output of
    the `fh.read()` line is now `xx` instead of `x,` which means that the line that
    writes `x` was executed twice. Additionally, the partial line will be executed
    as well, so when rewinding an indented block of code, you will see an error until
    you’ve executed valid code again.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Reloading modules
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often, when developing, I will write code in my regular editor and test the
    execution in the Python shell.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: When developing like this, a very useful feature of Python is the ability to
    reload imported modules using `importlib.reload()`. When you have multiple (nested)
    modules, this can get tedious fast, however. This is where the reload shortcut
    in `bpython` can help a lot. By using the *F6* button on your keyboard, `bpython`
    will not only run `importlib.reload()` on all modules in `sys.modules`, but it
    will also rerun the code in your session in a similar way to the rewind feature
    you saw earlier.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, we will start by creating a file named `bpython_reload.py`
    with the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This opens the `reload.txt` file for reading and writing in append mode. This
    means that `fh.write('x')` will append to the end of the file. The `fh.seek(0)`
    will jump to the beginning of the file (position 0) so that `print(fh.read())`
    can print the entire file content to the screen.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we open the `bpython` shell and import the module:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we press the *F6* button within that same shell, we will see that an extra
    character has been written and the code has been re-executed:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is an extremely useful feature with the same caveat as the rewind feature
    that not all code is safe to re-execute without side effects.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: ptpython
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ptpython` interpreter is younger (available since 2014) than `bpython`
    (available since 2009), so it might be slightly less mature and feature rich.
    It is, however, very actively developing and certainly worth mentioning. While
    there is (currently) no code reload feature similar to the one in `bpython`, there
    are several other useful features that `bpython` currently lacks:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Multiline code editing
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mouse support
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both Vi and Emacs key bindings
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntax checking while typing
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A history browser
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output highlighting
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These features are all ones you need to experience yourself, though; a book
    is not the right medium for a demonstration in this case. In any case, this interpreter
    is certainly worth looking at.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Installation can be done with a simple `pip install`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After installing, you can run it using the `ptpython` command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once the interpreter is running, you can configure `ptpython` using the built-in
    menu (press *F2*). In that menu, you can configure and enable/disable features
    such as completion for dictionaries, completion while typing, input validation,
    color depth, and highlighting colors.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: IPython and Jupyter
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The IPython interpreter is a completely different beast from the previously
    mentioned interpreters. In addition to being the interpreter with the most features,
    it is part of a whole ecosystem of packages that includes parallel computing,
    integrations with visual toolkits, interactive widgets, and a web-based interpreter
    (Jupyter).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Some key features of the IPython interpreter:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Easy object introspection
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output formatting (instead of `repr()`, IPython calls `pprint.pformat()`)
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command history can be accessed through variables and magic methods from both
    new and old sessions
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and loading sessions
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A whole range of magic commands and shortcuts
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to regular shell commands such as `cd` and `ls`
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensible tab completion, supporting not just Python methods and functions
    but filenames as well
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several of the other features of the IPython project are covered in the chapters
    about debugging, multiprocessing, scientific programming, and machine learning.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic installation of IPython can be done using a `pip install`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Installing through Anaconda is also a good option, though, especially if you
    are planning to use a lot of data science packages, which are often far easier
    to install and manage through `conda`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Basic interpreter usage
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The IPython interpreter can be used in a similar way to the other interpreters,
    but has somewhat different output from the other interpreters. Here’s an example
    covering some of the key features:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first line is a simple variable declaration; nothing special there. The
    second line shows the print output for the variable declared in the first line.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Now we declare a similar dictionary with more items in it. You can see that
    the output is now automatically formatted and split over multiple lines for readability
    if the line is too long for the screen. This effectively comes down to `print()`
    versus `pprint.pprint()`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'At `In [5]: _i1,` we see one of the useful internal variables, the input line.
    The `_i<N>` and `_ih[<N>]` variables give you the lines you wrote. Similarly,
    the last three entered lines are available through `_i`, `_ii`, and `_iii`, respectively.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: If the command generated output, it will be available through `_<N>`. And the
    last three output results are available through `_`, `__`, and `___`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call the external shell function `echo` by prefixing the line with
    `!` while passing along the Python variable `_i2`. When executing external shell
    functions, we can pass along Python variables by prefixing them with a `$`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading sessions
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ability to save and load a session so you can always come back to it is
    an incredibly useful feature. As is usually the case with IPython, there are several
    ways of achieving this goal. First of all, every session is already automatically
    saved for you, requiring no effort whatsoever. To load the previous session, you
    can run:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This command uses the same syntax as the `%history` command. Here is a quick
    overview of how the `%history` syntax works:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '`5`: Line 5'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-t 5`: Line 5 as pure Python (without IPython magic)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10-20`: Lines 10 to 20'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10/20`: Session 10, line 20'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~0/`: Current session'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~1/10-20`: Previous session lines 10 to 20'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~5/-~2`: Everything from 5 sessions ago to 2 sessions ago'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you know that a session will be an important one and you want to make sure
    it gets saved, use `%logstart`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As can be seen in the output, this feature is configurable. By default, it will
    write to (and rotate, if it exists) `ipython_log.py`. As soon as you run this
    command again, the previous logfile will be renamed to `ipython_log.001~` and
    so on for the older files.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，此功能是可配置的。默认情况下，它将写入（如果存在，则旋转）`ipython_log.py`。一旦再次运行此命令，之前的日志文件将被重命名为`ipython_log.001~`，依此类推，对于较旧的文件。
- en: 'Loading is done using the `%load` command and will immediately reactivate auto-logging
    since it’s replaying that line as well:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`%load`命令进行加载，并将立即重新激活自动记录，因为它也在回放该行：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Naturally, manually saving is also an option using `%save`. I would recommend
    adding the `-r` parameter so the session is saved as raw instead of a regular
    Python file. Let’s illustrate the difference:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，使用`%save`也可以手动保存。我建议添加`-r`参数，以便将会话以原始文件格式保存，而不是常规的Python文件。让我们来展示一下区别：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you don’t need to run the session from a regular Python interpreter, using
    the raw files is somewhat more legible.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要从常规Python解释器运行会话，使用原始文件会更容易阅读。
- en: Regular Python prompt/doctest mode
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常规Python提示符/doctest模式
- en: 'The default `ipython` prompt is very useful but it can feel a little verbose
    at times and you can’t easily copy the results to a file for doctests (we will
    cover more about doctests in *Chapter 10*, *Testing and Logging – Preparing for
    Bugs*). Because of that, it can be convenient to activate the `%doctest_mode`
    magic function so your prompt looks like the familiar Python interpreter:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`ipython`提示符非常有用，但有时可能会觉得有点冗长，而且你无法轻松地将结果复制到文件中进行doctests（我们将在*第10章*中详细介绍doctests，*测试和日志记录
    – 准备错误*）。正因为如此，激活`%doctest_mode`魔法函数可能很方便，这样你的提示符看起来就像熟悉的Python解释器：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, this also influences how the output is formatted, so it’s really
    similar to the regular Python shell. While magic functions can still be used,
    the output is nearly identical to the regular Python shell.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这也影响了输出的格式，所以它与常规的Python shell非常相似。虽然仍然可以使用魔法函数，但输出几乎与常规Python shell相同。
- en: Introspection and help
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反思与帮助
- en: One of the most useful shortcuts of IPython is `?`. That is the shortcut for
    accessing the IPython help, object help, and object introspection. If you’re looking
    for an up-to-date overview of the IPython interpreter features, start by typing
    ? and start reading. If you’re planning to use IPython, I definitely recommend
    doing so.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: IPython最有用的快捷键之一是`?`。这是访问IPython帮助、对象帮助和对象反思的快捷键。如果你正在寻找IPython解释器功能的最新概述，请先输入`?`并开始阅读。如果你打算使用IPython，我强烈推荐这样做。
- en: The `?` and `??` can be used both as a suffix and as a prefix. So, both `?history`
    and `history?` will return in the documentation for the `%history` command.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`?`和`??`既可以作为后缀也可以作为前缀使用。因此，`?history`和`history?`都会在`%history`命令的文档中返回。'
- en: 'Because the `?` shortcut shows the documentation, it is useful for both regular
    Python objects and the magic functions in IPython. The magic functions are really
    not that magic; besides having a name that’s prefixed with a `%`, they are just
    regular Python functions. In addition to `?`, there is also `??,` which attempts
    to show the source of the object:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`?`快捷键显示了文档，所以它对常规Python对象和IPython中的魔法函数都很有用。魔法函数实际上并不那么神奇；除了以`%`为前缀的名称外，它们只是常规的Python函数。除了`?`之外，还有`??,`，它试图显示对象的源代码：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Autocompletion
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动补全
- en: Autocompletion is where `ipython` really gets interesting. In addition to the
    regular code completion, `ipython` will complete filenames and LaTeX/Unicode for
    special characters as well.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 自动补全是`ipython`真正有趣的地方。除了常规的代码补全外，`ipython`还会补全文件名以及用于特殊字符的LaTeX/Unicode。
- en: 'The really useful part starts when creating your own objects, though. While
    regular automatic autocompletion will work without a hitch, you can customize
    the autocompletion to only return specific items, or do dynamic lookups from a
    database if needed. Usage is certainly easy enough:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 真正有用的部分开始于创建你自己的对象时。虽然常规的自动补全可以无缝工作，但你还可以自定义补全，使其只返回特定项，或者如果需要，从数据库中进行动态查找。使用起来当然足够简单：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now for the LaTeX/Unicode character completion. While this might not be something
    you need to use that often, I find it really useful in the cases that you do need
    it:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是LaTeX/Unicode字符补全的时候了。虽然这可能不是你经常需要使用的东西，但我发现当你需要它时，它非常有用：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Jupyter
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jupyter
- en: The Jupyter project offers an amazing web-based interpreter (Jupyter Notebook)
    that makes Python much more accessible for people who need to write some scripts
    but aren’t programmers by trade. It allows a seamless mix of Python code, LaTeX,
    and other markup.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The web-based interpreter isn’t the only or even most important feature of the
    Jupyter project, though. The biggest advantage of the Jupyter project is that
    it allows you to connect to remote systems (called “kernels”) from your local
    machine.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Originally, the project was part of the IPython project when `ipython` was still
    a large monolithic application that contained all components internally. Since
    then, the IPython project has been split into multiple IPython projects and several
    projects under the Jupyter name. Internally, they are still using much of the
    same code base and Jupyter heavily depends on IPython.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we continue, we should look at the current structure of the Jupyter
    and IPython projects and describe the most important projects:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '`jupyter`: The metapackage that contains all the Jupyter projects.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notebook`: The web-based interpreter, which is part of the Jupyter project.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lab`: The next-generation web-based interpreter offering multiple notebooks
    side by side and even supporting code embedded in other languages such as Markdown,
    R, and LaTeX.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ipython`: The Python terminal interface with the magic functions.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jupyter_console`: The Jupyter version of `ipython`.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ipywidgets`: Interactive widgets that can be used as user input in `notebook`.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ipyparallel`: The library for easy parallel execution of Python code across
    multiple servers. There will be more about this in *Chapter 14*, *Multiprocessing
    - When a Single CPU Core Is Not Enough*.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`traitlets`: The config system used by IPython and Jupyter, which allows you
    to create configurable objects with validation. There will be more about this
    in *Chapter 8*, *Metaclasses - Making Classes (Not Instances) Smarter*.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 2.1* shows the complexity and the size of the Jupyter and IPython projects
    and how they work together:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![Architecture diagram of project relationships](img/B15882_02_01.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Jupyter and IPython project structure'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: From this overview, you might wonder why both `ipython` and `jupyter console`
    exist. The difference is that `ipython` runs completely locally in a single process,
    and `jupyter console` runs everything on a remote kernel. When running locally,
    this means that Jupyter will automatically start a background processing kernel
    that any Jupyter application can connect to.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The Jupyter project could easily fill several books by itself so we will cover
    only the most common features in this chapter. Additionally, *Chapter 14* covers
    the multiprocessing aspect in more detail. And *Chapter 15*, *Scientific Python
    and Plotting*, depends on Jupyter Notebook as well.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Installing Jupyter
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let’s start with the installation. The installation is easy enough with
    a simple `pip install` or `conda install`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, all that’s left is to start it. Once you run the following command, your
    web browser should automatically open:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Docker images are available as well if, for some reason, the installation gives
    you trouble or if you want an easy installation for a lot of dependency-heavy
    packages. For the data science chapter later in the book, the `jupyter/tensorflow-notebook`
    Docker image is used:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will run the Docker image and forward port `8888` to the running `jupyter
    lab` so you can access it. Note that because of the default security, you will
    need to open `jupyter lab` through the links provided in the console, which contains
    the randomly generated security token. It should look something like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once you have it up and running, you should see something like this in your
    browser:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_02_02.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Jupyter dashboard'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can create a new notebook:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_02_03.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: A new file in Jupyter'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'And start typing with tab completion and all the features that are similar
    to `ipython`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_02_04.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Jupyter tab completion'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Within a notebook, you can have multiple cells. Each cell can have multiple
    lines of code and behave similarly to the IPython interpreter with one key difference:
    *only the last line* decides what is returned as the output, instead of each line
    being printed separately. But that doesn’t prevent you from using `print()` functions.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_02_05.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Jupyter output'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Each of these cells can be (re-)executed separately if needed, or all at once,
    to make sure the notebook still functions properly. In addition to code cells,
    Jupyter also supports several types of markup languages, such as Markdown, to
    add nicely formatted documentation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'And because it’s a web-based format, you can attach all sorts of objects, such
    as videos, audio files, PDF files, images, and renders. LaTeX formulas, for example,
    are mostly impossible to render in a normal interpreter, but with Jupyter, rendering
    a LaTeX formula is easily possible:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_02_06.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: A LaTeX formula in Jupyter'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we have interactive widgets, which are one of the best features of
    using notebooks over a regular shell session:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_02_07.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Jupyter widgets'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: By moving the slider, the function will be called again and the result will
    be immediately updated. This is extremely useful when debugging functions. In
    the chapter about user interfaces, you will learn how to create our own.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: IPython summary
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The entire list of features in the IPython and Jupyter projects could easily
    fill several books by itself, so we have only glossed over a very small portion
    of what the interpreter supports.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Later chapters will cover some other parts of the project, but the IPython documentation
    is your friend. The documentation is really detailed and largely up to date.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'An overview of some of the shortcuts/magic functions that you’ll want to look
    at follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '`%quickref`: A quick reference for most of the interpreter features and a list
    of the magic functions.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%cd`: Change the current working directory for your `ipython` session.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%paste`: Paste a pre-formatted code block from the clipboard so your indentation
    is pasted correctly and not mutilated/clobbered due to auto-indentation.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%edit`: Open an external editor for easy editing of code blocks. This is very
    useful when quickly testing multiline code blocks. The `%edit -p` command, for
    example, will re-edit the previous (`-p`) code block.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%timeit`: A shortcut to quickly benchmark a line of Python code using the
    `timeit` module.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`?`: Look at the documentation for any object.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`??`: Look at the source for any Python object. Native methods such as `sum()`
    are compiled C code, so the source can’t be fetched easily.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `rlcompleter` enhancement we created currently only handles dictionaries.
    Try and extend the code so it supports lists, strings, and tuples as well.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add colors to the completer (hint: use `colorama` for the coloring).'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of manually completing using our own object introspection, try and use
    the `jedi` library for autocompletion, which does static code analysis.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Static code analysis inspects code without executing it. This means it’s entirely
    safe to run, even on foreign code, as opposed to the autocompletion we wrote earlier,
    which runs the code in `object.keys()`.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Try to create a `Hello <ipywidget>` so the name of the person can be edited
    through a notebook without code changes.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try and create a script that will look for a given pattern through all of your
    previous `ipython` sessions.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Example answers for these exercises can be found on GitHub: [https://github.com/mastering-python/exercises](Chapter_2.xhtml).
    You are encouraged to submit your own solutions and learn about alternative solutions
    from others.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has shown you several of the available Python interpreters and
    some of the pros and cons. Additionally, you have had a small glimpse of what
    IPython and Jupyter can offer us. *Chapter 15*, *Scientific Python and Plotting*,
    almost exclusively uses Jupyter Notebooks and demonstrates a few more powerful
    features, such as plotting integration.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: For most generic Python programmers, I would suggest using either `bpython`
    or `ptpython`, since they are really fast and lightweight interpreters to (re-)start
    that still offer a lot of useful features.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: If your focus is more on scientific programming and/or handling large datasets
    in your shell, then IPython or JupyterLab are probably more useful. These are
    far more powerful tools, but they come at the cost of having slightly higher start
    up times and system requirements. I personally use both depending on the use case.
    When testing a few simple lines of Python and/or verifying the behavior of a small
    code block, I mostly use `bpython`/`ptpython`. When working with larger blocks
    of code and/or data, I tend to use IPython (or `ptipython`) or even JupyterLab.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter covers the Python style guide, which rules are important, and
    why they matter. Readability is one of the most important aspects of the Python
    philosophy, and you will learn methods and styles for writing cleaner and more
    readable Python code. In short, you will learn what Pythonic code is and how to
    write it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code156081100001293319171.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
