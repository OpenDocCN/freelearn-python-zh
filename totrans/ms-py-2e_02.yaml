- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Interactive Python Interpreters
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式Python解释器
- en: Now that we have a working Python installation, we need to run some code. The
    most obvious way is to create a Python file and execute it. Often, it can be faster
    to interactively develop code from an interactive Python interpreter, however.
    While the standard Python interpreter is already quite powerful, many enhancements
    and alternatives are available.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了一个有效的Python，我们需要运行一些代码。最明显的方法是创建一个Python文件并执行它。然而，从交互式Python解释器中交互式地开发代码通常更快。虽然标准Python解释器已经很强大，但还有许多增强和替代方案可用。
- en: 'The alternative interpreters/shells offer features such as:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 替代解释器/外壳提供如下功能：
- en: Smart autocompletion
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能自动完成
- en: Syntax highlighting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法高亮
- en: Saving and loading sessions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和加载会话
- en: Automatic indenting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动缩进
- en: Graphing/charting output
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形/图表输出
- en: 'In this chapter, you will learn about:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解：
- en: 'Alternative interpreters:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替代解释器：
- en: '`bpython`'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bpython`'
- en: '`ptpython`'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ptpython`'
- en: '`ipython`'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ipython`'
- en: '`jupyter`'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jupyter`'
- en: How to enhance interpreters
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何增强解释器
- en: The Python interpreter
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python解释器
- en: The standard Python interpreter is already fairly powerful, but more options
    are available through customization. First, let’s start with a `'Hello world!'`.
    Because the interpreter uses REPL, all output will be automatically printed and
    we can simply create a string.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 标准Python解释器已经很强大，但通过自定义还有更多选项可用。首先，让我们从`'Hello world!'`开始。因为解释器使用REPL，所有输出都将自动打印，我们只需创建一个字符串即可。
- en: Sometimes interactive interpreters are referred to as **REPL**. This stands
    for **Read-Eval-Print-Loop**. This effectively means that all of your statements
    will be executed and printed to your screen immediately.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有时交互式解释器被称为**REPL**。这代表**读取-评估-打印-循环**。这实际上意味着您的所有语句都将立即执行并打印到您的屏幕上。
- en: 'First, we need to start the interpreter; after that, we can type our commands:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要启动解释器；然后，我们可以输入我们的命令：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That was easy enough. And note that we didn’t have to use `print('Hello world!')`
    to show the output.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。并且请注意，我们不必使用`print('Hello world!')`来显示输出。
- en: Many interpreters have only limited support for Windows. While they all work
    to some degree, your experience will be better with Linux or OS X systems. I recommend
    trying them from a (virtual) Linux/Unix machine at least once to experience the
    full range of features.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 许多解释器对Windows的支持仅限于有限。虽然它们在某种程度上都能工作，但使用Linux或OS X系统您的体验会更好。我建议至少尝试一次从（虚拟）Linux/Unix机器上使用它们，以体验其全部功能。
- en: Modifying the interpreter
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改解释器
- en: As our first enhancement, we will add a few convenient shortcuts to the scope
    of the interpreter. Instead of having to type `import pprint; pprint.pprint(...)`
    to pretty-print our output, it would be useful to use `pp(...)` instead without
    having to run an `import` statement every time we start our interpreter. To do
    this, we will create a Python file that will be executed every time we run Python.
    On Linux and OS X systems, I would recommend ~`/.config/python/init.py`; on Windows,
    something like `C:\Users\rick\AppData\Local\Python\init.py` might be more suitable.
    Within this file, we can add regular Python code that will be executed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们的第一个增强功能，我们将向解释器的范围内添加一些方便的快捷键。我们不必每次启动解释器时都输入`import pprint; pprint.pprint(...)`来美化输出，使用`pp(...)`而不必每次都运行一个`import`语句会更有用。为此，我们将创建一个Python文件，每次我们运行Python时都会执行它。在Linux和OS
    X系统上，我建议使用~`/.config/python/init.py`；在Windows上，可能像`C:\Users\rick\AppData\Local\Python\init.py`这样的路径更合适。在这个文件中，我们可以添加将被执行的常规Python代码。
- en: 'Python won’t find the file automatically; you need to tell Python where to
    look for the file by using the `PYTHONSTARTUP` environment variable. On Linux
    and OS X, you can change the `~/.zshrc`, `~/.bashrc` file, or whatever your shell
    has, and add:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Python不会自动找到该文件；您需要通过使用`PYTHONSTARTUP`环境变量来告诉Python在哪里查找该文件。在Linux和OS X上，您可以更改`~/.zshrc`、`~/.bashrc`文件或您的shell拥有的任何文件，并添加：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This file is automatically executed every time you open a new shell session.
    So, once you open a new shell session, you are done.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件每次您打开一个新的shell会话时都会自动执行。所以，一旦您打开一个新的shell会话，您就完成了。
- en: If you want to activate this for your current shell, you can also run the export
    line above in your current shell.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想激活当前shell的此功能，您也可以在当前shell中运行上面的export行。
- en: On Windows, you need to find the Advanced System Settings and change the environment
    variables on that screen.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，您需要在高级系统设置中找到并更改该屏幕上的环境变量。
- en: 'Now we can add these lines to the file to make pretty print (`pprint`/`pp`)
    and pretty format (`pformat`/`pf`) available by default:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将这些行添加到文件中，以便默认启用并增强自动补全（`pprint`/`pp`）和美观格式化（`pformat`/`pf`）：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When we run the Python interpreter, now we will have `pp` and `pf` available
    in our scope:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行Python解释器时，现在我们将在我们的作用域中拥有`pp`和`pf`：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With a few of these minor changes, you can make your life a lot easier. You
    could modify your `sys.path` to include a directory with custom libraries, for
    example. And you can also change your prompt using the `sys.ps1` and `sys.ps2`
    variables. To illustrate, we’ll look at the interpreter before our changes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些小的改动，你可以使你的生活变得更加轻松。例如，你可以修改你的`sys.path`以包括一个包含自定义库的目录。你也可以使用`sys.ps1`和`sys.ps2`变量来更改你的提示符。为了说明，我们将查看更改之前的解释器：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And now we will modify `sys.ps1` and `sys.ps2` and run the exact same code
    again:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将修改`sys.ps1`和`sys.ps2`，并再次运行相同的代码：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The configuration above shows that you can easily change the interpreter to
    a slightly different output if you wish. For consistency purposes, however, it
    might be better to keep it the same.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置表明，如果你愿意，你可以轻松地将解释器更改为略有不同的输出。然而，出于一致性的目的，可能最好保持它不变。
- en: Enabling and enhancing autocompletion
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用并增强自动补全
- en: One of the most useful additions to the interpreter is the `rlcompleter` module.
    This module enables tab-activated autocompletion in your interpreter and is automatically
    activated if the `readline` module is available.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器中最有用的添加之一是`rlcompleter`模块。此模块使你的解释器中启用Tab激活的自动补全，如果`readline`模块可用，则自动激活。
- en: 'The `rlcompleter` module depends on the availability of the `readline` module,
    which is not bundled with Python on Windows systems. Luckily, an alternative can
    be installed easily:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`rlcompleter`模块依赖于`readline`模块的可用性，该模块不是Windows系统上Python的捆绑模块。幸运的是，可以轻松安装一个替代品：'
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It would be very useful to add some extra options to the autocompletion. First,
    look at the default output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为自动补全添加一些额外选项将非常有用。首先，看看默认输出：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, the tab completion for "`.`" works perfectly, but the tab completion
    for "`[`" does nothing. It would be useful to know the available items, so now
    we will work on adding that feature. It should be noted that this example uses
    a few techniques that are explained in later chapters, but that shouldn’t matter
    for now:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，"`.`"的Tab补全工作得很好，但"`[`"的Tab补全没有任何作用。了解可用项将很有用，所以现在我们将努力添加这个功能。需要注意的是，这个例子使用了一些在后面的章节中解释的技术，但这对现在来说并不重要：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That was quite a bit of code, and if you look carefully, you’ll notice multiple
    potential bugs in this limited example. I’m just trying to show a working example
    here without introducing too much complexity, so several edge cases are not considered.
    To make the script work, we need to store it in the `PYTHONSTARTUP` file as we
    discussed earlier. You should see the result from `print()` after opening the
    interpreter so you can verify whether the script was loaded. With this addition,
    we can now complete dictionary keys as well:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当多，如果你仔细看，你会在这个有限的例子中注意到多个潜在的bug。我只是试图在这里展示一个工作示例，而不引入太多的复杂性，所以没有考虑几个边缘情况。为了使脚本工作，我们需要像之前讨论的那样将其存储在`PYTHONSTARTUP`文件中。打开解释器后，你应该看到`print()`的结果，这样你可以验证脚本是否已加载。有了这个添加，我们现在可以完成字典键：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Naturally, you could expand this to include colors, other completions, and many
    more useful features.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，你可以扩展它以包括颜色、其他补全和许多其他有用的功能。
- en: Since this completion calls `object.keys()`, there is a potential risk here.
    This code could be dangerous if, for some reason, the `object.keys()` method code
    is not safe to execute. Perhaps you are running on an external library, or your
    code has overridden the `keys()` method to execute a heavy database function.
    And if `object.keys()` is a generator that is exhausted after executing once,
    you won’t have any results when running your actual code afterward.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个补全调用`object.keys()`，这里存在潜在的风险。如果出于某种原因，`object.keys()`方法代码不安全执行，这段代码可能会很危险。也许你正在运行外部库，或者你的代码已覆盖`keys()`方法以执行一个重量级数据库函数。如果`object.keys()`是一个在执行一次后耗尽的生成器，那么在运行实际代码后你将没有任何结果。
- en: Additionally, the `eval()` function can be dangerous to execute on unknown code.
    In this case, `eval()` is only executing the line we typed ourselves, so that
    is less of an issue here.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`eval()`函数在执行未知代码时可能很危险。在这种情况下，`eval()`只执行我们自己输入的行，所以这里的问题不大。
- en: Alternative interpreters
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替代解释器
- en: 'Now that you have seen some of the features of the regular Python interpreter,
    let’s look at some enhanced alternatives. There are many options available, but
    we will limit ourselves to the most popular ones here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了常规 Python 解释器的一些功能，让我们来看看一些增强的替代方案。有许多选项可用，但我们将限制在这里介绍最流行的几个：
- en: '`bpython`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bpython`'
- en: '`ptpython`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ptpython`'
- en: '`ipython`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ipython`'
- en: '`jupyter` (web-based `ipython`)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jupyter`（基于网页的 `ipython`）'
- en: Let’s get started.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: bpython
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: bpython
- en: The `bpython` interpreter is a `curses` interface for the Python interpreter
    that offers many useful features, while still being very similar to the regular
    Python interpreter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`bpython` 解释器是 Python 解释器的 `curses` 接口，提供了许多有用的功能，同时仍然非常类似于常规的 Python 解释器。'
- en: The `curses` library allows you to create a fully functioning **text-based user
    interface** (**TUI**). A TUI gives you full control over where you want to write
    to the screen. The regular Python interpreter is a **command-line interface**
    (**CLI**), which normally only allows you to append to the screen. With a TUI,
    you can write to any position on the screen, making its features somewhat comparable
    to a **graphical user interface** (**GUI**).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`curses` 库允许你创建一个完全功能的**基于文本的用户界面**（**TUI**）。TUI 可以让你完全控制你想要写入屏幕的位置。常规的 Python
    解释器是一个**命令行界面**（**CLI**），通常只允许你向屏幕追加内容。使用 TUI，你可以将内容写入屏幕上的任何位置，使其功能与**图形用户界面**（**GUI**）有某种程度的相似性。'
- en: 'Some key features of `bpython`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`bpython` 的一些关键特性：'
- en: As-you-type autocompletion (as opposed to tab completion with `rlcompleter`)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入时自动补全（与 `rlcompleter` 的制表符补全相反）
- en: In-line syntax highlighting while typing
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入时内联语法高亮
- en: Automatic function parameter documentation
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动函数参数文档
- en: A undo/rewind feature that removes the last line
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以撤销/倒退的功能，用于删除最后一行
- en: Easy reloading of imported modules, so your external code changes can be tested
    without restarting the interpreter
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易重新加载导入的模块，这样你就可以在不重新启动解释器的情况下测试外部代码的变化
- en: Quick changing of code in an external editor (convenient for multiline functions/code
    blocks)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在外部编辑器中快速更改代码（对于多行函数/代码块来说很方便）
- en: The ability to save the session to file/pastebin
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够将会话保存到文件/粘贴板
- en: 'Most of these features work fully automatically and transparently for you.
    Before we can start with `bpython`, we need to install it. A simple `pip install`
    should suffice:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些功能都会为你完全自动且透明地工作。在我们开始使用 `bpython` 之前，我们需要安装它。一个简单的 `pip install` 就足够了：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To illustrate the automatically enabled features, here is the output of the
    code we used for the regular Python interpreter completion:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明自动启用的功能，以下是用于常规 Python 解释器补全的代码输出：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you ran this code on your own system, you would see highlighting as well
    as the intermediate states of autocompletion. I encourage you to give it a try;
    the preceding excerpt does not show enough.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在自己的系统上运行此代码，你也会看到高亮显示以及自动补全的中间状态。我鼓励你试一试；前面的摘录不足以展示。
- en: Rewinding your session
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 撤销你的会话
- en: 'As for the more advanced features, let’s give those a try as well. First, let’s
    start with the rewind feature. While it appears to simply remove the last line,
    in the background it actually replays your entire history, except for the last
    line. This means that if your code is not safe to be run more than once, it can
    cause errors. The following code illustrates the usage and limitations of the
    rewind feature:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高级的功能，让我们也尝试一下。首先，让我们从倒退功能开始。虽然它看起来只是简单地删除最后一行，但在后台，它实际上会重新播放你的整个历史记录，除了最后一行。这意味着如果你的代码不安全多次运行，可能会引起错误。以下代码说明了倒退功能的用法和限制：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now if we press *Ctrl* + *R* to “rewind” the last line, we get the following
    output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们按下 *Ctrl* + *R* 来“倒退”最后一行，我们会得到以下输出：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the last line is gone now, but that’s not all; the output of
    the `fh.read()` line is now `xx` instead of `x,` which means that the line that
    writes `x` was executed twice. Additionally, the partial line will be executed
    as well, so when rewinding an indented block of code, you will see an error until
    you’ve executed valid code again.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，最后一行现在消失了，但这还不是全部；`fh.read()` 行的输出现在是 `xx` 而不是 `x,`，这意味着写入 `x` 的行被执行了两次。此外，部分行也会被执行，所以当你撤销缩进的代码块时，你会看到一个错误，直到你再次执行有效的代码。
- en: Reloading modules
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新加载模块
- en: Often, when developing, I will write code in my regular editor and test the
    execution in the Python shell.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，我经常在我的常规编辑器中编写代码，并在 Python 壳中测试执行。
- en: When developing like this, a very useful feature of Python is the ability to
    reload imported modules using `importlib.reload()`. When you have multiple (nested)
    modules, this can get tedious fast, however. This is where the reload shortcut
    in `bpython` can help a lot. By using the *F6* button on your keyboard, `bpython`
    will not only run `importlib.reload()` on all modules in `sys.modules`, but it
    will also rerun the code in your session in a similar way to the rewind feature
    you saw earlier.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当这样开发时，Python的一个非常有用的特性是使用`importlib.reload()`重新加载导入的模块。当您有多个（嵌套）模块时，这可能会很快变得繁琐。这就是`bpython`中的重新加载快捷键能大量帮助的地方。通过使用键盘上的*F6*按钮，`bpython`不仅会在`sys.modules`中的所有模块上运行`importlib.reload()`，而且还会以类似您之前看到的回放功能的方式重新运行会话中的代码。
- en: 'To demonstrate this, we will start by creating a file named `bpython_reload.py`
    with the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们将首先创建一个名为`bpython_reload.py`的文件，并包含以下代码：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This opens the `reload.txt` file for reading and writing in append mode. This
    means that `fh.write('x')` will append to the end of the file. The `fh.seek(0)`
    will jump to the beginning of the file (position 0) so that `print(fh.read())`
    can print the entire file content to the screen.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以追加模式打开`reload.txt`文件进行读写。这意味着`fh.write('x')`将追加到文件末尾。`fh.seek(0)`将跳转到文件开头（位置0），以便`print(fh.read())`可以将整个文件内容打印到屏幕上。
- en: 'Now we open the `bpython` shell and import the module:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们打开`bpython` shell并导入模块：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we press the *F6* button within that same shell, we will see that an extra
    character has been written and the code has been re-executed:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在同一个shell中按*F6*按钮，我们会看到已经写入了一个额外的字符，并且代码已经被重新执行：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is an extremely useful feature with the same caveat as the rewind feature
    that not all code is safe to re-execute without side effects.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有用的特性，与回放功能有相同的警告，即并非所有代码都是安全的，可以无副作用地重新执行。
- en: ptpython
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ptpython
- en: 'The `ptpython` interpreter is younger (available since 2014) than `bpython`
    (available since 2009), so it might be slightly less mature and feature rich.
    It is, however, very actively developing and certainly worth mentioning. While
    there is (currently) no code reload feature similar to the one in `bpython`, there
    are several other useful features that `bpython` currently lacks:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`ptpython`解释器比`bpython`（自2009年可用）年轻（自2014年可用），因此可能稍微不够成熟，功能也不够丰富。然而，它正在非常积极地开发，并且绝对值得提及。虽然目前没有与`bpython`中类似的代码重新加载功能，但还有一些其他有用的功能是`bpython`目前所缺少的：'
- en: Multiline code editing
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多行代码编辑
- en: Mouse support
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标支持
- en: Both Vi and Emacs key bindings
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vi和Emacs键绑定
- en: Syntax checking while typing
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入时的语法检查
- en: A history browser
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 历史浏览器
- en: Output highlighting
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出突出显示
- en: These features are all ones you need to experience yourself, though; a book
    is not the right medium for a demonstration in this case. In any case, this interpreter
    is certainly worth looking at.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性都是您需要亲自体验的；在这种情况下，一本书并不是演示的正确媒介。无论如何，这个解释器绝对值得一看。
- en: 'Installation can be done with a simple `pip install`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 安装可以通过简单的`pip install`完成：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After installing, you can run it using the `ptpython` command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，您可以使用`ptpython`命令运行它：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once the interpreter is running, you can configure `ptpython` using the built-in
    menu (press *F2*). In that menu, you can configure and enable/disable features
    such as completion for dictionaries, completion while typing, input validation,
    color depth, and highlighting colors.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦解释器开始运行，您可以使用内置菜单配置`ptpython`（按*F2*）。在该菜单中，您可以配置和启用/禁用诸如字典完成、输入时完成、输入验证、颜色深度和突出显示颜色等功能。
- en: IPython and Jupyter
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPython和Jupyter
- en: The IPython interpreter is a completely different beast from the previously
    mentioned interpreters. In addition to being the interpreter with the most features,
    it is part of a whole ecosystem of packages that includes parallel computing,
    integrations with visual toolkits, interactive widgets, and a web-based interpreter
    (Jupyter).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: IPython解释器与之前提到的解释器完全不同。它不仅是功能最丰富的解释器，还是包括并行计算、与可视化工具包集成、交互式小部件和基于Web的解释器（Jupyter）在内的整个生态系统的一部分。
- en: 'Some key features of the IPython interpreter:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: IPython解释器的某些关键特性：
- en: Easy object introspection
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的对象内省
- en: Output formatting (instead of `repr()`, IPython calls `pprint.pformat()`)
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出格式化（而不是`repr()`，IPython调用`pprint.pformat()`）
- en: Command history can be accessed through variables and magic methods from both
    new and old sessions
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令历史可以通过新会话和旧会话中的变量和魔法方法访问
- en: Saving and loading sessions
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和加载会话
- en: A whole range of magic commands and shortcuts
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列魔法命令和快捷方式
- en: Access to regular shell commands such as `cd` and `ls`
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问如 `cd` 和 `ls` 这样的常规 shell 命令
- en: Extensible tab completion, supporting not just Python methods and functions
    but filenames as well
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展的自动补全，不仅支持 Python 方法和函数，还支持文件名
- en: Several of the other features of the IPython project are covered in the chapters
    about debugging, multiprocessing, scientific programming, and machine learning.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 项目的其他一些特性在关于调试、多进程、科学编程和机器学习的章节中有所介绍。
- en: 'The basic installation of IPython can be done using a `pip install`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 的基本安装可以使用 `pip install` 完成：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Installing through Anaconda is also a good option, though, especially if you
    are planning to use a lot of data science packages, which are often far easier
    to install and manage through `conda`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Anaconda 安装也是一个不错的选择，尤其是如果你计划使用大量的数据科学包，这些包通常通过 `conda` 安装和管理要容易得多：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Basic interpreter usage
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本解释器使用
- en: 'The IPython interpreter can be used in a similar way to the other interpreters,
    but has somewhat different output from the other interpreters. Here’s an example
    covering some of the key features:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 解释器可以像其他解释器一样使用，但与其他解释器的输出略有不同。以下是一个涵盖一些关键特性的示例：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first line is a simple variable declaration; nothing special there. The
    second line shows the print output for the variable declared in the first line.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是一个简单的变量声明；那里没有什么特别之处。第二行显示了第一行声明的变量的打印输出。
- en: Now we declare a similar dictionary with more items in it. You can see that
    the output is now automatically formatted and split over multiple lines for readability
    if the line is too long for the screen. This effectively comes down to `print()`
    versus `pprint.pprint()`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们声明一个具有更多项的类似字典。你可以看到，如果行太长而无法在屏幕上显示，输出将自动格式化并拆分到多行以提高可读性。这实际上相当于 `print()`
    与 `pprint.pprint()` 的区别。
- en: 'At `In [5]: _i1,` we see one of the useful internal variables, the input line.
    The `_i<N>` and `_ih[<N>]` variables give you the lines you wrote. Similarly,
    the last three entered lines are available through `_i`, `_ii`, and `_iii`, respectively.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '在 `In [5]: _i1,` 我们可以看到一个有用的内部变量，即输入行。`_i<N>` 和 `_ih[<N>]` 变量提供了你所写的行。同样，最后输入的三行分别通过
    `_i`、`_ii` 和 `_iii` 可用。'
- en: If the command generated output, it will be available through `_<N>`. And the
    last three output results are available through `_`, `__`, and `___`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令生成了输出，它将通过 `_<N>` 提供。最后三个输出结果分别通过 `_`、`__` 和 `___` 提供。
- en: Finally, we call the external shell function `echo` by prefixing the line with
    `!` while passing along the Python variable `_i2`. When executing external shell
    functions, we can pass along Python variables by prefixing them with a `$`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过在行前加上 `!` 并传递 Python 变量 `_i2` 来调用外部 shell 函数 `echo`。在执行外部 shell 函数时，我们可以通过在它们前面加上
    `$` 来传递 Python 变量。
- en: Saving and loading sessions
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存和加载会话
- en: 'The ability to save and load a session so you can always come back to it is
    an incredibly useful feature. As is usually the case with IPython, there are several
    ways of achieving this goal. First of all, every session is already automatically
    saved for you, requiring no effort whatsoever. To load the previous session, you
    can run:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 能够保存和加载会话，以便你总能回到它，这是一个极其有用的功能。在 IPython 中，通常有多种方法可以实现这一目标。首先，每个会话已经自动为你保存，无需任何努力。要加载上一个会话，你可以运行：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This command uses the same syntax as the `%history` command. Here is a quick
    overview of how the `%history` syntax works:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令使用与 `%history` 命令相同的语法。以下是 `%history` 语法快速概述：
- en: '`5`: Line 5'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5`: 第 5 行'
- en: '`-t 5`: Line 5 as pure Python (without IPython magic)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-t 5`: 第 5 行作为纯 Python（不带 IPython 魔法）'
- en: '`10-20`: Lines 10 to 20'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10-20`: 第 10 到 20 行'
- en: '`10/20`: Session 10, line 20'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10/20`: 第 10 个会话的第 20 行'
- en: '`~0/`: Current session'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~0/`: 当前会话'
- en: '`~1/10-20`: Previous session lines 10 to 20'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~1/10-20`: 前一个会话的第 10 到 20 行'
- en: '`~5/-~2`: Everything from 5 sessions ago to 2 sessions ago'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~5/-~2`: 从 5 个会话前到 2 个会话前的所有内容'
- en: 'If you know that a session will be an important one and you want to make sure
    it gets saved, use `%logstart`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道一个会话将非常重要，并且想要确保它被保存，可以使用 `%logstart`：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As can be seen in the output, this feature is configurable. By default, it will
    write to (and rotate, if it exists) `ipython_log.py`. As soon as you run this
    command again, the previous logfile will be renamed to `ipython_log.001~` and
    so on for the older files.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，此功能是可配置的。默认情况下，它将写入（如果存在，则旋转）`ipython_log.py`。一旦再次运行此命令，之前的日志文件将被重命名为`ipython_log.001~`，依此类推，对于较旧的文件。
- en: 'Loading is done using the `%load` command and will immediately reactivate auto-logging
    since it’s replaying that line as well:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`%load`命令进行加载，并将立即重新激活自动记录，因为它也在回放该行：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Naturally, manually saving is also an option using `%save`. I would recommend
    adding the `-r` parameter so the session is saved as raw instead of a regular
    Python file. Let’s illustrate the difference:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，使用`%save`也可以手动保存。我建议添加`-r`参数，以便将会话以原始文件格式保存，而不是常规的Python文件。让我们来展示一下区别：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you don’t need to run the session from a regular Python interpreter, using
    the raw files is somewhat more legible.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要从常规Python解释器运行会话，使用原始文件会更容易阅读。
- en: Regular Python prompt/doctest mode
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常规Python提示符/doctest模式
- en: 'The default `ipython` prompt is very useful but it can feel a little verbose
    at times and you can’t easily copy the results to a file for doctests (we will
    cover more about doctests in *Chapter 10*, *Testing and Logging – Preparing for
    Bugs*). Because of that, it can be convenient to activate the `%doctest_mode`
    magic function so your prompt looks like the familiar Python interpreter:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`ipython`提示符非常有用，但有时可能会觉得有点冗长，而且你无法轻松地将结果复制到文件中进行doctests（我们将在*第10章*中详细介绍doctests，*测试和日志记录
    – 准备错误*）。正因为如此，激活`%doctest_mode`魔法函数可能很方便，这样你的提示符看起来就像熟悉的Python解释器：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, this also influences how the output is formatted, so it’s really
    similar to the regular Python shell. While magic functions can still be used,
    the output is nearly identical to the regular Python shell.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这也影响了输出的格式，所以它与常规的Python shell非常相似。虽然仍然可以使用魔法函数，但输出几乎与常规Python shell相同。
- en: Introspection and help
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反思与帮助
- en: One of the most useful shortcuts of IPython is `?`. That is the shortcut for
    accessing the IPython help, object help, and object introspection. If you’re looking
    for an up-to-date overview of the IPython interpreter features, start by typing
    ? and start reading. If you’re planning to use IPython, I definitely recommend
    doing so.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: IPython最有用的快捷键之一是`?`。这是访问IPython帮助、对象帮助和对象反思的快捷键。如果你正在寻找IPython解释器功能的最新概述，请先输入`?`并开始阅读。如果你打算使用IPython，我强烈推荐这样做。
- en: The `?` and `??` can be used both as a suffix and as a prefix. So, both `?history`
    and `history?` will return in the documentation for the `%history` command.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`?`和`??`既可以作为后缀也可以作为前缀使用。因此，`?history`和`history?`都会在`%history`命令的文档中返回。'
- en: 'Because the `?` shortcut shows the documentation, it is useful for both regular
    Python objects and the magic functions in IPython. The magic functions are really
    not that magic; besides having a name that’s prefixed with a `%`, they are just
    regular Python functions. In addition to `?`, there is also `??,` which attempts
    to show the source of the object:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`?`快捷键显示了文档，所以它对常规Python对象和IPython中的魔法函数都很有用。魔法函数实际上并不那么神奇；除了以`%`为前缀的名称外，它们只是常规的Python函数。除了`?`之外，还有`??,`，它试图显示对象的源代码：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Autocompletion
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动补全
- en: Autocompletion is where `ipython` really gets interesting. In addition to the
    regular code completion, `ipython` will complete filenames and LaTeX/Unicode for
    special characters as well.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 自动补全是`ipython`真正有趣的地方。除了常规的代码补全外，`ipython`还会补全文件名以及用于特殊字符的LaTeX/Unicode。
- en: 'The really useful part starts when creating your own objects, though. While
    regular automatic autocompletion will work without a hitch, you can customize
    the autocompletion to only return specific items, or do dynamic lookups from a
    database if needed. Usage is certainly easy enough:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 真正有用的部分开始于创建你自己的对象时。虽然常规的自动补全可以无缝工作，但你还可以自定义补全，使其只返回特定项，或者如果需要，从数据库中进行动态查找。使用起来当然足够简单：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now for the LaTeX/Unicode character completion. While this might not be something
    you need to use that often, I find it really useful in the cases that you do need
    it:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是LaTeX/Unicode字符补全的时候了。虽然这可能不是你经常需要使用的东西，但我发现当你需要它时，它非常有用：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Jupyter
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jupyter
- en: The Jupyter project offers an amazing web-based interpreter (Jupyter Notebook)
    that makes Python much more accessible for people who need to write some scripts
    but aren’t programmers by trade. It allows a seamless mix of Python code, LaTeX,
    and other markup.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter 项目提供了一个令人惊叹的基于网络的解释器（Jupyter Notebook），这使得 Python 对于需要编写一些脚本但不是职业程序员的用户来说更加易于访问。它允许无缝混合
    Python 代码、LaTeX 和其他标记语言。
- en: The web-based interpreter isn’t the only or even most important feature of the
    Jupyter project, though. The biggest advantage of the Jupyter project is that
    it allows you to connect to remote systems (called “kernels”) from your local
    machine.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 基于网络的解释器并不是 Jupyter 项目的唯一或最重要的功能。Jupyter 项目的最大优势是它允许您从本地机器连接到远程系统（称为“内核”）。
- en: Originally, the project was part of the IPython project when `ipython` was still
    a large monolithic application that contained all components internally. Since
    then, the IPython project has been split into multiple IPython projects and several
    projects under the Jupyter name. Internally, they are still using much of the
    same code base and Jupyter heavily depends on IPython.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，该项目是 IPython 项目的一部分，当时 `ipython` 仍然是一个包含所有组件的庞大单体应用程序。从那时起，IPython 项目已经分裂成多个
    IPython 项目和几个以 Jupyter 命名的项目。内部，它们仍然使用大量的相同代码库，Jupyter 严重依赖于 IPython。
- en: 'Before we continue, we should look at the current structure of the Jupyter
    and IPython projects and describe the most important projects:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们应该看看 Jupyter 和 IPython 项目的当前结构，并描述最重要的项目：
- en: '`jupyter`: The metapackage that contains all the Jupyter projects.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jupyter`：包含所有 Jupyter 项目的元包。'
- en: '`notebook`: The web-based interpreter, which is part of the Jupyter project.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notebook`：作为 Jupyter 项目一部分的基于网络的解释器。'
- en: '`lab`: The next-generation web-based interpreter offering multiple notebooks
    side by side and even supporting code embedded in other languages such as Markdown,
    R, and LaTeX.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lab`：下一代基于网络的解释器，可以并排提供多个笔记本，甚至支持嵌入其他语言如 Markdown、R 和 LaTeX 的代码。'
- en: '`ipython`: The Python terminal interface with the magic functions.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ipython`：具有魔法功能的 Python 终端界面。'
- en: '`jupyter_console`: The Jupyter version of `ipython`.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jupyter_console`：Jupyter 版本的 `ipython`。'
- en: '`ipywidgets`: Interactive widgets that can be used as user input in `notebook`.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ipywidgets`：可以在 `notebook` 中用作用户输入的交互式小部件。'
- en: '`ipyparallel`: The library for easy parallel execution of Python code across
    multiple servers. There will be more about this in *Chapter 14*, *Multiprocessing
    - When a Single CPU Core Is Not Enough*.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ipyparallel`：用于在多个服务器上轻松并行执行 Python 代码的库。关于这一点，将在 *第 14 章*，*多进程 - 当单个 CPU
    核心不够用时* 中详细介绍。'
- en: '`traitlets`: The config system used by IPython and Jupyter, which allows you
    to create configurable objects with validation. There will be more about this
    in *Chapter 8*, *Metaclasses - Making Classes (Not Instances) Smarter*.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traitlets`：IPython 和 Jupyter 所使用的配置系统，它允许您创建具有验证的可配置对象。关于这一点，将在 *第 8 章*，*元类
    - 使类（而非实例）更智能* 中详细介绍。'
- en: '*Figure 2.1* shows the complexity and the size of the Jupyter and IPython projects
    and how they work together:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2.1* 展示了 Jupyter 和 IPython 项目的复杂性和大小，以及它们是如何协同工作的：'
- en: '![Architecture diagram of project relationships](img/B15882_02_01.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![项目关系架构图](img/B15882_02_01.png)'
- en: 'Figure 2.1: Jupyter and IPython project structure'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：Jupyter 和 IPython 项目结构
- en: From this overview, you might wonder why both `ipython` and `jupyter console`
    exist. The difference is that `ipython` runs completely locally in a single process,
    and `jupyter console` runs everything on a remote kernel. When running locally,
    this means that Jupyter will automatically start a background processing kernel
    that any Jupyter application can connect to.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个概述中，您可能会想知道为什么同时存在 `ipython` 和 `jupyter console`。区别在于 `ipython` 在单个进程中完全本地运行，而
    `jupyter console` 在远程内核上运行一切。当本地运行时，这意味着 Jupyter 将自动启动一个后台处理内核，任何 Jupyter 应用程序都可以连接到它。
- en: The Jupyter project could easily fill several books by itself so we will cover
    only the most common features in this chapter. Additionally, *Chapter 14* covers
    the multiprocessing aspect in more detail. And *Chapter 15*, *Scientific Python
    and Plotting*, depends on Jupyter Notebook as well.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter 项目本身就可以填满几本书，所以我们将在本章中仅介绍最常用的功能。此外，*第 14 章* 更详细地介绍了多进程方面。而 *第 15 章*，*科学
    Python 和绘图* 也依赖于 Jupyter Notebook。
- en: Installing Jupyter
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Jupyter
- en: 'First, let’s start with the installation. The installation is easy enough with
    a simple `pip install` or `conda install`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从安装开始。使用简单的 `pip install` 或 `conda install` 进行安装就足够简单了：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, all that’s left is to start it. Once you run the following command, your
    web browser should automatically open:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，剩下的就是启动它了。一旦运行以下命令，您的网络浏览器应该会自动打开：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Docker images are available as well if, for some reason, the installation gives
    you trouble or if you want an easy installation for a lot of dependency-heavy
    packages. For the data science chapter later in the book, the `jupyter/tensorflow-notebook`
    Docker image is used:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装过程中遇到麻烦，或者您想要为大量依赖性强的包进行简单安装，Docker 镜像也是可用的。在本书后面的数据科学章节中，使用了 `jupyter/tensorflow-notebook`
    Docker 镜像：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will run the Docker image and forward port `8888` to the running `jupyter
    lab` so you can access it. Note that because of the default security, you will
    need to open `jupyter lab` through the links provided in the console, which contains
    the randomly generated security token. It should look something like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行 Docker 镜像并将端口 `8888` 转发到正在运行的 `jupyter lab`，以便您可以访问它。请注意，由于默认安全设置，您需要通过控制台提供的链接打开
    `jupyter lab`，其中包含随机生成的安全令牌。它看起来可能像这样：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once you have it up and running, you should see something like this in your
    browser:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动并运行，您在浏览器中应该会看到类似以下内容：
- en: '![](img/B15882_02_02.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15882_02_02.png)'
- en: 'Figure 2.2: Jupyter dashboard'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：Jupyter 仪表板
- en: 'Now you can create a new notebook:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以创建一个新的笔记本：
- en: '![](img/B15882_02_03.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15882_02_03.png)'
- en: 'Figure 2.3: A new file in Jupyter'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3：Jupyter 中的新文件
- en: 'And start typing with tab completion and all the features that are similar
    to `ipython`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 并开始使用 tab 补全和所有类似 `ipython` 的功能进行输入：
- en: '![](img/B15882_02_04.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15882_02_04.png)'
- en: 'Figure 2.4: Jupyter tab completion'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4：Jupyter 标签补全
- en: 'Within a notebook, you can have multiple cells. Each cell can have multiple
    lines of code and behave similarly to the IPython interpreter with one key difference:
    *only the last line* decides what is returned as the output, instead of each line
    being printed separately. But that doesn’t prevent you from using `print()` functions.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在笔记本中，您可以拥有多个单元格。每个单元格可以有多个代码行，并且与 IPython 解释器类似，只有一个关键区别：*只有最后一行*决定返回什么作为输出，而不是每行单独打印。但这并不妨碍您使用
    `print()` 函数。
- en: '![](img/B15882_02_05.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15882_02_05.png)'
- en: 'Figure 2.5: Jupyter output'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5：Jupyter 输出
- en: Each of these cells can be (re-)executed separately if needed, or all at once,
    to make sure the notebook still functions properly. In addition to code cells,
    Jupyter also supports several types of markup languages, such as Markdown, to
    add nicely formatted documentation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，每个单元格都可以单独（重新）执行，或者一次性执行所有单元格，以确保笔记本仍然正常工作。除了代码单元格外，Jupyter 还支持多种标记语言，如
    Markdown，以添加格式化的文档。
- en: 'And because it’s a web-based format, you can attach all sorts of objects, such
    as videos, audio files, PDF files, images, and renders. LaTeX formulas, for example,
    are mostly impossible to render in a normal interpreter, but with Jupyter, rendering
    a LaTeX formula is easily possible:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是一种基于网络的格式，您可以附加各种对象，例如视频、音频文件、PDF 文件、图像和渲染。例如，LaTeX 公式在普通解释器中通常无法渲染，但使用
    Jupyter，渲染 LaTeX 公式则变得非常容易：
- en: '![](img/B15882_02_06.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15882_02_06.png)'
- en: 'Figure 2.6: A LaTeX formula in Jupyter'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6：Jupyter 中的 LaTeX 公式
- en: 'Lastly, we have interactive widgets, which are one of the best features of
    using notebooks over a regular shell session:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还有交互式小部件，这是使用笔记本而不是常规的 shell 会话的最佳特性之一：
- en: '![](img/B15882_02_07.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15882_02_07.png)'
- en: 'Figure 2.7: Jupyter widgets'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7：Jupyter 小部件
- en: By moving the slider, the function will be called again and the result will
    be immediately updated. This is extremely useful when debugging functions. In
    the chapter about user interfaces, you will learn how to create our own.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过移动滑块，函数将被再次调用，结果将立即更新。这在调试函数时非常有用。在关于用户界面的章节中，您将学习如何创建自己的界面。
- en: IPython summary
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPython 摘要
- en: The entire list of features in the IPython and Jupyter projects could easily
    fill several books by itself, so we have only glossed over a very small portion
    of what the interpreter supports.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 和 Jupyter 项目中的所有功能列表单独成书也毫不夸张，所以我们只简要概述了解释器支持的一小部分功能。
- en: Later chapters will cover some other parts of the project, but the IPython documentation
    is your friend. The documentation is really detailed and largely up to date.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 后续章节将介绍项目的其他部分，但 IPython 文档是您的良师益友。文档非常详细，并且大部分内容都是最新的。
- en: 'An overview of some of the shortcuts/magic functions that you’ll want to look
    at follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 下面概述了一些您可能想要查看的快捷键/魔法函数：
- en: '`%quickref`: A quick reference for most of the interpreter features and a list
    of the magic functions.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%quickref`：大多数解释器功能和魔法函数的快速参考列表。'
- en: '`%cd`: Change the current working directory for your `ipython` session.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%cd`：更改`ipython`会话的当前工作目录。'
- en: '`%paste`: Paste a pre-formatted code block from the clipboard so your indentation
    is pasted correctly and not mutilated/clobbered due to auto-indentation.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%paste`：从剪贴板粘贴预格式化的代码块，以确保您的缩进正确粘贴，而不是由于自动缩进而损坏/覆盖。'
- en: '`%edit`: Open an external editor for easy editing of code blocks. This is very
    useful when quickly testing multiline code blocks. The `%edit -p` command, for
    example, will re-edit the previous (`-p`) code block.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%edit`：打开外部编辑器以轻松编辑代码块。这在快速测试多行代码块时非常有用。例如，`%edit -p`命令将重新编辑上一个（`-p`）代码块。'
- en: '`%timeit`: A shortcut to quickly benchmark a line of Python code using the
    `timeit` module.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%timeit`：使用`timeit`模块快速基准测试一行Python代码的快捷方式。'
- en: '`?`: Look at the documentation for any object.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?`：查看任何对象的文档。'
- en: '`??`: Look at the source for any Python object. Native methods such as `sum()`
    are compiled C code, so the source can’t be fetched easily.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`??`：查看任何Python对象的源代码。原生方法，如`sum()`，是编译的C代码，因此源代码无法轻松获取。'
- en: Exercises
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: The `rlcompleter` enhancement we created currently only handles dictionaries.
    Try and extend the code so it supports lists, strings, and tuples as well.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建的`rlcompleter`增强功能目前仅处理字典。尝试扩展代码，使其也支持列表、字符串和元组。
- en: 'Add colors to the completer (hint: use `colorama` for the coloring).'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为补全器添加颜色（提示：使用`colorama`进行着色）。
- en: Instead of manually completing using our own object introspection, try and use
    the `jedi` library for autocompletion, which does static code analysis.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 而不是手动使用我们自己的对象内省来完成，尝试使用`jedi`库来自动完成，该库执行静态代码分析。
- en: Static code analysis inspects code without executing it. This means it’s entirely
    safe to run, even on foreign code, as opposed to the autocompletion we wrote earlier,
    which runs the code in `object.keys()`.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 静态代码分析在不执行代码的情况下检查代码。这意味着它在运行时完全安全，与之前我们编写的自动完成不同，后者在`object.keys()`中运行代码。
- en: Try to create a `Hello <ipywidget>` so the name of the person can be edited
    through a notebook without code changes.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试创建一个`Hello <ipywidget>`，这样可以通过笔记本编辑人的名字，而无需更改代码。
- en: Try and create a script that will look for a given pattern through all of your
    previous `ipython` sessions.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试创建一个脚本，该脚本将遍历您所有的先前`ipython`会话以查找给定的模式。
- en: 'Example answers for these exercises can be found on GitHub: [https://github.com/mastering-python/exercises](Chapter_2.xhtml).
    You are encouraged to submit your own solutions and learn about alternative solutions
    from others.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习的示例答案可以在GitHub上找到：[https://github.com/mastering-python/exercises](Chapter_2.xhtml)。鼓励您提交自己的解决方案，并从他人的替代方案中学习。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has shown you several of the available Python interpreters and
    some of the pros and cons. Additionally, you have had a small glimpse of what
    IPython and Jupyter can offer us. *Chapter 15*, *Scientific Python and Plotting*,
    almost exclusively uses Jupyter Notebooks and demonstrates a few more powerful
    features, such as plotting integration.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您展示了可用的Python解释器的一些以及它们的优缺点。此外，您还简要了解了IPython和Jupyter能为我们提供的内容。*第15章*，*科学Python和绘图*几乎完全使用Jupyter笔记本，并演示了一些更强大的功能，例如绘图集成。
- en: For most generic Python programmers, I would suggest using either `bpython`
    or `ptpython`, since they are really fast and lightweight interpreters to (re-)start
    that still offer a lot of useful features.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数通用的Python程序员，我建议使用`bpython`或`ptpython`，因为它们确实是快速且轻量级的解释器，可以（重新）启动，同时仍然提供许多有用的功能。
- en: If your focus is more on scientific programming and/or handling large datasets
    in your shell, then IPython or JupyterLab are probably more useful. These are
    far more powerful tools, but they come at the cost of having slightly higher start
    up times and system requirements. I personally use both depending on the use case.
    When testing a few simple lines of Python and/or verifying the behavior of a small
    code block, I mostly use `bpython`/`ptpython`. When working with larger blocks
    of code and/or data, I tend to use IPython (or `ptipython`) or even JupyterLab.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的重点是科学编程和/或处理大型数据集，那么IPython或JupyterLab可能更有用。这些工具功能更强大，但代价是启动时间和系统要求略高。我根据使用情况个人使用两者。当测试几行简单的Python代码和/或验证小代码块的行为时，我主要使用`bpython`/`ptpython`。当处理较大的代码块和数据时，我倾向于使用IPython（或`ptipython`）或甚至JupyterLab。
- en: The next chapter covers the Python style guide, which rules are important, and
    why they matter. Readability is one of the most important aspects of the Python
    philosophy, and you will learn methods and styles for writing cleaner and more
    readable Python code. In short, you will learn what Pythonic code is and how to
    write it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章涵盖了Python风格指南，其中哪些规则很重要，以及为什么它们很重要。可读性是Python哲学最重要的方面之一，你将学习编写更干净、更易读的Python代码的方法和风格。简而言之，你将了解什么是Pythonic代码以及如何编写它。
- en: Join our community on Discord
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者进行讨论：[https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)
- en: '![](img/QR_Code156081100001293319171.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code156081100001293319171.png)'
