- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interactive Python Interpreters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a working Python installation, we need to run some code. The
    most obvious way is to create a Python file and execute it. Often, it can be faster
    to interactively develop code from an interactive Python interpreter, however.
    While the standard Python interpreter is already quite powerful, many enhancements
    and alternatives are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The alternative interpreters/shells offer features such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Smart autocompletion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntax highlighting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and loading sessions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic indenting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphing/charting output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternative interpreters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bpython`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ptpython`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ipython`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jupyter`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How to enhance interpreters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python interpreter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard Python interpreter is already fairly powerful, but more options
    are available through customization. First, let’s start with a `'Hello world!'`.
    Because the interpreter uses REPL, all output will be automatically printed and
    we can simply create a string.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes interactive interpreters are referred to as **REPL**. This stands
    for **Read-Eval-Print-Loop**. This effectively means that all of your statements
    will be executed and printed to your screen immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to start the interpreter; after that, we can type our commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That was easy enough. And note that we didn’t have to use `print('Hello world!')`
    to show the output.
  prefs: []
  type: TYPE_NORMAL
- en: Many interpreters have only limited support for Windows. While they all work
    to some degree, your experience will be better with Linux or OS X systems. I recommend
    trying them from a (virtual) Linux/Unix machine at least once to experience the
    full range of features.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the interpreter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As our first enhancement, we will add a few convenient shortcuts to the scope
    of the interpreter. Instead of having to type `import pprint; pprint.pprint(...)`
    to pretty-print our output, it would be useful to use `pp(...)` instead without
    having to run an `import` statement every time we start our interpreter. To do
    this, we will create a Python file that will be executed every time we run Python.
    On Linux and OS X systems, I would recommend ~`/.config/python/init.py`; on Windows,
    something like `C:\Users\rick\AppData\Local\Python\init.py` might be more suitable.
    Within this file, we can add regular Python code that will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python won’t find the file automatically; you need to tell Python where to
    look for the file by using the `PYTHONSTARTUP` environment variable. On Linux
    and OS X, you can change the `~/.zshrc`, `~/.bashrc` file, or whatever your shell
    has, and add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This file is automatically executed every time you open a new shell session.
    So, once you open a new shell session, you are done.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to activate this for your current shell, you can also run the export
    line above in your current shell.
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, you need to find the Advanced System Settings and change the environment
    variables on that screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can add these lines to the file to make pretty print (`pprint`/`pp`)
    and pretty format (`pformat`/`pf`) available by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the Python interpreter, now we will have `pp` and `pf` available
    in our scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With a few of these minor changes, you can make your life a lot easier. You
    could modify your `sys.path` to include a directory with custom libraries, for
    example. And you can also change your prompt using the `sys.ps1` and `sys.ps2`
    variables. To illustrate, we’ll look at the interpreter before our changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we will modify `sys.ps1` and `sys.ps2` and run the exact same code
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The configuration above shows that you can easily change the interpreter to
    a slightly different output if you wish. For consistency purposes, however, it
    might be better to keep it the same.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling and enhancing autocompletion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most useful additions to the interpreter is the `rlcompleter` module.
    This module enables tab-activated autocompletion in your interpreter and is automatically
    activated if the `readline` module is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rlcompleter` module depends on the availability of the `readline` module,
    which is not bundled with Python on Windows systems. Luckily, an alternative can
    be installed easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be very useful to add some extra options to the autocompletion. First,
    look at the default output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the tab completion for "`.`" works perfectly, but the tab completion
    for "`[`" does nothing. It would be useful to know the available items, so now
    we will work on adding that feature. It should be noted that this example uses
    a few techniques that are explained in later chapters, but that shouldn’t matter
    for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'That was quite a bit of code, and if you look carefully, you’ll notice multiple
    potential bugs in this limited example. I’m just trying to show a working example
    here without introducing too much complexity, so several edge cases are not considered.
    To make the script work, we need to store it in the `PYTHONSTARTUP` file as we
    discussed earlier. You should see the result from `print()` after opening the
    interpreter so you can verify whether the script was loaded. With this addition,
    we can now complete dictionary keys as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Naturally, you could expand this to include colors, other completions, and many
    more useful features.
  prefs: []
  type: TYPE_NORMAL
- en: Since this completion calls `object.keys()`, there is a potential risk here.
    This code could be dangerous if, for some reason, the `object.keys()` method code
    is not safe to execute. Perhaps you are running on an external library, or your
    code has overridden the `keys()` method to execute a heavy database function.
    And if `object.keys()` is a generator that is exhausted after executing once,
    you won’t have any results when running your actual code afterward.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `eval()` function can be dangerous to execute on unknown code.
    In this case, `eval()` is only executing the line we typed ourselves, so that
    is less of an issue here.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative interpreters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have seen some of the features of the regular Python interpreter,
    let’s look at some enhanced alternatives. There are many options available, but
    we will limit ourselves to the most popular ones here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bpython`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ptpython`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ipython`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jupyter` (web-based `ipython`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: bpython
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `bpython` interpreter is a `curses` interface for the Python interpreter
    that offers many useful features, while still being very similar to the regular
    Python interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: The `curses` library allows you to create a fully functioning **text-based user
    interface** (**TUI**). A TUI gives you full control over where you want to write
    to the screen. The regular Python interpreter is a **command-line interface**
    (**CLI**), which normally only allows you to append to the screen. With a TUI,
    you can write to any position on the screen, making its features somewhat comparable
    to a **graphical user interface** (**GUI**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some key features of `bpython`:'
  prefs: []
  type: TYPE_NORMAL
- en: As-you-type autocompletion (as opposed to tab completion with `rlcompleter`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In-line syntax highlighting while typing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic function parameter documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A undo/rewind feature that removes the last line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy reloading of imported modules, so your external code changes can be tested
    without restarting the interpreter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick changing of code in an external editor (convenient for multiline functions/code
    blocks)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to save the session to file/pastebin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most of these features work fully automatically and transparently for you.
    Before we can start with `bpython`, we need to install it. A simple `pip install`
    should suffice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate the automatically enabled features, here is the output of the
    code we used for the regular Python interpreter completion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you ran this code on your own system, you would see highlighting as well
    as the intermediate states of autocompletion. I encourage you to give it a try;
    the preceding excerpt does not show enough.
  prefs: []
  type: TYPE_NORMAL
- en: Rewinding your session
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As for the more advanced features, let’s give those a try as well. First, let’s
    start with the rewind feature. While it appears to simply remove the last line,
    in the background it actually replays your entire history, except for the last
    line. This means that if your code is not safe to be run more than once, it can
    cause errors. The following code illustrates the usage and limitations of the
    rewind feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we press *Ctrl* + *R* to “rewind” the last line, we get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the last line is gone now, but that’s not all; the output of
    the `fh.read()` line is now `xx` instead of `x,` which means that the line that
    writes `x` was executed twice. Additionally, the partial line will be executed
    as well, so when rewinding an indented block of code, you will see an error until
    you’ve executed valid code again.
  prefs: []
  type: TYPE_NORMAL
- en: Reloading modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often, when developing, I will write code in my regular editor and test the
    execution in the Python shell.
  prefs: []
  type: TYPE_NORMAL
- en: When developing like this, a very useful feature of Python is the ability to
    reload imported modules using `importlib.reload()`. When you have multiple (nested)
    modules, this can get tedious fast, however. This is where the reload shortcut
    in `bpython` can help a lot. By using the *F6* button on your keyboard, `bpython`
    will not only run `importlib.reload()` on all modules in `sys.modules`, but it
    will also rerun the code in your session in a similar way to the rewind feature
    you saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, we will start by creating a file named `bpython_reload.py`
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This opens the `reload.txt` file for reading and writing in append mode. This
    means that `fh.write('x')` will append to the end of the file. The `fh.seek(0)`
    will jump to the beginning of the file (position 0) so that `print(fh.read())`
    can print the entire file content to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we open the `bpython` shell and import the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we press the *F6* button within that same shell, we will see that an extra
    character has been written and the code has been re-executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is an extremely useful feature with the same caveat as the rewind feature
    that not all code is safe to re-execute without side effects.
  prefs: []
  type: TYPE_NORMAL
- en: ptpython
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ptpython` interpreter is younger (available since 2014) than `bpython`
    (available since 2009), so it might be slightly less mature and feature rich.
    It is, however, very actively developing and certainly worth mentioning. While
    there is (currently) no code reload feature similar to the one in `bpython`, there
    are several other useful features that `bpython` currently lacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Multiline code editing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mouse support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both Vi and Emacs key bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntax checking while typing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A history browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output highlighting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These features are all ones you need to experience yourself, though; a book
    is not the right medium for a demonstration in this case. In any case, this interpreter
    is certainly worth looking at.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installation can be done with a simple `pip install`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing, you can run it using the `ptpython` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Once the interpreter is running, you can configure `ptpython` using the built-in
    menu (press *F2*). In that menu, you can configure and enable/disable features
    such as completion for dictionaries, completion while typing, input validation,
    color depth, and highlighting colors.
  prefs: []
  type: TYPE_NORMAL
- en: IPython and Jupyter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The IPython interpreter is a completely different beast from the previously
    mentioned interpreters. In addition to being the interpreter with the most features,
    it is part of a whole ecosystem of packages that includes parallel computing,
    integrations with visual toolkits, interactive widgets, and a web-based interpreter
    (Jupyter).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some key features of the IPython interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy object introspection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output formatting (instead of `repr()`, IPython calls `pprint.pformat()`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command history can be accessed through variables and magic methods from both
    new and old sessions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and loading sessions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A whole range of magic commands and shortcuts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to regular shell commands such as `cd` and `ls`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensible tab completion, supporting not just Python methods and functions
    but filenames as well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several of the other features of the IPython project are covered in the chapters
    about debugging, multiprocessing, scientific programming, and machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic installation of IPython can be done using a `pip install`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Installing through Anaconda is also a good option, though, especially if you
    are planning to use a lot of data science packages, which are often far easier
    to install and manage through `conda`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Basic interpreter usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The IPython interpreter can be used in a similar way to the other interpreters,
    but has somewhat different output from the other interpreters. Here’s an example
    covering some of the key features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first line is a simple variable declaration; nothing special there. The
    second line shows the print output for the variable declared in the first line.
  prefs: []
  type: TYPE_NORMAL
- en: Now we declare a similar dictionary with more items in it. You can see that
    the output is now automatically formatted and split over multiple lines for readability
    if the line is too long for the screen. This effectively comes down to `print()`
    versus `pprint.pprint()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At `In [5]: _i1,` we see one of the useful internal variables, the input line.
    The `_i<N>` and `_ih[<N>]` variables give you the lines you wrote. Similarly,
    the last three entered lines are available through `_i`, `_ii`, and `_iii`, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: If the command generated output, it will be available through `_<N>`. And the
    last three output results are available through `_`, `__`, and `___`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call the external shell function `echo` by prefixing the line with
    `!` while passing along the Python variable `_i2`. When executing external shell
    functions, we can pass along Python variables by prefixing them with a `$`.
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading sessions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ability to save and load a session so you can always come back to it is
    an incredibly useful feature. As is usually the case with IPython, there are several
    ways of achieving this goal. First of all, every session is already automatically
    saved for you, requiring no effort whatsoever. To load the previous session, you
    can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This command uses the same syntax as the `%history` command. Here is a quick
    overview of how the `%history` syntax works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`5`: Line 5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-t 5`: Line 5 as pure Python (without IPython magic)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10-20`: Lines 10 to 20'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10/20`: Session 10, line 20'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~0/`: Current session'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~1/10-20`: Previous session lines 10 to 20'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~5/-~2`: Everything from 5 sessions ago to 2 sessions ago'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you know that a session will be an important one and you want to make sure
    it gets saved, use `%logstart`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen in the output, this feature is configurable. By default, it will
    write to (and rotate, if it exists) `ipython_log.py`. As soon as you run this
    command again, the previous logfile will be renamed to `ipython_log.001~` and
    so on for the older files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading is done using the `%load` command and will immediately reactivate auto-logging
    since it’s replaying that line as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Naturally, manually saving is also an option using `%save`. I would recommend
    adding the `-r` parameter so the session is saved as raw instead of a regular
    Python file. Let’s illustrate the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t need to run the session from a regular Python interpreter, using
    the raw files is somewhat more legible.
  prefs: []
  type: TYPE_NORMAL
- en: Regular Python prompt/doctest mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The default `ipython` prompt is very useful but it can feel a little verbose
    at times and you can’t easily copy the results to a file for doctests (we will
    cover more about doctests in *Chapter 10*, *Testing and Logging – Preparing for
    Bugs*). Because of that, it can be convenient to activate the `%doctest_mode`
    magic function so your prompt looks like the familiar Python interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this also influences how the output is formatted, so it’s really
    similar to the regular Python shell. While magic functions can still be used,
    the output is nearly identical to the regular Python shell.
  prefs: []
  type: TYPE_NORMAL
- en: Introspection and help
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most useful shortcuts of IPython is `?`. That is the shortcut for
    accessing the IPython help, object help, and object introspection. If you’re looking
    for an up-to-date overview of the IPython interpreter features, start by typing
    ? and start reading. If you’re planning to use IPython, I definitely recommend
    doing so.
  prefs: []
  type: TYPE_NORMAL
- en: The `?` and `??` can be used both as a suffix and as a prefix. So, both `?history`
    and `history?` will return in the documentation for the `%history` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the `?` shortcut shows the documentation, it is useful for both regular
    Python objects and the magic functions in IPython. The magic functions are really
    not that magic; besides having a name that’s prefixed with a `%`, they are just
    regular Python functions. In addition to `?`, there is also `??,` which attempts
    to show the source of the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Autocompletion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Autocompletion is where `ipython` really gets interesting. In addition to the
    regular code completion, `ipython` will complete filenames and LaTeX/Unicode for
    special characters as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The really useful part starts when creating your own objects, though. While
    regular automatic autocompletion will work without a hitch, you can customize
    the autocompletion to only return specific items, or do dynamic lookups from a
    database if needed. Usage is certainly easy enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the LaTeX/Unicode character completion. While this might not be something
    you need to use that often, I find it really useful in the cases that you do need
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Jupyter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Jupyter project offers an amazing web-based interpreter (Jupyter Notebook)
    that makes Python much more accessible for people who need to write some scripts
    but aren’t programmers by trade. It allows a seamless mix of Python code, LaTeX,
    and other markup.
  prefs: []
  type: TYPE_NORMAL
- en: The web-based interpreter isn’t the only or even most important feature of the
    Jupyter project, though. The biggest advantage of the Jupyter project is that
    it allows you to connect to remote systems (called “kernels”) from your local
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: Originally, the project was part of the IPython project when `ipython` was still
    a large monolithic application that contained all components internally. Since
    then, the IPython project has been split into multiple IPython projects and several
    projects under the Jupyter name. Internally, they are still using much of the
    same code base and Jupyter heavily depends on IPython.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we continue, we should look at the current structure of the Jupyter
    and IPython projects and describe the most important projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jupyter`: The metapackage that contains all the Jupyter projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notebook`: The web-based interpreter, which is part of the Jupyter project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lab`: The next-generation web-based interpreter offering multiple notebooks
    side by side and even supporting code embedded in other languages such as Markdown,
    R, and LaTeX.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ipython`: The Python terminal interface with the magic functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jupyter_console`: The Jupyter version of `ipython`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ipywidgets`: Interactive widgets that can be used as user input in `notebook`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ipyparallel`: The library for easy parallel execution of Python code across
    multiple servers. There will be more about this in *Chapter 14*, *Multiprocessing
    - When a Single CPU Core Is Not Enough*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`traitlets`: The config system used by IPython and Jupyter, which allows you
    to create configurable objects with validation. There will be more about this
    in *Chapter 8*, *Metaclasses - Making Classes (Not Instances) Smarter*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 2.1* shows the complexity and the size of the Jupyter and IPython projects
    and how they work together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Architecture diagram of project relationships](img/B15882_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Jupyter and IPython project structure'
  prefs: []
  type: TYPE_NORMAL
- en: From this overview, you might wonder why both `ipython` and `jupyter console`
    exist. The difference is that `ipython` runs completely locally in a single process,
    and `jupyter console` runs everything on a remote kernel. When running locally,
    this means that Jupyter will automatically start a background processing kernel
    that any Jupyter application can connect to.
  prefs: []
  type: TYPE_NORMAL
- en: The Jupyter project could easily fill several books by itself so we will cover
    only the most common features in this chapter. Additionally, *Chapter 14* covers
    the multiprocessing aspect in more detail. And *Chapter 15*, *Scientific Python
    and Plotting*, depends on Jupyter Notebook as well.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Jupyter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let’s start with the installation. The installation is easy enough with
    a simple `pip install` or `conda install`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all that’s left is to start it. Once you run the following command, your
    web browser should automatically open:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Docker images are available as well if, for some reason, the installation gives
    you trouble or if you want an easy installation for a lot of dependency-heavy
    packages. For the data science chapter later in the book, the `jupyter/tensorflow-notebook`
    Docker image is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This will run the Docker image and forward port `8888` to the running `jupyter
    lab` so you can access it. Note that because of the default security, you will
    need to open `jupyter lab` through the links provided in the console, which contains
    the randomly generated security token. It should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have it up and running, you should see something like this in your
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_02_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Jupyter dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can create a new notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_02_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: A new file in Jupyter'
  prefs: []
  type: TYPE_NORMAL
- en: 'And start typing with tab completion and all the features that are similar
    to `ipython`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_02_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Jupyter tab completion'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within a notebook, you can have multiple cells. Each cell can have multiple
    lines of code and behave similarly to the IPython interpreter with one key difference:
    *only the last line* decides what is returned as the output, instead of each line
    being printed separately. But that doesn’t prevent you from using `print()` functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_02_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Jupyter output'
  prefs: []
  type: TYPE_NORMAL
- en: Each of these cells can be (re-)executed separately if needed, or all at once,
    to make sure the notebook still functions properly. In addition to code cells,
    Jupyter also supports several types of markup languages, such as Markdown, to
    add nicely formatted documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'And because it’s a web-based format, you can attach all sorts of objects, such
    as videos, audio files, PDF files, images, and renders. LaTeX formulas, for example,
    are mostly impossible to render in a normal interpreter, but with Jupyter, rendering
    a LaTeX formula is easily possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_02_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: A LaTeX formula in Jupyter'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we have interactive widgets, which are one of the best features of
    using notebooks over a regular shell session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_02_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Jupyter widgets'
  prefs: []
  type: TYPE_NORMAL
- en: By moving the slider, the function will be called again and the result will
    be immediately updated. This is extremely useful when debugging functions. In
    the chapter about user interfaces, you will learn how to create our own.
  prefs: []
  type: TYPE_NORMAL
- en: IPython summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The entire list of features in the IPython and Jupyter projects could easily
    fill several books by itself, so we have only glossed over a very small portion
    of what the interpreter supports.
  prefs: []
  type: TYPE_NORMAL
- en: Later chapters will cover some other parts of the project, but the IPython documentation
    is your friend. The documentation is really detailed and largely up to date.
  prefs: []
  type: TYPE_NORMAL
- en: 'An overview of some of the shortcuts/magic functions that you’ll want to look
    at follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`%quickref`: A quick reference for most of the interpreter features and a list
    of the magic functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%cd`: Change the current working directory for your `ipython` session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%paste`: Paste a pre-formatted code block from the clipboard so your indentation
    is pasted correctly and not mutilated/clobbered due to auto-indentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%edit`: Open an external editor for easy editing of code blocks. This is very
    useful when quickly testing multiline code blocks. The `%edit -p` command, for
    example, will re-edit the previous (`-p`) code block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%timeit`: A shortcut to quickly benchmark a line of Python code using the
    `timeit` module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`?`: Look at the documentation for any object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`??`: Look at the source for any Python object. Native methods such as `sum()`
    are compiled C code, so the source can’t be fetched easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `rlcompleter` enhancement we created currently only handles dictionaries.
    Try and extend the code so it supports lists, strings, and tuples as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add colors to the completer (hint: use `colorama` for the coloring).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of manually completing using our own object introspection, try and use
    the `jedi` library for autocompletion, which does static code analysis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Static code analysis inspects code without executing it. This means it’s entirely
    safe to run, even on foreign code, as opposed to the autocompletion we wrote earlier,
    which runs the code in `object.keys()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Try to create a `Hello <ipywidget>` so the name of the person can be edited
    through a notebook without code changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try and create a script that will look for a given pattern through all of your
    previous `ipython` sessions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Example answers for these exercises can be found on GitHub: [https://github.com/mastering-python/exercises](Chapter_2.xhtml).
    You are encouraged to submit your own solutions and learn about alternative solutions
    from others.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has shown you several of the available Python interpreters and
    some of the pros and cons. Additionally, you have had a small glimpse of what
    IPython and Jupyter can offer us. *Chapter 15*, *Scientific Python and Plotting*,
    almost exclusively uses Jupyter Notebooks and demonstrates a few more powerful
    features, such as plotting integration.
  prefs: []
  type: TYPE_NORMAL
- en: For most generic Python programmers, I would suggest using either `bpython`
    or `ptpython`, since they are really fast and lightweight interpreters to (re-)start
    that still offer a lot of useful features.
  prefs: []
  type: TYPE_NORMAL
- en: If your focus is more on scientific programming and/or handling large datasets
    in your shell, then IPython or JupyterLab are probably more useful. These are
    far more powerful tools, but they come at the cost of having slightly higher start
    up times and system requirements. I personally use both depending on the use case.
    When testing a few simple lines of Python and/or verifying the behavior of a small
    code block, I mostly use `bpython`/`ptpython`. When working with larger blocks
    of code and/or data, I tend to use IPython (or `ptipython`) or even JupyterLab.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter covers the Python style guide, which rules are important, and
    why they matter. Readability is one of the most important aspects of the Python
    philosophy, and you will learn methods and styles for writing cleaner and more
    readable Python code. In short, you will learn what Pythonic code is and how to
    write it.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code156081100001293319171.png)'
  prefs: []
  type: TYPE_IMG
