- en: Chapter 3. Modularize, Package, Deploy!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the past few chapters, you wrote a simple application, added new features
    to it, and made sure that some commonly encountered bugs were fixed. Now, it is
    time to make it available to a broader audience. In this chapter, you will learn
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Modularizing and packaging the code written in earlier chapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing and deploying a source distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a private Python package repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making incremental releases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bringing your code under version control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to word of mouth publicity, the high fantasy game application is gaining
    further attention. More and more people are requesting access to the code, either
    to use the functionality in their own application or to simply play the game.
    So far, you have sent the complete source code to the users requesting it. But,
    it is silly to continue doing that because you have made quite a few frequent
    upgrades.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to handle this. The most basic option is to host the
    code on some server and ask the users to download it from that location. Another
    option is to use a version control system such as **Git** to manage the code and
    let others clone it. Yet another option, which we will see next, is to deploy
    this as a Python package.
  prefs: []
  type: TYPE_NORMAL
- en: '![Modularize, Package, Deploy!](img/B05034_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| *Not so fast, Sir Foo! We have to do some preparatory work first. Hold on
    to your enthusiasm for now. By the way, your army is still far away. You will
    be reunited with your comrades in arms in* [Chapter 6](ch06.html "Chapter 6. Design
    Patterns"), *Design Patterns*. |'
  prefs: []
  type: TYPE_TB
- en: Selecting a versioning convention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do we name new versions of the code? There are several versioning schemes
    in use. Let's quickly review a few popular ones.
  prefs: []
  type: TYPE_NORMAL
- en: Serial increments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this scheme, you just increment the version number in a serial manner for
    each upgrade, for example, v1, v2, v3, and so on. However, this does not give
    any information on what a particular release is about. Just by looking at the
    version number, it is tough to tell whether a particular version introduces a
    revolutionary feature or just fixes a minor bug. It does not give any information
    on API compatibility. You can choose this simple versioning scheme if it is a
    small application with a small user base and a very limited scope.
  prefs: []
  type: TYPE_NORMAL
- en: '![Serial increments](img/B05034_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**API compatibility**'
  prefs: []
  type: TYPE_NORMAL
- en: An **Application Programming Interface** (**API**), in simple terms, enables
    a piece of a program, say a library or an application, to talk to another one
    using a standard set of functions, methods, or objects.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a software library `car` that stores some data on a fancy car. You have
    an application that wishes to get some information on the car color. The library
    says, "just call my `color()` method to get what you need." Here, the `color()`
    method is an API method of the `car` library. With this information, you have
    started using `car.color()` within your application.
  prefs: []
  type: TYPE_NORMAL
- en: In the latest version of the `car` library, `color()` has been renamed to `get_color()`.
    If you switch to this new version, it will break your application code as you
    are still using `car.color()` to retrieve the color information from the library.
    In this case, the new API is said to be incompatible with the older releases of
    the library. Conversely, a **backward compatible** API is where applications using
    the older version of the library will continue to run smoothly even with the newer
    one. This is just one way to look at API compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Using a date format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this convention, the release name is tagged by embedding information on when
    it was released. For example, it may follow the YYYY-MM convention to include
    the year and month of release. Such a convention helps determine how old a particular
    release is. However, as before, the release name itself does not give any information
    about API compatibility unless you follow some hybrid naming convention. This
    scheme is typically useful if you are following a regular release schedule or
    have some time sensitive features in the release.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic versioning scheme
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a recommended versioning convention. In the application we have developed
    so far, we loosely followed the semantic versioning scheme. In this scheme, the
    release is represented by three numbers (**MAJOR.MINOR.PATCH**). For example,
    when we say version 1.2.4, it implies that the major version number is 1, minor
    version is 2, and patch or maintenance version number is 4\. The major version
    number is incremented when you introduce incompatible changes to the API that
    access functionality from your package. The minor version is incremented when
    some new minor functionality is added to the package while keeping the code backward
    compatible. For example, you add a new internal feature to the next version, but
    that does not break any code from the previous version. The API to access functionality
    from the package remains the same as before. The last number represents the patch.
    It is incremented when some bugs are fixed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python *PEP 440* specification talks in depth about the semantic versioning
    scheme for Python distributions. This is what the Python community recommends.
    You can find this specification at [https://www.python.org/dev/peps/pep-0440/](https://www.python.org/dev/peps/pep-0440/).
    Choose the versioning convention that best suits your application.
  prefs: []
  type: TYPE_NORMAL
- en: The versioning scheme illustrated in this book only loosely follows semantic
    versioning. For instance, in earlier illustrations, after fixing some important
    bugs, we updated the minor version number instead of the patch version number.
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding of various versioning conventions, let's go back to
    the *Attack of the Orcs* code and split it into independent modules. This would
    be our first step toward creating a package.
  prefs: []
  type: TYPE_NORMAL
- en: Modularizing the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been referring to modules in the earlier chapters. An explanation is
    in order. A single Python file with a `.py` extension is a **module**. You can
    use this module in some other source code using an `import` statement. The module
    name is the same as the file name, except the `.py` extension. For example, if
    the file name is `knight.py`, then `import knight` will import the module into
    your source file.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will split the code in the `attackoftheorcs_v1_1.py` file
    into individual modules. You can find this file in the supporting code bundle
    for the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Attack of the Orcs v2.0.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will name this version 2.0.0\. The major version is incremented to 2 as we
    are about to make some API level changes. The way we access functionality from
    the code will change after introduction of the new modules. Let's review the source
    file, `attackoftheorcs_v1_1.py`, from [Chapter 2](ch02.html "Chapter 2. Dealing
    with Exceptions"), *Dealing with Exceptions*. The first step is to create a module
    (a new file) for each of the classes. The module name should preferably be all
    lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: '![Attack of the Orcs v2.0.0](img/B05034_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at the code in the preceding screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new module called `gameutils.py` and copy the utility functions `weighted_random_selection`
    and `print_bold` into this module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `attackoftheorcs.py` file holds the `AttackOfTheOrcs` class. In the same
    file, copy the main execution code that runs the game. Optionally, create a new
    module for the main code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the code from the previous screenshot and put the other classes in
    their own modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are not done yet. Splitting the code into a bunch of modules gives rise to
    unresolved references. We need to fix these new errors now. This was not a problem
    earlier as the entire code was in a single file. For example, while creating `Hut`
    instances in the `AttackOfTheOrcs` class, Python could find the `Hut` class definition
    right in the same file. Now, we need to import these classes from their respective
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using an IDE such as PyCharm, it is very easy to detect such unresolved
    references using the **code inspection** feature. The IDE will show a visual indication
    (for example, a red underline) for all problematic references. Additionally, the
    Inspect Code feature lets you find all the problem code in one go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `import` statements at the beginning of the `attackoftheorcs.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Attack of the Orcs v2.0.0](img/B05034_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we import the `Hut` class from the new module called `hut`, and so on.
    The following code screenshot shows the `import` statements in the `knight.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Attack of the Orcs v2.0.0](img/B05034_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code screenshot shows the `import` statements in the `abstractgameunit.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Attack of the Orcs v2.0.0](img/B05034_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Likewise, you have to update all the remaining files and include the necessary
    `import` statements. Those changes are not discussed here. For further details,
    you can refer to the corresponding files in this chapter's supporting code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put all the new modules in a directory, call it `wargame` or give it any name
    you like. Recall that in [Chapter 2](ch02.html "Chapter 2. Dealing with Exceptions"),
    *Dealing with Exceptions*, we had created a class called `GameUnitError` in a
    `gameuniterror.py` file. Make sure to copy this file into the new directory. The
    directory structure after copying `gameuniterror.py` is shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Attack of the Orcs v2.0.0](img/B05034_03_16_wargame_dir.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the last step, let''s verify that the application runs smoothly by executing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Where `python` is either version 3.5 or 2.7.9 (or higher), depending on your
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have modularized the code, let''s create a Python package. What
    is a package? It is a kind of fancy name for a directory where Python modules
    are located. However, there is more to it than that. For such a directory to be
    called a package, it must also contain an `__init__.py` file. This file can be
    kept empty or you can put some initialization code in this file. To transform
    the `wargame` directory as a Python package, we will create an empty `__init__
    .py` file in this directory. The new directory structure is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a package](img/B05034_03_17_new_wargamedir.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Importing from the package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see how to use the functionality from this newly created package. To
    test this out, create a new file, `run_game.py`, at the same directory level as
    the `wargame` package. The directory structure will appear as follows. Here, `mydir`
    is the top-level directory (it can be any name):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing from the package](img/B05034_03_18_rungame_wargame_dir.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following code to the `run_game.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing from the package](img/B05034_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first line is the new `import` statement. Here, we are importing the `AttackOfTheOrcs`
    class from the `attackoftheorcs.py` file. If you execute this file in a terminal
    window, the program might abruptly end with the error traceback shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Such an error will occur if the `wargame` directory path is not included in
    the Python environment. In the error traceback, it is unable to find the `hut.py`
    file. The file is located at `/mydir/wargame/hut.py`. However, the location `/mydir/wargame`
    is not in Python''s search path. As a result, it cannot find the modules in this
    directory. There are several ways to fix this. The simplest option is to specify
    a `PYTHONPATH` environment variable in the terminal. In the Bash shell of Linux
    OS, this can be specified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows OS, you can set it from the command prompt, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Just replace `/mydir/wargame` with the appropriate path on your system. Another
    way to fix the problem is to add a `sys.path.append` `("/mydir/wargame")` statement
    at the beginning of the code in `run_game.py` before the `import` statement, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With both these options, however, you have to specify the full path. Yet another
    way to handle the problem is to add the following code in the `wargame/__init__.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The current path gives the absolute path to the directory where the `__init__.py`
    file is located. With this update, you should be all set to run the game.
  prefs: []
  type: TYPE_NORMAL
- en: Releasing the package on PyPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Python Package Index** (**PyPI**) ( [https://pypi.python.org/pypi](https://pypi.python.org/pypi))
    is a package distribution mechanism for the Python community. It is the official
    repository for the third-party packages. By default, the Python package manager,
    pip, searches this repository to install the packages.
  prefs: []
  type: TYPE_NORMAL
- en: This is the place where we will upload our source distribution and make it generally
    available to the Python community. The PyPI repository has a devoted **test server**
    ([https://testpypi.python.org/pypi](https://testpypi.python.org/pypi)) for developers
    who are just learning to package their code. As this is a learning activity, we
    will first deploy our package on the test server.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare the distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by laying out the ground work for the release. We first need to
    prepare the distribution to be released. The following steps provide a minimal
    set of instructions to prepare the distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – Setting up the package directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Make a new directory, and call it `testgamepkg` or give it any name you like.
    In this directory, copy the `wargame` package we created earlier. Now, create
    the following four empty files in this directory, `README`, `LICENSE.txt`, `MANIFEST.in`,
    and a `setup.py` file. The directory tree is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 1 – Setting up the package directory](img/B05034_03_20_testgamepkg_dir.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is not required to create a new directory, `testgamepkg`. Instead, you can
    create these four files in the same directory where the `wargame` package is present.
    All these files can also be found in the supporting material for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will add contents to each of these new files.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – Writing the setup.py file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `setup.py` file is a required file that contains the metadata for the package
    you want to release. Let''s write the following code in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 – Writing the setup.py file](img/B05034_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `import` statement on the first line imports the built-in `setup` function.
    On the next few lines, the contents of the `README` file are stored in a string
    called `readme`. Finally, we call the `setup` function with various arguments,
    as shown in the preceding code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: Out of these arguments, only `name`, `version`, and `packages` are required
    fields. You can add several other optional metadata arguments to the `setup` function.
    In the preceding code, we have specified the most common ones.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `setup` function takes several optional arguments. See the API reference
    ([https://docs.python.org/3/distutils/apiref.html](https://docs.python.org/3/distutils/apiref.html))
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: In the code, update the `name` field with a unique string. Make sure that the
    name is not already taken as a PyPI package. The `version` field represents the
    current version of the package. Earlier in the chapter, we gave the version number
    2.0.0 to the modularized code. You can either go with this scheme or use your
    own versioning convention. The third required field, `packages`, is a list of
    source packages to be included in the distribution. In this case, it is just the
    `wargame` package that contains all the code. The string stored in the `long_description`
    field is used to display the home page for the package on the PyPI website. In
    the code, we will put the contents of the `README` file as `long_description`.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – Updating the README and LICENSE.txt files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the `LICENSE.txt` file, simply copy the license description under which you
    want to release the package. For example, if you are distributing this package
    under the **MIT License** ([https://opensource.org/licenses/MIT](https://opensource.org/licenses/MIT)),
    copy and paste the MIT License description in this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `README` file is the file where you can add a detailed description of your
    project. PyPI expects this file to be in the **reStructuredText** (**RST)** or
    `.rst` format. More information on this format is available at [http://docutils.sourceforge.net/rst.html](http://docutils.sourceforge.net/rst.html).
    Here is an example of the `README` file. Note that the new lines before each heading
    and the one after the keyword `.. code:: python` are important:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Step 4 – Updating the MANIFEST.in file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, `distutils` includes the following files while creating the distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: The `README`, `README.txt`, `setup.py`, or `setup.cfg` files are present in
    the top-level distribution directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the `*.py` files implied by the packages list in `setup.py`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the `test/test*.py` files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `C` source files indicated by `libraries` or `ext_modules` in `setup.py`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But what if you want to include some additional files in your project? For example,
    we wish to ship `LICENSE.txt` along with the distribution. It won't get included
    as there is no provision to add it by default. For this, `distutils` looks for
    a template file called `MANIFEST.in`, where custom rules can be specified for
    the inclusion of additional files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s edit the `MANIFEST.in` file and make a rule for the inclusion of `LICENSE.txt`.
    Add the following line to this file and save it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Each line in this template represents a command. The preceding line tells Python
    to include all the `.txt` files in the top-level distribution directory. Thus,
    `LICENSE.txt` will now get included in the distribution.
  prefs: []
  type: TYPE_NORMAL
- en: All the files are now updated. It is time to build the distribution now!
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 – Build a deployment-ready distribution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create a source distribution. In a terminal window, run the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `sdist` command creates a distribution with the source files included. Running
    the second command creates a new `dist` directory containing an archive file.
    For example, in `setup.py`, if the `name` field is `testgamepkg` and the `version`
    is `2.0.0`, the archive will be `testgamepkg-2.0.0.tar.gz` on Linux and `testgamepkg-2.0.0.zip`
    on Windows OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, it creates a `MANIFEST` file with a list of all the included
    files in the package. The following screenshot shows the command-line output after
    running the `python setup.py sdist` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 – Build a deployment-ready distribution](img/B05034_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Creating a bdist**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sdist` command creates a source distribution. The examples in this chapter
    will only use `sdist` . However, you can also create a built distribution. The
    simplest way to create a built distribution is `$ python setup.py bdist`. This
    creates a default built distribution for your platform, such as `dist/testgamepkg-2.0.0.linux-x86_64.tar.gz`
    on Linux OS. As an exercise, create this distribution and see the contents of
    the archive. Another way to create a `bdist` is with a Python package called `wheel`
    ([https://pypi.python.org/pypi/wheel](https://pypi.python.org/pypi/wheel)). It
    is a built package format, although there is some work involved to use `wheel`.
    You can try this as yet another exercise. You may need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following `import` statement to `setup.py` file: `import setuptools`.
    Finally, run the command `$ python setup.py bdist_wheel`. This will create a distribution
    archive in the `dist` directory with a `.whl` extension.'
  prefs: []
  type: TYPE_NORMAL
- en: Uploading the distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The distribution is ready for deployment. Let's deploy it now!
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – Creating an account on PyPI test website
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you do not have an account on the PyPI testing site, create one at [https://testpypi.python.org/pypi?:action=register_form](https://testpypi.python.org/pypi?:action=register_form).
    Follow the steps on this website to create a new account.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – Creating a .pypirc file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is an important step. Python assumes the default repository for uploading
    distributions is [https://pypi.python.org/pypi](https://pypi.python.org/pypi).
    However, the PyPI test server has a different address that needs to be specified
    in a `.pypirc` file (notice the dot at the beginning of the name). This file has
    a special format. Add the following contents to the `.pypirc` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The file has details of the PyPI test repository under the header `[pypitest]`.
    In this file, you can store different profiles. Here, `[pypitest]` is a profile
    that stores the repository URL and your user credentials for the PyPI test repository.
    This provides a convenient way to specify the account credentials and repository
    URL while registering or uploading the distribution. The name of the profile can
    be changed to any other string, as long as the corresponding entry in the `index-servers`
    variable is updated. For example, you can name it `[test]`. You can also create
    multiple such profiles if you have multiple accounts on the PyPI or PyPI test
    websites.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this file, update the `username` and `password` fields with your actual
    credentials and save the file. On Linux OS, put this file in the user home directory:
    `~/.pypirc`. On Windows OS, create it at `C:\Users\user_name\.pypirc`. Replace
    `user_name` with the actual username.'
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – Register your project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A simple way to register your project is to log in to the test PyPI website
    and then use the package submission form: [https://testpypi.python.org/pypi?:action=register_form](https://testpypi.python.org/pypi?:action=register_form)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, the project registration can also be done using the command
    line. Open a terminal window and type the following commands. Replace the `/path/to/testgamepkg`
    with the actual path to the directory containing `setup.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-r` option for the `register` command is used to specify the URL of the
    PyPI test repository. Notice that, instead of the URL, we have simply written
    the profile name, `pypitest`. Alternatively, you can also specify the full URL,
    as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output after command execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 – Register your project](img/B05034_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you log in to the test PyPI website, a new project with the unique name you
    have chosen (in this example, it is `testgamepkg`) will show up.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – Uploading the package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, it is time to upload the package. This can be accomplished with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This command does two things. First, it creates the source distribution using
    the `sdist` command and then the source distribution is uploaded to the PyPI test
    repository with the `upload` command.
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 – Uploading the package](img/B05034_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| *That''s a good point, Sir Foo! In the Prepare the distribution section (see
    **Step 4 – Updating the MANIFEST.in** file*)*, we indeed created the distribution
    using the* `python setup.py sdist` *command*. |'
  prefs: []
  type: TYPE_TB
- en: At the time this book was written, `setuptools` did not have a provision to
    upload an existing distribution—the distribution creation and upload need to happen
    in a single command. The good news is that there is a third-party Python package
    called `twine` that enables uploading an already created distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'This package can be installed using pip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install `twine` at the same location as your Python executable. For
    example, if Python 3 is accessed as `/usr/bin/python`, then `twine` can be accessed
    as `/usr/bin/twine`. Now, upload the existing source distribution as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The distribution is now available for anyone to download and install on the
    PyPI test repository! To verify this, visit the package home page on the PyPI
    test site, `https://testpypi.python.org/pypi/your_package_name`. The home page
    of `testgamepkg` with a **2.0.2** version is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 – Uploading the package](img/B05034_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Security note**'
  prefs: []
  type: TYPE_NORMAL
- en: For older versions of Python (before v2.7.9 or v3.2), when you use `python seup.py
    sdist upload`, a HTTP connection is used to upload the files. What it means is
    that your user name and password are a security risk if there is a cyber attack!
    In this case, it is highly recommended to use the `twine` package. It securely
    uploads the distribution over HTTPS using a verified connection.
  prefs: []
  type: TYPE_NORMAL
- en: For Python 2.7.9+ and 3.2+, HTTPS is the default choice to upload the distribution.
    But you can still use `twine` for the other advantages as discussed. Visit [https://pypi.python.org/pypi/twine](https://pypi.python.org/pypi/twine)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: A single command to do it all
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know all the steps, let's combine these three steps, namely registering
    the project, creating a distribution, and uploading the distribution into a single
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this to work, we will make two small changes in `setup.py`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the `name` field to another unique name. This should be different from
    what you chose while following the earlier steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `url` field to reflect this new name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After these changes, run the following command in a terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is a combination of three commands executed in a serial manner. The first
    one, `register -r pypitest`, registers a new project; the second command, `sdist`,
    creates a source distribution; and finally, the third command, `upload -r pypitest`,
    submits the distribution to the PyPI test repository!
  prefs: []
  type: TYPE_NORMAL
- en: Installing your own distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The distribution is now available for installation using pip. Let''s install
    it ourselves to make sure there are no problems. Run the `pip` command shown in
    the following code snippet. Replace `testgamepkg` with the distribution name you
    have uploaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-i` (alternatively, `--index-url`) option specifies the base URL of PyPI.
    If you don''t specify this option, it will default to [https://pypi.python.org/simple](https://pypi.python.org/simple).
    Here is a sample response when the `install` command is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the package is successfully installed, test it by calling the functionality
    from that package. For example, start your Python interpreter and write the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you do not see any errors, everything is working as expected! The distribution
    is now generally available to our users on the PyPI test website.
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing your own distribution](img/B05034_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| *You are right. We only talked about the open distributions using the Python
    community repositories! If you want to create a private distribution, you should
    set up and maintain your own PyPI repository. Let''s talk about that next.* |'
  prefs: []
  type: TYPE_TB
- en: Using a private PyPI repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will briefly cover how to setup a private PyPI repository. The
    discussion will be limited to creating a simple HTTP-based local server. There
    are several packages that can help you do this. Let's use a popular package called
    `pypiserver` ([https://pypi.python.org/pypi/pypiserver](https://pypi.python.org/pypi/pypiserver)).
    Let's open a terminal window and get ready for action.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – Installing pypiserver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, install the required package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `pypi-server` executable sits at the same location that you have the Python
    executable. For example, if you have `/usr/bin/python`, `pypi-server` will be
    available as `/usr/bin/pypi-server`.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – Building a new source distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go to the directory where you have `setup.py` and all other files. In the discussion
    earlier, we named it `testgamepkg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We have already installed `testgamepkg` in an earlier section. To simplify
    things, in `setup.py` let''s change the `name` field to something else. While
    you are at it, also change the `url` and `version` field. The `setup.py` with
    these changes is shown in the following screenshot. The changes are highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 – Building a new source distribution](img/B05034_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s create a new source distribution by the name of `testpkg_private`.
    As before, the archive will be created in the `dist` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Step 3 – Starting a local server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let''s start a local server on your computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `-p` option is used to specify a port number. You can choose a number other
    than `8081`. The command also takes a directory as an argument. We have specified
    it as the `dist` directory. This is where it will search for your private distribution
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 – Starting a local server](img/B05034_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The server will start listening on `http://localhost:8081`. That''s it! Open
    this URL in a browser. It will display a simple web page with instructions, as
    shown in the preceding screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – Installing the private distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The installation instructions at `http://localhost:8081` are self explanatory.
    You can click on the **simple** link to view all the available packages. It essentially
    shows the contents of the `dist` directory specified when we started the server.
    If you want to include any additional packages, you can simply copy those to this
    directory. The following command installs this private distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This was a quick introduction to setting up a private PyPI repository. For illustration,
    we just created a local server based on HTTP. In practice, you should set up a
    secure server with the HTTPS protocol and authenticate users, similar to what
    the PyPI website does. Also, we had a basic mechanism where the package was copied
    over to the repository directory. In a real-world situation, you will need to
    support remote uploads. For further reading, visit the GitHub page of `pypiserver`,
    [https://github.com/pypiserver/pypiserver](https://github.com/pypiserver/pypiserver).
    Some other packages that help set up a private repository include `pyshop` at
    [https://pypi.python.org/pypi/pyshop](https://pypi.python.org/pypi/pyshop) and
    `djangopypi` at [https://pypi.python.org/pypi/djangopypi](https://pypi.python.org/pypi/djangopypi).
  prefs: []
  type: TYPE_NORMAL
- en: Making an incremental release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The package is released but that is not the end of the story. Very soon, you
    will need to make changes to the code and make the newer version available again.
    In this section, we will learn how to submit incremental patches to an already
    deployed distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging and uploading the new version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Preparing for the new release is pretty simple. Just update the version number
    to, for instance, `2.0.1` in the `setup.py` file. After making this change, run
    the earlier command that creates a source distribution and uploads the package
    in one go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The incremental release of v2.0.1 will now be available on the PyPI test repository.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading the installed version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the previous version of the package is already installed on your computer,
    use the `--upgrade` option to update to the latest release version. This step
    is optional, but it is always good practice to verify the released version is
    working as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As we did before, replace the name `testgamepkg` with the package name you have
    chosen.
  prefs: []
  type: TYPE_NORMAL
- en: Version controlling the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's recap what we have done so far. We started application development with
    a simple script. Gradually, we redesigned the application, added new features
    and fixed bugs to transform it into its current state. What if you want to go
    back to an earlier state of the code, say the code you wrote two days ago? You
    may want to do this for various reasons. For instance, the latest code might have
    some bugs that you didn't see two days ago. Imagine another scenario where you
    are collaborating with your colleagues on a project and you all need to work on
    the same set of files. How do we accomplish that?
  prefs: []
  type: TYPE_NORMAL
- en: In such situations, a **version control system** (**VCS**) comes to our rescue.
    It maintains a record of changes you make to the code. The files and directories
    now have a version associated with them. The VCS enables you to pull a specific
    version of any file.
  prefs: []
  type: TYPE_NORMAL
- en: There are several version control systems in use. Git, SVN, CVS, and Mercurial
    are some of the most popular open source VCS. In this book, we will cover some
    preliminary operational instructions on using Git, a distributed revision control
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Git resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Git is a very powerful tool for collaborative development. It is a pretty big
    topic. This chapter just gives a brief overview of some common use cases. The
    goal here is to provide a minimal set of instructions to bring our Python application
    code under version control.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are a few links to the resources that cover Git in a depth well
    beyond our scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://git-scm.com/documentation](https://git-scm.com/documentation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://gitref.org](http://gitref.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are already familiar with Git, or have used another version control such
    as SVN, jump directly to the final topic to solve an exercise. Also, the upcoming
    discussion will primarily focus on using Git from the command line. If you prefer
    a GUI client, the section *Using* *GUI* *clients* *for* *Git* will provide some
    pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Git software can be downloaded from [https://git-scm.com/downloads](https://git-scm.com/downloads).
    The website provides detailed installation instructions for various operating
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'With most Linux flavors, it can be simply installed using the package manager
    of the OS. For example, on Ubuntu, it can be installed from a terminal like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For Windows OS, install using the installer available on the Git website. After
    the installation, you should be able to access the Git executable from the command
    line. If it is not available, add the `PATH` to its executable in your environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your identity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before creating a Git repository and committing any code, you should tell Git
    who you are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With this command, any commits you make will automatically be associated with
    your username and e-mail address.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Git terminology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s understand a few frequently used commands in Git. This list is far from
    being comprehensive. The intention is to just learn the most common Git commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add`: This is a keyword used to bring any file or directory under the version
    control. With the `add` command, the Git index is updated and the new files are
    staged for the next commit, along with other changes in the directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`commit`: This keyword, after making changes to any of the files under version
    control, can be used to commit the files to the repository to register that change.
    In other words, Git records a new revision for the file, which also has information
    on who made those changes. While committing files, you can also add an informative
    message on what changes were made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clone`: This keyword, in Git terminology, means copying an original repository
    into a new one. This cloned repository on your computer can be used as a local
    or a working repository for your source code. Such a repository keeps a track
    of all the local changes you make to the contained code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`push`: Suppose you have a central repository that you have shared with your
    team. It could be located on a remote server. You have cloned this repository
    on your computer and have made several changes within this repository. Now you
    want to make these changes available to others. The `push` command is used to
    send these changes to the central repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pull`: You have updated the central repository with the `push` command. Now,
    if others want to use this code, their cloned repository needs to be synchronized
    with the central one. The `pull` command can be used to update the cloned repository
    with the new changes available in the central repository. If any of the files
    being updated with this command have local modifications, Git will try to merge
    the changes from the central repository into the local one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using a Git repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's set up a Git repository for our application. The steps we are about to
    follow are represented in the following simplified schematic.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and using a Git repository](img/B05034_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many alternatives to bring the code under version control. What is
    illustrated here is just one such option. For example, you can directly start
    with `git init` in the existing `wargame` package directory instead of creating
    a bare repository and then cloning it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a bare remote repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, we will create a **bare** Git repository. It is just a directory that
    stores the revision history of your project. Note that it does not have any commits
    or branches. We will use this bare repository as our central or remote repository.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Git uses the concept of remote repository. In this book, we won't really set
    up a truly remote repository. The remote repository will be just another local
    directory on your computer. To avoid confusion, we will refer to the remote repository
    as the central repository in the upcoming discussion. The details of the remote
    repository and Git branches are stored in the `.git/config` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The convention is to add a `.git` extension to the name. On the command line,
    execute the following commands to initialize a bare repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: First, a directory by the name `wargameRepo.git` is created. Inside this directory,
    the `git --bare init` command initializes a new repository. This command creates
    a `.git` directory for your project. The dot prefix indicates that it is a hidden
    directory. The `--bare` option indicates that this is a bare repository.
  prefs: []
  type: TYPE_NORMAL
- en: Clone the repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As seen earlier, the `clone` command can be used to create a copy of the central
    repository. Here is the command to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, it clones `wargameRepo.git` as `wargameRepo` (a new directory). This assumes
    that you do not have any directory by this name. You can now use the cloned repository,
    `wargameRepo`, as your working copy. This repository has the full working tree.
    In this case, however, there is nothing in there except the `.git` folder. Next,
    we will add files and directories to this working tree.
  prefs: []
  type: TYPE_NORMAL
- en: Copying the code to the cloned repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After cloning, copy the `wargame` package created earlier into the cloned repository.
    The directory structure after this operation is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Copying the code to the cloned repository](img/B05034_03_22_wargameRepo_dir.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Staging the code and committing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just copying the code into the repository doesn't mean it is version controlled.
    To do this, open the command prompt and go to the `wargameRepo` directory using
    the `cd` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, run the following command. Notice the dot in the command. This assumes
    that `git` is recognized as a command in your terminal window. If it isn't, you
    need to update the `PATH` environment variable or just specify the full path to
    this executable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells Git to stage everything in the current directory for a commit. In
    this case, it will add the `wargame` directory and all files inside it. If you
    run the `git status` command, it will show all the new files prepared for the
    initial commit (whenever that happens). The next step is to actually commit the
    files within our working repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Staging the code and committing](img/B05034_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `-m` argument in the `git commit` command is used to specify an informative
    message on what the commit is all about. The messages after this command are shown
    in the response received from Git after this command.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing the changes to the central repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This step is useful, especially when you are co-developing the code with other
    developers. In such a scenario, there will be a central repository, which we created
    earlier with the `--bare` option. To make your changes available to others, you
    need to push those to the central repository. As mentioned in a side note earlier,
    the central repository in this case is just another Git directory on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'We started with an empty repository. For the initial push into the central
    repository, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: What is `origin` here? Recall that our cloned repository, `wargameRepo`, originated
    from the central repository, `wargameRepo.git`. The `origin` is simply the URL
    pointing to your central repository. The second argument, `master`, is the Git
    branch name where the changes will be pushed. The default branch is called master.
    You can create different branches as well. We will limit this discussion to the
    default branch. The `.git/config` file stores details about the origin and branches
    in your local repository.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, the command mentioned earlier pushes the master branch in your
    working repository to the new master branch in your central repository (`origin/master`).
  prefs: []
  type: TYPE_NORMAL
- en: 'After the initial push, if you make any changes to the code, you first need
    to commit those in the working repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that you continue to work on the same branch (master), for any subsequent
    push to the central repository, simply execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This will update the master branch of the central repository with your changes.
    With this, you are all set to share your code with other developers using the
    central repository. If you want to get changes made by other developers, you can
    use `$ git pull` to fetch those changes and merge them with your working copy.
    We did not discuss the other Git features, such as tagging your code, creating
    branches, resolving conflicts, and so on. It is recommended you read the Git documentation,
    [https://git-scm.com/doc](https://git-scm.com/doc), to better understand these
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Using GUI clients for Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The earlier section exclusively discussed how to use Git from the command line.
    These commands can also be accessed through a **graphical user interface** (**GUI**).
    There are many GUI clients available for Git, for instance, **gitk** on Linux
    ([http://gitk.sourceforge.net/](http://gitk.sourceforge.net/)) or **Github Desktop**,
    available for Mac and Windows 7 or later ([https://desktop.github.com/](https://desktop.github.com/)).
    The free Python IDEs, such as the community edition of PyCharm, provide an easy-to-use
    GUI integration for Git and other version control systems. PyCharm provides a
    context menu integration for Git commands. For example, right-clicking on a file
    in the IDE will give you a context menu option to add or commit the file to a
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We released the distribution to the PyPI test repository as it was just a toy
    problem. For more serious stuff, you should deploy the package to the PyPI main
    repository, [https://pypi.python.org/pypi](https://pypi.python.org/pypi). As an
    exercise, deploy a package on the main PyPI server. The process is similar to
    what we discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new account on the PyPI website. Note that you need to create a separate
    account; the test PyPI account won't work here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `.pypirc` file, create a new profile to store credentials for the main
    server. See the following illustration for an inspiration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Appropriately, update the `url` field in `setup.py`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow the other steps in package creation and release. Remember to specify
    the main repository everywhere, instead of the test repository. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See what happens if you do not specify the `-r` option Which repository would
    it default to?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to some key aspects of application development in
    general and Python application development in particular. The chapter started
    with an introduction to different versioning conventions. It demonstrated how
    to create Python modules and packages.
  prefs: []
  type: TYPE_NORMAL
- en: With step-by-step instructions, the chapter demonstrated how to prepare a distribution
    (also called a package), deploy it on the PyPI test server, and install this deployed
    package using pip. Additionally, it also showed you how to make incremental releases
    and set up a private Python distribution. Finally, the chapter provided an overview
    of version control using Git.
  prefs: []
  type: TYPE_NORMAL
- en: Coding standards are a set of guidelines that you should follow while developing
    the code. Complying with these standards can have a significant impact on the
    code readability and the life of the code. In the next chapter, you will learn
    another important aspect of software development, code documentation, and best
    practices.
  prefs: []
  type: TYPE_NORMAL
