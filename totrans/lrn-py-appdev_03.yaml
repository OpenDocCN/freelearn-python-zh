- en: Chapter 3. Modularize, Package, Deploy!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。模块化、打包、部署！
- en: 'In the past few chapters, you wrote a simple application, added new features
    to it, and made sure that some commonly encountered bugs were fixed. Now, it is
    time to make it available to a broader audience. In this chapter, you will learn
    the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几章中，你编写了一个简单的应用程序，为其添加了新功能，并确保修复了一些常见错误。现在，是时候让它面向更广泛的受众了。在本章中，你将学习以下主题：
- en: Modularizing and packaging the code written in earlier chapters
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将前几章编写的代码模块化和打包
- en: Preparing and deploying a source distribution
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备和部署源代码分发
- en: Setting up a private Python package repository
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置私有Python包仓库
- en: Making incremental releases
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作增量发布
- en: Bringing your code under version control
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码纳入版本控制
- en: Thanks to word of mouth publicity, the high fantasy game application is gaining
    further attention. More and more people are requesting access to the code, either
    to use the functionality in their own application or to simply play the game.
    So far, you have sent the complete source code to the users requesting it. But,
    it is silly to continue doing that because you have made quite a few frequent
    upgrades.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了口碑宣传，高奇幻游戏应用正在获得更多的关注。越来越多的人要求获取代码，要么是为了在自己的应用程序中使用功能，要么只是为了简单地玩游戏。到目前为止，你已经向请求的用户发送了完整的源代码。但是，继续这样做是愚蠢的，因为你已经进行了相当频繁的升级。
- en: There are several ways to handle this. The most basic option is to host the
    code on some server and ask the users to download it from that location. Another
    option is to use a version control system such as **Git** to manage the code and
    let others clone it. Yet another option, which we will see next, is to deploy
    this as a Python package.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种处理方式。最基本的选择是将代码托管在某个服务器上，并要求用户从该位置下载。另一个选择是使用版本控制系统，如**Git**来管理代码，并允许其他人克隆它。另一种选择，我们将在下一节中看到，是将它作为Python包部署。
- en: '![Modularize, Package, Deploy!](img/B05034_03_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![模块化、打包、部署！](img/B05034_03_01.jpg)'
- en: '| *Not so fast, Sir Foo! We have to do some preparatory work first. Hold on
    to your enthusiasm for now. By the way, your army is still far away. You will
    be reunited with your comrades in arms in* [Chapter 6](ch06.html "Chapter 6. Design
    Patterns"), *Design Patterns*. |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '*别急，先生Foo！我们首先得做一些准备工作。现在先抑制一下你的热情。顺便说一句，你的军队还远着呢。你将在第6章“设计模式”中与你的战友们重逢。[Chapter
    6](ch06.html "Chapter 6. Design Patterns")。|'
- en: Selecting a versioning convention
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择版本控制约定
- en: How do we name new versions of the code? There are several versioning schemes
    in use. Let's quickly review a few popular ones.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何命名代码的新版本？目前有几种版本控制方案在使用中。让我们快速回顾几个流行的方案。
- en: Serial increments
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列递增
- en: In this scheme, you just increment the version number in a serial manner for
    each upgrade, for example, v1, v2, v3, and so on. However, this does not give
    any information on what a particular release is about. Just by looking at the
    version number, it is tough to tell whether a particular version introduces a
    revolutionary feature or just fixes a minor bug. It does not give any information
    on API compatibility. You can choose this simple versioning scheme if it is a
    small application with a small user base and a very limited scope.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方案中，你只需以序列方式逐次增加版本号进行升级，例如，v1、v2、v3，依此类推。然而，这并没有提供关于特定版本内容的任何信息。仅通过查看版本号，很难判断特定版本是引入了革命性功能还是仅仅修复了一个小错误。它也没有提供关于API兼容性的信息。如果你有一个小应用，用户基础小，范围有限，可以选择这种简单的版本控制方案。
- en: '![Serial increments](img/B05034_03_12.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![序列递增](img/B05034_03_12.jpg)'
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**API compatibility**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**API兼容性**'
- en: An **Application Programming Interface** (**API**), in simple terms, enables
    a piece of a program, say a library or an application, to talk to another one
    using a standard set of functions, methods, or objects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，**应用程序编程接口**（**API**）允许程序的一部分，比如库或应用程序，通过一组标准的函数、方法或对象与另一部分进行通信。
- en: Imagine a software library `car` that stores some data on a fancy car. You have
    an application that wishes to get some information on the car color. The library
    says, "just call my `color()` method to get what you need." Here, the `color()`
    method is an API method of the `car` library. With this information, you have
    started using `car.color()` within your application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个名为`car`的软件库，它存储了一些关于豪华汽车的数据。你的应用程序希望获取一些关于汽车颜色的信息。库会说：“只需调用我的`color()`方法即可获取所需信息。”在这里，`color()`方法是`car`库的API方法。有了这个信息，你开始在应用程序中使用`car.color()`。
- en: In the latest version of the `car` library, `color()` has been renamed to `get_color()`.
    If you switch to this new version, it will break your application code as you
    are still using `car.color()` to retrieve the color information from the library.
    In this case, the new API is said to be incompatible with the older releases of
    the library. Conversely, a **backward compatible** API is where applications using
    the older version of the library will continue to run smoothly even with the newer
    one. This is just one way to look at API compatibility.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在`car`库的最新版本中，`color()`已被重命名为`get_color()`。如果您切换到这个新版本，由于您仍然使用`car.color()`从库中检索颜色信息，您的应用程序代码将会中断。在这种情况下，新的API被认为与库的旧版本不兼容。相反，**向后兼容**的API是指使用库旧版本的应用程序即使在新的版本中也能正常运行。这是看待API兼容性的一个方法。
- en: Using a date format
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用日期格式
- en: In this convention, the release name is tagged by embedding information on when
    it was released. For example, it may follow the YYYY-MM convention to include
    the year and month of release. Such a convention helps determine how old a particular
    release is. However, as before, the release name itself does not give any information
    about API compatibility unless you follow some hybrid naming convention. This
    scheme is typically useful if you are following a regular release schedule or
    have some time sensitive features in the release.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个约定中，版本名称通过嵌入发布时间的信息来标记。例如，它可能遵循YYYY-MM约定来包含发布年份和月份。这样的约定有助于确定特定发布的年龄。然而，正如之前一样，除非您遵循某种混合命名约定，否则发布名称本身不会提供有关API兼容性的任何信息。这个方案通常在您遵循常规发布计划或发布中包含一些时间敏感功能时很有用。
- en: Semantic versioning scheme
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语义版本控制方案
- en: This is a recommended versioning convention. In the application we have developed
    so far, we loosely followed the semantic versioning scheme. In this scheme, the
    release is represented by three numbers (**MAJOR.MINOR.PATCH**). For example,
    when we say version 1.2.4, it implies that the major version number is 1, minor
    version is 2, and patch or maintenance version number is 4\. The major version
    number is incremented when you introduce incompatible changes to the API that
    access functionality from your package. The minor version is incremented when
    some new minor functionality is added to the package while keeping the code backward
    compatible. For example, you add a new internal feature to the next version, but
    that does not break any code from the previous version. The API to access functionality
    from the package remains the same as before. The last number represents the patch.
    It is incremented when some bugs are fixed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个推荐的版本控制约定。在我们迄今为止开发的应用中，我们大致遵循了语义版本控制方案。在这个方案中，版本通过三个数字（**MAJOR.MINOR.PATCH**）来表示。例如，当我们说版本1.2.4时，这意味着主版本号是1，次要版本是2，补丁或维护版本号是4。当你向API引入不兼容的更改以访问你的包的功能时，主版本号会增加。当向包中添加一些新的次要功能，同时保持代码向后兼容时，次要版本会增加。例如，你向下一个版本添加一个新内部功能，但这不会破坏上一个版本的任何代码。访问包功能的API与之前保持相同。最后一个数字代表补丁。当修复了一些错误时，它会增加。
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Python *PEP 440* specification talks in depth about the semantic versioning
    scheme for Python distributions. This is what the Python community recommends.
    You can find this specification at [https://www.python.org/dev/peps/pep-0440/](https://www.python.org/dev/peps/pep-0440/).
    Choose the versioning convention that best suits your application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Python *PEP 440* 规范深入讨论了Python发行版的语义版本控制方案。这是Python社区推荐的。您可以在[https://www.python.org/dev/peps/pep-0440/](https://www.python.org/dev/peps/pep-0440/)找到这个规范。选择最适合您应用的版本控制约定。
- en: The versioning scheme illustrated in this book only loosely follows semantic
    versioning. For instance, in earlier illustrations, after fixing some important
    bugs, we updated the minor version number instead of the patch version number.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中所展示的版本控制方案仅大致遵循语义版本控制。例如，在早期的示例中，在修复了一些重要错误之后，我们更新了次要版本号而不是补丁版本号。
- en: With this understanding of various versioning conventions, let's go back to
    the *Attack of the Orcs* code and split it into independent modules. This would
    be our first step toward creating a package.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了各种版本控制约定之后，让我们回到*奥克之攻*代码，并将其拆分为独立的模块。这将是我们创建包的第一步。
- en: Modularizing the code
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码模块化
- en: We have been referring to modules in the earlier chapters. An explanation is
    in order. A single Python file with a `.py` extension is a **module**. You can
    use this module in some other source code using an `import` statement. The module
    name is the same as the file name, except the `.py` extension. For example, if
    the file name is `knight.py`, then `import knight` will import the module into
    your source file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面几章中提到了模块。现在需要对此进行解释。具有 `.py` 扩展名的单个 Python 文件是一个 **模块**。您可以使用 `import`
    语句在源代码中使用此模块。模块名称与文件名相同，只是没有 `.py` 扩展名。例如，如果文件名是 `knight.py`，则 `import knight`
    将将模块导入到您的源文件中。
- en: In this section, we will split the code in the `attackoftheorcs_v1_1.py` file
    into individual modules. You can find this file in the supporting code bundle
    for the previous chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将 `attackoftheorcs_v1_1.py` 文件中的代码拆分为单独的模块。您可以在上一章的支持代码包中找到此文件。
- en: Attack of the Orcs v2.0.0
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 《奥克之战》v2.0.0 版
- en: We will name this version 2.0.0\. The major version is incremented to 2 as we
    are about to make some API level changes. The way we access functionality from
    the code will change after introduction of the new modules. Let's review the source
    file, `attackoftheorcs_v1_1.py`, from [Chapter 2](ch02.html "Chapter 2. Dealing
    with Exceptions"), *Dealing with Exceptions*. The first step is to create a module
    (a new file) for each of the classes. The module name should preferably be all
    lowercase.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个版本命名为 2.0.0。由于我们即将进行一些 API 级别的更改，主版本号增加到 2。引入新模块后，我们从代码中访问功能的方式将发生变化。让我们回顾一下来自
    [第 2 章](ch02.html "第 2 章。处理异常")，*处理异常* 的源文件 `attackoftheorcs_v1_1.py`。第一步是为每个类创建一个模块（一个新文件）。模块名称最好是全部小写。
- en: '![Attack of the Orcs v2.0.0](img/B05034_03_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![奥克之战 v2.0.0](img/B05034_03_02.jpg)'
- en: 'Let''s take a look at the code in the preceding screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下前面的截图中的代码：
- en: Create a new module called `gameutils.py` and copy the utility functions `weighted_random_selection`
    and `print_bold` into this module.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `gameutils.py` 的新模块，并将 `weighted_random_selection` 和 `print_bold` 这两个实用函数复制到该模块中。
- en: The `attackoftheorcs.py` file holds the `AttackOfTheOrcs` class. In the same
    file, copy the main execution code that runs the game. Optionally, create a new
    module for the main code.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attackoftheorcs.py` 文件包含 `AttackOfTheOrcs` 类。在同一文件中，复制运行游戏的主体执行代码。可选地，为主要的代码创建一个新的模块。'
- en: Refer to the code from the previous screenshot and put the other classes in
    their own modules.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考前面的截图中的代码，并将其他类放入它们自己的模块中。
- en: We are not done yet. Splitting the code into a bunch of modules gives rise to
    unresolved references. We need to fix these new errors now. This was not a problem
    earlier as the entire code was in a single file. For example, while creating `Hut`
    instances in the `AttackOfTheOrcs` class, Python could find the `Hut` class definition
    right in the same file. Now, we need to import these classes from their respective
    modules.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成。将代码拆分为多个模块会导致未解决引用。我们现在需要修复这些新错误。之前这并不是一个问题，因为整个代码都在一个文件中。例如，在 `AttackOfTheOrcs`
    类中创建 `Hut` 实例时，Python 可以在同一个文件中找到 `Hut` 类的定义。现在，我们需要从各自的模块中导入这些类。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are using an IDE such as PyCharm, it is very easy to detect such unresolved
    references using the **code inspection** feature. The IDE will show a visual indication
    (for example, a red underline) for all problematic references. Additionally, the
    Inspect Code feature lets you find all the problem code in one go.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用 PyCharm 等集成开发环境 (IDE)，则可以使用 **代码检查** 功能轻松检测此类未解决引用。IDE 将为所有问题引用显示视觉指示（例如，红色下划线）。此外，Inspect
    Code 功能允许您一次性找到所有问题代码。
- en: 'Add the following `import` statements at the beginning of the `attackoftheorcs.py`
    file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `attackoftheorcs.py` 文件的开始处添加以下 `import` 语句：
- en: '![Attack of the Orcs v2.0.0](img/B05034_03_13.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![奥克之战 v2.0.0](img/B05034_03_13.jpg)'
- en: 'Here, we import the `Hut` class from the new module called `hut`, and so on.
    The following code screenshot shows the `import` statements in the `knight.py`
    file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从新模块 `hut` 中导入 `Hut` 类，等等。以下代码截图显示了 `knight.py` 文件中的 `import` 语句：
- en: '![Attack of the Orcs v2.0.0](img/B05034_03_14.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![奥克之战 v2.0.0](img/B05034_03_14.jpg)'
- en: 'The following code screenshot shows the `import` statements in the `abstractgameunit.py`
    file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码截图显示了 `abstractgameunit.py` 文件中的 `import` 语句：
- en: '![Attack of the Orcs v2.0.0](img/B05034_03_15.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![奥克之战 v2.0.0](img/B05034_03_15.jpg)'
- en: Likewise, you have to update all the remaining files and include the necessary
    `import` statements. Those changes are not discussed here. For further details,
    you can refer to the corresponding files in this chapter's supporting code bundle.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您必须更新所有剩余的文件并包含必要的 `import` 语句。这些更改在此不讨论。有关更多详细信息，您可以参考本章支持代码包中的相应文件。
- en: 'Put all the new modules in a directory, call it `wargame` or give it any name
    you like. Recall that in [Chapter 2](ch02.html "Chapter 2. Dealing with Exceptions"),
    *Dealing with Exceptions*, we had created a class called `GameUnitError` in a
    `gameuniterror.py` file. Make sure to copy this file into the new directory. The
    directory structure after copying `gameuniterror.py` is shown in the next screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有新模块放在一个目录中，命名为 `wargame` 或您喜欢的任何名称。回想一下，在 [第 2 章](ch02.html "第 2 章。处理异常")
    中，我们曾在 `gameuniterror.py` 文件中创建了一个名为 `GameUnitError` 的类。请确保将此文件复制到新目录中。复制 `gameuniterror.py`
    后的目录结构如下截图所示：
- en: '![Attack of the Orcs v2.0.0](img/B05034_03_16_wargame_dir.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Orcs 攻击 v2.0.0](img/B05034_03_16_wargame_dir.jpg)'
- en: 'As the last step, let''s verify that the application runs smoothly by executing
    the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，让我们通过执行以下命令来验证应用程序是否运行顺畅：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Where `python` is either version 3.5 or 2.7.9 (or higher), depending on your
    environment.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `python` 版本可以是 3.5 或 2.7.9（或更高版本），具体取决于您的环境。
- en: Creating a package
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个包
- en: 'Now that we have modularized the code, let''s create a Python package. What
    is a package? It is a kind of fancy name for a directory where Python modules
    are located. However, there is more to it than that. For such a directory to be
    called a package, it must also contain an `__init__.py` file. This file can be
    kept empty or you can put some initialization code in this file. To transform
    the `wargame` directory as a Python package, we will create an empty `__init__
    .py` file in this directory. The new directory structure is shown in the following
    screenshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经模块化了代码，让我们创建一个 Python 包。什么是包？它是一种对 Python 模块所在目录的别称。然而，它不仅仅如此。为了使这样的目录被称为包，它还必须包含一个
    `__init__.py` 文件。这个文件可以保持为空，或者你可以在这个文件中放入一些初始化代码。为了将 `wargame` 目录转换为 Python 包，我们将在该目录中创建一个空的
    `__init__ .py` 文件。新的目录结构如下截图所示：
- en: '![Creating a package](img/B05034_03_17_new_wargamedir.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![创建包](img/B05034_03_17_new_wargamedir.jpg)'
- en: Importing from the package
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从包中导入
- en: 'Let''s see how to use the functionality from this newly created package. To
    test this out, create a new file, `run_game.py`, at the same directory level as
    the `wargame` package. The directory structure will appear as follows. Here, `mydir`
    is the top-level directory (it can be any name):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这个新创建的包的功能。为了测试这一点，在 `wargame` 包的同一目录级别创建一个新的文件，名为 `run_game.py`。目录结构将如下所示。在这里，`mydir`
    是顶级目录（可以是任何名称）：
- en: '![Importing from the package](img/B05034_03_18_rungame_wargame_dir.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![从包中导入](img/B05034_03_18_rungame_wargame_dir.jpg)'
- en: 'Add the following code to the `run_game.py` file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `run_game.py` 文件中：
- en: '![Importing from the package](img/B05034_03_19.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![从包中导入](img/B05034_03_19.jpg)'
- en: 'The first line is the new `import` statement. Here, we are importing the `AttackOfTheOrcs`
    class from the `attackoftheorcs.py` file. If you execute this file in a terminal
    window, the program might abruptly end with the error traceback shown in the following
    code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是新的 `import` 语句。在这里，我们是从 `attackoftheorcs.py` 文件中导入 `AttackOfTheOrcs` 类。如果您在终端窗口中执行此文件，程序可能会突然结束，并显示以下代码中的错误跟踪：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Such an error will occur if the `wargame` directory path is not included in
    the Python environment. In the error traceback, it is unable to find the `hut.py`
    file. The file is located at `/mydir/wargame/hut.py`. However, the location `/mydir/wargame`
    is not in Python''s search path. As a result, it cannot find the modules in this
    directory. There are several ways to fix this. The simplest option is to specify
    a `PYTHONPATH` environment variable in the terminal. In the Bash shell of Linux
    OS, this can be specified as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `wargame` 目录路径未包含在 Python 环境中，将会出现此类错误。在错误跟踪中，无法找到 `hut.py` 文件。该文件位于 `/mydir/wargame/hut.py`。然而，位置
    `/mydir/wargame` 不在 Python 的搜索路径中。因此，它无法找到该目录中的模块。有几种方法可以解决这个问题。最简单的方法是在终端中指定一个
    `PYTHONPATH` 环境变量。在 Linux 操作系统的 Bash shell 中，可以这样指定：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On Windows OS, you can set it from the command prompt, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 操作系统上，您可以从命令提示符设置它，如下所示：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Just replace `/mydir/wargame` with the appropriate path on your system. Another
    way to fix the problem is to add a `sys.path.append` `("/mydir/wargame")` statement
    at the beginning of the code in `run_game.py` before the `import` statement, as
    shown in the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将 `/mydir/wargame` 替换为您系统上的适当路径。另一种修复问题的方法是，在 `run_game.py` 代码中的 `import`
    语句之前，添加一个 `sys.path.append` `("/mydir/wargame")` 语句，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With both these options, however, you have to specify the full path. Yet another
    way to handle the problem is to add the following code in the `wargame/__init__.py`
    file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用这两种选项，您都必须指定完整路径。另一种处理问题的方法是在 `wargame/__init__.py` 文件中添加以下代码：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The current path gives the absolute path to the directory where the `__init__.py`
    file is located. With this update, you should be all set to run the game.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当前路径给出了 `__init__.py` 文件所在目录的绝对路径。通过这次更新，您应该已经准备好运行游戏了。
- en: Releasing the package on PyPI
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 PyPI 上发布包
- en: The **Python Package Index** (**PyPI**) ( [https://pypi.python.org/pypi](https://pypi.python.org/pypi))
    is a package distribution mechanism for the Python community. It is the official
    repository for the third-party packages. By default, the Python package manager,
    pip, searches this repository to install the packages.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python 包索引** (**PyPI**) ([https://pypi.python.org/pypi](https://pypi.python.org/pypi))
    是 Python 社区的包分发机制。它是第三方包的官方仓库。默认情况下，Python 包管理器 pip 会搜索这个仓库来安装包。'
- en: This is the place where we will upload our source distribution and make it generally
    available to the Python community. The PyPI repository has a devoted **test server**
    ([https://testpypi.python.org/pypi](https://testpypi.python.org/pypi)) for developers
    who are just learning to package their code. As this is a learning activity, we
    will first deploy our package on the test server.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们上传源分发的地方，使其对 Python 社区普遍可用。PyPI 仓库有一个专门的 **测试服务器** ([https://testpypi.python.org/pypi](https://testpypi.python.org/pypi))，供刚开始学习打包代码的开发者使用。由于这是一个学习活动，我们将首先在测试服务器上部署我们的包。
- en: Prepare the distribution
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备分发
- en: Let's start by laying out the ground work for the release. We first need to
    prepare the distribution to be released. The following steps provide a minimal
    set of instructions to prepare the distribution.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为发布奠定基础开始。我们首先需要准备要发布的分发。以下步骤提供了一组最小指令来准备分发。
- en: Step 1 – Setting up the package directory
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 1 – 设置包目录
- en: 'Make a new directory, and call it `testgamepkg` or give it any name you like.
    In this directory, copy the `wargame` package we created earlier. Now, create
    the following four empty files in this directory, `README`, `LICENSE.txt`, `MANIFEST.in`,
    and a `setup.py` file. The directory tree is shown in the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的目录，命名为 `testgamepkg` 或您喜欢的任何名称。在这个目录中，复制我们之前创建的 `wargame` 包。现在，在这个目录中创建以下四个空文件，`README`、`LICENSE.txt`、`MANIFEST.in`
    和一个 `setup.py` 文件。目录树如图所示：
- en: '![Step 1 – Setting up the package directory](img/B05034_03_20_testgamepkg_dir.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 1 – 设置包目录](img/B05034_03_20_testgamepkg_dir.jpg)'
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is not required to create a new directory, `testgamepkg`. Instead, you can
    create these four files in the same directory where the `wargame` package is present.
    All these files can also be found in the supporting material for this chapter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要创建新的目录 `testgamepkg`。相反，您可以在包含 `wargame` 包的同一目录中创建这四个文件。所有这些文件也可以在本章的支持材料中找到。
- en: Next, we will add contents to each of these new files.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向每个新文件添加内容。
- en: Step 2 – Writing the setup.py file
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 2 – 编写 setup.py 文件
- en: 'The `setup.py` file is a required file that contains the metadata for the package
    you want to release. Let''s write the following code in this file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup.py` 文件是一个必需的文件，其中包含您要发布的包的元数据。让我们在这个文件中写下以下代码：'
- en: '![Step 2 – Writing the setup.py file](img/B05034_03_05.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 2 – 编写 setup.py 文件](img/B05034_03_05.jpg)'
- en: The `import` statement on the first line imports the built-in `setup` function.
    On the next few lines, the contents of the `README` file are stored in a string
    called `readme`. Finally, we call the `setup` function with various arguments,
    as shown in the preceding code snippet.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行的 `import` 语句导入内置的 `setup` 函数。在接下来的几行中，`README` 文件的内容被存储在一个名为 `readme` 的字符串中。最后，我们使用前面代码片段中所示的各种参数调用
    `setup` 函数。
- en: Out of these arguments, only `name`, `version`, and `packages` are required
    fields. You can add several other optional metadata arguments to the `setup` function.
    In the preceding code, we have specified the most common ones.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些参数中，只有`name`、`version`和`packages`是必需字段。您可以为`setup`函数添加几个其他可选元数据参数。在前面的代码中，我们指定了最常见的参数。
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `setup` function takes several optional arguments. See the API reference
    ([https://docs.python.org/3/distutils/apiref.html](https://docs.python.org/3/distutils/apiref.html))
    for details.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup`函数接受多个可选参数。有关详细信息，请参阅API参考（[https://docs.python.org/3/distutils/apiref.html](https://docs.python.org/3/distutils/apiref.html)）。'
- en: In the code, update the `name` field with a unique string. Make sure that the
    name is not already taken as a PyPI package. The `version` field represents the
    current version of the package. Earlier in the chapter, we gave the version number
    2.0.0 to the modularized code. You can either go with this scheme or use your
    own versioning convention. The third required field, `packages`, is a list of
    source packages to be included in the distribution. In this case, it is just the
    `wargame` package that contains all the code. The string stored in the `long_description`
    field is used to display the home page for the package on the PyPI website. In
    the code, we will put the contents of the `README` file as `long_description`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，使用一个唯一的字符串更新`name`字段。确保该名称尚未被用作PyPI软件包的名称。`version`字段表示软件包的当前版本。在本章的早期部分，我们给模块化代码指定了版本号2.0.0。你可以采用这个方案，或者使用自己的版本控制约定。第三个必需的字段`packages`是一个包含在分发中的源软件包列表。在这种情况下，它只是包含所有代码的`wargame`软件包。存储在`long_description`字段中的字符串用于在PyPI网站上显示软件包的主页。在代码中，我们将`README`文件的内容作为`long_description`。
- en: Step 3 – Updating the README and LICENSE.txt files
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步 – 更新README和LICENSE.txt文件
- en: In the `LICENSE.txt` file, simply copy the license description under which you
    want to release the package. For example, if you are distributing this package
    under the **MIT License** ([https://opensource.org/licenses/MIT](https://opensource.org/licenses/MIT)),
    copy and paste the MIT License description in this file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LICENSE.txt`文件中，只需复制你想要发布软件包的许可描述即可。例如，如果你正在根据**MIT许可协议**（[https://opensource.org/licenses/MIT](https://opensource.org/licenses/MIT)）分发此软件包，请将MIT许可描述复制并粘贴到该文件中。
- en: 'The `README` file is the file where you can add a detailed description of your
    project. PyPI expects this file to be in the **reStructuredText** (**RST)** or
    `.rst` format. More information on this format is available at [http://docutils.sourceforge.net/rst.html](http://docutils.sourceforge.net/rst.html).
    Here is an example of the `README` file. Note that the new lines before each heading
    and the one after the keyword `.. code:: python` are important:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`README`文件是您可以添加项目详细描述的文件。PyPI期望此文件以**reStructuredText**（**RST**）或`.rst`格式存在。有关此格式的更多信息，请参阅[http://docutils.sourceforge.net/rst.html](http://docutils.sourceforge.net/rst.html)。以下是`README`文件的示例。请注意，每个标题之前和`..
    code:: python`关键字之后的新行都很重要：'
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Step 4 – Updating the MANIFEST.in file
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步 – 更新`MANIFEST.in`文件
- en: 'By default, `distutils` includes the following files while creating the distribution:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`distutils`在创建分发时包含以下文件：
- en: The `README`, `README.txt`, `setup.py`, or `setup.cfg` files are present in
    the top-level distribution directory
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README`、`README.txt`、`setup.py`或`setup.cfg`文件位于顶级分发目录中'
- en: All the `*.py` files implied by the packages list in `setup.py`
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup.py`中`*.py`文件列表中隐含的所有文件'
- en: All the `test/test*.py` files
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有`test/test*.py`文件
- en: The `C` source files indicated by `libraries` or `ext_modules` in `setup.py`
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由`setup.py`中的`libraries`或`ext_modules`指示的`C`源文件
- en: But what if you want to include some additional files in your project? For example,
    we wish to ship `LICENSE.txt` along with the distribution. It won't get included
    as there is no provision to add it by default. For this, `distutils` looks for
    a template file called `MANIFEST.in`, where custom rules can be specified for
    the inclusion of additional files.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想在项目中包含一些额外的文件怎么办？例如，我们希望将`LICENSE.txt`与分发一起打包。由于默认情况下没有提供添加它的方法，它将不会被包含。为此，`distutils`会查找一个名为`MANIFEST.in`的模板文件，其中可以指定自定义规则以包含额外的文件。
- en: 'Let''s edit the `MANIFEST.in` file and make a rule for the inclusion of `LICENSE.txt`.
    Add the following line to this file and save it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编辑`MANIFEST.in`文件，并为`LICENSE.txt`的包含制定一个规则。将以下行添加到该文件并保存：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Each line in this template represents a command. The preceding line tells Python
    to include all the `.txt` files in the top-level distribution directory. Thus,
    `LICENSE.txt` will now get included in the distribution.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板中的每一行代表一个命令。前面的行告诉 Python 包含顶级分发目录中的所有 `.txt` 文件。因此，`LICENSE.txt` 现在将被包含在分发中。
- en: All the files are now updated. It is time to build the distribution now!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所有文件现在都已更新。现在是时候构建分发啦！
- en: Step 5 – Build a deployment-ready distribution
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 5 步 – 构建部署就绪的分发
- en: 'Let''s create a source distribution. In a terminal window, run the following
    commands:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个源分发。在终端窗口中，运行以下命令：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `sdist` command creates a distribution with the source files included. Running
    the second command creates a new `dist` directory containing an archive file.
    For example, in `setup.py`, if the `name` field is `testgamepkg` and the `version`
    is `2.0.0`, the archive will be `testgamepkg-2.0.0.tar.gz` on Linux and `testgamepkg-2.0.0.zip`
    on Windows OS.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`sdist` 命令创建一个包含源文件的分发。运行第二个命令创建一个包含存档文件的新 `dist` 目录。例如，在 `setup.py` 中，如果 `name`
    字段是 `testgamepkg` 且版本是 `2.0.0`，则存档在 Linux 上将是 `testgamepkg-2.0.0.tar.gz`，在 Windows
    OS 上将是 `testgamepkg-2.0.0.zip`。'
- en: 'Additionally, it creates a `MANIFEST` file with a list of all the included
    files in the package. The following screenshot shows the command-line output after
    running the `python setup.py sdist` command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它创建一个包含包中所有包含文件的 `MANIFEST` 文件。以下截图显示了运行 `python setup.py sdist` 命令后的命令行输出：
- en: '![Step 5 – Build a deployment-ready distribution](img/B05034_03_06.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![第 5 步 – 构建部署就绪的分发](img/B05034_03_06.jpg)'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Creating a bdist**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建 bdist**'
- en: 'The `sdist` command creates a source distribution. The examples in this chapter
    will only use `sdist` . However, you can also create a built distribution. The
    simplest way to create a built distribution is `$ python setup.py bdist`. This
    creates a default built distribution for your platform, such as `dist/testgamepkg-2.0.0.linux-x86_64.tar.gz`
    on Linux OS. As an exercise, create this distribution and see the contents of
    the archive. Another way to create a `bdist` is with a Python package called `wheel`
    ([https://pypi.python.org/pypi/wheel](https://pypi.python.org/pypi/wheel)). It
    is a built package format, although there is some work involved to use `wheel`.
    You can try this as yet another exercise. You may need to do the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`sdist` 命令创建一个源分发。本章中的示例将仅使用 `sdist`。然而，你也可以创建一个构建分发。创建构建分发的最简单方法是 `$ python
    setup.py bdist`。这将在你的平台上创建一个默认的构建分发，例如在 Linux OS 上的 `dist/testgamepkg-2.0.0.linux-x86_64.tar.gz`。作为一个练习，创建这个分发并查看存档的内容。创建
    `bdist` 的另一种方法是使用一个名为 `wheel` 的 Python 包（[https://pypi.python.org/pypi/wheel](https://pypi.python.org/pypi/wheel)）。它是一种构建包格式，尽管使用
    `wheel` 需要一些工作。你可以尝试这个作为另一个练习。你可能需要执行以下操作：'
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, add the following `import` statement to `setup.py` file: `import setuptools`.
    Finally, run the command `$ python setup.py bdist_wheel`. This will create a distribution
    archive in the `dist` directory with a `.whl` extension.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将以下 `import` 语句添加到 `setup.py` 文件中：`import setuptools`。最后，运行命令 `$ python setup.py
    bdist_wheel`。这将创建一个在 `dist` 目录下具有 `.whl` 扩展名的分发存档。
- en: Uploading the distribution
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传分发
- en: The distribution is ready for deployment. Let's deploy it now!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 分发已准备好部署。现在让我们部署它！
- en: Step 1 – Creating an account on PyPI test website
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 1 步 – 在 PyPI 测试网站上创建账户
- en: If you do not have an account on the PyPI testing site, create one at [https://testpypi.python.org/pypi?:action=register_form](https://testpypi.python.org/pypi?:action=register_form).
    Follow the steps on this website to create a new account.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有 PyPI 测试网站的账户，请在 [https://testpypi.python.org/pypi?:action=register_form](https://testpypi.python.org/pypi?:action=register_form)
    上创建一个。按照该网站上的步骤创建新账户。
- en: Step 2 – Creating a .pypirc file
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2 步 – 创建 .pypirc 文件
- en: 'This is an important step. Python assumes the default repository for uploading
    distributions is [https://pypi.python.org/pypi](https://pypi.python.org/pypi).
    However, the PyPI test server has a different address that needs to be specified
    in a `.pypirc` file (notice the dot at the beginning of the name). This file has
    a special format. Add the following contents to the `.pypirc` file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的步骤。Python 假设上传分发的默认仓库是 [https://pypi.python.org/pypi](https://pypi.python.org/pypi)。然而，PyPI
    测试服务器有一个不同的地址，需要在 `.pypirc` 文件中指定（注意名称开头的点）。此文件具有特殊格式。将以下内容添加到 `.pypirc` 文件中：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The file has details of the PyPI test repository under the header `[pypitest]`.
    In this file, you can store different profiles. Here, `[pypitest]` is a profile
    that stores the repository URL and your user credentials for the PyPI test repository.
    This provides a convenient way to specify the account credentials and repository
    URL while registering or uploading the distribution. The name of the profile can
    be changed to any other string, as long as the corresponding entry in the `index-servers`
    variable is updated. For example, you can name it `[test]`. You can also create
    multiple such profiles if you have multiple accounts on the PyPI or PyPI test
    websites.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件在 `[pypitest]` 标题下包含 PyPI 测试仓库的详细信息。在此文件中，你可以存储不同的配置文件。在这里，`[pypitest]` 是一个存储仓库
    URL 和 PyPI 测试仓库用户凭据的配置文件。这提供了一个方便的方法来指定注册或上传发行版时的账户凭据和仓库 URL。配置文件名可以更改为任何其他字符串，只要更新`index-servers`变量中的对应条目。例如，你可以将其命名为
    `[test]`。如果你在 PyPI 或 PyPI 测试网站上拥有多个账户，你也可以创建多个这样的配置文件。
- en: 'In this file, update the `username` and `password` fields with your actual
    credentials and save the file. On Linux OS, put this file in the user home directory:
    `~/.pypirc`. On Windows OS, create it at `C:\Users\user_name\.pypirc`. Replace
    `user_name` with the actual username.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，使用你的实际凭据更新`username`和`password`字段，并保存文件。在 Linux 操作系统上，将此文件放在用户主目录中：`~/.pypirc`。在
    Windows 操作系统上，在`C:\Users\user_name\.pypirc`处创建它。将`user_name`替换为实际的用户名。
- en: Step 3 – Register your project
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 3 – 注册你的项目
- en: 'A simple way to register your project is to log in to the test PyPI website
    and then use the package submission form: [https://testpypi.python.org/pypi?:action=register_form](https://testpypi.python.org/pypi?:action=register_form)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注册你的项目的一个简单方法是登录到测试 PyPI 网站，然后使用包提交表单：[https://testpypi.python.org/pypi?:action=register_form](https://testpypi.python.org/pypi?:action=register_form)
- en: 'Alternatively, the project registration can also be done using the command
    line. Open a terminal window and type the following commands. Replace the `/path/to/testgamepkg`
    with the actual path to the directory containing `setup.py`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，项目注册也可以通过命令行完成。打开一个终端窗口，并输入以下命令。将`/path/to/testgamepkg`替换为包含`setup.py`的实际路径：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `-r` option for the `register` command is used to specify the URL of the
    PyPI test repository. Notice that, instead of the URL, we have simply written
    the profile name, `pypitest`. Alternatively, you can also specify the full URL,
    as shown in the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`register`命令的`-r`选项用于指定 PyPI 测试仓库的 URL。请注意，我们在这里没有直接写 URL，而是简单地写了配置文件名，`pypitest`。或者，你也可以指定完整的
    URL，如下面的命令所示：'
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following screenshot shows the output after command execution:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了命令执行后的输出：
- en: '![Step 3 – Register your project](img/B05034_03_07.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 3 – 注册你的项目](img/B05034_03_07.jpg)'
- en: If you log in to the test PyPI website, a new project with the unique name you
    have chosen (in this example, it is `testgamepkg`) will show up.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你登录到测试 PyPI 网站，你将看到一个名为你选择的唯一名称的新项目（在这个例子中，它是`testgamepkg`）。
- en: Step 4 – Uploading the package
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 4 – 上传包
- en: 'Finally, it is time to upload the package. This can be accomplished with the
    following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候上传包了。这可以通过以下命令完成：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This command does two things. First, it creates the source distribution using
    the `sdist` command and then the source distribution is uploaded to the PyPI test
    repository with the `upload` command.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令执行了两件事。首先，使用`sdist`命令创建源分布，然后使用`upload`命令将源分布上传到 PyPI 测试仓库。
- en: '![Step 4 – Uploading the package](img/B05034_03_08.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 4 – 上传包](img/B05034_03_08.jpg)'
- en: '| *That''s a good point, Sir Foo! In the Prepare the distribution section (see
    **Step 4 – Updating the MANIFEST.in** file*)*, we indeed created the distribution
    using the* `python setup.py sdist` *command*. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| *这是一个很好的观点，Sir Foo！在准备发行版部分（见**步骤 4 – 更新 MANIFEST.in 文件**）*，我们确实使用了* `python
    setup.py sdist` *命令来创建发行版。|'
- en: At the time this book was written, `setuptools` did not have a provision to
    upload an existing distribution—the distribution creation and upload need to happen
    in a single command. The good news is that there is a third-party Python package
    called `twine` that enables uploading an already created distribution.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书编写时，`setuptools` 没有提供上传现有发行版的选项——发行版的创建和上传需要在单个命令中完成。好消息是，有一个名为 `twine` 的第三方
    Python 包，它允许上传已创建的发行版。
- en: 'This package can be installed using pip:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此包可以使用 pip 安装：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will install `twine` at the same location as your Python executable. For
    example, if Python 3 is accessed as `/usr/bin/python`, then `twine` can be accessed
    as `/usr/bin/twine`. Now, upload the existing source distribution as:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The distribution is now available for anyone to download and install on the
    PyPI test repository! To verify this, visit the package home page on the PyPI
    test site, `https://testpypi.python.org/pypi/your_package_name`. The home page
    of `testgamepkg` with a **2.0.2** version is shown in the following screenshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 – Uploading the package](img/B05034_03_09.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: Tip
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Security note**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: For older versions of Python (before v2.7.9 or v3.2), when you use `python seup.py
    sdist upload`, a HTTP connection is used to upload the files. What it means is
    that your user name and password are a security risk if there is a cyber attack!
    In this case, it is highly recommended to use the `twine` package. It securely
    uploads the distribution over HTTPS using a verified connection.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: For Python 2.7.9+ and 3.2+, HTTPS is the default choice to upload the distribution.
    But you can still use `twine` for the other advantages as discussed. Visit [https://pypi.python.org/pypi/twine](https://pypi.python.org/pypi/twine)
    for more information.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: A single command to do it all
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know all the steps, let's combine these three steps, namely registering
    the project, creating a distribution, and uploading the distribution into a single
    command.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'For this to work, we will make two small changes in `setup.py`, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Change the `name` field to another unique name. This should be different from
    what you chose while following the earlier steps.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `url` field to reflect this new name.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After these changes, run the following command in a terminal window:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is a combination of three commands executed in a serial manner. The first
    one, `register -r pypitest`, registers a new project; the second command, `sdist`,
    creates a source distribution; and finally, the third command, `upload -r pypitest`,
    submits the distribution to the PyPI test repository!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Installing your own distribution
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The distribution is now available for installation using pip. Let''s install
    it ourselves to make sure there are no problems. Run the `pip` command shown in
    the following code snippet. Replace `testgamepkg` with the distribution name you
    have uploaded:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `-i` (alternatively, `--index-url`) option specifies the base URL of PyPI.
    If you don''t specify this option, it will default to [https://pypi.python.org/simple](https://pypi.python.org/simple).
    Here is a sample response when the `install` command is executed:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once the package is successfully installed, test it by calling the functionality
    from that package. For example, start your Python interpreter and write the following
    code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you do not see any errors, everything is working as expected! The distribution
    is now generally available to our users on the PyPI test website.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing your own distribution](img/B05034_03_10.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![安装自己的分发](img/B05034_03_10.jpg)'
- en: '| *You are right. We only talked about the open distributions using the Python
    community repositories! If you want to create a private distribution, you should
    set up and maintain your own PyPI repository. Let''s talk about that next.* |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| *你说得对。我们只讨论了使用 Python 社区仓库的开放分发！如果你想创建私有分发，你应该设置并维护自己的 PyPI 仓库。让我们接下来讨论这个话题。*
    |'
- en: Using a private PyPI repository
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用私有 PyPI 仓库
- en: This section will briefly cover how to setup a private PyPI repository. The
    discussion will be limited to creating a simple HTTP-based local server. There
    are several packages that can help you do this. Let's use a popular package called
    `pypiserver` ([https://pypi.python.org/pypi/pypiserver](https://pypi.python.org/pypi/pypiserver)).
    Let's open a terminal window and get ready for action.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将简要介绍如何设置私有 PyPI 仓库。讨论将限于创建一个简单的基于 HTTP 的本地服务器。有几个包可以帮助你完成这项工作。让我们使用一个流行的包，称为
    `pypiserver` ([https://pypi.python.org/pypi/pypiserver](https://pypi.python.org/pypi/pypiserver))。让我们打开一个终端窗口并准备行动。
- en: Step 1 – Installing pypiserver
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 1 – 安装 pypiserver
- en: 'First, install the required package:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装所需的包：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `pypi-server` executable sits at the same location that you have the Python
    executable. For example, if you have `/usr/bin/python`, `pypi-server` will be
    available as `/usr/bin/pypi-server`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`pypi-server` 可执行文件位于与 Python 可执行文件相同的目录。例如，如果你有 `/usr/bin/python`，则 `pypi-server`
    将作为 `/usr/bin/pypi-server` 可用。'
- en: Step 2 – Building a new source distribution
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 2 – 构建新的源分发
- en: 'Go to the directory where you have `setup.py` and all other files. In the discussion
    earlier, we named it `testgamepkg`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 前往包含 `setup.py` 和所有其他文件的目录。在前面讨论中，我们将其命名为 `testgamepkg`：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We have already installed `testgamepkg` in an earlier section. To simplify
    things, in `setup.py` let''s change the `name` field to something else. While
    you are at it, also change the `url` and `version` field. The `setup.py` with
    these changes is shown in the following screenshot. The changes are highlighted:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在前面部分安装了 `testgamepkg`。为了简化，在 `setup.py` 中，让我们将 `name` 字段更改为其他内容。在此过程中，也请更改
    `url` 和 `version` 字段。带有这些更改的 `setup.py` 如下截图所示。更改已突出显示：
- en: '![Step 2 – Building a new source distribution](img/B05034_03_21.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 2 – 构建新的源分发](img/B05034_03_21.jpg)'
- en: 'Now, let''s create a new source distribution by the name of `testpkg_private`.
    As before, the archive will be created in the `dist` directory:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为 `testpkg_private` 的新源分发。和以前一样，存档将创建在 `dist` 目录中：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Step 3 – Starting a local server
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 3 – 启动本地服务器
- en: 'Next, let''s start a local server on your computer:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在你的计算机上启动一个本地服务器：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `-p` option is used to specify a port number. You can choose a number other
    than `8081`. The command also takes a directory as an argument. We have specified
    it as the `dist` directory. This is where it will search for your private distribution
    packages.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p` 选项用于指定端口号。你可以选择除 `8081` 以外的数字。命令还接受一个目录作为参数。我们将其指定为 `dist` 目录。这就是它将搜索你的私有分发包的地方。'
- en: '![Step 3 – Starting a local server](img/B05034_03_11.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 3 – 启动本地服务器](img/B05034_03_11.jpg)'
- en: 'The server will start listening on `http://localhost:8081`. That''s it! Open
    this URL in a browser. It will display a simple web page with instructions, as
    shown in the preceding screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将监听 `http://localhost:8081`。就这样！在浏览器中打开此 URL。它将显示一个带有说明的简单网页，如前一个截图所示：
- en: Step 4 – Installing the private distribution
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 4 – 安装私有分发
- en: 'The installation instructions at `http://localhost:8081` are self explanatory.
    You can click on the **simple** link to view all the available packages. It essentially
    shows the contents of the `dist` directory specified when we started the server.
    If you want to include any additional packages, you can simply copy those to this
    directory. The following command installs this private distribution:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `http://localhost:8081` 的安装说明是自我解释的。你可以点击 **简单** 链接查看所有可用的包。它基本上显示了我们在启动服务器时指定的
    `dist` 目录的内容。如果你想包含任何额外的包，你可以简单地将其复制到这个目录。以下命令安装此私有分发：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This was a quick introduction to setting up a private PyPI repository. For illustration,
    we just created a local server based on HTTP. In practice, you should set up a
    secure server with the HTTPS protocol and authenticate users, similar to what
    the PyPI website does. Also, we had a basic mechanism where the package was copied
    over to the repository directory. In a real-world situation, you will need to
    support remote uploads. For further reading, visit the GitHub page of `pypiserver`,
    [https://github.com/pypiserver/pypiserver](https://github.com/pypiserver/pypiserver).
    Some other packages that help set up a private repository include `pyshop` at
    [https://pypi.python.org/pypi/pyshop](https://pypi.python.org/pypi/pyshop) and
    `djangopypi` at [https://pypi.python.org/pypi/djangopypi](https://pypi.python.org/pypi/djangopypi).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个快速介绍如何设置私有PyPI仓库。为了说明，我们只是基于HTTP创建了一个本地服务器。在实践中，你应该设置一个使用HTTPS协议的安全服务器并验证用户，类似于PyPI网站所做的那样。此外，我们有一个基本的机制，其中包被复制到仓库目录。在现实世界的情况下，你需要支持远程上传。有关进一步阅读，请访问`pypiserver`的GitHub页面[https://github.com/pypiserver/pypiserver](https://github.com/pypiserver/pypiserver)。其他一些有助于设置私有仓库的包包括位于[https://pypi.python.org/pypi/pyshop](https://pypi.python.org/pypi/pyshop)的`pyshop`和位于[https://pypi.python.org/pypi/djangopypi](https://pypi.python.org/pypi/djangopypi)的`djangopypi`。
- en: Making an incremental release
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作增量发布
- en: The package is released but that is not the end of the story. Very soon, you
    will need to make changes to the code and make the newer version available again.
    In this section, we will learn how to submit incremental patches to an already
    deployed distribution.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 包已经发布，但这并不是故事的结束。很快，你将需要对代码进行更改并再次使新版本可用。在本节中，我们将学习如何向已部署的分布提交增量补丁。
- en: Packaging and uploading the new version
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打包和上传新版本
- en: 'Preparing for the new release is pretty simple. Just update the version number
    to, for instance, `2.0.1` in the `setup.py` file. After making this change, run
    the earlier command that creates a source distribution and uploads the package
    in one go:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 准备新版本发布相当简单。只需在`setup.py`文件中将版本号更新为，例如`2.0.1`。在做出这个更改后，运行之前创建源分布并一次性上传包的命令：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The incremental release of v2.0.1 will now be available on the PyPI test repository.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: v2.0.1的增量发布现在将在PyPI测试仓库中可用。
- en: Upgrading the installed version
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级已安装的版本
- en: 'If the previous version of the package is already installed on your computer,
    use the `--upgrade` option to update to the latest release version. This step
    is optional, but it is always good practice to verify the released version is
    working as expected:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包的先前版本已经安装在你的计算机上，请使用`--upgrade`选项更新到最新发布版本。这一步是可选的，但始终是一个好习惯来验证发布版本是否按预期工作：
- en: '[PRE26]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we did before, replace the name `testgamepkg` with the package name you have
    chosen.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所做的那样，将名称`testgamepkg`替换为你选择的包名。
- en: Version controlling the code
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码版本控制
- en: Let's recap what we have done so far. We started application development with
    a simple script. Gradually, we redesigned the application, added new features
    and fixed bugs to transform it into its current state. What if you want to go
    back to an earlier state of the code, say the code you wrote two days ago? You
    may want to do this for various reasons. For instance, the latest code might have
    some bugs that you didn't see two days ago. Imagine another scenario where you
    are collaborating with your colleagues on a project and you all need to work on
    the same set of files. How do we accomplish that?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下到目前为止我们所做的工作。我们从一个简单的脚本开始应用程序开发。逐渐地，我们对应用程序进行了重新设计，添加了新功能并修复了错误，使其转变为现在的状态。如果你想要回到代码的早期状态，比如说两天前你写的代码，你会怎么做？你可能出于各种原因想要这样做。例如，最新的代码可能有一些你在两天前没有看到的错误。想象另一种场景，你正在与你的同事合作一个项目，你们所有人都需要工作在同一组文件上。我们如何完成这个任务？
- en: In such situations, a **version control system** (**VCS**) comes to our rescue.
    It maintains a record of changes you make to the code. The files and directories
    now have a version associated with them. The VCS enables you to pull a specific
    version of any file.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一个**版本控制系统**（**VCS**）会帮助我们。它记录了你所做的代码更改。现在文件和目录都有了与之关联的版本。VCS使你能够拉取任何文件的特定版本。
- en: There are several version control systems in use. Git, SVN, CVS, and Mercurial
    are some of the most popular open source VCS. In this book, we will cover some
    preliminary operational instructions on using Git, a distributed revision control
    system.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有几种版本控制系统在使用中。Git、SVN、CVS和Mercurial是最受欢迎的开源VCS之一。在这本书中，我们将介绍一些关于使用Git（一个分布式版本控制系统）的初步操作指令。
- en: Git resources
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git资源
- en: Git is a very powerful tool for collaborative development. It is a pretty big
    topic. This chapter just gives a brief overview of some common use cases. The
    goal here is to provide a minimal set of instructions to bring our Python application
    code under version control.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Git是协作开发的一个非常强大的工具。这是一个相当大的主题。本章仅简要概述了一些常见用例。这里的目的是提供一组最小的指令，以便将我们的Python应用程序代码纳入版本控制。
- en: Note
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following are a few links to the resources that cover Git in a depth well
    beyond our scope:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些涵盖Git的资源的链接，其深度远超我们的范围：
- en: '[https://git-scm.com/documentation](https://git-scm.com/documentation)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://git-scm.com/documentation](https://git-scm.com/documentation)'
- en: '[http://gitref.org](http://gitref.org)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://gitref.org](http://gitref.org)'
- en: If you are already familiar with Git, or have used another version control such
    as SVN, jump directly to the final topic to solve an exercise. Also, the upcoming
    discussion will primarily focus on using Git from the command line. If you prefer
    a GUI client, the section *Using* *GUI* *clients* *for* *Git* will provide some
    pointers.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经熟悉Git，或者使用过SVN等其他版本控制系统，请直接跳转到最后的话题以解决练习。此外，即将进行的讨论将主要关注从命令行使用Git。如果您更喜欢GUI客户端，*使用GUI客户端进行Git*这一节将提供一些提示。
- en: Installing Git
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Git
- en: Git software can be downloaded from [https://git-scm.com/downloads](https://git-scm.com/downloads).
    The website provides detailed installation instructions for various operating
    systems.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Git软件可以从[https://git-scm.com/downloads](https://git-scm.com/downloads)下载。该网站为各种操作系统提供了详细的安装说明。
- en: 'With most Linux flavors, it can be simply installed using the package manager
    of the OS. For example, on Ubuntu, it can be installed from a terminal like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数Linux发行版，可以使用操作系统的包管理器简单地安装。例如，在Ubuntu上，可以从终端安装，如下所示：
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For Windows OS, install using the installer available on the Git website. After
    the installation, you should be able to access the Git executable from the command
    line. If it is not available, add the `PATH` to its executable in your environment
    variables.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows操作系统，可以使用Git网站上的安装程序进行安装。安装完成后，您应该能够从命令行访问Git可执行文件。如果不可用，请在您的环境变量中将`PATH`添加到其可执行文件中。
- en: Configuring your identity
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置您的身份
- en: 'Before creating a Git repository and committing any code, you should tell Git
    who you are:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建Git仓库并提交任何代码之前，您应该告诉Git您的身份：
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With this command, any commits you make will automatically be associated with
    your username and e-mail address.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令，您所做的任何提交都将自动与您的用户名和电子邮件地址关联。
- en: Basic Git terminology
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本Git术语
- en: 'Let''s understand a few frequently used commands in Git. This list is far from
    being comprehensive. The intention is to just learn the most common Git commands:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解Git中一些常用的命令。这个列表远非详尽无遗。目的是仅学习最常用的Git命令：
- en: '`add`: This is a keyword used to bring any file or directory under the version
    control. With the `add` command, the Git index is updated and the new files are
    staged for the next commit, along with other changes in the directory.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add`：这是一个用于将任何文件或目录纳入版本控制的关键字。使用`add`命令，Git索引将被更新，新文件将被暂存以供下一次提交，同时还包括目录中的其他更改。'
- en: '`commit`: This keyword, after making changes to any of the files under version
    control, can be used to commit the files to the repository to register that change.
    In other words, Git records a new revision for the file, which also has information
    on who made those changes. While committing files, you can also add an informative
    message on what changes were made.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`commit`：在更改任何受版本控制文件后，可以使用此关键字将文件提交到仓库以注册更改。换句话说，Git为文件记录了一个新版本，其中还包含有关谁进行了这些更改的信息。在提交文件时，您还可以添加有关所做更改的说明性消息。'
- en: '`clone`: This keyword, in Git terminology, means copying an original repository
    into a new one. This cloned repository on your computer can be used as a local
    or a working repository for your source code. Such a repository keeps a track
    of all the local changes you make to the contained code.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clone`：在Git术语中，这个关键字意味着将原始仓库复制到一个新的仓库中。您计算机上的这个克隆仓库可以用作源代码的本地或工作仓库。这样的仓库会跟踪您对包含代码的所有本地更改。'
- en: '`push`: Suppose you have a central repository that you have shared with your
    team. It could be located on a remote server. You have cloned this repository
    on your computer and have made several changes within this repository. Now you
    want to make these changes available to others. The `push` command is used to
    send these changes to the central repository.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pull`: You have updated the central repository with the `push` command. Now,
    if others want to use this code, their cloned repository needs to be synchronized
    with the central one. The `pull` command can be used to update the cloned repository
    with the new changes available in the central repository. If any of the files
    being updated with this command have local modifications, Git will try to merge
    the changes from the central repository into the local one.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using a Git repository
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's set up a Git repository for our application. The steps we are about to
    follow are represented in the following simplified schematic.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and using a Git repository](img/B05034_03_03.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: Tip
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many alternatives to bring the code under version control. What is
    illustrated here is just one such option. For example, you can directly start
    with `git init` in the existing `wargame` package directory instead of creating
    a bare repository and then cloning it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Creating a bare remote repository
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, we will create a **bare** Git repository. It is just a directory that
    stores the revision history of your project. Note that it does not have any commits
    or branches. We will use this bare repository as our central or remote repository.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Git uses the concept of remote repository. In this book, we won't really set
    up a truly remote repository. The remote repository will be just another local
    directory on your computer. To avoid confusion, we will refer to the remote repository
    as the central repository in the upcoming discussion. The details of the remote
    repository and Git branches are stored in the `.git/config` file.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'The convention is to add a `.git` extension to the name. On the command line,
    execute the following commands to initialize a bare repository:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First, a directory by the name `wargameRepo.git` is created. Inside this directory,
    the `git --bare init` command initializes a new repository. This command creates
    a `.git` directory for your project. The dot prefix indicates that it is a hidden
    directory. The `--bare` option indicates that this is a bare repository.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Clone the repository
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As seen earlier, the `clone` command can be used to create a copy of the central
    repository. Here is the command to do this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, it clones `wargameRepo.git` as `wargameRepo` (a new directory). This assumes
    that you do not have any directory by this name. You can now use the cloned repository,
    `wargameRepo`, as your working copy. This repository has the full working tree.
    In this case, however, there is nothing in there except the `.git` folder. Next,
    we will add files and directories to this working tree.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Copying the code to the cloned repository
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After cloning, copy the `wargame` package created earlier into the cloned repository.
    The directory structure after this operation is shown here:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![Copying the code to the cloned repository](img/B05034_03_22_wargameRepo_dir.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: Staging the code and committing
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just copying the code into the repository doesn't mean it is version controlled.
    To do this, open the command prompt and go to the `wargameRepo` directory using
    the `cd` command.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, run the following command. Notice the dot in the command. This assumes
    that `git` is recognized as a command in your terminal window. If it isn't, you
    need to update the `PATH` environment variable or just specify the full path to
    this executable.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This tells Git to stage everything in the current directory for a commit. In
    this case, it will add the `wargame` directory and all files inside it. If you
    run the `git status` command, it will show all the new files prepared for the
    initial commit (whenever that happens). The next step is to actually commit the
    files within our working repository:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![Staging the code and committing](img/B05034_03_04.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: The `-m` argument in the `git commit` command is used to specify an informative
    message on what the commit is all about. The messages after this command are shown
    in the response received from Git after this command.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Pushing the changes to the central repository
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This step is useful, especially when you are co-developing the code with other
    developers. In such a scenario, there will be a central repository, which we created
    earlier with the `--bare` option. To make your changes available to others, you
    need to push those to the central repository. As mentioned in a side note earlier,
    the central repository in this case is just another Git directory on your computer.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'We started with an empty repository. For the initial push into the central
    repository, execute the following command:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: What is `origin` here? Recall that our cloned repository, `wargameRepo`, originated
    from the central repository, `wargameRepo.git`. The `origin` is simply the URL
    pointing to your central repository. The second argument, `master`, is the Git
    branch name where the changes will be pushed. The default branch is called master.
    You can create different branches as well. We will limit this discussion to the
    default branch. The `.git/config` file stores details about the origin and branches
    in your local repository.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, the command mentioned earlier pushes the master branch in your
    working repository to the new master branch in your central repository (`origin/master`).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'After the initial push, if you make any changes to the code, you first need
    to commit those in the working repository:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Assuming that you continue to work on the same branch (master), for any subsequent
    push to the central repository, simply execute the following command:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This will update the master branch of the central repository with your changes.
    With this, you are all set to share your code with other developers using the
    central repository. If you want to get changes made by other developers, you can
    use `$ git pull` to fetch those changes and merge them with your working copy.
    We did not discuss the other Git features, such as tagging your code, creating
    branches, resolving conflicts, and so on. It is recommended you read the Git documentation,
    [https://git-scm.com/doc](https://git-scm.com/doc), to better understand these
    concepts.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更新中央仓库的 master 分支以包含你的更改。有了这个，你就可以准备好与其他开发者共享你的代码了。如果你想获取其他开发者所做的更改，可以使用 `$
    git pull` 来获取这些更改并将它们合并到你的工作副本中。我们没有讨论其他 Git 功能，如对代码打标签、创建分支、解决冲突等。建议你阅读 Git 文档，[https://git-scm.com/doc](https://git-scm.com/doc)，以更好地理解这些概念。
- en: Using GUI clients for Git
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Git 的 GUI 客户端
- en: The earlier section exclusively discussed how to use Git from the command line.
    These commands can also be accessed through a **graphical user interface** (**GUI**).
    There are many GUI clients available for Git, for instance, **gitk** on Linux
    ([http://gitk.sourceforge.net/](http://gitk.sourceforge.net/)) or **Github Desktop**,
    available for Mac and Windows 7 or later ([https://desktop.github.com/](https://desktop.github.com/)).
    The free Python IDEs, such as the community edition of PyCharm, provide an easy-to-use
    GUI integration for Git and other version control systems. PyCharm provides a
    context menu integration for Git commands. For example, right-clicking on a file
    in the IDE will give you a context menu option to add or commit the file to a
    repository.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 早期章节专门讨论了如何从命令行使用 Git。这些命令也可以通过图形用户界面（GUI）访问。有许多 Git 的 GUI 客户端可用，例如 Linux 上的
    **gitk** ([http://gitk.sourceforge.net/](http://gitk.sourceforge.net/)) 或适用于 Mac
    和 Windows 7 或更高版本的 **Github Desktop** ([https://desktop.github.com/](https://desktop.github.com/))。免费的
    Python IDE，如 PyCharm 的社区版，为 Git 和其他版本控制系统提供了易于使用的 GUI 集成。PyCharm 为 Git 命令提供了上下文菜单集成。例如，在
    IDE 中右键单击文件将提供一个上下文菜单选项，用于将文件添加或提交到仓库。
- en: Exercise
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: We released the distribution to the PyPI test repository as it was just a toy
    problem. For more serious stuff, you should deploy the package to the PyPI main
    repository, [https://pypi.python.org/pypi](https://pypi.python.org/pypi). As an
    exercise, deploy a package on the main PyPI server. The process is similar to
    what we discussed earlier.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这只是一个小问题，我们将分发版发布到了 PyPI 测试仓库。对于更严肃的内容，你应该将包部署到 PyPI 主仓库，[https://pypi.python.org/pypi](https://pypi.python.org/pypi)。作为一个练习，将包部署到主
    PyPI 服务器。这个过程与我们之前讨论的类似。
- en: Create a new account on the PyPI website. Note that you need to create a separate
    account; the test PyPI account won't work here.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 PyPI 网站上创建一个新账户。请注意，你需要创建一个单独的账户；测试 PyPI 账户在这里不起作用。
- en: 'In the `.pypirc` file, create a new profile to store credentials for the main
    server. See the following illustration for an inspiration:'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `.pypirc` 文件中，创建一个新的配置文件来存储主服务器的凭证。以下插图可以提供灵感：
- en: '[PRE36]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Appropriately, update the `url` field in `setup.py`.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适当地更新 `setup.py` 中的 `url` 字段。
- en: 'Follow the other steps in package creation and release. Remember to specify
    the main repository everywhere, instead of the test repository. For example:'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照包创建和发布的其他步骤进行。请记住，在所有地方指定主仓库，而不是测试仓库。例如：
- en: '[PRE37]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: See what happens if you do not specify the `-r` option Which repository would
    it default to?
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看如果不指定 `-r` 选项会发生什么？它会默认到哪个仓库？
- en: Summary
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to some key aspects of application development in
    general and Python application development in particular. The chapter started
    with an introduction to different versioning conventions. It demonstrated how
    to create Python modules and packages.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了应用开发的一些关键方面，特别是 Python 应用开发。本章从介绍不同的版本控制约定开始。它演示了如何创建 Python 模块和包。
- en: With step-by-step instructions, the chapter demonstrated how to prepare a distribution
    (also called a package), deploy it on the PyPI test server, and install this deployed
    package using pip. Additionally, it also showed you how to make incremental releases
    and set up a private Python distribution. Finally, the chapter provided an overview
    of version control using Git.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 通过逐步说明，本章演示了如何准备一个分发版（也称为包），将其部署到 PyPI 测试服务器，并使用 pip 安装已部署的包。此外，它还展示了如何进行增量发布和设置私有
    Python 分发。最后，本章概述了使用 Git 进行版本控制。
- en: Coding standards are a set of guidelines that you should follow while developing
    the code. Complying with these standards can have a significant impact on the
    code readability and the life of the code. In the next chapter, you will learn
    another important aspect of software development, code documentation, and best
    practices.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 编码规范是一套你在编写代码时应该遵循的指南。遵守这些规范可以对代码的可读性和代码的寿命产生重大影响。在下一章中，你将学习软件开发的重要方面之一，即代码文档和最佳实践。
