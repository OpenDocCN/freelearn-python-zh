- en: '*Chapter 5*: Django Forms'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In programming, a **form** is an object that contains input fields, drop-down
    boxes, radio buttons, checkboxes, and a submit button. The duty of the form is
    to capture information from the user; what is done after that can be anything
    including storing that information in a database, sending an email, or generating
    a reporting document using that data. In this chapter, we discuss as much as we
    can about how forms are used in Django. Form objects are a very complex subject
    to discuss; we only have enough room in this chapter to cover the essentials and
    some advanced topics. Some of the topics in this chapter can be combined with
    other topics covered later in [*Chapter 8*](B17243_08_ePub.xhtml#_idTextAnchor239),
    *Working with the Django REST Framework*, to create form objects on SPA-like pages.
  prefs: []
  type: TYPE_NORMAL
- en: In our first form, we will create a class called `ContactForm` and build an
    email field in three different ways. Later, when we render that form in the browser,
    we will observe how its behavior changes using those three different mechanisms.
    We want to watch how validation is performed on each email field and watch how
    the behavior differs among them. This will give us a better understanding of which
    mechanism is needed for the intended behavior that we wish to achieve as the outcome.
    We will even look into writing custom field classes and learn how they can benefit
    us in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your project's needs, validation of your form may require a lot
    of custom JavaScript in order to accomplish your goals. The focus of this book
    is not on JavaScript but rather on the concepts of Django. However, by the end
    of this chapter, we will have provided an example that demonstrates how JavaScript
    can be blended into your project when working with dynamic inline formsets on
    a form object. You can expand upon this to build your own custom JavaScript functions
    that suit your project's needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Types of forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using form fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleaning forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom form fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with form views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering forms in templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking models to a form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding inline formsets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To work with the code in this chapter, the following tools will need to be
    installed on your local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: Python version 3.9 – used as the underlying programming language for the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django version 4.0 – used as the backend framework of the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pip package manager – used to manage third-party Python/Django packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will continue to work with the solution created in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037),
    *Project Configuration*. However, it is not necessary to use the Visual Studio
    IDE. The main project itself can be run using another IDE or run independently
    using a terminal or command-line window from within the project root folder. This
    is where the `manage.py` file resides. Whatever editor or IDE you are using, a
    virtual environment will also be needed to work with the Django project. Instructions
    for how to create a project and virtual environment can be found in [*Chapter
    2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project Configuration*. You will
    need a database to store the data contained in your project. PostgreSQL was chosen
    for the examples in the previous chapter; however, any database type that you
    choose for your project can be used to work with the examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also be using data that is in the form of a Django fixture, provided
    in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077), *Models, Relations, and
    Inheritance*, in the subsection titled *Loading the Chapter_3 data fixture*. Make
    sure the `chapter_3` fixture is loaded into your database; if this has already
    been done, then you may skip the next command. If you have already created the
    tables found in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077), *Models,
    Relations, and Inheritance*, and have not loaded that fixture yet, then run the
    following command, after activating your virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the code created in this chapter can be found in the GitHub repository
    for this book: [https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer](https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer).
    The bulk of the code depicted in this chapter can be found in the `/becoming_a_django_entdev/becoming_a_django_entdev/chapter_5/`
    directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/3xQQ2H3](https://bit.ly/3xQQ2H3).'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for this chapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start by creating a new app in your project called `chapter_5` by following
    the steps discussed in [*Chapter 2*](B17243_02_ePub.xhtml#_idTextAnchor037), *Project
    Configuration*, in the subsection titled *Creating a Django app*. As discussed
    in that section, don't forget to change the value of the `name =` variable for
    your app class found in the `/becoming_a_django_entdev/becoming_a_django_entdev/chapter_5/apps.py`
    file to now point to the path where you installed your app. Be sure to also include
    this app in your `INSTALLED_APPS` variable found in the `settings.py` file. At
    the end of [*Chapter 4*](B17243_04_ePub.xhtml#_idTextAnchor116), *URLs, Views,
    and Templates*, we set `DEBUG = False` as part of an exercise. Be sure to set
    this back to `DEBUG = True` for the remainder of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main `urls.py` file of the site, add the following path, which points
    to the URL patterns of this chapter that we will be creating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've created the app for this chapter, let's begin using the Django
    admin site to manage the models created in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077),
    *Models, Relations, and Inheritance*.
  prefs: []
  type: TYPE_NORMAL
- en: Types of forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django is designed to simplify a great deal of work involved when handling forms.
    It does this by providing ways to render your form object as HTML and process
    data on form submission. There are a lot of different ways to use and work with
    form objects but they all start with a form class. Django provides two different
    classes for us to use, `ModelForm` and `Form`. The differences between the two
    are that one links directly to the tables in a database and the other does not.
    The `ModelForm` class, the one that links to a database, will automatically create
    fields and perform field validation based on the field constraints set within
    that model class, from the database level.
  prefs: []
  type: TYPE_NORMAL
- en: Form classes also use a `Meta` subclass, as was used on a model class in [*Chapter
    3*](B17243_03_ePub.xhtml#_idTextAnchor077), *Models, Relations, and Inheritance*.
    There are other form classes that Django provides, such as `BaseForm` and `BaseModelForm`,
    which are used to write abstract base form classes, but these form classes are
    beyond the scope of this book. Other classes relate to inline formsets, which
    are basically forms within a form. By the end of this chapter, we will have inserted
    an inline formset onto the page when the form gets rendered and used JavaScript
    to add more of them when the user clicks a button.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss importing and using the `Form` and `ModelForm` classes when creating
    a form class first.
  prefs: []
  type: TYPE_NORMAL
- en: Form class – Form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Form` class is used to create fields that don't link to a database. This
    is used when a form is sending an email or generating a PDF report, just to name
    a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create your `Form` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `forms.py` in your `/becoming_a_django_entdev/chapter_5/`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside this file, include the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will discuss working with fields in a moment, but let's discuss importing
    the `ModelForm` class next.
  prefs: []
  type: TYPE_NORMAL
- en: Form class – ModelForm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ModelForm` class is used when we want to create or modify data directly
    in a database. Each field is linked to a column of the table it represents. Additional
    fields can be created and used in ways that are not linked to your database. For
    instance, you could fire off an email that contains the data from an added field.
    This field could also be a comment, timestamp, or another type of hidden data
    field.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create your `ModelForm` class, inside your existing `/chapter_5/forms.py`
    file, include the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Later in this chapter, we will link this class to the `Vehicle` model, created
    in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077), *Models, Relations, and
    Inheritance*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's remove these `pass` statements and begin working with field arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Using form fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the standard model field classes introduced in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077),
    *Models, Relations, and Inheritance*, Django also provides a number of form field
    classes that are available to use. The difference is that a model field class
    works with the columns of a database and a form field class is used only as an
    input field within an HTML `<form></form>` object in a template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table can be used as a cheat sheet to reference what fields are
    available when writing your `Form` and/or `ModelForm` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Form fields also accept a variety of different field arguments that customize
    the behavior of each field. In the next section, we will use some of the field
    types in the preceding list to write fields on our form classes, discussing the
    different arguments that can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a complete breakdown of each of these field types, visit the official Django
    documentation on field classes and arguments, found here: [https://docs.djangoproject.com/en/4.0/ref/forms/fields/](https://docs.djangoproject.com/en/4.0/ref/forms/fields/).'
  prefs: []
  type: TYPE_NORMAL
- en: Common field arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will begin adding fields to a form class and introduce field arguments in
    this exercise. Field arguments are a way for us to set properties on a field.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create your field, in your `/chapter_5/forms.py` file, add the `import`
    statement highlighted in the following code block, and in the same `ContactForm`
    class, add a field called `full_name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we defined an HTML `<input type="text">` object using
    the `forms.CharField` field class. A `CharField` object's default widget is an
    input `type="text"` field. The `label` argument lets us define the text that would
    render as `<label for="my_field_id">My Form Field Label</label>` of this field.
  prefs: []
  type: TYPE_NORMAL
- en: The `help_text` argument will render a `<span class="helptext">{{ your_help_text_message</span>`
    element, right after your input field in the **Document Object Model** (**DOM**).
  prefs: []
  type: TYPE_NORMAL
- en: Document Object Model
  prefs: []
  type: TYPE_NORMAL
- en: The DOM is an interface found in all browsers that presents HTML in a tree-like
    structure of nodes. The nodes represent objects in this tree, where the `<span>`
    or `<input>` nodes comprise a single object.
  prefs: []
  type: TYPE_NORMAL
- en: The `min_length` and `max_length` arguments are used among most field types;
    they define the minimum and maximum character count, respectively, allowed in
    the field. The `required` argument will define whether the field must contain
    a value in order to be valid. These will render as attributes of an `<input type="text"
    maxlength="300" minlength="2" required="" />` object.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's discuss form validation a little bit more. In the next two subsections,
    we will cover the `widget` and `validator` arguments. For a complete breakdown
    of all the field arguments that are available and not covered, visit [https://docs.djangoproject.com/en/4.0/ref/forms/fields/#core-field-arguments](https://docs.djangoproject.com/en/4.0/ref/forms/fields/#core-field-arguments).
  prefs: []
  type: TYPE_NORMAL
- en: Field widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A field's `widget` argument allows us to define what kind of field to use, such
    as an input object of the date, email, password, or text type. This can also be
    a checkbox, radio button, drop-down select, or text area, to name a few examples.
    We don't have to specify the `widget` argument unless we want to change the default
    widget or override its initial properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the next step to override the `full_name` field to render an input with
    the `id`, `class`, and `placeholder` attributes. The rendered output we hope to
    achieve should look like the following dummy code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In your `/chapter_5/forms.py` file, edit your `full_name` field, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If we changed the default widget of a field from `forms.TextInput` to something
    else, such as `forms.EmailInput`, that would render as `<input type="email">`.
    Changing `forms.TextInput` to `forms.DateInput` would render as `<input type="date">`.
    Using `forms.TextArea` would render as a `<textarea></textarea>` object instead.
    Of course, these are just some of the many different options that exist. For a
    complete breakdown of all the widgets available and how they can help you construct
    your fields, visit [https://docs.djangoproject.com/en/4.0/ref/forms/widgets/](https://docs.djangoproject.com/en/4.0/ref/forms/widgets/).
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss using field validators next.
  prefs: []
  type: TYPE_NORMAL
- en: Field validators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When manually defining widgets, we sometimes have to write specific validation
    rules. For example, let's take a `forms.EmailInput` class; this would require
    adding validation rules that determine whether the value of the string the user
    provided is actually in [example@example.com](mailto:example@example.com) format
    and not some random string, such as `IAmAString`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create and validate an email field:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_5/forms.py` file, in the existing `ContactForm`, add the
    `email_1` field shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While fields can be manipulated using validator arguments in this way, Django
    tries to provide developers with options that minimize or reduce the amount of
    code that they need to write. For example, instead of writing the preceding example
    to enforce an email format on `CharField`, we could just use the `EmailField`
    class instead, which already enforces this rule for us. The `EmailField` class
    includes all of the logic and validation to handle an email field.
  prefs: []
  type: TYPE_NORMAL
- en: 'To practice using the `EmailField` class, we will create an additional field
    to compare and contrast both code approaches. In your `/chapter_5/forms.py` file,
    in the same `ContactForm` class, add the `email_2` field shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The difference between the code found in *step 1* and *step 2* is that we do
    not need to define a widget or validator argument when using an `EmailField` class
    to produce the same behavior as with a `CharField` class. The error message is
    now located in the `error_messages` argument using the `email` key, as shown.
  prefs: []
  type: TYPE_NORMAL
- en: For a complete breakdown of all of the validator classes and methods available,
    visit [https://docs.djangoproject.com/en/4.0/ref/validators/](https://docs.djangoproject.com/en/4.0/ref/validators/).
    Let's practice cleaning forms next, which is just another way to perform validation.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can perform validation on form fields in other ways as well. Within a form
    class, we can write methods that validate each field individually by writing them
    in this format: `def clean_{{ form_field_name }}()`. When doing this, only the
    value of the field that we are cleaning can be accessed. If we want to access
    other field values found in that form, we have to write a single `def clean()`
    method that will allow us to compare two fields against each other. For example,
    we could use the `def clean()` method to only require a field when another field''s
    value is not empty.'
  prefs: []
  type: TYPE_NORMAL
- en: The following two subsections break down these two concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Method – clean_{{ your_field_name }}()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To clean an individual form field, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_5/forms.py` file, in the same `ContactForm` class, add a
    new field called `email_3`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In that same `ContactForm` class, add the `clean_email_3` method shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding example, we are importing the `validate_email()` method from
    the `django.core.validators` library, to determine whether the string is in email
    format. First, we are using a simple conditional statement to check whether the
    field has a value or not; if not, we are issuing an error message stating `"This
    field is required"`. We are performing a validation check even though the `email_3`
    field has a `required` argument set to `False`. This just illustrates another
    way we can do the same thing. If a value exists, we then wrap the `validate_email()`
    method in a *Try/Except* statement, and if validation fails, we are adding the
    `"The following is not a valid email address: {{ field_value }}"` error message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `self.add_error()` method provided in the `Form` and `ModelForm` classes
    accepts two arguments: the first argument is the name of the field and the second
    is your custom error message. Instead of using `self.add_error(''email_3'', ''This
    field is required'')` to add error messages to a form, we can use the `raise ValidationError(''This
    field is required'')` class instead. Except, there''s one problem: using this
    class will remove this field from the `cleaned_data` values list. That will work
    if you only use the `clean_email_3()` method by itself. If you wanted to access
    that same cleaned data within the `def clean()` method, you''d need to return
    the value in `def clean_email_3()`, as depicted in the last line of *step 2* previously.
    Django will fire off the individual clean methods on each field before the `clean()`
    method is executed, saving that as the last method in the stack of cleaning methods.
    If your field value is not returned in the clean method specific to that field,
    we will not be able to access it when we need to later on.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's use the `clean()` method next.
  prefs: []
  type: TYPE_NORMAL
- en: Method – clean()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `clean()` method is used to access all of the field data within a form,
    upon form submission. It is in this method that you could compare against the
    values of many fields before allowing a successful form submission. This next
    example will allow us to compare two fields against each other and raise one or
    more different field validation messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to configure your `clean()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_5/forms.py` file, add another field to your `ContactForm`
    class called `conditional_required`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In that same `ContactForm` class, add the following `clean()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this `clean()` method, we are assigning the value of the `email_3` field
    to the variable called `email`. Then, we are assigning the value of the `conditional_required`
    field to the variable called `text_field`. Using a simple conditional statement,
    we then check to see whether `email` has a value present, and if so, check whether
    `text_field` has a value present. If this condition is met, we then add the required
    error to the `conditional_required` field. Since we set the `conditional_required`
    field to use the `required = False` argument, if there is no value in the `email_3`
    field, this field will not be required.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to creating our own custom form fields next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom form fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, the needs of the project outweigh the options that are provided
    to us. If a field class is not available by default, we have two options: create
    our own or use a third-party package where someone else has already written a
    field class for us.'
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with the same `ContactForm` class, we will demonstrate the differences
    between validation mechanisms by building a `MultipleEmailField`. This will be
    a single field, accepting a single string of emails, all separated by commas.
    Each email item will then be checked independently to see whether it is in a valid
    email string format. We will use the same `validate_email()` function as we did
    before to enforce this constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Field class – Field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Django provides a class called `Field` found in the `django.forms.fields` library,
    used to construct custom field classes. Any of the options and methods found in
    this class can be overwritten as needed. For example, overriding the `def __init__()`
    method will provide a way to add, change, or remove field arguments, completely
    transforming how you work with these fields later on. We won't actually be overriding
    the `__init__()` method for this exercise; instead, we will be working with the
    `to_python()` and `validate()` methods. These will be the only two methods needed
    to perform the validation that we need on `MultipleEmailField`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to write your `Field` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `fields.py` in your `/becoming_a_django_entdev/chapter_5/`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In that file, add the following `MultipleEmailField` class and `import` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you want to use some of the validators provided by Django, use the `default_validators`
    option shown in the preceding code. This is where you will define what validator
    to use. We are using our own logic found in the `validate` method of the `MultipleEmailField`
    class and will not be using a default validator for what we are trying to achieve.
    You are welcome to use any of the validators that Django provides for your field
    classes, found in the `django.core.validators` library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `default_error_messages` option is used to define the default messages
    for a field class. In the `default_error_messages` option shown previously, we
    are specifying two keys: `required` and `email`. These two keys will act as the
    default message used when a required field has been submitted without a value
    present and when a value does not meet the email string format. When specifying
    a default error message in the `default_error_messages` option, we no longer have
    to use the `error_messages = {}` argument of a field. It is still possible to
    use the `error_messages` argument on a field-by-field basis if we wanted to.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In that same `MultipleEmailField` class, add the following `to_python()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `to_python()` method is used to transform values into Python objects. This
    one in particular is written to transform a string into a list of emails, excluding
    the comma.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that same `MultipleEmailField` class, add the following `validate()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `validate()` method checks each item in the list of emails to make sure
    it is in email format. We are also overriding the options provided in the `Field`
    class, such as the `widget` option shown in *step 2*. The default widget is `TextInput`.
    Since that is already what we need, we don't actually have to include it; it was
    provided in the preceding example for illustrative purposes. When writing your
    own custom field, you can replace `TextInput` with any of the Django widgets found
    in the `django.forms.widgets` library. If you want to take your field one step
    further, you could even write your own custom widget class, but this is beyond
    the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Let's work on using our custom field class next.
  prefs: []
  type: TYPE_NORMAL
- en: Using a custom field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the `MultipleEmailField` that we created in the previous subsection,
    in your `/chapter_5/forms.py` file, add the following `import` statement and add
    the `multiple_emails` field to `ContactForm`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we do not need to include any validation messages
    because we have already defined the messages we want in the `MultipleEmailField`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The arguments that are available are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'These are the arguments included within the `__init__()` method of the `Field`
    class in the Django library. If we needed to use arguments such as `min_length`
    and `max_length`, as we did for the `full_name` field, we should have constructed
    the `MultipleEmailField` class using the `CharField` class instead of the `Field`
    class like we did in *step 2* of the subsection titled *Field class – Field* of
    this chapter, as depicted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The reason why we would want to use `CharField` instead of the `Field` class
    is that it extends the `Field` class and adds logic that includes the `min_length`
    and `max_length` arguments. Using this notion, you can extend any other field
    class, making available any of the unique arguments or behaviors of that class
    when writing your own custom class.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's take our contact form and use it with a view class to serve up our
    contact page.
  prefs: []
  type: TYPE_NORMAL
- en: Working with form views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **form view** is just like any other view class, except that a form view class
    is designed to process and handle form objects and form submissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Django offers four main form view classes, listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FormView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UpdateView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeleteView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These can all be found in the `django.views.generic.edit` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to create a view to work with the `ContactForm` class that we created
    earlier, which does not relate to any models, we would use a simple `FormView`
    class. The other three classes can be used with forms that relate to models. They
    each serve a different purpose: to create, update, or delete records in a database.
    For example, `CreateView` will render a form containing blank or default values
    intended to create a record that does not exist yet. `UpdateView` uses a form
    that looks up an existing record, displays the values that exist for that record,
    and allows changes to be made. `DeleteView` will display to the user a prompt
    or confirmation page, asking the user whether they actually want to proceed with
    this task, then delete that record.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's use the `FormView` class to begin building a page that displays the `ContactForm`
    class object. We will be working with `CreateView` and `UpdateView` later in this
    chapter. For a complete breakdown of how to use all of these form view classes,
    visit [https://docs.djangoproject.com/en/4.0/ref/class-based-views/generic-editing/](https://docs.djangoproject.com/en/4.0/ref/class-based-views/generic-editing/).
  prefs: []
  type: TYPE_NORMAL
- en: View class – FormView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by constructing a class called `FormClassView` using Django's `FormView`
    class. This class will have three options that we will define, the first option
    being `template_name`, which is used to define the path of the HTML template that
    we are using. The second option is the `form_class` option, which is used to define
    the name of the form class that this view is going to process, that being the
    `ContactForm` class. The third option is `success_url`, which specifies a relative
    URL path to redirect the user to when the form is successfully submitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to configure your `FormClassView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have a file called `views.py` in your `/becoming_a_django_entdev/chapter_5/`
    folder. This is usually created automatically for you when a new Django app is
    created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In that same file, add the code shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Any of these options can use a callable to gain those values, such as the use
    of the `reverse()` function to specify `success_url`. An example of how this can
    be done is depicted here, but this is not part of the actual exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: We won't actually need the callable shown here to formulate the success URL.
    All we need is the string representation of `'/chapter_5/contact-form-success/'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, configure the URL pattern for `http://localhost:8000/chapter-5/form-class/`.
    If this file was not automatically created for you, create the `/chapter_5/urls.py`
    file and add the following form page pattern and `import` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In that same file, add the following success pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this step, we added a second pattern to serve as the success page at `http://localhost:8000/chapter-5/contact-form-success/`.
    This success page will be used for all exercises in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a view class to work with and some basic options defined, let's
    explore what it takes to work with the different request methods.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP request methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Working with the `FormView` class in Django, there are two HTTP request methods:
    the `GET` and `POST` methods. The `GET` method is intended to render a form with
    blank or default values onto a page and wait for the user to fill out the form
    and submit it. Once the form has been submitted, the `POST` method will be executed.'
  prefs: []
  type: TYPE_NORMAL
- en: GET
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `get()` method is just like any other GET method for a view class. It is
    the go-to method when the page first gets loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to configure your `FormClassView` class''s `get()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `/chapter_5/views.py` file, add the `get()` method to your existing
    `FormClassView` class using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding `get()` method, we are returning an HTTP response in the form
    of a `TemplateResponse` class, using the value of `self.template_name` as the
    path to the template location. We are providing that template with context unique
    to this page, such as the `title`, `page_id`, `page_class`, `h1_tag`, and `form`
    variables that are depicted in the preceding code block. The value of `self.form_class`
    is used to pass the form object into the template. Initial values can be defined
    on form fields when the page first gets loaded, which is when the form is initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `initial` list to your existing `get()` method of the `FormClassView`
    class and pass it into your return context, as highlighted in the following code
    block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this `get()` method, we added the `initial` variable as a list and then passed
    that list into the `self.form_class(initial)` object, which lets us set the initial
    value on fields, defining field names as the keys shown previously with their
    corresponding values.
  prefs: []
  type: TYPE_NORMAL
- en: POST
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `post()` method is used to render the same page when a form has been submitted.
    In this method, we can determine whether the form is valid and if so, we want
    to redirect it to a success URL. If the form is not valid, the page will reload
    with the values that the user entered into the fields and display any error messages
    that may exist. We can also alter or add to the context of a page using a `post()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_5/views.py` file, in the same `FormClassView` class, add
    the `post()` method shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `TemplateResponse` return statement, the highlighted text where the
    context is written represents the context that has changed from the `get()` method
    to the `post()` method. In order to preserve the data that the user has entered
    into the form, `request.POST` must be passed into the form class, where `self.form_class(request.POST)`
    is highlighted in the preceding step. If we didn't pass `request.POST` into `self.form_class()`,
    then we would have rendered a blank form, as if we were using the `get()` method,
    upon first visiting this page.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our view class written, we can work on the template that will
    render our form next.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering forms in templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django offers five main ways to easily and quickly render a form object onto
    a page. The first three are to render a form using a paragraph, table, or list
    structure. The other two include the traditional way of rendering a form, which
    is based on the template in the `django.forms.templates.django.forms` library
    called `default.html`, and then a way to render your own template. New to Django
    4.0 is the `template_name` option on all form classes. This option allows you
    to point to a template file where you can structure your own HTML formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to render your form objects:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `base_template_1.html` file that was created in [*Chapter 4*](B17243_04_ePub.xhtml#_idTextAnchor116),
    *URLs, Views, and Templates*, into your `/becoming_a_django_entdev/chapter_5/templates/chapter_5/base/`
    folder. Copy all related partial template files that are added as `{% include
    %}` statements into that file as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That `base_template_1.html` file will be repurposed as the base template for
    this chapter's exercise. Adjust any paths to point to the new `chapter_5` folder,
    such as any CSS and JavaScript file paths.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy all related CSS, JavaScript, and HTML files into your `chapter_5` app as
    well. These are not required to complete this exercise but will prevent 404 errors
    in your console logs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file called `form-class.html` inside your `/becoming_a_django_entdev/chapter_5/templates/chapter_5/`
    folder and include the tags we can see in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside your `/chapter_5/form-class.html` file, add the following code inside
    the `body_content` block, to render a form in the simplest way possible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we need to at least write the `<form>` element and define an attribute
    of `method="post"` telling the browser how to handle a form submission. The `{{
    form }}` tag renders any fields that exist for this form, using the `django.forms.templates.django.forms.default.html`
    library template. `{% csrf_token %}` is a cross-site request forgery token that
    is used for security measures and is required on all Django forms. `<input type="submit">`
    specifies the button that is used to trigger the form's submit action.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive into the remaining four mechanisms and how they are used.
  prefs: []
  type: TYPE_NORMAL
- en: Render form – as_p
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This option will render each field wrapped in a paragraph, `<p></p>`, element.
    The label will be stacked above the input field with the help text below it. If
    errors are present, each field will have its own list object rendered above the
    paragraph objects, listing all the errors relating to that field.
  prefs: []
  type: TYPE_NORMAL
- en: To render your form with `as_p`, in your `/chapter_5/form-class.html` file,
    change the `{{ form }}` tag to `{{ form.as_p }}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This should render each field to look like the demo code depicted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Let's render the form formatted as a table next.
  prefs: []
  type: TYPE_NORMAL
- en: Render form – as_table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This option takes each field and wraps it in a `<tr></tr>` element. The label
    of this field is wrapped in a `<th></th>` element and the field itself is wrapped
    in a `<td></td>` element. The label will be stacked to the left with the input
    object and help text and error message displayed to the right, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Render form – as_table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.1_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Render form – as_table
  prefs: []
  type: TYPE_NORMAL
- en: To use this option, we still have to wrap the form tag in a `<table></table>`
    element because only the inner contents of a table are rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'To render your form as a table, in your `/chapter_5/form-class.html` file,
    change your `{{ form }}` tag to `{{ form.as_table }}` and wrap it in the `<table>`
    tag, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Let's render the form formatted as a list next.
  prefs: []
  type: TYPE_NORMAL
- en: Render form – as_ul
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This option will render your form as a list with each field wrapped in a `<li></li>`
    element. Inside that element, the label will come first, then the input field,
    and the help text last. If an error occurs, it gets injected as its own list item
    above that field, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Render form – As a list'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.2_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Render form – As a list
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have to wrap the form in an element with the `<ul></ul>` list element.
    To render your form as a list, in your `/chapter_5/form-class.html` file, change
    the `{{ form }}` tag to `{{ form.as_ul }}` and wrap it in the `<ul>` tag, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Let's use a new approach that was introduced in Django 4.0 next.
  prefs: []
  type: TYPE_NORMAL
- en: Render form – using template_name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New to Django 4.0 is the `template_name` feature. This feature is used to render
    a form in the style written within a custom template. It gives developers the
    ability to structure their own HTML when fields are rendered. Developers can create
    many different template styles and use them as needed. Fields are accessed via
    the `{{ fields }}` tag inside that custom template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to configure your custom form template:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_5/forms.py` file, add the `template_name` option to the existing
    `ContactForm` class, as highlighted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, create the `custom-form.html` file in your `/chapter_5/templates/chapter_5/forms/`
    folder. We will not be adding an `{% extends %}` tag to this file; instead, we
    will treat it as if we are using an `{% include %}` tag, where it is just a snippet
    and not an entire page of HTML.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside your `/chapter_5/custom-forms.html` file, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are looping through all of the fields with the `{% for field, errors
    in fields %}` tag shown in the preceding code block. We've added our own HTML
    structure using the `<div>`, `<label>`, and `<span>` elements. The field itself
    is rendered using the `{{ field }}` tag. Other information, such as the help text,
    is used in conjunction with the `safe` filter in `{{ field.help_text|safe }}`.
    The `safe` filter is used to make sure that any HTML contained in the string gets
    rendered as HTML objects and not printed as the string representation of that
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Let's demonstrate all of these form renderings in action next.
  prefs: []
  type: TYPE_NORMAL
- en: Render demo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By now, we should have a working form. In your browser, visit the URL `http://localhost:8000/chapter-5/form-class/`,
    and you should see your form rendered onto the page. Through all of the examples
    provided using the `ContactForm` class, we should see six fields on this page.
    Here, we can see how an email field can behave differently as we interact with
    the form. For example, if we set the required argument in the `email_1` field
    to equal `False`, we can submit the form with nothing entered into this field
    and it will succeed. In the field named `email_2`, we specified the `required`
    argument as equal to `True`. This added the `required` attribute to that input
    field, preventing the user from submitting that form. This means the user will
    never see the error message that we provided in the Django code. This route would
    require the use of JavaScript, such as the jQuery Validate library, to handle
    the error state and display an error message for us. Doing nothing would result
    in the browser handling the error state for us, and in Chrome, that would look
    as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – ContactForm email_2 field'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.3_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – ContactForm email_2 field
  prefs: []
  type: TYPE_NORMAL
- en: 'However, on the field named `email_3`, we set the required argument to equal
    `False`, and in the clean method, we are performing the validation that checks
    whether the field has a value or not. This lets us submit the form and see the
    error message that was provided on postback, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – ContactForm email_3 field'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.4_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – ContactForm email_3 field
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's take Django forms a step further and start working with the models
    in a form class. We created a placeholder class for this, called `VehicleForm`,
    in the section titled *Form class – ModelForm*.
  prefs: []
  type: TYPE_NORMAL
- en: Linking a model to a form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linking a model to a form without needing any special field rendering is fairly
    easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_5/forms.py` file, add the following code to the existing
    `VehicleForm` class (remember to remove the `pass` statement that was added to
    this class earlier):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we don't have to create fields for this form. Django
    will automatically use the form field type associated with the model field type
    that we wrote for the `Vehicle` model, created in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077),
    *Models, Relations, and Inheritance*. If any field behavior needed modifying,
    we would write form fields the same way we did for `ContactForm` and then customize
    them as we see fit. The `Meta` subclass used here defines what model class we
    are using and the `fields` option specifies what fields of that model we want
    to include and in what order they should be included.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Using `fields = '__all__'` will include all fields that exist for that model
    in the order that they were written for that model.
  prefs: []
  type: TYPE_NORMAL
- en: Let's work with the `CreateView` class next.
  prefs: []
  type: TYPE_NORMAL
- en: View class – CreateView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the `VehicleForm` class that we now have wired up to the `Vehicle` model,
    let's create a view that will render a form with no or default field values using
    the `CreateView` class. It will let us create a new vehicle record in the database
    when that form is successfully submitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to configure your `CreateView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_5/views.py` file, add the following `import` statements and
    create the `ModelFormClassCreateView` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In that same `ModelFormClassCreateView` class, add the following `get()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In that same `ModelFormClassCreateView` class, add the following `post()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, we gave this class the same two methods that we used earlier—`get()`
    and `post()`. These two methods work the same way as when used in a class constructed
    with the `FormView` class. In the `get()` method, we are passing just a blank
    form into the template as context using `self.form_class()`. In the `post()` method,
    we are once again passing `request` into the form to get the data that was submitted
    by the user, using `form = self.form_class(request.POST)`. In that `post()` method,
    validation is performed using `if form.is_valid():` and it will either redirect
    to a success page or refresh, serving up the form with the correct error messages.
    If the form is validated successfully, just before we perform the redirect, we
    are saving the form using `vehicle.save()`, the same way we did when we added
    data using the Django shell in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077),
    *Models, Relations, and Inheritance*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a URL pattern using the `ModelFormClassCreateView` class, add the following
    path to your `/chapter_5/urls.py` file, and include the following `import` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In that same `/chapter_5/urls.py` file, add the following success URL pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We added the success URL pattern for a vehicle form at `http://localhost:8000/chapter-5/vehicle-form-success/`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, construct your `/chapter_5/model-form-class.html` file the same way that
    we created the `/chapter_5/form-class.html` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, visit the URL `http://localhost:8000/chapter-5/model-form-class/`, and
    if you are rendering your form using the standard `{{ form }}` tag, you should
    see the page looking as in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.5 – VehicleForm using ModelFormClassCreateView'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.5_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – VehicleForm using ModelFormClassCreateView
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this example is in its simplest form. If you wanted to use another
    format or a template of your own, you would follow the steps under the *Rendering
    forms in templates* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: View class – UpdateView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we need to create a URL pattern using a path converter to capture
    the ID of the vehicle record that is being looked up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to configure your `UpdateView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_5/urls.py` file, add the path shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This pattern will allow us to access a `Vehicle` record by ID, also known as
    a primary key, in a database. We specify the ID of the `Vehicle` that we want
    to look up in the URL itself, as in `http://localhost:8000/chapter-5/model-form-class/2/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_5/views.py` file, add the `ModelFormClassUpdateView` class
    and `import` statements shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In that same `ModelFormClassUpdateView` class, add the `get()` and `post()`
    methods shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, navigate to the URL `http://localhost:8000/chapter-5/model-form-class/2/`,
    and you should see the form preloaded with the values found in the database for
    that Vehicle, as depicted in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.6 – VehicleForm using ModelFormClassUpdateView'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.6_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – VehicleForm using ModelFormClassUpdateView
  prefs: []
  type: TYPE_NORMAL
- en: We once again use the same two `get()` and `post()` methods. One minor difference
    in how we are writing the `get()` method here is that we are performing the `Vehicle`
    query. We use a `try/except` statement to determine whether the object exists
    in the database using `vehicle = Vehicle.objects.get(pk=id)`. If it does not exist,
    we create the form object as a blank form using `form = self.form_class()`. If
    the `Vehicle` object is found, then we pass that instance into the form that we
    are initializing, using `form = self.form_class(instance=vehicle)`. The `post()`
    method is written the same as what we wrote for `ModelFormClassCreateView`, except
    that we updated the context string variables to reflect this class name.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When working with fields that have an attribute of `unique = True` and saving
    that object in a form using the `UpdateView` class, you may get a postback error
    message telling you that the object already exists. To get around this, try removing
    the `unique` attribute on your model and implementing your own `clean()` method
    to enforce that uniqueness. There are also several other approaches to solve this
    while keeping the `unique` attribute; all are rather difficult to implement and
    go beyond the scope of this chapter. Practice building a form to update the `Engine`
    class on your own that does not contain a `unique` field.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add inline formsets next.
  prefs: []
  type: TYPE_NORMAL
- en: Adding inline formsets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An inline formset is a form within a form. It's a way to provide dynamic fields,
    for example, for additional personnel, comments, or objects. They are commonly
    used in combination with JavaScript code on the frontend to create or remove sets
    of fields as desired by the user. In the next exercise, we will expand upon the
    `ModelFormClassCreateView` class to add our inline formset. This formset will
    capture prospective buyer information, to capture the first and last name of that
    lead. We will create an **Add Another** button for the user to add as many prospective
    buyers as they would like to. JavaScript is used to control creating and/or deleting
    the new DOM objects. It will also update the Django management form data in the
    process. You can build upon this concept to make your form more robust with added
    fields and controls for the user to manipulate inline formsets.
  prefs: []
  type: TYPE_NORMAL
- en: Follow the steps in the following sections to get started with inline formsets.
  prefs: []
  type: TYPE_NORMAL
- en: Formset function – formset_factory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **formset factory** is a controller that we use to register inline formsets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create your formset factory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `/chapter_5/forms.py` file, add the following `ProspectiveBuyerForm`
    class, which will act as the inline form, capturing the first and last name of
    the prospective buyer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are doing nothing different in the `ProspectiveBuyerForm` class in the preceding
    code compared to what we did in `ContactForm` before. The same concepts and validation
    measures apply to the fields within an inline formset. Adjust the logic as necessary
    for your fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same `/chapter_5/forms.py` file, register that form as `formset_factory`
    using the following example. Make sure to place the `ProspectiveBuyerFormSet`
    class below the `ProspectiveBuyerForm` class in this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding example, we registered the `ProspectiveBuyerForm` class in
    a formset factory called `ProspectiveBuyerFormset`, which we will use next in
    our view class. The `extra = 1` argument is used to include only one instance
    of this formset when this `formset_factory` is first initialized. There are many
    other options available, and they are all explained in detail here: [https://docs.djangoproject.com/en/4.0/topics/forms/formsets/](https://docs.djangoproject.com/en/4.0/topics/forms/formsets/).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are using a standard `formset_factory` for a form with fields
    that are not linked to a model. Formsets that do link to models would use the
    `modelformset_factory()` method to link form fields to a model in your database.
    When using that method, data is saved in the view class the same way as when we
    saved the `VehicleForm` data.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use this inline formset in a view class next.
  prefs: []
  type: TYPE_NORMAL
- en: Using inline formsets in the view class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to use your newly created inline formset in a view class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_5/views.py` file, in the existing `ModelFormClassCreateView`
    class, add a few minor adjustments to the existing `get()` method, as highlighted
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same `ModelFormClassCreateView` class, add a few minor adjustments to
    the existing `post()` method, as highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding steps, we are passing the inline `ProspectiveBuyerFormset`
    formset into the template as an additional context variable called `buyer_formset`.
    This and the form object should always be thought of as entirely separate objects.
    The form and the formset can also be related if they are using `ForeignKey`, `ManyToMany`,
    or `OneToOne` model relations.
  prefs: []
  type: TYPE_NORMAL
- en: Let's render these inline formsets into a template next.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering inline formsets in the template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To render your newly created inline formsets into a template file, in your
    `/chapter_5/model-form-class.html` file, include all of the nodes, class names,
    and IDs that exist, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: The JavaScript we will soon write will depend on this structure, and as your
    structure changes, be sure to change your JavaScript as well. In the preceding
    code, the important parts of the form include the ID attribute of the form itself,
    called `id="form"`. We will use that to target the form as a whole in the JavaScript
    we are going to write. A conditional is used to check whether the `buyer_formset`
    variable exists before we do anything with it. For example, if you wanted to serve
    up an instance of this page that has no formsets at all, then this conditional
    will prevent breakage.
  prefs: []
  type: TYPE_NORMAL
- en: An important feature to never forget to include is the management form data,
    which is added using the `{{ buyer_formset.management_form }}` tag. This will
    include important data that Django needs to process your inline formsets. We then
    loop through each form in the `buyer_formset` object using `{% for form in buyer_formset
    %}`. For each form that does exist, we wrap all of the internal HTML in a node
    called `<div class="formset-container"></div>`. This class is important as it
    will differentiate between each inline form when we work with JavaScript. Inside,
    you can structure your fields however you like. Lastly, outside of the loop, just
    before the submit button, we need to add a new `<button>` of `type="button"` to
    prevent accidentally submitting the form. Give that button an attribute of `id="add-formset"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, visit the same URL that we went to before, to add a new vehicle at `http://localhost:8000/chapter-5/model-form-class/`.
    You should see a form resembling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – VehicleForm inline formset'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.7_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – VehicleForm inline formset
  prefs: []
  type: TYPE_NORMAL
- en: There will only be one instance of the prospective buyer for now. Next, we will
    add the JavaScript controls that let us add more instances to this form.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic inline formsets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to configure the JavaScript needed to let the user add more
    instances of an inline formset:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `/chapter_5/base/base_template_1.html` file, there is already a reference
    to a JavaScript file in the `<head>` of that document. Make sure the following
    script is included in your `<head>` of that document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will load a single JavaScript file that is used to make a form interactive
    and lets the user add another instance of the inline `ProspectiveBuyerFormset`
    formset.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you didn''t already copy the JavaScript files when copying the `base_template_1.html`
    file earlier in preparation for a previous exercise, then go ahead and create
    the `/chapter_5/static/chapter_5/` and `/chapter_5/static/chapter_5/js/` folders
    and the `site-js.js` file using your IDE, File Explorer, or the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside your `/chapter_5/js/site-js.js` file, include the following variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following event listener to that same JavaScript file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following function to that same JavaScript file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What we are doing is adding an event listener that listens for the click event
    of the `<div class="formset-container"></div>` and insert that cloned node just
    before the `<button id="add-formset"></button>` node. Since Django also requires
    the precise management of form data, we need to be sure that we update the relevant
    data every time an inline formset is added or removed. This is why we are finding
    the number of inline formsets that exist before we perform the clone action as
    the `formsetNum` variable. Then, we increment this number, which starts at index
    0, using a regular expression method to search all the inner HTML nodes of the
    node with the `formset-container` CSS class. That incremented number is used to
    update all node attributes to the proper index of the new node that we inserted.
    We also update the value of the form object with `id="id_form-TOTAL_FORMS"` to
    the new total of inline formsets that exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'If successful, when we click the **Add Another Prospective Buyer** button,
    we should see additional inline formsets added, just like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – VehicleForm adding another inline formset'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.8_B17243.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.8 – VehicleForm adding another inline formset
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, we have completed two major forms, one to act as the contact form and
    another to handle the vehicle object, created in [*Chapter 3*](B17243_03_ePub.xhtml#_idTextAnchor077),
    *Models, Relations, and Inheritance*. We added a variety of fields and discussed
    the differences between those field types. Using the email example over and over
    again as we did, we witnessed how validation works in many different ways. Depending
    on the requirements gathered for a project, we can then decide on several different
    writing patterns to align with those requirements. For example, if we wanted to
    completely eliminate the need for JavaScript validation, such as using my favorite
    library jQuery Validate, we could just write clean methods in form classes to
    perform all of the validation on the backend. This would use the power of Django
    to serve up the error messages. However, if we did use JavaScript-based validation
    on the frontend, we could write fields that create the node attributes for us,
    such as the `<input>` field attribute of `required=""`, which would prevent a
    form from submitting if it had no value.
  prefs: []
  type: TYPE_NORMAL
- en: No matter the requirements of a project, we also discovered a really easy way
    to create our own field classes. Custom field classes let us preformat fields
    that support a **Don't Repeat Yourself** (**DRY**) style of writing. We explored
    the differences in view classes, form classes, and field classes, and then discussed
    ways to render those forms in a template.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore a user interface specifically tailored
    for the rapid development of forms that lets users update, create, and delete
    model objects on their own. This is called the Django admin site, which is basically
    a glorified way to render forms related to model management.
  prefs: []
  type: TYPE_NORMAL
