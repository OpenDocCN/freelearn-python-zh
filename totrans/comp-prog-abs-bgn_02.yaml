- en: '*Chapter 1*: Introduction to Computer Programs'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：计算机程序简介'
- en: Programming is the art and science of writing instructions that a computer can
    follow to accomplish a task. This task can be playing a game, performing a calculation,
    or browsing the web, for example. However, before we can learn how to write programs,
    we should understand what a program is and how a computer can understand and execute
    the instructions we give it. In this chapter, we will study this in more detail,
    along with the basics of what a computer is, how it works, and its history.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编程是编写计算机可以遵循以完成任务的艺术和科学。这项任务可以是玩游戏、执行计算或浏览网页，例如。然而，在我们学习如何编写程序之前，我们应该了解什么是程序，以及计算机如何理解并执行我们给出的指令。在本章中，我们将更详细地研究这一点，以及计算机的基本知识、工作原理及其历史。
- en: Even a basic level of understanding of these topics will help us later on when
    we discuss the different aspects of writing programs, as we can then relate to
    how the computer will treat the code we write.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对这些主题有基本的理解，也会在以后我们讨论编写程序的不同方面时有所帮助，因为那时我们可以将计算机如何处理我们编写的代码联系起来。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: A perspective on the history and origins of the computer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对计算机的历史和起源的视角
- en: Background knowledge of the original ideas behind programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程背后原始想法的背景知识
- en: Understanding what a computer program is
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解什么是计算机程序
- en: Learning how a computer program works
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习计算机程序的工作原理
- en: An understanding of what machine code is
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解什么是机器码
- en: A brief history of computing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算机简史
- en: 'Humans have always built tools and made innovations to make life more comfortable
    and to allow us to do more things faster and more efficiently. We need to go back
    in time a few hundred years in order to see the first attempts at building a tool
    that could resemble a computer. However, before we do that, we might want to define
    what a computer is. Wikipedia offers the following definition:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 人类一直都在制造工具和进行创新，以使生活更加舒适，并使我们能够更快、更有效地做更多的事情。我们需要回顾几百年前，才能看到第一个试图建造类似计算机的工具的尝试。然而，在我们这样做之前，我们可能想要定义什么是计算机。维基百科提供了以下定义：
- en: A computer is a machine that can be instructed to carry out sequences of arithmetic
    or logical operations automatically via computer programming.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机是一种可以通过计算机编程自动执行一系列算术或逻辑运算的机器。
- en: So, a computer is a programmable machine that performs arithmetic or logical
    operations. Let's review a few inventions from the past using this definition
    to ascertain which of them could be considered a computer.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，计算机是一种可编程的机器，它执行算术或逻辑运算。让我们回顾一下过去的几项发明，使用这个定义来确定哪些可以被认为是计算机。
- en: To begin, we can rule out the Jacquard machine, which was the automated loom
    invented in the early years of the 19th century. These looms could be programmed
    using punch cards, but they produced woven silk, which, of course, is not the
    result of an arithmetic or logical operation. Programmability, using punch cards,
    was an idea that survived well into the computer age, but these looms were not
    computers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以排除雅克德罗机，这是一种在19世纪初发明的自动化织布机。这些织布机可以使用穿孔卡片编程，但它们生产的是丝绸，当然，这不是算术或逻辑运算的结果。使用穿孔卡片进行可编程性的想法在计算机时代一直存在，但这些织布机不是计算机。
- en: If we go even further back in time, we find devices such as the abacus that
    helped us to get the results of arithmetic operations; however, they were not
    programmable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再往回追溯时间，我们会发现像算盘这样的工具帮助我们得到算术运算的结果；然而，它们是不可编程的。
- en: 'In the 1770s, Pierre Jaquet-Droz, a Swiss watchmaker, created some mechanical
    dolls that he called automata. These dolls could read instructions and could thereby
    be considered programmable, but they did not perform arithmetic or logical operations.
    Instead, he created one doll that could play music, one that could make drawings,
    and one that could write letters (they are referred to as the musician, the draughtsman,
    and the writer):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在1770年代，瑞士钟表匠皮埃尔·雅克·德罗兹（Pierre Jaquet-Droz）创造了一些他称之为自动机的机械娃娃。这些娃娃能够读取指令，因此可以被认为是可编程的，但它们不执行算术或逻辑运算。相反，他创造了一个能演奏音乐的娃娃，一个能画画的娃娃，以及一个能写字的娃娃（它们被称为音乐家、绘图家和作家）：
- en: '![Figure 1.1: The Jaquet-Droz automata (photograph by Rama, Wikimedia Commons;
    Cc-by-sa-2.0-fr)](img/B15554_01_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1：Jaquet-Droz自动机（Rama拍摄，维基媒体共享；Cc-by-sa-2.0-fr）](img/B15554_01_01.jpg)'
- en: 'Figure 1.1: The Jaquet-Droz automata (photograph by Rama, Wikimedia Commons;
    Cc-by-sa-2.0-fr)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：Jaquet-Droz自动机（Rama拍摄，维基媒体共享；Cc-by-sa-2.0-fr）
- en: In order to see something that resembles a computer, we will need to look at
    Charles Babbage's inventions. He originated the concept of a programmable computer
    with his ideas for a machine, called the Difference Engine, and later, a more
    advanced version called the Analytical Engine. Of the two, the Analytical Engine
    was particularly groundbreaking as it could be programmable, which meant it could
    be used to solve different problems. He presented his work in the first half of
    the 19th century, and even if the machines were never completed, we can agree
    that Babbage is a very important person behind the basic concept of the programmable
    computer.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到类似计算机的东西，我们需要看看查尔斯·巴贝奇的发明。他通过为一种称为差分机的机器的想法，以及后来称为分析机的更高级版本，提出了可编程计算机的概念。在这两个中，分析机尤其具有开创性，因为它可以编程，这意味着它可以用来解决不同的问题。他在19世纪上半叶展示了他的工作，即使这些机器从未完成，我们也可以同意巴贝奇是可编程计算机基本概念背后的一个非常重要的人物。
- en: During the first half of the 20th century, we witnessed some analog computers,
    but it was not until the second world war, and the years following, that we saw
    the birth of real digital computers. The difference between an analog and a digital
    computer is that the former is a mechanical machine that works with an analog
    input such as voltage, temperature, or pressure. In comparison, a digital computer
    works with input that can be represented by numbers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪上半叶，我们见证了某些模拟计算机，但直到第二次世界大战以及随后的年份，我们才看到了真正的数字计算机的诞生。模拟计算机和数字计算机之间的区别在于，前者是一种使用模拟输入（如电压、温度或压力）的机械机器。相比之下，数字计算机使用的是可以用数字表示的输入。
- en: 'Many people consider the **Electronic Numerical Integrator and Computer** (**ENIAC**),
    constructed by J. Presper Eckert and John Mauchly between 1943 and 1946, as the
    first digital computer because it was the first one that was both completed and
    fully functional:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人认为，由J. Presper Eckert和John Mauchly于1943年至1946年之间构建的**电子数值积分计算机**（**ENIAC**）是第一台数字计算机，因为它是最先完成且完全功能性的：
- en: '![Figure 1.2: Betty Jean Jennings and Fran Bilas, both programmers, operate
    ENIAC''s main control panel – U. S. Army Photo (Public Domain [PD])](img/B15554_01_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2：Betty Jean Jennings和Fran Bilas，两位程序员，操作ENIAC的主控制面板 – 美国陆军照片（公有领域 [PD]）](img/B15554_01_02.jpg)'
- en: 'Figure 1.2: Betty Jean Jennings and Fran Bilas, both programmers, operate ENIAC''s
    main control panel – U.S. Army Photo (Public Domain [PD])'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：Betty Jean Jennings和Fran Bilas，两位程序员，操作ENIAC的主控制面板 – 美国陆军照片（公有领域 [PD]）
- en: Since then, we have seen tremendous development up until the point we are at
    today. However, even though our modern computers can do so much more and at a
    much faster rate than these earlier inventions, the basic principles of how they
    operate remain the same.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，我们见证了直到今天为止的巨大发展。然而，尽管我们的现代计算机可以做得更多，并且速度比这些早期发明快得多，但它们运作的基本原理仍然相同。
- en: A brief history of programming
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程简史
- en: A programmable computer needs to be, well, programmed. So, of course, the history
    of programming goes hand in hand with the evolution of computers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可编程计算机需要被编程。因此，当然，编程的历史与计算机的演变是紧密相连的。
- en: 'In 1833, Charles Babbage met Ada Lovelace, daughter of poet Lord Byron. She
    became very impressed and interested in Babbage''s plans for his programmable
    machines, and their collaboration began. Among other things, she wrote some notes
    outlining her ideas for how the Babbage Analytical Engine could be programmed.
    We can call her the inventor of programming, even if we had to wait over 100 years
    until we had the machine that could make her ideas come true. Her status today
    is summarized in a *History Extra* article, from 2017, by James Essinger:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 1833年，查尔斯·巴贝奇遇到了诗人拜伦勋爵的女儿Ada Lovelace。她对巴贝奇的可编程机器计划印象深刻，并产生了浓厚的兴趣，他们的合作就此开始。除了其他事情外，她还写了一些笔记，概述了她关于如何编程巴贝加分析机的想法。我们可以称她为编程的发明者，即使我们不得不等待超过100年，直到我们有了能够实现她想法的机器。她今天的地位在2017年James
    Essinger的*历史额外*文章中得到了总结：
- en: Today, Ada is quite rightly seen as an icon of feminist scientific achievement,
    a heroine of the mind, and one of the earliest visionaries in the early history
    of the computer.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Ada完全正确地被视为女性科学成就的象征，一个思想英雄，以及计算机早期历史中最早的先知之一。
- en: 'In her notes, Lovelace did a couple of remarkable things. The first was that
    she wrote an algorithm for how Bernoulli numbers, a sequence of rational numbers
    often used in number theory, could be calculated by the Analytical Engine. This
    algorithm is considered by many to be the first computer program. Second, she
    outlined the future of what these machines could do, and, in her vision, she saw
    that they could be used to draw pictures and compose music. The fact is that when
    we finally could build a computer, the way they were programmed was heavily influenced
    by her ideas:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在她的笔记中，洛芙莱斯做了几件引人注目的事情。首先，她写了一个算法，说明了如何通过分析引擎计算伯努利数，这是一个在数论中经常使用的有理数序列。这个算法被许多人认为是第一个计算机程序。其次，她概述了这些机器未来的用途，在她的设想中，她看到它们可以用来绘制图片和创作音乐。事实上，当我们最终能够建造计算机时，它们的编程方式受到了她的想法的极大影响：
- en: '![Figure 1.3: Ada Lovelace, aged 17 (portrait by Joan Baum; PD-Art)](img/B15554_01_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3：17岁的阿达·洛芙莱斯（Joan Baum的肖像；PD-Art）](img/B15554_01_03.jpg)'
- en: 'Figure 1.3: Ada Lovelace, aged 17 (portrait by Joan Baum; PD-Art)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：17岁的阿达·洛芙莱斯（Joan Baum的肖像；PD-Art）
- en: The first digital computers were programmed using machine code – the only thing
    a computer understands. Later in this chapter, we will talk more about machine
    code and explore what it is. And, as you will discover, it is just a sequence
    of numbers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一台数字计算机使用机器码进行编程——这是计算机唯一能理解的东西。在本章的后面部分，我们将更多地讨论机器码，并探讨它是什么。你会发现，它只是一串数字的序列。
- en: In 1949, John Mauchly proposed something called Brief Code, which was later
    renamed to Short Code. Short Code can be considered to be one of the first higher-level
    programming languages. A higher-level programming language is a way for us to
    write instructions to the computer in a way that is more understandable to humans,
    which is better than a machine code. The Short Code program is then translated
    into machine code, and it is that code that the computer executes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 1949年，约翰·莫奇利提出了一个名为Brief Code的东西，后来被更名为Short Code。Short Code可以被认为是第一种高级编程语言之一。高级编程语言是我们用更易于人类理解的方式向计算机发出指令的方法，这比机器码要好。然后，Short
    Code程序被翻译成机器码，而计算机执行的就是这种代码。
- en: In 1954, the language Fortran was invented at IBM, by John Backus, and this
    can be considered to be the first widely used high-level, general-purpose programming
    language. Fortran is, in fact, still in use.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 1954年，在IBM，由约翰·巴科斯发明了Fortran语言，这可以被认为是第一个广泛使用的高级通用编程语言。实际上，Fortran仍然在使用中。
- en: The 1950s saw the birth of some other languages that have also survived, such
    as Lisp and COBOL. Since then, we have had over 2,300 new programming languages.
    In the next chapter, we will look at how programming languages have evolved and
    how they are related, but also why people keep inventing new ones.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 20世纪50年代见证了其他一些语言的诞生，这些语言也得以幸存，例如Lisp和COBOL。从那时起，我们已经有了超过2,300种新的编程语言。在下一章中，我们将探讨编程语言的演变及其相互关系，但也会探讨为什么人们不断发明新的编程语言。
- en: What is a program?
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序是什么？
- en: A computer is dumb in the sense that, without programs, it can't do anything.
    A computer program is a set of instructions that the computer can execute, and
    it is our job, as programmers, to write these programs using one or more programming
    languages.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，计算机是愚蠢的，因为没有程序，它什么也不能做。计算机程序是一组计算机可以执行的指令，作为程序员，我们的任务是使用一种或多种编程语言编写这些程序。
- en: 'Most applications that we run, such as a web browser, word processor, or mail
    client, can''t communicate with the computer hardware directly. They require a
    layer in between that takes care of this. This layer is called the **operating
    system**. Windows and Linux are two examples of well-known operating systems.
    The main purpose of an operating system is to take care of the direct communication
    between the applications that we use and the hardware, such as the processor,
    memory, hard drives, keyboards, and printers. To be able to perform this communication,
    the operating system requires special programs that are designed to communicate
    with a particular device. These programs are called **device drivers**. A somewhat
    simplified diagram of how this works is shown here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行的大多数应用程序，例如网页浏览器、文字处理软件或邮件客户端，都不能直接与计算机硬件通信。它们需要一个介于其间的层来处理这个问题。这个层被称为 **操作系统**。Windows和Linux是两个著名的操作系统例子。操作系统的主要目的是处理我们使用的应用程序与硬件（如处理器、内存、硬盘、键盘和打印机）之间的直接通信。为了能够执行这种通信，操作系统需要特殊程序，这些程序被设计用来与特定设备通信。这些程序被称为
    **设备驱动程序**。下面是一个简化的示意图，展示了这个过程：
- en: '![Figure 1.4: The system architecture](img/B15554_01_04.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4：系统架构](img/B15554_01_04.jpg)'
- en: 'Figure 1.4: The system architecture'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：系统架构
- en: Programmers will write the user applications, the operating system, and the
    device drivers, but the user applications category is by far the most common.
    The programs we write will communicate with the system kernel, which is the core
    of the operating system. The operating system will take care of the direct communication
    with the underlying hardware. The good thing about this structure is that we only
    need to talk to the operating system, so we don't need to think about what kind
    of mouse the user has or how to send a line of text to a particular printer model.
    The operating system will talk to the device drivers for the mouse and the printer,
    and the driver will know precisely how to communicate with that device.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员将编写用户应用程序、操作系统和设备驱动程序，但用户应用程序类别无疑是最常见的。我们编写的程序将与系统内核通信，系统内核是操作系统的核心。操作系统将负责与底层硬件的直接通信。这种结构的优点是我们只需要与操作系统通信，因此我们不需要考虑用户有什么样的鼠标或者如何将一行文本发送到特定的打印机型号。操作系统将与鼠标和打印机的设备驱动程序通信，驱动程序将确切知道如何与该设备通信。
- en: 'If we write a program and that program wants to print the text **Hi there computer!**
    to the screen, then this request will be sent to the operating system. The operating
    system will pass this on to the device driver for the monitor, and this driver
    will know how to send this to the monitor connected to this computer:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编写一个程序，并且这个程序想要将文本 **Hi there computer!** 打印到屏幕上，那么这个请求将会发送到操作系统。操作系统会将这个请求传递给连接到这台计算机的显示器设备驱动程序，而这个驱动程序将知道如何将这个信息发送到显示器：
- en: '![Figure 1.5: How instructions flow from the application to the hardware](img/B15554_01_05.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5：指令从应用程序流向硬件的方式](img/B15554_01_05.jpg)'
- en: 'The text entered will not magically appear on the screen, though. It will pass
    through several layers inside the computer. In 1945, the Hungarian-American mathematician
    and physicist John Von Neumann, and others, created a document titled *First Draft
    of a Report to the EDVAC*. In this 101-page document, the first logical design
    of a computer using the concept of a stored program was presented. Additionally,
    the design of an electronic digital computer was described. This design is today
    known as the Von Neumann Architecture, and it defines four different components
    that can be used to construct a computer. These components are as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然输入的文本不会神奇地出现在屏幕上。它将通过计算机内部的几个层。1945年，匈牙利裔美国数学家和物理学家约翰·冯·诺伊曼（John Von Neumann）和其他人创建了一份名为
    *First Draft of a Report to the EDVAC* 的文件。在这101页的文件中，提出了使用存储程序概念的第一台计算机的逻辑设计。此外，还描述了电子数字计算机的设计。这种设计今天被称为冯·诺伊曼架构，它定义了可以用来构建计算机的四个不同组件。这些组件如下：
- en: A processing unit that has an arithmetic logic unit and registers for the processing
    unit to use.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含算术逻辑单元和用于处理单元的寄存器的处理单元。
- en: A control unit that contains an instruction register and a program counter.
    These are used to execute programs.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含指令寄存器和程序计数器的控制单元。这些用于执行程序。
- en: Memory that stores data and instructions. This memory is volatile, meaning that
    its content will be erased when the power is turned off or the computer is restarted.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储数据和指令的内存。这种内存是易失性的，这意味着当电源关闭或计算机重启时，其内容将被清除。
- en: External mass storage. This is long-time storage for programs and data that
    can also be preserved after a computer restarts.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部大容量存储。这是程序和数据的长期存储，计算机重启后也可以保留。
- en: Input and output mechanisms. Today, this is typically a keyboard, a mouse, and
    a monitor.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入和输出机制。今天，这通常是键盘、鼠标和显示器。
- en: All of these components, except external mass storage, come into play when text
    is entered on the keyboard and displayed on the screen.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除了外部大容量存储外，所有这些组件在键盘输入文本并在屏幕上显示时都会发挥作用。
- en: As mentioned in the previous section, the computer can only understand one thing,
    and that is machine code. The machine code is a set of numerical values that the
    computer interprets as different instructions. The computer only works with numbers
    in the binary form, also known as base 2, and that is why we often hear that a
    computer only understands zeros and ones.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，计算机只能理解一种东西，那就是机器码。机器码是一组数值，计算机将其解释为不同的指令。计算机只处理二进制形式的数字，也称为基数2，这就是为什么我们经常听说计算机只理解0和1。
- en: 'To understand the different bases, let''s consider how many digits they have.
    In our daily life, we use the decimal system, called base 10, because we have
    10 digits, from 0 to 9 (we assume the reason for this is that we started counting
    on our fingers). In the base 2 binary system, we only have two digits, 0 and 1\.
    In base 16, the hexadecimal system, we have 16 digits. As we only have digits
    for 0 to 9, we must use some letters in the hexadecimal system to represent the
    values between 10 and 15\. Those letters are A to F. We do this because we must
    understand the difference between digits and numbers: a digit is a single symbol
    representing a value, whereas a number is a sequence of one or more digits. So,
    for example, we can talk about the digit 7, but not the digit 12 (as it is a number
    made up of 2 digits). In the hexadecimal system, we need to represent 16 values;
    therefore, we need 16 digits. Since we only have 10 digits in our decimal system,
    we need to use something else. In this case, it is the letters A to F.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解不同的基数，让我们考虑它们有多少位数字。在我们的日常生活中，我们使用十进制系统，称为基数10，因为我们有10个数字，从0到9（我们假设这是因为我们开始用手指计数）。在基2的二进制系统中，我们只有两个数字，0和1。在基16的十六进制系统中，我们有16个数字。因为我们只有0到9的数字，所以在十六进制系统中，我们必须使用一些字母来表示10到15之间的值。这些字母是A到F。我们这样做是因为我们必须理解数字和数之间的区别：一个数字是一个代表值的单个符号，而一个数是一系列一个或多个数字。所以，例如，我们可以谈论数字7，但不能谈论数字12（因为它是由两个数字组成的数）。在十六进制系统中，我们需要表示16个值；因此，我们需要16个数字。由于我们的十进制系统中只有10个数字，我们需要使用其他东西。在这种情况下，就是字母A到F。
- en: 'Refer to the following table for a comparison between decimal, binary, and
    hexadecimal numbers:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下表格，比较十进制、二进制和十六进制数字：
- en: '![](img/B15554_Table_1.1.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15554_Table_1.1.jpg)'
- en: 'Table 1.1: The numbers 1-15 in the decimal, binary, and hexadecimal format'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.1：十进制、二进制和十六进制格式中的数字1-15
- en: How does a computer program work?
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算机程序是如何工作的？
- en: 'All the tools that we, as humans, have created have helped us with physical
    labor. Finally, we reached a point where we could invent a tool that would help
    us with mental labor: the computer.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们作为人类所创造的所有工具都帮助我们减轻了体力劳动。最终，我们达到了一个可以发明一个帮助我们进行脑力劳动的工具：计算机。
- en: When planning the design of such a machine, the inventors discovered that it
    must perform four different tasks. The computer would need to take data as input,
    store that data, process the data, and then output the result.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计此类机器时，发明者发现它必须执行四个不同的任务。计算机需要接受数据作为输入，存储这些数据，处理数据，然后输出结果。
- en: 'These four tasks are common to all the computers we have ever built. Let''s
    take a closer look at these tasks:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个任务是我们所构建的所有计算机的共同点。让我们更详细地看看这些任务：
- en: We can provide input to the computer in many ways, such as with a keyboard,
    a mouse, voice commands, and touch screens.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过多种方式向计算机提供输入，例如使用键盘、鼠标、语音命令和触摸屏。
- en: 'The input data is sent to the computer''s storage: the internal memory.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入数据被发送到计算机的存储：内部内存。
- en: The **CPU** (which is the **central processing unit**) retrieves the data from
    storage and performs operations on it.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CPU**（中央处理单元）从存储中检索数据并对其进行操作。'
- en: The result of these operations is then sent back to be stored in memory again
    before it is sent out as output.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些操作的结果随后被发送回存储在内存中，然后再作为输出发送出去。
- en: 'Just as different devices can be used to send input to the computer, so too
    can the output be in different forms, and we can use various appliances to present
    the result, such as text to a printer, music through the speakers, or video to
    a screen. The output from one computer can even be inputted to another computer:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如不同的设备可以用来向计算机发送输入一样，输出也可以以不同的形式存在，我们可以使用各种设备来展示结果，例如将文本打印到打印机上，通过扬声器播放音乐，或将视频显示在屏幕上。一台计算机的输出甚至可以被输入到另一台计算机中：
- en: '![Figure 1.6: The four tasks of a computer](img/B15554_01_06.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6：计算机的四个任务](img/B15554_01_06.jpg)'
- en: 'Figure 1.6: The four tasks of a computer'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6：计算机的四个任务
- en: All four steps – input, storage, process, and output – handle data. Let's explore
    what this data is and what form it takes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 所有四个步骤——输入、存储、处理和输出——都处理数据。让我们来探讨一下这些数据是什么以及它采取的形式。
- en: Understanding the binary system
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解二进制系统
- en: Why is it that computers only work with zeros and ones? Why can't they work
    directly with text or images, for example? The answer is that it is rather easy
    to build circuits that can represent two states. If you have an electrical wire,
    you can either run electricity through it or not. The flow or no flow of electricity
    could represent several things, such as on or off, true or false, or zero or one.
    Let's think of these two states as zero and one for now, with zero representing
    no electricity flowing and one symbolizing that we do have flow. If we can serve
    these two states, we could add more wires and, by doing that, have more zeros
    and ones.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么计算机只处理零和一呢？为什么它们不能直接处理文本或图像，例如？答案是，构建可以表示两种状态的电路相当容易。如果你有一根电线，你可以选择通过它通电或不通电。电流的流动或不流动可以代表几件事情，例如开或关、真或假、或零或一。现在让我们把这些两种状态暂时看作零和一，其中零代表没有电流流动，一表示确实有电流流动。如果我们能够处理这两种状态，我们就可以添加更多的电线，通过这样做，我们就有更多的零和一。
- en: But what could we possibly do with all of these zeros and ones? Well, the answer
    is that we can do almost anything. For example, with only zeros and ones, we can
    represent any integer by using the binary numeral system. Let's demonstrate how
    that works.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们究竟能用这些零和一做什么呢？嗯，答案是我们可以几乎做任何事情。例如，仅使用零和一，我们可以通过二进制数制来表示任何整数。让我们演示一下这是如何工作的。
- en: To understand binary numbers, we must start by looking at the decimal numeral
    system. In the decimal system, we work with 10 digits, from 0 to 9\. When we count,
    we go through these digits until we reach 9\. Now we have run out of digits, so
    we start over from zero and add a one in front of it, forming the number 10\.
    Then, we continue until we reach 19, then we do the same thing again; start over
    from zero and increase the value in front of the zero by one, so we get 20\.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解二进制数，我们必须首先看看十进制数制。在十进制系统中，我们使用10个数字，从0到9。当我们计数时，我们通过这些数字直到我们达到9。现在我们用完了数字，所以我们从零开始，并在前面加一个一，形成数字10。然后，我们继续计数直到我们达到19，然后我们再次这样做；从零开始，并在零的前面增加一个一，所以我们得到20。
- en: 'Another way to think about different numeral systems is to think about the
    value a position represents. Let''s consider an example. The number 212 has the
    digit 2 in two places, but their position gives them two different values. If
    we start from the right and move to the left, we can say that we take the first
    digit, 2, and multiply it by 1\. Then, we take the second digit, 1, and multiply
    it by 10\. Finally, we take the last digit, 2, and multiply it by 100\. If we
    move from right to left, each step is worth 10 times as much as the previous step.
    Take a look at this calculation represented in the following table:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考不同数制的方法是考虑一个位置所代表的值。让我们来看一个例子。数字212有两个位置上有数字2，但它们的位置使它们具有不同的值。如果我们从右边开始向左移动，我们可以这样说：我们取第一个数字，2，乘以1。然后，我们取第二个数字，1，乘以10。最后，我们取最后一个数字，2，乘以100。如果我们从右向左移动，每一步的价值是前一步的10倍。看看以下表格中所示的计算：
- en: '![Table 1.2:The positional values of a binary number](img/B15554_Table_1.2.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![表1.2：二进制数的位值](img/B15554_Table_1.2.jpg)'
- en: Table 1.2\. The positional values of a decimal number
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.2：十进制数的位值
- en: When using the binary system, we do the same thing, but only using the digits
    0 and 1\. We start our counting with 0, followed by 1\. At this point, we run
    out of digits, so we start over from 0, adding a 1 in front of it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用二进制系统时，我们做的是同样的事情，但只使用数字 0 和 1。我们从 0 开始计数，然后是 1。在这个点上，我们用完了数字，所以我们从 0 重新开始，在其前面加一个
    1。
- en: 'Counting in binary looks like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制计数看起来是这样的：
- en: 0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010, 1011, 1100, 1101, 1110,
    1111, and so on
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010, 1011, 1100, 1101, 1110,
    1111，等等
- en: 'When it comes to the values each position has for binary numbers, it works
    just as it does with decimal numbers. However, the value for each position is
    not multiplied by 10 but instead by 2\. We multiply the first digit by 1, the
    second digit by 2, the third digit by 4, and so on. To make things simpler, we
    could say that a one in a particular position means that the number representing
    that position shall be a part of the final value, and zero means it shall not.
    Take a look at this table for binary number 11010100:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到二进制数中每个位置所具有的值时，它的工作方式与十进制数一样。然而，每个位置的值不是乘以 10，而是乘以 2。我们将第一个数字乘以 1，第二个数字乘以
    2，第三个数字乘以 4，依此类推。为了使事情更简单，我们可以说，在特定位置上的 1 表示该位置的数字应该是最终值的一部分，而 0 表示它不应该。看看这个表，以了解二进制数
    11010100：
- en: '![Table 1.3: Interpreting binary number 11010100](img/B15554_Table_1.3.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![表 1.3：解释二进制数 11010100](img/B15554_Table_1.3.jpg)'
- en: 'Table 1.3: Interpreting binary number 11010100'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.3：解释二进制数 11010100
- en: Here, we have ones at the positions represented by 128, 64, 16, and 4, so now
    we can add them together (we can ignore the positions with zeros as adding zero
    to something will not make any difference) to get what the binary number of 11010100
    is in decimal form, which is 212.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有 128、64、16 和 4 位置上的 1，因此现在我们可以将它们相加（我们可以忽略带有 0 的位置，因为将 0 加到某物上不会产生任何影响），以得到二进制数
    11010100 的十进制形式，即 212。
- en: 'If we want to convert a decimal number, say 27, into binary, we start by thinking
    how far we can go through the sequence of positional values: 1, 2, 4, 8, 16, and
    so on. Which is the largest of these that we can find that is smaller than or
    equal to 27? The answer is 16, so the first 1 in this binary number will be at
    this position. On all positions before 16, we can insert 0:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要将一个十进制数，比如 27，转换为二进制，我们首先思考我们可以通过位置值序列走多远：1, 2, 4, 8, 16，等等。这些中哪一个是我们能找到的最大的小于或等于
    27 的值？答案是 16，所以这个二进制数中的第一个 1 将在这个位置。在 16 之前的所有位置上，我们可以插入 0：
- en: '![Figure 1.7: Finding the first position that is less than or equal to 27](img/B15554_01_07.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.7：找到小于或等于 27 的第一个位置](img/B15554_01_07.jpg)'
- en: 'Figure 1.7: Finding the first position that is less than or equal to 27'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7：找到小于或等于 27 的第一个位置
- en: 'We then subtract 16 from 27 and get 11 and repeat the process with this value.
    The largest value that is less than or equal to 11 is 8:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们从 27 中减去 16，得到 11，并使用这个值重复这个过程。小于或等于 11 的最大值是 8：
- en: '![Figure 1.8: Finding the first position that is less than or equal to 8](img/B15554_01_08.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8：找到小于或等于 8 的第一个位置](img/B15554_01_08.jpg)'
- en: 'Figure 1.8: Finding the first position that is less than or equal to 8'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8：找到小于或等于 8 的第一个位置
- en: 'We subtract 8 from 11 and get 3\. The next value, 4, is larger than 3, so we
    insert a 0 at this position:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 11 中减去 8，得到 3。下一个值，4，大于 3，所以我们在这个位置插入一个 0：
- en: '![Figure 1.9\. We encounter a position that is greater than 3 so we insert
    a 0](img/B15554_01_09.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.9：我们遇到一个大于 3 的位置，所以我们插入一个 0](img/B15554_01_09.jpg)'
- en: 'Figure 1.9: We encounter a position that is greater than 3 so we insert a 0'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9：我们遇到一个大于 3 的位置，所以我们插入一个 0
- en: 'As we have not inserted a 1 yet, we keep the value of 3 and try to find a value
    that works for it. The next one, 2, is less than or equal to 3, so we insert a
    1 here and then subtract 2 from 3 and get 1:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还没有插入一个 1，我们保持 3 的值，并尝试找到一个适合它的值。下一个值，2，小于或等于 3，所以我们在这里插入一个 1，然后从 3 中减去
    2，得到 1：
- en: '![Figure 1.10: 2 is less than 3, so we insert a 1 at this position](img/B15554_01_010.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.10：2 小于 3，所以我们在这个位置插入一个 1](img/B15554_01_010.jpg)'
- en: 'Figure 1.10: 2 is less than 3, so we insert a 1 at this position'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10：2 小于 3，所以我们在这个位置插入一个 1
- en: 'We repeat this until we reach 0:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重复这个过程，直到达到 0：
- en: '![Figure 1.11: When we have reached the end, we have arrived at the complete
    binary number](img/B15554_01_011.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.11：当我们到达末尾时，我们已经到达了完整的二进制数](img/B15554_01_011.jpg)'
- en: 'Figure 1.11: When we have reached the end, we have arrived at the complete
    binary number'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11：当我们到达末尾时，我们已经到达了完整的二进制数
- en: We now know that 27 will be 11011 in binary. We can ignore the leading zeros.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道 27 在二进制中将是 11011。我们可以忽略前面的零。
- en: When we have one single binary digit, we call it a **bit**, and if we place
    them in groups of 8 bits, we call them a **byte**. One byte can hold values between
    0 and 255\. This is because a 1 in all positions (11111111) will be 128 + 64 +
    32 + 16 + 8 + 4 + 2 + 1= 255.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们只有一个二进制位时，我们称它为**位**，如果我们将它们分成 8 位的组，我们称它们为**字节**。一个字节可以存储介于 0 到 255 之间的值。这是因为所有位置上的
    1（11111111）将是 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 = 255。
- en: By using lots of zeros and ones, the computer can represent any number in binary
    form, and if it can represent numbers, it can serve other things too, such as
    text.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用大量的 0 和 1，计算机可以以二进制形式表示任何数字，如果它可以表示数字，它也可以表示其他事物，例如文本。
- en: Understanding ASCII and Unicode
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 ASCII 和 Unicode
- en: If you give each letter of the English alphabet a numerical value, you could
    represent text with numbers. We could, for example, say that A=1, B=2, and so
    on. The computer does not use these values for the letters, but instead, it can
    either use something that is called the ASCII table (pronounced *as-key*) or another
    representation that is called Unicode. It is not important to understand exactly
    how they work; the only thing we need to understand is that a number can represent
    every character. This number can then be looked up using either the ASCII table
    or Unicode.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你给英语字母表的每个字母一个数值，你可以用数字来表示文本。例如，我们可以说 A=1，B=2，以此类推。计算机不使用这些值来表示字母，而是可以使用称为
    ASCII 表的东西（发音为 *as-key*）或另一种称为 Unicode 的表示。我们不需要完全理解它们是如何工作的；我们只需要理解的是，一个数字可以表示每个字符。然后，我们可以使用
    ASCII 表或 Unicode 来查找这个数字。
- en: The ASCII table uses one byte to represent different characters. The table starts
    with characters that are non-printable. Eventually, it reaches the characters
    in the English alphabet. So, A, for example, is 65, B is 66, and so on. 255 characters
    will not take us far as we have lots of different alphabets around the world,
    and we also want to represent other symbols. That is why we also have Unicode.
    Its mapping to individual characters is not as direct as it is in the ASCII table,
    but all we need to know right now is that with it, we can use numbers to represent
    characters.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII 表使用一个字节来表示不同的字符。表从不可打印的字符开始。最终，它达到了英语字母表中的字符。所以，例如，A 是 65，B 是 66，以此类推。255
    个字符并不能带我们走得太远，因为我们周围有大量的不同字母表，我们还想表示其他符号。这就是为什么我们还有 Unicode。它对单个字符的映射不像 ASCII
    表那样直接，但我们现在需要知道的是，有了它，我们可以使用数字来表示字符。
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Non-printable characters are symbols that are not used for visual representation;
    for example, when we need a way to indicate a tab or a new line, or if printing
    text to a printer, we want the printer to continue to the next page.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 不可打印的字符是那些不用于视觉表示的符号；例如，当我们需要一种表示制表符或换行符的方法时，或者如果将文本打印到打印机上，我们希望打印机继续到下一页。
- en: Representing other forms of data
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表示其他形式的数据
- en: We've learned how to represent text in binary, but what about things other than
    text and numbers? What about images? And video? And sound?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何用二进制表示文本，但除了文本和数字之外的东西怎么办？图像、视频和声音怎么办？
- en: 'Images are made up of pixels, and three values, RGB, represent each pixel.
    These values tell the computer how much red, green, and blue a pixel has:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图像由像素组成，三个值，RGB，代表每个像素。这些值告诉计算机一个像素有多少红色、绿色和蓝色：
- en: '![Figure 1.12: Three values represent a single pixel, indicating how much red,
    green, and blue it has](img/B15554_01_012.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.12：三个值代表一个像素，指示它有多少红色、绿色和蓝色](img/B15554_01_012.jpg)'
- en: 'Figure 1.12: Three values represent a single pixel, indicating how much red,
    green, and blue it has'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12：三个值代表一个像素，指示它有多少红色、绿色和蓝色
- en: A video is nothing more than a composite of many images, so every frame is an
    image; therefore, it can be represented the same way.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 视频不过是许多图像的组合，所以每一帧都是一个图像；因此，它可以以相同的方式表示。
- en: 'A waveform can represent sound. Each peak and valley can be a number:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 波形可以表示声音。每个峰值和谷值都可以是一个数字：
- en: '![](img/B15554_01_013.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15554_01_013.jpg)'
- en: 'Figure 1.13: Audio depicted as a waveform'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13：音频以波形表示
- en: Now that we know how the computer can represent data, we have to find out how
    it processes it. To understand that, we must first dive into a corner of mathematics
    that is called Boolean algebra.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了计算机如何表示数据，我们就必须找出它是如何处理数据的。为了理解这一点，我们必须首先深入了解一个被称为布尔代数的数学领域。
- en: Boolean algebra
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔代数
- en: George Boole, who lived between 1815 and 1864, was a self-taught English mathematician
    and the inventor of Boolean logic, which is the basis of how all our computers
    work.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 乔治·布尔（George Boole），生活在 1815 年至 1864 年之间，是一位自学成才的英国数学家，也是布尔逻辑的发明者，这是所有计算机工作的基础。
- en: 'Boolean logic, sometimes referred to as Boolean algebra, is a form of mathematics
    that works with only two values: **true** and **false**. It also defines three
    operations that we can perform on these two values: **AND**, **OR**, and **NOT**.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔逻辑，有时也称为布尔代数，是一种仅使用两个值：**true**（真）和**false**（假）进行工作的数学形式。它还定义了三种我们可以对这些两个值执行的操作：**AND**（与）、**OR**（或）和**NOT**（非）。
- en: '**NOT** is the simplest of these operations as all it does is just switch the
    value, so not true is false, and not false is true. For example, if I say, "It
    is raining today," this statement can be true or false. It is true if it rains
    and false if it is not. If I instead say, "It is **NOT** raining today," then
    the statement will be true if it doesn''t rain and false if it does.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**NOT** 是这些操作中最简单的，因为它所做的只是切换值，所以非真即为假，非假即为真。例如，如果我这么说，“今天在下雨”，这个陈述可以是真也可以是假。如果下雨，它就是真的；如果不下雨，它就是假的。如果我改为说，“今天
    **NOT** 在下雨”，那么这个陈述将在不下雨时为真，在下雨时为假。'
- en: '**AND** takes two statements that can be either true or false and evaluates
    them into a single value. The outcome will be true if both incoming values are
    true and false in all other situations. If I say, "It is raining today, **AND**
    I have a blue umbrella," the statement will only be true if both parts are true,
    that is, if it is actually raining and my umbrella is actually blue. However,
    if it is raining but my umbrella is pink, what I say will be false, even though
    half of it was true.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**AND** 取两个可以是真或假的陈述，并将它们评估为一个单一值。如果两个输入值都为真，结果将为真，在其他所有情况下都为假。如果我这么说，“今天在下雨，**AND**
    我有一把蓝色雨伞”，这个陈述只有在两部分都为真时才是真的，也就是说，如果实际上在下雨，我的雨伞实际上是蓝色的。然而，如果下雨但我的雨伞是粉色的，我所说的将是假的，尽管其中一半是真的。'
- en: '**OR** works on two parts, just like **AND**, but now only one of the two must
    be true to make the statement true. If I say, "Today I will go to the beach **OR**
    I will go to town," then the statement will be true whether I either go to the
    beach or to town, and also if I manage to do both.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**OR** 操作作用于两个部分，就像 **AND** 一样，但现在只需要其中一个为真即可使语句为真。如果我这么说，“今天我会去海滩 **OR** 我会去镇上，”那么无论我是否去海滩或镇上，这个语句都会是真的，而且如果我同时做到了这两件事，这个语句也是真的。'
- en: We can illustrate how these three operations work in something called a truth
    table. A truth table is a way to describe how an input of the **true** and **false**
    values is transformed by an operation. The input is often referred to as **P**
    if we only have one input value, or **P** and **Q** if we have two. The result
    is shown in the last column.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一种称为真值表的东西来说明这三个操作是如何工作的。真值表是一种描述输入的 **true** 和 **false** 值如何被一个操作转换的方法。如果只有一个输入值，我们通常将其称为
    **P**；如果有两个，我们将其称为 **P** 和 **Q**。结果显示在最后一列。
- en: 'If **P** is the input value, the truth table for **NOT** will look like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 **P** 是输入值，**NOT** 的真值表将如下所示：
- en: '![Table 1.4: The truth table for NOT](img/B15554_Table_1.4.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![表 1.4：NOT 的真值表](img/B15554_Table_1.4.jpg)'
- en: 'Table 1.4: The truth table for NOT'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.4：NOT 的真值表
- en: 'For **AND**, the truth table looks like this if **P** and **Q** are the input:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 **AND**，如果 **P** 和 **Q** 是输入值，其真值表如下：
- en: '![Table 1.5: The truth table for AND](img/B15554_Table_1.5.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![表 1.5：AND 的真值表](img/B15554_Table_1.5.jpg)'
- en: 'Table 1.5: The truth table for AND'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.5：AND 的真值表
- en: 'For **OR**, the truth table looks like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 **OR**，真值表如下所示：
- en: '![Table 1.6: The truth table for OR](img/B15554_Table_1.6.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![表 1.6：OR 的真值表](img/B15554_Table_1.6.jpg)'
- en: 'Table 1.6: The truth table for OR'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.6：OR 的真值表
- en: As you can see, the only way an **AND** operation can be **true** is if both
    parts are true, and the only time **OR** can be false is if both parts are **false**.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，**AND** 操作只有在两个部分都为真时才能为真，而 **OR** 只有在两个部分都为假时才能为假。
- en: 'When Claude Shannon, an American mathematician and electrical engineer, published
    his master''s degree thesis in 1937, *A Symbolic Analysis of Relay and Switching
    Circuits*, he based his work on the ideas of Boole. From Shannon''s ideas, Boolean
    logic made its way into our modern computers because, with the help of the simple
    operations that Boole defined, we could transform any value that can be in one
    of two states: true or false, on or off, or, in the case of binary numbers, one
    or zero.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当美国数学家和电气工程师克劳德·香农在1937年发表了其硕士学位论文《继电器和开关电路的符号分析》时，他基于布尔的思想。从香农的思想中，布尔逻辑进入了我们的现代计算机，因为借助布尔定义的简单操作，我们可以将任何可以处于两种状态之一（真或假，开或关，或者，在二进制数字的情况下，一或零）的值转换。
- en: 'We can accomplish these operations with the help of transistors. There is no
    need for us to go into the details of how a transistor works – just knowing that
    it can be used to represent true/false, on/off, or 0/1 is enough. We can then
    connect several transistors into different configurations to accomplish operations
    such as **AND**, **OR**, and **NOT**. These combinations are called **gates**,
    so we will have a group of transistors called an **AND gate**, one that is called
    an **OR gate**, and one that is called a **NOT gate**. These gates can then be
    connected further to construct circuits that can add, subtract, multiply, and
    divide. We have now built a machine that can represent both numbers and these
    basic operations. We have done this using only numbers, and all these numbers
    will be in binary, so we have a machine that only works with zeros and ones: the
    computer.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用晶体管来完成这些操作。我们不需要深入了解晶体管的工作原理——只需知道它可以用来表示真/假、开/关或0/1就足够了。然后我们可以将几个晶体管连接成不同的配置来完成**AND**、**OR**和**NOT**等操作。这些组合被称为**门**，因此我们将有一组被称为**AND门**的晶体管，一个被称为**OR门**的，一个被称为**NOT门**的。然后这些门可以进一步连接来构建可以进行加、减、乘、除的电路。我们现在已经构建了一台可以表示数字和这些基本操作的机器。我们只使用数字做到了这一点，并且所有这些数字都将以二进制形式存在，因此我们有一个只使用零和一的机器：计算机。
- en: Machine code – the native language of the computer
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机器码 – 计算机的原生语言
- en: 'Now that we have circuits that can perform some basic operations on numbers,
    and we have data in the form of numbers, we can start to write programs that will
    perform operations on the data. We can do that with the only thing the computer
    understands: machine code. As numbers can represent everything, the instructions
    we give to the computer will be – yes, that''s right – just numbers.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可以执行一些基本数字操作的电路，并且我们有以数字形式的数据，我们可以开始编写将执行数据操作的程序。我们可以用计算机唯一理解的东西来做这件事：机器码。因为数字可以代表一切，我们给计算机的指令将是——是的，没错——只是数字。
- en: Each processor type has a specific set of instructions. That is why a program
    written for a Mac can't run on a PC running Windows, for example. So, the instructions
    can be machine code. Machine code has several operations, called **opcodes**.
    The operations can be things such as **AND**, **OR**, **ADD**, and so on. Each
    opcode has a unique number. For example, **AND** could have an opcode value of
    1, and **OR** could have an opcode value of 9\.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每种处理器类型都有其特定的指令集。这就是为什么为Mac编写的程序不能在运行Windows的PC上运行，例如。因此，指令可以是机器码。机器码有几种操作，称为**操作码**。操作可以是**AND**、**OR**、**ADD**等。每个操作码都有一个唯一的数字。例如，**AND**可能有一个操作码值为1，而**OR**可能有一个操作码值为9。
- en: The processor will also have several registers. A register is a small area,
    sometimes referred to as a data holding place, where the processor can store data
    it is currently working with. Before executing an operation, we will need to move
    the data we want as input to the operation, from memory, into some of these registers.
    The result of the operation, the output, is also stored in a register. In reality,
    things are a bit more complicated than this, but we do not need to go into all
    the details here.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器还将拥有几个寄存器。寄存器是一个小区域，有时被称为数据存储位置，处理器可以在其中存储它当前正在处理的数据。在执行操作之前，我们需要将作为操作输入的数据从内存移动到这些寄存器之一。操作的结果，即输出，也存储在寄存器中。实际上，事情比这要复杂得多，但在这里我们不需要深入所有细节。
- en: 'We can now recall the image of the four operations that were common for all
    computers: input, storage, process, and output. We first get some **input**, and
    it will go to the computer''s memory for **storage**. The processor will then
    retrieve it from its registers and perform operations on it, which is the **process**
    part. When we have the result of the operations, it will go back into the memory
    so that it can later be sent to the **output**.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以回忆起所有计算机都常见的四种操作：输入、存储、处理和输出。我们首先进行一些**输入**，然后它将进入计算机的内存进行**存储**。处理器然后将它从其寄存器中检索出来，并对其进行操作，这就是**处理**部分。当我们得到操作的结果时，它将返回到内存中，以便稍后可以将其发送到**输出**。
- en: One way to write these instructions is to use something called an *assembly*.
    This is a way of writing a program where we use three-letter abbreviations for
    the opcodes and have names for the registers. By doing this, it will be easier
    to read and understand the instructions we give. We can then use a program that
    can translate the assembly code into machine code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这些指令的一种方法是用一种叫做*汇编*的东西。这是一种编写程序的方式，我们使用操作码的三字母缩写，并为寄存器命名。通过这样做，我们将更容易阅读和理解我们给出的指令。然后我们可以使用一个程序将汇编代码翻译成机器码。
- en: 'The assembly language is the first programming language we encounter. The assembly
    language can look like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言是我们遇到的第一种编程语言。汇编语言可能看起来像这样：
- en: '[PRE0]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we are moving (`mov`) the value of 14 into one of the registers, called
    `eax`, and then we are moving the value of 10 into another register, called `ebx`.
    We are then performing the `add` operation on the contents of these two registers.
    The result will be written back into a register; perhaps `eax` will be reused
    for this.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将值14移动到名为`eax`的一个寄存器中，然后我们将值10移动到另一个名为`ebx`的寄存器中。然后我们对这两个寄存器的内容执行`add`操作。结果将写回到一个寄存器中；也许`eax`会再次被用于这个操作。
- en: If the **move** operation has an opcode of 136 and the **add** operation has
    an opcode of 1, we can use these values together with the numerical representations
    of the registers to have all of this in only numerical format. And, as we know,
    everything that is numerical can be represented in binary form, that is, with
    zeros and ones.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**移动**操作的操作码为136，而**加法**操作的操作码为1，我们可以使用这些值以及寄存器的数值表示，将所有这些信息都只用数字格式表示。而且，正如我们所知，所有数字都可以用二进制形式表示，即用0和1。
- en: Now we have all that, we need to look at some machine code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所有这些，我们需要查看一些机器码。
- en: Example machine code
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例机器码
- en: 'Remember that the instructions we give will be different depending on what
    processor and operating system we use. The following is an example of what machine
    code can look like for a program printing the text **Hello, World!** to the screen
    on a computer using the Linux operating system:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们给出的指令将取决于我们使用的处理器和操作系统。以下是一个示例，展示了在Linux操作系统上运行的一个程序将文本**Hello, World!**打印到屏幕上的机器码：
- en: '[PRE1]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When looking at this program, we can write the numbers in binary or decimal
    format if we want to. However, to make it easier to read, we often use hexadecimal
    numbers as we can then use fewer digits. For example, 15 in the decimal format
    (two digits) is 1111 (four digits) in binary, but only F (one digit) in hexadecimal.
    It is just more compact – that is the only reason we do this.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看这个程序时，如果我们想的话，可以用二进制或十进制格式来写这些数字。然而，为了便于阅读，我们通常使用十六进制数字，因为这样我们可以使用更少的数字。例如，十进制中的15（两位数字）在二进制中是1111（四位数字），但在十六进制中只有F（一位数字）。这仅仅更紧凑——这就是我们这样做的原因。
- en: Don't worry if you don't understand anything about the machine code program.
    It is not supposed to be readable for humans; however, for the computer, this
    all makes sense.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对机器码程序不理解，不要担心。它并不打算对人类可读；然而，对于计算机来说，这一切都是有意义的。
- en: Writing code in machine code is error-prone. A number in the wrong place can
    be the difference between success and disaster. The natural next step, therefore,
    has been to create something more comfortable for humans to read and write, which
    the computer can then translate into machine code. One such measure has been the
    creation of the assembly language that we talked about earlier.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器码中编写代码容易出错。一个数字放错位置可能会导致成功与灾难的区别。因此，下一步自然的步骤就是创建一些对人类来说更易于阅读和编写的代码，然后计算机可以将这些代码翻译成机器码。我们之前提到的汇编语言就是这样一种措施。
- en: 'Here is the same program, written in the assembly language:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相同的程序，用汇编语言编写的：
- en: '[PRE2]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, this is still not that easy to understand. In the next chapter,
    we will learn how to write the same program using languages that resemble human
    language to a much higher degree.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这仍然不是那么容易理解。在下一章中，我们将学习如何使用更接近人类语言的编程语言来编写相同的程序。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have gone back in history and explored the development of
    computers. The history of computers is a vast topic, but we touched on some important
    events that have made computers the fantastic machines that we know today.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了历史，探讨了计算机的发展。计算机的历史是一个庞大的主题，但我们触及了一些重要事件，这些事件使得计算机成为了我们今天所知道的神奇机器。
- en: For a computer to be useful, it requires programs, and to be able to write programs,
    we need programming languages. We learned that the development of programming
    was closely related to the development of computers, even if Lady Ada Lovelace
    managed to write what was considered to be the first computer program about 100
    years before the first computer was built.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要使计算机变得有用，它需要程序，而要能够编写程序，我们需要编程语言。我们了解到编程的发展与计算机的发展密切相关，即使阿达·洛芙莱斯女士设法在第一台计算机建造大约100年前就写出了被认为是第一个计算机程序。
- en: With the history of computers covered, we then turned our attention to what
    a computer program is and how the computer can use the instructions given in the
    program to accomplish the intentions of the programmer. To do that, we examined
    the smallest parts of data a computer can handle, the bits, which are the zeros
    and ones of the binary representation of numbers. We learned that the ideas of
    George Boole and his Boolean logic are the core of how a computer can transform
    data. Boole's ideas will return in later chapters, as we will use them when writing
    programs as well.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了计算机的历史之后，我们接着关注了计算机程序是什么，以及计算机如何使用程序中给出的指令来完成程序员的意图。为了做到这一点，我们考察了计算机可以处理的最小数据单元，即比特，它们是数字的二进制表示中的零和一。我们了解到乔治·布尔及其布尔逻辑的理念是计算机如何转换数据的核心。布尔的理念将在后面的章节中再次出现，因为我们在编写程序时也会用到它们。
- en: Finally, we took a closer look at the language of computers, machine code. We
    saw how hard it is for us to read and understand, and because of that, we will
    appreciate the next chapter, where we will learn what we can do to avoid working
    with this difficult code directly.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们更深入地研究了计算机的语言，即机器代码。我们看到了我们阅读和理解它的难度，正因为如此，我们将更加欣赏下一章，在那里我们将学习我们可以做些什么来避免直接与这种困难的代码打交道。
