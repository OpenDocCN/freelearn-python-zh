<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Data Structures and Algorithms</h1></div></div></div><p>Data structures are the building blocks to solve programming problems. They provide organization for the data, and algorithms provide the logic to carve the perfect solution. Python provides many efficient built-in data structures that can be used effectively. There are other good data-structure implementations in the standard library as well as third-party libraries. Often, the more pressing question is when to use what, or what data-structure is good for the present problem description. To resolve this, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Python data structures</li><li class="listitem" style="list-style-type: disc">Python library data structures</li><li class="listitem" style="list-style-type: disc">Third-party data structures</li><li class="listitem" style="list-style-type: disc">Algorithms on scale</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Python built-in data structures</h1></div></div></div><p>
<strong>Key 1: Understanding Python's in-built data structure.</strong>
</p><p>Before going in <a id="id91" class="indexterm"/>on how to use different data structures, we should take a look at the attributes of the object that are important for built-in data structures. For the default sorting to work, the object should have one of the <code class="literal">__lt__</code>, and <code class="literal">__gt__</code> methods defined. Otherwise, we can pass a key function to the sorting method to use in getting the intermediate keys that are used to compare it, as shown in the following code:</p><div><pre class="programlisting">def less_than(self, other):
    return self.data &lt;= other.data


class MyDs(object):

    def __init__(self, data):
        self.data = data

    def __str__(self,):
        return str(self.data)
    __repr__ = __str__

if __name__ == '__main__':

    ml = [MyDs(i) for i in range(10, 1, -1)]
    try:
        ml.sort()
    except TypeError:
        print("unable to sort by default")

    for att in '__lt__', '__le__', '__gt__', '__ge__':
        setattr(MyDs, att, less_than)
        ml = [MyDs(i) for i in list(range(5, 1, -1)) + list(range(1, 5,))]
        try:
            ml.sort()
            print(ml)
        except TypeError:
            print("cannot sort")
        delattr(MyDs, att)

    ml = [MyDs(i) for i in range(10, 1, -1)]
    print("sorted", sorted(ml, key=lambda x: x.data))
    ml.sort(key=lambda x: x.data)
    print("sort", ml)</pre></div><p>The output <a id="id92" class="indexterm"/>of the preceding code is as follows:</p><div><pre class="programlisting">[1, 2, 2, 3, 3, 4, 4, 5]
cannot sort
[5, 4, 4, 3, 3, 2, 2, 1]
cannot sort
sorted [2, 3, 4, 5, 6, 7, 8, 9, 10]
sort [2, 3, 4, 5, 6, 7, 8, 9, 10]</pre></div><p>Whether two objects are equal in value is defined by the output of the <code class="literal">__eq__</code> method. Collections<a id="id93" class="indexterm"/> have the same value if they have the same length and the same value of all items, as shown in the following code:</p><div><pre class="programlisting">def equals(self, other):
    return self.data == other.data


class MyDs(object):

    def __init__(self, data):
        self.data = data

    def __str__(self,):
        return str(self.data)
    __repr__ = __str__

if __name__ == '__main__':
    m1 = MyDs(1)
    m2 = MyDs(2)
    m3 = MyDs(1)
    print(m1 == m2)
    print(m1 == m3)

    setattr(MyDs, '__eq__', equals)
    print(m1 == m2)
    print(m1 == m3)
    delattr(MyDs, '__eq__')

    print("collection")
    l1 = [1, "arun", MyDs(3)]
    l2 = [1, "arun", MyDs(3)]
    print(l1 == l2)
    setattr(MyDs, '__eq__', equals)
    print(l1 == l2)
    l2.append(45)
    print(l1 == l2)
    delattr(MyDs, '__eq__')

    print("immutable collection")
    t1 = (1, "arun", MyDs(3), [1, 2])
    t2 = (1, "arun", MyDs(3), [1, 2])
    print(t1 == t2)
    setattr(MyDs, '__eq__', equals)
    print(t1 == t2)
    t1[3].append(7)
    print(t1 == t2)</pre></div><p>The output <a id="id94" class="indexterm"/>of the preceding code is as follows:</p><div><pre class="programlisting">False
False
False
True
collection
False
True
False
immutable collection
False
True
False</pre></div><p>Hash function maps a larger value set to the smaller hash set. Hence, two different objects can have the same hash, but objects with a different hash must be different. In other words, equal value objects should have the same hash, and objects with a different hash must have different values for hash to be meaningful. When we define <code class="literal">__eq__</code> in a class, we must define a hash function as well. By default, for user class instances, hash uses the ID of the object, as shown in the following code:</p><div><pre class="programlisting">class MyDs(object):

    def __init__(self, data):
        self.data = data

    def __str__(self,):
        return "%s:%s" % (id(self) % 100000, self.data)

    def __eq__(self, other):
        print("collision")
        return self.data == other.data

    def __hash__(self):
        return hash(self.data)

    __repr__ = __str__


if __name__ == '__main__':

    dd = {MyDs(i): i for i in (1, 2, 1)}
    print(dd)

    print("all collisions")
    setattr(MyDs, '__hash__', lambda x: 1)
    dd = {MyDs(i): i for i in (1, 2, 1)}
    print(dd)

    print("all collisions,all values same")
    setattr(MyDs, '__eq__', lambda x, y: True)
    dd = {MyDs(i): i for i in (1, 2, 1)}
    print(dd)</pre></div><p>The output of the <a id="id95" class="indexterm"/>preceding code is as follows:</p><div><pre class="programlisting">collision
{92304:1: 1, 92360:2: 2}
all collisions
collision
collision
{51448:1: 1, 51560:2: 2}
all collisions,all values same
{92304:1: 1}</pre></div><p>It can be seen that mutable objects do not have hash defined. Although this is not advised, we can, however, do so in our user defined classes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Tuples</strong>: These <a id="id96" class="indexterm"/>are immutable lists, slice operations are <em>O(n)</em>, retrieval is <em>O(n)</em>, and they have small memory requirements. They are normally used to group objects of different types in a single structure, such as C language structures, where the position is fixed for particular types of information, shown as follows:<div><pre class="programlisting">&gt;&gt;&gt; sys.getsizeof(())
48
&gt;&gt;&gt; sys.getsizeof(tuple(range(100)))
848</pre></div><p>Named tuples that are available from the collections module can be used to access values with object notation, as follows:</p><div><pre class="programlisting">&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; student = namedtuple('student','name,marks')
&gt;&gt;&gt; s1 = student('arun',133)
&gt;&gt;&gt; s1.name
'arun'
&gt;&gt;&gt; s1.marks
133
&gt;&gt;&gt; type(s1)
&lt;class '__main__.student'&gt;</pre></div></li><li class="listitem" style="list-style-type: disc"><strong>Lists</strong> : These are <a id="id97" class="indexterm"/>mutable data structures that are similar to tuples. They are good to collect objects of similar types. When analyzing their time-complexity, we see that insert, delete, slice, and copy operations require <em>O(n)</em>, Retrieval require len <em>O(1)</em>, and sort requires <em>O(nlogn)</em>. Lists are implemented as dynamic arrays. It must resize to double of its previous on increase in size greater than current capacity. Insert and delete at the front of the list takes more time as it must move all references to other elements one by one:<div><pre class="programlisting">&gt;&gt;&gt; sys.getsizeof([])
64
&gt;&gt;&gt; sys.getsizeof(list(range(100)))
1008</pre></div></li><li class="listitem" style="list-style-type: disc"><strong>Dictionary</strong>: These <a id="id98" class="indexterm"/>are mutable mappings. A key can be any hashable object. Getting a value for key, setting a value for a key, and deleting a key are all <em>O(1)</em>, and copying is <em>O(n)</em>:<div><pre class="programlisting">&gt;&gt;&gt; d = dict()
&gt;&gt;&gt; getsizeof(d)
288
&gt;&gt;&gt; getsizeof({i:None for i in range(100)})
6240</pre></div></li><li class="listitem" style="list-style-type: disc"><strong>Sets</strong>: These <a id="id99" class="indexterm"/>can be thought as of groups of items where hash is used to retrieve items. Sets have methods to check union, and intersection, which is useful rather than checking the same with lists. Let's take an example of groups of animals, as follows:<div><pre class="programlisting">&gt;&gt;&gt; air = ("sparrow", "crow")
&gt;&gt;&gt; land = ("sparrow","lizard","frog")
&gt;&gt;&gt; water = ("frog","fish")
&gt;&gt;&gt; # find animal able to live on land and water
... 
&gt;&gt;&gt; [animal for animal in water if animal in land]
['frog']
&gt;&gt;&gt; 
&gt;&gt;&gt; air = set(air)
&gt;&gt;&gt; land = set(land)
&gt;&gt;&gt; water = set(water)
&gt;&gt;&gt; land | water #animal living either land or water
{'frog', 'fish', 'sparrow', 'lizard'}
&gt;&gt;&gt; land &amp; water #animal living both land and water
{'frog'}
&gt;&gt;&gt; land ^ water #animal living on only one land or water
{'fish', 'sparrow', 'lizard'}</pre></div><p>Their implementation and time-complexity is very similar to dictionary, shown as follows:</p><div><pre class="programlisting">&gt;&gt;&gt; s = set()
&gt;&gt;&gt; sys.getsizeof(s)
224
&gt;&gt;&gt; s = set(range(100))
&gt;&gt;&gt; sys.getsizeof(s)
8416</pre></div></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Python library data structures</h1></div></div></div><p>
<strong>Key 2: Using Python's</strong><a id="id100" class="indexterm"/>
<strong> standard library data structures.</strong>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>collections.deque</strong>: The<a id="id101" class="indexterm"/> collections module have a <code class="literal">deque</code> implementation. Deque is useful for the scenarios where item insertion and deletion occurs at both ends of structure as it has efficient inserts at the start of structure as well. Time-complexity is similar to copy <em>O(n)</em>, insert—<em>O(1)</em>, and delete—<em>O(n)</em>. The following graph shows an insert at 0 position operation comparison between list and deque:<div><pre class="programlisting">&gt;&gt;&gt; d = deque()
&gt;&gt;&gt; getsizeof(d)
632
&gt;&gt;&gt; d = deque(range(100))
&gt;&gt;&gt; getsizeof(d)
1160</pre></div><p>The following<a id="id102" class="indexterm"/> image is the graphical representation of the preceding code:</p><div><img src="img/B04885_04_02.jpg" alt="Python library data structures"/></div></li><li class="listitem" style="list-style-type: disc"><strong>PriorityQueue</strong>: A<a id="id103" class="indexterm"/> standard library queue module has implementations for multiproducer, and multiconsumer queues. We can simplify and reuse its <code class="literal">PriorityQueue</code> for simpler cases using the <code class="literal">heapq</code> module, as follows:<div><pre class="programlisting">from heapq import heappush, heappop
from itertools import count

class PriorityQueue(object):
    def __init__(self,):
        self.queue = []
        self.counter = count()

    def __len__(self):
        return len(self.queue)

    def pop(self,):
        item = heappop(self.queue)
        print(item)
        return item[2],item[0]

    def push(self,item,priority):
        cnt = next(self.counter)
        heappush(self.queue, (priority, cnt, item))</pre></div></li></ul></div><p>Other than these, queue<a id="id104" class="indexterm"/> modules have <code class="literal">threadsafe</code>, <code class="literal">LifoQueue</code>, <code class="literal">PriorityQueue</code>, <code class="literal">queue</code>, <code class="literal">deque</code> implementations. Also, lists can be used as stacks or queues. Collections also have <code class="literal">orderedDict</code>, which remembers the sequence of elements.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Third party data structures</h1></div></div></div><p>
<strong>Key 3: Using third-party data structures.</strong>
</p><p>Python has a <a id="id105" class="indexterm"/>good bunch of data structures in the core language/library. But sometimes, an application has very specific requirements. We can always use third-party data-structure packages. Most of such modules are Python wrapper over C, C++ implementations:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">blist</code> module provides a drop-in replacement for list, <code class="literal">sortedList</code>, and <code class="literal">sortedset</code>. It is discussed in greater detail in later chapters.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">bintrees</code> module provides binary, AVL tree, and Red-Black trees.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">banyan</code> module provides Red-Black trees, splay tree, and sorted lists.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Sortedcontainers</code> module provides <code class="literal">SortedList</code>, <code class="literal">SortedDict</code>, and <code class="literal">SortedSet</code>. So, one can get almost every data structure for Python easily. More stress should be given on why one data structure is better than another for a use case.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec20"/>Arrays/List</h2></div></div></div><p>For numeric <a id="id106" class="indexterm"/>calculations<a id="id107" class="indexterm"/> involving math, NumPy arrays should be considered. They are fast, memory-efficient, and provide many vector and matrix operations.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec21"/>Binary tree</h2></div></div></div><p>Trees have better <a id="id108" class="indexterm"/>worst-case<a id="id109" class="indexterm"/> insertion/removal, <em>O(log(n))</em>, min/max, and look-ups than dictionaries. There are several implementations that are available.</p><p>One module is <code class="literal">bintrees</code>, which have C implementations that are available for Red-Black trees, AVL tree, and <a id="id110" class="indexterm"/>Binary trees. For example, in Red-Black trees, it is easy to find max, and min, ranges as <a id="id111" class="indexterm"/>shown in the following example:</p><div><pre class="programlisting">tr = bintrees.FastRBTree()
tr.insert("a",40)
tr.insert("b",5)
tr.insert("a",9)
print(list(tr.keys()),list(tr.items()))
print(tr.min_item())
print(tr.pop_max())
print(tr.pop_max())
tr = bintrees.FastRBTree([(i,i+1) for i in range(10)])
print(tr[5:9])</pre></div><p>The output of the preceding code is as follows:</p><div><pre class="programlisting">['a', 'b'] [('a', 9), ('b', 5)]
('a', 9)
('b', 5)
('a', 9)
FastRBTree({5: 6, 6: 7, 7: 8, 8: 9})</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec22"/>Sorted containers</h2></div></div></div><p>These are<a id="id112" class="indexterm"/> pure-Python modules having <code class="literal">SortedList</code>, <code class="literal">SortedSet</code>, and <code class="literal">SortedDict</code> Data structures, which <a id="id113" class="indexterm"/>can keep the keys/items sorted. The <code class="literal">SortedContainers</code> module claims to have speed comparable to C extensions modules, shown as follows:</p><div><pre class="programlisting">import sortedcontainers as sc
import sys
l = sc.SortedList()
l.update([0,4,2,1,4,2])
print(l)
print(l.index(2),l.index(4))
l.add(6)
print(l[-1])
l = sc.SortedList(range(10))
print(l)
print(list(l.irange(2,6)))

seta = sc.SortedSet(range(1,4))
setb = sc.SortedSet(range(3,7))
print(seta - setb)
print(seta | setb )
print(seta &amp; setb)
print([i for i in seta])</pre></div><p>The output <a id="id114" class="indexterm"/>of the preceding <a id="id115" class="indexterm"/>code is as follows:</p><div><pre class="programlisting">SortedList([0, 1, 2, 2, 4, 4], load=1000)
2 4
6
SortedList([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], load=1000)
[2, 3, 4, 5, 6]
SortedSet([1, 2], key=None, load=1000)
SortedSet([1, 2, 3, 4, 5, 6], key=None, load=1000)
SortedSet([3], key=None, load=1000)
[1, 2, 3]</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec23"/>Trie</h2></div></div></div><p>This is an <a id="id116" class="indexterm"/>ordered-tree <a id="id117" class="indexterm"/>data-structure, where the position in the tree defines the key. The keys are normally strings. In comparison to dictionaries, it has faster worst-case data retrieval <em>O(m)</em>. Hash functions are not needed. If we are using strings only to be stored in the keys, it can take a lot less space then dictionary.</p><div><img src="img/B04885_04_01.jpg" alt="Trie"/></div><p>In Python, we have the <code class="literal">marisa-trie</code> package that provides this functionality as static Data structures. It is a Cython wrapper over the C++ library. We can associate values with <a id="id118" class="indexterm"/>the keys as <a id="id119" class="indexterm"/>well. It also provides memory mapped I/O, which is useful to decrease memory usage on cost of speed. The <code class="literal">datrie</code> is another package that provides read-write tries, The following are some basic usage of these libraries:</p><div><pre class="programlisting">&gt;&gt;&gt; import string
&gt;&gt;&gt; import marisa_trie as mtr
&gt;&gt;&gt; import datrie as dtr
&gt;&gt;&gt; 
&gt;&gt;&gt; 
&gt;&gt;&gt; # simple read-only keys
... tr = mtr.Trie([u'192.168.124.1',u'192.168.124.2',u'10.10.1.1',u'10.10.1.2'])
&gt;&gt;&gt; #get all keys
... print(tr.keys())
['10.10.1.1', '10.10.1.2', '192.168.124.1', '192.168.124.2']
&gt;&gt;&gt; #check if key exists
... print(tr.has_keys_with_prefix('192'))
True
&gt;&gt;&gt; # get id of key
... print(tr.get('192.168.124.1'))
2
&gt;&gt;&gt; # get all items
... print(tr.items())
[('10.10.1.1', 0), ('10.10.1.2', 1), ('192.168.124.1', 2), ('192.168.124.2', 3)]
&gt;&gt;&gt; 
&gt;&gt;&gt; # storing data along with keys
... btr = mtr.BytesTrie([('192.168.124.1',b'redmine.meeku.com'),
...                     ('192.168.124.2',b'jenkins.meeku.com'),
...                     ('10.5.5.1',b'gerrit.chiku.com'),
...                     ('10.5.5.2',b'gitlab.chiku.com'),
...                     ])
&gt;&gt;&gt; print(list(btr.items()))
[('10.5.5.1', b'gerrit.chiku.com'), ('10.5.5.2', b'gitlab.chiku.com'), ('192.168.124.1', b'redmine.meeku.com'), ('192.168.124.2', b'jenkins.meeku.com')]
&gt;&gt;&gt; print(btr.get('10.5.5.1'))
[b'gerrit.chiku.com']
&gt;&gt;&gt; 
&gt;&gt;&gt; with open("/tmp/marisa","w") as f:
...     btr.write(f)
... 
&gt;&gt;&gt;     
... # using memory mapped io to decrease memory usage
... dbtr = mtr.BytesTrie().mmap("/tmp/marisa")
&gt;&gt;&gt; print(dbtr.get("192.168.124.1"))
[b'redmine.meeku.com']
&gt;&gt;&gt; 
&gt;&gt;&gt; 
&gt;&gt;&gt; trie = dtr.Trie('0123456789.') #define allowed character range
&gt;&gt;&gt; trie['192.168.124.1']= 'redmine.meeku.com'
&gt;&gt;&gt; trie['192.168.124.2'] = 'jenkins.meeku.com'
&gt;&gt;&gt; trie['10.5.5.1'] = 'gerrit.chiku.com'
&gt;&gt;&gt; trie['10.5.5.2'] = 'gitlab.chiku.com'
&gt;&gt;&gt; print(trie.prefixes('192.168.245'))
[]
&gt;&gt;&gt; print(trie.values())
['gerrit.chiku.com', 'gitlab.chiku.com', 'redmine.meeku.com', 'jenkins.meeku.com']
&gt;&gt;&gt; print(trie.suffixes())
['10.5.5.1', '10.5.5.2', '192.168.124.1', '192.168.124.2']
&gt;&gt;&gt; 
&gt;&gt;&gt; trie.save("/tmp/1.datrie")
&gt;&gt;&gt; ntr = dtr.Trie.load('/tmp/1.datrie')
&gt;&gt;&gt; print(ntr.values())
['gerrit.chiku.com', 'gitlab.chiku.com', 'redmine.meeku.com', 'jenkins.meeku.com']
&gt;&gt;&gt; print(ntr.suffixes())
['10.5.5.1', '10.5.5.2', '192.168.124.1', '192.168.124.2']</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Algorithms on scale</h1></div></div></div><p>
<strong>Key 4: Thinking out-of-the-box for the algorithms.</strong>
</p><p>An <a id="id120" class="indexterm"/>algorithm is how we solve a problem. The most common issue of not being able to solve the problem is to not being able to define it properly. Normally, we look to apply an algorithm <a id="id121" class="indexterm"/>only at a small level, such as in a small functionality, or sorting in a function. We, however, do not think about algorithms when the scale increases, mostly the stress is on how fast it is. Let's take a simple requirement of sorting a file and sending it to a user. If the file is, let's say 10-20 KB or so, it will be best to simply use the Python sorted function to sort the entries. In the following code, the file is of format where columns are ID, name, due, and due-date. We want to sort it based on dues, as follows:</p><div><pre class="programlisting">10000000022,shy-flower-ac5,-473,16/03/25
10000000096,red-water-e85,-424,16/02/12
10000000097,dry-star-c85,-417,16/07/19
10000000070,damp-night-c76,-364,16/03/12
10000000032,muddy-shadow-aad,-362,16/08/05

def dosort(filename,result):
    with open(filename) as ifile:
        with open(result,"w") as ofile:
            for line in sorted(
                map(lambda x:x.strip(), ifile.readlines()
                    ),key=lambda x:int(x.split(',')[2])
                ):
                ofile.write(line)
                ofile.write('\n')</pre></div><p>This works great, but <a id="id122" class="indexterm"/>as the file increases in size, the memory requirement increases. We cannot load all contents in the memory at the same time. Hence, we can use external merge-sort to divide the file into small parts, sort them, and then merge the sorted results together. In the following code, we used <code class="literal">heapq.merge</code> to merge iterators:</p><div><pre class="programlisting">import tempfile
import heapq

def slowread(f, nbytes):
    while True:
        ilines = f.readlines(nbytes)
        if not ilines:
            break
        for line in ilines:
            yield int(line.split(',')[2]),line

def dosort(filename, result):
    partition = 5000
    with open(filename,"r") as ifile:
        with open(result,"w") as ofile:
            tempfiles = []
            while True:
                ilines  = ifile.readlines(partition)
                if len(ilines) == 0 :
                    break
                tfile = tempfile.TemporaryFile(mode="w+")
                tfile.writelines(
                    sorted(
                        ilines,
                        key=lambda x:int(x.split(',')[2])
                        ))
                tfile.seek(0)
                tempfiles.append(tfile)
            lentempfiles = len(tempfiles)
            read_generators = [slowread(tfile, partition//(lentempfiles+1))  for tfile in tempfiles]
            res = []
            for line in heapq.merge(*read_generators):
                res.append(line[1])
                if len(res) &gt; 100:
                    ofile.writelines(res)
                    res.clear()
            if res:
                ofile.writelines(res)
            ofile.close()</pre></div><p>Once we use up <a id="id123" class="indexterm"/>memory of a single computer, or have files distributed over multiple computers in a network, the file-based algorithm will not work. We will need to sort incoming streams from upstream servers, and send the sorted stream to the downstream. If we look at the following code carefully, we will see that we have not changed the underlying mechanism. We are still using <code class="literal">heapq.merge</code> to merge elements, but now, we are getting elements from the network instead. The following client code is simple, it just starts sending sorted lines by lines on receive of the next command from a downstream server:</p><div><pre class="programlisting">import socket
import sys
from sort2 import dosort2

HOST = '127.0.0.1'
PORT =  9002
NCLIENTS = 2

class Client(object):

    def __init__(self,HOST,PORT,filename):
        self.skt = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        self.skt.connect((HOST,PORT))
        self.filename = filename
        self.skt.setblocking(True)

    def run(self):
        for line in dosort2(self.filename):
            print("for",line)
            data = self.skt.recv(1024)
            print("data cmd",data)
            if data == b'next\r\n':
                data = None
                self.skt.send(line[1].encode())
            else:
                print("got from server",data)
        print("closing socket")
        self.skt.close()

c = Client(HOST,PORT,sys.argv[1])
c.run()</pre></div><p>In the server code, the <code class="literal">ClientConn</code> class abstracts away network operations and provides an<a id="id124" class="indexterm"/> iterator interface to <code class="literal">heapq.merge</code>. We can greatly enhance the code using buffering. Here, the <code class="literal">get_next</code> method gets new line from the client. Simple abstraction solved a great problem:</p><div><pre class="programlisting">import socket
import heapq
from collections import deque

HOST = '127.0.0.1'
PORT = 9002
NCLIENTS = 2

class Empty(Exception):
    pass

class ClientConn(object):
    def __init__(self, conn, addr):
        self.conn = conn
        self.addr = addr
        self.buffer = deque()
        self.finished = False
        self.get_next()

    def __str__(self, ):
        return '%s' % (str(self.addr))

    def get_next(self):
        print("getting next", self.addr)
        self.conn.send(b"next\r\n")
        try:
            ndata = self.conn.recv(1024)
        except Exception as e:
            print(e)
            self.finished = True
            ndata = None
        if ndata:
            ndata = ndata.decode()
            print("got from client", ndata)
            self.push((int(ndata.split(',')[2]), ndata))
        else:
            self.finished = True

    def pop(self):
        if self.finished:
            raise Empty()
        else:
            elem = self.buffer.popleft()
            self.get_next()
            return elem

    def push(self, value):
        self.buffer.append(value)

    def __iter__(self, ):
        return self

    def __next__(self, ):
        try:
            return self.pop()
        except Empty:
            print("iter empty")
            raise StopIteration


class Server(object):
    def __init__(self, HOST, PORT, NCLIENTS):
        self.nclients = NCLIENTS
        self.skt = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.skt.setblocking(True)
        self.skt.bind((HOST, PORT))
        self.skt.listen(1)

    def run(self):
        self.conns = []  # list of all clients connected

        while len(self.conns) &lt; self.nclients:  # accept client till we have all
            conn, addr = self.skt.accept()
            cli = ClientConn(conn, addr)
            self.conns.append(cli)
            print('Connected by', cli)

        with open("result", "w") as ofile:
            for line in heapq.merge(*self.conns):
                print("output", line)
                ofile.write(line[1])

s = Server(HOST, PORT, NCLIENTS)
s.run()</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Summary</h1></div></div></div><p>In this chapter, we learned about the data structures that are available in the Python standard library and some third-party libraries, which are extremely useful for everyday programming. Knowledge of data-structure usage is very much important in choosing right tool for the job. Choosing of an algorithm is highly application-specific, and we should always try to find out a solution that is simpler to read.</p><p>In the next chapter, we will cover design patterns that provide great help in writing elegant solutions to the problems.</p></div></body></html>