<html><head></head><body>
<div id="_idContainer101">
<h1 class="chapter-number" id="_idParaDest-259"><a id="_idTextAnchor298"/><span class="koboSpan" id="kobo.1.1">15</span></h1>
<h1 id="_idParaDest-260"><a id="_idTextAnchor299"/><span class="koboSpan" id="kobo.2.1">Flask Unit Testing</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.3.1">Unit testing</span></strong><span class="koboSpan" id="kobo.4.1"> is an</span><a id="_idIndexMarker1030"/><span class="koboSpan" id="kobo.5.1"> essential phase in software development that guarantees the proper functioning of each component of an application. </span><span class="koboSpan" id="kobo.5.2">In </span><a href="B18554_07.xhtml#_idTextAnchor142"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">React Unit Testing</span></em><span class="koboSpan" id="kobo.9.1">, we discussed unit testing as it relates to React components in building reliable user interfaces for the frontend part of a web application. </span><span class="koboSpan" id="kobo.9.2">With backend development, the principles of unit testing are similar, except that you are using a different programming language – or better, still working with a backend </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">tech stack.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">Unit testing ensures that each component or module of a software application is working correctly in isolation from the rest of the application. </span><span class="koboSpan" id="kobo.11.2">By testing each unit separately and thoroughly, developers can identify and fix issues early in the development cycle, which can save time and effort in the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">long run.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">Unit testing helps catch defects early and provides a safety net for refactoring code, making it easier to maintain and evolve the application over time. </span><span class="koboSpan" id="kobo.13.2">Ultimately, the goal of unit testing is to produce high-quality software that meets the requirements and expectations of </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">end users.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">In this chapter, we will discuss briefly the importance of unit testing in Flask and explore the benefits of using pytest as a testing framework for Flask applications. </span><span class="koboSpan" id="kobo.15.2">We will also cover the installation and setup process</span><a id="_idIndexMarker1031"/><span class="koboSpan" id="kobo.16.1"> for pytest, as well as the fundamentals of </span><strong class="bold"><span class="koboSpan" id="kobo.17.1">test-driven </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.18.1">development </span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">(</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.20.1">TDD</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">Additionally, we will delve into writing basic tests and assertions and handling exceptions. </span><span class="koboSpan" id="kobo.22.2">At the end of this chapter, you will be able to understand the importance of unit testing in Flask applications, describe what pytest is and how it differs from other testing frameworks, and how pytest can be integrated into your </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">existing project.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">You will have also learned how to test JSON APIs using pytest and understand how to make requests to the API endpoints and validate the response data. </span><span class="koboSpan" id="kobo.24.2">Finally, you will be able to apply TDD principles to write tests before writing the actual code and use the tests to guide the </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">development process.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">In this chapter, we’ll be covering the </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.28.1">Unit testing in </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">Flask applications</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.30.1">Introducing pytest</span></span></li>
<li><span class="koboSpan" id="kobo.31.1">Setting up </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">of pytest</span></span></li>
<li><span class="koboSpan" id="kobo.33.1">Basic syntax, structures, and features </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">of pytest</span></span></li>
<li><span class="koboSpan" id="kobo.35.1">Writing </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">unit tests</span></span></li>
<li><span class="koboSpan" id="kobo.37.1">Testing </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">JSON APIs</span></span></li>
<li><span class="koboSpan" id="kobo.39.1">Test-driven development </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">with Flask</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.41.1">Handling exceptions</span></span></li>
</ul>
<h1 id="_idParaDest-261"><a id="_idTextAnchor300"/><span class="koboSpan" id="kobo.42.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.43.1">The complete code for this chapter is available on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">at: </span></span><a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter15"><span class="No-Break"><span class="koboSpan" id="kobo.45.1">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter15</span></span></a></p>
<h1 id="_idParaDest-262"><a id="_idTextAnchor301"/><span class="koboSpan" id="kobo.46.1">Unit testing in Flask applications</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.47.1">Flask</span></strong><span class="koboSpan" id="kobo.48.1"> is</span><a id="_idIndexMarker1032"/><span class="koboSpan" id="kobo.49.1"> like a</span><a id="_idIndexMarker1033"/><span class="koboSpan" id="kobo.50.1"> chef’s knife for web developers – it’s a versatile</span><a id="_idIndexMarker1034"/><span class="koboSpan" id="kobo.51.1"> tool that can help you cook up scalable and flexible applications in no time. </span><span class="koboSpan" id="kobo.51.2">However, as the complexity of Flask applications grows, it becomes increasingly difficult to ensure that all the components of the application are working correctly together. </span><span class="koboSpan" id="kobo.51.3">This is where unit testing </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">comes in.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">Unit testing is a software testing technique that involves testing each component or module of an application in isolation from the rest of the application. </span><span class="koboSpan" id="kobo.53.2">By testing each unit separately and thoroughly, developers can identify and fix issues at the outset of the development process. </span><span class="koboSpan" id="kobo.53.3">The practice of unit testing can assist in spotting defects quickly and serve as a safeguard when making changes or modifying code, thus making it easier to maintain and evolve the application </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">With Flask applications, unit testing helps ensure that all the routes, views, and other components are working as expected. </span><span class="koboSpan" id="kobo.55.2">Unit testing can also help catch issues with database interactions, external API calls, and other </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">external dependencies.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">The testing heuristics or principles are </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.59.1">FIRST</span></strong><span class="koboSpan" id="kobo.60.1">: Fast, Independent, Repeatable, Self-Validating, </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">and </span></span><span class="No-Break"><a id="_idIndexMarker1035"/></span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">Timely</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.63.1">RITE</span></strong><span class="koboSpan" id="kobo.64.1">: Readable, Isolated, Thorough, </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">and</span></span><span class="No-Break"><a id="_idIndexMarker1036"/></span><span class="No-Break"><span class="koboSpan" id="kobo.66.1"> Explicit</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.67.1">3A</span></strong><span class="koboSpan" id="kobo.68.1">: Arrange, </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">Act, </span></span><span class="No-Break"><a id="_idIndexMarker1037"/></span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">Assert</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.71.1">These principles can be utilized by developers as guidelines and best practices to ensure the effectiveness of their unit testing efforts. </span><span class="koboSpan" id="kobo.71.2">These testing principles can enhance the quality of code, minimize bugs and defects, and ultimately deliver superior software products to </span><a id="_idIndexMarker1038"/><span class="koboSpan" id="kobo.72.1">application users. </span><span class="koboSpan" id="kobo.72.2">By adhering to these </span><a id="_idIndexMarker1039"/><span class="koboSpan" id="kobo.73.1">principles, developers and testers can improve the overall reliability and maintainability of the </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">Let’s briefly examine these testing principles to understand how they can guide you in writing excellent </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">unit tests.</span></span></p>
<h2 id="_idParaDest-263"><a id="_idTextAnchor302"/><span class="koboSpan" id="kobo.77.1">FIRST</span></h2>
<p><span class="koboSpan" id="kobo.78.1">FIRST</span><a id="_idIndexMarker1040"/><span class="koboSpan" id="kobo.79.1"> emphasizes the importance of unit tests being quick to </span><a id="_idIndexMarker1041"/><span class="koboSpan" id="kobo.80.1">run, not dependent on external factors, able to be run repeatedly without side effects, self-checking, and </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">written promptly:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.82.1">Fast</span></strong><span class="koboSpan" id="kobo.83.1">: Unit tests should be designed to execute quickly so that they can be run frequently without delaying the development cycle. </span><span class="koboSpan" id="kobo.83.2">This means that the unit under test should be lightweight and should not depend on external resources, such as databases or network connections, which can introduce delays in the test execution. </span><span class="koboSpan" id="kobo.83.3">In Flask, we can ensure fast execution of tests by mocking external dependencies using tools such as the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">pytest_mock</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.85.1"> plugin.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.86.1">Independent</span></strong><span class="koboSpan" id="kobo.87.1">: Unit tests should be designed to run independently of each other so that the failure of one test does not affect the execution of other tests. </span><span class="koboSpan" id="kobo.87.2">In Flask, we can achieve independence between tests by resetting the application state before each test using the Flask </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">test client.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.89.1">Repeatable</span></strong><span class="koboSpan" id="kobo.90.1">: Unit tests should be designed to produce the same result every time they are run, regardless of the environment in which they are executed. </span><span class="koboSpan" id="kobo.90.2">This means that the unit under test should not rely on external factors, such as system time or random number generators, that can introduce variability in the </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">test results.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.92.1">Self-checking</span></strong><span class="koboSpan" id="kobo.93.1">: Unit tests should be designed to check their results and report failures without requiring human intervention. </span><span class="koboSpan" id="kobo.93.2">This means that the unit test should include assertions that compare the expected results with the actual results of the test. </span><span class="koboSpan" id="kobo.93.3">In Flask, we can use the built-in assert statement to check the </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">test results.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.95.1">Timely</span></strong><span class="koboSpan" id="kobo.96.1">: Unit tests should be designed to be written promptly, ideally before the code they are testing is written. </span><span class="koboSpan" id="kobo.96.2">This means that they should be part of the development </span><a id="_idIndexMarker1042"/><span class="koboSpan" id="kobo.97.1">process and not an afterthought. </span><span class="koboSpan" id="kobo.97.2">In Flask, we can follow the TDD approach to ensure</span><a id="_idIndexMarker1043"/><span class="koboSpan" id="kobo.98.1"> that tests are written before </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">the code.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.100.1">Next, we will explore RITE (Reproducible, Isolated, Thorough and Extensible), a testing principle that can enhance the effectiveness of unit tests and enhance </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">code quality.</span></span></p>
<h2 id="_idParaDest-264"><a id="_idTextAnchor303"/><span class="koboSpan" id="kobo.102.1">RITE</span></h2>
<p><span class="koboSpan" id="kobo.103.1">RITE emphasizes</span><a id="_idIndexMarker1044"/><span class="koboSpan" id="kobo.104.1"> the importance of unit tests being easy to </span><a id="_idIndexMarker1045"/><span class="koboSpan" id="kobo.105.1">read and understand, isolated from other components, covering all possible scenarios, and explicit in </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">their assertions:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.107.1">Reproducible</span></strong><span class="koboSpan" id="kobo.108.1">: Tests should be able to be reproduced on different systems and environments. </span><span class="koboSpan" id="kobo.108.2">This means that tests should not rely on external factors such as network connectivity, time, or other system resources. </span><span class="koboSpan" id="kobo.108.3">By ensuring that tests can be run consistently across different environments, developers can be confident that their code works </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">as intended.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.110.1">Isolated</span></strong><span class="koboSpan" id="kobo.111.1">: Tests should be independent of each other and not share any state. </span><span class="koboSpan" id="kobo.111.2">This means that each test should start with a clean slate and not rely on any previous test results or global state. </span><span class="koboSpan" id="kobo.111.3">By isolating tests, developers can ensure that each test is testing a specific piece of functionality and is not affected by other parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">the system.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.113.1">Thorough</span></strong><span class="koboSpan" id="kobo.114.1">: Tests should test all aspects of the system, including edge cases and error conditions. </span><span class="koboSpan" id="kobo.114.2">This means that developers should strive to create tests that cover as much of the code base as possible, including all possible inputs </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">and outputs.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.116.1">Extensible</span></strong><span class="koboSpan" id="kobo.117.1">: Tests should be easy to extend and maintain as the system evolves. </span><span class="koboSpan" id="kobo.117.2">This means that tests should be designed to accommodate changes in the code base, such as new features or changes in the </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">system architecture.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.119.1">In a nutshell, the </span><a id="_idIndexMarker1046"/><span class="koboSpan" id="kobo.120.1">RITE principles are beneficial because</span><a id="_idIndexMarker1047"/><span class="koboSpan" id="kobo.121.1"> they can help you to improve the quality, reliability, and maintainability of </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">your code.</span></span></p>
<p><span class="koboSpan" id="kobo.123.1">Moving forward, we will explore 3A (Arrange, Act, and Assert), a unit test approach that can make your unit tests more readable </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">and maintainable.</span></span></p>
<h2 id="_idParaDest-265"><a id="_idTextAnchor304"/><span class="koboSpan" id="kobo.125.1">3A</span></h2>
<p><span class="koboSpan" id="kobo.126.1">3A is a </span><a id="_idIndexMarker1048"/><span class="koboSpan" id="kobo.127.1">simple </span><a id="_idIndexMarker1049"/><span class="koboSpan" id="kobo.128.1">guideline for structuring a unit test and consists of three steps – Arrange, Act, and Assert. </span><span class="koboSpan" id="kobo.128.2">The Arrange phase sets up the test scenario, the Act phase performs the action being tested, and the Assert phase checks the expected outcome. </span><span class="koboSpan" id="kobo.128.3">The 3A principle is the best practice for designing and writing effective </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">unit tests:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.130.1">Arrange</span></strong><span class="koboSpan" id="kobo.131.1">: In this step, you set up the conditions for the test by initializing objects, setting</span><a id="_idIndexMarker1050"/><span class="koboSpan" id="kobo.132.1"> variables, and other necessary actions. </span><span class="koboSpan" id="kobo.132.2">This ensures that the test environment is properly configured and that the system under test is in the </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">expected state.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.134.1">Act</span></strong><span class="koboSpan" id="kobo.135.1">: In this step, you perform the action or method call that is being tested. </span><span class="koboSpan" id="kobo.135.2">This may involve passing arguments to a function, invoking a method on an object, or making a request to an API endpoint. </span><span class="koboSpan" id="kobo.135.3">The key is to ensure that the action being taken is specific and targeted at the functionality </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">being tested.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.137.1">Assert</span></strong><span class="koboSpan" id="kobo.138.1">: In this step, you verify that the outcome of the action matches the expected result. </span><span class="koboSpan" id="kobo.138.2">This often involves checking the value returned by a function, comparing the state of an object before and after a method call, or ensuring that an API</span><a id="_idIndexMarker1051"/><span class="koboSpan" id="kobo.139.1"> endpoint</span><a id="_idIndexMarker1052"/><span class="koboSpan" id="kobo.140.1"> returns the correct response status code </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">and data.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.142.1">Next, we will explore Pytest as a widely used testing framework that seamlessly integrates with Flask. </span><span class="koboSpan" id="kobo.142.2">Pytest is empowering developers to efficiently create and execute unit tests, integration tests, and more, ensuring the robustness and reliability of Flask </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">web applications.</span></span></p>
<h1 id="_idParaDest-266"><a id="_idTextAnchor305"/><span class="koboSpan" id="kobo.144.1">Introducing Pytest</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.145.1">Pytest</span></strong><span class="koboSpan" id="kobo.146.1"> is an open source testing </span><a id="_idIndexMarker1053"/><span class="koboSpan" id="kobo.147.1">framework for Python that simplifies the process of writing and executing concise and readable tests. </span><span class="koboSpan" id="kobo.147.2">Pytest provides a simple and flexible way to write tests and supports a wide range of testing options out of the box, including functional tests, unit tests, and </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">integration tests.</span></span></p>
<p><span class="koboSpan" id="kobo.149.1">Pytest is widely used among Python developers due to its ease of use, powerful fixture system, and integration with other Python testing tools. </span><span class="koboSpan" id="kobo.149.2">Pytest can automatically find and run all the tests in a project with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">-test</span></strong><span class="koboSpan" id="kobo.151.1"> discovery ability. </span><span class="koboSpan" id="kobo.151.2">Pytest generates detailed reports that provide developers with valuable insights into the </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">test results.</span></span></p>
<p><span class="koboSpan" id="kobo.153.1">These reports include information on the number of tests executed, the time taken to run each test, and any failures or errors that occurred. </span><span class="koboSpan" id="kobo.153.2">This information can help developers pinpoint and address issues promptly, improving the overall quality of the code base. </span><span class="koboSpan" id="kobo.153.3">Pytest has an amazing large community of users and contributors who actively develop and maintain plugins that extend </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">Pytest functionalities.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">Interestingly, Pytest differs from other testing frameworks such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">unittest</span></strong><span class="koboSpan" id="kobo.157.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">nose</span></strong><span class="koboSpan" id="kobo.159.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">doctest</span></strong><span class="koboSpan" id="kobo.161.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">tox</span></strong><span class="koboSpan" id="kobo.163.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">hypothesis library</span></strong><span class="koboSpan" id="kobo.165.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">robot framework</span></strong><span class="koboSpan" id="kobo.167.1"> with its simplicity and power, versatility, and community support, providing easy-to-use testing capabilities with detailed reporting. </span><span class="koboSpan" id="kobo.167.2">Pytest is </span><a id="_idIndexMarker1054"/><span class="koboSpan" id="kobo.168.1">undoubtedly a popular choice among Python developers for unit testing and other </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">testing needs.</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">Next, we’ll walk through the steps of setting up Pytest and creating our </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">first test.</span></span></p>
<h1 id="_idParaDest-267"><a id="_idTextAnchor306"/><span class="koboSpan" id="kobo.172.1">Setting up Pytest</span></h1>
<p><span class="koboSpan" id="kobo.173.1">Testing your Python</span><a id="_idIndexMarker1055"/><span class="koboSpan" id="kobo.174.1"> code is an essential part of the development process, and Pytest is a powerful tool for actualizing a robust testing environment. </span><span class="koboSpan" id="kobo.174.2">In this section, we’ll walk you through the steps of setting up Pytest and transforming your Python code testing experience from amateur into pro, providing advanced features and capabilities that make testing faster, easier, and </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">more effective.</span></span></p>
<p><span class="koboSpan" id="kobo.176.1">To set up Pytest, you can follow </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">these steps:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.178.1">Installing pip</span></strong><span class="koboSpan" id="kobo.179.1">: You can install Pytest using </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">pip</span></strong><span class="koboSpan" id="kobo.181.1">, the package installer for Python. </span><span class="koboSpan" id="kobo.181.2">Open your Terminal or command prompt in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">bizza/backend/</span></strong><span class="koboSpan" id="kobo.183.1"> project directory and run the </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">following command:</span></span><pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.185.1">pip install pytest</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.186.1">The preceding line installs Pytest and all </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">its dependencies.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.188.1">Creating a test file</span></strong><span class="koboSpan" id="kobo.189.1">: Create a new file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">test_addition.py</span></strong><span class="koboSpan" id="kobo.191.1"> in your project directory – that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">bizza/backend/tests/test_addition.py</span></strong><span class="koboSpan" id="kobo.193.1">. </span><span class="koboSpan" id="kobo.193.2">This is a simple example test file to warm </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">up with.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.195.1">Writing a test function</span></strong><span class="koboSpan" id="kobo.196.1">: Inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">test_addition.py</span></strong><span class="koboSpan" id="kobo.198.1">, write a simple test function using the </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">following format:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.200.1">def test_function_name():    assert expression</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.201.1">Let’s discuss the preceding short </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">format snippet:</span></span></p><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">test_function_name</span></strong><span class="koboSpan" id="kobo.204.1"> represents the test </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">function’s name</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">expression</span></strong><span class="koboSpan" id="kobo.207.1"> represents the code you want </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">to test</span></span></li>
<li><span class="koboSpan" id="kobo.209.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">assert</span></strong><span class="koboSpan" id="kobo.211.1"> statement checks whether the expression is true and raises an error if the expression </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">is false</span></span></li>
</ul></li>
</ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.213.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.214.1">In Pytest, test functions are identified by their name and should start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">test_</span></strong><span class="koboSpan" id="kobo.216.1"> prefix. </span><span class="koboSpan" id="kobo.216.2">With this naming convention, Pytest can recognize your functions as tests and run them automatically. </span><span class="koboSpan" id="kobo.216.3">When you run Pytest in the Terminal, Pytest searches your code base for any functions that begin </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">test_</span></strong><span class="koboSpan" id="kobo.218.1">. </span><span class="koboSpan" id="kobo.218.2">Then, Pytest executes those functions and reports the results of </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">the tests.</span></span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.220.1">Now, let’s describe </span><a id="_idIndexMarker1056"/><span class="koboSpan" id="kobo.221.1">a test function that tests whether adding two numbers produces the </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">expected result:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.223.1">def test_addition():    assert 1 + 1 == 2</span></pre>
<p class="list-inset"><span class="koboSpan" id="kobo.224.1">The preceding code shows a simple Pytest test function that tests the addition of two numbers. </span><span class="koboSpan" id="kobo.224.2">The function’s name starts with </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">test_</span></strong><span class="koboSpan" id="kobo.226.1">, which tells Pytest that it is a </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">test function.</span></span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.228.1">The body of the function contains an assertion that checks whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">1 + 1</span></strong><span class="koboSpan" id="kobo.230.1"> equals </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">2</span></strong><span class="koboSpan" id="kobo.232.1">. </span><span class="koboSpan" id="kobo.232.2">If the assertion is </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">true</span></strong><span class="koboSpan" id="kobo.234.1">, then the test passes. </span><span class="koboSpan" id="kobo.234.2">If the assertion is </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">false</span></strong><span class="koboSpan" id="kobo.236.1">, then the test fails and Pytest reports </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">an error.</span></span></p>
<ol>
<li value="4"><strong class="bold"><span class="koboSpan" id="kobo.238.1">Running the tests</span></strong><span class="koboSpan" id="kobo.239.1">: Open your Terminal and navigate to your project directory – that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">bizza/backend/</span></strong><span class="koboSpan" id="kobo.241.1">. </span><span class="koboSpan" id="kobo.241.2">Run the following command to run </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">your tests:</span></span><pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.243.1">pytest</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.244.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">pytest</span></strong><span class="koboSpan" id="kobo.246.1"> command will automatically discover and run all the tests in your project. </span><span class="koboSpan" id="kobo.246.2">You should see a message indicating that your test passed. </span><span class="koboSpan" id="kobo.246.3">Hats off – you have set up Pytest and run your first test! </span><span class="koboSpan" id="kobo.246.4">You can continue to add more test functions to your </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">test_addition.py</span></strong><span class="koboSpan" id="kobo.248.1"> file using the </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">same format.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.250.1">The following Terminal output shows the test result </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">as passed:</span></span></p><pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.252.1">(venv) C:\bizza\backend&gt;pytest</span></strong><strong class="bold"><span class="koboSpan" id="kobo.253.1">========================================================================= test session starts =========================================================================</span></strong><strong class="bold"><span class="koboSpan" id="kobo.254.1">platform win32 -- Python 3.10.1, pytest-7.3.1, pluggy-1.0.0</span></strong><strong class="bold"><span class="koboSpan" id="kobo.255.1">rootdir: C:\bizza\backend</span></strong><strong class="bold"><span class="koboSpan" id="kobo.256.1">plugins: Faker-16.6.0</span></strong><strong class="bold"><span class="koboSpan" id="kobo.257.1">collected 1 item</span></strong><strong class="bold"><span class="koboSpan" id="kobo.258.1">tests\test_addition.py [100%]</span></strong><strong class="bold"><span class="koboSpan" id="kobo.259.1">========================================================================= 1 passed in 21.61s ==========================================================================</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.260.1">Let’s take a look at</span><a id="_idIndexMarker1057"/><span class="koboSpan" id="kobo.261.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">preceding output:</span></span></p><ol><li class="upper-roman"><span class="koboSpan" id="kobo.263.1">The first line in the preceding code shows some information about the platform and versions of Python, Pytest, and other </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">related plugins.</span></span></li>
<li class="upper-roman"><span class="koboSpan" id="kobo.265.1">The second line indicates the root directory for the tests. </span><span class="koboSpan" id="kobo.265.2">In this case, it </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">C:\bizza\backend</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">.</span></span></li>
<li class="upper-roman"><span class="koboSpan" id="kobo.269.1">The third line shows that Pytest has collected one test item, which is stored in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">tests\test_addition.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.271.1"> file.</span></span></li>
<li class="upper-roman"><span class="koboSpan" id="kobo.272.1">The fourth line shows the result of the test: a single dot indicates that the test passed. </span><span class="koboSpan" id="kobo.272.2">If the test had failed, this would have been indicated </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">"F"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">.</span></span></li>
<li class="upper-roman"><span class="koboSpan" id="kobo.276.1">The fifth line shows some summary information, including the number of tests that passed, and the time taken to run </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">the tests.</span></span></li>
<li class="upper-roman"><span class="koboSpan" id="kobo.278.1">Finally, the command prompt returns, indicating that the test has </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">finished running.</span></span></li>
</ol></li>
</ol>
<p><span class="koboSpan" id="kobo.280.1">Let’s </span><a id="_idIndexMarker1058"/><span class="koboSpan" id="kobo.281.1">assume the </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">test_addition.py</span></strong><span class="koboSpan" id="kobo.283.1"> function’s output has changed to </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">5</span></strong><span class="koboSpan" id="kobo.285.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">2</span></strong><span class="koboSpan" id="kobo.287.1">. </span><span class="koboSpan" id="kobo.287.2">Should we expect the test to fail? </span><span class="koboSpan" id="kobo.287.3">Of course, yes! </span><span class="koboSpan" id="kobo.287.4">The test should fail. </span><span class="koboSpan" id="kobo.287.5">The following is the output of the </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">failed test:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.289.1">(venv) C:\bizza\backend&gt;pytest================================================= test session starts =================================================
collected 1 item
tests\test_addition.py F                              [100%]
====================================================== FAILURES =======================================================
____________________________________________________ test_addition ____________________________________________________
    def test_addition():
&gt;      assert 1 + 1 == 5
E      assert (1 + 1) == 5
tests\test_addition.py:3: AssertionError</span></pre>
<p><span class="koboSpan" id="kobo.290.1">The preceding output</span><a id="_idIndexMarker1059"/><span class="koboSpan" id="kobo.291.1"> indicates that the test named </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">test_addition.py</span></strong><span class="koboSpan" id="kobo.293.1"> has failed. </span><span class="koboSpan" id="kobo.293.2">The assertion asserts </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">1 + 1 == 5</span></strong><span class="koboSpan" id="kobo.295.1"> is failing because the actual result of 1 + 1 is 2, </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">not 5.</span></span></p>
<p><span class="koboSpan" id="kobo.297.1">Ready for the next step? </span><span class="koboSpan" id="kobo.297.2">Let’s examine the basic syntax and structure of Pytest. </span><span class="koboSpan" id="kobo.297.3">Then, we will dive deeper into unit testing </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">with Pytest.</span></span></p>
<h1 id="_idParaDest-268"><a id="_idTextAnchor307"/><span class="koboSpan" id="kobo.299.1">Basic syntax, structures, and features of Pytest</span></h1>
<p><span class="koboSpan" id="kobo.300.1">The basic </span><a id="_idIndexMarker1060"/><span class="koboSpan" id="kobo.301.1">syntax </span><a id="_idIndexMarker1061"/><span class="koboSpan" id="kobo.302.1">and </span><a id="_idIndexMarker1062"/><span class="koboSpan" id="kobo.303.1">structure of a Pytest test function can be represented </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.305.1">def test_function_name():    # Arrange: set up the necessary test data or
      environment
    # Act: execute the code being tested
    result = some_function()
    # Assert: check that the expected behavior is observed
    assert result == expected_result</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">test_function_name</span></strong><span class="koboSpan" id="kobo.307.1"> should be a descriptive name that conveys the purpose of </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">the test:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.309.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">Arrange</span></strong><span class="koboSpan" id="kobo.311.1"> section sets up the necessary test data or environment, such as initializing objects or connecting to </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">a database</span></span></li>
<li><span class="koboSpan" id="kobo.313.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">Act</span></strong><span class="koboSpan" id="kobo.315.1"> section executes the code being tested, such as calling a function or performing a </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">specific action</span></span></li>
<li><span class="koboSpan" id="kobo.317.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">Assert</span></strong><span class="koboSpan" id="kobo.319.1"> section checks that the expected behavior is observed, using assertions to verify that the output or behavior of the code matches what </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">was expected</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.321.1">Pytest supports a wide range of assertions, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">assert x == y, assert x != y, assert x in y,</span></strong><span class="koboSpan" id="kobo.323.1"> and many more. </span><span class="koboSpan" id="kobo.323.2">Pytest also supports the use of fixtures, which can be used to manage test dependencies and set up test data </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">and environments.</span></span></p>
<p><span class="koboSpan" id="kobo.325.1">The basic syntax and structure of a Pytest test function are designed to make it easy to write clear, concise tests that verify that your code works as expected. </span><span class="koboSpan" id="kobo.325.2">With Pytest’s structure and the use of fixtures, you can write tests that are reliable, repeatable, and easy </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">to maintain.</span></span></p>
<p><span class="koboSpan" id="kobo.327.1">Next, we will look at one of the key Pytest </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">features: </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.329.1">fixtures</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">.</span></span></p>
<h2 id="_idParaDest-269"><a id="_idTextAnchor308"/><span class="koboSpan" id="kobo.331.1">Using fixtures</span></h2>
<p><span class="koboSpan" id="kobo.332.1">In software </span><a id="_idIndexMarker1063"/><span class="koboSpan" id="kobo.333.1">testing, a </span><strong class="bold"><span class="koboSpan" id="kobo.334.1">fixture</span></strong><span class="koboSpan" id="kobo.335.1"> is a defined state or set of data that </span><a id="_idIndexMarker1064"/><span class="koboSpan" id="kobo.336.1">is needed for a test to run. </span><span class="koboSpan" id="kobo.336.2">Essentially, fixtures are functions that help in managing and providing consistent resources, such as data, configuration, or objects, to different test cases within a test suite. </span><span class="koboSpan" id="kobo.336.3">Fixtures enable you to establish a stable and controlled environment </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">for testing.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">They ensure that each test case has access to the required resources without duplicating setup and teardown methods across multiple tests. </span><span class="koboSpan" id="kobo.338.2">You are probably wondering what setup and teardown methods are. </span><span class="koboSpan" id="kobo.338.3">Let’s pause for a minute and shed more light on this duo in testing </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">Flask applications.</span></span></p>
<p><span class="koboSpan" id="kobo.340.1">In unit testing, the concepts of setup and teardown methods are pivotal techniques that are used to prepare and clean up the testing environment before and after the execution of each test case. </span><span class="koboSpan" id="kobo.340.2">Before delving into test cases, the setup procedure comes into play. </span><span class="koboSpan" id="kobo.340.3">The setup method is executed before each test case, and its purpose is to establish the required conditions </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">for testing.</span></span></p>
<p><span class="koboSpan" id="kobo.342.1">For instance, let’s consider a Flask unit test scenario; the setup method could be designed to mimic a Flask application instance and configure a testing client, thereby providing the necessary infrastructure to simulate HTTP requests and responses for </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">testing purposes.</span></span></p>
<p><span class="koboSpan" id="kobo.344.1">On the flip side, there is the teardown phase. </span><span class="koboSpan" id="kobo.344.2">The teardown procedure takes place post-execution of every test case and involves cleaning up resources that were initially established during the setup operation. </span><span class="koboSpan" id="kobo.344.3">Back to the Flask unit test illustration, the teardown method might be programmed to gracefully terminate the testing client and shut down the Flask application instance. </span><span class="koboSpan" id="kobo.344.4">This ensures that no lingering resources remain active that can disrupt </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">subsequent tests.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">This duo of setup and teardown is typically located within the confines of a class encapsulating the suite of test cases. </span><span class="koboSpan" id="kobo.346.2">To understand it better, consider the following code snippet, which illustrates a class incorporating setup and teardown methods to validate a </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">Flask application:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.348.1">class FlaskTestCase:    def setup(self):
        self.app = create_app()
        self.client = app.test_client()
    def teardown(self):
        self.app = None
        self.client = None
    def test_index_page(self):
        response = self.client.get("/")
        assert response.status_code == 200
        assert response.content == b"Bizza Web Application"</span></pre>
<p><span class="koboSpan" id="kobo.349.1">In the preceding code, the setup method creates a Flask application instance and a test client. </span><span class="koboSpan" id="kobo.349.2">On the other hand, the teardown method gracefully concludes the test client and disposes of the Flask application instance. </span><span class="koboSpan" id="kobo.349.3">The outcome is a neat and orderly closure of resources once a </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">test concludes.</span></span></p>
<p><span class="koboSpan" id="kobo.351.1">However, in</span><a id="_idIndexMarker1065"/><span class="koboSpan" id="kobo.352.1"> pytest, the setup and teardown paradigms can be</span><a id="_idIndexMarker1066"/><span class="koboSpan" id="kobo.353.1"> emulated using fixtures. </span><span class="koboSpan" id="kobo.353.2">Fixtures serve as functions designated to furnish shared resources to multiple test cases. </span><span class="koboSpan" id="kobo.353.3">Fixtures allow you to define and manage test dependencies. </span><span class="koboSpan" id="kobo.353.4">This is how fixtures work in pytest. </span><span class="koboSpan" id="kobo.353.5">You define a fixture with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">@pytest.fixture</span></strong><span class="koboSpan" id="kobo.355.1"> decorator. </span><span class="koboSpan" id="kobo.355.2">This function can then be used as a parameter in test functions, which allows the test function to access the fixture’s data </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">or environment.</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">When a test function is run, pytest automatically detects any fixtures that are defined as parameters and runs those fixture functions first, passing their return values as arguments to the test function. </span><span class="koboSpan" id="kobo.357.2">This ensures that the test function has access to the data or environment it needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">run correctly.</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">The following code snippet showcases a fixture that can be used to produce a Flask application instance and a </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">test client:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.361.1">import pytest@pytest.fixture()
def app():
    app = create_app()
    return app
@pytest.fixture()
def client(app):
    client = app.test_client()
    return client</span></pre>
<p><span class="koboSpan" id="kobo.362.1">The preceding code shows that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">app</span></strong><span class="koboSpan" id="kobo.364.1"> fixture creates a Flask application instance and the client fixture creates a test client. </span><span class="koboSpan" id="kobo.364.2">These fixtures can then be used by test cases within the test suite to get access to the Flask application and the </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">test client.</span></span></p>
<p><span class="koboSpan" id="kobo.366.1">It is noteworthy to say one clear advantage of adopting fixtures for setup and teardown is their potential for reusability. </span><span class="koboSpan" id="kobo.366.2">By using fixtures, the setup and teardown logic can be efficiently </span><a id="_idIndexMarker1067"/><span class="koboSpan" id="kobo.367.1">shared across multiple test cases. </span><span class="koboSpan" id="kobo.367.2">This will invariably </span><a id="_idIndexMarker1068"/><span class="koboSpan" id="kobo.368.1">ensure that the testing code is more maintainable, and by extension, enhance the reusability of </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">test cases.</span></span></p>
<p><span class="koboSpan" id="kobo.370.1">Fixtures in your tests can provide clear benefits, including </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.372.1">Reusability</span></strong><span class="koboSpan" id="kobo.373.1">: You</span><a id="_idIndexMarker1069"/><span class="koboSpan" id="kobo.374.1"> can define a fixture once and use it in multiple tests. </span><span class="koboSpan" id="kobo.374.2">This can save time and </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">reduce duplication.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.376.1">Readability</span></strong><span class="koboSpan" id="kobo.377.1">: By separating the setup code into a fixture function, your test functions can be more focused and easier </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">to read.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.379.1">Maintainability</span></strong><span class="koboSpan" id="kobo.380.1">: Fixtures </span><a id="_idIndexMarker1070"/><span class="koboSpan" id="kobo.381.1">ensure that your tests are consistent and repeatable, even as your code </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">base evolves.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.383.1">Fixtures in pytest provide a powerful and flexible mechanism for managing test dependencies and simplifying your </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">testing workflow.</span></span></p>
<p><span class="koboSpan" id="kobo.385.1">Now, let’s delve into parameterizing in pytest. </span><span class="koboSpan" id="kobo.385.2">Using parameterized tests in pytest allows you to test your code more thoroughly with less </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">code duplication.</span></span></p>
<h2 id="_idParaDest-270"><a id="_idTextAnchor309"/><span class="koboSpan" id="kobo.387.1">Parameterizing in pytest</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.388.1">Parameterizing</span></strong><span class="koboSpan" id="kobo.389.1"> tests in </span><a id="_idIndexMarker1071"/><span class="koboSpan" id="kobo.390.1">pytest is a feature that </span><a id="_idIndexMarker1072"/><span class="koboSpan" id="kobo.391.1">enables you to write a single test function that can be executed with different sets of input parameters. </span><span class="koboSpan" id="kobo.391.2">This is useful when you want to test a function or method with a variety of inputs </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">or configurations.</span></span></p>
<p><span class="koboSpan" id="kobo.393.1">To parameterize a test function in pytest, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">@pytest.mark.parametrize</span></strong><span class="koboSpan" id="kobo.395.1"> decorator. </span><span class="koboSpan" id="kobo.395.2">This decorator takes two arguments: the name of the parameter and a list of values or tuples representing the different parameter sets </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">to test.</span></span></p>
<p><span class="koboSpan" id="kobo.397.1">Let’s explore a parameterized test function </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">in pytest:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.399.1">import pytestdef add(a, b):
    return a + b
@pytest.mark.parametrize("a, b, expected_result", [
    (1, 2, 3),
    (10, 20, 30),
    (0, 0, 0),
    (-1, 1, 0), ids=["1+2=3", "10+20=30", "0+0=0",
        "-1+1=0"]
])
def test_addition(a, b, expected_result):
    assert add(a, b) == expected_result</span></pre>
<p><span class="koboSpan" id="kobo.400.1">The preceding code is a demonstration of parameterized tests in pytest to test a function with multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">input values.</span></span></p>
<p><span class="koboSpan" id="kobo.402.1">The function being tested is </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">add(a, b)</span></strong><span class="koboSpan" id="kobo.404.1">, which takes two arguments, </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">a</span></strong><span class="koboSpan" id="kobo.406.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">b</span></strong><span class="koboSpan" id="kobo.408.1">, and returns their sum. </span><span class="koboSpan" id="kobo.408.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">@pytest.mark.parametrize</span></strong><span class="koboSpan" id="kobo.410.1"> decorator is used to provide a list of input values and their corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">expected results.</span></span></p>
<p><span class="koboSpan" id="kobo.412.1">The decorator takes </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">three arguments:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.414.1">A comma-separated string of parameter names – in this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">"a, </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">b, expected_result"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.418.1">A list of tuples representing the parameter sets and their expected results. </span><span class="koboSpan" id="kobo.418.2">In this example, we have four parameter sets: </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">(1, 2, 3)</span></strong><span class="koboSpan" id="kobo.420.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">(10, 20, 30)</span></strong><span class="koboSpan" id="kobo.422.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">(0, 0, 0)</span></strong><span class="koboSpan" id="kobo.424.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">(-1, </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">1, 0)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.428.1">An optional </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">ids</span></strong><span class="koboSpan" id="kobo.430.1"> argument, which provides custom names for the </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">test cases.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.432.1">For each parameter set in the list, pytest will execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">test_addition()</span></strong><span class="koboSpan" id="kobo.434.1"> function with the corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">a</span></strong><span class="koboSpan" id="kobo.436.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">b</span></strong><span class="koboSpan" id="kobo.438.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">expected_result</span></strong><span class="koboSpan" id="kobo.440.1"> values. </span><span class="koboSpan" id="kobo.440.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">assert</span></strong><span class="koboSpan" id="kobo.442.1"> statement in the test function checks that the actual result of </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">add(a, b)</span></strong><span class="koboSpan" id="kobo.444.1"> matches the </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">expected result.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">When the test</span><a id="_idIndexMarker1073"/><span class="koboSpan" id="kobo.447.1"> function is executed, pytest will generate a </span><a id="_idIndexMarker1074"/><span class="koboSpan" id="kobo.448.1">separate report for each parameter set, so you can see exactly which cases passed and which </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">ones failed:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.450.1">The first parameter set, </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">(1, 2, 3)</span></strong><span class="koboSpan" id="kobo.452.1">, tests whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">add()</span></strong><span class="koboSpan" id="kobo.454.1"> function correctly adds </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">1</span></strong><span class="koboSpan" id="kobo.456.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">2</span></strong><span class="koboSpan" id="kobo.458.1">, resulting </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">3</span></strong></span></li>
<li><span class="koboSpan" id="kobo.461.1">The second parameter set, </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">(10, 20, 30)</span></strong><span class="koboSpan" id="kobo.463.1">, tests whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">add()</span></strong><span class="koboSpan" id="kobo.465.1"> correctly adds </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">10</span></strong><span class="koboSpan" id="kobo.467.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">20</span></strong><span class="koboSpan" id="kobo.469.1">, resulting </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">30</span></strong></span></li>
<li><span class="koboSpan" id="kobo.472.1">The third parameter set, </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">(0, 0, 0)</span></strong><span class="koboSpan" id="kobo.474.1">, tests whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">add()</span></strong><span class="koboSpan" id="kobo.476.1"> correctly adds two zeros, resulting </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">0</span></strong></span></li>
<li><span class="koboSpan" id="kobo.479.1">The fourth parameter set, </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">(-1, 1, 0)</span></strong><span class="koboSpan" id="kobo.481.1">, tests whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">add()</span></strong><span class="koboSpan" id="kobo.483.1"> correctly adds </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">-1</span></strong><span class="koboSpan" id="kobo.485.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">1</span></strong><span class="koboSpan" id="kobo.487.1">, resulting </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">0</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.490.1">Parameterizing tests can help you write more concise and effective test code by reducing the amount of duplication in your test functions and making it easier to test a wide range of inputs </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">and configurations.</span></span></p>
<p><span class="koboSpan" id="kobo.492.1">And that’s not all in terms of pytest’s features. </span><span class="koboSpan" id="kobo.492.2">Next, we’ll explore mocking external dependencies</span><a id="_idIndexMarker1075"/> <span class="No-Break"><span class="koboSpan" id="kobo.493.1">in </span></span><span class="No-Break"><a id="_idIndexMarker1076"/></span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">pytest.</span></span></p>
<h2 id="_idParaDest-271"><a id="_idTextAnchor310"/><span class="koboSpan" id="kobo.495.1">Mocking external dependencies in pytest</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.496.1">Mocking external dependencies</span></strong><span class="koboSpan" id="kobo.497.1"> is a testing technique that involves creating simulated </span><a id="_idIndexMarker1077"/><span class="koboSpan" id="kobo.498.1">versions of external dependencies, such </span><a id="_idIndexMarker1078"/><span class="koboSpan" id="kobo.499.1">as APIs or databases, to isolate your code under test from these dependencies. </span><span class="koboSpan" id="kobo.499.2">When you’re writing unit tests, you typically want to test only the code within the scope of the test, not any external services or libraries that it </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">relies on.</span></span></p>
<p><span class="koboSpan" id="kobo.501.1">This practice helps you keep your tests focused and fast, as well as avoid false positives or false negatives that can result from relying on external dependencies that may not be available or may </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">behave unpredictably.</span></span></p>
<p><span class="koboSpan" id="kobo.503.1">To create a mock object, you must use a mocking framework, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">unittest.mock</span></strong><span class="koboSpan" id="kobo.505.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">pytest-mock</span></strong><span class="koboSpan" id="kobo.507.1">, to create a fake object that mimics the behavior of the real object. </span><span class="koboSpan" id="kobo.507.2">You can then use this mocked object in your tests instead of the real object, which allows you to test your code in a </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">controlled environment.</span></span></p>
<p><span class="koboSpan" id="kobo.509.1">For instance, let’s say you are testing a function that retrieves data from an external API. </span><span class="koboSpan" id="kobo.509.2">You can use a mocking framework to create a mock object that mimics the behavior of the API, and then use this mocked object in your tests instead of making actual API calls. </span><span class="koboSpan" id="kobo.509.3">This allows you to test your function’s behavior in a controlled environment, without you having to worry about network connectivity or the behavior of the </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">external API.</span></span></p>
<p><span class="koboSpan" id="kobo.511.1">Using a mocking strategy in your tests can also help you write more comprehensive tests as it allows you to simulate error conditions or edge cases that might be difficult or impossible to replicate with a real external dependency. </span><span class="koboSpan" id="kobo.511.2">For example, you can use a mocked object to simulate a network timeout or a database error, and then verify that your code under test handles these </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">conditions correctly.</span></span></p>
<p><span class="koboSpan" id="kobo.513.1">Let’s say we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">Speaker</span></strong><span class="koboSpan" id="kobo.515.1"> class in our project that depends on an external </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">email_service</span></strong><span class="koboSpan" id="kobo.517.1"> module to send email notifications to speakers. </span><span class="koboSpan" id="kobo.517.2">We want to write a test for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">Speaker</span></strong><span class="koboSpan" id="kobo.519.1"> class that verifies that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">Speaker</span></strong><span class="koboSpan" id="kobo.521.1"> class sends the expected email notifications when a new speaker is added. </span><span class="koboSpan" id="kobo.521.2">To achieve this, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">pytest-mock</span></strong><span class="koboSpan" id="kobo.523.1"> plugin to mock the </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">email_service</span></strong><span class="koboSpan" id="kobo.525.1"> module and check that the expected calls </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">are made.</span></span></p>
<p><span class="koboSpan" id="kobo.527.1">Let’s dive into a </span><a id="_idIndexMarker1079"/><span class="No-Break"><span class="koboSpan" id="kobo.528.1">code</span></span><span class="No-Break"><a id="_idIndexMarker1080"/></span><span class="No-Break"><span class="koboSpan" id="kobo.529.1"> implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.530.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">bizza/backend/tests</span></strong><span class="koboSpan" id="kobo.532.1"> directory, add the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">test_speaker.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.534.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.535.1"># test_speaker.pyfrom bizza.backend.speaker import Speaker
def test_speaker_notification(mocker):
    # Arrange
    email_mock = mocker.patch(
        "bizza.backend.email_service.send_email")
    speaker = Speaker("John Darwin", "john@example.com")
    # Act
    speaker.register()
    # Assert
    email_mock.assert_called_once_with(
        "john@example.com",
        "Thank you for registering as a speaker",
        "Hello John, \n\nThank you for registering as a
        speaker. </span><span class="koboSpan" id="kobo.535.2">We look forward to your talk!\n\nBest
        regards,\nThe Conference Team"
    )</span></pre>
<p><span class="koboSpan" id="kobo.536.1">In </span><a id="_idIndexMarker1081"/><span class="koboSpan" id="kobo.537.1">the </span><a id="_idIndexMarker1082"/><span class="koboSpan" id="kobo.538.1">preceding code, we created a mocked object for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">email_service.send_email</span></strong><span class="koboSpan" id="kobo.540.1"> function using </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">mocker.patch</span></strong><span class="koboSpan" id="kobo.542.1">. </span><span class="koboSpan" id="kobo.542.2">Then, we created a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">Speaker</span></strong><span class="koboSpan" id="kobo.544.1"> object and called the </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">Speaker</span></strong><span class="koboSpan" id="kobo.546.1"> object’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">register()</span></strong><span class="koboSpan" id="kobo.548.1"> method, which should trigger an email notification to </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">be sent.</span></span></p>
<p><span class="koboSpan" id="kobo.550.1">Then, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">assert_called_once_with</span></strong><span class="koboSpan" id="kobo.552.1"> method of the mocked object to check that the expected email was sent with the correct arguments. </span><span class="koboSpan" id="kobo.552.2">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">send_email</span></strong><span class="koboSpan" id="kobo.554.1"> function is called with different arguments, the test </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">will fail.</span></span></p>
<p><span class="koboSpan" id="kobo.556.1">By using </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">pytest-mock</span></strong><span class="koboSpan" id="kobo.558.1"> to mock the external dependency, we can isolate our test from any potential network issues or other dependencies of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">email_service</span></strong><span class="koboSpan" id="kobo.560.1"> module. </span><span class="koboSpan" id="kobo.560.2">This makes our test more reliable and easier to maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.562.1">Mocking external dependencies is a powerful technique for isolating your code under test from </span><a id="_idIndexMarker1083"/><span class="koboSpan" id="kobo.563.1">external services or libraries, and </span><a id="_idIndexMarker1084"/><span class="koboSpan" id="kobo.564.1">for creating controlled environments that allow you to write comprehensive, </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">reliable tests.</span></span></p>
<h1 id="_idParaDest-272"><a id="_idTextAnchor311"/><span class="koboSpan" id="kobo.566.1">Writing unit tests</span></h1>
<p><span class="koboSpan" id="kobo.567.1">Writing tests </span><a id="_idIndexMarker1085"/><span class="koboSpan" id="kobo.568.1">with pytest involves creating test functions that verify the functionality of your code. </span><span class="koboSpan" id="kobo.568.2">These test functions are executed by pytest and can be organized into test modules and test packages. </span><span class="koboSpan" id="kobo.568.3">In addition to test functions, pytest provides other testing features such as fixtures, parameterization, and mocking, which can help you write more robust and </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">efficient tests.</span></span></p>
<p><span class="koboSpan" id="kobo.570.1">In this section, we will cover the basics of writing tests with pytest, including creating test functions, using assertions to check for expected behavior, and organizing tests into </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">test suites.</span></span></p>
<p><span class="koboSpan" id="kobo.572.1">Now, let’s laser-focus on writing unit tests for a user registration component of </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">an application.</span></span></p>
<h2 id="_idParaDest-273"><a id="_idTextAnchor312"/><span class="koboSpan" id="kobo.574.1">Unit-testing user registration</span></h2>
<p><span class="koboSpan" id="kobo.575.1">Unit testing is a </span><a id="_idIndexMarker1086"/><span class="koboSpan" id="kobo.576.1">crucial part of the software development process. </span><span class="koboSpan" id="kobo.576.2">Unit testing unarguably allows developers to verify that their code works correctly and reliably, as stated earlier. </span><span class="koboSpan" id="kobo.576.3">One area where unit testing is particularly important is user registration, which is a critical part of </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">many applications.</span></span></p>
<p><span class="koboSpan" id="kobo.578.1">A user registration feature typically involves collecting user input, validating the input, storing it in a database, and sending a confirmation email to the user. </span><span class="koboSpan" id="kobo.578.2">Testing these features thoroughly is important to ensure that it works as intended and that users can register successfully </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">and securely.</span></span></p>
<p><span class="koboSpan" id="kobo.580.1">In this context, unit tests can be used to verify that the registration feature handles various scenarios correctly, such as valid and invalid inputs, duplicate usernames, and </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">email </span></span><span class="No-Break"><a id="_idIndexMarker1087"/></span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">confirmation.</span></span></p>
<p><span class="koboSpan" id="kobo.583.1">Let’s examine a unit test implementation for </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">user registration.</span></span></p>
<h3><span class="koboSpan" id="kobo.585.1">User creation unit test</span></h3>
<p><span class="koboSpan" id="kobo.586.1">Let’s test that </span><a id="_idIndexMarker1088"/><a id="_idTextAnchor313"/><span class="koboSpan" id="kobo.587.1">new users can be created and saved to the database. </span><span class="koboSpan" id="kobo.587.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">tests</span></strong><span class="koboSpan" id="kobo.589.1"> directory, create </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">test_user_login_creation.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.592.1">def test_create_user(db):    # Create a new user
    user = User(username='testuser',
        password='testpassword',
            email='test@example.com')
    #Add the user to the database
    db.session.add(user)
    db.session.commit()
    # Retrieve the user from the database
    retrieved_user = db.session.query(User)
        .filter_by(username='testuser').first()
    # Assert that the retrieved user matches the original
      user
    assert retrieved_user is not None
    assert retrieved_user.username == 'testuser'
    assert retrieved_user.email == 'test@example.com'</span></pre>
<p><span class="koboSpan" id="kobo.593.1">In the preceding test snippet, we created a new user with a specific </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">username</span></strong><span class="koboSpan" id="kobo.595.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">password</span></strong><span class="koboSpan" id="kobo.597.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">email address</span></strong><span class="koboSpan" id="kobo.599.1">. </span><span class="koboSpan" id="kobo.599.2">Then, we added the user to the database and commited the changes. </span><span class="koboSpan" id="kobo.599.3">Finally, we retrieved the user from the database using a query and asserted that the retrieved user matches the original user in all fields. </span><span class="koboSpan" id="kobo.599.4">This test ensures that new</span><a id="_idIndexMarker1089"/><span class="koboSpan" id="kobo.600.1"> users can be successfully created and saved to </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">the database.</span></span></p>
<h3><span class="koboSpan" id="kobo.602.1">Input validation unit test</span></h3>
<p><span class="koboSpan" id="kobo.603.1">Let’s test </span><a id="_idIndexMarker1090"/><span class="koboSpan" id="kobo.604.1">that the registration form validates user input correctly and returns appropriate error messages for </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">invalid input:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.606.1">def test_user_registration_input_validation(client, db):    # Attempt to register a new user with an invalid
      username
    response = client.post('/register',
        data={'username': 'a'*51,
            'password': 'testpassword',
                'email': 'test@example.com'})
    # Assert that the response status code is 200 OK
    assert response.status_code == 200
    # Assert that an error message is displayed for the
      invalid username
    assert b'Invalid username. </span><span class="koboSpan" id="kobo.606.2">Must be between 1 and 50
        characters.' </span><span class="koboSpan" id="kobo.606.3">in response.data
    # Attempt to register a new user with an invalid email
      address
    response = client.post('/register',
        data={'username': 'testuser',
            'password': 'testpassword',
                'email': 'invalid-email'})
    # Assert that the response status code is 200 OK
    assert response.status_code == 200
    # Assert that an error message is displayed for the
      invalid email address
    assert b'Invalid email address.' </span><span class="koboSpan" id="kobo.606.4">in response.data
    # Attempt to register a new user with a password that
      is too short
    response = client.post('/register',
        data={'username': 'testuser',
            'password': 'short',
                'email': 'test@example.com'})
    # Assert that the response status code is 200 OK
    assert response.status_code == 200
    # Assert that an error message is displayed for the
      short password
    assert b'Password must be at least 8 characters long.'
</span><span class="koboSpan" id="kobo.606.5">        in response.data</span></pre>
<p><span class="koboSpan" id="kobo.607.1">In the preceding</span><a id="_idIndexMarker1091"/><span class="koboSpan" id="kobo.608.1"> test, we simulated attempts to register a new user with various invalid inputs, such as an invalid </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">username</span></strong><span class="koboSpan" id="kobo.610.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">email address</span></strong><span class="koboSpan" id="kobo.612.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">password</span></strong><span class="koboSpan" id="kobo.614.1"> properties that are too short. </span><span class="koboSpan" id="kobo.614.2">We sent </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">POST</span></strong><span class="koboSpan" id="kobo.616.1"> requests to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">'/register'</span></strong><span class="koboSpan" id="kobo.618.1"> endpoint with this invalid input data and asserted that the response status code was </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">200 OK</span></strong><span class="koboSpan" id="kobo.620.1">, indicating that the registration form was submitted successfully, but </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">with errors.</span></span></p>
<p><span class="koboSpan" id="kobo.622.1">Then, we asserted that the appropriate error messages were displayed on the page for each invalid input. </span><span class="koboSpan" id="kobo.622.2">This test ensures that the registration form correctly validates the user input </span><a id="_idIndexMarker1092"/><span class="koboSpan" id="kobo.623.1">and returns appropriate error messages for </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">invalid input.</span></span></p>
<p><span class="koboSpan" id="kobo.625.1">Next, we will examine unit testing the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">login</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.627.1"> component.</span></span></p>
<h2 id="_idParaDest-274"><a id="_idTextAnchor314"/><span class="koboSpan" id="kobo.628.1">Unit-testing user login</span></h2>
<p><span class="koboSpan" id="kobo.629.1">Unit testing </span><a id="_idIndexMarker1093"/><span class="koboSpan" id="kobo.630.1">user login involves testing the functionality of the code responsible for authenticating a user who attempts to log into an application. </span><span class="koboSpan" id="kobo.630.2">This typically involves verifying that user credentials are correct and that the appropriate response is returned based on whether the authentication was successful </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">or not.</span></span></p>
<p><span class="koboSpan" id="kobo.632.1">Unit testing in this context can help ensure that the login process is reliable and secure, with appropriate error handling for invalid login attempts. </span><span class="koboSpan" id="kobo.632.2">Additionally, unit testing can help identify potential vulnerabilities in the login process, such as injection attacks or </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">password-guessing attempts.</span></span></p>
<h3><span class="koboSpan" id="kobo.634.1">User with valid credentials unit test</span></h3>
<p><span class="koboSpan" id="kobo.635.1">Let’s test that </span><a id="_idIndexMarker1094"/><span class="koboSpan" id="kobo.636.1">a user with valid credentials can successfully log in and access </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">the application:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.638.1">def test_user_login(client, user):    # Login with valid credentials
    response = client.post('/login',
        data={'username': user.username,
            'password': user.password},
        follow_redirects=True)
    # Check that the response status code is 200 OK
    assert response.status_code == 200
    # Check that the user is redirected to the home page
      after successful login
    assert b'Welcome to the application!' </span><span class="koboSpan" id="kobo.638.2">in response.data</span></pre>
<p><span class="koboSpan" id="kobo.639.1">In the preceding test, we’re using the client fixture to simulate a user logging in by sending a </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">POST</span></strong><span class="koboSpan" id="kobo.641.1"> request to the login endpoint with valid credentials. </span><span class="koboSpan" id="kobo.641.2">We’re also using the user fixture to create a test user with valid credentials. </span><span class="koboSpan" id="kobo.641.3">After sending the login request, we check that the response status code is </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">200 OK</span></strong><span class="koboSpan" id="kobo.643.1"> and that the user is redirected</span><a id="_idIndexMarker1095"/><span class="koboSpan" id="kobo.644.1"> to the home page, which indicates that the login </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">was successful.</span></span></p>
<h3><span class="koboSpan" id="kobo.646.1">User with invalid credentials unit test</span></h3>
<p><span class="koboSpan" id="kobo.647.1">Let’s test that a</span><a id="_idIndexMarker1096"/><span class="koboSpan" id="kobo.648.1"> user with invalid credentials cannot log in and receives an appropriate </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">error message:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.650.1">def test_login_invalid_credentials(client):    # Try to log in with invalid credentials
    response = client.post('/login',
        data={'username': 'nonexistentuser',
        'password': 'wrongpassword'})
    # Check that the response status code is 401
      Unauthorized
    assert response.status_code == 401
    # Check that the response contains the expected error
      message
    assert b'Invalid username or password' in response.data</span></pre>
<p><span class="koboSpan" id="kobo.651.1">In the preceding</span><a id="_idIndexMarker1097"/><span class="koboSpan" id="kobo.652.1"> test, we are trying to log in with a username and password that are not valid, and we expect the server to respond with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">401 Unauthorized</span></strong><span class="koboSpan" id="kobo.654.1"> status code and an error message indicating that the credentials </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">were invalid.</span></span></p>
<h3><span class="koboSpan" id="kobo.656.1">Testing SQL injection attacks</span></h3>
<p><span class="koboSpan" id="kobo.657.1">Let’s test that the </span><a id="_idIndexMarker1098"/><span class="koboSpan" id="kobo.658.1">code is properly validating user input to prevent SQL </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">injection attacks:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.660.1">def test_sql_injection_attack_login(client):    # Attempt to login with a username that contains SQL
      injection attack code
    response = client.post('/login',
        data={'username': "'; DROP TABLE users; --",
            'password': 'password'})
    # Check that the response status code is 401
      Unauthorized
    assert response.status_code == 401
    # Check that the user was not actually logged in
    assert current_user.is_authenticated == False</span></pre>
<p><span class="koboSpan" id="kobo.661.1">In the preceding test, we are attempting to use SQL injection attack code as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">username</span></strong><span class="koboSpan" id="kobo.663.1"> input in the login form. </span><span class="koboSpan" id="kobo.663.2">The test checks that the response status code is </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">401 Unauthorized</span></strong><span class="koboSpan" id="kobo.665.1">, indicating that the attack was not successful, and the user was not </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">logged in.</span></span></p>
<p><span class="koboSpan" id="kobo.667.1">It also checks that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">current_user.is_authenticated</span></strong><span class="koboSpan" id="kobo.669.1"> attribute is </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">False</span></strong><span class="koboSpan" id="kobo.671.1">, confirming that the user is not authenticated. </span><span class="koboSpan" id="kobo.671.2">This test helps ensure that the code is properly</span><a id="_idIndexMarker1099"/><span class="koboSpan" id="kobo.672.1"> validating user input to prevent SQL </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">injection attacks.</span></span></p>
<h3><span class="koboSpan" id="kobo.674.1">Testing for password strength</span></h3>
<p><span class="koboSpan" id="kobo.675.1">Let’s test</span><a id="_idIndexMarker1100"/><span class="koboSpan" id="kobo.676.1"> that the code is properly validating user passwords to ensure they meet the minimum complexity requirements (for example, a minimum length, the requirement of special characters, and </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">so on):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.678.1">def test_password_strength():    # Test that a password with valid length and characters
      is accepted
    assert check_password_strength("abc123XYZ!") == True
    # Test that a password with an invalid length is rejected
    assert check_password_strength("abc") == False
    # Test that a password without any special characters
      is rejected
    assert check_password_strength("abc123XYZ") == False
    # Test that a password without any lowercase letters is
      rejected
    assert check_password_strength("ABC123!") == False
    # Test that a password without any uppercase letters is
      rejected
    assert check_password_strength("abc123!") == False
    # Test that a password without any numbers is rejected
    assert check_password_strength("abcXYZ!") == False</span></pre>
<p><span class="koboSpan" id="kobo.679.1">In the</span><a id="_idIndexMarker1101"/><span class="koboSpan" id="kobo.680.1"> preceding test, </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">check_password_strength()</span></strong><span class="koboSpan" id="kobo.682.1"> is a function that takes a password string as input and returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">True</span></strong><span class="koboSpan" id="kobo.684.1"> if it meets the minimum complexity requirements and </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">False</span></strong><span class="koboSpan" id="kobo.686.1"> otherwise. </span><span class="koboSpan" id="kobo.686.2">This unit test verifies that the function works as expected by testing </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">various scenarios.</span></span></p>
<p><span class="koboSpan" id="kobo.688.1">With the use of a testing framework, Pytest, and writing effective unit tests, developers can catch bugs and defects early on, reducing the risk of errors in production and improving the overall quality and reliability of their </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">code base.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.690.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.691.1">The preceding tests assumed that you have a Flask application set up with routes for user registration and login, as well as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">SQLAlchemy</span></strong><span class="koboSpan" id="kobo.693.1"> database with a user model. </span><span class="koboSpan" id="kobo.693.2">We also assume that you have a test client configured with Pytest’s Flask test client </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">fixture (client).</span></span></p>
<p><span class="koboSpan" id="kobo.695.1">Next, we will look at testing JSON APIs to make sure that the API endpoints work </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">as expected.</span></span></p>
<h1 id="_idParaDest-275"><a id="_idTextAnchor315"/><span class="koboSpan" id="kobo.697.1">Testing JSON APIs</span></h1>
<p><span class="koboSpan" id="kobo.698.1">Testing JSON APIs is an</span><a id="_idIndexMarker1102"/><span class="koboSpan" id="kobo.699.1"> essential part of developing any web application that communicates with external clients. </span><span class="koboSpan" id="kobo.699.2">APIs provide a simple and flexible way to exchange data between the server and the client. </span><span class="koboSpan" id="kobo.699.3">APIs are critical to ensure that the APIs work as expected before they are exposed to </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">external users.</span></span></p>
<p><span class="koboSpan" id="kobo.701.1">Unit-testing JSON APIs involves verifying that the API endpoints return the expected results for different types of input data and handling error cases. </span><span class="koboSpan" id="kobo.701.2">Additionally, it’s essential to ensure that the API follows industry-standard protocols and is secure against common web vulnerabilities. </span><span class="koboSpan" id="kobo.701.3">In this way, developers can ensure the reliability and security of the web application and minimize the risk of errors or </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">security breaches.</span></span></p>
<p><span class="koboSpan" id="kobo.703.1">Let’s go through a test suite with four tests – </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">test_get_all_speakers</span></strong><span class="koboSpan" id="kobo.705.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">test_create_speaker</span></strong><span class="koboSpan" id="kobo.707.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">test_update_speaker</span></strong><span class="koboSpan" id="kobo.709.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">test_delete_speaker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.713.1">import pytestimport requests
# Define the base URL for the speakers API
BASE_URL = 'https://localhost:5000/v1/api/speakers/'
def test_get_all_speakers():
    # Send a GET request to the speakers API to retrieve
      all speakers
    response = requests.get(BASE_URL)
    # Check that the response has a status code of 200 OK
    assert response.status_code == 200
    # Check that the response contains a JSON object with a
      list of speakers
    assert isinstance(response.json(), list)</span></pre>
<p><span class="koboSpan" id="kobo.714.1">The preceding</span><a id="_idIndexMarker1103"/><span class="koboSpan" id="kobo.715.1"> test, </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">test_get_all_speakers</span></strong><span class="koboSpan" id="kobo.717.1">, sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">GET</span></strong><span class="koboSpan" id="kobo.719.1"> request to the speakers API to retrieve all speakers and then checks that the response has a status code of </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">200 OK</span></strong><span class="koboSpan" id="kobo.721.1"> and contains a JSON object with a list </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">of speakers.</span></span></p>
<h2 id="_idParaDest-276"><a id="_idTextAnchor316"/><span class="koboSpan" id="kobo.723.1">Testing speaker data creation</span></h2>
<p><span class="koboSpan" id="kobo.724.1">The following</span><a id="_idIndexMarker1104"/><span class="koboSpan" id="kobo.725.1"> test, </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">test_create_speaker</span></strong><span class="koboSpan" id="kobo.727.1">, defines a speaker data object to be created, sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">POST</span></strong><span class="koboSpan" id="kobo.729.1"> request to the Speakers API to create a new speaker using this data, and then checks that the response has a status code of </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">201 CREATED</span></strong><span class="koboSpan" id="kobo.731.1"> and contains a JSON object with the newly created </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">speaker data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.733.1">def test_create_speaker():    # Define the speaker data to be created
    speaker_data = {
        'name': 'John Darwin',
        'topic': 'Python',
        'email': 'john@example.com',
        'phone': '555-555-5555'
    }
    # Send a POST request to the speakers API to create a
      new speaker
    response = requests.post(BASE_URL, json=speaker_data)
    # Check that the response has a status code of 201
      CREATED
    assert response.status_code == 201
    # Check that the response contains a JSON object with
      the newly created speaker data
    assert response.json()['name'] == 'John Darwin'
    assert response.json()['topic'] == 'Python'
    assert response.json()['email'] == 'john@example.com'
    assert response.json()['phone'] == '555-555-5555'</span></pre>
<h2 id="_idParaDest-277"><a id="_idTextAnchor317"/><span class="koboSpan" id="kobo.734.1">Updating the speaker data object</span></h2>
<p><span class="koboSpan" id="kobo.735.1">The following </span><a id="_idIndexMarker1105"/><span class="koboSpan" id="kobo.736.1">test code, </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">test_update_speaker</span></strong><span class="koboSpan" id="kobo.738.1">, defines a speaker data object to be updated, sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">PUT</span></strong><span class="koboSpan" id="kobo.740.1"> request to the Speakers API to update the speaker with </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">id 1</span></strong><span class="koboSpan" id="kobo.742.1"> using this data, and then checks that the response has a status code of </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">200</span></strong><span class="koboSpan" id="kobo.744.1"> for a </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">successful update:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.746.1">def test_update_speaker():    # Define the speaker data to be updated
    speaker_data = {
        'name': 'John Doe',
        'topic': 'Python for Data Science',
        'email': 'johndoe@example.com',
        'phone': '555-555-5555'
    }
    # Send a PUT request to the speakers API to update the
      speaker data
    response = requests.put(BASE_URL + '1',
        json=speaker_data)
    # Check that the response has a status code of 200 OK
    assert response.status_code == 200
    # Check that the response contains a JSON object with
      the updated speaker data
    assert response.json()['name'] == 'John Darwin'
    assert response.json()['topic'] == 'Python for Data
        Science'
    assert response.json()['email'] == 'john@example.com'
    assert response.json()['phone'] == '555-555-5555'</span></pre>
<h2 id="_idParaDest-278"><a id="_idTextAnchor318"/><span class="koboSpan" id="kobo.747.1">Testing the deletion of the speaker data object</span></h2>
<p><span class="koboSpan" id="kobo.748.1">The following </span><a id="_idIndexMarker1106"/><span class="koboSpan" id="kobo.749.1">code snippet sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">DELETE</span></strong><span class="koboSpan" id="kobo.751.1"> request to the Speakers API to delete the speaker with </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">ID 1</span></strong><span class="koboSpan" id="kobo.753.1">. </span><span class="koboSpan" id="kobo.753.2">The test function checks that the response has a status code of </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">204 NO CONTENT</span></strong><span class="koboSpan" id="kobo.755.1">. </span><span class="koboSpan" id="kobo.755.2">If the speaker with </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">ID 1</span></strong><span class="koboSpan" id="kobo.757.1"> is successfully deleted from the API, the response from the API should have a status code of </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">204 NO CONTENT</span></strong><span class="koboSpan" id="kobo.759.1">. </span><span class="koboSpan" id="kobo.759.2">If the speaker is not found or if there is an error in the delete request, the response status code will be different, and the test </span><span class="No-Break"><span class="koboSpan" id="kobo.760.1">will fail:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.761.1">def test_delete_speaker():    # Send a DELETE request to the speakers API to delete
      the speaker with ID 1
    response = requests.delete(BASE_URL + '1')
    # Check that the response has a status code of 204 NO
      CONTENT
    assert response.status_code == 204</span></pre>
<p><span class="koboSpan" id="kobo.762.1">At this point, you might be wondering, why do we need to invest time and resources into rectifying bugs once they’ve emerged in our application when it’s entirely possible to proactively</span><a id="_idIndexMarker1107"/><span class="koboSpan" id="kobo.763.1"> forestall their occurrence from </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">the outset?</span></span></p>
<p><span class="koboSpan" id="kobo.765.1">Next, we will discuss TDD using Flask as a significant proactive approach to </span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">software development!</span></span></p>
<h1 id="_idParaDest-279"><a id="_idTextAnchor319"/><span class="koboSpan" id="kobo.767.1">Test-driven development with Flask</span></h1>
<p><span class="koboSpan" id="kobo.768.1">TDD is a software</span><a id="_idIndexMarker1108"/><span class="koboSpan" id="kobo.769.1"> development approach</span><a id="_idIndexMarker1109"/><span class="koboSpan" id="kobo.770.1"> where you write automated tests before writing the actual code. </span><span class="koboSpan" id="kobo.770.2">The process involves writing a test case for a specific feature or functionality and then writing the minimum amount of code necessary to make the test pass. </span><span class="koboSpan" id="kobo.770.3">Once the test passes, you write additional tests to cover different edge cases and functionality until you have fully implemented the </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">desired feature.</span></span></p>
<p><span class="koboSpan" id="kobo.772.1">Using Flask with an attendee endpoint as a case study, the TDD process might look </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">like this:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.774.1">Define the feature</span></strong><span class="koboSpan" id="kobo.775.1">: The first step is to define the feature you want to implement. </span><span class="koboSpan" id="kobo.775.2">In this case, the feature is an endpoint that allows users to view a list of attendees for </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">an event.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.777.1">Write a test case</span></strong><span class="koboSpan" id="kobo.778.1">: Next, you must write a test case that defines the expected behavior of the endpoint. </span><span class="koboSpan" id="kobo.778.2">For example, you might write a test that checks that the endpoint returns a JSON response with a list </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">of attendees.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.780.1">Run the test</span></strong><span class="koboSpan" id="kobo.781.1">: You then run the test, which will fail since you haven’t implemented the </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">endpoint yet.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.783.1">Write the minimum amount of code</span></strong><span class="koboSpan" id="kobo.784.1">: You write the minimum amount of code necessary to make the test pass. </span><span class="koboSpan" id="kobo.784.2">In this case, you would write the code for the </span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">attendee endpoint.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.786.1">Run the test again</span></strong><span class="koboSpan" id="kobo.787.1">: Then, you must run the test again, which should now pass since you’ve implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">the endpoint.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.789.1">Write additional tests</span></strong><span class="koboSpan" id="kobo.790.1">: Finally, you must write additional tests to cover different edge cases and functionality. </span><span class="koboSpan" id="kobo.790.2">For example, you might write a test that checks that the endpoint returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">404</span></strong><span class="koboSpan" id="kobo.792.1"> error if the event </span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">doesn’t exist.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.794.1">Now, let’s</span><a id="_idIndexMarker1110"/><span class="koboSpan" id="kobo.795.1"> implement </span><a id="_idIndexMarker1111"/><span class="koboSpan" id="kobo.796.1">the attendee’s endpoint using the TDD approach, starting with a failed test case since we haven’t implemented the </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">endpoint yet.</span></span></p>
<h2 id="_idParaDest-280"><a id="_idTextAnchor320"/><span class="koboSpan" id="kobo.798.1">Defining the feature</span></h2>
<p><span class="koboSpan" id="kobo.799.1">The first step is to </span><a id="_idIndexMarker1112"/><span class="koboSpan" id="kobo.800.1">define the feature you want to implement. </span><span class="koboSpan" id="kobo.800.2">In this case, the feature is an endpoint that allows users to view a list of attendees for </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">an event.</span></span></p>
<h2 id="_idParaDest-281"><a id="_idTextAnchor321"/><span class="koboSpan" id="kobo.802.1">Writing a failed test case</span></h2>
<p><span class="koboSpan" id="kobo.803.1">The next step is to</span><a id="_idIndexMarker1113"/><span class="koboSpan" id="kobo.804.1"> write a test case that checks that the attendee endpoint returns the expected data. </span><span class="koboSpan" id="kobo.804.2">This test should fail initially since we haven’t implemented the </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">endpoint yet.</span></span></p>
<p><span class="koboSpan" id="kobo.806.1">Create </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">test_attendees.py</span></strong><span class="koboSpan" id="kobo.808.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">tests</span></strong><span class="koboSpan" id="kobo.810.1"> directory and add the following code </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">bizza/backend/tests/test_attendees.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.814.1">from flask import Flask, jsonifyimport pytest
app = Flask(__name__)
@pytest.fixture
def client():
    with app.test_client() as client:
        yield client
def test_attendees_endpoint_returns_correct_data(client):
    response = client.get('/events/123/attendees')
    expected_data = [{'name': 'John Darwin',
        'email': 'john@example.com'},
            {'name': 'Jane Smith',
                'email': 'jane@example.com'}]
    assert response.json == expected_data</span></pre>
<h2 id="_idParaDest-282"><a id="_idTextAnchor322"/><span class="koboSpan" id="kobo.815.1">Implementing the minimal amount of code to pass the test</span></h2>
<p><span class="koboSpan" id="kobo.816.1">Now, we can</span><a id="_idIndexMarker1114"/><span class="koboSpan" id="kobo.817.1"> implement the attendee endpoint function to return the hardcoded data. </span><span class="koboSpan" id="kobo.817.2">This is the minimal amount of code necessary to make the </span><span class="No-Break"><span class="koboSpan" id="kobo.818.1">test pass:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.819.1"># Define the attendee endpoint@app.route('/events/&lt;int:event_id&gt;/attendees')
def get_attendees(event_id):
    # Return a hardcoded list of attendees as a JSON
      response
    attendees = [{'name': 'John Darwin',
        'email': 'john@example.com'},
            {'name': 'Jane Smith',
                'email': 'jane@example.com'}]
    return jsonify(attendees)</span></pre>
<h2 id="_idParaDest-283"><a id="_idTextAnchor323"/><span class="koboSpan" id="kobo.820.1">Running the test and ensuring it passes</span></h2>
<p><span class="koboSpan" id="kobo.821.1">Run the test </span><a id="_idIndexMarker1115"/><span class="koboSpan" id="kobo.822.1">again to ensure that it </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">now passes:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.824.1">$ pytest test_attendees.py----------------------------------------------------------------------
Ran 1 test in 0.001s
OK</span></pre>
<h2 id="_idParaDest-284"><a id="_idTextAnchor324"/><span class="koboSpan" id="kobo.825.1">Refactoring the code</span></h2>
<p><span class="koboSpan" id="kobo.826.1">Now that we </span><a id="_idIndexMarker1116"/><span class="koboSpan" id="kobo.827.1">have a passing test, we can refactor the code to make it more maintainable, efficient, and readable. </span><span class="koboSpan" id="kobo.827.2">For example, we could replace the hardcoded data with data retrieved from a database or </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">external API.</span></span></p>
<h2 id="_idParaDest-285"><a id="_idTextAnchor325"/><span class="koboSpan" id="kobo.829.1">Writing additional tests</span></h2>
<p><span class="koboSpan" id="kobo.830.1">Finally, we </span><a id="_idIndexMarker1117"/><span class="koboSpan" id="kobo.831.1">can write additional test cases to ensure that the endpoint behaves correctly in different scenarios. </span><span class="koboSpan" id="kobo.831.2">For example, we might write tests to ensure that the endpoint handles invalid input correctly, or that it returns an empty list if no attendees are found for a </span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">given event.</span></span></p>
<p><span class="koboSpan" id="kobo.833.1">With the TDD process, you can ensure that your code is thoroughly tested and that you’ve implemented all the desired functionalities. </span><span class="koboSpan" id="kobo.833.2">This approach can help you catch bugs early in the development process and make it easier to maintain and refactor your code in </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">the future.</span></span></p>
<p><span class="koboSpan" id="kobo.835.1">So far, we have discussed TDD as a software development approach where tests are created before the actual code implementation. </span><span class="koboSpan" id="kobo.835.2">This approach encourages developers to write tests that define the expected behavior of their code and then write the code itself to make </span><a id="_idIndexMarker1118"/><span class="koboSpan" id="kobo.836.1">the tests pass. </span><span class="koboSpan" id="kobo.836.2">Next, we will delve into the realm of exception handling in a test suite </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">in Flask.</span></span></p>
<h1 id="_idParaDest-286"><a id="_idTextAnchor326"/><span class="koboSpan" id="kobo.838.1">Handling exceptions</span></h1>
<p><span class="koboSpan" id="kobo.839.1">Handling exceptions </span><a id="_idIndexMarker1119"/><span class="koboSpan" id="kobo.840.1">with unit testing is a software development technique that involves testing how a piece of code handles different types of exceptions that may occur during runtime. </span><span class="koboSpan" id="kobo.840.2">Exceptions can be triggered by a variety of factors, such as invalid input, unexpected input, or issues with the environment in which the code </span><span class="No-Break"><span class="koboSpan" id="kobo.841.1">is running.</span></span></p>
<p><span class="koboSpan" id="kobo.842.1">Unit testing is the practice of writing small, automated tests to ensure that individual units of code are working as expected. </span><span class="koboSpan" id="kobo.842.2">When it comes to handling exceptions, unit tests can help ensure that the code responds appropriately to various error conditions. </span><span class="koboSpan" id="kobo.842.3">As a developer, you need to test that your code can handle exceptions gracefully. </span><span class="koboSpan" id="kobo.842.4">You can simulate these error conditions in a controlled environment so that you have more confidence in your code’s ability to handle exceptions that </span><span class="No-Break"><span class="koboSpan" id="kobo.843.1">may occur.</span></span></p>
<p><span class="koboSpan" id="kobo.844.1">For instance, in the case of a Flask application with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">attendees</span></strong><span class="koboSpan" id="kobo.846.1"> endpoint, you may want to test how the application handles requests for events with no attendees. </span><span class="koboSpan" id="kobo.846.2">By writing a unit test that sends a request to the endpoint with an event that has no attendees, we can ensure that the application returns the appropriate error response code and message, rather than crashing or providing an </span><span class="No-Break"><span class="koboSpan" id="kobo.847.1">inaccurate response.</span></span></p>
<p><span class="koboSpan" id="kobo.848.1">Let’s dive into a code implementation of how you can handle exceptions for </span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">attendees’ endpoints:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.850.1">from flask import Flask, jsonifyapp = Flask(__name__)
class Event:
    def __init__(self, name):
        self.name = name
        self.attendees = []
    def add_attendee(self, name):
        self.attendees.append(name)
    def get_attendees(self):
        if not self.attendees:
            raise Exception("No attendees found for event")
        return self.attendees
@app.route('/event/&lt;event_name&gt;/attendees')
def get_attendees(event_name):
    try:
        event = Event(event_name)
        attendees = event.get_attendees()
    except Exception as e:
        return jsonify({'error': str(e)}), 404
    return jsonify(attendees)</span></pre>
<p><span class="koboSpan" id="kobo.851.1">In the preceding </span><a id="_idIndexMarker1120"/><span class="koboSpan" id="kobo.852.1">implementation, we’ve added a custom exception to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">Event</span></strong><span class="koboSpan" id="kobo.854.1"> class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">Exception("No attendees found for event")</span></strong><span class="koboSpan" id="kobo.856.1">. </span><span class="koboSpan" id="kobo.856.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">get_attendees</span></strong><span class="koboSpan" id="kobo.858.1"> method, if there are no attendees, we raise this exception. </span><span class="koboSpan" id="kobo.858.2">In the Flask endpoint function, we wrap the </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">Event</span></strong><span class="koboSpan" id="kobo.860.1"> instantiation and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">get_attendees</span></strong><span class="koboSpan" id="kobo.862.1"> call in a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">try/except</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.864.1"> block.</span></span></p>
<p><span class="koboSpan" id="kobo.865.1">If an exception is raised, we return a JSON response with the error message and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">404</span></strong><span class="koboSpan" id="kobo.867.1"> status code to indicate that the requested resource was </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">not found.</span></span></p>
<p><span class="koboSpan" id="kobo.869.1">Let’s examine the </span><span class="No-Break"><span class="koboSpan" id="kobo.870.1">test function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.871.1">def test_get_attendees_empty():    event_name = 'test_event'
    app = create_app()
    with app.test_client() as client:
        response =
            client.get(f'/event/{event_name}/attendees')
        assert response.status_code == 404
        assert response.json == {'error': 'No attendees
            found for event'}
def test_get_attendees():
    event_name = 'test_event'
    attendee_name = 'John Doe'
    event = Event(event_name)
    event.add_attendee(attendee_name)
    app = create_app()
    with app.test_client() as client:
        response =
            client.get(f'/event/{event_name}/attendees')
        assert response.status_code == 200
        assert response.json == [attendee_name]</span></pre>
<p><span class="koboSpan" id="kobo.872.1">In the first test function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">test_get_attendees_empty()</span></strong><span class="koboSpan" id="kobo.874.1">, we expect the endpoint to return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">404</span></strong><span class="koboSpan" id="kobo.876.1"> status code and an error message JSON response because there are no attendees for the event. </span><span class="koboSpan" id="kobo.876.2">In the second test, </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">test_get_attendees()</span></strong><span class="koboSpan" id="kobo.878.1">, we add an attendee to the event and expect the endpoint to return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">200</span></strong><span class="koboSpan" id="kobo.880.1"> status code and a JSON response containing the </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">attendee’s name.</span></span></p>
<p><span class="koboSpan" id="kobo.882.1">When you test for</span><a id="_idIndexMarker1121"/><span class="koboSpan" id="kobo.883.1"> expected exceptions and handle them gracefully in your code, you can ensure that your application behaves as expected and provides helpful error messages to users </span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">when needed.</span></span></p>
<h1 id="_idParaDest-287"><a id="_idTextAnchor327"/><span class="koboSpan" id="kobo.885.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.886.1">Unit testing, as a crucial aspect of Flask application development, ensures the reliability and functionality of application software. </span><span class="koboSpan" id="kobo.886.2">In this chapter, we learned how to structure and implement effective unit tests for various components of a Flask application. </span><span class="koboSpan" id="kobo.886.3">We explored how Pytest simplifies testing processes and enhances the productivity </span><span class="No-Break"><span class="koboSpan" id="kobo.887.1">of developers.</span></span></p>
<p><span class="koboSpan" id="kobo.888.1">This chapter covered the fundamentals of Pytest, including its introduction, setup process, basic syntax, and features. </span><span class="koboSpan" id="kobo.888.2">We discovered the importance of the setup and teardown methods, which help create a controlled testing environment and ensure the proper disposal of resources after each </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">test case.</span></span></p>
<p><span class="koboSpan" id="kobo.890.1">By applying these techniques, we were able to create more robust and isolated unit tests that mirror real-world scenarios. </span><span class="koboSpan" id="kobo.890.2">Furthermore, we provided guidelines on how to write unit tests, test JSON APIs, apply TDD, and handle exceptions in Flask applications. </span><span class="koboSpan" id="kobo.890.3">With the adoption of these practices, developers can improve the overall quality of their Flask applications and minimize the risk of errors </span><span class="No-Break"><span class="koboSpan" id="kobo.891.1">and bugs.</span></span></p>
<p><span class="koboSpan" id="kobo.892.1">As we move forward and wrap up our journey of building robust and scalable Flask applications, the next chapter will dive into the world of containerization and deployment. </span><span class="koboSpan" id="kobo.892.2">We will explore how to containerize Flask applications, allowing us to replicate development environments and effortlessly deploy our applications to </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">various platforms.</span></span></p>
<p><span class="koboSpan" id="kobo.894.1">We will also delve into deploying Flask applications to cloud services, harnessing the power of platforms such as Docker and AWS for efficient and </span><span class="No-Break"><span class="koboSpan" id="kobo.895.1">scalable deployment.</span></span></p>
</div>
</body></html>