- en: 16\. Using a Frontend JavaScript Library with Django
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16. 使用前端 JavaScript 库与 Django 结合
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces the basics of JavaScript and ends with building an interactive
    web frontend for Bookr using the React JavaScript framework. You will learn how
    to include the React JavaScript framework in a Django template, and how to build
    React components. This chapter also includes an introduction to `fetch` JavaScript
    function which is used to retrieve information from a REST API. Toward the end
    of the chapter, you will be introduced to the Django `{% verbatim %}` template
    tag, which is used to include unparsed data in a Django template.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 JavaScript 的基础知识，并以使用 React JavaScript 框架为 Bookr 构建交互式网页前端结束。你将学习如何在 Django
    模板中包含 React JavaScript 框架，以及如何构建 React 组件。本章还包括了 `fetch` JavaScript 函数的介绍，该函数用于从
    REST API 获取信息。在章节的末尾，你将了解到 Django `{% verbatim %}` 模板标签，它用于在 Django 模板中包含未解析的数据。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Django is a great tool for building the backend of an application. You have
    seen how easy it is to set up the database, route URLs, and render templates.
    Without using JavaScript, though, when those pages are rendered to the browser,
    they are static and do not provide any form of interaction. By using JavaScript,
    your pages can be transformed into applications that are fully interactive in
    the browser.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Django 是构建应用程序后端的一个优秀工具。你已经看到了设置数据库、路由 URL 和渲染模板是多么容易。然而，如果不使用 JavaScript，当这些页面渲染到浏览器时，它们是静态的，并且不提供任何形式的交互。通过使用
    JavaScript，你的页面可以变成在浏览器中完全交互的应用程序。
- en: This chapter will be a brief introduction to JavaScript frameworks and how to
    use them with Django. While it won't be a deep dive into how to build an entire
    JavaScript application from scratch (that would be a book in itself), we will
    give enough of an introduction so that you can add interactive components to your
    own Django application. In this chapter, we will primarily be working with the
    React framework. Even if you do not have any JavaScript experience, we will introduce
    enough about it so that, by the end of this chapter, you will be comfortable writing
    your own React components. In *Chapter 12*, *Building a REST API*, you built a
    REST API for Bookr. We will interact with that API using JavaScript to retrieve
    data. We will enhance Bookr by showing some review previews on the main page that
    are dynamically loaded and can be paged through.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将简要介绍 JavaScript 框架及其与 Django 的使用方法。虽然它不会深入探讨如何从头开始构建一个完整的 JavaScript 应用程序（那将是一本自己的书），但我们将提供足够的介绍，以便你可以在自己的
    Django 应用程序中添加交互式组件。在本章中，我们将主要使用 React 框架。即使你没有 JavaScript 经验，我们也会介绍足够的内容，以便在本章结束时，你将能够舒适地编写自己的
    React 组件。在 *第 12 章*，*构建 REST API* 中，你为 Bookr 构建了一个 REST API。我们将使用 JavaScript 与该
    API 交互以检索数据。我们将通过在主页上显示一些动态加载并可分页的评论预览来增强 Bookr。
- en: Note
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code for the exercises and activities in this chapter can be found in this
    book's GitHub repository at [http://packt.live/3iasIMl](http://packt.live/3iasIMl).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章练习和活动的代码可以在本书的 GitHub 仓库中找到，网址为 [http://packt.live/3iasIMl](http://packt.live/3iasIMl)。
- en: JavaScript Frameworks
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 框架
- en: 'These days, real-time interactivity is a fundamental part of web applications.
    While simple interactions can be added without a framework (developing without
    a framework is often called *Vanilla JS*), as your web application grows, it can
    be much easier to manage with the use of a framework. Without a framework, you
    would need to do all these things yourself:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，实时交互是网络应用程序的基本组成部分。虽然可以不使用框架添加简单的交互（不使用框架的开发通常被称为 *Vanilla JS*），但随着你的网络应用程序的增长，使用框架进行管理会容易得多。没有框架，你需要自己完成所有这些事情：
- en: Manually define the database schema.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动定义数据库模式。
- en: Convert data from HTTP requests into native objects.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 HTTP 请求中的数据转换为原生对象。
- en: Write form validation.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写表单验证。
- en: Write SQL queries to save data.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 SQL 查询以保存数据。
- en: Construct HTML to show a response.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 HTML 来显示响应。
- en: 'Compare this to what Django provides. Its **ORM** (**Object Relational Mapping**),
    automatic form parsing and validation, and templating drastically cut down on
    the amount of code you need to write. JavaScript frameworks bring similar time-saving
    enhancements to JavaScript development. Without them, you would have to manually
    update the HTML elements in the browser as your data changes. Let''s take a simple
    example: showing the count of the number of times a button has been clicked. Without
    a framework, you would have to do the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与Django提供的功能进行比较。它的**ORM**（**对象关系映射**）、自动表单解析和验证以及模板化大大减少了你需要编写的代码量。JavaScript框架为JavaScript开发带来了类似的时间节省增强。没有它们，你将不得不手动更新浏览器中的HTML元素，以适应数据的变化。让我们用一个简单的例子来说明：显示按钮被点击的次数。没有框架，你必须做以下事情：
- en: Assign a handler to the button click event.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为按钮点击事件分配处理程序。
- en: Increment the variable that stored the count.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加存储计数的变量。
- en: Locate the element containing the click count display.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位包含点击计数显示的元素。
- en: Replace the element's text with the new click count.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将元素的文本替换为新的点击计数。
- en: 'When using a framework, the button count variable is bound to the display (HTML),
    so the process you have to code is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用框架时，按钮计数变量绑定到显示（HTML），因此你需要编写的代码过程如下：
- en: Handle the button click.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理按钮点击。
- en: Increment the variable.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加变量。
- en: The framework takes care of automatically re-rendering the number display. This
    is just a simple example, though; as your application grows, the disparity in
    complexity between the two approaches expands. There are several JavaScript frameworks
    available, each with different features and some supported and used by large companies.
    Some of the most popular are React ([https://reactjs.org](https://reactjs.org)),
    Vue ([http://vuejs.org](http://vuejs.org)), Angular ([https://angularjs.org](https://angularjs.org)),
    Ember ([https://emberjs.com](https://emberjs.com)), and Backbone.js ([https://backbonejs.org](https://backbonejs.org)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 框架负责自动重新渲染数字显示。这只是一个简单的例子；随着你的应用程序的增长，两种方法之间的复杂性差异会扩大。有几个JavaScript框架可供选择，每个框架都有不同的功能，其中一些被大公司支持和使用。其中一些最受欢迎的是React
    ([https://reactjs.org](https://reactjs.org))、Vue ([http://vuejs.org](http://vuejs.org))、Angular
    ([https://angularjs.org](https://angularjs.org))、Ember ([https://emberjs.com](https://emberjs.com))
    和 Backbone.js ([https://backbonejs.org](https://backbonejs.org))。
- en: In this chapter, we will be using React, as it is easy to drop into an existing
    web application and allows *progressive enhancement*. This means that rather than
    having to build your application from scratch, targeting React, you can simply
    apply it to certain parts of the HTML that Django generates; for example, a single
    text field that automatically interprets Markdown and shows the result without
    reloading the page. We will also cover some of the features that Django offers
    that can help integrate several JavaScript frameworks.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用React，因为它很容易集成到现有的网络应用中，并允许*渐进增强*。这意味着你不必从头开始构建你的应用程序，针对React，你只需将其应用于Django生成的HTML的某些部分；例如，一个自动解释Markdown并显示结果的文本字段，而无需重新加载页面。我们还将介绍Django提供的一些功能，这些功能可以帮助集成多个JavaScript框架。
- en: 'There are several different levels that JavaScript can be incorporated into
    a web application at. *Figure 16.1* shows our current stack, with no JavaScript
    (note that the following diagrams do not show requests to the server):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 可以在多个不同的层级被整合到网络应用中。*图16.1* 展示了我们的当前堆栈，其中不包含JavaScript（注意以下图表没有显示对服务器的请求）：
- en: '![Figure 16.1: Current stack'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.1：当前堆栈'
- en: '](img/B15509_16_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15509_16_01.jpg]'
- en: 'Figure 16.1: Current stack'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1：当前堆栈
- en: 'You can base your entire application on JavaScript using **Node.js** (a server-side
    JavaScript interpreter), which would take the place of Python and Django in the
    stack. *Figure 16.2* shows how this might look:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用**Node.js**（一个服务器端JavaScript解释器）将整个应用程序基于JavaScript构建，这将取代堆栈中的Python和Django。*图16.2*
    展示了这可能看起来是什么样子：
- en: '![Figure 16.2: Using Node.js to generate HTML'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.2：使用Node.js生成HTML'
- en: '](img/B15509_16_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15509_16_02.jpg]'
- en: 'Figure 16.2: Using Node.js to generate HTML'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2：使用Node.js生成HTML
- en: 'Or, you can have your frontend and templates entirely in JavaScript, and just
    use Django to act as a REST API to provide data to render. *Figure 16.3* shows
    this stack:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以将你的前端和模板完全用JavaScript编写，只需使用Django作为REST API来提供渲染所需的数据。*图16.3* 展示了这个堆栈：
- en: '![Figure 16.3: Sending JSON from Django and rendering it in the browser'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.3：从Django发送JSON并在浏览器中渲染'
- en: '](img/B15509_16_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15509_16_03.jpg]'
- en: 'Figure 16.3: Sending JSON from Django and rendering it in the browser'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'The final approach is progressive enhancement, which is (as mentioned) what
    we will be using. In this way, Django is still generating the HTML templates and
    React sits on top of this to add interactivity:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.4: HTML generated with Django with React providing progressive
    enhancement'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_16_04.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.4: HTML generated with Django with React providing progressive enhancement'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Note that it is common to use multiple techniques together. For example, Django
    may generate the initial HTML to which React is applied in the browser. The browser
    can then query Django for JSON data to be rendered, using React.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Introduction
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will briefly introduce some basic JavaScript concepts, such
    as variables and functions. Different operators will be covered as we introduce
    them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '**Loading JavaScript**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript can either be inline in an HTML page or included from a separate
    JavaScript file. Both methods use the `<script>` tag. With inline JavaScript,
    the JavaScript code is written directly inside the `<script>` tags in an HTML
    file; for example, like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Note that the `console.log` function prints out data to the browser console
    that is visible in the developer tools of your browser:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.5: The result of the console.log(a) call – 5 is printed to the
    browser console'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_16_05.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.5: The result of the console.log(a) call – 5 is printed to the browser
    console'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also put the code into its own file (we would not include the `<script>`
    tags in the standalone file). We then load it into the page using the `<script>`
    tag''s `src` attribute, as we saw in *Chapter 5*, *Serving Static Files*:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The source code, whether inline or included, will be executed as soon as the
    browser loads the `<script>` tag.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '**Variables and Constants**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike in Python, variables in JavaScript must be declared, using either the
    `var`, `let`, or `const` keyword:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Just like in Python, though, a type for a variable does not need to be declared.
    You will notice that the lines end with semicolons. JavaScript does not require
    lines to be terminated with semicolons – they are optional. However, some style
    guides enforce their use. You should try to stick with a single convention for
    any project.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'You should use the `let` keyword to declare a variable. Variable declarations
    are scoped. For example, a variable declared with `let` inside a `for` loop will
    not be defined outside the loop. In this example, we''ll loop through and sum
    the multiples of 10 till 90, and then print the result to `console.log`. You''ll
    notice we can access variables declared at the function level inside the `for`
    loop, but not the other way around:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`const` is for constant data and cannot be redefined. That does not mean that
    the object it points to cannot be changed, though. For example, you couldn''t
    do this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `var` keyword is required by older browsers that don't support `let` or
    `const`. Only 1% of browsers these days don't support those keywords, so throughout
    the rest of the chapter, we will only use `let` or `const`. Like `let`, variables
    declared with `var` can be reassigned; however, they are scoped at the function
    level only.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`var` 关键字是旧版浏览器所必需的，这些浏览器不支持 `let` 或 `const`。如今只有 1% 的浏览器不支持这些关键字，所以在本章的其余部分，我们只会使用
    `let` 或 `const`。与 `let` 一样，使用 `var` 声明的变量可以被重新分配；然而，它们仅在函数级别有作用域。'
- en: JavaScript supports several different types of variables, including strings,
    arrays, objects (which are like dictionaries), and numbers. We will cover arrays
    and objects in their own sections now.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 支持多种不同类型的变量，包括字符串、数组、对象（类似于字典）和数字。现在我们将单独介绍数组和对象。
- en: '**Arrays**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组**'
- en: 'Arrays are defined similarly to how they are in Python, with square brackets.
    They can contain different types of data, just like with Python:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 数组定义的方式与 Python 中的定义类似，使用方括号。它们可以包含不同类型的数据，就像 Python 一样：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Another thing to remember with the use of `const` is that it prevents reassigning
    the constant but does not prevent changing the variable or object being pointed
    to. For example, we would not be allowed to do this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `const` 需要记住的另一件事是，它防止重新分配常量，但不会阻止更改所指向的变量或对象。例如，我们不允许这样做：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, you could update the contents of the `myThings` array by using the
    `push` method (like Python''s `list.append`) to append a new item:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以通过使用 `push` 方法（类似于 Python 的 `list.append`）来更新 `myThings` 数组的内容，添加一个新项目：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Objects**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象**'
- en: 'JavaScript objects are like Python dictionaries, providing a key-value store.
    The syntax to declare them is similar as well:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 对象类似于 Python 字典，提供键值存储。声明它们的语法也类似：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that, unlike Python, JavaScript object/dictionary keys do not need to be
    quoted when creating them – unless they contain special characters (spaces, dashes,
    dots, and more).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与 Python 不同，JavaScript 对象/字典的键在创建时不需要引号 – 除非它们包含特殊字符（空格、破折号、点等）。
- en: 'The values from `o` can be accessed either with item access or attribute access:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `o` 中获取值可以使用项目访问或属性访问：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Also note that since `o` was declared as a constant, we cannot reassign it,
    but we can alter the object''s attributes:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，由于 `o` 被声明为常量，我们无法重新分配它，但我们可以更改对象的属性：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Functions**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**'
- en: 'There are a few different ways to define functions in JavaScript. We will look
    at three. You can define them using the `function` keyword:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中定义函数有几种不同的方法。我们将探讨三种。你可以使用 `function` 关键字来定义它们：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'All arguments to a function are optional in JavaScript; that is, you could
    call the preceding function like this: `myFunc()`, and no error would be raised
    (at least during call time). The `a`, `b`, and `c` variables would all be the
    special type `undefined`. This would cause issues in the logic of the function.
    `undefined` is kind of like `None` in Python – although JavaScript also has `null`,
    which is more similar to `None`. Functions can also be defined by assigning them
    to a variable (or constant):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，所有函数的参数都是可选的；也就是说，你可以像这样调用前面的函数：`myFunc()`，而不会引发错误（至少在调用时不会）。变量
    `a`、`b` 和 `c` 都将是特殊类型 `undefined`。这可能会在函数的逻辑中引起问题。`undefined` 在 Python 中类似于 `None`
    – 尽管JavaScript也有 `null`，它更类似于 `None`。函数也可以通过将它们分配给变量（或常量）来定义：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can also define functions using an arrow syntax. For example, we can also
    define `myFunc` like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用箭头语法来定义函数。例如，我们也可以这样定义 `myFunc`：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is more common when defining functions as part of an object, for example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当将函数作为对象的一部分定义时，这种情况更为常见，例如：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this case, it would be called like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它将这样调用：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We will return to the reasons for using arrow functions after introducing classes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍类之后，我们将回到使用箭头函数的原因。
- en: '**Classes and Methods**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**类和方法**'
- en: 'Classes are defined with the `class` keyword. Inside a `class` definition,
    methods are defined without the `function` keyword. The JavaScript interpreter
    can recognize the syntax and tell that it is a method. Here is an example class,
    which takes a number to add (through `toAdd`) when instantiated. That number will
    be added to whatever is passed to the `add` method, and the result returned:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 类使用 `class` 关键字定义。在类定义内部，方法定义时不使用 `function` 关键字。JavaScript 解释器可以识别这种语法，并知道它是一个方法。以下是一个示例类，它通过
    `toAdd` 参数接收一个数字，当实例化时。这个数字将被添加到传递给 `add` 方法的任何内容上，并返回结果：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Classes are instantiated with the `new` keyword. Other than that, their usage
    is very similar to classes in Python:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 类使用 `new` 关键字实例化。除此之外，它们的用法与 Python 中的类非常相似：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Arrow Functions**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**箭头函数**'
- en: Now that we've introduced the `this` keyword, we can return to the purpose of
    arrow functions. Not only are they shorter to write, but they also preserve the
    context of `this`. Unlike `self` in Python, which always refers to a specific
    object because it is passed into methods, the object that `this` refers to can
    change based on context. Usually, it is due to the nesting of functions, which
    is common in JavaScript.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了 `this` 关键字，我们可以回到箭头函数的目的。它们不仅更易于编写，而且还能保留 `this` 的上下文。与 Python 中的
    `self` 不同，`self` 总是指向特定的对象，因为它被传递到方法中，而 `this` 指向的对象可以根据上下文而变化。通常，这是由于函数的嵌套，这在
    JavaScript 中很常见。
- en: 'Let''s look at two examples. First, an object with a function called `outer`.
    This `outer` function contains an `inner` function. We refer to `this` in both
    the `inner` and `outer` functions:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两个例子。首先，一个名为 `outer` 的函数对象。这个 `outer` 函数包含一个 `inner` 函数。我们在 `inner` 和 `outer`
    函数中都引用了 `this`：
- en: Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: The next code example refers to the `window` object. In JavaScript, `window`
    is a special global variable that exists in each browser tab and represents information
    about that tab. It is an instance of the `window` class. Some examples of the
    attributes `window` has are `document` (which stores the current HTML document),
    `location` (which is the current location shown in the tab's address bar), and
    `outerWidth` and `outerHeight` (which represent the width and height of the browser
    window respectively). For example, to print the current tab's location to the
    browser console, you would write `console.log(window.location)`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码示例涉及 `window` 对象。在 JavaScript 中，`window` 是一个特殊的全局变量，存在于每个浏览器标签中，并代表该标签的信息。它是
    `window` 类的一个实例。`window` 具有的属性示例包括 `document`（存储当前的 HTML 文档）、`location`（在标签的地址栏中显示的当前位置）以及
    `outerWidth` 和 `outerHeight`（分别代表浏览器窗口的宽度和高度）。例如，要将当前标签的位置打印到浏览器控制台，你会写 `console.log(window.location)`。
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Inside the `outer` function, `this` refers to `o1` itself, whereas inside the
    `inner` function, `this` refers to the window (an object that contains information
    about the browser window).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `outer` 函数内部，`this` 指的是 `o1` 本身，而在 `inner` 函数内部，`this` 指的是窗口（一个包含有关浏览器窗口信息的对象）。
- en: 'Compare this to defining the inner function using arrow syntax:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与使用箭头语法定义内部函数进行比较：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When we use arrow syntax, `this` is consistent and refers to `o2` in both cases.
    Now that we have had a very brief introduction to JavaScript, let's introduce
    React.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用箭头语法时，`this` 在两种情况下都是一致的，并指向 `o2`。现在我们已经对 JavaScript 有了一个非常简要的介绍，让我们来介绍
    React。
- en: Further Reading
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Covering all the concepts of JavaScript is beyond the scope of this book. For
    a complete, hands-on course on JavaScript, you can always refer to *The JavaScript
    Workshop*: [https://courses.packtpub.com/courses/javascript](https://courses.packtpub.com/courses/javascript).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖 JavaScript 的所有概念超出了本书的范围。对于一门完整的、动手实践的 JavaScript 课程，你总是可以参考 *The JavaScript
    Workshop*：[https://courses.packtpub.com/courses/javascript](https://courses.packtpub.com/courses/javascript)。
- en: React
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React
- en: React allows you to build applications using components. Each component can
    *render* itself, by generating HTML to be inserted on the page.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: React 允许你使用组件来构建应用程序。每个组件都可以通过生成要插入页面的 HTML 来*渲染*自己。
- en: A component may also keep track of its own *state*. If it does track its own
    state, when the state changes, the component will automatically re-render itself.
    This means if you have an action method that updates a state variable on a component,
    you don't need to then figure out whether the component needs to be redrawn; React
    will do this for you. A web app should track its own state so that it doesn't
    need to query the server to find out how it needs to update to display data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组件也可能跟踪其自身的*状态*。如果它跟踪自己的状态，当状态发生变化时，组件将自动重新渲染自己。这意味着如果你有一个更新组件状态变量的操作方法，你不需要再确定组件是否需要重绘；React
    会为你完成这项工作。一个 Web 应用应该跟踪其自身的状态，这样它就不需要查询服务器以了解如何更新以显示数据。
- en: Data is passed between components using properties, or *props* for short. The
    method of passing properties looks kind of like HTML attributes, but there are
    some differences, which we will cover later in the chapter. Properties are received
    by a component in a single `props` object.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 数据通过属性或简称为 *props* 的属性在组件之间传递。传递属性的方法看起来有点像 HTML 属性，但有一些区别，我们将在本章后面讨论。属性通过一个单独的
    `props` 对象被组件接收。
- en: To illustrate with an example, you might build a shopping list app with React.
    You would have a component for the list container (`ListContainer`), and a component
    for a list item (`ListItem`). `ListItem` would be instantiated multiple times,
    once for each item on the shopping list. The container would hold a state, containing
    a list of the items' names. Each item name would be passed to the `ListItem` instances
    as a *prop*. Each `ListItem` would then store the item's name and an `isBought`
    flag in its own state. As you click an item to mark it off the list, `isBought`
    would be set to `true`. Then React would automatically call `render` on that `ListItem`
    to update the display.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个例子来说明，你可能使用 React 来构建一个购物清单应用。你将会有一个用于列表容器的组件（`ListContainer`），以及一个用于列表项的组件（`ListItem`）。`ListItem`
    将会被实例化多次，每次对应购物清单上的一个项目。容器将包含一个状态，其中包含项目名称的列表。每个项目名称都会作为 *prop* 传递给 `ListItem`
    实例。每个 `ListItem` 将在其自己的状态中存储项目名称和一个 `isBought` 标志。当你点击一个项目来标记它从列表中移除时，`isBought`
    将被设置为 `true`。然后 React 会自动调用该 `ListItem` 的 `render` 方法来更新显示。
- en: 'There are a few different methods of using React with your application. If
    you want to build a deep and complex React application, you should use `npm` (`<script>`
    tag:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 React 与你的应用程序结合使用有几种不同的方法。如果你想构建一个深度和复杂的 React 应用程序，你应该使用 `npm` (`<script>`
    标签：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `crossorigin` attribute is for security and means cookies or other data
    cannot be sent to the remote server. This is necessary when using a public CDN
    such as [https://unpkg.com/](https://unpkg.com/), in case a malicious script has
    been hosted there by someone.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`crossorigin` 属性是为了安全考虑，意味着不能将 cookie 或其他数据发送到远程服务器。当使用公共 CDN，如 [https://unpkg.com/](https://unpkg.com/)
    时，这是必要的，以防有人在那里托管了恶意脚本。'
- en: These should be placed on a page that you want to add React to, just before
    the closing `</body>` tag. The reason for putting the tags here instead of in
    the `<head>` of the page is that the script might want to refer to HTML elements
    on the page. If we put the script tag in the head, it will be executed before
    the page elements are available (as they come after).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应该放置在你想要添加 React 的页面上，在关闭 `</body>` 标签之前。将标签放在这里而不是页面的 `<head>` 中，原因可能是脚本可能需要引用页面上的
    HTML 元素。如果我们把脚本标签放在 `<head>` 中，它将在页面元素可用之前执行（因为它们在后面）。
- en: Note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The links to the latest React versions can be found at [https://reactjs.org/docs/cdn-links.html](https://reactjs.org/docs/cdn-links.html).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 [https://reactjs.org/docs/cdn-links.html](https://reactjs.org/docs/cdn-links.html)
    找到指向最新 React 版本的链接。
- en: Components
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件
- en: 'There are two ways to build a component in React: with functions or with classes.
    Regardless of the approach, to get displayed on a page, the component must return
    some HTML elements to display. A functional component is a single function that
    returns elements, whereas a class-based component will return elements from its
    `render` method. Functional components cannot keep track of their own state.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中构建组件有两种方式：使用函数或使用类。无论采用哪种方法，要显示在页面上，组件必须返回一些 HTML 元素来显示。一个函数式组件是一个返回元素的单一函数，而基于类的组件将从其
    `render` 方法返回元素。函数式组件无法跟踪自己的状态。
- en: React is like Django in that it automatically escapes HTML in strings that are
    returned from `render`. To generate HTML elements, you must construct them using
    their tag, the attributes/properties they should have, and their content. This
    is done with the `React.createElement` function. A component will return a React
    element, which may contain sub-elements.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: React 与 Django 类似，它会自动转义从 `render` 返回的字符串中的 HTML。要生成 HTML 元素，你必须使用它们的标签、它们应该有的属性/属性以及它们的内容来构建它们。这是通过
    `React.createElement` 函数完成的。一个组件将返回一个 React 元素，该元素可能包含子元素。
- en: 'Let us look at two implementations of the same component, first as a function
    then as a class. The functional component takes `props` as an argument. This is
    an object containing the properties that are passed to it. The following function
    returns an `h1` element:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看同一组件的两个实现，首先是作为函数，然后是作为类。函数式组件接受 `props` 作为参数。这是一个包含传递给它的属性的对象。以下函数返回一个
    `h1` 元素：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that it is conventional for the function to have an uppercase first character.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，函数的名称通常以大写字母开头。
- en: 'While a functional component is a single function that generates HTML, a class-based
    component must implement a `render` method to do this. The code in the `render`
    method is the same as in the functional component, with one difference: the class-based
    component accepts the `props` object in its constructor, and then `render` (or
    other) methods can refer to `props` using `this.props`. Here is the same `HelloWorld`
    component, implemented as a class:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然函数式组件是一个生成HTML的单个函数，但基于类的组件必须实现一个`render`方法来完成这个任务。`render`方法中的代码与函数式组件中的代码相同，只有一个区别：基于类的组件在其构造函数中接受`props`对象，然后`render`（或其他）方法可以使用`this.props`来引用`props`。以下是将相同的`HelloWorld`组件实现为类的示例：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When using classes, all components extend from the `React.Component` class.
    Class-based components have an advantage over functional components, which is
    that they encapsulate the handling actions/event, and their own state. For simple
    components, using the functional style means less code. For more information on
    components and properties, see [https://reactjs.org/docs/components-and-props.html](https://reactjs.org/docs/components-and-props.html).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用类时，所有组件都扩展自`React.Component`类。基于类的组件比函数式组件有优势，即它们封装了处理动作/事件和它们自己的状态。对于简单的组件，使用函数式风格意味着更少的代码。有关组件和属性的更多信息，请参阅[https://reactjs.org/docs/components-and-props.html](https://reactjs.org/docs/components-and-props.html)。
- en: Whichever method you choose to define a component, it is used in the same way.
    In this chapter, we will only be using class-based components.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种方法来定义组件，它们的使用方式都是相同的。在本章中，我们只将使用基于类的组件。
- en: 'To put this component onto an HTML page, we first need to add a place for React
    to render it. Normally, this is done using `<div>` with an `id` attribute. For
    example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此组件放入HTML页面，我们首先需要为React添加一个渲染位置。通常，这是使用具有`id`属性的`<div>`来完成的。例如：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that `id` does not have to be `react_container`, it just needs to be unique
    for the page. Then, in the JavaScript code, after defining all your components,
    they are rendered on the page using the `ReactDOM.render` function. This takes
    two arguments: the root React element (not the component) and the HTML element
    in which it should be rendered.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`id`不必是`react_container`，它只需要在页面上是唯一的。然后，在JavaScript代码中，在定义了所有组件之后，它们使用`ReactDOM.render`函数在页面上进行渲染。这个函数接受两个参数：根React元素（不是组件）和它应该渲染的HTML元素。
- en: 'We would use it like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像这样使用它：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that the `HelloWorld` component (class/function) itself is not being passed
    to the `render` function, it is wrapped in a `React.createElement` call to instantiate
    it and transform it into an element.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`HelloWorld`组件（类/函数）本身并没有传递给`render`函数，它是被`React.createElement`调用封装的，以实例化它并将其转换为元素。
- en: As you might have guessed from its name, the `document.getElementById` function
    locates an HTML element in the document and returns a reference to it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从其名称中你可能已经猜到了，`document.getElementById`函数在文档中定位一个HTML元素，并返回对其的引用。
- en: 'The final output in the browser when the component is rendered is like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件被渲染时，在浏览器中的最终输出如下所示：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s look at a more advanced example component. Note that since `React.createElement`
    is such a commonly used function, it''s common to alias to a shorter name, such
    as `e`: that''s what the first line of this example does.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个更高级的示例组件。请注意，由于`React.createElement`是一个非常常用的函数，通常将其别名到更短的名字，例如`e`：这就是这个示例的第一行所做的事情。
- en: 'This component displays a button and has an internal state that keeps track
    of how many times the button was clicked. First, let''s look at the component
    class in its entirety:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件显示一个按钮，并有一个内部状态来跟踪按钮被点击的次数。首先，让我们看一下组件类的整体结构：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Some things to note about the `ClickCounter` class:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`ClickCounter`类的几点注意事项：
- en: 'The `props` argument is an object (dictionary) of attribute values that have
    been passed to the component when it is used in HTML. For example:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`props`参数是一个对象（字典），它包含在组件在HTML中使用时传递给它的属性值。例如：'
- en: '[PRE27]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `props` dictionary would contain the key `foo` with a value of bar, and
    the key `rex` with the value `baz`.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`props`字典将包含键`foo`，其值为`bar`，以及键`rex`，其值为`baz`。'
- en: '`super(props)` calls the super class''s `constructor` method and passes the
    `props` variable. This is analogous to the `super()` method in Python.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`super(props)`调用超类的`constructor`方法，并传递`props`变量。这类似于Python中的`super()`方法。'
- en: Each React class has a `state` variable, which is an object. `constructor` can
    initialize it. The state should be changed using the `setState` method, rather
    than being manipulated directly. When it is changed, the `render` method will
    be automatically called to redraw the component.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个React类都有一个`state`变量，它是一个对象。`constructor`可以初始化它。应该使用`setState`方法来更改状态，而不是直接操作。当状态改变时，`render`方法将自动被调用以重新绘制组件。
- en: 'The `render` method returns a new HTML element, using the `React.createElement`
    function (remember, the `e` variable was aliased to this function). In this case,
    the arguments to `React.createElement` will return a `<button>` element with a
    click handler, and with the text content `this.state.clickCount`. Essentially,
    it will return an element like this (when `clickCount` is `0`):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`render`方法返回一个新的HTML元素，使用`React.createElement`函数（记住，`e`变量被重命名为这个函数）。在这种情况下，`React.createElement`的参数将返回一个带有点击处理程序和文本内容`this.state.clickCount`的`<button>`元素。本质上，它将返回如下元素（当`clickCount`为`0`时）：'
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `onClick` function is set as an anonymous function with arrow syntax. This
    is similar to having a function as follows (although not quite the same since
    it''s in a different context):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`onClick`函数被设置为箭头语法匿名函数。这类似于以下函数（尽管并不完全相同，因为它处于不同的上下文中）：'
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since the function is only one line, we can also remove one set of wrapping
    braces, and we end up with this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数只有一行，我们也可以去掉一组括号，最终得到如下：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We covered how to place `ClickCounter` onto a page earlier in this section,
    something like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节前面介绍了如何将`ClickCounter`放置到页面上，大致如下：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The screenshot in the following figure shows the counter in the button when
    the page loads:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下图截图显示了页面加载时按钮中的计数器：
- en: Note
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the following figure, `DjDt` refers to the debug toolbar that we learned
    about in the *Django Debug Toolbar* section in *Chapter 15*, *Django Third-Party
    Libraries*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，`DjDt`指的是我们在第15章的“Django调试工具栏”部分中学习的调试工具栏。
- en: '![Figure 16.6: Button with 0 for the count'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.6：计数为0的按钮'
- en: '](img/B15509_16_06.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15509_16_06.jpg](img/B15509_16_06.jpg)'
- en: 'Figure 16.6: Button with 0 for the count'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6：计数为0的按钮
- en: 'After clicking the button a few times, the button looks as shown in *Figure
    16.7*:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮几次后，按钮看起来如图16.7所示：
- en: '![Figure 16.7: Button after clicking seven times'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.7：点击七次后的按钮'
- en: '](img/B15509_16_07.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15509_16_07.jpg](img/B15509_16_07.jpg)'
- en: 'Figure 16.7: Button after clicking seven times'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7：点击七次后的按钮
- en: 'Now, just to demonstrate how *not* to write the `render` function, we''ll look
    at what happens if we just return HTML as a string, like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了演示如何**不**编写`render`函数，我们将看看如果我们只是像这样返回HTML字符串会发生什么：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now the rendered page looks as shown in *Figure 16.8*:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在渲染的页面看起来如图16.8所示：
- en: '![Figure 16.8: Returned HTML rendered as a string'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.8：作为字符串返回的HTML'
- en: '](img/B15509_16_08.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15509_16_08.jpg](img/B15509_16_08.jpg)'
- en: 'Figure 16.8: Returned HTML rendered as a string'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8：作为字符串返回的HTML
- en: This shows React's automatic escaping of HTML in action. Now that we have had
    a brief intro to JavaScript and React, let's add an example page to Bookr so you
    can see it in action.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了React自动转义HTML的功能。现在我们已经对JavaScript和React有了简要的介绍，让我们在Bookr中添加一个示例页面，以便您可以看到它的实际应用。
- en: 'Exercise 16.01: Setting Up a React Example'
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习16.01：设置React示例
- en: 'In this exercise, we will create an example view and template to use with React.
    Then we will implement the `ClickCounter` component. At the end of the exercise,
    you will be able to interact with it with the `ClickCounter` button:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个示例视图和模板，用于与React一起使用。然后我们将实现`ClickCounter`组件。在练习结束时，您将能够通过`ClickCounter`按钮与之交互：
- en: In PyCharm, go to `New` -> `File` inside the project's `static` directory. Name
    the new file `react-example.js`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PyCharm中，进入项目`static`目录下的`New` -> `File`。将新文件命名为`react-example.js`。
- en: 'Inside it, put this code, which will define the React component, then render
    it into the `react_container` `<div>` that we will be creating:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，放入以下代码，这将定义React组件，然后将其渲染到我们将要创建的`react_container` `<div>`中：
- en: '[PRE33]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can now save `react-example.js`.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您现在可以保存`react-example.js`。
- en: 'Go to `New` -> `HTML File` inside the project''s `templates` directory:![Figure
    16.9: Create a new HTML file'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入项目`templates`目录下的`New` -> `HTML File`：![图16.9：创建一个新的HTML文件
- en: '](img/B15509_16_09.jpg)'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15509_16_09.jpg](img/B15509_16_09.jpg)'
- en: 'Figure 16.9: Create a new HTML file'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图16.9：创建一个新的HTML文件
- en: 'Name the new file `react-example.html`:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将新文件命名为`react-example.html`：
- en: '![Figure 16.10: Name the file react-example.html'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图16.10：命名文件react-example.html'
- en: '](img/B15509_16_10.jpg)'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15509_16_10.jpg](img/B15509_16_10.jpg)'
- en: 'Figure 16.10: Name the file react-example.html'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can change the title inside the `<title>` element to *React Example*, but
    that is not necessary for this exercise.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`react-example.html` is created with some HTML boilerplate as we have seen
    before. Add the following `<script>` tags to include React just before the closing
    `</body>` tag:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `react-example.js` file will be included using a `<script>` tag, and we
    need to generate the script path using the `static` template tag. First, `load`
    the static template library at the start of the file by adding this on the second
    line:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The first few lines of your file will look like *Figure 16.11*:'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 16.11: The load static template tag included'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_16_11.jpg)'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We now need to add the containing `<div>` that React will render into. Add
    this element after the opening `<body>` tag:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can save `react-example.html`.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we''ll add a view to render the template. Open the `reviews` app''s `views.py`
    and add a `react_example` view at the end of the file:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this simple view, we are just rendering the `react-example.html` template
    with no context data.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we need to map a URL to the new view. Open the `bookr` package''s
    `urls.py` file. Add this map to the `urlpatterns` variable:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can save and close `urls.py`.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the Django dev server if it''s not already running, then go to `http://127.0.0.1:8000/react-example/`.
    You should see the `ClickCount` button rendered as in *Figure 16.12*:![Figure
    16.12: ClickCount button'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_16_12.jpg)'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 16.12: ClickCount button'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Try clicking the button a few times and watch the counter increment.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we created our first React component, then added a template
    and view to render it. We included the React framework source from a CDN. In the
    next section, we will introduce **JSX**, which is a method of combining templates
    and code into a single file that can simplify our code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: JSX
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It can be quite verbose to define each element using the `React.createElement`
    function – even when we alias to a shorter variable name. The verbosity is exacerbated
    when we start building larger components.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'When using React, we can use JSX instead to build the HTML elements. JSX stands
    for JavaScript XML – since both JavaScript and XML are written in the same file.
    For example, consider the following code in which we are creating a button using
    the `render` method:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Instead of this, we can return its HTML directly, as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Note that the HTML is not quoted and returned as a string. That is, we are
    not doing this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Since JSX is an unusual syntax (a combination of HTML and JavaScript in a single
    file), we need to include another JavaScript library before it can be used: Babel
    ([https://babeljs.io](https://babeljs.io)). This is a library that can *transpile*
    code between different versions of JavaScript. You can write code using the latest
    syntax and have it *transpiled* (a combination of translate and compile) into
    a version of code that older browsers can understand.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Babel can be included with a `<script>` tag like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This should be included on the page after your other React-related script tags,
    but before you include any files containing JSX.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Any JavaScript source code that includes JSX must have the `type="text/babel"`
    attribute added:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is so Babel knows to parse the file rather than just treating it as plain
    JavaScript.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Note that using Babel in this way can be slow for large projects. It is designed
    to be used as part of the build process in an `npm` project and to have your JSX
    files transpiled ahead of time (rather than in real time as we are doing here).
    `npm` project setup is beyond the scope of this book. For our purposes and with
    the small amount of JSX we are using, using Babel will be fine.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'JSX uses braces to include JavaScript data inside HTML, similar to Django''s
    double braces in templates. JavaScript inside braces will be executed. We''ll
    now look at how to convert our button creation example to JSX. Our `render` method
    can be changed to this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Note that the `onClick` attribute has no quotes around its value; instead,
    it is wrapped in braces. This is passing the JavaScript function that is defined
    inline to the component. It will be available in that component''s `props` dictionary
    that is passed to the `constructor` method. For example, imagine that we had passed
    it like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In such a case, it would be passed to the component as a string value and thus
    would not work.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'We are also rendering the current value of `clickCount` as the content of the
    `button`. JavaScript could be executed inside these braces too. To show the click
    count plus one, we could do this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the next exercise, we will include Babel in our template and then convert
    our component to use JSX.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.02: JSX and Babel'
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we want to implement JSX in our component to simplify our
    code. To do this, we need to make a couple of changes to the `react-example.js`
    file and `react-example.html` file to switch to JSX to render `ClickCounter`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'In PyCharm, open `react-example.js` and change the `render` method to use JSX
    instead, by replacing it with the following code. You can refer to *step 2* from
    *Exercise 16.01*, *Setting Up a React Example*, where we defined this method:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can now treat `ClickCounter` as an element itself. In the `ReactDOM.render`
    call at the end of the file, you can replace the first argument, `e(ClickCounter)`,
    with a `<ClickCounter/>` element, like this:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Since we''re no longer using the `React.create` function that we created in
    *step 2* of *Exercise 16.01*, *Setting Up a React Example*, we can remove the
    alias we created; delete the first line:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can save and close the file.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `react-example.html` template. You need to include the Babel library
    JavaScript. Add this code between the React `script` elements and the `react-example.js`
    element:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add a `type="text/babel"` attribute to the `react-example.html` `<script>`
    tag:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Save `react-example.html`.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Start the Django dev server if it is not already running and go to `http://127.0.0.1:8000/react-example/`.
    You should see the same button as we had before (*Figure 16.12*). When clicking
    the button, you should see the count increment as well.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this exercise, we did not change the behavior of the `ClickCounter` React
    component. Instead, we refactored it to use JSX. This makes it easier to write
    the component's output directly as HTML and cut down on the amount of code we
    need to write. In the next section, we will look at passing properties to a JSX
    React component.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: JSX Properties
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Properties on JSX-based React components are set in the same way as attributes
    on a standard HTML element. The important thing to remember is whether you are
    setting them as a string or a JavaScript value.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some examples using the `ClickCounter` component. Say that we
    want to extend `ClickCounter` so that a `target` number can be specified. When
    the target is reached, the button should be replaced with the text `Well done,
    <name>!`. These values should be passed into `ClickCounter` as properties.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'When using variables, we have to pass them as JSX values:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can mix and match the method of passing the values too. This is also valid:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the next exercise, we will update `ClickCounter` to read these values from
    properties and change its behavior when the target is reached. We will pass these
    values in from the Django template.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.03: React Component Properties'
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will modify `ClickCounter` to read the values of `target`
    and `name` from its `props`. You will pass these in from the Django view and use
    the `escapejs` filter to make the `name` value safe for use in a JavaScript string.
    When you are finished, you will be able to click on the button until it reaches
    a target, and then see a `Well done` message:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'In PyCharm, open the `reviews` app''s `views.py`. We will modify the `react_example`
    view''s `render` call to pass through a context containing `name` and `target`,
    like this:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You can use your own name and pick a different target value if you like. Save
    `views.py`.
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `react-example.js` file. We will update the `state` setting in the
    `constructor` method to set the name and target from `props`, like this:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Change the behavior of the `render` method to return `Well done, <name>!` once
    `target` has been reached. Add this `if` statement inside the `render` method:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To pass the values in, move the `ReactDOM.render` call into the template so
    that Django can render that piece of code. Cut this `ReactDOM.render` line from
    the end of `react-example.js`:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We will paste it into the template file in *step 6*. `react-example.js` should
    now only contain the `ClickCounter` class. Save and close the file.
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open `react-example.html`. After all the existing `<script>` tags (but before
    the closing `</body>` tag), add opening and closing `<script>` tags with the `type="text/babel"`
    attribute. Inside them, we need to assign the Django context values that were
    passed to the template to JavaScript variables. Altogether, you should be adding
    this code:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The first assigns the `name` variable with the `name` context variable. We use
    the `escapejs` template filter; otherwise, we could generate invalid JavaScript
    code if our name had a double quote in it. The second value, `target`, is assigned
    from `target`. This is a number, so it does not need to be escaped.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Due to the way Django escapes the values for JavaScript, `name` cannot be passed
    directly to the component property like this:'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<ClickCounter name="{{ name|escapejs }}"/>`'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The JSX will not un-escape the values correctly and you will end up with escape
    sequences.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'However, you could pass the numerical value target in like this:'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<ClickCounter target="{ {{ target }} }"/>`'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Also, be aware of the spacing between the Django braces and JSX braces. In this
    book, we will stick with assigning all properties to variables first, then passing
    them to the component, for consistency.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Underneath these variable declarations, paste in the `ReactDOM.render` call that
    you copied from `react-example.js`. Then, add the `target={ target }` and `name={
    name }` properties to `ClickCounter`. Remember, these are the JavaScript variables
    being passed in, not the Django context variables – they just happen to have the
    same name. The `<script>` block should now look like this:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: You can save `react-example.html`.
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the Django dev server if it is not already running, then go to `http://127.0.0.1:8000/react-example/`.
    Try clicking the button a few times – it should increment until you click it `target`
    number of times. Then, it will be replaced with the `Well done, <name>!` text.
    See *Figure 16.13* for how it should look after you''ve clicked it enough times:![Figure
    16.13: Well done message'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_16_13.jpg)'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 16.13: Well done message'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we passed data to a React component using `props`. We escaped
    the data when assigning it to a JavaScript variable using the `escapejs` template
    filter. In the next section, we will cover how to fetch data over HTTP using JavaScript.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'For a more detailed, hands-on course on React, you can always refer to *The
    React Workshop*: [https://courses.packtpub.com/courses/react](https://courses.packtpub.com/courses/react).'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Promises
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To prevent blocking on long-running operations, many JavaScript functions are
    implemented asynchronously. The way they work is by returning immediately, but
    then invoking a callback function when a result is available. The object these
    types of functions return is a `Promise`. Callback functions are provided to the
    `Promise` object by calling its `then` method. When the function finishes running,
    it will either `resolve` the `Promise` (call the `success` function) or `reject`
    it (call the `failure` function).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'We will illustrate the wrong and right way of using promises. Consider a hypothetical
    long-running function that performs a big calculation, called `getResult`. Instead
    of returning the result, it returns a `Promise`. You would not use it like this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Instead, it should be invoked like this, with a callback function passed to
    `then` on the returned `Promise`. We will assume that `getResult` can never fail,
    so we only provide it with a `success` function for the resolve case:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Normally, you wouldn''t assign the returned `Promise` to a variable. Instead,
    you''d chain the `then` call to the function call. We''ll show this in the next
    example, along with a failure callback (assume `getResult` can now fail). We''ll
    also add some comments illustrating the order in which the code executes:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now that we've introduced promises, we can look at the `fetch` function, which
    makes HTTP requests. It is asynchronous and works by returning promises.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: fetch
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most browsers (95%) support a function called `fetch`, which allows you to make
    HTTP requests. It uses an asynchronous callback interface with promises.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fetch` function takes two arguments. The first is the URL to make the
    request to and the second is an object (dictionary) with settings for the request.
    For example, consider this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The settings are things such as the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '`method`: The request HTTP method (`GET`, `POST`, and more).'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`headers`: Another object (dictionary) of HTTP headers to send.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body`: The HTTP body to send (for `POST`/`PUT` requests).'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`credentials`: By default, `fetch` does not send any cookies. This means your
    requests will act like you are not authenticated. To have it set cookies in its
    requests, this should be set to the value `same-origin` or `include`.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at it in action with a simple request:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This code will fetch from `/api/book-list/` and then call a function that logs
    the request to the browser's console using `console.log`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16.14* shows the console output in Firefox for the preceding response:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.14: Response output in the console'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_16_14.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.14: Response output in the console'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, there isn''t much information that is output. We need to decode
    the response before we can work with it. We can use the `json` method on the response
    object to decode the response body to a JSON object. This also returns a `Promise`,
    so we will ask to get the JSON, then work with the data in our callback. The full
    code block to do that looks like this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This will log the decoded object that was in JSON format to the browser console.
    In Firefox, the output looks like *Figure 16.15*:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.15: Decoded book list output to console'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_16_15.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.15: Decoded book list output to console'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: In *Exercise 16.04*, *Fetching and Rendering Books*, we will write a new React
    component that will fetch a list of books and then render each one as a list item
    (`<li>`). Before that, we need to learn about the JavaScript `map` method and
    how to use it to build HTML in React.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript map Method
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes we want to execute the same piece of code (JavaScript or JSX) multiple
    times for different input data. In this chapter, it will be most useful to generate
    JSX elements with the same HTML tags but different content. In JavaScript, the
    `map` method iterates over the target array and then executes a callback function
    for each element in the array. Each of these elements is then added to a new array,
    which is then returned. For example, this short snippet uses `map` to double each
    number in the `numbers` array:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `doubled` array now contains the values `[2, 4, 6]`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create a list of JSX values using this method. The only thing to
    note is that each item in the list must have a unique `key` property set. In this
    next short example, we are transforming an array of numbers into `<li>` elements.
    We can then use them inside `<ul>`. Here is an example `render` function to do
    this:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'When rendered, this will generate the following HTML:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In the next exercise, we will build a React component with a button that will
    fetch the list of books from the API when it is clicked. The list of books will
    then be displayed.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.04: Fetching and Rendering Books'
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create a new component named `BookDisplay` that
    renders an array of books inside `<ul>`. The books will be retrieved using `fetch`.
    To do this, we add the React component into the `react-example.js` file. Then
    we pass the URL of the book list to the component inside the Django template:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: In PyCharm, open `react-example.js`, which you previously used in *step 9* of
    *Exercise 16.03*, *React Component Properties*. You can delete the entire `ClickCounter`
    class.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class called `BookDisplay` that `extends` from `React.Component`.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, add a `constructor` method that takes `props` as an argument. It should
    call `super(props)` and then set its state like this:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This will initialize `books` as an empty array, read the API URL from the passed-in
    property `url`, and set a `fetchInProgress` flag to `false`. The code of your
    `constructor` method should be like this:'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Next, add a `doFetch` method. You can copy and paste this code to create it:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: First, with the `if` statement, we check if a fetch has already been started.
    If so, we `return` from the function. Then, we use `setState` to update the state,
    setting `fetchInProgress` to `true`. This will both update our button display
    text and stop multiple requests from being run at once. We then `fetch` the `this.state.url`
    (which we will pass in through the template later in the exercise). The response
    is retrieved with the `GET` method and we only want to `Accept` a JSON response.
    After we get a response, we then return its JSON using the `json` method. This
    returns a `Promise`, so we use another `then` to handle the callback when the
    JSON is parsed. In that final callback, we set the state of the component, with
    `fetchInProgress` going back to `false`, and the `books` array being set to the
    decoded JSON data.
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, create the `render` method. You can copy and paste this code too:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This uses the `map` method to iterate over the array of books in `state`. We
    generate `<li>` for each book, using the book's `pk` as the `key` instance for
    the list item. The content of `<li>` is the book's title. We define a `buttonText`
    variable to store (and update) the text that the button will display. If we currently
    have a `fetch` operation running, then this will be *Fetch in Progress*. Otherwise,
    it will be *Fetch*. Finally, we return a `<div>` that contains all the data we
    want. The content of `<ul>` is the `bookListItems` variable (the array of `<li>`
    instances). It also contains a `<button>` instance added in a similar way to in
    the previous exercises. The `onClick` method calls the `doFetch` method of the
    class. We can make the button `disabled` (that is, the user can't click the button)
    if there is a fetch in progress. We set the button text to the `buttonText` variable
    we created earlier. You can now save and close `react-example.js`.
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open `react-example.html`. We need to replace the `ClickCounter` render (from
    *Exercise 16.03*, *React Component Properties*) with a `BookDisplay` render. Delete
    the `name` and `target` variable definitions. We will instead render the `<BookDisplay>`.
    Set the `url` property as a string and pass in the URL to the book list API, using
    the `{% url %}` template tag to generate it. The `ReactDOM.render` call should
    then look like this:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: You can now save and close `react-example.html`.
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the Django dev server if it''s not already running, then visit `http://127.0.0.1:8000/react-example/`.
    You should see a single `Fetch` button on the page (*Figure 16.16*):![Figure 16.16:
    Book Fetch button'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_16_16.jpg)'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 16.16: Book Fetch button'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking the `Fetch` button, it should become disabled and have its text
    changed to `Fetch in Progress`, as we can see here:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.17: Fetch in Progress'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_16_17.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.17: Fetch in Progress'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the fetch is complete, you should see the list of books rendered as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.18: Book fetch complete'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_16_18.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.18: Book fetch complete'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: This exercise was a chance to integrate React with the Django REST API you built
    in *Chapter 12*, *Building a REST API*. We built a new component (`BookDisplay`)
    with a call to `fetch` to get a list of books. We used the JavaScript `map` method
    to transform the book array to some `<li>` elements. As we had seen before, we
    used `button` to trigger `fetch` when it was clicked. We then provided the book
    list API URL to the React component in the Django template. Later, we saw a list
    of books in Bookr that were loaded dynamically using the REST API.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Before we move onto the activity for this chapter, we will talk about some considerations
    for other JavaScript frameworks when working with Django.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: The verbatim Template Tag
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen that when using React, we can use JSX interpolation values in Django
    templates. This is because JSX uses single braces to interpolate values, and Django
    uses double braces. As long as there are spaces between the JSX and Django braces,
    it should work fine.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'Other frameworks, such as Vue, also use double braces for variable interpolation.
    What that means is if you had a Vue component''s HTML in your template, you might
    try to interpolate a value like this:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Of course, when Django renders the template, it will interpolate the `name`
    value before the Vue framework gets a chance to render.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `verbatim` template tag to have Django output the data exactly
    as it appears in the template, without performing any rendering or variable interpolation.
    Using it with the previous example is simple:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Now when Django renders the template, the HTML between the template tags will
    be output exactly as it is written, allowing Vue (or another framework) to take
    over and interpolate the variables itself. Many other frameworks separate their
    templates into their own files, which should not conflict with Django's templates.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: There are many JavaScript frameworks available, and which one you ultimately
    decide to use will depend on your own opinion or what your company/team uses.
    If you do run into conflicts, the solution will depend on your particular framework.
    The examples in this section should help lead you in the right direction.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: We have now covered most things you will need to integrate React (or other JavaScript
    frameworks) with Django. In the next activity, you will implement these learnings
    to fetch the most recent reviews on Bookr.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 16.01: Reviews Preview'
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we will update the Bookr main page to fetch the six most recent
    reviews and display them. The user will be able to click buttons to go forward
    to the next six reviews, and then back to the previous ones.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete the activity:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: First, we can clean up some code from previous exercises. You can take backups
    of these files to preserve them for later reference if you like. Alternatively,
    you can use the GitHub versions too, for future reference. Delete the `react_example`
    view, `react-example` URL, `react-example.html` template, and `react-example.js`
    file.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `recent-reviews.js` static file.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two components, a `ReviewDisplay` component that displays the data for
    a single review, and a `RecentReviews` component that handles fetching the review
    data and displaying a list of `ReviewDisplay` components.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, create the `ReviewDisplay` class. In its constructor, you should read
    the `review` being passed in through the `props` and assign it to the state.
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `render` method of `ReviewDisplay` should return JSX HTML like this:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: However, you should replace the `BOOK_TITLE`, `REVIEW_RATING`, `CREATOR_EMAIL`,
    `REVIEW_CONTENT`, and `BOOK_ID` placeholders with their proper values from the
    `review` that the component has fetched.
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that when working with JSX and React, the `class` of an element is set
    with the `className` attribute, not `class`. When it's rendered as HTML, it becomes
    `class`.
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create another React component called `RecentReviews`. Its `constructor` method
    should set up the `state` with the following keys/values:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`reviews`: `[]` (empty list)'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`currentUrl`: `props.url`'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`nextUrl`: `null`'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`previousUrl`: `null`'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`loading`: `false`'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Implement a method to download the reviews from the REST API. Call it `fetchReviews`.
    It should return immediately if `state.loading` is `true`. Then, it should set
    the `loading` property of `state` to `true`.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement `fetch` in the same way as you did in *Exercise 16.04*, *Fetching
    and Rendering Books*. It should follow the same pattern of requesting `state.currentUrl`
    and then getting the JSON data from the response. Then, set the following values
    in `state`:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`loading`: `false`'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`reviews`: `data.results`'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`nextUrl`: `data.next`'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`previousUrl`: `data.previous`'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Implement a `componentDidMount` method. This is a method that is called when
    React has loaded the component onto the page. It should call the `fetchReviews`
    method.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `loadNext` method. If the `nextUrl` in `state` is null, it should return
    immediately. Otherwise, it should set `state.currentUrl` to `state.nextUrl`, then
    call `fetchReviews`.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, create a `loadPrevious` method; however, this should set `state.currentUrl`
    to `state.previousUrl`.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the render method. If the state is loading, then it should return
    the text `Loading…` inside an `<h5>` element.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two variables to store the `previousButton` and `nextButton` HTML. They
    both should have the `btn btn-secondary` class and the next button should also
    have the `float-right` class. They should have `onClick` attributes set to call
    the `loadPrevious` or `loadNext` methods. They should have their `disabled` attributes
    set to `true` if the respective `previousUrl` or `nextUrl` attributes are `null`.
    The button text should be *Previous* or *Next*.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate over the reviews using the `map` method and store the result to a variable.
    Each `review` should be represented by a `ReviewDisplay` component with the attribute
    `key` set to the review's `pk` and `review` set to the `Review` class. If there
    are no reviews (`reviews.length === 0`), then the variable instead should be an
    `<h5>` element with the content *No reviews to display*.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, return all the content wrapped in `<div>` elements, like this:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `className` we are using here will display each review preview in one, two,
    or three columns depending on the screen size.
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, edit `base.html`. You will add all the new content inside the `content`
    block so that it will not be displayed on the non-main pages that override this
    block. Add an `<h4>` element with the content `Recent Reviews`.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `<div>` element for React to render into. Make sure you give it a unique `id`.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include the `<script>` tags to include React, React DOM, Babel, and the `recent-reviews.js`
    file. These four tags should be similar to what you had in *Exercise 16.04*, *Fetching
    and Rendering Books*.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last thing to add is another `<script>` tag containing the `ReactDOM.render`
    call code. The root component being rendered is `RecentReviews`. It should have
    a `url` attribute set to the value `url="{% url 'api:review-list' %}?limit=6"`.
    This does a URL lookup for `ReviewViewSet` and then appends a page size argument
    of `6`, limiting the number of reviews that are retrieved to a maximum of `6`.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have completed these steps, you should be able to navigate to `http://127.0.0.1:8000/`
    (the main Bookr page) and see a page like this:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.19: Completed reviews preview'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_16_19.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.19: Completed reviews preview'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: In the screenshot, the page has been scrolled to show the `Previous`/`Next`
    buttons. Notice the `Previous` button is disabled because we are on the first
    page.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click `Next`, you should see the next page of reviews. If you click
    `Next` enough times (depending on how many reviews you have), you will eventually
    reach the last page and then the `Next` button will be disabled:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.20: Next button disabled'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_16_20.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.20: Next button disabled'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have no reviews, then you should see the message `No reviews to display`:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.21: No reviews to display. text'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_16_21.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.21: No reviews to display. text'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'While the page is loading the reviews, you should see the text `Loading…`;
    however, it will probably only display for a split second since the data is being
    loaded off your own computer:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.22: Loading text'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_16_22.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.22: Loading text'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced JavaScript frameworks and described how they
    work with Django to enhance templates and add interactivity. We introduced the
    JavaScript language and covered some of its main features, variable types, and
    classes. We then introduced the concepts behind React and how it builds HTML by
    using components. We built a React component using just JavaScript and the `React.createElement`
    function. After that, we introduced JSX and saw how it made the development of
    components easier, by letting you directly write HTML in your React components.
    The concepts of `promises` and the `fetch` function were introduced, and we saw
    how to get data from a REST API using `fetch`. The chapter finished with an exercise
    that retrieved reviews from Bookr using the REST API and rendered them to the
    page in an interactive component.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to deploy our Django project to a production
    web server. You can download the chapter from the GitHub repository for this book
    at [http://packt.live/2Kx6FmR](http://packt.live/2Kx6FmR).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
