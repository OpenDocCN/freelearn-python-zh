- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Exploring the GPIO
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索GPIO
- en: Throughout the first four chapters of the book, we have touched on the **General-Purpose
    Input/Output** (**GPIO**) port on the Raspberry Pi. In [*Chapter 3*](B21282_03.xhtml#_idTextAnchor048),
    we used it extensively in the construction of our weather indicator. In this chapter,
    we will dive deeper into the functionality and applications of the GPIO port on
    the Raspberry Pi as we start to build our IoT home security application. We will
    also explore the GPIO port on the Raspbery Pi Pico, the microcontroller cousin
    of the Raspberry Pi.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前四章中，我们已涉及树莓派上的**通用输入/输出**（**GPIO**）端口。在[第3章](B21282_03.xhtml#_idTextAnchor048)中，我们广泛地使用了它来构建我们的天气指示器。在本章中，我们将深入探讨树莓派GPIO端口的特性和应用，随着我们开始构建我们的物联网家庭安全应用。我们还将探索树莓派Pico上的GPIO端口，它是树莓派的微控制器兄弟。
- en: In the hands-on tutorial section, we will construct a basic alarm system using
    a PIR motion sensor to detect human presence. This system will integrate a pushbutton
    for activation control and a buzzer as an alert mechanism. Through this practical
    exercise, we will demonstrate how the Raspberry Pi can interface with various
    components to create functional real-world applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在动手实验部分，我们将使用PIR运动传感器来检测人类存在，构建一个基本的报警系统。这个系统将集成一个按钮用于激活控制，以及一个蜂鸣器作为警报机制。通过这个实际练习，我们将展示树莓派如何与各种组件接口，以创建功能性的实际应用。
- en: 'In this chapter, we will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Introducing the GPIO on the Raspberry Pi and Raspberry Pi Pico
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍树莓派和树莓派Pico上的GPIO
- en: Understanding sensors, actuators, and indicators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解传感器、执行器和指示器
- en: Building a simple alarm system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个简单的报警系统
- en: Let’s begin!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the requirements for completing this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章所需的以下要求：
- en: Intermediate knowledge of Python programming
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具备Python编程的中间知识
- en: A late model Raspberry Pi, preferably a Raspberry Pi 5 with at least 4 GB of
    RAM
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一款较新的树莓派，最好是带有至少4GB RAM的树莓派5
- en: A PIR sensor
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个PIR传感器
- en: An SFM-27 buzzer
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一款SFM-27蜂鸣器
- en: A pushbutton such as an arcade-style button
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个按钮，如街机风格的按钮
- en: 'The code for this chapter may be found here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下位置找到：
- en: '[https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter5](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter5%0D)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter5](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter5%0D)'
- en: Introducing the GPIO on Raspberry Pi
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍树莓派上的GPIO
- en: 'The GPIO port is a versatile set of 40 pins on the Raspberry Pi and Pico, enabling
    interaction with the external world. These pins can be configured as input or
    output and can connect to sensors, LEDs, and more. Included are ports to provide
    power, several ground connections, and GPIOs designated for specific protocols
    such as I2C, UART, SPI, and PCM. In the following table, we can see how we may
    match up pins with specific communication protocols:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO端口是树莓派和Pico上的一组40个引脚，允许与外部世界交互。这些引脚可以配置为输入或输出，并可以连接到传感器、LED等。其中包括提供电源的端口、几个接地连接以及用于特定协议（如I2C、UART、SPI和PCM）的GPIO。在下面的表中，我们可以看到我们如何将引脚与特定的通信协议匹配：
- en: '![Figure 5.1 – GPIO pins and communication protocols](img/B21282_05_1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – GPIO引脚和通信协议](img/B21282_05_1.jpg)'
- en: Figure 5.1 – GPIO pins and communication protocols
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 树莓派GPIO引脚和通信协议
- en: Exploring the Raspberry Pi GPIO pinout diagram
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索树莓派GPIO引脚图
- en: In *Figure 5**.2*, we can see a pinout diagram of the GPIO ports on the Raspberry
    Pi and Raspberry Pi Pico. Outlined are the GPIO pin numbers as well as the pins
    that may be configured for special operations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图5.2*中，我们可以看到树莓派和树莓派Pico的GPIO端口引脚图。概述了GPIO引脚编号以及可能配置为特殊操作的引脚。
- en: Important note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Common to many purchases of a Raspberry Pi and Raspberry Pi Pico is a reference
    sheet with the GPIO pinout diagram. This tool is extremely helpful for development,
    as it acts as a guide to the GPIO (Raspberry Pi) and GP (Pico) pin numbers required
    for device connections to the Pi and Pico, respectively.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派和树莓派Pico的许多购买都附带一个GPIO引脚图参考表。这个工具对于开发来说非常有用，因为它作为GPIO（树莓派）和GP（Pico）引脚编号的指南，这些编号是设备连接到Pi和Pico所需的。
- en: We may find various versions of these diagrams on the internet. For those of
    us interested, there is an interactive version of the Raspberry Pi GPIO pinout
    at [https://pinout.xyz](https://pinout.xyz).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能在互联网上找到这些图表的多种版本。对于有兴趣的人来说，有一个交互式的树莓派GPIO引脚图在[https://pinout.xyz](https://pinout.xyz)。
- en: '![Figure 5.2 – GPIO pinout diagram](img/B21282_05_2.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – GPIO引脚图](img/B21282_05_2.jpg)'
- en: Figure 5.2 – GPIO pinout diagram
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – GPIO引脚图
- en: The Raspberry Pi’s GPIO port includes pins GPIO 0 (EEPROM SDA) and GPIO 1 (EEPROM
    SCL), which enable automatic communication with attached HATs. Additionally, there
    are pins designated for various communication protocols.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派（Raspberry Pi）的GPIO端口包括GPIO 0（EEPROM SDA）和GPIO 1（EEPROM SCL）引脚，这些引脚使得与连接的HAT模块进行自动通信成为可能。此外，还有用于各种通信协议的引脚。
- en: To better understand the communication capabilities of the Raspberry Pi and
    Pico, let’s examine the specific communication protocols that we may configure
    our devices to work with.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解树莓派和Pico的通信能力，让我们来检查我们可能配置设备与之工作的特定通信协议。
- en: Understanding GPIO pin communication protocols
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解GPIO引脚通信协议
- en: The Raspberry Pi’s and Pico’s GPIO pins enable several key communication protocols
    such as I2C, SPI, UART, and PCM. These allow the Raspberry Pi and Pico to interact
    with various devices and sensors. Each protocol has its unique applications, from
    interfacing with sensors to digital audio transmission. In the following sections,
    we’ll provide an overview of these communication methods that may be configured.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派和Pico的GPIO引脚支持多个关键通信协议，如I2C、SPI、UART和PCM。这些协议使得树莓派和Pico能够与各种设备和传感器交互。每种协议都有其独特的应用，从与传感器接口到数字音频传输。在接下来的章节中，我们将概述这些可能配置的通信方法。
- en: I2C
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I2C
- en: I2C is a serial communication protocol developed by Philips Semiconductor, now
    NXP Semiconductors. I2C allows multiple devices to communicate with each other
    using a two-wire interface.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: I2C是由飞利浦半导体（Philips Semiconductor）现在为恩智浦半导体（NXP Semiconductors）开发的串行通信协议。I2C允许多个设备通过双线接口相互通信。
- en: 'Here’s a breakdown of the connections:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是连接的分解：
- en: '**Serial Data Line** (**SDA**): This is the data line.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**串行数据线**（**SDA**）：这是数据线。'
- en: '**Serial Clock Line** (**SLC**): This is the clock line that synchronizes data
    transfer over the I2C bus.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**串行时钟线**（**SLC**）：这是同步I2C总线上的数据传输的时钟线。'
- en: 'The key features of the I2C protocol include the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: I2C协议的关键特性包括以下内容：
- en: '**Multi-master and multi-slave**: Multiple devices can be connected to the
    bus, with the capability for more than one master.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多主多从**：多个设备可以连接到总线上，并且可以支持超过一个主设备。'
- en: '**Address-based communication**: Each device on the bus has a unique address,
    allowing targeted communication.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于地址的通信**：总线上的每个设备都有一个唯一的地址，允许进行定向通信。'
- en: '**Simple hardware connection**: Only two pull-up resistors are required for
    the SDA and SCL lines when setting up an I2C connection.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单的硬件连接**：在设置I2C连接时，SDA和SCL线只需要两个上拉电阻。'
- en: '**Speed variants**: I2C supports different speed modes, including standard
    (up to 100 Kbps), fast (up to 400 Kbps), high speed (up to 3.4 Mbps), and more.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度变体**：I2C支持不同的速度模式，包括标准模式（最高100 Kbps）、快速模式（最高400 Kbps）、高速模式（最高3.4 Mbps）等。'
- en: On the Raspberry Pi and Pico, the I2C protocol is particularly valuable for
    connecting peripherals such as PIR sensors, mini-OLED screens, and other components
    using just two wires.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在树莓派和Pico上，I2C协议对于仅用两根线连接PIR传感器、迷你OLED屏幕和其他组件尤其有价值。
- en: SPI
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SPI
- en: The **Serial Peripheral Interface** (**SPI**) is a synchronous serial communication
    protocol used for short-distance communication, primarily in embedded systems,
    to connect microcontrollers and peripheral devices such as sensors, SD cards,
    and LCDs.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**串行外设接口**（**SPI**）是一种用于短距离通信的同步串行通信协议，主要用于嵌入式系统，用于连接微控制器和外围设备，如传感器、SD卡和LCD。'
- en: 'Here’s a breakdown of the connections:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是连接的分解：
- en: '**SDO—Serial Data Out**: This line is used for sending data from the controller
    to the peripherals.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SDO—串行数据输出**：该线路用于从控制器向外围设备发送数据。'
- en: '**SDI—Serial Data In**: This line allows peripherals to send data back to the
    controller.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SDI—串行数据输入**：该线路允许外围设备将数据发送回控制器。'
- en: '**SCLK—Serial Clock**: Like the SCL line in I2C, this provides the clock signal,
    synchronizing data transfer between devices.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SCLK—串行时钟**：类似于I2C中的SCL线，它提供时钟信号，同步设备间的数据传输。'
- en: '**CS0—Chip Select 0**: This line is crucial for selecting specific devices
    when there are multiple peripherals. By toggling CS0, the controller can determine
    which device it’s communicating with.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CS0—芯片选择0**：当存在多个外围设备时，此线路对于选择特定设备至关重要。通过切换CS0，控制器可以确定它与哪个设备进行通信。'
- en: '**CS1—Chip Select 1**: Like CS0, CS1 provides an additional selection line,
    enabling the addressing of more devices on a single SPI bus.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CS1—芯片选择1**：与CS0类似，CS1提供了一条额外的选择线路，使得在单个SPI总线上可以寻址更多设备。'
- en: 'The following are the features and advantages of SPI:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是SPI的功能和优势：
- en: '**Full-duplex communication**: SPI supports simultaneous bidirectional communication,
    allowing data to be sent and received at the same time. This means that during
    an SPI communication, data can flow from the master to the slave and from the
    slave to the master concurrently. This is unlike I2C, which operates in a half-duplex
    mode (can either send or receive data at any given moment, but not at the same
    time).'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全双工通信**：SPI支持同时双向通信，允许数据同时发送和接收。这意味着在SPI通信期间，数据可以同时从主设备流向从设备，以及从从设备流向主设备。这与I2C不同，I2C在半双工模式下运行（在任何给定时刻可以发送或接收数据，但不能同时进行）。'
- en: '**Speed**: SPI often outpaces I2C in terms of data transfer rates, making it
    suitable for applications that demand higher-speed communications.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：在数据传输速率方面，SPI通常超过I2C，使其适用于需要高速通信的应用。'
- en: '**Direct hardware control**: Without a specific addressing scheme as in I2C,
    SPI offers more straightforward device control via the CE pins.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接硬件控制**：与I2C中的特定寻址方案不同，SPI通过CE引脚提供更直接的设备控制。'
- en: SPI communication is useful when connecting components such as SD cards, displays,
    **ADCs** (short for **analog-to-digital converters**), and more. An example is
    an application where we connect an SD card via SPI for data logging.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: SPI通信在连接如SD卡、显示屏、**ADCs**（即**模拟-数字转换器**）等组件时非常有用。一个例子是我们通过SPI连接SD卡进行数据记录的应用。
- en: UART
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UART
- en: UART, which stands for **Universal Asynchronous Receiver–Transmitter**, is a
    prevalent communication protocol in the electronics domain, especially known for
    its simplicity and effectiveness in point-to-point communications between devices.
    UART stands out with its full-duplex communication capability. This allows two
    devices to exchange data concurrently.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: UART，即**通用异步收发器**，是电子领域的一种常用通信协议，尤其以其在设备之间点对点通信中的简单性和有效性而闻名。UART以其全双工通信能力而突出。这允许两个设备同时交换数据。
- en: 'Here’s a breakdown of the connections:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是连接的分解：
- en: '**TX—Transmit**: This connection is used to send data out to another device.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TX—发送**：此连接用于将数据发送到另一个设备。'
- en: '**RX—Receive**: Conversely, this connection is used to receive data from another
    device.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RX—接收**：相反，此连接用于从另一个设备接收数据。'
- en: These connections allow for simultaneous bidirectional communication; while
    the Raspberry Pi and Pico transmit data via their TX pins, they can also receive
    data through their RX pins.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些连接允许双向通信；当树莓派和Pico通过它们的TX引脚发送数据时，它们也可以通过它们的RX引脚接收数据。
- en: 'Some features of UART compared to other communication methods such as I2C and
    SPI include:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与I2C和SPI等其他通信方法相比，UART的一些特性包括：
- en: '**Peer-to-peer communication**: Unlike I2C and SPI, which have defined master-slave
    relationships, UART devices communicate as equals, with no designated master or
    slave.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对等通信**：与I2C和SPI不同，后者有定义的主从关系，UART设备作为对等体通信，没有指定的主设备或从设备。'
- en: '**Asynchronous mechanism**: Unlike SPI, UART communication doesn’t rely on
    a shared clock signal. Instead, both devices must agree on a baud rate before
    initiating communication.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步机制**：与SPI不同，UART通信不依赖于共享的时钟信号。相反，在启动通信之前，两个设备必须就波特率达成一致。'
- en: Given its simplicity, UART is commonly used for serial console access and interfacing
    with peripherals that demand a straightforward communication path. One common
    use of UART and the Raspberry PI is the connection of flight controllers for drones.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其简单性，UART通常用于串行控制台访问和与需要简单通信路径的外围设备接口。UART和树莓派的一个常见用途是将无人机飞行控制器连接起来。
- en: PCM
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PCM
- en: 'We can set GPIO pins 12, 35, 38, and 40 on the Raspberry Pi for **PCM** (**Pulse-Code
    Modulation**), which digitally represents analog signals by sampling their magnitude
    at regular intervals and quantizing it into a digital code. These pins are specifically
    designated for PCM communication on the device:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在树莓派上的GPIO 12、35、38和40上设置**PCM**（**脉冲编码调制**），这些引脚通过在固定时间间隔内采样它们的幅度并将其量化为数字代码来数字表示模拟信号。这些引脚专门用于设备上的PCM通信：
- en: '**GPIO 12** (**PCM_CLK**): This is the clock pin, ensuring synchronization
    during data transfer.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPIO 12**（**PCM_CLK**）：这是时钟引脚，确保数据传输时的同步。'
- en: '**GPIO 35** (**PCM_FS**): This is frame sync. It helps in defining the start
    and end of the data frame.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPIO 35**（**PCM_FS**）：这是帧同步。它有助于定义数据帧的开始和结束。'
- en: '**GPIO 38** (**PCM_DIN**): This is the data input. This is where the Raspberry
    Pi receives PCM data from external devices.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPIO 38**（**PCM_DIN**）：这是数据输入。这是树莓派从外部设备接收PCM数据的地方。'
- en: '**GPIO 40** (**PCM_DOUT**): This is the data output. The Raspberry Pi uses
    this pin to send PCM data to other devices.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPIO 40**（**PCM_DOUT**）：这是数据输出。树莓派使用此引脚将PCM数据发送到其他设备。'
- en: 'Some notable aspects of PCM include the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: PCM的一些显著特点包括以下内容：
- en: '**Digital representation**: PCM converts analog signals into a digital format,
    making it ideal for preserving the nuance of the original signal in a format that’s
    resistant to noise and interference.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字表示法**：PCM将模拟信号转换为数字格式，使其在抗噪声和干扰的格式中保存原始信号的细微差别，非常适合。'
- en: '**Common in audio**: Many audio formats, such as WAV, use PCM to represent
    sound digitally, ensuring high fidelity.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在音频中常见**：许多音频格式，如WAV，使用PCM来数字表示声音，确保高保真度。'
- en: '**Flexibility**: PCM can be used for a range of applications beyond audio,
    including telecommunications and data storage.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：PCM可用于音频以外的各种应用，包括电信和数据存储。'
- en: On the Raspberry Pi, PCM’s utility is evident in various tasks, from digital
    audio playback and recording to interfacing with devices that require precise
    analog-to-digital representations. A notable application of PCM with the Raspberry
    Pi is in the field of digital audio systems and sound interfaces.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在树莓派上，PCM的实用性在各种任务中显而易见，从数字音频播放和录制到与需要精确的模拟到数字表示的设备进行接口。PCM与树莓派的一个显著应用是在数字音频系统和声音接口领域。
- en: 'The following is a table summarizing the communication protocols and the Raspberry
    Pi and Raspberry Pi Pico:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个总结通信协议和树莓派以及树莓派Pico的表格：
- en: '![Figure 5.3 – Communication protocols summarized](img/B21282_05_3.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – 总结的通信协议](img/B21282_05_3.jpg)'
- en: Figure 5.3 – Communication protocols summarized
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 总结的通信协议
- en: Now that we understand the communication protocols we may use with the Raspberry
    Pi and Raspberry Pi Pico, let’s look at sensors, actuators, and indicators and
    how we may hook them up to our Raspberry Pi and Raspberry Pi Pico. This is the
    main purpose of the GPIO port.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了可以与树莓派和树莓派Pico一起使用的通信协议，让我们来看看传感器、执行器和指示器，以及我们如何将它们连接到我们的树莓派和树莓派Pico上。这是GPIO端口的主要用途。
- en: Understanding sensors, actuators, and indicators
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解传感器、执行器和指示器
- en: The GPIO functionality of the Raspberry Pi and Pico offers a foundation for
    connecting various sensors and driving indicators like LEDs and controlling actuators
    like servo motors. By integrating these devices, our devices can both collect
    data and execute responsive actions based on this information.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派和Pico的GPIO功能为连接各种传感器和驱动指示器（如LED）以及控制执行器（如伺服电机）提供了基础。通过集成这些设备，我们的设备可以收集数据并根据这些信息执行响应动作。
- en: For instance, a PIR sensor (*A* in *Figure 5**.4*) can detect motion in a room,
    prompting an LED or triggering an alarm. Using temperature and humidity sensors,
    such as DHT11 (*B* in *Figure 5**.4*), we can assess environmental conditions
    and, in response, engage a fan or a heating element.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个PIR传感器（*图5**.4*中的*A*）可以检测房间内的运动，从而点亮LED或触发警报。使用温度和湿度传感器，如DHT11（*图5**.4*中的*B*），我们可以评估环境条件，并据此启动风扇或加热元件。
- en: 'With distance sensors (*C* in *Figure 5**.4*), we can measure the closeness
    of objects and instruct a servo motor to halt a robot, preventing collisions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用距离传感器（*图5**.4*中的*C*），我们可以测量物体的接近程度，并指令伺服电机停止机器人，防止碰撞：
- en: '![Figure 5.4 – Sensors for the Raspberry Pi](img/B21282_05_4.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – 树莓派的传感器](img/B21282_05_4.jpg)'
- en: Figure 5.4 – Sensors for the Raspberry Pi
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 树莓派的传感器
- en: Numerous devices can be integrated with our Raspberry Pi and Pico. Robotics
    alone offers line tracking sensors for directing robots along set paths and **Time
    of Flight** (**TOF**) sensors, which are compact and precise distance sensors.
    Beyond robotics, there are sensors for soil moisture, rain detection, light, and
    temperature/humidity, creating the potential for a self-regulating greenhouse.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将许多设备集成到我们的 Raspberry Pi 和 Pico 中。仅就机器人技术而言，它提供了用于引导机器人沿预定路径行驶的线跟踪传感器和**飞行时间**（**TOF**）传感器，这些传感器体积小且精确，距离传感器。在机器人技术之外，还有土壤湿度、雨量检测、光线和温度/湿度传感器，这为自调节温室创造了潜力。
- en: In the next section, we’ll explore connecting and reading data from a PIR sensor
    (*A* in *Figure 5**.4*) and a Raspberry Pi using Python and the GPIO Zero library.
    Taking what we learn, we will use our knowledge to create a basic alarm system
    with our Raspberry Pi.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用 Python 和 GPIO Zero 库连接并读取 PIR 传感器（*图 5.4* 中的 *A*）和 Raspberry
    Pi 的数据。结合我们所学，我们将利用我们的知识来创建一个基本的报警系统，使用我们的 Raspberry Pi。
- en: We will start by setting up our development environment before we write code
    to interact with the PIR sensor.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写与 PIR 传感器交互的代码之前，我们将首先设置我们的开发环境。
- en: Setting up our development environment
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的开发环境
- en: 'We will use a Python virtual environment for our development. As there are
    libraries that only work with the root installation of Python, we will use system
    packages in our Python virtual environment. To do so, we do the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Python 虚拟环境进行我们的开发。由于有些库只与 Python 的根安装版本兼容，因此我们将使用系统包在我们的 Python 虚拟环境中。为此，我们执行以下操作：
- en: On our Raspberry Pi 5, we open a Terminal.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 Raspberry Pi 5 上，我们打开一个终端。
- en: 'To store our project files, we create a new directory with the following:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了存储我们的项目文件，我们使用以下命令创建一个新的目录：
- en: '[PRE0]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We then navigate to the new directory with the following:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用以下命令导航到新目录：
- en: '[PRE1]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We create a new Python virtual environment for our project with the following:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用以下命令为我们的项目创建一个新的 Python 虚拟环境：
- en: '[PRE2]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With our new Python virtual environment created, we source into it with the
    following command:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建我们的新 Python 虚拟环境后，我们使用以下命令将其源代码导入：
- en: '[PRE3]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![Figure 5.5 – Terminal using dashboard-env environment](img/B21282_05_5.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 使用 dashboard-env 环境的终端](img/B21282_05_5.jpg)'
- en: Figure 5.5 – Terminal using dashboard-env environment
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 使用 dashboard-env 环境的终端
- en: 'We close the Terminal with the following command:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用以下命令关闭终端：
- en: '[PRE4]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are now ready to load up Thonny. We do so by clicking on the **Menu** icon
    in the Raspberry Pi taskbar, navigating to the **Programming** category, and selecting
    **Thonny**.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已准备好加载 Thonny。我们通过点击 Raspberry Pi 任务栏中的**菜单**图标，导航到**编程**类别，并选择**Thonny**来完成此操作。
- en: By default, Thonny uses the Raspberry Pi’s built-in version of Python. For our
    project, we will use the Python virtual environment we just created. To start
    we need to view the project files by clicking on **View** and selecting **Files**
    if it is not already selected.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Thonny 使用 Raspberry Pi 内置的 Python 版本。对于我们的项目，我们将使用我们刚刚创建的 Python 虚拟环境。为了开始，我们需要通过点击**视图**并选择**文件**来查看项目文件（如果尚未选择）。
- en: In the `Files` section, we locate the `ch5-env` directory.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“文件”部分，我们找到“ch5-env”目录。
- en: 'We then right-click on the folder and select the option **Activate virtual**
    **environment** :'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们右键点击文件夹并选择**激活虚拟环境**选项：
- en: '![Figure 5.6 – Activating a Python virtual environment in Thonny](img/B21282_05_6.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 在 Thonny 中激活 Python 虚拟环境](img/B21282_05_6.jpg)'
- en: Figure 5.6 – Activating a Python virtual environment in Thonny
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 在 Thonny 中激活 Python 虚拟环境
- en: With our project folder created and our Python virtual environment set up and
    activated, we may now start writing code to access sensors connected to the GPIO
    port. We will start by exploring PIR sensors a little more.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的项目文件夹并设置和激活我们的 Python 虚拟环境后，我们现在可以开始编写代码来访问连接到 GPIO 端口的传感器。我们将从探索 PIR
    传感器开始。
- en: Exploring the PIR sensor
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 PIR 传感器
- en: '**Passive infrared** (**PIR**) sensors are devices specialized in detecting
    infrared radiation, typically emitted by living beings due to their body heat.
    These sensors work by monitoring changes in infrared levels, which occur when
    an infrared source, such as a human, moves across its field of view. PIR sensors
    can be recognized by their distinctive sphere shell that dominates the sensor
    (*A* in *Figure 5**.4*).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**被动红外**（**PIR**）传感器是专门用于检测红外辐射的设备，通常由生物体因体温而发出。这些传感器通过监测红外水平的变化来工作，这些变化发生在红外源（如人）在其视野中移动时。PIR
    传感器可以通过其占主导地位的独特球壳来识别（*图 5.4* 中的 *A*）。'
- en: 'Connecting a PIR sensor to a Raspberry Pi is straightforward. Three pins are
    needed:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将 PIR 传感器连接到 Raspberry Pi 很简单。需要三个引脚：
- en: VCC is connected to 5V from the Raspberry Pi.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VCC 连接到 Raspberry Pi 的 5V。
- en: GND is connected to a GND pin.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GND 连接到 GND 引脚。
- en: Signal is connected to GPIO 23.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号连接到 GPIO 23。
- en: 'In *Figure 5**.7*, we see a PIR sensor connected to a Raspberry Pi using a
    breadboard:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 5.7* 中，我们看到一个 PIR 传感器通过面包板连接到 Raspberry Pi：
- en: '![Figure 5.7 – Connecting a PIR sensor to a Raspberry Pi](img/B21282_05_7.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 将 PIR 传感器连接到 Raspberry Pi](img/B21282_05_7.jpg)'
- en: Figure 5.7 – Connecting a PIR sensor to a Raspberry Pi
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 将 PIR 传感器连接到 Raspberry Pi
- en: 'To acquire sensory data from our PIR sensor, we use the GPIO Zero library.
    To do so, we do the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要从我们的 PIR 传感器获取感官数据，我们使用 GPIO Zero 库。为此，我们执行以下操作：
- en: In Thonny, we create a new tab by selecting **File** and then **New** or by
    hitting *Ctrl* + *N* on the keyboard.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Thonny 中，我们通过选择 **文件** 然后选择 **新建** 或按键盘上的 *Ctrl* + *N* 来创建一个新的标签页。
- en: 'Inside the tab, we enter the following code:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标签页中，我们输入以下代码：
- en: '[PRE5]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We save the code as `pir-test.py`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将代码保存为 `pir-test.py`。
- en: To run the code in Thonny, we click on the green run button and hit *F5* on
    the keyboard or click on the **Run** menu option at the top and then **Run** **current
    script**.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在 Thonny 中运行代码，我们点击绿色运行按钮，按键盘上的 *F5* 或点击顶部的 **运行** 菜单选项，然后选择 **运行** **当前脚本**。
- en: 'We should see the message `"Motion detected!!"` when we move our hand near
    the PIR sensor:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们把手靠近 PIR 传感器时，我们应该看到消息 `"Motion detected!!"`：
- en: '![Figure 5.8 – Results from testing a PIR sensor](img/B21282_05_8.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – 测试 PIR 传感器的结果](img/B21282_05_8.jpg)'
- en: Figure 5.8 – Results from testing a PIR sensor
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 测试 PIR 传感器的结果
- en: With the PIR sensor tested, we are now ready to build a basic alarm system using
    the Raspberry Pi.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试了 PIR 传感器后，我们现在可以使用 Raspberry Pi 构建一个基本的报警系统。
- en: Building a simple alarm system
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个简单的报警系统
- en: The Raspberry Pi’s GPIO pins can be configured for specific communication protocols
    such as I2C or set as standard input/output pins to gauge conditions or levels.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 的 GPIO 引脚可以配置为特定的通信协议，如 I2C，或设置为标准输入/输出引脚以测量条件或水平。
- en: In this final section of the chapter, we will use our knowledge to build a simple
    alarm system. Our alarm system will consist of a pushbutton, a PIR sensor, and
    a buzzer. All components are connected to the GPIO port (*Figure 5**.9*).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将使用我们的知识来构建一个简单的报警系统。我们的报警系统将包括一个按钮、一个 PIR 传感器和一个蜂鸣器。所有组件都连接到 GPIO
    端口（*图 5.9*）。
- en: '![Figure 5.9 – Buzzer, pushbutton, and PIR sensor connected to the GPIO port
    through extension ribbon](img/B21282_05_9.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – 蜂鸣器、按钮和 PIR 传感器通过扩展排线连接到 GPIO 端口](img/B21282_05_9.jpg)'
- en: Figure 5.9 – Buzzer, pushbutton, and PIR sensor connected to the GPIO port through
    extension ribbon
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 蜂鸣器、按钮和 PIR 传感器通过扩展排线连接到 GPIO 端口
- en: In *Figure 5**.9*, we are using a GPIO extension ribbon to connect the GPIO
    port to a breadboard so that we can easily prototype and reconfigure connections.
    The ribbon simplifies the process and keeps the wiring organized. Using the GPIO
    extension cable is entirely optional. Just as we did in [*Chapter 4*](B21282_04.xhtml#_idTextAnchor068),
    our Raspberry Pi is installed with the Raspberry Pi seven-inch touchscreen with
    the associated case.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 5.9* 中，我们使用 GPIO 扩展排线将 GPIO 端口连接到面包板，这样我们就可以轻松地进行原型设计和重新配置连接。排线简化了过程并使布线整齐。使用
    GPIO 扩展电缆完全是可选的。就像我们在 [*第 4 章*](B21282_04.xhtml#_idTextAnchor068) 中做的那样，我们的 Raspberry
    Pi 安装了 Raspberry Pi 七英寸触摸屏及其相关的外壳。
- en: 'We connect the components to the GPIO port using the following diagram:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下图示将组件连接到 GPIO 端口：
- en: '![Figure 5.10 – Basic alarm circuit](img/B21282_05_10.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10 – 基本报警电路](img/B21282_05_10.jpg)'
- en: Figure 5.10 – Basic alarm circuit
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 基本报警电路
- en: 'We write the code for our alarm system in Thonny:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Thonny 中编写我们的报警系统代码：
- en: Inside Thonny, we create a new tab by selecting **File** and then **New** or
    by hitting *Ctrl* + *N* on the keyboard.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Thonny 中，我们通过选择 **文件** 然后选择 **新建** 或按键盘上的 *Ctrl* + *N* 来创建一个新的标签页。
- en: 'Inside the tab, we enter the following code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标签页中，我们输入以下代码：
- en: '[PRE6]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Before executing our code, let’s go through it.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在执行我们的代码之前，让我们先过一遍。
- en: 'We start by importing our libraries:'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先导入我们的库：
- en: '`gpiozero` for Raspberry Pi GPIO operations'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gpiozero` 用于 Raspberry Pi GPIO 操作'
- en: '`time` for creating sleep intervals'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time` 用于创建睡眠间隔'
- en: 'We then define our GPIO connections:'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们然后定义我们的 GPIO 连接：
- en: PIR sensor connected to GPIO pin 23
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: PIR 传感器连接到 GPIO 引脚 23
- en: Button connected to GPIO pin 20
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮连接到 GPIO 引脚 20
- en: Buzzer connected to GPIO pin 21
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蜂鸣器连接到 GPIO 引脚 21
- en: '`active`: The variable to keep track of alarm state (on/off)'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`active`：用于跟踪闹钟状态的变量（开启/关闭）'
- en: 'We define our `toggle_alarm()` function:'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了我们的`toggle_alarm()`函数：
- en: Switches the alarm state between active and inactive
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在活动和非活动状态之间切换闹钟状态
- en: If the alarm is deactivated while it’s sounding, the buzzer is turned off
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在蜂鸣器响起时解除闹钟，蜂鸣器会被关闭
- en: 'Our `monitor()` function is defined next:'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们接下来定义`monitor()`函数：
- en: Continuously checks for motion if the alarm system is active
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果闹钟系统处于活动状态，则持续检查运动
- en: If motion is detected, the program waits for five seconds to allow for alarm
    deactivation
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果检测到运动，程序将等待五秒钟以允许解除闹钟
- en: If the alarm is still active after the five-second delay, the buzzer sounds
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在五秒钟延迟后闹钟仍然处于活动状态，蜂鸣器会响起
- en: We then set the `button.when_pressed` `gpiozero` property to bind it to the
    `toggle_alarm()` function. This allows us to assign a function to be executed
    immediately when a button is pressed. This event-driven approach eliminates the
    need for continuous polling.
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们将`button.when_pressed`的`gpiozero`属性设置为绑定到`toggle_alarm()`函数。这允许我们在按下按钮时立即执行一个函数。这种事件驱动的方法消除了连续轮询的需要。
- en: Our main execution block runs the `monitor()` function.
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的主要执行块运行`monitor()`函数。
- en: The `try / catch` allows for a clean exit with a keyboard interrupt (*Ctrl*
    + *C*), ensuring the buzzer is turned off upon exit.
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try / catch`允许在键盘中断（*Ctrl* + *C*）的情况下干净地退出，确保在退出时蜂鸣器被关闭。'
- en: We save the program as `basic-alarm.py`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将程序保存为`basic-alarm.py`。
- en: To run the code in Thonny, we click on the green run button, hit *F5* on the
    keyboard, or click on the **Run** menu option at the top, and then **Run** **current
    script**.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在Thonny中运行代码，我们点击绿色运行按钮，在键盘上按*F5*，或者在顶部点击**运行**菜单选项，然后点击**运行****当前脚本**。
- en: We activate the alarm by pressing on a pushbutton. Our alarm’s single sensor
    is a PIR sensor, which monitors motion.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过按下按钮来激活闹钟。我们的单一传感器是PIR传感器，它监控运动。
- en: Once motion is detected, there is a five-second delay before the buzzer is activated.
    This allows time for the person who is aware of the alarm to turn it off before
    the buzzer goes off.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦检测到运动，蜂鸣器激活前会有五秒钟的延迟。这为意识到闹钟的人提供了时间，在蜂鸣器响起之前将其关闭。
- en: To turn off the alarm, we simply push the button again.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要关闭闹钟，我们只需再次按下按钮。
- en: In upcoming chapters, we’ll transform our basic alarm system into an IoT-enabled
    alarm using a Raspberry Pi Pico W. This will allow us to monitor sensor data from
    any location worldwide, offering the convenience and versatility of managing our
    alarm system as though we were right beside the installed sensors.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将我们的基本闹钟系统转变为一个使用Raspberry Pi Pico W的物联网闹钟。这将使我们能够从全球任何位置监控传感器数据，提供像在我们旁边安装的传感器一样管理我们的闹钟系统的便利性和多功能性。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In [*Chapter 5*](B21282_05.xhtml#_idTextAnchor080), we explored the Raspberry
    Pi’s GPIO pins and their communication capabilities, including protocols such
    as I2C, SPI, UART, and PCM. We highlighted the significance of the GPIO pinout
    diagram when working with the Raspberry Pi and Raspberry Pi Pico.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B21282_05.xhtml#_idTextAnchor080)中，我们探讨了Raspberry Pi的GPIO引脚及其通信能力，包括I2C、SPI、UART和PCM等协议。我们强调了GPIO引脚图在处理Raspberry
    Pi和Raspberry Pi Pico时的意义。
- en: We focused on the PIR sensor for motion detection and connected it to our Raspberry
    Pi. We then used this knowledge to build a basic alarm system using the PIR sensor,
    a pushbutton, and a buzzer. Even though we didn’t engage in a hands-on exercise
    with the Pico, the principles, and techniques we learned apply to both the Raspberry
    Pi and Raspberry Pi Pico.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们专注于PIR传感器进行运动检测，并将其连接到我们的Raspberry Pi。然后我们利用这些知识使用PIR传感器、按钮和蜂鸣器构建了一个基本的闹钟系统。尽管我们没有与Pico进行实际操作练习，但我们学到的原理和技术适用于Raspberry
    Pi和Raspberry Pi Pico。
- en: This chapter commenced the construction of our IoT home security system. In
    the upcoming chapters, we will add to our basic alarm as we turn it into an impressive
    IoT home security system by creating an IoT alarm module and an IoT button to
    arm it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始了我们物联网家庭安全系统的构建。在接下来的章节中，我们将向我们的基本闹钟添加功能，当我们将其转变为一个令人印象深刻的物联网家庭安全系统时，我们将创建一个物联网闹钟模块和一个物联网按钮来启动它。
