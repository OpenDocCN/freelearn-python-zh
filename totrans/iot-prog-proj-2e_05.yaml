- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring the GPIO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the first four chapters of the book, we have touched on the **General-Purpose
    Input/Output** (**GPIO**) port on the Raspberry Pi. In [*Chapter 3*](B21282_03.xhtml#_idTextAnchor048),
    we used it extensively in the construction of our weather indicator. In this chapter,
    we will dive deeper into the functionality and applications of the GPIO port on
    the Raspberry Pi as we start to build our IoT home security application. We will
    also explore the GPIO port on the Raspbery Pi Pico, the microcontroller cousin
    of the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: In the hands-on tutorial section, we will construct a basic alarm system using
    a PIR motion sensor to detect human presence. This system will integrate a pushbutton
    for activation control and a buzzer as an alert mechanism. Through this practical
    exercise, we will demonstrate how the Raspberry Pi can interface with various
    components to create functional real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the GPIO on the Raspberry Pi and Raspberry Pi Pico
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding sensors, actuators, and indicators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a simple alarm system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the requirements for completing this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate knowledge of Python programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A late model Raspberry Pi, preferably a Raspberry Pi 5 with at least 4 GB of
    RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A PIR sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An SFM-27 buzzer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pushbutton such as an arcade-style button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this chapter may be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter5](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter5%0D)'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the GPIO on Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The GPIO port is a versatile set of 40 pins on the Raspberry Pi and Pico, enabling
    interaction with the external world. These pins can be configured as input or
    output and can connect to sensors, LEDs, and more. Included are ports to provide
    power, several ground connections, and GPIOs designated for specific protocols
    such as I2C, UART, SPI, and PCM. In the following table, we can see how we may
    match up pins with specific communication protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – GPIO pins and communication protocols](img/B21282_05_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – GPIO pins and communication protocols
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Raspberry Pi GPIO pinout diagram
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Figure 5**.2*, we can see a pinout diagram of the GPIO ports on the Raspberry
    Pi and Raspberry Pi Pico. Outlined are the GPIO pin numbers as well as the pins
    that may be configured for special operations.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Common to many purchases of a Raspberry Pi and Raspberry Pi Pico is a reference
    sheet with the GPIO pinout diagram. This tool is extremely helpful for development,
    as it acts as a guide to the GPIO (Raspberry Pi) and GP (Pico) pin numbers required
    for device connections to the Pi and Pico, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We may find various versions of these diagrams on the internet. For those of
    us interested, there is an interactive version of the Raspberry Pi GPIO pinout
    at [https://pinout.xyz](https://pinout.xyz).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – GPIO pinout diagram](img/B21282_05_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – GPIO pinout diagram
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi’s GPIO port includes pins GPIO 0 (EEPROM SDA) and GPIO 1 (EEPROM
    SCL), which enable automatic communication with attached HATs. Additionally, there
    are pins designated for various communication protocols.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand the communication capabilities of the Raspberry Pi and
    Pico, let’s examine the specific communication protocols that we may configure
    our devices to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding GPIO pin communication protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Raspberry Pi’s and Pico’s GPIO pins enable several key communication protocols
    such as I2C, SPI, UART, and PCM. These allow the Raspberry Pi and Pico to interact
    with various devices and sensors. Each protocol has its unique applications, from
    interfacing with sensors to digital audio transmission. In the following sections,
    we’ll provide an overview of these communication methods that may be configured.
  prefs: []
  type: TYPE_NORMAL
- en: I2C
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I2C is a serial communication protocol developed by Philips Semiconductor, now
    NXP Semiconductors. I2C allows multiple devices to communicate with each other
    using a two-wire interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of the connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Serial Data Line** (**SDA**): This is the data line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serial Clock Line** (**SLC**): This is the clock line that synchronizes data
    transfer over the I2C bus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The key features of the I2C protocol include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multi-master and multi-slave**: Multiple devices can be connected to the
    bus, with the capability for more than one master.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Address-based communication**: Each device on the bus has a unique address,
    allowing targeted communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple hardware connection**: Only two pull-up resistors are required for
    the SDA and SCL lines when setting up an I2C connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed variants**: I2C supports different speed modes, including standard
    (up to 100 Kbps), fast (up to 400 Kbps), high speed (up to 3.4 Mbps), and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the Raspberry Pi and Pico, the I2C protocol is particularly valuable for
    connecting peripherals such as PIR sensors, mini-OLED screens, and other components
    using just two wires.
  prefs: []
  type: TYPE_NORMAL
- en: SPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Serial Peripheral Interface** (**SPI**) is a synchronous serial communication
    protocol used for short-distance communication, primarily in embedded systems,
    to connect microcontrollers and peripheral devices such as sensors, SD cards,
    and LCDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of the connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SDO—Serial Data Out**: This line is used for sending data from the controller
    to the peripherals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SDI—Serial Data In**: This line allows peripherals to send data back to the
    controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SCLK—Serial Clock**: Like the SCL line in I2C, this provides the clock signal,
    synchronizing data transfer between devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CS0—Chip Select 0**: This line is crucial for selecting specific devices
    when there are multiple peripherals. By toggling CS0, the controller can determine
    which device it’s communicating with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CS1—Chip Select 1**: Like CS0, CS1 provides an additional selection line,
    enabling the addressing of more devices on a single SPI bus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the features and advantages of SPI:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full-duplex communication**: SPI supports simultaneous bidirectional communication,
    allowing data to be sent and received at the same time. This means that during
    an SPI communication, data can flow from the master to the slave and from the
    slave to the master concurrently. This is unlike I2C, which operates in a half-duplex
    mode (can either send or receive data at any given moment, but not at the same
    time).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed**: SPI often outpaces I2C in terms of data transfer rates, making it
    suitable for applications that demand higher-speed communications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Direct hardware control**: Without a specific addressing scheme as in I2C,
    SPI offers more straightforward device control via the CE pins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SPI communication is useful when connecting components such as SD cards, displays,
    **ADCs** (short for **analog-to-digital converters**), and more. An example is
    an application where we connect an SD card via SPI for data logging.
  prefs: []
  type: TYPE_NORMAL
- en: UART
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: UART, which stands for **Universal Asynchronous Receiver–Transmitter**, is a
    prevalent communication protocol in the electronics domain, especially known for
    its simplicity and effectiveness in point-to-point communications between devices.
    UART stands out with its full-duplex communication capability. This allows two
    devices to exchange data concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of the connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TX—Transmit**: This connection is used to send data out to another device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RX—Receive**: Conversely, this connection is used to receive data from another
    device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These connections allow for simultaneous bidirectional communication; while
    the Raspberry Pi and Pico transmit data via their TX pins, they can also receive
    data through their RX pins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some features of UART compared to other communication methods such as I2C and
    SPI include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Peer-to-peer communication**: Unlike I2C and SPI, which have defined master-slave
    relationships, UART devices communicate as equals, with no designated master or
    slave.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous mechanism**: Unlike SPI, UART communication doesn’t rely on
    a shared clock signal. Instead, both devices must agree on a baud rate before
    initiating communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given its simplicity, UART is commonly used for serial console access and interfacing
    with peripherals that demand a straightforward communication path. One common
    use of UART and the Raspberry PI is the connection of flight controllers for drones.
  prefs: []
  type: TYPE_NORMAL
- en: PCM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can set GPIO pins 12, 35, 38, and 40 on the Raspberry Pi for **PCM** (**Pulse-Code
    Modulation**), which digitally represents analog signals by sampling their magnitude
    at regular intervals and quantizing it into a digital code. These pins are specifically
    designated for PCM communication on the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GPIO 12** (**PCM_CLK**): This is the clock pin, ensuring synchronization
    during data transfer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GPIO 35** (**PCM_FS**): This is frame sync. It helps in defining the start
    and end of the data frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GPIO 38** (**PCM_DIN**): This is the data input. This is where the Raspberry
    Pi receives PCM data from external devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GPIO 40** (**PCM_DOUT**): This is the data output. The Raspberry Pi uses
    this pin to send PCM data to other devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some notable aspects of PCM include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Digital representation**: PCM converts analog signals into a digital format,
    making it ideal for preserving the nuance of the original signal in a format that’s
    resistant to noise and interference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Common in audio**: Many audio formats, such as WAV, use PCM to represent
    sound digitally, ensuring high fidelity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: PCM can be used for a range of applications beyond audio,
    including telecommunications and data storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the Raspberry Pi, PCM’s utility is evident in various tasks, from digital
    audio playback and recording to interfacing with devices that require precise
    analog-to-digital representations. A notable application of PCM with the Raspberry
    Pi is in the field of digital audio systems and sound interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a table summarizing the communication protocols and the Raspberry
    Pi and Raspberry Pi Pico:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Communication protocols summarized](img/B21282_05_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Communication protocols summarized
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the communication protocols we may use with the Raspberry
    Pi and Raspberry Pi Pico, let’s look at sensors, actuators, and indicators and
    how we may hook them up to our Raspberry Pi and Raspberry Pi Pico. This is the
    main purpose of the GPIO port.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding sensors, actuators, and indicators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GPIO functionality of the Raspberry Pi and Pico offers a foundation for
    connecting various sensors and driving indicators like LEDs and controlling actuators
    like servo motors. By integrating these devices, our devices can both collect
    data and execute responsive actions based on this information.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, a PIR sensor (*A* in *Figure 5**.4*) can detect motion in a room,
    prompting an LED or triggering an alarm. Using temperature and humidity sensors,
    such as DHT11 (*B* in *Figure 5**.4*), we can assess environmental conditions
    and, in response, engage a fan or a heating element.
  prefs: []
  type: TYPE_NORMAL
- en: 'With distance sensors (*C* in *Figure 5**.4*), we can measure the closeness
    of objects and instruct a servo motor to halt a robot, preventing collisions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Sensors for the Raspberry Pi](img/B21282_05_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Sensors for the Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: Numerous devices can be integrated with our Raspberry Pi and Pico. Robotics
    alone offers line tracking sensors for directing robots along set paths and **Time
    of Flight** (**TOF**) sensors, which are compact and precise distance sensors.
    Beyond robotics, there are sensors for soil moisture, rain detection, light, and
    temperature/humidity, creating the potential for a self-regulating greenhouse.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll explore connecting and reading data from a PIR sensor
    (*A* in *Figure 5**.4*) and a Raspberry Pi using Python and the GPIO Zero library.
    Taking what we learn, we will use our knowledge to create a basic alarm system
    with our Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by setting up our development environment before we write code
    to interact with the PIR sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our development environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use a Python virtual environment for our development. As there are
    libraries that only work with the root installation of Python, we will use system
    packages in our Python virtual environment. To do so, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: On our Raspberry Pi 5, we open a Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To store our project files, we create a new directory with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then navigate to the new directory with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create a new Python virtual environment for our project with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With our new Python virtual environment created, we source into it with the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 5.5 – Terminal using dashboard-env environment](img/B21282_05_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Terminal using dashboard-env environment
  prefs: []
  type: TYPE_NORMAL
- en: 'We close the Terminal with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are now ready to load up Thonny. We do so by clicking on the **Menu** icon
    in the Raspberry Pi taskbar, navigating to the **Programming** category, and selecting
    **Thonny**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, Thonny uses the Raspberry Pi’s built-in version of Python. For our
    project, we will use the Python virtual environment we just created. To start
    we need to view the project files by clicking on **View** and selecting **Files**
    if it is not already selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Files` section, we locate the `ch5-env` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then right-click on the folder and select the option **Activate virtual**
    **environment** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Activating a Python virtual environment in Thonny](img/B21282_05_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Activating a Python virtual environment in Thonny
  prefs: []
  type: TYPE_NORMAL
- en: With our project folder created and our Python virtual environment set up and
    activated, we may now start writing code to access sensors connected to the GPIO
    port. We will start by exploring PIR sensors a little more.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the PIR sensor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Passive infrared** (**PIR**) sensors are devices specialized in detecting
    infrared radiation, typically emitted by living beings due to their body heat.
    These sensors work by monitoring changes in infrared levels, which occur when
    an infrared source, such as a human, moves across its field of view. PIR sensors
    can be recognized by their distinctive sphere shell that dominates the sensor
    (*A* in *Figure 5**.4*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connecting a PIR sensor to a Raspberry Pi is straightforward. Three pins are
    needed:'
  prefs: []
  type: TYPE_NORMAL
- en: VCC is connected to 5V from the Raspberry Pi.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GND is connected to a GND pin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signal is connected to GPIO 23.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In *Figure 5**.7*, we see a PIR sensor connected to a Raspberry Pi using a
    breadboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Connecting a PIR sensor to a Raspberry Pi](img/B21282_05_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Connecting a PIR sensor to a Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: 'To acquire sensory data from our PIR sensor, we use the GPIO Zero library.
    To do so, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In Thonny, we create a new tab by selecting **File** and then **New** or by
    hitting *Ctrl* + *N* on the keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the tab, we enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We save the code as `pir-test.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To run the code in Thonny, we click on the green run button and hit *F5* on
    the keyboard or click on the **Run** menu option at the top and then **Run** **current
    script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We should see the message `"Motion detected!!"` when we move our hand near
    the PIR sensor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Results from testing a PIR sensor](img/B21282_05_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Results from testing a PIR sensor
  prefs: []
  type: TYPE_NORMAL
- en: With the PIR sensor tested, we are now ready to build a basic alarm system using
    the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple alarm system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Raspberry Pi’s GPIO pins can be configured for specific communication protocols
    such as I2C or set as standard input/output pins to gauge conditions or levels.
  prefs: []
  type: TYPE_NORMAL
- en: In this final section of the chapter, we will use our knowledge to build a simple
    alarm system. Our alarm system will consist of a pushbutton, a PIR sensor, and
    a buzzer. All components are connected to the GPIO port (*Figure 5**.9*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Buzzer, pushbutton, and PIR sensor connected to the GPIO port
    through extension ribbon](img/B21282_05_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Buzzer, pushbutton, and PIR sensor connected to the GPIO port through
    extension ribbon
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 5**.9*, we are using a GPIO extension ribbon to connect the GPIO
    port to a breadboard so that we can easily prototype and reconfigure connections.
    The ribbon simplifies the process and keeps the wiring organized. Using the GPIO
    extension cable is entirely optional. Just as we did in [*Chapter 4*](B21282_04.xhtml#_idTextAnchor068),
    our Raspberry Pi is installed with the Raspberry Pi seven-inch touchscreen with
    the associated case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We connect the components to the GPIO port using the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Basic alarm circuit](img/B21282_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Basic alarm circuit
  prefs: []
  type: TYPE_NORMAL
- en: 'We write the code for our alarm system in Thonny:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside Thonny, we create a new tab by selecting **File** and then **New** or
    by hitting *Ctrl* + *N* on the keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the tab, we enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before executing our code, let’s go through it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We start by importing our libraries:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gpiozero` for Raspberry Pi GPIO operations'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time` for creating sleep intervals'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We then define our GPIO connections:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: PIR sensor connected to GPIO pin 23
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Button connected to GPIO pin 20
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Buzzer connected to GPIO pin 21
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`active`: The variable to keep track of alarm state (on/off)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We define our `toggle_alarm()` function:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Switches the alarm state between active and inactive
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the alarm is deactivated while it’s sounding, the buzzer is turned off
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `monitor()` function is defined next:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuously checks for motion if the alarm system is active
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If motion is detected, the program waits for five seconds to allow for alarm
    deactivation
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the alarm is still active after the five-second delay, the buzzer sounds
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We then set the `button.when_pressed` `gpiozero` property to bind it to the
    `toggle_alarm()` function. This allows us to assign a function to be executed
    immediately when a button is pressed. This event-driven approach eliminates the
    need for continuous polling.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Our main execution block runs the `monitor()` function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `try / catch` allows for a clean exit with a keyboard interrupt (*Ctrl*
    + *C*), ensuring the buzzer is turned off upon exit.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We save the program as `basic-alarm.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To run the code in Thonny, we click on the green run button, hit *F5* on the
    keyboard, or click on the **Run** menu option at the top, and then **Run** **current
    script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We activate the alarm by pressing on a pushbutton. Our alarm’s single sensor
    is a PIR sensor, which monitors motion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once motion is detected, there is a five-second delay before the buzzer is activated.
    This allows time for the person who is aware of the alarm to turn it off before
    the buzzer goes off.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To turn off the alarm, we simply push the button again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In upcoming chapters, we’ll transform our basic alarm system into an IoT-enabled
    alarm using a Raspberry Pi Pico W. This will allow us to monitor sensor data from
    any location worldwide, offering the convenience and versatility of managing our
    alarm system as though we were right beside the installed sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B21282_05.xhtml#_idTextAnchor080), we explored the Raspberry
    Pi’s GPIO pins and their communication capabilities, including protocols such
    as I2C, SPI, UART, and PCM. We highlighted the significance of the GPIO pinout
    diagram when working with the Raspberry Pi and Raspberry Pi Pico.
  prefs: []
  type: TYPE_NORMAL
- en: We focused on the PIR sensor for motion detection and connected it to our Raspberry
    Pi. We then used this knowledge to build a basic alarm system using the PIR sensor,
    a pushbutton, and a buzzer. Even though we didn’t engage in a hands-on exercise
    with the Pico, the principles, and techniques we learned apply to both the Raspberry
    Pi and Raspberry Pi Pico.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter commenced the construction of our IoT home security system. In
    the upcoming chapters, we will add to our basic alarm as we turn it into an impressive
    IoT home security system by creating an IoT alarm module and an IoT button to
    arm it.
  prefs: []
  type: TYPE_NORMAL
