<html><head></head><body><div><h1 class="header-title">Creating Games and Graphics</h1>
                
            
            
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Using IDLE3 to debug your programs</li>
<li>Drawing lines using a mouse on a Tkinter Canvas</li>
<li>Creating a bat and ball game</li>
<li>Creating an overhead scrolling game</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Games are often a great way to explore and extend your programming skills, as they present an inherent motivating force to modify and improve your creation, add new features, and create new challenges. They are also great for sharing your ideas with others, even if they aren't interested in programming.</p>
<p>This chapter focuses on using the Tkinter Canvas widget to create and display objects on a screen for the user to interact with. Using these techniques, a wide variety of games and applications can be created, limited only by your own creativity.</p>
<p>We will also take a quick look at using the debugger built into IDLE3, a valuable tool for testing and developing your programs without the need to write extensive test code.</p>
<p>The first example demonstrates how we can monitor and make use of the mouse to create objects and draw directly on the Canvas widget. Then, we create a bat and ball game, which shows how the positions of objects can be controlled and how interactions between them can be detected and responded to. Finally, we take things a little further and use Tkinter to place our own graphics onto the Canvas widget to create an overhead view treasure hunt game.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using IDLE3 to debug your programs</h1>
                
            
            
                
<p>A key aspect of programming is being able to test and debug your code, and a useful tool to achieve this is a debugger. The IDLE editor (make sure you use IDLE3 to support the Python 3 code we use in this book) includes a basic debugger. It allows you to step through your code, observe the values of local and global variables, and set breakpoints.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>To enable the debugger, start IDLE3 and select Debugger from the Debug menu; it will open up the following window (if you are currently running some code, you will need to stop it first):</li>
</ol>
<div><img src="img/2cb1160c-a6c5-41da-a129-ffc1d43a430d.png" style="width:44.58em;height:20.83em;" width="659" height="308"/></div>
<p>The IDLE3 debugger window</p>
<ol start="2">
<li>Open up the code you want to test (via File | Open...) and try running it (<em>F5</em>). You will find that the code will not start since the debugger has automatically stopped at the first line. The following screenshot shows that the debugger has stopped on the first line of code in <kbd>filehandler.py</kbd>, which is <kbd>line 3: import os</kbd>:</li>
</ol>
<div><img src="img/fd9ccc69-4360-437d-8a60-bd62796a177d.png" style="width:43.50em;height:28.58em;" width="550" height="361"/></div>
<p>The IDLE3 debugger at the start of the code</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The control buttons shown in the following screenshot allow you to run and/or jump through the code:</p>
<div><img src="img/fcb83ee8-3292-4740-90dc-c868f52e19da.png" style="width:28.67em;height:2.75em;" width="375" height="36"/></div>
<p>Debugger controls</p>
<p>The functions of the control buttons are as follows:</p>
<ul>
<li>Go: This button will execute the code as normal.</li>
<li>Step: This button will execute the block of code one line at a time, and then stop again. If a function is called, it will enter that function and allow you to step through that, too.</li>
<li>Over: This button is like the Step command, but if there is a function call, it will execute the whole function and stop at the following line.</li>
<li>Out: This button will keep executing the code until it has completed the function it is currently in, continuing until you come out of the function.</li>
<li>Quit: This button ends the program immediately.</li>
</ul>
<p>In addition to the previously mentioned controls, you can Set Breakpoint and Clear Breakpoint directly within the code. A breakpoint is a marker that you can insert in the code (by right-clicking on the editor window), which the debugger will always break on (stop at) when reached, as shown in the following screenshot:</p>
<div><img src="img/0556a804-3c2f-43d5-b2b2-28921732b6e6.png" style="width:44.33em;height:19.33em;" width="507" height="221"/></div>
<p>Set and clear breakpoints directly in your code</p>
<p>The checkboxes (on the right-hand side of the control buttons) allow you to choose what information to display when you step through the code or when the debugger stops somewhere due to a breakpoint. Stack is shown in the main window, which is similar to what you would see if the program hit an unhandled exception. The Stack option shows all of the function calls made to get to the current position in the code, right up to the line it has stopped at. The Source option highlights the line of code currently being executed and, in some cases, the code inside the imported modules, too (if they are non-compiled libraries).</p>
<p>You can also select whether to display Locals and/or Globals. By default, the Source and Globals options are usually disabled, as they can make the process quite slow if there is a lot of data to display.</p>
<p>Python uses the concept of local and global variables to define the scope (where and when the variables are visible and valid). Global variables are defined at the top level of the file and are visible from any point in the code, after it has been defined. However, in order to alter its value from anywhere other than the top level, Python requires you to use the global keyword first. Without the global keyword, you will create a local copy with the same name (the value of which will be lost when you exit the block). Local variables are defined when you create a variable within a function; once outside of the function, the variable is destroyed and is not visible anymore.</p>
<p>Following Stack data are the Locals – in this case, <kbd>aPhoto</kbd>, <kbd>filename</kbd>, and <kbd>self</kbd>. Then (if enabled), we have all of the global values that are currently valid, providing useful details about the status of the program (<kbd>DATE = 1</kbd>, <kbd>DEBUG = True</kbd>, <kbd>FOLDERSONLY = True</kbd>, and so on):</p>
<div><img src="img/dbc36fcb-4ffe-4ee0-8cd5-6f264e81f267.png" style="width:33.67em;height:32.58em;" width="550" height="532"/></div>
<p>The Stack, Locals, and Globals options within the debugger</p>
<p>The debugger isn't particularly advanced, as it does not allow you to expand complex objects, such as the <kbd>photohandler.Photo</kbd> object, to see what data it contains. However, if required, you can adjust your code and assign the data you want to observe to some temporary variables during testing.</p>
<p>It is worth learning how to use the debugger, as it is a much easier way to track down particular problems and check whether or not things are functioning as you expect them to.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Drawing lines using a mouse on Tkinter Canvas</h1>
                
            
            
                
<p class="packt_figure">The Tkinter Canvas widget provides an area to create and draw objects on. The following script demonstrates how to use mouse events to interact with Tkinter. By detecting the mouse clicks, we can use Tkinter to draw a line that follows the movement of the mouse:</p>
<div><img src="img/72dfae6f-9ceb-4b53-946d-f9567b5b81b9.png" style="width:29.17em;height:23.17em;" width="300" height="238"/></div>
<p>A simple drawing application using Tkinter</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>As before, we need to have Tkinter installed, and either the Raspbian desktop running (<kbd>startx</kbd> from the command line) or an SSH session with X11 forwarding and an X server running (see <a href="b2230c60-fd75-45fd-82c8-e477459db3e0.xhtml" target="_blank">Chapter 1</a>, <em>Getting Started with a Raspberry Pi 3 Computer</em>). We will also need a mouse connected.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Create the following script, <kbd>painting.py</kbd>:</p>
<pre>#!/usr/bin/python3 
#painting.py 
import tkinter as TK 
 
#Set defaults 
btn1pressed = False 
newline = True 
 
def main(): 
  root = TK.Tk() 
  the_canvas = TK.Canvas(root) 
  the_canvas.pack() 
  the_canvas.bind("&lt;Motion&gt;", mousemove) 
  the_canvas.bind("&lt;ButtonPress-1&gt;", mouse1press) 
  the_canvas.bind("&lt;ButtonRelease-1&gt;", mouse1release) 
  root.mainloop() 
 
def mouse1press(event): 
  global btn1pressed 
  btn1pressed = True 
 
def mouse1release(event): 
  global btn1pressed, newline 
  btn1pressed = False 
  newline = True 
 
def mousemove(event): 
  if btn1pressed == True: 
    global xorig, yorig, newline 
    if newline == False: 
      event.widget.create_line(xorig,yorig,event.x,event.y, 
                               smooth=TK.TRUE) 
    newline = False 
    xorig = event.x 
    yorig = event.y 
 
if __name__ == "__main__": 
  main() 
#End</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The Python code creates a Tkinter window that contains a <kbd>Canvas</kbd> object called<br/>
<kbd>the_canvas</kbd>. We use the <kbd>bind</kbd> function here, which will bind a specific event that occurs on this widget (<kbd>the_canvas</kbd>) to a specific action or key press. In this case, we bind the <kbd>&lt;Motion&gt;</kbd> function of the mouse, plus the click and release of the first mouse button (<kbd>&lt;ButtonPress-1&gt;</kbd> and <kbd>&lt;ButtonRelease-1&gt;</kbd>). Each of these events are then used to call the <kbd>mouse1press()</kbd>, <kbd>mouse1release()</kbd>, and <kbd>mousemove()</kbd> functions.</p>
<p>The logic here is to track the status of the mouse button using the <kbd>mouse1press()</kbd> and <kbd>mouse1release()</kbd> functions.</p>
<p>If the mouse button has been clicked, the <kbd>mousemove()</kbd> function will check to see whether we are drawing a new line (we set new coordinates for this) or continuing an old one (we draw a line from the previous coordinates to the coordinates of the current event that has triggered <kbd>mousemove()</kbd>). We just need to ensure that we reset to the <kbd>newline</kbd> command whenever the mouse button is released to reset the start position of the line.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Creating a bat and ball game</h1>
                
            
            
                
<p>A classic bat and ball game can be created using the drawing tools of <kbd>canvas</kbd> and detecting the collisions of the objects. The user will be able to control the green paddle, using the left and right cursor keys to aim the ball at the bricks and hit them until they have all been destroyed:</p>
<div><img src="img/f6fe6c2b-966c-413b-9975-01727c500869.png" style="width:34.17em;height:26.83em;" width="636" height="501"/></div>
<p>A game in progress</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This example requires graphical output, so you must have a screen and keyboard attached to the Raspberry Pi, or use X11 forwarding and X server if connected remotely from another computer.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Create the following script, <kbd>bouncingball.py</kbd>:</p>
<ol>
<li>First, import the <kbd>tkinter</kbd> and <kbd>time</kbd> modules, and define constants for the<br/>
game graphics:</li>
</ol>
<pre style="padding-left: 60px">#!/usr/bin/python3 
# bouncingball.py 
import tkinter as TK 
import time 
 
VERT,HOREZ=0,1 
xTOP,yTOP = 0,1 
xBTM,yBTM = 2,3 
MAX_WIDTH,MAX_HEIGHT = 640,480 
xSTART,ySTART = 100,200 
BALL_SIZE=20 
RUNNING=True </pre>
<ol start="2">
<li>Next, create functions for closing the program, moving the paddle right and left, and for calculating the direction of the ball:</li>
</ol>
<pre style="padding-left: 60px">def close(): 
  global RUNNING 
  RUNNING=False 
  root.destroy() 
 
def move_right(event): 
  if canv.coords(paddle)[xBTM]&lt;(MAX_WIDTH-7): 
    canv.move(paddle, 7, 0) 
 
def move_left(event): 
  if canv.coords(paddle)[xTOP]&gt;7: 
    canv.move(paddle, -7, 0) 
 
def determineDir(ball,obj): 
  global delta_x,delta_y 
  if (ball[xTOP] == obj[xBTM]) or (ball[xBTM] ==  
      obj[xTOP]): 
    delta_x = -delta_x 
  elif (ball[yTOP] == obj[yBTM]) or (ball[yBTM] ==  
        obj[yTOP]): 
    delta_y = -delta_y </pre>
<ol start="3">
<li>Set up the <kbd>tkinter</kbd> window and define the <kbd>canvas</kbd>:</li>
</ol>
<pre style="padding-left: 60px">root = TK.Tk() 
root.title("Bouncing Ball") 
root.geometry('%sx%s+%s+%s' %(MAX_WIDTH, MAX_HEIGHT, 100, 100)) 
root.bind('&lt;Right&gt;', move_right) 
root.bind('&lt;Left&gt;', move_left) 
root.protocol('WM_DELETE_WINDOW', close) 
 
canv = TK.Canvas(root, highlightthickness=0) 
canv.pack(fill='both', expand=True)</pre>
<ol start="4">
<li>Add the borders, <kbd>ball</kbd>, and <kbd>paddle</kbd> objects to the <kbd>canvas</kbd>:</li>
</ol>
<pre style="padding-left: 60px">top = canv.create_line(0, 0, MAX_WIDTH, 0, fill='blue', 
                       tags=('top')) 
left = canv.create_line(0, 0, 0, MAX_HEIGHT, fill='blue', 
                        tags=('left')) 
right = canv.create_line(MAX_WIDTH, 0, MAX_WIDTH, MAX_HEIGHT, 
                         fill='blue', tags=('right')) 
bottom = canv.create_line(0, MAX_HEIGHT, MAX_WIDTH, MAX_HEIGHT, 
                          fill='blue', tags=('bottom')) 
 
ball = canv.create_rectangle(0, 0, BALL_SIZE, BALL_SIZE, 
                             outline='black', fill='black',  
                             tags=('ball')) 
paddle = canv.create_rectangle(100, MAX_HEIGHT - 30, 150, 470, 
                               outline='black',  
                               fill='green', tags=('rect')) </pre>
<ol start="5">
<li>Draw all of the bricks and set up the ball and paddle positions:</li>
</ol>
<pre style="padding-left: 60px">brick=list() 
for i in range(0,16): 
  for row in range(0,4): 
    brick.append(canv.create_rectangle(i*40, row*20, 
                 ((i+1)*40)-2, ((row+1)*20)-2, 
                 outline='black', fill='red', 
                 tags=('rect'))) 
 
delta_x = delta_y = 1 
xold,yold = xSTART,ySTART 
canv.move(ball, xold, yold) </pre>
<ol start="6">
<li>Create the main loop for the game to check for collisions and handle the movement of the paddle and ball:</li>
</ol>
<pre style="padding-left: 60px">while RUNNING: 
  objects = canv.find_overlapping(canv.coords(ball)[0], 
                                  canv.coords(ball)[1], 
                                  canv.coords(ball)[2], 
                                  canv.coords(ball)[3]) 
 
  #Only change the direction once (so will bounce off 1st 
  # block even if 2 are hit) 
  dir_changed=False 
  for obj in objects: 
    if (obj != ball): 
      if dir_changed==False: 
        determineDir(canv.coords(ball),canv.coords(obj)) 
        dir_changed=True 
      if (obj &gt;= brick[0]) and (obj &lt;= brick[len(brick)-1]): 
        canv.delete(obj) 
      if (obj == bottom): 
        text = canv.create_text(300,100,text="YOU HAVE MISSED!") 
        canv.coords(ball, (xSTART,ySTART, 
                    xSTART+BALL_SIZE,ySTART+BALL_SIZE)) 
        delta_x = delta_y = 1 
        canv.update() 
        time.sleep(3) 
        canv.delete(text) 
  new_x, new_y = delta_x, delta_y 
  canv.move(ball, new_x, new_y) 
 
  canv.update() 
  time.sleep(0.005) 
#End </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We create a Tkinter application that is 640 x 480 pixels and bind the <kbd>&lt;Right&gt;</kbd> and <kbd>&lt;Left&gt;</kbd> cursor keys to the <kbd>move_right()</kbd> and <kbd>move_left()</kbd> functions. We use <kbd>root.protocol('WM_DELETE_WINDOW', close)</kbd> to detect when the window is closed, so that we can cleanly exit the program (via <kbd>close()</kbd>, which sets <kbd>RUNNING</kbd> to <kbd>False</kbd>).</p>
<p>We then add a Canvas widget that will hold all our objects to the application. We create the following objects: <kbd>top</kbd>, <kbd>left</kbd>, <kbd>right</kbd>, and <kbd>bottom</kbd>. These make up our bounding sides for our game area. The <kbd>canvas</kbd> coordinates are <kbd>0,0</kbd> in the top-left corner and <kbd>640,480</kbd> in the bottom-right corner, so the start and end coordinates can be determined for each side (using <kbd>canv.create_line(xStart, yStart, xEnd, yEnd)</kbd>):</p>
<div><img src="img/a75623a9-6ddd-4bce-9143-3ff9aeb61f3e.png" style="width:18.67em;height:12.42em;" width="619" height="411"/></div>
<p>The coordinates of the Canvas widget</p>
<p>You can also add multiple <kbd>tags</kbd> to the objects; <kbd>tags</kbd> are often useful for defining specific actions or behaviors of objects. For instance, they allow for different types of events to occur when specific objects or bricks are hit. We will see more uses of <kbd>tags</kbd> in the next example.</p>
<p>Next, we define the ball and paddle objects, which are added using <kbd>canv.create_rectangle()</kbd>. This requires two sets of coordinates that define the opposite corners of the image (in this case, the top-left and bottom-right corners).</p>
<p>A Tkinter rectangle is defined by the coordinates of the two corners:</p>
<div><img src="img/e0ddc64f-8bf6-41e4-9806-464cae5ef0fb.png" style="width:12.00em;height:6.83em;" width="402" height="229"/></div>
<p>Example of Tkinter rectangle</p>
<p>Finally, we can create the bricks!</p>
<p>We want our bricks to be 40 x 20 pixels wide so that we can fit 16 bricks across our game area of 640 pixels (in four rows). We can create a list of brick objects with their positions defined automatically, as shown in the following code:</p>
<pre>brick=list() 
for i in range(0,16): 
  for row in range(0,4): 
    brick.append(canv.create_rectangle(i*40, row*20,  
                 ((i+1)*40)-2, ((row+1)*20)-2, outline='black',  
                 fill='red', tags=('rect'))) </pre>
<p>A brick-like effect is provided by making the bricks slightly smaller (<kbd>-2</kbd>) to create a small gap:</p>
<div><img src="img/7ad77ba6-9a6a-40fd-b80d-ad33a1609431.png" style="width:35.00em;height:5.33em;" width="655" height="100"/></div>
<p>4 x 16 block of rows</p>
<p>We will now set the default settings before starting the main control loop. The movement of the ball will be governed by <kbd>delta_x</kbd> and <kbd>delta_y</kbd>, which are added to or subtracted from the ball's previous position in each cycle.</p>
<p>Next, we set the starting position of the ball and use the <kbd>canv.move()</kbd> function to move the ball by that amount. The <kbd>move()</kbd> function will add <kbd>100</kbd> to the <kbd>x</kbd> and <kbd>y</kbd> coordinates of the ball object, which was originally created at position <kbd>0,0</kbd>.</p>
<p>Now that everything is set up, the main loop can run; this will check that the ball has not hit anything (using the <kbd>canv.find_overlapping()</kbd> function), make any adjustments to the <kbd>delta_x</kbd> or <kbd>delta_y</kbd> values, and then apply them to move the ball to the next location.</p>
<p>The sign of <kbd>delta_x</kbd> and <kbd>delta_y</kbd> determines the direction of the ball. Positive values will make the ball travel diagonally downwards and towards the right, while <kbd>-delta_x</kbd> will make it travel towards the left – either downwards or upwards, depending on whether <kbd>delta_y</kbd> is positive or negative.</p>
<p>After the ball has been moved, we use <kbd>canv.update()</kbd> to redraw any changes made to the display, and <kbd>time.sleep()</kbd> allows a small delay before checking and moving the ball again.</p>
<p>Object collisions are detected using the <kbd>canv.find_overlapping()</kbd> function. This returns a list of <kbd>canvas</kbd> objects that are found to be overlapping the bounds of a rectangle defined by the supplied coordinates. For example, in the case of the square ball, are any of the coordinates of the <kbd>canvas</kbd> objects within the space the ball is occupying? See the following:</p>
<div><img src="img/38695a4d-8844-48c2-89db-de31d2651269.png" style="width:22.08em;height:8.92em;" width="644" height="261"/></div>
<p>The objects are checked to detect if they overlap each other</p>
<p>If the ball is found to be overlapping another object, such as the walls, the paddle, or one or more of the bricks, we need to determine which direction the ball should travel in next. Since we are using the coordinates of the ball as the area within which to check, the ball will always be listed, so that we ignore them when we check the list of objects.</p>
<p>We use the <kbd>dir_changed</kbd> flag to ensure that if we hit two bricks at the same time, we do not change direction twice before we move the ball. Otherwise, it would cause the ball to continue moving in the same direction, even though it has collided with the bricks.</p>
<p>So, if the ball is overlapping something else, we can call <kbd>determineDir()</kbd> with the coordinates of the ball and the object to work out what the new direction should be.</p>
<p>When the ball collides with something, we want the ball to bounce off of it; fortunately, this is easy to simulate, as we just need to change the sign of either <kbd>delta_x</kbd> or <kbd>delta_y</kbd>, depending on whether we have hit something on the sides or the top/bottom. If the ball hits the bottom of another object, it means that we were traveling upwards and should now travel downwards. However, we will continue to travel in the same direction on the <kbd>x</kbd> axis (be it left or right, or just up). This can be seen from the following code:</p>
<pre>if (ball[xTOP] == obj[xBTM]) or (ball[xBTM] == obj[xTOP]): 
    delta_x = -delta_x </pre>
<p>The <kbd>determineDir()</kbd> function looks at the coordinates of the ball and the object, and looks for a match between either the left and right <kbd>x</kbd> coordinates or the top and bottom <kbd>y</kbd> coordinates. This is enough to say whether the collision is on the sides or top/bottom, and we can set the <kbd>delta_x</kbd> or <kbd>delta_y</kbd> signs accordingly, as can be seen in the following code:</p>
<pre>if (obj &gt;= brick[0]) and (obj &lt;= brick[-1]): 
    canv.delete(obj) </pre>
<p>Next, we can determine whether we have hit a brick by checking whether the overlapping object ID is between the first and last ID bricks. If it was a brick, we can remove it using <kbd>canv.delete()</kbd>.</p>
<p>Python allows the index values to wrap around, rather than access, the invalid memory, so an index value of <kbd>-1</kbd> will provide us with the last item in the list. We use this to reference the last brick as <kbd>brick [-1]</kbd>.</p>
<p>We also check to see whether the object being overlapped is the bottom line (in which case, the player has missed the ball with the paddle), so a short message is briefly displayed. We reset the position of the <kbd>ball</kbd> and <kbd>delta_x</kbd>/<kbd>delta_y</kbd> values. The <kbd>canv.update()</kbd> function ensures that the display is refreshed with the message before it is deleted (three seconds later).</p>
<p>Finally, the ball is moved by the <kbd>delta_x</kbd>/<kbd>delta_y</kbd> distance, and the display is updated. A small delay is added here to reduce the rate of updates and the CPU time used. Otherwise, you will find that your Raspberry Pi will become unresponsive if it is spending 100 percent of its effort running the program.</p>
<p>When the user presses the cursor keys, the <kbd>move_right()</kbd> and <kbd>move_left()</kbd> functions are called. They check the position of the paddle object, and if the paddle is not at the edge, the paddle will be moved accordingly. If the ball hits the paddle, the collision detection will ensure that the ball bounces off, just as if it has hit one of the bricks.</p>
<p>You can extend this game further by adding a score for each block destroyed, allowing the player a finite number of lives that are lost when they miss the ball, and even writing some code to read in new brick layouts.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Creating an overhead scrolling game</h1>
                
            
            
                
<p>By using objects and images in our programs, we can create many types of 2D graphical games.</p>
<p>In this recipe, we will create a treasure hunt game where the player is trying to find buried treasure (by pressing <em>Enter</em> to dig for it). Each time the treasure has not been found, the player is given a clue to how far away the treasure is; the player can then use the cursor keys to move around and search until they find it:</p>
<div><img src="img/7a03175d-c108-4242-a127-2c8626a9e273.png" style="width:40.25em;height:31.58em;" width="637" height="500"/></div>
<p>Dig for treasure in your own overhead scrolling game</p>
<p>Although this is a basic concept for a game, it could easily be extended to include multiple layouts, traps, and enemies to avoid, and perhaps even additional tools or puzzles to solve. With a few adjustments to the graphics, the character could be exploring a dungeon, a spaceship, or hopping through the clouds, collecting rainbows!</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>The following example uses a number of images; these are available as part of the book's resources. You will need to place the nine images in the same directory as the Python script.</p>
<p>The required image files can be seen in the code bundle of this chapter.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Create the following script, <kbd>scroller.py</kbd>:</p>
<ol>
<li>Begin by importing the required libraries and parameters:</li>
</ol>
<pre style="padding-left: 60px">#!/usr/bin/python3 
# scroller.py 
import tkinter as TK 
import time 
import math 
from random import randint 
 
STEP=7 
xVAL,yVAL=0,1 
MAX_WIDTH,MAX_HEIGHT=640,480 
SPACE_WIDTH=MAX_WIDTH*2 
SPACE_HEIGHT=MAX_HEIGHT*2 
LEFT,UP,RIGHT,DOWN=0,1,2,3 
SPACE_LIMITS=[0,0,SPACE_WIDTH-MAX_WIDTH, 
              SPACE_HEIGHT-MAX_HEIGHT] 
DIS_LIMITS=[STEP,STEP,MAX_WIDTH-STEP,MAX_HEIGHT-STEP] 
BGN_IMG="bg.gif" 
PLAYER_IMG=["playerL.gif","playerU.gif", 
            "playerR.gif","playerD.gif"] 
WALL_IMG=["wallH.gif","wallV.gif"] 
GOLD_IMG="gold.gif" 
MARK_IMG="mark.gif" 
newGame=False 
checks=list() </pre>
<ol start="2">
<li>Provide functions to handle the movements of the player:</li>
</ol>
<pre style="padding-left: 60px">def move_right(event): 
  movePlayer(RIGHT,STEP) 
def move_left(event): 
  movePlayer(LEFT,-STEP) 
def move_up(event): 
  movePlayer(UP,-STEP) 
def move_down(event): 
  movePlayer(DOWN,STEP) 
 
def foundWall(facing,move): 
  hitWall=False 
  olCoords=[canv.coords(player)[xVAL], 
            canv.coords(player)[yVAL], 
            canv.coords(player)[xVAL]+PLAYER_SIZE[xVAL], 
            canv.coords(player)[yVAL]+PLAYER_SIZE[yVAL]] 
  olCoords[facing]+=move 
  objects = canv.find_overlapping(olCoords[0],olCoords[1], 
                                  olCoords[2],olCoords[3]) 
  for obj in objects: 
    objTags = canv.gettags(obj) 
    for tag in objTags: 
      if tag == "wall": 
        hitWall=True 
  return hitWall 
 
def moveBackgnd(movement): 
  global bg_offset 
  bg_offset[xVAL]+=movement[xVAL] 
  bg_offset[yVAL]+=movement[yVAL] 
  for obj in canv.find_withtag("bg"): 
    canv.move(obj, -movement[xVAL], -movement[yVAL]) 
 
def makeMove(facing,move): 
  if facing == RIGHT or facing == LEFT: 
    movement=[move,0] #RIGHT/LEFT 
    bgOffset=bg_offset[xVAL] 
    playerPos=canv.coords(player)[xVAL] 
  else: 
    movement=[0,move] #UP/DOWN 
    bgOffset=bg_offset[yVAL] 
    playerPos=canv.coords(player)[yVAL] 
  #Check Bottom/Right Corner 
  if facing == RIGHT or facing == DOWN:  
    if (playerPos+PLAYER_SIZE[xVAL]) &lt; DIS_LIMITS[facing]: 
      canv.move(player, movement[xVAL], movement[yVAL]) 
    elif bgOffset &lt; SPACE_LIMITS[facing]: 
      moveBackgnd(movement) 
  else: 
    #Check Top/Left Corner 
    if (playerPos) &gt; DIS_LIMITS[facing]: 
      canv.move(player, movement[xVAL], movement[yVAL]) 
    elif bgOffset &gt; SPACE_LIMITS[facing]: 
      moveBackgnd(movement) 
 
def movePlayer(facing,move): 
  hitWall=foundWall(facing,move) 
  if hitWall==False: 
    makeMove(facing,move) 
  canv.itemconfig(player,image=playImg[facing])</pre>
<ol start="3">
<li>Add functions to check how far the player is from the hidden gold:</li>
</ol>
<pre style="padding-left: 60px">def check(event): 
  global checks,newGame,text 
  if newGame: 
    for chk in checks: 
      canv.delete(chk) 
    del checks[:] 
    canv.delete(gold,text) 
    newGame=False 
    hideGold() 
  else: 
    checks.append( 
                  canv.create_image(canv.coords(player)[xVAL], 
                  canv.coords(player)[yVAL], 
                  anchor=TK.NW, image=checkImg, 
                  tags=('check','bg'))) 
    distance=measureTo(checks[-1],gold) 
    if(distance&lt;=0): 
      canv.itemconfig(gold,state='normal') 
      canv.itemconfig(check,state='hidden') 
      text = canv.create_text(300,100,fill="white", 
                              text=("You have found the gold in"+  
                              " %d tries!"%len(checks))) 
      newGame=True 
    else: 
      text = canv.create_text(300,100,fill="white", 
                              text=("You are %d steps away!"%distance)) 
      canv.update() 
      time.sleep(1) 
      canv.delete(text) 
 
def measureTo(objectA,objectB): 
  deltaX=canv.coords(objectA)[xVAL]- 
                     canv.coords(objectB)[xVAL] 
  deltaY=canv.coords(objectA)[yVAL]- 
                     canv.coords(objectB)[yVAL] 
  w_sq=abs(deltaX)**2 
  h_sq=abs(deltaY)**2 
  hypot=math.sqrt(w_sq+h_sq) 
  return round((hypot/5)-20,-1)</pre>
<ol start="4">
<li>Add functions to help find a location to hide the gold in:</li>
</ol>
<pre style="padding-left: 60px">def hideGold(): 
  global gold 
  goldPos=findLocationForGold() 
  gold=canv.create_image(goldPos[xVAL], goldPos[yVAL], 
                         anchor=TK.NW, image=goldImg, 
                         tags=('gold','bg'), 
                         state='hidden') 
 
def findLocationForGold(): 
  placeGold=False 
  while(placeGold==False): 
    goldPos=[randint(0-bg_offset[xVAL], 
             SPACE_WIDTH-GOLD_SIZE[xVAL]-bg_offset[xVAL]), 
             randint(0-bg_offset[yVAL], 
             SPACE_HEIGHT-GOLD_SIZE[yVAL]-bg_offset[yVAL])] 
    objects = canv.find_overlapping(goldPos[xVAL], 
                                    goldPos[yVAL], 
                                    goldPos[xVAL]+GOLD_SIZE[xVAL], 
                                    goldPos[yVAL]+GOLD_SIZE[yVAL]) 
    findNewPlace=False 
    for obj in objects: 
      objTags = canv.gettags(obj) 
      for tag in objTags: 
        if (tag == "wall") or (tag == "player"): 
          findNewPlace=True 
    if findNewPlace == False: 
      placeGold=True 
  return goldPos </pre>
<ol start="5">
<li>Create the Tkinter application window and bind the keyboard events:</li>
</ol>
<pre style="padding-left: 60px">root = TK.Tk() 
root.title("Overhead Game") 
root.geometry('%sx%s+%s+%s' %(MAX_WIDTH,  
                              MAX_HEIGHT,  
                              100, 100)) 
root.resizable(width=TK.FALSE, height=TK.FALSE) 
root.bind('&lt;Right&gt;', move_right) 
root.bind('&lt;Left&gt;', move_left) 
root.bind('&lt;Up&gt;', move_up) 
root.bind('&lt;Down&gt;', move_down) 
root.bind('&lt;Return&gt;', check) 
 
canv = TK.Canvas(root, highlightthickness=0) 
canv.place(x=0,y=0,width=SPACE_WIDTH,height=SPACE_HEIGHT)</pre>
<ol start="6">
<li>Initialize all of the game objects (the background tiles, the player, the walls, and<br/>
the gold):</li>
</ol>
<pre style="padding-left: 60px">#Create background tiles 
bgnImg = TK.PhotoImage(file=BGN_IMG) 
BGN_SIZE = bgnImg.width(),bgnImg.height() 
background=list() 
COLS=int(SPACE_WIDTH/BGN_SIZE[xVAL])+1 
ROWS=int(SPACE_HEIGHT/BGN_SIZE[yVAL])+1 
for col in range(0,COLS): 
  for row in range(0,ROWS): 
    background.append(canv.create_image(col*BGN_SIZE[xVAL], 
                      row*BGN_SIZE[yVAL], anchor=TK.NW, 
                      image=bgnImg, 
                      tags=('background','bg'))) 
bg_offset=[0,0] 
 
#Create player 
playImg=list() 
for img in PLAYER_IMG: 
  playImg.append(TK.PhotoImage(file=img)) 
#Assume images are all same size/shape 
PLAYER_SIZE=playImg[RIGHT].width(),playImg[RIGHT].height() 
player = canv.create_image(100,100, anchor=TK.NW, 
                           image=playImg[RIGHT], 
                           tags=('player')) 
 
#Create walls 
wallImg=[TK.PhotoImage(file=WALL_IMG[0]), 
         TK.PhotoImage(file=WALL_IMG[1])] 
WALL_SIZE=[wallImg[0].width(),wallImg[0].height()] 
wallPosH=[(0,WALL_SIZE[xVAL]*1.5), 
          (WALL_SIZE[xVAL],WALL_SIZE[xVAL]*1.5), 
          (SPACE_WIDTH-WALL_SIZE[xVAL],WALL_SIZE[xVAL]*1.5), 
          (WALL_SIZE[xVAL],SPACE_HEIGHT-WALL_SIZE[yVAL])] 
wallPosV=[(WALL_SIZE[xVAL],0),(WALL_SIZE[xVAL]*3,0)] 
wallPos=[wallPosH,wallPosV] 
wall=list() 
for i,img in enumerate(WALL_IMG): 
  for item in wallPos[i]: 
    wall.append(canv.create_image(item[xVAL],item[yVAL], 
                anchor=TK.NW, image=wallImg[i], 
                tags=('wall','bg'))) 
 
#Place gold 
goldImg = TK.PhotoImage(file=GOLD_IMG) 
GOLD_SIZE=[goldImg.width(),goldImg.height()] 
hideGold() 
#Check mark 
checkImg = TK.PhotoImage(file=MARK_IMG) </pre>
<ol start="7">
<li>Finally, start the <kbd>mainloop()</kbd> command to allow Tkinter to monitor for events:</li>
</ol>
<pre style="padding-left: 60px">#Wait for actions from user 
root.mainloop() 
#End </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As before, we create a new Tkinter application that contains a <kbd>Canvas</kbd> widget, so that we can add all of the game objects. We ensure that we bind the right, left, up, down and <em>Enter</em> keys, which will be our controls in the game.</p>
<p>First, we place our background image (<kbd>bg.gif</kbd>) onto the <kbd>Canvas</kbd> widget. We calculate the number of images we can fit along the length and width to tile the whole canvas space, and locate them using suitable coordinates.</p>
<p>Next, we create the player image (by creating <kbd>playImg</kbd>, a list of Tkinter image objects for each direction the player can turn in) and place it on the canvas.</p>
<p>We now create the walls, the positions of which are defined by the <kbd>wallPosH</kbd> and <kbd>wallPosV</kbd> lists. These could be defined using the exact coordinates, and perhaps even read from a file to provide an easy method to load different layouts for levels, if required. By iterating through the lists, the horizontal and vertical wall images are put in position on the canvas.</p>
<p>To complete the layout, we just need to hide the gold somewhere. Using the <kbd>hideGold()</kbd> function, we can randomly determine a suitable place to locate the gold. Within <kbd>findLocationForGold()</kbd>, we use <kbd>randint(0,value)</kbd> to create a pseudo-random number (it is not totally random, but good enough for this use) between <kbd>0</kbd> and <kbd>value</kbd>. In our case, the value we want is between <kbd>0</kbd> and the edge of our canvas space, minus the size of the gold image and any <kbd>bg_offset</kbd> that has been applied to the canvas. This ensures that it is not beyond the edge of the screen. We then check the potential location, using the <kbd>find_overlapping()</kbd> function to see whether any objects with <kbd>wall</kbd> or <kbd>player</kbd> tags are in the way. If so, we pick a new location. Otherwise, we place the gold on the canvas, but with the <kbd>state="hidden"</kbd> value, which will hide it from view.</p>
<p>We then create <kbd>checkImg</kbd> (a Tkinter image), and use it while checking for gold to mark the area we have checked. Finally, we just wait for the user to press one of the keys.</p>
<p>The character will move around the screen whenever one of the cursor keys is pressed. The player's movement is determined by the <kbd>movePlayer()</kbd> function; it will first check whether the player is trying to move into a wall, then determine (within the <kbd>makeMove()</kbd> function) if the player is at the edge of the display or canvas space.</p>
<p>Every time a cursor key is pressed, we use the logic shown in the diagram to determine what to do:</p>
<div><img src="img/8fa4ac91-6983-4b12-8a55-922d6cad0783.png" style="width:40.33em;height:22.25em;" width="1180" height="650"/></div>
<p>Cursor key press action logic</p>
<p>The <kbd>foundWall()</kbd> function works out whether the player will hit a wall by checking for any objects with <kbd>wall</kbd> tags within the area being covered by the player image, plus a little extra for the area that the player will be moving to next. The following diagram shows how the <kbd>olCoords</kbd> coordinates are determined:</p>
<div><img src="img/0aebc920-9a89-468c-94f3-34590750a19b.png" style="width:43.42em;height:18.92em;" width="848" height="372"/></div>
<p>olCoords coordinate determination</p>
<p>The <kbd>makeMove()</kbd> function checks if the player will be moving to the edge of the display (as defined by <kbd>DIS_LIMITS</kbd>) and whether they are at the edge of the canvas space (as defined by <kbd>SPACE_LIMITS</kbd>). Within the display, the player can be moved in the direction of the cursor, or all of the objects tagged with <kbd>bg</kbd> within the canvas space are moved in the opposite direction, simulating scrolling behind the player. This is done with the <kbd>moveBackground()</kbd> function.</p>
<p>When the player presses <em>Enter</em>, we'll want to check for gold in the current location. Using the <kbd>measureTo()</kbd> function, the position of the player and the gold are compared (the distance between the <kbd>x</kbd> and <kbd>y</kbd> coordinates of each is calculated, as shown in the following figure):</p>
<div><img src="img/c36f28ad-060a-4445-ab10-aa38dbfbb51f.png" style="width:23.08em;height:12.50em;" width="697" height="375"/></div>
<p>Player and gold distance calculation</p>
<p>The result is scaled to provide a rough indication of how far away the player is from the gold. If the distance is greater than zero, we display how far away the player is from the gold and leave a cross to show where we have checked. If the player has found the gold, we display a message saying so and set <kbd>newGame</kbd> to <kbd>True</kbd>. The next time the player presses <em>Enter</em>, the places marked with a cross are removed, and the gold is relocated to somewhere new.</p>
<p>With the gold hidden again, the player is ready to start over!</p>


            

            
        
    </div>



  </body></html>