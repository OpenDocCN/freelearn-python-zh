<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;Summing Up &#x2013; A Complete Example"><div class="titlepage"><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Summing Up – A Complete Example</h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>"Do not dwell in the past, do not dream of the future, concentrate the mind on the present moment."</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>The Shakyamuni Buddha</em></span></span></td></tr></table></div><p>In this chapter, I will show you one last project. If you've worked well in the rest of the book, this example should be easy. I tried my best to craft it in a way that it will neither be too hard for those who have only read the book, nor too simple for those who also took the time to work on the examples, and maybe have read up on the links and topics I suggested.</p><div class="section" title="The challenge"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec85"/>The challenge</h1></div></div></div><p>One problem that we all have these days is remembering passwords. We have passwords for everything: websites, phones, cards, bank accounts, and so on. The amount of information we have to memorize is just too much, so many people end up using the same password over and over again. This is very bad, of course, so at some point, tools were invented<a id="id809" class="indexterm"/> to alleviate this problem. One of these tools is called <span class="strong"><strong>KeepassX</strong></span>, and basically it works like this: you start the software by setting up a special password<a id="id810" class="indexterm"/> called <span class="strong"><strong>master password</strong></span>. Once inside, you store a record for each password you need to memorize, for example, your e-mail account, the bank website, credit card information, and so on. When you close the software, it encrypts the database used to store all that information, so that the data can only be accessed by the owner of the master password. Therefore, kind of in a <span class="emphasis"><em>Lord of The Rings</em></span> fashion, by just owning one password, you rule them all.</p></div></div>
<div class="section" title="Our implementation"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec86"/>Our implementation</h1></div></div></div><p>Our goal in this chapter is to create something similar but web-based, and the way I want to implement it is by writing two applications.</p><p>One will be an API written in Falcon. Its purpose will be twofold, it will be able to both generate and validate passwords. It will provide the caller with information about the validity and a score which should indicate how strong the password is.</p><p>The second <a id="id811" class="indexterm"/>application is a Django website, which will provide the interface to handle records. Each record will retain information such as the username, e-mail, password, URL, and so on. It will show a list of all the records, and it will allow the user to create, update and delete them. Passwords will be encrypted before being stored in the database.</p><p>The purpose of the whole project is, therefore, to mimic the way KeepassX works, even though it is in a much simpler fashion. It will be up to you, if you like this idea, to develop it further in order to add other features and make it more secure. I will make sure to give you some suggestions on how to extend it, towards the end.</p><p>This chapter will therefore be quite dense, code-wise. It's the price I have to pay for giving you an interesting example in a restricted amount of space.</p><p>Before we start, please make sure you are comfortable with the projects presented in <a class="link" href="ch10.html" title="Chapter 10. Web Development Done Right">Chapter 10</a>, <span class="emphasis"><em>Web Development Done Right</em></span> so that you're familiar with the basics of web development. Make sure also that you have installed all the <code class="literal">pip</code> packages needed for this project: <code class="literal">django</code>, <code class="literal">falcon</code>, <code class="literal">cryptography</code>, and <code class="literal">nose-parameterized</code>. If you download the source code for the book, you'll find everything you need to install in the <code class="literal">requirements</code> folder, while the code for this chapter will be in <code class="literal">ch12</code>.</p></div>
<div class="section" title="Implementing the Django interface"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec87"/>Implementing the Django interface</h1></div></div></div><p>I hope<a id="id812" class="indexterm"/> you're comfortable with the concepts presented in <a class="link" href="ch10.html" title="Chapter 10. Web Development Done Right">Chapter 10</a>, <span class="emphasis"><em>Web Development Done Right</em></span> which was mostly about Django. If you haven't read it, this is probably a good time, before reading on here.</p><div class="section" title="The setup"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec137"/>The setup</h2></div></div></div><p>In your <a id="id813" class="indexterm"/>root folder (<code class="literal">ch12</code>, for me), which will contain the root for the interface and the root for the API, start by running this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ django-admin startproject pwdweb</strong></span>
</pre></div><p>This will create the structure for a Django project, which we know well by now. I'll show you the final structure of the interface project here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ tree -A pwdweb</strong></span>
<span class="strong"><strong>pwdweb</strong></span>
<span class="strong"><strong>├── db.sqlite3</strong></span>
<span class="strong"><strong>├── manage.py</strong></span>
<span class="strong"><strong>├── pwdweb</strong></span>
<span class="strong"><strong>│   ├── __init__.py</strong></span>
<span class="strong"><strong>│   ├── settings.py</strong></span>
<span class="strong"><strong>│   ├── urls.py</strong></span>
<span class="strong"><strong>│   └── wsgi.py</strong></span>
<span class="strong"><strong>└── records</strong></span>
<span class="strong"><strong>    ├── admin.py</strong></span>
<span class="strong"><strong>    ├── forms.py</strong></span>
<span class="strong"><strong>    ├── __init__.py</strong></span>
<span class="strong"><strong>    ├── migrations</strong></span>
<span class="strong"><strong>    │   ├── 0001_initial.py</strong></span>
<span class="strong"><strong>    │   └── __init__.py</strong></span>
<span class="strong"><strong>    ├── models.py</strong></span>
<span class="strong"><strong>    ├── static</strong></span>
<span class="strong"><strong>    │   └── records</strong></span>
<span class="strong"><strong>    │       ├── css</strong></span>
<span class="strong"><strong>    │       │   └── main.css</strong></span>
<span class="strong"><strong>    │       └── js</strong></span>
<span class="strong"><strong>    │           ├── api.js</strong></span>
<span class="strong"><strong>    │           └── jquery-2.1.4.min.js</strong></span>
<span class="strong"><strong>    ├── templates</strong></span>
<span class="strong"><strong>    │   └── records</strong></span>
<span class="strong"><strong>    │       ├── base.html</strong></span>
<span class="strong"><strong>    │       ├── footer.html</strong></span>
<span class="strong"><strong>    │       ├── home.html</strong></span>
<span class="strong"><strong>    │       ├── list.html</strong></span>
<span class="strong"><strong>    │       ├── messages.html</strong></span>
<span class="strong"><strong>    │       ├── record_add_edit.html</strong></span>
<span class="strong"><strong>    │       └── record_confirm_delete.html</strong></span>
<span class="strong"><strong>    ├── templatetags</strong></span>
<span class="strong"><strong>    │   └── record_extras.py</strong></span>
<span class="strong"><strong>    ├── urls.py</strong></span>
<span class="strong"><strong>    └── views.py</strong></span>
</pre></div><p>As usual, don't <a id="id814" class="indexterm"/>worry if you don't have all the files, we'll add them gradually. Change to the <code class="literal">pwdweb</code> folder, and make sure Django is correctly set up: <code class="literal">$ python manage.py runserver</code> (ignore the warning about unapplied migrations).</p><p>Shut down the server and create an app: <code class="literal">$ python manage.py startapp records</code>. That is excellent, now we can start coding. First things first, let's open <code class="literal">pwdweb/settings.py</code> and start by adding <code class="literal">'records'</code>, at the end of the <code class="literal">INSTALLED_APP</code> tuple (note that the comma is included in the code). Then, go ahead and fix the <code class="literal">LANGUAGE_CODE</code> and <code class="literal">TIME_ZONE</code> settings according to your preference and finally, add the following line at the bottom:</p><div class="informalexample"><pre class="programlisting">ENCRYPTION_KEY = b'qMhPGx-ROWUDr4veh0ybPRL6viIUNe0vcPDmy67x6CQ='</pre></div><p>This is<a id="id815" class="indexterm"/> a custom encryption key that has nothing to do with Django settings, but we will need it later on, and this is the best place for it to be. Don't worry for now, we'll get back to it.</p></div><div class="section" title="The model layer"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec138"/>The model layer</h2></div></div></div><p>We need <a id="id816" class="indexterm"/>to add just one model for the records application: <code class="literal">Record</code>. This model will represent each record we want to store in the database:</p><p>
<code class="literal">records/models.py</code>
</p><div class="informalexample"><pre class="programlisting">from cryptography.fernet import Fernet
from django.conf import settings
from django.db import models

class Record(models.Model):
    DEFAULT_ENCODING = 'utf-8'

    title = models.CharField(max_length=64, unique=True)
    username = models.CharField(max_length=64)
    email = models.EmailField(null=True, blank=True)
    url = models.URLField(max_length=255, null=True, blank=True)
    password = models.CharField(max_length=2048)
    notes = models.TextField(null=True, blank=True)
    created = models.DateTimeField(auto_now_add=True)
    last_modified = models.DateTimeField(auto_now=True)

    def <span class="strong"><strong>encrypt_password</strong></span>(self):
        self.password = self.encrypt(self.password)

    def <span class="strong"><strong>decrypt_password</strong></span>(self):
        self.password = self.decrypt(self.password)

    def <span class="strong"><strong>encrypt</strong></span>(self, plaintext):
        return self.cypher('encrypt', plaintext)

    def <span class="strong"><strong>decrypt</strong></span>(self, cyphertext):
        return self.cypher('decrypt', cyphertext)

    def <span class="strong"><strong>cypher</strong></span>(self, cypher_func, text):
        fernet = Fernet(settings.ENCRYPTION_KEY)
        result = getattr(fernet, cypher_func)(
            self._to_bytes(text))
        return self._to_str(result)

    def _to_str(self, bytes_str):
        return bytes_str.decode(self.DEFAULT_ENCODING)

    def _to_bytes(self, s):
        return s.encode(self.DEFAULT_ENCODING)</pre></div><p>Firstly, we set the <code class="literal">DEFAULT_ENCODING</code> class attribute to <code class="literal">'utf-8'</code>, which is the most popular type of encoding for the web (and not only the web). We set this attribute on the class to avoid hardcoding a string in more than one place.</p><p>Then, we<a id="id817" class="indexterm"/> proceed to set up all the model's fields. As you can see, Django allows you to specify very specific fields, such as <code class="literal">EmailField</code> and <code class="literal">URLField</code>. The reason why it's better to use these specific fields instead of a plain and simple <code class="literal">CharField</code> is we'll get e-mail and URL validation for free when we create a form for this model, which is brilliant.</p><p>All the options are quite standard, and we saw them in <a class="link" href="ch10.html" title="Chapter 10. Web Development Done Right">Chapter 10</a>, <span class="emphasis"><em>Web Development Done Right</em></span> but I want to point out a few things anyway. Firstly, <code class="literal">title</code> needs to be unique so that each <code class="literal">Record</code> object has a unique title and we don't want to risk having doubles. Each database treats strings a little bit differently, according to how it is set up, which engine it runs, and so on, so I haven't made the <code class="literal">title</code> field the primary key for this model, which would have been the natural thing to do. I prefer to avoid the pain of having to deal with weird string errors and I am happy with letting Django add a primary key to the model automatically.</p><p>Another option you should understand is the <code class="literal">null=True, blank=True</code> couple. The former allows the field to be <code class="literal">NULL</code>, which makes it non-mandatory, while the second allows it to be <span class="emphasis"><em>blank</em></span> (that is to say, an empty string). Their use is quite peculiar in Django, so I suggest you to take a look at the official documentation to understand exactly how to use them.</p><p>Finally, the dates: <code class="literal">created</code> needs to have <code class="literal">auto_add_now=True</code>, which will set the current moment in time on the object when it's created. On the other hand, <code class="literal">last_modified</code> needs to be updated every time we save the model, hence we set <code class="literal">auto_now=True</code>.</p><p>After the field definitions, there are a few methods for encrypting and decrypting the password. It is always a very bad idea to save passwords as they are in a database, therefore you should always encrypt them before saving them.</p><p>Normally, when<a id="id818" class="indexterm"/> saving a password, you encrypt it using a <span class="strong"><strong>one way encryption</strong></span> algorithm (also known as a <span class="strong"><strong>one way hash function</strong></span>). This <a id="id819" class="indexterm"/>means that, once you have created the hash, there is no way for you to revert it back to the original password.</p><p>This kind of <a id="id820" class="indexterm"/>encryption is normally used for authentication: the user puts their username and password in a form and, on submission, the code fetches the hash from the user record in the database and compares it with the hash of the password the user has just put in the form. If the two hashes match, it means that they were produced by the same password, therefore authentication is granted.</p><p>In this case though, we need to be able to recover the passwords, otherwise this whole application<a id="id821" class="indexterm"/> wouldn't be very useful. Therefore, we will use a so-called <span class="strong"><strong>symmetric encryption </strong></span>algorithm to encrypt them. The way this <a id="id822" class="indexterm"/>works is very simple: the password (called <span class="strong"><strong>plaintext</strong></span>) is passed to an <span class="emphasis"><em>encrypt</em></span> function, along with a <span class="emphasis"><em>secret key</em></span>. The algorithm produces an encrypted <a id="id823" class="indexterm"/>string (called <span class="strong"><strong>cyphertext</strong></span>) out of them, which is what you store in the database. When you want to recover the password, you will need the cyphertext and the secret key. You feed them to a <span class="emphasis"><em>decrypt</em></span> function, and you get back your original password. This is exactly what we need.</p><p>In order to perform symmetric encryption, we need the <code class="literal">cryptography</code> package, which is why I instructed you to install it.</p><p>All the methods in the <code class="literal">Record</code> class are very simple. <code class="literal">encrypt_password</code> and <code class="literal">decrypt_password</code> are shortcuts to <code class="literal">encrypt</code> and <code class="literal">decrypt</code> the <code class="literal">password</code> field and reassign the result to itself.</p><p>The <code class="literal">encrypt</code> and <code class="literal">decrypt</code> methods are dispatchers for the <code class="literal">cypher</code> method, and <code class="literal">_to_str</code> and <code class="literal">_to_bytes</code> are just a couple of helpers. The <code class="literal">cryptography</code> library works with <span class="emphasis"><em>bytes</em></span> objects, so we need those helpers to go back and forth between bytes and strings, using a common encoding.</p><p>The only interesting logic is in the <code class="literal">cypher</code> method. I could have coded it directly in the <code class="literal">encrypt</code> and <code class="literal">decrypt</code> ones, but that would have resulted in a bit of redundancy, and I wouldn't have had the chance to show you a different way of accessing an object's attribute, so let's analyze the body of <code class="literal">cypher</code>.</p><p>We start by creating an instance of the <code class="literal">Fernet</code> class, which provides us with the symmetric encryption functionality we need. We set the instance up by passing the secret key in the settings (<code class="literal">ENCRYPTION_KEY</code>). After creating <code class="literal">fernet</code>, we need to use it. We can use it to either encrypt or decrypt, according to what value is given to the <code class="literal">cypher_func</code> parameter. We use <code class="literal">getattr</code> to get an attribute from an object given the object itself and the name of the attribute. This technique allows us to fetch any attribute from an object dynamically.</p><p>The result of <code class="literal">getattr(fernet, cypher_func)</code>, with <code class="literal">cyper_func</code> being <code class="literal">'encrypt'</code>, for example, is<a id="id824" class="indexterm"/> the same as <code class="literal">fernet.encrypt</code>. The <code class="literal">getattr</code> function returns a method, which we then call with the bytes representation of the text argument. We then return the result, in string format.</p><p>Here's what this function is equivalent to when it's called by the encrypt dispatcher:</p><div class="informalexample"><pre class="programlisting">def cypher_encrypt(self, text):
        fernet = Fernet(settings.ENCRYPTION_KEY)
        result = fernet.encrypt(
            self._to_bytes(text))
        return self._to_str(result)</pre></div><p>When you take the time to understand it properly, you'll see it's not as difficult as it sounds.</p><p>So, we have our model, hence it's time to migrate (I hope you remember that this will create the tables in the database for your application):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python manage.py makemigrations</strong></span>
<span class="strong"><strong>$ python manage.py migrate</strong></span>
</pre></div><p>Now you should have a nice database with all the tables you need to run the interface application. Go ahead and create a superuser (<code class="literal">$ python manage.py createsuperuser</code>).</p><p>By the way, if you want to generate your own encryption key, it is as easy as this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; from cryptography.fernet import Fernet</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Fernet.generate_key()</strong></span>
</pre></div></div><div class="section" title="A simple form"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec139"/>A simple form</h2></div></div></div><p>We need a <a id="id825" class="indexterm"/>form for the <code class="literal">Record</code> model, so we'll use the <code class="literal">ModelForm</code> technique we saw in <a class="link" href="ch10.html" title="Chapter 10. Web Development Done Right">Chapter 10</a>, <span class="emphasis"><em>Web Development Done Right</em></span>.</p><p>
<code class="literal">records/forms.py</code>
</p><div class="informalexample"><pre class="programlisting">from django.forms import ModelForm, Textarea
from .models import Record

class RecordForm(ModelForm):
    class Meta:
        model = Record
        fields = ['title', 'username', 'email', 'url',
                  'password', 'notes']
        widgets = {'notes': Textarea(
            attrs={'cols': 40, 'rows': 4})}</pre></div><p>We create a <code class="literal">RecordForm</code> class that inherits from <code class="literal">ModelForm</code>, so that the form is created automatically thanks to the introspection capabilities of Django. We only specify which model to<a id="id826" class="indexterm"/> use, which fields to display (we exclude the dates, which are handled automatically) and we provide minimal styling for the dimensions of the notes field, which will be displayed using a <code class="literal">Textarea</code> (which is a multiline text field in HTML).</p></div><div class="section" title="The view layer"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec140"/>The view layer</h2></div></div></div><p>There are <a id="id827" class="indexterm"/>a total of five pages in the interface application: home, record list, record creation, record update, and record delete confirmation. Hence, there <a id="id828" class="indexterm"/>are five views that we have to write. As you'll see in a moment, Django helps us a lot by giving us views we can reuse with minimum customization. All the code that follows belongs to the <code class="literal">records/views.py</code> file.</p><div class="section" title="Imports and home view"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec42"/>Imports and home view</h3></div></div></div><p>Just to <a id="id829" class="indexterm"/>break the ice, here are the imports and the view for the home page:</p><div class="informalexample"><pre class="programlisting">from django.contrib import messages
from django.contrib.messages.views import SuccessMessageMixin
from django.core.urlresolvers import reverse_lazy
from django.views.generic import TemplateView
from django.views.generic.edit import (
    CreateView, UpdateView, DeleteView)
from .forms import RecordForm
from .models import Record

class HomeView(TemplateView):
    template_name = 'records/home.html'</pre></div><p>We import a few tools from Django. There are a couple of messaging-related objects, a URL lazy reverser, and four different types of view. We also import our <code class="literal">Record</code> model and <code class="literal">RecordForm</code>. As you can see, the <code class="literal">HomeView</code> class consists of only two lines since we only need to specify which template we want to use, the rest just reuses the code from <code class="literal">TemplateView</code>, as it is. It's so easy, it almost feels like cheating.</p></div><div class="section" title="Listing all records"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec43"/>Listing all records</h3></div></div></div><p>After the <a id="id830" class="indexterm"/>home view, we can write a view to list all the <code class="literal">Record</code> instances that we have in the database.</p><div class="informalexample"><pre class="programlisting">class RecordListView(TemplateView):
    template_name = 'records/list.html'

    def get(self, request, *args, **kwargs):
        context = self.get_context_data(**kwargs)
        records = Record.objects.all().order_by('title')  #1
        for record in records:
            record.plaintext = record.decrypt(record.password) #2
        context['records'] = records
        return self.render_to_response(context)</pre></div><p>All we need to do is sub-class <code class="literal">TemplateView</code> again, and override the <code class="literal">get</code> method. We need to do a couple of things: we fetch all the records from the database and sort them by <code class="literal">title</code> (<code class="literal">#1</code>) and then parse all the records in order to add the attribute <code class="literal">plaintext</code> (<code class="literal">#2</code>) onto each of them, to show the original password on the page. Another way of doing this would be to add a read-only property to the <code class="literal">Record</code> model, to do the decryption on the fly. I'll leave it to you, as a fun exercise, to amend the code to do it.</p><p>After recovering and augmenting the records, we put them in the <code class="literal">context</code> dict and finish as usual by invoking <code class="literal">render_to_response</code>.</p></div><div class="section" title="Creating records"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec44"/>Creating records</h3></div></div></div><p>Here's the <a id="id831" class="indexterm"/>code for the creation view:</p><div class="informalexample"><pre class="programlisting">class EncryptionMixin:
    def form_valid(self, form):
        self.encrypt_password(form)
        return super(EncryptionMixin, self).form_valid(form)

    def encrypt_password(self, form):
        self.object = form.save(commit=False)
        self.object.encrypt_password()
        self.object.save()

class RecordCreateView(
        EncryptionMixin, SuccessMessageMixin, CreateView):
    template_name = 'records/record_add_edit.html'
    form_class = RecordForm
    success_url = reverse_lazy('records:add')
    success_message = 'Record was created successfully'</pre></div><p>A part of its logic has been factored out in order to be reused later on in the update view. Let's start with <code class="literal">EncryptionMixin</code>. All it does is override the <code class="literal">form_valid</code> method so that, prior to saving a new <code class="literal">Record</code> instance to the database, we make sure we call <code class="literal">encrypt_password</code> on the object that results from saving the form. In other words, when the user submits the form to create a new <code class="literal">Record</code>, if the form validates successfully, then the <code class="literal">form_valid</code> method is invoked. Within this method what usually happens is that an object is created out of the <code class="literal">ModelForm</code> instance, like this:</p><div class="informalexample"><pre class="programlisting">self.object = form.save()</pre></div><p>We <a id="id832" class="indexterm"/>need to interfere with this behavior because running this code as it is would save the record with the original password, which isn't encrypted. So we change this to call <code class="literal">save</code> on the <code class="literal">form</code> passing <code class="literal">commit=False</code>, which creates the <code class="literal">Record</code> instance out of the <code class="literal">form</code>, but doesn't attempt to save it in the database. Immediately afterwards, we encrypt the password on that instance and then we can finally call save on it, actually committing it to the database.</p><p>Since we need this behavior both for creating and updating records, I have factored it out in a mixin.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note210"/>Note</h3><p>Perhaps, a better solution for this password encryption logic is to create a custom <code class="literal">Field</code> (inheriting from <code class="literal">CharField</code> is the easiest way to do it) and add the necessary logic to it, so that when we handle <code class="literal">Record</code> instances from and to the database, the encryption and decryption logic is performed automatically for us. Though more elegant, this solution needs me to digress and explain a lot more about Django internals, which is too much for the extent of this example. As usual, you can try to do it yourself, if you feel like a challenge.</p></div></div><p>After creating the <code class="literal">EncryptionMixin</code> class, we can use it in the <code class="literal">RecordCreateView</code> class. We also inherit from two other classes: <code class="literal">SuccessMessageMixin</code> and <code class="literal">CreateView</code>. The message mixin provides us with the logic to quickly set up a message when creation is successful, and the <code class="literal">CreateView</code> gives us the necessary logic to create an object from a form.</p><p>You can see that all we have to code is some customization: the template name, the form class, and the success message and URL. Everything else is gracefully handled for us by Django.</p></div><div class="section" title="Updating records"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec45"/>Updating records</h3></div></div></div><p>The code<a id="id833" class="indexterm"/> to update a <code class="literal">Record</code> instance is only a tiny bit more complicated. We just need to add some logic to decrypt the password before we populate the form with the record data.</p><div class="informalexample"><pre class="programlisting">class RecordUpdateView(
        EncryptionMixin, SuccessMessageMixin, UpdateView):
    template_name = 'records/record_add_edit.html'
    form_class = RecordForm
    model = Record
    success_message = 'Record was updated successfully'

    def get_context_data(self, **kwargs):
        kwargs['update'] = True
        return super(
            RecordUpdateView, self).get_context_data(**kwargs)

    def form_valid(self, form):
        self.success_url = reverse_lazy(
            'records:edit',
            kwargs={'pk': self.object.pk}
        )
        return super(RecordUpdateView, self).form_valid(form)

    def get_form_kwargs(self):
        kwargs = super(RecordUpdateView, self).get_form_kwargs()
        kwargs['instance'].decrypt_password()
        return kwargs</pre></div><p>In this view, we still inherit from both <code class="literal">EncryptionMixin</code> and <code class="literal">SuccessMessageMixin</code>, but the view class we use is <code class="literal">UpdateView</code>.</p><p>The first<a id="id834" class="indexterm"/> four lines are customization as before, we set the template name, the form class, the <code class="literal">Record</code> model, and the success message. We cannot set the <code class="literal">success_url</code> as a class attribute because we want to redirect a successful edit to the same edit page for that record and, in order to do this, we need the ID of the instance we're editing. No worries, we'll do it another way.</p><p>First, we override <code class="literal">get_context_data</code> in order to set <code class="literal">'update'</code> to <code class="literal">True</code> in the <code class="literal">kwargs</code> argument, which means that a key <code class="literal">'update'</code> will end up in the <code class="literal">context</code> dict that is passed to the template for rendering the page. We do this because we want to use the same template for creating and updating a record, therefore we will use this variable in the context to be able to understand in which situation we are. There are other ways to do this but this one is quick and easy and I like it because it's explicit.</p><p>After overriding <code class="literal">get_context_data,</code> we need to take care of the URL redirection. We do this in the <code class="literal">form_valid</code> method since we know that, if we get there, it means the <code class="literal">Record</code> instance has been successfully updated. We reverse the <code class="literal">'records:edit'</code> view, which is exactly the view we're working on, passing the primary key of the object in question. We take that information from <code class="literal">self.object.pk</code>.</p><p>One of the reasons it's helpful to have the object saved on the view instance is that we can use it when needed without having to alter the signature of the many methods in the view in order to pass the object around. This design is very helpful and allows us to achieve a lot with very few lines of code.</p><p>The last thing we need to do is to decrypt the password on the instance before populating the form for the user. It's simple enough to do it in the <code class="literal">get_form_kwargs</code> method, where you can access the <code class="literal">Record</code> instance in the <code class="literal">kwargs</code> dict, and call <code class="literal">decrypt_password</code> on it.</p><p>This is all<a id="id835" class="indexterm"/> we need to do to update a record. If you think about it, the amount of code we had to write is really very little, thanks to Django class-based views.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip22"/>Tip</h3><p>A good way of understanding which is the best method to override, is to take a look at the Django official documentation or, even better in this case, check out the source code and look at the class-based views section. You'll be able to appreciate how much work has been done there by Django developers so that you only have to touch the smallest amounts of code to customize your views.</p></div></div></div><div class="section" title="Deleting records"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec46"/>Deleting records</h3></div></div></div><p>Of the<a id="id836" class="indexterm"/> three actions, deleting a record is definitely the easiest one. All we need is the following code:</p><div class="informalexample"><pre class="programlisting">class RecordDeleteView(SuccessMessageMixin, DeleteView):
    model = Record
    success_url = reverse_lazy('records:list')

    def delete(self, request, *args, **kwargs):
        messages.success(
            request, 'Record was deleted successfully')
        return super(RecordDeleteView, self).delete(
            request, *args, **kwargs)</pre></div><p>We only need to inherit from <code class="literal">SuccessMessageMixin</code> and <code class="literal">DeleteView</code>, which gives us all we need. We set up the model and the success URL as class attributes, and then we override the <code class="literal">delete</code> method only to add a nice message that will be displayed in the list view (which is where we redirect to after deletion).</p><p>We don't need to specify the template name, since we'll use a name that Django infers by default: <code class="literal">record_confirm_delete.html</code>.</p><p>With this final view, we're all set to have a nice interface that we can use to handle <code class="literal">Record</code> instances.</p></div></div><div class="section" title="Setting up the URLs"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec141"/>Setting up the URLs</h2></div></div></div><p>Before<a id="id837" class="indexterm"/> we move on to the template layer, let's set up the URLs. This time, I want to show you the inclusion technique I talked about in <a class="link" href="ch10.html" title="Chapter 10. Web Development Done Right">Chapter 10</a>, <span class="emphasis"><em>Web Development Done Right</em></span>.</p><p>
<code class="literal">pwdweb/urls.py</code>
</p><div class="informalexample"><pre class="programlisting">from django.conf.urls import include, url
from django.contrib import admin
from records import urls as records_url
from records.views import HomeView

urlpatterns = [
    url(r'^admin/', include(admin.site.urls)),
    url(r'^records/', include(records_url, namespace='records')),
    url(r'^$', HomeView.as_view(), name='home'),
]</pre></div><p>These are the URLs for the main project. We have the usual admin, a home page, and then for the records section, we include another <code class="literal">urls.py</code> file, which we define in the <code class="literal">records</code> application. This technique allows for apps to be reusable and self-contained. Note that, when including another <code class="literal">urls.py</code> file, you can pass namespace information, which you can then use in functions such as <code class="literal">reverse</code>, or the <code class="literal">url</code> template tag. For example, we've seen that the path to the <code class="literal">RecordUpdateView</code> was <code class="literal">'records:edit'</code>. The first part of that string is the namespace, and the second is the name that we have given to the view, as you can see in the following code:</p><p>
<code class="literal">records/urls.py</code>
</p><div class="informalexample"><pre class="programlisting">from django.conf.urls import include, url
from django.contrib import admin
from .views import (RecordCreateView, RecordUpdateView,
                    RecordDeleteView, RecordListView)

urlpatterns = [
    url(r'^add/$', RecordCreateView.as_view(), <span class="strong"><strong>name</strong></span>='add'),
    url(r'^edit/(?P&lt;pk&gt;[0-9]+)/$', RecordUpdateView.as_view(),
        <span class="strong"><strong>name</strong></span>='edit'),
    url(r'^delete/(?P&lt;pk&gt;[0-9]+)/$', RecordDeleteView.as_view(),
        <span class="strong"><strong>name</strong></span>='delete'),
    url(r'^$', RecordListView.as_view(), <span class="strong"><strong>name</strong></span>='list'),
]</pre></div><p>We define four different <code class="literal">url</code> instances. There is one for adding a record, which doesn't need primary key information since the object doesn't exist yet. Then we have two <code class="literal">url</code> instances for updating and deleting a record, and for those we need to also specify primary key information to be passed to the view. Since <code class="literal">Record</code> instances have integer IDs, we can safely pass them on the URL, following good URL design practice. Finally, we define one <code class="literal">url</code> instance for the list of records.</p><p>All <code class="literal">url</code> instances<a id="id838" class="indexterm"/> have <code class="literal">name</code> information which is used in views and templates.</p></div><div class="section" title="The template layer"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec142"/>The template layer</h2></div></div></div><p>Let's<a id="id839" class="indexterm"/> start <a id="id840" class="indexterm"/>with the template we'll use as the basis for the rest:</p><p>
<code class="literal">records/templates/records/base.html</code>
</p><div class="informalexample"><pre class="programlisting">{% load static from staticfiles %}
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta name="viewport"
          content="width=device-width, initial-scale=1.0"&gt;
    &lt;link href="{% static "records/css/main.css" %}"
          rel="stylesheet"&gt;
    &lt;title&gt;{% block title %}Title{% endblock title %}&lt;/title&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;div id="page-content"&gt;
      {% block page-content %}{% endblock page-content %}
    &lt;/div&gt;
    &lt;div id="footer"&gt;{% block footer %}{% endblock footer %}&lt;/div&gt;
    <span class="strong"><strong>{% block scripts %}</strong></span>
<span class="strong"><strong>      &lt;script</strong></span>
<span class="strong"><strong>        src="{% static "records/js/jquery-2.1.4.min.js" %}"&gt;</strong></span>
<span class="strong"><strong>      &lt;/script&gt;</strong></span>
<span class="strong"><strong>    {% endblock scripts %}</strong></span>
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>It's very similar to the one I used in <a class="link" href="ch10.html" title="Chapter 10. Web Development Done Right">Chapter 10</a>, <span class="emphasis"><em>Web Development Done Right</em></span> although it is a bit more compressed and with one major difference. We will import jQuery in every page.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note68"/>Note</h3><p>jQuery is <a id="id841" class="indexterm"/>the most popular JavaScript library out there. It allows you to write code that works on all the main browsers and it gives you many extra tools such as the<a id="id842" class="indexterm"/> ability to perform asynchronous calls (<span class="strong"><strong>AJAX</strong></span>) from the browser itself. We'll use this library to perform the calls to the API, both to generate and validate our passwords. You can <a id="id843" class="indexterm"/>download it at <a class="ulink" href="https://jquery.com/">https://jquery.com/</a>, and put it in the <code class="literal">pwdweb/records/static/records/js/</code> folder (you may have to amend the import in the template).</p></div></div><p>I highlighted <a id="id844" class="indexterm"/>the only interesting part of this template<a id="id845" class="indexterm"/> for you. Note that we load the JavaScript library at the end. This is common practice, as JavaScript is used to manipulate the page, so loading libraries at the end helps in avoiding situations such as JavaScript code failing because the element needed hadn't been rendered on the page yet.</p><div class="section" title="Home and footer templates"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec47"/>Home and footer templates</h3></div></div></div><p>The <a id="id846" class="indexterm"/>home template is very simple:</p><p>
<code class="literal">records/templates/records/home.html</code>
</p><div class="informalexample"><pre class="programlisting">{% extends "records/base.html" %}
{% block title %}Welcome to the Records website.{% endblock %}

{% block page-content %}
  &lt;h1&gt;Welcome {{ user.first_name }}!&lt;/h1&gt;
  &lt;div class="home-option"&gt;To create a record click
    &lt;a href="{% url "records:add" %}"&gt;here.&lt;/a&gt;
  &lt;/div&gt;
  &lt;div class="home-option"&gt;To see all records click
    &lt;a href="{% url "records:list" %}"&gt;here.&lt;/a&gt;
  &lt;/div&gt;
{% endblock page-content %}</pre></div><p>There is nothing new here when compared to the <code class="literal">home.html</code> template we saw in <a class="link" href="ch10.html" title="Chapter 10. Web Development Done Right">Chapter 10</a>, <span class="emphasis"><em>Web Development Done Right</em></span>. The footer template is actually exactly the same:</p><p>
<code class="literal">records/templates/records/footer.html</code>
</p><div class="informalexample"><pre class="programlisting">&lt;div class="footer"&gt;
  Go back &lt;a href="{% url "home" %}"&gt;home&lt;/a&gt;.
&lt;/div&gt;</pre></div></div><div class="section" title="Listing all records"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec48"/>Listing all records</h3></div></div></div><p>This <a id="id847" class="indexterm"/>template to list all records is fairly simple:</p><p>
<code class="literal">records/templates/records/list.html</code>
</p><div class="informalexample"><pre class="programlisting">{% extends "records/base.html" %}
<span class="strong"><strong>{% load record_extras %}</strong></span>
{% block title %}Records{% endblock title %}

{% block page-content %}
  &lt;h1&gt;Records&lt;/h1&gt;<span class="strong"><strong>&lt;span name="top"&gt;&lt;/span&gt;</strong></span>
  <span class="strong"><strong>{% include "records/messages.html" %}</strong></span>

  {% for record in records %}
  &lt;div class="record {% cycle 'row-light-blue' 'row-white' %}"
       <span class="strong"><strong>id="record-{{ record.pk }}"</strong></span>&gt;
    &lt;div class="record-left"&gt;
      &lt;div class="record-list"&gt;
        &lt;span class="record-span"&gt;Title&lt;/span&gt;{{ record.title }}
      &lt;/div&gt;
      &lt;div class="record-list"&gt;
        &lt;span class="record-span"&gt;Username&lt;/span&gt;
        {{ record.username }}
      &lt;/div&gt;
      &lt;div class="record-list"&gt;
        &lt;span class="record-span"&gt;Email&lt;/span&gt;{{ record.email }}
      &lt;/div&gt;
      &lt;div class="record-list"&gt;
        &lt;span class="record-span"&gt;URL&lt;/span&gt;
          &lt;a href="{{ record.url }}" target="_blank"&gt;
            {{ record.url }}&lt;/a&gt;
      &lt;/div&gt;
      &lt;div class="record-list"&gt;
        &lt;span class="record-span"&gt;Password&lt;/span&gt;
        <span class="strong"><strong>{% hide_password record.plaintext %}</strong></span>
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="record-right"&gt;
      &lt;div class="record-list"&gt;
        &lt;span class="record-span"&gt;Notes&lt;/span&gt;
        &lt;textarea rows="3" cols="40" class="record-notes"
                  <span class="strong"><strong>readonly</strong></span>&gt;{{ record.notes }}&lt;/textarea&gt;
      &lt;/div&gt;
      &lt;div class="record-list"&gt;
        &lt;span class="record-span"&gt;Last modified&lt;/span&gt;
        {{ record.last_modified }}
      &lt;/div&gt;
      &lt;div class="record-list"&gt;
        &lt;span class="record-span"&gt;Created&lt;/span&gt;
        {{ record.created }}
      &lt;/div&gt;

    &lt;/div&gt;
    &lt;div class="record-list-actions"&gt;
      &lt;a href="<span class="strong"><strong>{% url "records:edit" pk=record.pk %}</strong></span>"&gt;» edit&lt;/a&gt;
      &lt;a href="<span class="strong"><strong>{% url "records:delete" pk=record.pk %}</strong></span>"&gt;» delete
      &lt;/a&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  {% endfor %}
{% endblock page-content %}

{% block footer %}
  &lt;p&gt;<span class="strong"><strong>&lt;a href="#top"&gt;Go back to top&lt;/a&gt;</strong></span>&lt;/p&gt;
  {% include "records/footer.html" %}
{% endblock footer %}</pre></div><p>For this<a id="id848" class="indexterm"/> template as well, I have highlighted the parts I'd like you to focus on. Firstly, I load a custom tags module, <code class="literal">record_extras</code>, which we'll need later. I have also added an anchor at the top, so that we'll be able to put a link to it at the bottom of the page, to avoid having to scroll all the way up.</p><p>Then, I included a template to provide me with the HTML code to display Django messages. It's a very simple template which I'll show you shortly.</p><p>Then, we define a list of <code class="literal">div</code> elements. Each <code class="literal">Record</code> instance has a container <code class="literal">div</code>, in which there are two other main <code class="literal">div</code> elements: <code class="literal">record-left</code> and <code class="literal">record-right</code>. In order to display them side by side, I have set this class in the <code class="literal">main.css</code> file:</p><div class="informalexample"><pre class="programlisting">.record-left { float: left; width: 300px;}</pre></div><p>The outermost <code class="literal">div</code> container (the one with class <code class="literal">record</code>), has an <code class="literal">id</code> attribute, which I have used as an anchor. This allows us to click on <span class="strong"><strong>cancel</strong></span> on the record delete page, so that if we change our minds and don't want to delete the record, we can get back to the list page, and at the right position.</p><p>Each attribute of the record is then displayed in <code class="literal">div</code> elements whose class is <code class="literal">record-list</code>. Most of these classes are just there to allow me to set a bit of padding and dimensions on the HTML elements.</p><p>The next interesting bit is the <code class="literal">hide_password</code> tag, which takes the plaintext, which is the unencrypted password. The purpose of this custom tag is to display a sequence of <code class="literal">'*'</code> characters, as long as the original password, so that if someone is passing by while you're on the page, they won't see your passwords. However, hovering on that sequence of <code class="literal">'*'</code> characters will show you the original password in the tooltip. Here's the code for the <code class="literal">hide_password</code> tag:</p><p>
<code class="literal">records/templatetags/record_extras.py</code>
</p><div class="informalexample"><pre class="programlisting">from django import template
from django.utils.html import escape

register = template.Library()

@register.simple_tag
def hide_password(password):
    return '&lt;span title="{0}"&gt;{1}&lt;/span&gt;'.format(
        escape(password), '*' * len(password))</pre></div><p>There is<a id="id849" class="indexterm"/> nothing fancy here. We just register this function as a simple tag and then we can use it wherever we want. It takes a <code class="literal">password</code> and puts it as a <code class="literal">tooltip</code> of a <code class="literal">span</code> element, whose main content is a sequence of <code class="literal">'*' </code>characters. Just note one thing: we need to escape the password, so that we're sure it won't break our HTML (think of what might happen if the password contained a double-quote <code class="literal">`"`</code>, for example).</p><p>As far as the <code class="literal">list.html</code> template is concerned, the next interesting bit is that we set the <code class="literal">readonly</code> attribute to the <code class="literal">textarea</code> element, so as not to give the impression to the user that they can modify notes on the fly.</p><p>Then, we set a couple of links for each <code class="literal">Record</code> instance, right at the bottom of the container <code class="literal">div</code>. There is one for the edit page, and another for the delete page. Note that we need to pass the <code class="literal">url</code> tag not only the <code class="literal">namespace:name</code> string, but also the primary key information, as required by the URL setup we made in the <code class="literal">urls.py</code> module for those views.</p><p>Finally, we import the footer and set the link to the anchor on top of the page.</p><p>Now, as promised, here is the code for the messages:</p><p>
<code class="literal">records/templates/records/messages.html</code>
</p><div class="informalexample"><pre class="programlisting">{% if messages %}
  {% for message in messages %}
    &lt;p class="{{ message.tags }}"&gt;{{ message }}&lt;/p&gt;
  {% endfor %}
{% endif %}</pre></div><p>This code takes care of displaying messages only when there is at least one to display. We give the <code class="literal">p</code> tag <code class="literal">class</code> information to display success messages in green and error messages in red.</p><p>If you grab the <code class="literal">main.css</code> file from the source code for the book, you will now be able to visualize the list page (yours will be blank, you still need to insert data into it), and it should look something like this:</p><div class="mediaobject"><img src="graphics/4715_12_01.jpg" alt="Listing all records"/></div><p>As you <a id="id850" class="indexterm"/>can see, I have two records in the database at the moment. I'm hovering on the password of the first one, which is my platform account at my sister's school, and the password is displayed in the tooltip. The division in two <code class="literal">div</code> elements, <span class="emphasis"><em>left</em></span> and <span class="emphasis"><em>right</em></span>, helps in making rows smaller so that the overall result is more pleasing to the eye. The important information is on the left and the ancillary information is on the right. The row color alternates between a very light shade of blue and white.</p><p>Each row has an <span class="strong"><strong>edit</strong></span> and <span class="strong"><strong>delete</strong></span> link, at its bottom left. We'll show the pages for those two links right after we see the code for the templates that create them.</p><p>The CSS code that holds all the information for this interface is the following:</p><p>
<code class="literal">records/static/records/css/main.css</code>
</p><div class="informalexample"><pre class="programlisting">html, body, * {
  font-family: 'Trebuchet MS', Helvetica, sans-serif; }
a { color: #333; }
.record {
  clear: both; padding: 1em; border-bottom: 1px solid #666;}
.record-left { float: left; width: 300px;}
.record-list { padding: 2px 0; }
.fieldWrapper { padding: 5px; }
.footer { margin-top: 1em; color: #333; }
.home-option { padding: .6em 0; }
.record-span { font-weight: bold; padding-right: 1em; }
.record-notes { vertical-align: top; }
.record-list-actions { padding: 4px 0; clear: both; }
.record-list-actions a { padding: 0 4px; }
#pwd-info { padding: 0 6px; font-size: 1.1em; font-weight: bold;}
#id_notes { vertical-align: top; }
/* Messages */
.success, .errorlist {font-size: 1.2em; font-weight: bold; }
.success {color: #25B725; }
.errorlist {color: #B12B2B; }
/* colors */
.row-light-blue { background-color: #E6F0FA; }
.row-white { background-color: #fff; }
.green { color: #060; }
.orange { color: #FF3300; }
.red { color: #900; }</pre></div><p>Please <a id="id851" class="indexterm"/>remember, I'm not a CSS guru so just take this file as it is, a fairly naive way to provide styling to our interface.</p></div><div class="section" title="Creating and editing records"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec49"/>Creating and editing records</h3></div></div></div><p>Now for the interesting part. Creating and updating a record. We'll use the same template for both, so <a id="id852" class="indexterm"/>we expect some decisional logic to be there<a id="id853" class="indexterm"/> that will tell us in which of the two situations we are. As it turns out, it will not be that much code. The most exciting part of this template, however, is its associated JavaScript file which we'll examine right afterwards.</p><p>
<code class="literal">records/templates/records/record_add_edit.html</code>
</p><div class="informalexample"><pre class="programlisting">{% extends "records/base.html" %}
{% load static from staticfiles %}
{% block title %}
  <span class="strong"><strong>{% if update %}Update{% else %}Create{% endif %} Record</strong></span>
{% endblock title %}

{% block page-content %}
  &lt;h1&gt;<span class="strong"><strong>{% if update %}Update a{% else %}Create a new{% endif %}</strong></span>
    Record
  &lt;/h1&gt;
  {% include "records/messages.html" %}

  &lt;form action="." method="post"&gt;<span class="strong"><strong>{% csrf_token %}</strong></span>
    {{ form.non_field_errors }}

    &lt;div class="fieldWrapper"&gt;{{ form.title.errors }}
      {{ form.title.label_tag }} {{ form.title }}&lt;/div&gt;

    &lt;div class="fieldWrapper"&gt;{{ form.username.errors }}
      {{ form.username.label_tag }} {{ form.username }}&lt;/div&gt;

    &lt;div class="fieldWrapper"&gt;{{ form.email.errors }}
      {{ form.email.label_tag }} {{ form.email }}&lt;/div&gt;

    &lt;div class="fieldWrapper"&gt;{{ form.url.errors }}
      {{ form.url.label_tag }} {{ form.url }}&lt;/div&gt;

    &lt;div class="fieldWrapper"&gt;{{ form.password.errors }}
      {{ form.password.label_tag }} {{ form.password }}
      <span class="strong"><strong>&lt;span id="pwd-info"&gt;&lt;/span&gt;</strong></span>&lt;/div&gt;

    <span class="strong"><strong>&lt;button type="button" id="validate-btn"&gt;</strong></span>
<span class="strong"><strong>      Validate Password&lt;/button&gt;</strong></span>
<span class="strong"><strong>    &lt;button type="button" id="generate-btn"&gt;</strong></span>
<span class="strong"><strong>      Generate Password&lt;/button&gt;</strong></span>

    &lt;div class="fieldWrapper"&gt;{{ form.notes.errors }}
      {{ form.notes.label_tag }} {{ form.notes }}&lt;/div&gt;

    &lt;input type="submit"
      value="<span class="strong"><strong>{% if update %}Update{% else %}Insert{% endif %}</strong></span>"&gt;
  &lt;/form&gt;
{% endblock page-content %}

{% block footer %}
  &lt;br&gt;{% include "records/footer.html" %}&lt;br&gt;
  Go to &lt;a href="{% url "records:list" %}"&gt;the records list&lt;/a&gt;.
{% endblock footer %}

{% block scripts %}
  {{ block.super }}
  &lt;script src="<span class="strong"><strong>{% static "records/js/api.js" %}</strong></span>"&gt;&lt;/script&gt;
{% endblock scripts %}</pre></div><p>As <a id="id854" class="indexterm"/>usual, I have highlighted the important parts, so let's<a id="id855" class="indexterm"/> go through this code together.</p><p>You can see the first bit of decision logic in the <code class="literal">title</code> block. Similar decision logic is also displayed later on, in the header of the page (the <code class="literal">h1</code> HTML tag), and in the <code class="literal">submit</code> button at the end of the form.</p><p>Apart from<a id="id856" class="indexterm"/> this logic, what I'd like you to focus on is the <a id="id857" class="indexterm"/>form and what's inside it. We set the action attribute to a dot, which means <span class="emphasis"><em>this page</em></span>, so that we don't need to customize it according to which view is serving the page. Also, we immediately take care of the <span class="emphasis"><em>cross-site request forgery</em></span> token, as explained in <a class="link" href="ch10.html" title="Chapter 10. Web Development Done Right">Chapter 10</a>, <span class="emphasis"><em>Web Development Done Right</em></span>.</p><p>Note that, this time, we cannot leave the whole form rendering up to Django since we want to add in a couple of extra things, so we go down one level of granularity and ask Django to render each individual field for us, along with any errors, along with its label. This way we still save a lot of effort, and at the same time, we can also customize the form as we like. In situations like this, it's not uncommon to write a small template to render a field, in order to avoid repeating those three lines for each field. In this case though, the form is so small I decided to avoid raising the complexity level up any further.</p><p>The <code class="literal">span</code> element, <code class="literal">pwd-info</code>, contains the information about the password that we get from the API. The two buttons after that, <code class="literal">validate-btn</code> and <code class="literal">generate-btn</code>, are hooked up with the AJAX calls to the API.</p><p>At the end of the template, in the <code class="literal">scripts</code> block, we need to load the <code class="literal">api.js</code> JavaScript file which contains the code to work with the API. We also need to use <code class="literal">block.super</code>, which will load whatever code is in the same block in the parent template (for example, jQuery). <code class="literal">block.super</code> is basically the template equivalent of a call to <code class="literal">super(ClassName, self)</code> in Python. It's important to load jQuery before our library, since the latter is based on the former.</p></div><div class="section" title="Talking to the API"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec50"/>Talking to the API</h3></div></div></div><p>Let's now<a id="id858" class="indexterm"/> take a look at that JavaScript. I don't expect you to understand everything. Firstly, this is a Python book and secondly, you're supposed to be a beginner (though by now, <span class="emphasis"><em>ninja trained</em></span>), so fear not. However, as JavaScript has, by now, become essential if you're dealing with a web environment, having a working knowledge of it is extremely important even for a Python developer, so try and get the most out of what I'm about to show you. We'll see the password generation first:</p><p>
<code class="literal">records/static/records/js/api.js</code>
</p><div class="informalexample"><pre class="programlisting">var baseURL = 'http://127.0.0.1:5555/password';

var getRandomPassword = function() {
  var apiURL = '{url}/generate'.replace('{url}', baseURL);
  $.ajax({
    type: 'GET',
    url: apiURL,
    success: function(data, status, request) {
      $('#id_password').val(data[1]);
    },
    error: function() { alert('Unexpected error'); }
  });
}

$(function() {
  $('#generate-btn').click(getRandomPassword);
});</pre></div><p>Firstly, we<a id="id859" class="indexterm"/> set a variable for the base API URL: <code class="literal">baseURL</code>. Then, we define the <code class="literal">getRandomPassword</code> function, which is very simple. At the beginning, it defines the <code class="literal">apiURL</code> extending <code class="literal">baseURL</code> with a replacement technique. Even if the syntax is different from that of Python, you shouldn't have any issues understanding this line.</p><p>After defining the <code class="literal">apiURL</code>, the interesting bit comes up. We call <code class="literal">$.ajax</code>, which is the jQuery function that performs the AJAX calls. That <code class="literal">$</code> is a shortcut for jQuery. As you can see in the body of the call, it's a <code class="literal">GET</code> request to <code class="literal">apiURL</code>. If it succeeds (<code class="literal">success</code>: ...), an anonymous function is run, which sets the value of the <code class="literal">id_password</code> text field to the second element of the returned data. We'll see the structure of the data when we examine the API code, so don't worry about that now. If an error occurs, we simply alert the user that there was an unexpected error.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note69"/>Note</h3><p>The reason why the password field in the HTML has <code class="literal">id_password</code> as the ID is due to the way Django renders forms. You can customize this behavior using a custom prefix, for example. In this case, I'm happy with the Django defaults.</p></div></div><p>After the function definition, we run a couple of lines of code to bind the <code class="literal">click</code> event on the <code class="literal">generate-btn</code> button to the <code class="literal">getRandomPassword</code> function. This means that, after this code has been run by the browser engine, every time we click the <code class="literal">generate-btn</code> button, the <code class="literal">getRandomPassword</code> function is called.</p><p>That wasn't so scary, was it? So let's see what we need for the validation part.</p><p>Now there is a value in the <span class="strong"><strong>password</strong></span> field and we want to validate it. We need to call the API and inspect its response. Since passwords can have weird characters, I don't want to pass them on the URL, therefore I will use a <code class="literal">POST</code> request, which allows me to put the password in its body. To do this, I need the following code:</p><div class="informalexample"><pre class="programlisting">var validatePassword = function() {
  var apiURL = '{url}/validate'.replace('{url}', baseURL);
  $.ajax({
    type: 'POST',
    url: apiURL,
    <span class="strong"><strong>data: JSON.stringify({'password': $('#id_password').val()}),</strong></span>
    contentType: "text/plain",  // Avoid CORS preflight
    success: function(data, status, request) {
      var valid = data['valid'], infoClass, grade;
      var msg = (valid?'Valid':'Invalid') + ' password.';
      if (valid) {
        var score = data['score']['total'];
        grade = (score&lt;10?'Poor':(score&lt;18?'Medium':'Strong'));
        infoClass = (score&lt;10?'red':(score&lt;18?'orange':'green'));
        msg += ' (Score: {score}, {grade})'
          .replace('{score}', score).replace('{grade}', grade);
      }
      $('#pwd-info').html(msg);
      $('#pwd-info').removeClass().addClass(infoClass);
    },
    error: function(data) { alert('Unexpected error'); }
  });
}

$(function() {
  $('#validate-btn').click(validatePassword);
});</pre></div><p>The concept<a id="id860" class="indexterm"/> is the same as before, only this time it's for the <code class="literal">validate-btn</code> button. The body of the AJAX call is similar. We use a <code class="literal">POST</code> instead of a <code class="literal">GET</code> request, and we define the data as a JSON object, which is the equivalent of using <code class="literal">json.dumps({'password': 'some_pwd'})</code> in Python.</p><p>The <code class="literal">contentType</code> line is a quick hack to avoid problems with the CORS preflight behavior<a id="id861" class="indexterm"/> of the browser. <span class="strong"><strong>Cross-origin resource sharing</strong></span> (<span class="strong"><strong>CORS</strong></span>) is a mechanism that allows restricted resources on a web page to be requested from another domain outside of the domain from which the request originated. In a nutshell, since the API is located at <code class="literal">127.0.0.1:5555</code> and the interface is running at <code class="literal">127.0.0.1:8000</code>, without this hack, the browser wouldn't allow us to perform the calls. In a production environment, you may want to check the documentation for JSONP, which is a much better (albeit more complex) solution to this issue.</p><p>The body of the anonymous function which is run if the call succeeds is apparently only a bit complicated. All we need to do is understand if the password is valid (from <code class="literal">data['valid']</code>), and assign it a grade and a CSS class based on its score. Validity and score information come from the API response.</p><p>The only tricky bit in this code is the JavaScript ternary operator, so let's see a comparative example for it:</p><div class="informalexample"><pre class="programlisting"># Python
error = 'critical' if error_level &gt; 50 else 'medium'
// JavaScript equivalent
error = (error_level &gt; 50 ? 'critical' : 'medium');</pre></div><p>With this<a id="id862" class="indexterm"/> example, you shouldn't have any issue reading the rest of the logic in the function. I know, I could have just used a regular <code class="literal">if (...)</code>, but JavaScript coders use the ternary operator all the time, so you should get used to it. It's good training to scratch our heads a bit harder in order to understand code.</p><p>Lastly, I'd like you to take a look at the end of that function. We set the <code class="literal">html</code> of the <code class="literal">pwd-info</code> span element to the message we assembled (<code class="literal">msg</code>), and then we style it. In one line, we remove all the CSS classes from that element (<code class="literal">removeClass()</code> with no parameters does that), and we add the <code class="literal">infoClass</code> to it. <code class="literal">infoClass</code> is either <code class="literal">'red'</code>, <code class="literal">'orange'</code>, or <code class="literal">'green'</code>. If you go back to the <code class="literal">main.css</code> file, you'll see them at the bottom.</p><p>Now that we've seen both the template code and the JavaScript to make the calls, let's see a screenshot of the page. We're going to edit the first record, the one about my sister's school.</p><div class="mediaobject"><img src="graphics/4715_12_02.jpg" alt="Talking to the API"/></div><p>In the picture, you can see that I updated the password by clicking on the <span class="strong"><strong>Generate</strong></span> <span class="strong"><strong>Password</strong></span> button. Then, I saved the record (so you could see the nice message on top), and, finally, I clicked on the <span class="strong"><strong>Validate</strong></span> <span class="strong"><strong>Password</strong></span> button.</p><p>The result is<a id="id863" class="indexterm"/> shown in green on the right-hand side of the <span class="strong"><strong>Password</strong></span> field. It's strong (23 is actually the maximum score we can get) so the message is displayed in a nice shade of green.</p></div><div class="section" title="Deleting records"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec51"/>Deleting records</h3></div></div></div><p>To delete<a id="id864" class="indexterm"/> a record, go to the list and click on the <span class="strong"><strong>delete</strong></span> link. You'll be redirected to a page that asks you for confirmation; you can then choose to proceed and delete the poor record, or to cancel the request and go back to the list page. The template code is the following:</p><p>
<code class="literal">records/templates/records/record_confirm_delete.html</code>
</p><div class="informalexample"><pre class="programlisting">{% extends "records/base.html" %}
{% block title %}Delete record{% endblock title %}

{% block page-content %}
  &lt;h1&gt;Confirm Record Deletion&lt;/h1&gt;
  &lt;form action="." method="post"&gt;{% csrf_token %}
    &lt;p&gt;Are you sure you want to delete "<span class="strong"><strong>{{ object }}</strong></span>"?&lt;/p&gt;
    &lt;input type="submit" value="Confirm" /&gt;&amp;nbsp;
    &lt;a href="<span class="strong"><strong>{% url "records:list" %}#record-{{ object.pk }}</strong></span>"&gt;
       » cancel&lt;/a&gt;
  &lt;/form&gt;
{% endblock page-content %}</pre></div><p>Since this is a template for a standard Django view, we need to use the naming conventions adopted by Django. Therefore, the record in question is called <span class="strong"><strong>object</strong></span> in the template. The <code class="literal">{{ object }}</code> tag displays a string representation for the object, which is not exactly beautiful at the moment, since the whole line will read: <span class="strong"><strong>Are you sure you want to delete "Record object"?</strong></span>.</p><p>This is because we haven't added a <code class="literal">__str__</code> method to our <code class="literal">Model</code> class yet, which means that Python has no idea of what to show us when we ask for a string representation of an instance. Let's change this by completing our model, adding the <code class="literal">__str__</code> method at the bottom of the class body:</p><p>
<code class="literal">records/models.py</code>
</p><div class="informalexample"><pre class="programlisting">class Record(models.Model):
    ...

    <span class="strong"><strong>def __str__(self):</strong></span>
<span class="strong"><strong>        return '{}'.format(self.title)</strong></span>
</pre></div><p>Restart the server and now the page will read: <span class="strong"><strong>Are you sure you want to delete "Some Bank"?</strong></span> where <span class="emphasis"><em>Some Bank</em></span> is the <code class="literal">title</code> of the record whose <span class="strong"><strong>delete</strong></span> link I clicked on.</p><p>We could<a id="id865" class="indexterm"/> have just used <code class="literal">{{ object.title }}</code>, but I prefer to fix the root of the problem, not just the effect. Adding a <code class="literal">__str__</code> method is in fact something that you ought to do for all of your models.</p><p>The interesting bit in this last template is actually the link for canceling the operation. We use the <code class="literal">url</code> tag to go back to the list view (<code class="literal">records:list</code>), but we add anchor information to it so that it will eventually read something like this (this is for <code class="literal">pk=2</code>):</p><p>
<code class="literal">http://127.0.0.1:8000/records/#record-2</code>
</p><p>This will go back to the list page and scroll down to the container <code class="literal">div</code> that has ID record 2, which is nice.</p><p>This concludes the interface. Even though this section was similar to what we saw in <a class="link" href="ch10.html" title="Chapter 10. Web Development Done Right">Chapter 10</a>, <span class="emphasis"><em>Web Development Done Right</em></span>, we've been able to concentrate more on the code in this chapter. We've seen how useful Django class-based views are, and we even touched on some cool JavaScript. Run <code class="literal">$ python manage.py runserver</code> and your interface should be up and running at <code class="literal">http://127.0.0.1:8000</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note70"/>Note</h3><p>If you are wondering, <code class="literal">127.0.0.1</code> means the <code class="literal">localhost</code>—your computer—while <code class="literal">8000</code> is the port to which the server is bound, to listen for incoming requests.</p></div></div><p>Now it's time to spice things up a bit with the second part of this project.</p></div></div></div>
<div class="section" title="Implementing the Falcon API"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec88"/>Implementing the Falcon API</h1></div></div></div><p>The <a id="id866" class="indexterm"/>structure of the Falcon project we're about to code is nowhere near as extended as the interface one. We'll code five files altogether. In your <code class="literal">ch12</code> folder, create a new one called <code class="literal">pwdapi</code>. This is its final structure:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ tree -A pwdapi/</strong></span>
<span class="strong"><strong>pwdapi/</strong></span>
<span class="strong"><strong>├── core</strong></span>
<span class="strong"><strong>│   ├── handlers.py</strong></span>
<span class="strong"><strong>│   └── passwords.py</strong></span>
<span class="strong"><strong>├── main.py</strong></span>
<span class="strong"><strong>└── tests</strong></span>
<span class="strong"><strong>    └── test_core</strong></span>
<span class="strong"><strong>        ├── test_handlers.py</strong></span>
<span class="strong"><strong>        └── test_passwords.py</strong></span>
</pre></div><p>The API was all coded using TDD, so we're also going to explore the tests. However, I think it's going to be easier for you to understand the tests if you first see the code, so we're <a id="id867" class="indexterm"/>going to start with that.</p><div class="section" title="The main application"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec143"/>The main application</h2></div></div></div><p>This is<a id="id868" class="indexterm"/> the code for the Falcon application:</p><p>
<code class="literal">main.py</code>
</p><div class="informalexample"><pre class="programlisting">import falcon
from core.handlers import (
    PasswordValidatorHandler,
    PasswordGeneratorHandler,
)

validation_handler = PasswordValidatorHandler()
generator_handler = PasswordGeneratorHandler()

app = falcon.API()
app.add_route('/password/validate/', validation_handler)
app.add_route('/password/generate/', generator_handler)</pre></div><p>As in the example in <a class="link" href="ch10.html" title="Chapter 10. Web Development Done Right">Chapter 10</a>, <span class="emphasis"><em>Web Development Done Right</em></span>, we start by creating one instance for each of the handlers we need, then we create a <code class="literal">falcon.API</code> object and, by calling its <code class="literal">add_route</code> method, we set up the routing to the URLs of our API. We'll get to the definitions of the handlers in a moment. Firstly, we need a couple of helpers.</p></div><div class="section" title="Writing the helpers"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec144"/>Writing the helpers</h2></div></div></div><p>In this <a id="id869" class="indexterm"/>section, we will take a look at a couple of classes that <a id="id870" class="indexterm"/>we'll use in our handlers. It's always good to factor out some logic following the <span class="strong"><strong>Single Responsibility Principle</strong></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note71"/>Note</h3><p>In<a id="id871" class="indexterm"/> OOP, the <span class="strong"><strong>Single Responsibility Principle</strong></span> (<span class="strong"><strong>SRP</strong></span>) states that every class should have responsibility for a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All of its services should be narrowly aligned with that responsibility.</p><p>The Single Responsibility Principle is the <span class="emphasis"><em>S</em></span> in <span class="strong"><strong>S.O.L.I.D.</strong></span>, an acronym for the first five OOP and software design principles introduced by Robert Martin.</p><p>I heartily suggest you to open a browser and read up on this subject, it is very important.</p></div></div><p>All the <a id="id872" class="indexterm"/>code in the helpers section belongs to the <code class="literal">core/passwords.py</code> module. Here's how it begins:</p><div class="informalexample"><pre class="programlisting">from math import ceil
from random import sample
from string import ascii_lowercase, ascii_uppercase, digits

punctuation = '!#$%&amp;()*+-?@_|'
allchars = ''.join(
    (ascii_lowercase, ascii_uppercase, digits, punctuation))</pre></div><p>We'll <a id="id873" class="indexterm"/>need to handle some randomized calculations but the most important part here is the allowed characters. We will allow letters, digits, and a set of punctuation characters. To ease writing the code, we will merge those parts into the <code class="literal">allchars</code> string.</p><div class="section" title="Coding the password validator"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec52"/>Coding the password validator</h3></div></div></div><p>The <code class="literal">PasswordValidator</code> class is my favorite bit of logic in the whole API. It exposes an <code class="literal">is_valid</code> and<a id="id874" class="indexterm"/> a <code class="literal">score</code> method. The latter runs all defined validators ("private" methods in the same class), and collects the scores into a single dict which is returned as a result. I'll write this class method by method so that it does not get too complicated:</p><div class="informalexample"><pre class="programlisting">class PasswordValidator:
    def __init__(self, password):
        self.password = password.strip()</pre></div><p>It begins by setting <code class="literal">password</code> (with no leading or trailing spaces) as an instance attribute. This way we won't then have to pass it around from method to method. All the methods that will follow belong to this class.</p><div class="informalexample"><pre class="programlisting">    def is_valid(self):
        return (len(self.password) &gt; 0 and
                all(char in allchars for char in self.password))</pre></div><p>A password is valid when its length is greater than 0 and all of its characters belong to the <code class="literal">allchars</code> string. When you read the <code class="literal">is_valid</code> method, it's practically English (that's how amazing Python is). <code class="literal">all</code> is a built-in function that tells you if all the elements of the iterable you feed to it are <code class="literal">True</code>.</p><div class="informalexample"><pre class="programlisting">    def score(self):
        result = {
            'length': self._score_length(),
            'case': self._score_case(),
            'numbers': self._score_numbers(),
            'special': self._score_special(),
            'ratio': self._score_ratio(),
        }
        result['total'] = sum(result.values())
        return result</pre></div><p>This is<a id="id875" class="indexterm"/> the other main method. It's very simple, it just prepares a dict with all the results from the validators. The only independent bit of logic happens at the end, when we sum the grades from each validator and assign it to a <code class="literal">'total'</code> key in the dict, just for convenience.</p><p>As you can see, we score a password by length, by letter case, by the presence of numbers, and special characters, and, finally, by the ratio between letters and numbers. Letters allow a character to be between <span class="emphasis"><em>26 * 2 = 52</em></span> different possible choices, while digits allow only 10. Therefore, passwords whose letters to digits ratio is higher are more difficult to crack.</p><p>Let's see the length validator:</p><div class="informalexample"><pre class="programlisting">    def _score_length(self):
        scores_list = ([0]*4) + ([1]*4) + ([3]*4) + ([5]*4)
        scores = dict(enumerate(scores_list))
        return scores.get(len(self.password), 7)</pre></div><p>We assign 0 points to passwords whose length is less than four characters, 1 point for those whose length is less than 8, 3 for a length less than 12, 5 for a length less than 16, and 7 for a length of 16 or more.</p><p>In order to avoid a waterfall of <code class="literal">if</code>/<code class="literal">elif</code> clauses, I have adopted a functional style here. I prepared a <code class="literal">score_list,</code> which is basically <code class="literal">[0, 0, 0, 0, 1, 1, 1, 1, 3, ...]</code>. Then, by enumerating it, I got a (<span class="emphasis"><em>length, score</em></span>) pair for each length less than 16. I put those pairs into a dict, which gives me the equivalent in dict form, so it should look like this: <code class="literal">{0:0, 1:0, 2:0, 3:0, 4:1, 5:1, ...}</code>. I then perform a <code class="literal">get</code> on this dict with the length of the password, setting a value of 7 as the default (which will be returned for lengths of 16 or more, which are not in the dict).</p><p>I have nothing against <code class="literal">if</code>/<code class="literal">elif</code> clauses, of course, but I wanted to take the opportunity to show you different coding styles in this final chapter, to help you get used to reading code which deviates from what you would normally expect. It's only beneficial.</p><div class="informalexample"><pre class="programlisting">    def _score_case(self):
        lower = bool(set(ascii_lowercase) &amp; set(self.password))
        upper = bool(set(ascii_uppercase) &amp; set(self.password))
        return int(lower or upper) + 2 * (lower and upper)</pre></div><p>The way we validate the case is again with a nice trick. <code class="literal">lower</code> is <code class="literal">True</code> when the intersection between the password and all lowercase characters is non-empty, otherwise it's <code class="literal">False</code>. <code class="literal">upper</code> behaves in the same way, only with uppercase characters.</p><p>To <a id="id876" class="indexterm"/>understand the evaluation that happens on the last line, let's use the inside-out technique once more: <code class="literal">lower or upper</code> is <code class="literal">True</code> when at least one of the two is <code class="literal">True</code>. When it's <code class="literal">True</code>, it will be converted to a <code class="literal">1</code> by the <code class="literal">int</code> class. This equates to saying, if there is at least one character, regardless of the casing, the score gets 1 point, otherwise it stays at 0.</p><p>Now for the second part: <code class="literal">lower and upper</code> is <code class="literal">True</code> when both of them are <code class="literal">True</code>, which means that we have at least one lowercase and one uppercase character. This means that, to crack the password, a brute-force algorithm would have to loop through 52 letters instead of just 26. Therefore, when that's <code class="literal">True</code>, we get an extra two points.</p><p>This validator therefore produces a result in the range (0, 1, 3), depending on what the password is.</p><div class="informalexample"><pre class="programlisting">    def _score_numbers(self):
        return 2 if (set(self.password) &amp; set(digits)) else 0</pre></div><p>Scoring on the numbers is simpler. If we have at least one number, we get two points, otherwise we get 0. In this case, I used a ternary operator to return the result.</p><div class="informalexample"><pre class="programlisting">    def _score_special(self):
        return 4 if (
            set(self.password) &amp; set(punctuation)) else 0</pre></div><p>The special characters validator has the same logic as the previous one but, since special characters add quite a bit of complexity when it comes to cracking a password, we have scored four points instead of just two.</p><p>The last one validates the ratio between the letters and the digits.</p><div class="informalexample"><pre class="programlisting">    def _score_ratio(self):
        alpha_count = sum(
            <span class="strong"><strong>1 if c.lower() in ascii_lowercase else 0</strong></span>
            for c in self.password)
        digits_count = sum(
            <span class="strong"><strong>1 if c in digits else 0</strong></span> for c in self.password)
        if digits_count == 0:
            return 0
        return min(ceil(alpha_count / digits_count), 7)</pre></div><p>I highlighted the conditional logic in the expressions in the <code class="literal">sum</code> calls. In the first case, we get a 1 for each character whose lowercase version is in <code class="literal">ascii_lowercase</code>. This means that summing all those 1's up gives us exactly the count of all the letters. Then, we do the same for the digits, only we use the digits string for reference, and we don't need to lowercase the character. When <code class="literal">digits_count</code> is 0, <code class="literal">alpha_count / digits_count</code> would cause a <code class="literal">ZeroDivisionError</code>, therefore we check on <code class="literal">digits_count</code> and when it's 0 we return 0. If we have digits, we calculate the ceiling of the <span class="emphasis"><em>letters:digits</em></span> ratio, and return it, capped at 7.</p><p>Of course, there<a id="id877" class="indexterm"/> are many different ways to calculate a score for a password. My aim here is not to give you the finest algorithm to do that, but to show you how you could go about implementing it.</p></div><div class="section" title="Coding the password generator"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec53"/>Coding the password generator</h3></div></div></div><p>The<a id="id878" class="indexterm"/> password generator is a much simpler class than the validator. However, I have coded it so that we won't need to create an instance to use it, just to show you yet again a different coding style.</p><div class="informalexample"><pre class="programlisting">class PasswordGenerator:

    @classmethod
    def generate(cls, length, bestof=10):
        candidates = sorted([
            cls._generate_candidate(length)
            for k in range(max(1, bestof))
        ])
        return candidates[-1]

    @classmethod
    def _generate_candidate(cls, length):
        password = cls._generate_password(length)
        score = PasswordValidator(password).score()
        return (score['total'], password)

    @classmethod
    def _generate_password(cls, length):
        chars = allchars * (ceil(length / len(allchars)))
        return ''.join(sample(chars, length))</pre></div><p>Of the three methods, only the first one is meant to be used. Let's start our analysis with the last one: <code class="literal">_generate_password</code>.</p><p>This method simply takes a length, which is the desired length for the password we want, and calls the sample function to get a population of length elements out of the <code class="literal">chars</code> string. The return value of the sample function is a list of length elements, and we need to make it a string using <code class="literal">join</code>.</p><p>Before we can call <code class="literal">sample</code>, think about this, what if the desired length exceeds the length of <code class="literal">allchars</code>? The call would result in <code class="literal">ValueError: Sample larger than the population</code>.</p><p>Because<a id="id879" class="indexterm"/> of this, we create the <code class="literal">chars</code> string in a way that it is made by concatenating the <code class="literal">allchars</code> string to itself just enough times to cover the desired length. To give you an example, let's say we need a password of 27 characters, and let's pretend <code class="literal">allchars</code> is 10 characters long. <code class="literal">length / len(allchars)</code> gives 2.7, which, when passed to the <code class="literal">ceil</code> function, becomes 3. This means that we're going to assign <code class="literal">chars</code> to a triple concatenation of the <code class="literal">allchars</code> string, hence <code class="literal">chars</code> will be <span class="emphasis"><em>10 * 3 = 30</em></span> characters long, which is enough to cover our requirements.</p><p>Note that, in order for these methods to be called without creating an instance of this class, we need to decorate them with the <code class="literal">classmethod</code> decorator. The convention is then to call the first argument, <code class="literal">cls</code>, instead of <code class="literal">self</code>, because Python, behind the scenes, will pass the class object to the call.</p><p>The code for <code class="literal">_generate_candidate</code> is also very simple. We just generate a password and, given the length, we calculate its score, and return a tuple (<span class="emphasis"><em>score, password</em></span>).</p><p>We do this so that in the <code class="literal">generate</code> method we can generate 10 (by default) passwords each time the method is called and return the one that has the highest score. Since our generation logic is based on a random function, it's always a good way to employ a technique like this to avoid worst case scenarios.</p><p>This concludes the code for the helpers.</p></div></div><div class="section" title="Writing the handlers"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec145"/>Writing the handlers</h2></div></div></div><p>As you <a id="id880" class="indexterm"/>may have noticed, the code for the helpers isn't related <a id="id881" class="indexterm"/>to Falcon at all. It is just pure Python that we can reuse when we need it. On the other hand, the code for the handlers is of course based on Falcon. The code that follows belongs to the <code class="literal">core/handlers.py</code> module so, as we did before, let's start with the first few lines:</p><div class="informalexample"><pre class="programlisting">import json
import falcon
from .passwords import PasswordValidator, PasswordGenerator

class HeaderMixin:
    def set_access_control_allow_origin(self, resp):
        resp.set_header('Access-Control-Allow-Origin', '*')</pre></div><p>That was very simple. We import <code class="literal">json</code>, <code class="literal">falcon</code>, and our helpers, and then we set up a mixin which we'll need in both handlers. The need for this mixin is to allow the API to serve requests that come from somewhere else. This is the other side of the CORS coin to what we saw in the JavaScript code for the interface. In this case, we boldly go where no security expert would ever dare, and allow requests to come from any domain (<code class="literal">'*'</code>). We do this <a id="id882" class="indexterm"/>because this is an exercise and, in this context, it is fine, but don't do it in production, okay?</p><div class="section" title="Coding the password validator handler"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec54"/>Coding the password validator handler</h3></div></div></div><p>This <a id="id883" class="indexterm"/>handler will have to respond to a <code class="literal">POST</code> request, therefore I have coded an <code class="literal">on_post</code> method, which is the way you react to a <code class="literal">POST</code> request in Falcon.</p><div class="informalexample"><pre class="programlisting">class PasswordValidatorHandler(HeaderMixin):

    def on_post(self, req, resp):
        self.process_request(req, resp)
        password = req.context.get('_body', {}).get('password')
        if password is None:
            resp.status = falcon.HTTP_BAD_REQUEST
            return None

        result = self.parse_password(password)
        resp.body = json.dumps(result)

    def parse_password(self, password):
        validator = PasswordValidator(password)
        return {
            'password': password,
            'valid': validator.is_valid(),
            'score': validator.score(),
        }

    def process_request(self, req, resp):
        self.set_access_control_allow_origin(resp)

        body = req.stream.read()
        if not body:
            raise falcon.HTTPBadRequest('Empty request body',
                'A valid JSON document is required.')
        try:
            <span class="strong"><strong>req.context['_body'] = json.loads(</strong></span>
<span class="strong"><strong>                body.decode('utf-8'))</strong></span>
        except (ValueError, UnicodeDecodeError):
            raise falcon.HTTPError(
                falcon.HTTP_753, 'Malformed JSON',
                'JSON incorrect or not utf-8 encoded.')</pre></div><p>Let's start with the <code class="literal">on_post</code> method. First of all, we call the <code class="literal">process_request</code> method, which does a sanity check on the request body. I won't go into finest detail because it's taken from the Falcon documentation, and it's a standard way of processing a request. Let's just <a id="id884" class="indexterm"/>say that, if everything goes well (the highlighted part), we get the body of the request (already decoded from JSON) in <code class="literal">req.context['_body']</code>. If things go badly for any reason, we return an appropriate error response.</p><p>Let's go back to <code class="literal">on_post</code>. We fetch the password from the request context. At this point, <code class="literal">process_request</code> has succeeded, but we still don't know if the body was in the correct format. We're expecting something like: <code class="literal">{'password': 'my_password'}</code>.</p><p>So we proceed with caution. We get the value for the <code class="literal">'_body'</code> key and, if that is not present, we return an empty dict. We get the value for <code class="literal">'password'</code> from that. We use <code class="literal">get</code> instead of direct access to avoid <code class="literal">KeyError</code> issues.</p><p>If the password is <code class="literal">None,</code> we simply return a 400 error (bad request). Otherwise, we validate it and calculate its score, and then set the result as the body of our response.</p><p>You can see how easy it is to validate and calculate the score of the password in the <code class="literal">parse_password</code> method, by using our helpers.</p><p>We return a dict with three pieces of information: <code class="literal">password</code>, <code class="literal">valid</code>, and <code class="literal">score</code>. The password information is technically redundant because whoever made the request would know the password but, in this case, I think it's a good way of providing enough information for things such as logging, so I added it.</p><p>What happens if the JSON-decoded body is not a dict? I will leave it up to you to fix the code, adding some logic to cater for that edge case.</p></div><div class="section" title="Coding the password generator handler"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec55"/>Coding the password generator handler</h3></div></div></div><p>The <a id="id885" class="indexterm"/>generator handler has to handle a <code class="literal">GET</code> request with one query parameter: the desired password length.</p><div class="informalexample"><pre class="programlisting">class PasswordGeneratorHandler(HeaderMixin):

    def on_get(self, req, resp):
        self.process_request(req, resp)
        length = req.context.get('_length', 16)
        resp.body = json.dumps(
            PasswordGenerator.generate(length))

    def process_request(self, req, resp):
        self.set_access_control_allow_origin(resp)
        length = req.get_param('length')
        if length is None:
            return
        try:
            length = int(length)
            assert length &gt; 0
            req.context['_length'] = length
        except (ValueError, TypeError, AssertionError):
            raise falcon.HTTPBadRequest('Wrong query parameter',
                '`length` must be a positive integer.')</pre></div><p>We have a similar <code class="literal">process_request</code> method. It does a sanity check on the request, even though<a id="id886" class="indexterm"/> a bit differently from the previous handler. This time, we need to make sure that if the length is provided on the query string (which means, for example, <code class="literal">http://our-api-url/?length=23</code>), it's in the correct format. This means that <code class="literal">length</code> needs to be a positive integer.</p><p>So, to validate that, we do an <code class="literal">int</code> conversion (<code class="literal">req.get_param('length')</code> returns a string), then we assert that <code class="literal">length</code> is greater than zero and, finally, we put it in <code class="literal">context</code> under the <code class="literal">'_length'</code> key.</p><p>Doing the <code class="literal">int</code> conversion of a string which is not a suitable representation for an integer raises <code class="literal">ValueError</code>, while a conversion from a type that is not a string raises <code class="literal">TypeError</code>, therefore we catch those two in the <code class="literal">except</code> clause.</p><p>We also catch <code class="literal">AssertionError</code>, which is raised by the <code class="literal">assert length &gt; 0</code> line when <code class="literal">length</code> is not a positive integer. We can then safely guarantee that the length is as desired with one single <code class="literal">try</code>/<code class="literal">except</code> block.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip23"/>Tip</h3><p>Note that, when coding a <code class="literal">try</code>/<code class="literal">except</code> block, you should usually try and be as specific as possible, separating instructions that would raise different exceptions if a problem arose. This would allow you more control over the issue, and easier debugging. In this case though, since this is a simple API, it's fine to have code which only reacts to a request for which <code class="literal">length</code> is not in the right format.</p></div></div><p>The code for the <code class="literal">on_get</code> method is quite straightforward. It starts by processing the request, then the length is fetched, falling back to 16 (the default value) when it's not passed, and then a password is generated and dumped to JSON, and then set to be the body of the response.</p></div></div><div class="section" title="Running the API"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec146"/>Running the API</h2></div></div></div><p>In order <a id="id887" class="indexterm"/>to run this application, you need to remember that we set the base URL in the interface to <code class="literal">http://127.0.0.1:5555</code>. Therefore, we need the following command to start the API:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gunicorn -b 127.0.0.1:5555 main:app</strong></span>
</pre></div><p>Running that will start the app defined in the main module, binding the server instance to port <code class="literal">5555</code> on <code class="literal">localhost</code>. For<a id="id888" class="indexterm"/> more information about Gunicorn, please refer to either <a class="link" href="ch10.html" title="Chapter 10. Web Development Done Right">Chapter 10</a>, <span class="emphasis"><em>Web Development Done Right</em></span> or directly to the project's home page (<a class="ulink" href="http://gunicorn.org/">http://gunicorn.org/</a>).</p><p>The code for the API is now complete so if you have both the interface and the API running, you can try them out together. See if everything works as expected.</p></div><div class="section" title="Testing the API"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec147"/>Testing the API</h2></div></div></div><p>In this<a id="id889" class="indexterm"/> section, let's take a look at the tests I wrote for the helpers <a id="id890" class="indexterm"/>and for the handlers. Tests for the helpers are heavily based on the <code class="literal">nose_parameterized</code> library, as my favorite testing style is interface testing, with as little patching as possible. Using <code class="literal">nose_parameterized</code> allows me to write tests that are easier to read because the test cases are very visible.</p><p>On the other hand, tests for the handlers have to follow the testing conventions for the Falcon library, so they will be a bit different. This is, of course, ideal since it allows me to show you even more.</p><p>Due to the limited amount of pages I have left, I'll show you only a part of the tests, so make sure you check them out in full in the source code.</p><div class="section" title="Testing the helpers"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec56"/>Testing the helpers</h3></div></div></div><p>Let's see<a id="id891" class="indexterm"/> the tests for the <code class="literal">PasswordGenerator</code> class:</p><p>
<code class="literal">tests/test_core/test_passwords.py</code>
</p><div class="informalexample"><pre class="programlisting">class PasswordGeneratorTestCase(TestCase):

    def test__generate_password_length(self):
        for length in range(300):
            assert_equal(
                length,
                len(PasswordGenerator._generate_password(length))
            )

    def test__generate_password_validity(self):
        for length in range(1, 300):
            password = PasswordGenerator._generate_password(
                length)
            assert_true(PasswordValidator(password).is_valid())

    def test__generate_candidate(self):
        score, password = (
            PasswordGenerator._generate_candidate(42))
        expected_score = PasswordValidator(password).score()
        assert_equal(expected_score['total'], score)

    @patch.object(PasswordGenerator, '_generate_candidate')
    def test__generate(self, _generate_candidate_mock):
        # checks `generate` returns the highest score candidate
        _generate_candidate_mock.side_effect = [
            (16, '&amp;a69Ly+0H4jZ'),
            (17, 'UXaF4stRfdlh'),
            (21, 'aB4Ge_KdTgwR'),  # the winner
            (12, 'IRLT*XEfcglm'),
            (16, '$P92-WZ5+DnG'),
            (18, 'Xi#36jcKA_qQ'),
            (19, '?p9avQzRMIK0'),
            (17, '4@sY&amp;bQ9*H!+'),
            (12, 'Cx-QAYXG_Ejq'),
            (18, 'C)RAV(HP7j9n'),
        ]
        assert_equal(
            (21, 'aB4Ge_KdTgwR'), PasswordGenerator.generate(12))</pre></div><p>Within <code class="literal">test__generate_password_length</code> we make sure the <code class="literal">_generate_password</code> method <a id="id892" class="indexterm"/>handles the length parameter correctly. We generate a password for each length in the range [0, 300), and verify that it has the correct length.</p><p>In the <code class="literal">test__generate_password_validity</code> test, we do something similar but, this time, we make sure that whatever length we ask for, the generated password is valid. We use the <code class="literal">PasswordValidator</code> class to check for validity.</p><p>Finally, we need to test the <code class="literal">generate</code> method. The password generation is random, therefore, in order to test this function, we need to mock <code class="literal">_generate_candidate</code>, thus controlling its output. We set the <code class="literal">side_effect</code> argument on its mock to be a list of 10 candidates, from which we expect the <code class="literal">generate</code> method to choose the one with the highest score. Setting <code class="literal">side_effect</code> on a mock to a list causes that mock to return the elements of that list, one at a time, each time it's called. To avoid ambiguity, the highest score is 21, and only one candidate has scored that high. We call the method and make sure that that particular one is the candidate which is returned.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note72"/>Note</h3><p>If you are wondering why I used those double underscores in the test names, it's very simple: the first one is a separator and the second one is the leading underscore that is part of the name of the method under test.</p></div></div><p>Testing the <code class="literal">PasswordValidator</code> class requires many more lines of code, so I'll show only a <a id="id893" class="indexterm"/>portion of these tests:</p><p>
<code class="literal">pwdapi/tests/test_core/test_passwords.py</code>
</p><div class="informalexample"><pre class="programlisting">from unittest import TestCase
from unittest.mock import patch
from nose_parameterized import parameterized, param
from nose.tools import (
    assert_equal, assert_dict_equal, assert_true)
from core.passwords import PasswordValidator, PasswordGenerator

class PasswordValidatorTestCase(TestCase):

    @parameterized.expand([
        (False, ''),
        (False, '  '),
        (True, 'abcdefghijklmnopqrstuvwxyz'),
        (True, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'),
        (True, '0123456789'),
        (True, '!#$%&amp;()*+-?@_|'),
    ])
    def test_is_valid(self, valid, password):
        validator = PasswordValidator(password)
        assert_equal(valid, validator.is_valid())</pre></div><p>We start by testing the <code class="literal">is_valid</code> method. We test whether or not it returns <code class="literal">False</code> when it's fed an empty string, as well as a string made up of only spaces, which makes sure we're testing whether we're calling <code class="literal">.strip()</code> when we assign the password.</p><p>Then, we use all the characters that we want to be accepted to make sure the function accepts them.</p><p>I understand the syntax behind the <code class="literal">parameterize.expand</code> decorator can be challenging at first but really, all there is to it is that each tuple consists of an independent test case which, in turn, means that the <code class="literal">test_is_valid</code> test is run individually for each tuple, and that the two tuple elements are passed to the method as arguments: <code class="literal">valid</code> and <code class="literal">password</code>.</p><p>We then test for invalid characters. We expect them all to fail so we use <code class="literal">param.explicit</code>, which runs the test for each of the characters in that weird string.</p><div class="informalexample"><pre class="programlisting">    @parameterized.expand(
        param.explicit(char) for char in '&gt;]{&lt;`\\;,[^/"\'~:}=.'
    )
    def test_is_valid_invalid_chars(self, password):
        validator = PasswordValidator(password)
        assert_equal(False, validator.is_valid())</pre></div><p>They all evaluate to <code class="literal">False</code>, so we're good.</p><div class="informalexample"><pre class="programlisting">    @parameterized.expand([
        (0, ''),  # 0-3: score 0
        (0, 'a'),  # 0-3: score 0
        (0, 'aa'),  # 0-3: score 0
        (0, 'aaa'),  # 0-3: score 0
        (1, 'aaab'),  # 4-7: score 1
        ...
        (5, 'aaabbbbccccddd'),  # 12-15: score 5
        (5, 'aaabbbbccccdddd'),  # 12-15: score 5
    ])
    def test__score_length(self, score, password):
        validator = PasswordValidator(password)
        assert_equal(score, validator._score_length())</pre></div><p>To <a id="id894" class="indexterm"/>test the <code class="literal">_score_length</code> method, I created 16 test cases for the lengths from 0 to 15. The body of the test simply makes sure that the score is assigned appropriately.</p><div class="informalexample"><pre class="programlisting">    def test__score_length_sixteen_plus(self):
        # all password whose length is 16+ score 7 points
        password = 'x' * 255
        for length in range(16, len(password)):
            validator = PasswordValidator(password[:length])
            assert_equal(7, validator._score_length())</pre></div><p>The preceding test is for lengths from 16 to 254. We only need to make sure that any length after 15 gets 7 as a score.</p><p>I will skip over the tests for the other internal methods and jump directly to the one for the score method. In order to test it, I want to control exactly what is returned by each of the <code class="literal">_score_*</code> methods so I mock them out and in the test, I set a return value for each of them. Note that to mock methods of a class, we use a variant of <code class="literal">patch</code>: <code class="literal">patch.object</code>. When you set return values on mocks, it's never good to have repetitions because you may not be sure which method returned what, and the test wouldn't fail in the case of a swap. So, always return different values. In my case, I am using the first few prime numbers to be sure there is no possibility of confusion.</p><div class="informalexample"><pre class="programlisting">    @patch.object(PasswordValidator, '_score_length')
    @patch.object(PasswordValidator, '_score_case')
    @patch.object(PasswordValidator, '_score_numbers')
    @patch.object(PasswordValidator, '_score_special')
    @patch.object(PasswordValidator, '_score_ratio')
    def test_score(
            self,
            _score_ratio_mock,
            _score_special_mock,
            _score_numbers_mock,
            _score_case_mock,
            _score_length_mock):

        _score_ratio_mock.return_value = 2
        _score_special_mock.return_value = 3
        _score_numbers_mock.return_value = 5
        _score_case_mock.return_value = 7
        _score_length_mock.return_value = 11

        expected_result = {
            'length': 11,
            'case': 7,
            'numbers': 5,
            'special': 3,
            'ratio': 2,
            'total': 28,
        }

        validator = PasswordValidator('')
        assert_dict_equal(expected_result, validator.score())</pre></div><p>I want to <a id="id895" class="indexterm"/>point out explicitly that the <code class="literal">_score_*</code> methods are mocked, so I set up my <code class="literal">validator</code> instance by passing an empty string to the class constructor. This makes it even more evident to the reader that the internals of the class have been mocked out. Then, I just check if the result is the same as what I was expecting.</p><p>This last test is the only one in this class in which I used mocks. All the other tests for the <code class="literal">_score_*</code> methods are in an interface style, which reads better and usually produces better results.</p></div><div class="section" title="Testing the handlers"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec57"/>Testing the handlers</h3></div></div></div><p>Let's<a id="id896" class="indexterm"/> briefly see one example of a test for a handler:</p><p>
<code class="literal">pwdapi/tests/test_core/test_handlers.py</code>
</p><div class="informalexample"><pre class="programlisting">import json
from unittest.mock import patch
from nose.tools import assert_dict_equal, assert_equal
import falcon
import falcon.testing as testing
from core.handlers import (
    PasswordValidatorHandler, PasswordGeneratorHandler)

class PGHTest(PasswordGeneratorHandler):
    def process_request(self, req, resp):
        self.req, self.resp = req, resp
        return super(PGHTest, self).process_request(req, resp)

class PVHTest(PasswordValidatorHandler):
    def process_request(self, req, resp):
        self.req, self.resp = req, resp
        return super(PVHTest, self).process_request(req, resp)</pre></div><p>Because<a id="id897" class="indexterm"/> of the tools Falcon gives you to test your handlers, I created a child for each of the classes I wanted to test. The only thing I changed (by overriding a method) is that in the <code class="literal">process_request</code> method, which is called by both classes, before processing the request I make sure I set the <code class="literal">req</code> and <code class="literal">resp</code> arguments on the instance. The normal behavior of the <code class="literal">process_request</code> method is thus not altered in any other way. By doing this, whatever happens over the course of the test, I'll be able to check against those objects.</p><p>It's quite common to use tricks like this when testing. We never change the code to adapt for a test, it would be bad practice. We find a way of adapting our tests to suit our needs.</p><div class="informalexample"><pre class="programlisting">class TestPasswordValidatorHandler(testing.TestBase):

    def before(self):
        self.resource = PVHTest()
        self.api.add_route('/password/validate/', self.resource)</pre></div><p>The <code class="literal">before</code> method is called by the Falcon <code class="literal">TestBase</code> logic, and it allows us to set up the resource we want to test (the handler) and a route for it (which is not necessarily the same as the one we use in production).</p><div class="informalexample"><pre class="programlisting">    def test_post(self):
        self.simulate_request(
            '/password/validate/',
            body=json.dumps({'password': 'abcABC0123#&amp;'}),
            method='POST')
        resp = self.resource.resp

        assert_equal('200 OK', resp.status)
        assert_dict_equal(
            {'password': 'abcABC0123#&amp;',
             'score': {'case': 3, 'length': 5, 'numbers': 2,
                'special': 4, 'ratio': 2, 'total': 16},
             'valid': True},
             json.loads(resp.body))</pre></div><p>This is the test for the happy path. All it does is simulate a <code class="literal">POST</code> request with a JSON payload as body. Then, we inspect the response object. In particular, we inspect its status and its body. We <a id="id898" class="indexterm"/>make sure that the handler has correctly called the validator and returned its results.</p><p>We also test the generator handler:</p><div class="informalexample"><pre class="programlisting">class TestPasswordGeneratorHandler(testing.TestBase):

    def before(self):
        self.resource = PGHTest()
        self.api.add_route('/password/generate/', self.resource)

    @patch('core.handlers.PasswordGenerator')
    def test_get(self, PasswordGenerator):
        PasswordGenerator.generate.return_value = (7, 'abc123')
        self.simulate_request(
            '/password/generate/',
            query_string='length=7',
            method='GET')
        resp = self.resource.resp

        assert_equal('200 OK', resp.status)
        assert_equal([7, 'abc123'], json.loads(resp.body))</pre></div><p>For this one as well, I will only show you the test for the happy path. We mock out the <code class="literal">PasswordGenerator</code> class because we need to control which password it will generate and, unless we mock, we won't be able to do it, as it is a random process.</p><p>Once we have correctly set up its return value, we can simulate the request again. In this case, it's a <code class="literal">GET</code> request, with a desired length of 7. We use a technique similar to the one we used for the other handler, and check the response status and body.</p><p>These are not the only tests you could write against the API, and the style could be different as well. Some people mock often, I tend to mock only when I really have to. Just try to see if you can make some sense out of them. I know they're not really easy but they'll be good training for you. Tests are extremely important so give it your best shot.</p></div></div></div>
<div class="section" title="Where do you go from here?"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec89"/>Where do you go from here?</h1></div></div></div><p>If you liked this project and you feel like expanding it, here are a few suggestions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Implement the encryption in the mechanism of a custom Django field.</li><li class="listitem" style="list-style-type: disc">Amend the template for the record list so that you can search for a particular record.</li><li class="listitem" style="list-style-type: disc">Amend the JavaScript to use JSONP with a callback to overcome the CORS issue.</li><li class="listitem" style="list-style-type: disc">Amend the JavaScript to fire the validation call when the password field changes.</li><li class="listitem" style="list-style-type: disc">Write a Django command that allows you to encrypt and decrypt the database file. When you do it from the command line, incorporate that behavior into the website, possibly on the home page, so that you don't have access to the records unless you are authenticated. This is definitely a hard challenge as it requires either another database with an authentication password stored properly with a one way hash, or some serious reworking of the data structure used to hold the record model data. Even if you don't have the means to do it now, try and think about how you would solve this problem.</li><li class="listitem" style="list-style-type: disc">Set up PostgreSQL on your machine and switch to using it instead of the SQLite file that is the default.</li><li class="listitem" style="list-style-type: disc">Add the ability to attach a file to a record.</li><li class="listitem" style="list-style-type: disc">Play with the application, try to find out which features you want to add or change, and then do it.</li></ul></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec90"/>Summary</h1></div></div></div><p>In this chapter, we've worked on a final project that involves an interface and an API. We have used two different frameworks to accomplish our goal: Django and Falcon. They are very different and have allowed us to explore different concepts and techniques to craft our software and make this fun application come alive.</p><p>We have seen an example of symmetric encryption and explored code that was written in a more functional style, as opposed to a more classic control flow-oriented approach. We have reused and extended the Django class-based views, reducing to a minimum the amount of code we had to write.</p><p>When coding the API, we decoupled handling requests from password management. This way it's much easier to see which part of the code depends on the Falcon framework and which is independent from it.</p><p>Finally, we saw a few tests for the helpers and handlers of the API. We have briefly touched on a technique that I use to expand classes under test in order to be able to test against those parts of the code which would not normally be available.</p><p>My aim in this chapter was to provide you with an interesting example that could be expanded and improved in different ways. I also wanted to give you a few examples of different coding styles and techniques, which is why I chose to spread things apart and use different frameworks.</p></div>
<div class="section" title="A word of farewell"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec91"/>A word of farewell</h1></div></div></div><p>I hope that you are still thirsty and that this book will be just the first of many steps you take towards Python. It's a truly wonderful language, well worth learning deeply.</p><p>I hope that you enjoyed this journey with me, I did my best to make it interesting for you. It sure was for me, I had such a great time writing these pages.</p><p>Python is open source, so please keep sharing it and consider supporting the wonderful community around it.</p><p>Till next time, my friend, farewell!</p></div></body></html>