<html><head></head><body>
<div><div><div><h1 id="_idParaDest-128" class="contributor"><a id="_idTextAnchor137" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/><a id="_idTextAnchor138" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>8</h1>
			<h1 id="_idParaDest-129" class="contributor"><a id="_idTextAnchor139" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Building the Frontend of the Application</h1>
			<p class="calibre5">In the previous chapter, you explored how to build your FastAPI backend and connect to MongoDB. This will be used by a React frontend that you will be building in this chapter. The application will be simple and feature-rich and, most importantly, will allow you to see the parts of the stack working together.</p>
			<p class="calibre5">In this chapter, you will build the frontend of a full-stack FARM application. You will learn how to set up a React Vite application and install and set up React Router, as well as various ways of loading content. The application will enable authenticated users to insert new items (cars), while there will be several pages for displaying cars.</p>
			<p class="calibre5">You will develop a website that will list used cars for sale and allow only logged-in users to post new car ads. You will begin by creating a React application with Vite, then you will lay out the page structure with React Router and gradually introduce features such as authentication, protected pages, and data loading. After this chapter, you will be able to comfortably leverage React Router for your <strong class="bold">single-page-applications</strong> (<strong class="bold">SPAs</strong>) and use the powerful <strong class="bold">React Hook Form</strong> (<strong class="bold">RHF</strong>) for granular form control.</p>
			<p class="calibre5">This chapter will cover the following topics:</p>
			<ul class="calibre14">
				<li class="calibre17">Creating a new React application using Vite</li>
				<li class="calibre17">Setting up the React Router for SPA page navigation</li>
				<li class="calibre17">Managing data with data loaders</li>
				<li class="calibre17">Introduction to RHF and Zod for data validation</li>
				<li class="calibre17">Authentication and authorization with the Context API</li>
				<li class="calibre17">Protecting routes and displaying data with React Router pages</li>
			</ul>
			<h1 id="_idParaDest-130" class="contributor"><a id="_idTextAnchor140" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Technical requirements</h1>
			<p class="calibre5">The technical requirements for this chapter are similar to the ones listed in <a href="B22406_04.xhtml#_idTextAnchor071" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic">Chapter 4</em></a><em class="italic">, Getting Started with FastAPI</em>. You will need the following:</p>
			<ul class="calibre14">
				<li class="calibre17">Node version 18.14</li>
				<li class="calibre17">A good code editor, such as Visual Studio Code</li>
				<li class="calibre17">The Node package manager</li>
			</ul>
			<h1 id="_idParaDest-131" class="contributor"><a id="_idTextAnchor141" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Creating a Vite React application</h1>
			<p class="calibre5">In this section you will scaffold a Vite React application and set up Tailwind CSS for styling. This procedure has already been covered in <a href="B22406_05.xhtml#_idTextAnchor090" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic" lang="en-US" xml:lang="en-US">Chapter 5</em></a>,<em class="italic" lang="en-US" xml:lang="en-US"> Setting Up a React workflow,</em>, so you can refer to it. Make sure to complete the brief tutorial in <a href="B22406_05.xhtml#_idTextAnchor090" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic">Chapter 5</em></a>, as the following guide is heavily based on the concepts presented therein.</p>
			<p class="calibre5">You are going to use the <code>create vite</code> command with the Node package manager to create your project through the following steps:</p>
			<ol class="calibre14">
				<li class="calibre15">Open your terminal client in a project directory containing the previously created backend folder, and issue the following command for creating a Vite React project:<pre class="source-code">
npm create vite@latest frontend-app -- --template react</pre></li>				<li class="calibre15">Now, change the directory to the newly created <code>frontend-app</code> folder and install the dependencies and Tailwind:<pre class="source-code">
npm install -D tailwindcss postcss autoprefixer</pre></li>				<li class="calibre15">Initialize the Tailwind configuration—the following command creates a blank Tailwind configuration file:<pre class="source-code">
npx tailwindcss init -p</pre></li>				<li class="calibre15">Finally, configure the generated <code>tailwind.config.js</code> and React’s <code>index.css</code> files according to the latest documentation at <a href="https://tailwindcss.com/docs/guides/vite" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://tailwindcss.com/docs/guides/vite</a>.</li>
			</ol>
			<p class="calibre5">Your index.css should now include only the Tailwind imports:</p>
			<pre class="source-code">
@tailwind base;
@tailwind components;
@tailwind utilities;</pre>			<p class="calibre5">To test that Tailwind has been properly configured, change the <code>App.jsx</code> file and start the development server:</p>
			<pre class="source-code">
export default function App() {
  return ( &lt;
    h1 className = “text-3xl font-bold” &gt;
    Cars FARM &lt;
    /h1&gt;
  )
}</pre>			<p class="calibre5">When you refresh your app, you should see a white page with the text <strong class="bold">Cars FARM</strong>. </p>
			<p class="calibre5">After setting up a functional React application and Tailwind, it is time to introduce probably the most important third-party React package—React Router.</p>
			<h2 id="_idParaDest-132" class="about-the-author"><a id="_idTextAnchor142" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>React Router</h2>
			<p class="calibre5">Up to this point, all of your components have fit onto a single page because you were building SPAs. To enable your application to display completely different pages based on the provided route, you will use a package called React Router—the de facto standard when it comes to page routing in React. </p>
			<p class="calibre5">While there are some very good and robust alternatives, such as TanStack Router (<a href="https://tanstack.com/router/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://tanstack.com/router/</a>), React Router is widely adopted, and getting to know its basic mechanisms will greatly benefit you, as a developer, as you are bound to run into code based on it.</p>
			<p class="calibre5">Version 6.4 of React Router has some major changes while retaining previous basic principles, which you will use to build your frontend. However, as of May 2024, even more drastic changes have been announced—<strong class="bold">React Remix</strong>, an entire full-stack framework (with functionalities comparable to Next.js), which is based on React Router, and React Router itself should be merged into a single project. In this section, you will learn about the most important components that will allow you to create a single-page experience without page reloading or having knowledge of React Router 6.4, which will be very useful later, as it is the most widely adopted React routing solution.</p>
			<p class="calibre5">The basic underlying principle of React Router is to listen to URL path changes (such as <code>/about</code> or <code>/login</code>) and conditionally display components in a layout. The displayed components can be thought of as “pages,” while the layout keeps some parts of the pages that should always be displayed—such as a footer and navigation.</p>
			<p class="calibre5">Before looking at React Router, review the pages that you will have in your application:</p>
			<ul class="calibre14">
				<li class="calibre17"><code>/</code>) path</li>
				<li class="calibre17"><code>/cars</code>)</li>
				<li class="calibre17"><code>/cars/car_id</code>)</li>
				<li class="calibre17"><code>/login</code>)</li>
				<li class="calibre17"><strong class="bold">An “insert new car” page</strong>: This will provide a form for the authenticated user only</li>
			</ul>
			<p class="calibre5">For simplicity, you will not include a registration route (since there will only be a couple of authenticated employees) and there will not be a deleting or updating functionality on the frontend. In the following section, you will install and configure React Router and make it the basis of your application.</p>
			<h2 id="_idParaDest-133" class="about-the-author"><a id="_idTextAnchor143" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Installing and setting up React Router</h2>
			<p class="calibre5">React Router is just a Node.js package, so the installation process is easy. The setting up of the router inside the application, however, includes lots of features and different options. You will be using the most powerful and recommended data router, which provides data loading and is the suggested option by the React Router team.</p>
			<p class="calibre5">Working with the router generally involves two steps:</p>
			<ol class="calibre14">
				<li class="calibre15">Using one of the provided methods for generating the desired routes (<a href="https://reactrouter.com/en/main/routers/picking-a-router" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://reactrouter.com/en/main/routers/picking-a-router</a>).</li>
				<li class="calibre15">Creating components, often called <code>Login.jsx</code> and <code>Home.jsx</code>. Additionally, you will almost always create one or more layouts that will contain common components such as the navigation or the footer. </li>
			</ol>
			<p class="calibre5">Now, you will perform the steps necessary to install React Router into your application:</p>
			<ol class="calibre14">
				<li class="calibre15">The first step, as with any third-party package, is to install the <code>router</code> package:<pre class="source-code">
npm i react-router-dom@6.23.1</pre><p class="list-inset">The version number corresponds to the latest version at the time of writing, so you can reproduce the exact functionality.</p><p class="list-inset">In this chapter, the CSS styling of the application will intentionally be kept to a bare minimum—just enough to distinguish between components.</p></li>				<li class="calibre15">Start by creating a new directory called <code>/pages</code> inside the <code>/src</code> folder and scaffolding all your pages. The page names will be <code>Home</code>, <code>Cars</code>, <code>Login</code>, <code>NewCar</code>, <code>NotFound</code>, and <code>SingleCar</code>, all with the <code>.jsx</code> extensions and you will perform the scaffolding of these other pages the same way as the <code>Home.jsx</code> page.<p class="list-inset">The first component, located at <code>/src/pages/Home.jsx</code>, will look like this:</p><pre class="source-code">
const Home = () =&gt; {
    return (
        &lt;div&gt;Home&lt;/div&gt;
    )
}
export default Home</pre><p class="list-inset">Although they are often referred to as pages when speaking about React Router, these pages are nothing more than regular React components. The distinction, and the fact that they are often grouped together in a directory called <code>pages</code>, is based purely on the fact that these components correspond to the pages structure of a SPA and are generally not meant to be reused elsewhere.</p></li>				<li class="calibre15">After scaffolding the desired pages, implement the router. This procedure consists of creating the router and inserting it into a top-level React component. You will use the <code>App.jsx</code> component, which loads and inserts the entire React application in the DOM.</li>
			</ol>
			<p class="calibre5">Since version 6.4, React Router has introduced the possibility of fetching data before the route (or page) that needs the said data is loaded, through simple functions called <code>createBrowserRouter</code> (<a href="https://reactrouter.com/en/main/routers/create-browser-router" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://reactrouter.com/en/main/routers/create-browser-router</a>) since it is <em class="italic">the recommended router for all React Router web projects</em>, as stated in the documentation.</p>
			<p class="calibre5">After selecting <code>createBrowserRouter</code> as the desired method of creating the router, it is time to integrate it into your application.</p>
			<h3 class="calibre8">Integrating the router with the application</h3>
			<p class="calibre5">In the following steps, you will integrate the router into your application, create a <code>Layout</code> component, and plug in the components (pages) that will be loaded on each defined URI:</p>
			<ol class="calibre14">
				<li class="calibre15">To properly configure the router, you will need another component—the <code>Layout</code> component—in which the previously created pages will be rendered. Inside the <code>/src</code> folder, create a <code>/layouts</code> folder and create a <code>RootLayout.jsx</code> file inside it:<pre class="source-code">
const RootLayout = () =&gt; {
  return (
    &lt;div&gt;RootLayout&lt;/div&gt;
  )
}
export default RootLayout</pre><p class="list-inset">The React router that you will be using and the one that supports data loading is based on three imports from the <code>react-router-dom</code> package: <code>createBrowserRouter</code>, <code>createRoutesFromElements</code>, and <code>Route</code>. </p></li>				<li class="calibre15">Open the <code>App.jsx</code> file and import the packages and the previously created pages:<pre class="source-code">
import {
  createBrowserRouter,
  Route,
  createRoutesFromElements,
  RouterProvider
} from “react-router-dom”
import RootLayout from “./layouts/RootLayout”
import Cars from “./pages/Cars”
import Home from “./pages/Home”
import Login from “./pages/Login”
import NewCar from “./pages/NewCar”
import SingleCar from “./pages/SingleCar”</pre></li>				<li class="calibre15">Now, continuing with the same <code>App.jsx</code> file, hook up the router created from the elements that you just imported and defined:<pre class="source-code">
const router = createBrowserRouter(
  createRoutesFromElements(
    &lt;Route path=”/” element={&lt;RootLayout /&gt;}&gt;
      &lt;Route index element={&lt;Home /&gt;} /&gt;
      &lt;Route path=”cars” element={&lt;Cars /&gt;} /&gt;
      &lt;Route path=”login” element={&lt;Login /&gt;} /&gt;
      &lt;Route path=”new-car” element={&lt;NewCar /&gt;} /&gt;
      &lt;Route path=”cars/:id” element={&lt;SingleCar /&gt;} /&gt;
    &lt;/Route&gt;
  )
)
export default function App() {
  return (
    &lt;RouterProvider router={router} /&gt;
  )
}</pre></li>			</ol>
			<p class="calibre5">There are a few important things to note in the preceding code. After creating the router, you invoked the React Router function called <code>createRoutesFromElements</code>, which creates the actual routes. A route is used to define an individual path that corresponds and maps to a component; it can be a self-closing tag (such as the ones used for the pages) or it can enclose other routes—such as the home page path, which in turn corresponds to <code>RootLayout</code>.</p>
			<p class="calibre5">If you start the React server again and visit the page <code>http://localhost:5173</code>, you will see only the text <code>RootLayout</code>. Try navigating to any of the routes defined in the router: <code>/cars</code>, <code>/cars/333</code>, or <code>/login</code>. You will see the same <code>RootLayout</code> text, but if you enter a path that is not defined, such as <code>/about</code>, React will inform you that the page doesn’t exist with a message similar to this: <code>Unexpected Application Error! 404 </code><code>Not Found</code>.</p>
			<p class="calibre5">This means that the router is indeed working; it is not set up to handle cases in which the user navigates to an undefined route and it does not display the contents of the pages. Now you will fix both problems. </p>
			<h3 class="calibre8">Creating the layout and the NotFound page</h3>
			<p class="calibre5">In order to work properly, the router needs a place to display the content of pages— remember that “pages” are just React components. Now you will create <code>Layout.jsx</code> and also handle cases in which a user hits a URI that doesn’t exist, resulting in a <code>Page Not </code><code>Found</code> error:</p>
			<ol class="calibre14">
				<li class="calibre15">First, create a new page in the <code>/src/pages</code> directory and name it <code>NotFound.jsx</code>, with the following content:<pre class="source-code">
const NotFound = () =&gt; {
  return (
    &lt;div&gt;This page does not exist yet!&lt;/div&gt;
  )
}
export default NotFound</pre><p class="list-inset">Now, create a catch-all route that will display the <em class="italic" lang="en-US" xml:lang="en-US">Not Found</em> page in cases where the path doesn’t match any defined route. Remember that the order of routes is important—React Router will attempt to match routes sequentially, so it makes sense to use the <code>*</code> symbol to catch all previously undefined routes and associate them with the <code>NotFound</code> component. </p></li>				<li class="calibre15">Update the <code>App.jsx</code> file to display the <code>NotFound</code> route as the last route in the <code>RootLayout</code> route:<pre class="source-code">
  createRoutesFromElements(
    &lt;Route path=”/” element={&lt;RootLayout /&gt;}&gt;
      &lt;Route index element={&lt;Home /&gt;} /&gt;
	// more routes here…
      <strong class="bold" lang="en-US" xml:lang="en-US">&lt;Route path=”*” element={&lt;NotFound /&gt;} /&gt;</strong>
    &lt;/Route&gt;
  )
&lt;Route path=”/” element={&lt;RootLayout /&gt;}&gt;</pre><p class="list-inset">All the other pages are nested. You will need to modify <code>RootLayout</code> (which will always be loaded, even for non-existing routes!) and provide the <code>Outlet</code> component for rendering page-specific components. </pre></li>				<li class="calibre15">Open <code>RootLayout.jsx</code> and modify it:<pre class="source-code">
import { Outlet } from “react-router-dom”
const RootLayout = () =&gt; {
    return (
        &lt;div className=” bg-blue-200 min-h-screen p-2”&gt;
            &lt;h2&gt;RootLayout&lt;/h2&gt;
            &lt;main className=”p-8 flex flex-col flex-1 bg-white “&gt;
<strong class="bold">                &lt;Outlet /&gt;</strong>
            &lt;/main&gt;
        &lt;/div&gt;
    )
}
export default RootLayout</pre><p class="list-inset">With the <code>Outlet</code> component now in place, you have achieved routing. If you try to navigate to the pages defined in the router, you should see the page update with the component content, in which the layout is displayed as before, but the <code>Outlet</code> component changes and displays the content of the page selected in the URL.</p><p class="list-inset">The whole point of using the router is to achieve navigation through “pages” without having to reload the page. </p></li>				<li class="calibre15">Now, to finalize the <code>RootLayout</code> component, you will update the component and add some links, using the provided <code>NavLink</code> component from React Router:<pre class="source-code">
import {
  Outlet,
  NavLink
} from “react-router-dom”
const RootLayout = () =&gt; {
  return (
    &lt;div className=” bg-blue-200 min-h-screen p-2”&gt;
      &lt;h2&gt;RootLayout&lt;/h2&gt;
      &lt;header className=”p-8 w-full”&gt;
        &lt;nav className=”flex flex-row 
          justify-between”&gt;
          &lt;div className=”flex flex-row space-x-3”&gt;
            &lt;NavLink to=”/”&gt;Home&lt;/NavLink&gt;
            &lt;NavLink to=”/cars”&gt;Cars&lt;/NavLink&gt;
            &lt;NavLink to=”/login”&gt;Login&lt;/NavLink&gt;
            &lt;NavLink to=”/new-car”&gt;New Car&lt;/NavLink&gt;
          &lt;/div&gt;
        &lt;/nav&gt;
      &lt;/header&gt;
      &lt;main className=”p-8 flex flex-col flex-1
        bg-white “&gt;
        &lt;Outlet /&gt;
     &lt;/main&gt;
   &lt;/div&gt;
  )
}
export default RootLayout</pre></li>			</ol>
			<p class="calibre5">Now you have a simple navigation in place and the <code>NotFound</code> page loads when needed. The router also provides navigation history, so the browser’s back and forward buttons are functional. The app styling is intentionally minimalistic and used only to underline the different components.</p>
			<p class="calibre5">So far, you have only one layout, but there could potentially be more—one for the cars list page and the individual car pages—embedded into the main layout. Just like APIRouters from FastAPI, React routes and layouts can be nested. React Router’s nesting is a powerful feature that enables the construction of layered websites that load or update only the necessary components.</p>
			<p class="calibre5">After having set up the React Router, let’s explore an important feature that is available only when using data routers, such as the one you used—data loaders—special functions that allow developers to access data in a more efficient way.</p>
			<h2 id="_idParaDest-134" class="about-the-author"><a id="_idTextAnchor144" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>React Router loaders</h2>
			<p class="calibre5">Loaders are simply functions that can provide data to the route before it loads (<a href="https://reactrouter.com/en/main/route/loader" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://reactrouter.com/en/main/route/loader</a>) through a simple React hook. </p>
			<p class="calibre5">In order to use some data, first create a new <code>.env</code> file and add the address of your Python backend:</p>
			<pre class="source-code">
VITE_API_URL=http://127.0.0.1:8000</pre>			<p class="calibre5">If you restart the server now, Vite will be able to pick up the address in your code and the URI will be available at <code>import.meta.env.VITE_API_URL</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To learn more about how Vite handles environment variables, head over to their documentation: <a href="https://vitejs.dev/guide/env-and-mode" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://vitejs.dev/guide/env-and-mode</a>. </p>
			<p class="calibre5">Now you will learn how React Router manages data loading and prefetching. Perform the following steps to load data from your backend into the React application and learn how to use the powerful and simple <code>useLoader</code> Hook. </p>
			<p class="calibre5">First, work on the <code>/src/pages/Cars.jsx</code> component to see how data loaders can help you manage component data: </p>
			<ol class="calibre14">
				<li class="calibre15">Create a <code>src/components</code> folder and inside, create a simple static React component in the <code>CarCard.jsx</code> file for displaying a single car:<pre class="source-code">
const CarCard = ({ car }) =&gt; {
  return (
    &lt;div className=”flex flex-col p-3 text-black 
      bg-white rounded-xl overflow-hidden shadow-md
      hover:scale-105 transition-transform
      duration-200”&gt;
      &lt;div&gt;{car.brand} {car.make} {car.year} {car.cm3}
        {car.price} {car.km}
      &lt;/div&gt;
      &lt;img src={car.picture_url} alt={car.make}
        className=”w-full h-64 object-cover
        object-center” /&gt;
    &lt;/div&gt;
  )
}
export default CarCard</pre><p class="list-inset">With the <code>Card</code> component out of the way, you can now see how the data loader works. </p><p class="list-inset">Loaders are functions that provide data to the components in the router before they are rendered. These functions are usually defined and exported from the same component, although this is not mandatory. </p></li>				<li class="calibre15">Open <code>Cars.jsx</code> and update it accordingly:<pre class="source-code">
import { useLoaderData } from “react-router-dom”
import CarCard from “../components/CarCard”
const Cars = () =&gt; {
  const cars = useLoaderData()
  return (
    &lt;div&gt;
      &lt;h1&gt;Available cars&lt;/h1&gt;
      &lt;div className=”md:grid md:grid-cols-3 sm:grid
        sm:grid-cols-2 gap-5”&gt;
        {cars.map(car =&gt; (
          &lt;CarCard key={car.id} car={car} /&gt;
        ))}
      &lt;/div&gt;
    &lt;/div&gt;
  )
}
export default Cars</pre><p class="list-inset">The component imports <code>useLoaderData</code>—a custom hook provided by React Router whose sole purpose is to provide the data from the loader function to the component that needs it. This paradigm is at the heart of React Remix and similar to some Next.js functionalities, so it is useful to get acquainted with. The <code>useLoader</code> function will contain the data from the server, usually in JSON format.</p></li>				<li class="calibre15">Now, export the <code>carsLoader</code> function as well in the same file:<pre class="source-code">
export const carsLoader = async () =&gt; {
  const res = await fetch(
    `${import.meta.env.VITE_API_URL}/cars?limit=30`
    )
  const response = await res.json()
  if (!res.ok){
    throw new Error(response.message)
  }
  return response[‘cars’]
}</pre></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">These two pieces—the component and the function—are not connected. This connection must happen in the router and allow preloading of data at the router level. </p>
			<ol class="calibre14">
				<li value="4" class="calibre15">Now you will connect the component and the loader through the router. Open the <code>App.jsx</code> file and modify the code by providing the loader argument to the <code>/</code><code>cars</code> route:<pre class="source-code">
import Cars, { carsLoader } from “./pages/Cars”
// continues
  &lt;Route path=”/” element={&lt;RootLayout /&gt;}&gt;
    &lt;Route index element={&lt;Home /&gt;} /&gt;
    &lt;Route path=”cars” element={&lt;Cars /&gt;}     
      <strong class="bold">loader={carsLoader}</strong> /&gt;
      &lt;Route path=”login” element={&lt;Login /&gt;} /&gt;
      &lt;Route path=”new-car” element={&lt;NewCar /&gt;} /&gt;
      &lt;Route path=”cars/:id” 
        element={&lt;SingleCar /&gt;} /&gt;
      &lt;Route path=”*” element={&lt;NotFound /&gt;} /&gt;
    &lt;/Route&gt;</pre></li>			</ol>
			<p class="calibre5">With the loader now in place, you are ready to test your <code>/cars</code> page, which should be displaying the cars saved in the collection so far.</p>
			<p class="calibre5">The next few sections will explore the implementation of another piece of functionality that you will likely encounter in every React (or Next.js, or web development in general) project—handling forms with React with RHF. You will implement the login functionality with the help of the most popular third-party package for handling forms with React, and also perform data validation with the Zod package.</p>
			<h1 id="_idParaDest-135" class="contributor"><a id="_idTextAnchor145" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>React Hook Form and Zod</h1>
			<p class="calibre5">There are many ways of handling forms with React, and one of the most common patterns was shown in <a href="B22406_05.xhtml#_idTextAnchor090" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic">Chapter 5</em></a>, <em class="italic">Setting Up a React Workflow</em>. State variables are created with the <code>useState</code> Hook, the form is prevented from submitting and is intercepted, and, finally, the data is passed through JSON or as form data. While this workflow is acceptable when working with simple data and a couple of fields, it can quickly become difficult to manage in cases where you have to keep track of dozens of fields, their constraints, and their possible states. </p>
			<p class="calibre5">RHF is a mature project with a thriving community and is distinguished from other similar libraries by its speed, minimal amount of rendering, and deep integration with the most popular data validation libraries for TypeScript and JavaScript, such as Zod and Yup. In this case, you will learn the basics of Zod.</p>
			<h2 id="_idParaDest-136" class="about-the-author"><a id="_idTextAnchor146" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Performing data validation with Zod</h2>
			<p class="calibre5">The JavaScript and TypeScript ecosystem currently has several validation libraries—with Zod and Yup arguably being the most popular ones. Zod is a TypeScript-first schema declaration and validation library that provides data validation of data structures. Zod provides a simple and intuitive object-based syntax for creating complex validation rules for objects and values in JavaScript applications and greatly facilitates the process of ensuring data integrity across the application. </p>
			<p class="calibre5">The basic idea of these packages is to provide them with a prototype of the desired data structure and to perform a validation of the data against said defined data structure:</p>
			<ol class="calibre14">
				<li class="calibre15">First, install the package:<pre class="source-code">
npm i react-hook-form@7.51.5</pre><p class="list-inset">Since the version number at the time of writing and used in the book’s repository is 7.51.5, use the preceding command if you want to reproduce the exact code from the repository.</p></li>				<li class="calibre15">Update the <code>Login.jsx</code> component and make it display <code>LoginForm</code>, which you will create shortly:<pre class="source-code">
import LoginForm from “../components/LoginForm”
const Login = () =&gt; {
  return (
  &lt;div&gt;
    &lt;h1&gt;Login&lt;/h1&gt;
    &lt;LoginForm /&gt;
  &lt;/div&gt;
  )
}
export default Login</pre></li>				<li class="calibre15">Now, the <code>/src/components/LoginForm.jsx</code> file will contain all the form functionality as well as the data validation with Zod:<pre class="source-code">
import { useForm } from “react-hook-form”
import { z } from ‘zod’;
import { zodResolver } from ‘@hookform/resolvers/zod’;
const schema = z.object({
  username: z.string().min(4, ‘Username must be at least 4 characters long’).max(10, ‘Username cannot exceed 10 characters’),
  password: z.string().min(4, ‘Password must be at least 4 characters long’).max(10, ‘Password cannot exceed 10 characters’),
});</pre><p class="list-inset">The component begins with the imports—the <code>useForm</code> hook and Zod, as well as the Zod resolver for integration with the form hook. Data validation in Zod is similar to how it is in Pydantic—you define an object and set the desired properties on various fields. In this case, we set that the username and password is between 4 and 10 characters long, but Zod allows for some very complex validation, as you can see on their website (<a href="https://zod.dev/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://zod.dev/</a>). </p><p class="list-inset">The <code>useForm</code> Hook provides several useful functions: </p><ul class="calibre19"><li class="calibre15"><code>register</code> is used to register single-form fields with the hook</li><li class="calibre15"><code>handleSubmit</code> is the function that will be called upon submission </li><li class="calibre15"><code>formState</code> contains different information about the form state (<a href="https://react-hook-form.com/docs/useform/formstate" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://react-hook-form.com/docs/useform/formstate</a>) </li></ul></li>				<li class="calibre15">Now, set up the <code>form</code> Hook:<pre class="source-code">
const LoginForm = () =&gt; {
  const { register, <strong class="bold">handleSubmit</strong>, 
    formState: { errors } } = useForm({
      resolver: zodResolver(schema),
    });
  const <strong class="bold">onSubmitForm</strong> = (data) =&gt; {
      console.log(data)
    }</pre><p class="list-inset">In this case, you will only track the errors (tied to the validation defined previously with Zod), but this object tracks much more. In your code, you’ll just output the data to the console once it is validated. </p></li>				<li class="calibre15">Now, build the form’s JSX and add some styling to see what’s happening:<pre class="source-code">
return (
  &lt;div className=”flex items-center justify-center”&gt;
    &lt;div className=”w-full max-w-xs”&gt;
    &lt;form className=”bg-white shadow-md rounded 
      px-8 pt-6 pb-8 mb-4”                      
      onSubmit={handleSubmit(<code>onSubmit</code> event is bound to the handle. This process is quite simple: the form has an <code>onSubmit</code> method that you handed over to the <code>handleSubmit</code> method of RHF. This <code>handleSubmit</code> method is destructured from the hook itself, along with the <code>register</code> function (for mapping input fields) and the errors that reside in the form state. After establishing the connection, the <code>handleSubmit</code> method needs to know which function should process the form and its data. In this case, it should pass the handling to the <code>onSubmitForm</code> function.</p><p class="list-inset">The two form fields, for the username and the password, are nearly identical:</p><pre class="source-code">&lt;div className=”mb-4”&gt;
  &lt;label htmlFor=”username” className=”block 
    text-gray-700 text-sm font-bold mb-2”&gt;
    Username
  &lt;/label&gt;
  &lt;input id=”username” type=”text”
    placeholder=”Username” required
<strong class="bold">    {...register(‘username’)}</strong>
    className=”shadow appearance-none border 
      rounded w-full py-2 px-3 text-gray-700
      leading-tight focus:outline-none
      focus:shadow-outline”/&gt;
      <strong class="bold">{errors.username &amp;&amp; &lt;p className=”text-red-500</strong>
<strong class="bold">      text-xs italic”&gt;{errors.username.message}</strong>&lt;/p&gt;}
&lt;/div&gt;</pre></li>			</ol>
			<p class="calibre5">The highlighted parts of the code are the registration of the fields with the <code>useForm</code> Hook—a way of letting the form know which fields to expect and the errors (if they are present) that are related to their respective fields.</p>
			<p class="calibre5">This way, the fields are registered to the hook form through this spread operator syntax. Since the errors provided by the form are bound to the fields, take this opportunity and show them next to the fields that report errors for a more pleasing user experience.</p>
			<p class="calibre5">The rest of the component is intuitive and covers the <code>password</code> field and the <code>submit</code> button:</p>
			<pre class="source-code">
&lt;div className=”mb-6”&gt;
  &lt;label htmlFor=”password” className=”block text-gray-700   
    text-sm font-bold mb-2”&gt;Password&lt;/label&gt;
  &lt;input id=”password” type=”password” placeholder=”****”
    required
    <strong class="bold">{...register(‘password’)}</strong>
    className=”shadow appearance-none border rounded w-full
    py-2 px-3 text-gray-700 mb-3 leading-tight
    focus:outline-none focus:shadow-outline” /&gt;
  <strong class="bold" lang="en-US" xml:lang="en-US">{errors.password &amp;&amp; &lt;p className=”text-red-500 text-xs</strong>
<strong class="bold">    italic”&gt;{errors.password.message}&lt;/p&gt;}</strong>
&lt;/div&gt;
&lt;div className=”flex items-center justify-between”&gt;
          &lt;button type=”submit”&gt;Sign In&lt;/button&gt;
        &lt;/div&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  )
}
export default LoginForm</pre>			<p class="calibre5">The complete code from the book is available in the book repository.</p>
			<p class="calibre5">The form is now ready and is handled completely by the hook form with a Zod validation. If you try to input data that doesn’t meet the validation criteria (username or password shorter than four characters, for instance) you will get an error message next to the fields. After setting up the form for logging in, you will create an authentication context that will allow the user to stay logged in. The authentication process—the creation of a React context and storing the JWT—will be very similar to the one covered in <a href="B22406_06.xhtml#_idTextAnchor105" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic">Chapter 6</em></a>, <em class="italic">Authentication and Authorization</em>, so this next section only covers and highlights the important parts of the code.</p>
			<h1 id="_idParaDest-137" class="contributor"><a id="_idTextAnchor147" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Authentication context and storing the JWT</h1>
			<p class="calibre5">In this section, you will use your brand-new form, powered by RHF, and connect it to the Context API. The procedure for defining a React Context API was covered in detail in <a href="B22406_04.xhtml#_idTextAnchor071" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Started with FastAPI</em> and in this chapter, you will apply that knowledge and create a similar context for keeping track of the authentication state of the application:</p>
			<ol class="calibre14">
				<li class="calibre15">Create a new folder in the <code>/src</code> directory and name it <code>contexts</code>. Inside this folder, create a new file called <code>AuthContext.jsx</code> and create the provider:<pre class="source-code">
import { createContext, useState, useEffect } from ‘react’;
import { Navigate } from ‘react-router-dom’;
export const AuthContext = createContext();
export const AuthProvider = ({ children }) =&gt; {
  const [user, setUser] = useState(null);
  const [jwt, setJwt] =  useState(localStorage.getItem('jwt')||null);
  const [message, setMessage] = useState(
    “Please log in”
  );</pre><p class="list-inset">The context that you are creating is rather simple and contains a couple of state variables and setters that will be needed for the authentication flow: the username (whose presence or absence thereof will indicate whether the user is authenticated), the JWT, and a helper message that, in this case, is only useful for debugging and illustration.</p><p class="list-inset">The initial values are set to <code>null</code> and a generic message through the <code>useState</code> hook—the username is set to <code>null</code>, the JWT to an empty string, and the message to <code>Please log in</code>. </p></li>				<li class="calibre15">Next, add a <code>useEffect</code> hook that will fire once the context is loaded or when the page is reloaded:<pre class="source-code">
useEffect(() =&gt; {
  const storedJwt = localStorage
    .getItem(‘jwt’);
  if(storedJwt) {
    setJwt(storedJwt);
    fetch(
      `${import.meta.env.VITE_API_URL}/users/me`, {
      headers: {
      Authorization: `Bearer ${storedJwt}`,
      },
        })
    .then(res =&gt; res.json())</pre><p class="list-inset">The first part of the <code>useEffect</code> hook checks whether there is a JWT present in the local storage. If it is present, the <code>useEffect</code> hook performs an API call to the FastAPI server to determine whether the JWT is able to return a valid user:</p><pre class="source-code">.then(data =&gt; {
  if(data.username) {
    setUser({user: data.username});
    setMessage(`Welcome back, ${data.username}!`);
  } else {</pre><p class="list-inset">If the token is invalid or it has been tampered with or has expired, the <code>useEffect</code> hook removes it from local storage, sets the context state variables to <code>null</code>, and sets an appropriate message to the users:</p><pre class="source-code">localStorage.removeItem(
  ‘jwt’);
setJwt(null);
setUser(null);
setMessage(data.message)
}
})
.catch(() =&gt; {
  localStorage
    .removeItem(
      ‘jwt’);
  setJwt(null);
  setUser(null);
  setMessage(
    ‘Please log in or register’
  );
});
}
else {
  setJwt(null);
  setUser(null);
  setMessage(
    ‘Please log in or register’
  );
}
}, []); };</pre></li>			</ol>
			<p class="calibre5">To sum it up, the <code>useEffect</code> hook performs a cycle. First, it checks for the local storage and if it doesn’t find a JWT, it deletes the JWT from the context, sets the username to <code>null</code>, and prompts the user to log in. The same result is obtained if the API call to the <code>/me</code> route, with the existing JWT, does not yield a valid username. This means that the token is present, but invalid or expired. If the JWT is indeed present and it can be used in order to obtain a valid username, the username is then set and the JWT is stored in the <em class="italic">Context</em>. Since the dependency array is empty, this hook will run only once on the first render.</p>
			<h2 id="_idParaDest-138" class="about-the-author"><a id="_idTextAnchor148" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Implementing the login functionality</h2>
			<p class="calibre5">The login function will reside again inside the context for simplicity, although it could be in a separate file. Following is the login flow:</p>
			<ol class="calibre14">
				<li class="calibre15">The user provides their username and password.</li>
				<li class="calibre15">A fetch call to the backend is performed.</li>
				<li class="calibre15">If the response has an HTTP status of <code>200</code> and the JWT is returned, <code>localStorage</code> is set, as well as the context, and the user is authenticated.</li>
				<li class="calibre15">If the response doesn’t return an HTTP status of <code>200</code>, it means that the login information was not accepted and, in that case, both the JWT and the username values are set to <code>null</code> in the context and effectively invalidated.</li>
			</ol>
			<p class="calibre5">To implement the login functionality, perform these steps:</p>
			<ol class="calibre14">
				<li class="calibre15">First, the <code>login</code> function needs to call the login API route with the provided username and password. Paste the following code into the end of the <code>AuthContext.jsx</code> file:<pre class="source-code">
const login = async (username,
  password) =&gt; {  const response = await fetch(`${import.meta.env.VITE_API_URL}/users/login`, {
      method: ‘POST’,
      headers: {
        ‘Content-Type’: ‘application/json’,
      },
      body: JSON.stringify({
        username,
        password
      }),
    });</pre></li>				<li class="calibre15">Next, depending on the response, the function will set the state variables in the context accordingly:<pre class="source-code">
  const data = await response
    .json();
  if(response.ok) {
    setJwt(data.token);
    localStorage.setItem(‘jwt’, data
      .token);
    setUser(data.username);
    setMessage(
      `Login successful: welcome  ${data.username}`
    );
  } else {
    setMessage(‘Login failed: ‘ +
      data.detail);
    setUser(null)
    setJwt(null);
    localStorage.removeItem(‘jwt’);
  }
  return data
};</pre><p class="list-inset">The logic is similar to the one applied in the <code>useEffect</code> hook—if a valid user is found, the context state variables (username and JWT) are set; otherwise, they are set to <code>null</code>. </p></li>				<li class="calibre15">The final part is just the <code>logout</code> function and the returning of the context provider. The following <code>logout</code> function is defined inside <code>AuthProvider</code>:<pre class="source-code">
    const logout = () =&gt; {
      setUser(null);
      setJwt(null);
      localStorage.removeItem(‘jwt’);
      setMessage(‘Logout successful’);
    };
    return ( &lt;
      AuthContext.Provider value = {
        {
          username,
          jwt,
          login,
          logout,
          message,
          setMessage
        }
      } &gt; {
        children
      } &lt;
      /AuthContext.Provider&gt;
    );</pre></li>			</ol>
			<p class="calibre5">At this point you have accomplished quite a lot: you have set up the context, defined the login and logout functions, and created the context provider. Now, to facilitate the use of the context, you will create a simple custom React hook, based on the <code>useContext</code> built-in hook.</p>
			<h3 class="calibre8">Creating a custom hook for accessing the context</h3>
			<p class="calibre5">With the Context API set up, you can now proceed and create a <code>useAuth.jsx</code> file inside a new folder, <code>/src/hooks</code>, which will allow easy access to the context from various places:</p>
			<ol class="calibre14">
				<li class="calibre15">Create the <code>useAuth.jsx</code> file inside the new folder:<pre class="source-code">
import {
  useContext
} from “react”;
import {
  AuthContext
} from “../contexts/AuthContext”;
export const useAuth = () =&gt; {
  const context = useContext(
    AuthContext)
  if (!context) {
    throw new Error(
      ‘Must be used within an AuthProvider’
      )
  }
  return context
}</pre><p class="list-inset">The <code>useAuth</code> hook contains an error message in case the hook is accessed outside of the context—but your context will enclose the entire application.</p><p class="list-inset">The final step in using a React context is to wrap the components that will need to access it; in your case, this will be <code>App.jsx</code>—the root component. </p></li>				<li class="calibre15">Open the <code>App.jsx</code> file and wrap the only component that it is currently returning—
<code>RouterProvider</code>—inside <code>AuthProvider</code>:<pre class="source-code">
import { AuthProvider } from “./contexts/AuthContext”
// continues
export default function App() {
  return (
    <strong class="bold">&lt;AuthProvider&gt;</strong>
      &lt;RouterProvider router={router} /&gt;
    <strong class="bold">&lt;/AuthProvider&gt;</strong>
  )
}</pre><p class="list-inset">Finally, display the context data and the state variables inside the <code>RootLayout</code> component that currently hosts all of your pages. This is a useful debugging technique while working with React Context API; you do not need to switch to and from the developer tools constantly. </p></li>				<li class="calibre15">Open <code>RootLayout.jsx</code> and edit the file:<pre class="source-code">
import { Outlet, NavLink } from “react-router-dom”
<strong class="bold">import { useAuth } from “../hooks/useAuth”</strong>
const RootLayout = () =&gt; {
    <code>logout</code> function, you can now add a little bit of JSX conditional rendering and create a dynamic menu:<pre class="source-code">
const RootLayout = () =&gt; {
  const {
    user,
    message,
    logout
  } = useAuth()
  return (
    &lt;div className=” bg-blue-200 min-h-screen p-2”&gt;
      &lt;h2&gt;RootLayout&lt;/h2&gt;
      &lt;p className=”text-red-500 p-2 border”&gt;
        {message}
    &lt;/p&gt;
    &lt;p&gt;Username: {user}&lt;/p&gt;
    &lt;header className=”p-3 w-full”&gt;
      &lt;nav className=”flex flex-row justify-between
        mx-auto”&gt;
      &lt;div className=”flex flex-row space-x-3”&gt;
        &lt;NavLink to=”/”&gt;Home&lt;/NavLink&gt;
        &lt;NavLink to=”/cars”&gt;Cars&lt;/NavLink&gt;
          {user ? &lt;&gt;
        &lt;NavLink to=”/new-car”&gt;New Car&lt;/NavLink&gt;
          &lt;button onClick={logout}&gt;Logout&lt;/button&gt;
        &lt;/&gt; : &lt;&gt; 
        &lt;NavLink to=”/login”&gt;Login&lt;/NavLink&gt;
        &lt;/&gt;}
      &lt;/div&gt;
    &lt;/nav&gt;
  &lt;/header&gt;
  &lt;main className=”p-8 flex flex-col flex-1 
    bg-white “&gt;
    &lt;Outlet /&gt;
  &lt;/main&gt;
    &lt;/div&gt;
  )
}
export default RootLayout</pre></li>			</ol>
			<p class="calibre5">The application is rather simple, but it showcases the login/logout process well. As an exercise, you could easily implement the registration page—the API endpoint already exists and you should create the logic for handling the register form. </p>
			<p class="calibre5">The following section will focus on completing some more functionality—the route for inserting new cars is still reachable for users who are not logged in and the form doesn’t exist yet. Now you will secure the resource creation endpoint and create protected pages with React Router.</p>
			<h2 id="_idParaDest-139" class="about-the-author"><a id="_idTextAnchor149" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Protecting routes</h2>
			<p class="calibre5">Protected routes are routes and pages that are not accessible to everyone—they usually require the user to be logged in or to have certain privileges (admin or creator). There are many ways of protecting routes in React Router. One popular pattern is through high-order components—they are wrapper components that wrap routes that require a logged-in user. The new React Router and its <code>Outlet</code> component allow you to easily implement gate logic and redirect the user if they need to be authorized.</p>
			<p class="calibre5">Create a basic component that checks for the presence of a user (through the username). If the user is present, the component will use an <code>Outlet</code> component to let the wrapped routes make their way to the browser; otherwise, a redirect to the login page will ensue:</p>
			<ol class="calibre14">
				<li class="calibre15">Create a new component in the <code>/src/components</code> folder and name it <code>AuthRequired.jsx</code>:<pre class="source-code">
import {
  Outlet,
  Navigate
} from “react-router-dom”
import {
  useAuth
} from “../hooks/useAuth”
const AuthRequired = () =&gt; {
  const {
    jwt
  } = useAuth()
  return (
    &lt;div&gt;
            &lt;h1&gt;AuthRequired&lt;/h1&gt;
            {jwt ? &lt;Outlet /&gt; : &lt;Navigate to=”/login” /&gt;}
        &lt;/div&gt;
  )
}
export default AuthRequired</pre><p class="list-inset">The logic is simple; the component ensures you perform the JWT presence check. It then acts like a semaphore or a simple IF construct that checks for a condition—if a JWT is present, the <code>Outlet</code> component will show the enclosed components (in our case only one: the <code>NewCar</code> page), and if not, React Router’s <code>Navigate</code> component is used for programmatic navigation to the home page. </p><p class="list-inset">This simple solution will not force the authenticated user to be redirected to the home page if they reload a protected page, since the <code>useEffect</code> hook in <code>Layout.jsx</code> will detect whether the JWT is invalid only after the component loads. If the JWT is indeed invalid, the <code>useEffect</code> hook will invalidate the JWT, thus triggering the redirect.</p></li>				<li class="calibre15">Now, update the <code>App.jsx</code> component, import the <code>AuthRequired</code> component, and enclose the <code>NewCar</code> page:<pre class="source-code">
import AuthRequired from “./components/AuthRequired”
<strong class="bold">import { AuthProvider } from “./contexts/AuthContext”</strong>
// code continues
const router = createBrowserRouter(
  createRoutesFromElements(
    &lt;Route path=”/” element={&lt;RootLayout /&gt;}&gt;
      &lt;Route index element={&lt;Home /&gt;} /&gt;
      &lt;Route path=”cars” element={&lt;Cars /&gt;} loader={carsLoader} /&gt;
      &lt;Route path=”login” element={&lt;Login /&gt;} /&gt;
<strong class="bold">      &lt;Route element={&lt;AuthRequired /&gt;}&gt;</strong>
<strong class="bold">        &lt;Route path=”new-car” element={&lt;NewCar /&gt;} /&gt;</strong>
<strong class="bold">      &lt;/Route&gt;</strong>
      &lt;Route path=”cars/:id” element={&lt;SingleCar /&gt;} /&gt;</pre></li>			</ol>
			<p class="calibre5">You have learned how to protect routes that need authentication. Now, you will build another form to insert data about new cars and upload images (one image per car, to be precise) to Cloudinary through FastAPI. </p>
			<h2 id="_idParaDest-140" class="about-the-author"><a id="_idTextAnchor150" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Creating the page for inserting new cars</h2>
			<p class="calibre5">The page for inserting new cars into the collection—the <code>NewCar.jsx</code> component—is protected and can be accessed only by authenticated users. In this section, you will build a more complex form and gradually modularize the code:</p>
			<ol class="calibre14">
				<li class="calibre15">First, update the <code>NewCar.jsx</code> page and add a <code>CarForm</code> component, which you will build shortly:<pre class="source-code">
import CarForm from “../components/CarForm”
const NewCar = () =&gt; {
    return (
        &lt;div&gt;
<strong class="bold">            &lt;CarForm /&gt;</strong>
        &lt;/div&gt;
    )
}
export default NewCar</pre></li>				<li class="calibre15">Now, create this component in the <code>/src/components</code> folder. In this folder, create a new file and name it <code>CarForm.jsx</code>. Before starting to code the form, quickly review what type of data the form needs to collect and send to the API:<ul class="calibre19"><li class="calibre15"><strong class="bold">Brand</strong>: A string</li><li class="calibre15"><strong class="bold">Make</strong>: A string</li><li class="calibre15"><strong class="bold">Year</strong>: An integer</li><li class="calibre15"><strong class="bold">Price</strong>: An integer</li><li class="calibre15"><strong class="bold">Km</strong>: An integer</li><li class="calibre15"><strong class="bold">Cm3</strong>: An integer</li><li class="calibre15"><strong class="bold">Picture</strong>: A file object</li></ul><p class="list-inset">It would be rather tedious and repetitive to create each field in the form as an individual input and just copy and paste everything across the file. Instead, you can abstract the input field and make it a reusable component. This component will need to accept some props, such as a name and type (number or string), and RHF can register it and associate an error, if any, to said field. So, before starting the form, create another component that will be reused as many times as needed and that will significantly facilitate the process of creating and updating the form should you need to add even more fields later—in a real-life scenario, cars can have hundreds of fields.</p></li>
				<li class="calibre15">Create a new file in the <code>/src/components</code> folder and name it <code>InputField.jsx</code>:<pre class="source-code">
const InputField = ({ props }) =&gt; {
  const { name, type, error } = props;
  return (
    &lt;div className=”mb-4”&gt;
      &lt;label
        className=”block text-gray-700 text-sm mb-2”
        htmlFor={name}
      &gt;
        {name}
      &lt;/label&gt;
      &lt;input
        className=”shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline”
        id={name}
        name={name}
        type={type}
        placeholder={name}
        required
        autoComplete=”off”
        {...props}
      /&gt;
      {error &amp;&amp; &lt;p className=”text-red-500 text-xs italic”&gt;{error.message}&lt;/p&gt;}
    &lt;/div&gt;
  );
};
export default InputField;</pre><p class="list-inset">The field component is simple, yet useful—it abstracts all the functionality and even adds some styling. </p></li>				<li class="calibre15">Now, go back to the <code>CarForm</code> file and start with the imports:<pre class="source-code">
import { useForm } from “react-hook-form”
import { z } from ‘zod’;
import { zodResolver } from ‘@hookform/resolvers/zod’;
import { useNavigate } from “react-router-dom”;
import { useAuth } from “../hooks/useAuth”;
import InputField from “./InputField”;</pre></li>				<li class="calibre15">You are going to use Zod again for data validation, so add a schema—it should ideally match the Pydantic validation rules on the backend for consistency:<pre class="source-code">
const schema = z.object({
    brand: z.string().min(2, ‘Brand must contain at least two letters’).max(20, ‘Brand cannot exceed 20 characters’),
    make: z.string().min(1, ‘Car model must be at least 1 character long’).max(20, ‘Model cannot exceed 20 characters’),
    year: z.coerce.number().gte(1950).lte(2025),
    price: z.coerce.number().gte(100).lte(1000000),
    km: z.coerce.number().gte(0).lte(500000),
    cm3: z.coerce.number().gt(0).lte(5000),
    picture: z.any()
        .refine(file =&gt; file[0] &amp;&amp; file[0].type.startsWith(‘image/’), { message: ‘File must be an image’ })
        .refine(file =&gt; file[0] &amp;&amp; file[0].size &lt;= 1024 * 1024, { message: ‘File size must be less than 1MB’ }),
});</pre><p class="list-inset">The Zod schema syntax is rather intuitive, though there might be some aspects that need caution—numbers need to be coerced, as HTML forms send strings by default, and files can be validated through handy functions. </p></li>				<li class="calibre15">Now, start the actual form component:<pre class="source-code">
const CarForm = () =&gt; {
    const navigate = useNavigate();
    const { jwt } = useAuth();
    const { register, handleSubmit, 
    formState: { errors, isSubmitting } } = useForm({
        resolver: zodResolver(schema),
    });</pre><p class="list-inset">The <code>useNavigate</code> hook is used to navigate away from the page once the submission is complete, while <code>useForm</code> is similar to the one used for logging users in.  </p></li>				<li class="calibre15">Create a simple JavaScript array containing the data about the fields that are needed for the form:<pre class="source-code">
    let formArray = [
        {
            name: “brand”,
            type: “text”,
            error: errors.brand
        },
        {
            name: “make”,
            type: “text”,
            error: errors.make
        },
        {
            name: “year”,
            type: “number”,
            error: errors.year
        },
        {
            name: “price”,
            type: “number”,
            error: errors.price
        },
        {
            name: “km”,
            type: “number”,
            error: errors.km
        },
        {
            name: “cm3”,
            type: “number”,
            error: errors.cm3
        },
        {
            name: “picture”,
            type: “file”,
            error: errors.picture
        }
    ]</pre></li>				<li class="calibre15">With this array, the form code becomes much more manageable. Look at the <code>onSubmit</code> function:<pre class="source-code">
const onSubmit = async (data) =&gt; {
  const formData = new FormData();
  formArray.forEach((field) =&gt; {
    if (field == “picture”) {
      formData.append(field, data[field][0]);
    } else {
      formData.append(field.name, data[field.name]);
    }
  });
};</pre><p class="list-inset">Suddenly, the <code>onSubmit</code> function is much more succinct—it loops over the array and adds the fields to the <code>formData</code> object. Keep in mind that the <code>file</code> field is special—it is an array and you want only the first element, that is, the picture. </p></li>				<li class="calibre15">To complete the <code>onSubmit</code> function, you need to make the <code>POST</code> request to the API:<pre class="source-code">
const result = await fetch(`${import.meta.env.VITE_API_URL}/cars/`, {
  method: “POST”,
  body: formData,
  headers: {
    Authorization: `Bearer ${jwt}`,
  },
});
const json = await result.json();
if (result.ok) {
  navigate(“/cars”);
} else if (json.detail) {
  setMessage(JSON.stringify(json));
  navigate(“/”);
}</pre><p class="list-inset">The fetch call is simple. After you get the result back, you can apply custom logic. In this case, you JSONify—render the error object as a JSON string and set the message to show it—if the error is coming from the server. </p></li>				<li class="calibre15">Finally, the JSX is trivial, thanks to your <code>InputField</code> component and <code>formArray</code>, while you also use the submitting value from the <code>useForm</code> hook:<pre class="source-code">
return (
  &lt;div className=”flex items-center justify-center”&gt;
    &lt;div className=”w-full max-w-xs”&gt;
      &lt;form
        className=”bg-white shadow-md rounded px-8 pt-6 pb-8 mb-4 “
        encType=”multipart/form-data”
        onSubmit={handleSubmit(onSubmit)}
      &gt;
        &lt;h2 className=”text-center text-2xl font-bold mb-6”&gt;Insert new car&lt;/h2&gt;
        {formArray.map((item, index) =&gt; (
          &lt;InputField
            key={index}
            props={{
              name: item.name,
              type: item.type,
              error: item.error,
              ...register(item.name),
            }}
          /&gt;
        ))}
        &lt;div className=”flex items-center justify-between”&gt;
          &lt;button
            className=”bg-gray-900 hover:bg-gray-700 text-white w-full font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline”
            type=”submit”
            disabled={isSubmitting}
          &gt;
            {isSubmitting ? “Saving...” : “Save new car”}
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);}
export default CarForm</pre></li>			</ol>
			<p class="calibre5">The submit button is now reused as a submission indicator—it displays a different message while submitting and is also disabled to prevent multiple requests.</p>
			<p class="calibre5">Building a page to update cars would be very similar to the previous endpoint—RHF plays extremely well with initial or default data that can be populated from an existing object, and you can also play with the online form builder: <a href="https://react-hook-form.com/form-builder" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2">https://react-hook-form.com/form-builder</a>. Deleting cars is also relatively simple as the request needs only to be authenticated and contains the car ID.</p>
			<p class="calibre5">You have now built a car creation page, which can be extended in numerous ways. You have learned how to modularize your React code and how to provide meaningful messages and logic to your application, depending on the data flow to and from the server. Now you will build a page for displaying single cars and use loaders again.</p>
			<h2 id="_idParaDest-141" class="about-the-author"><a id="_idTextAnchor151" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Displaying single cars</h2>
			<p class="calibre5">Now that you have created the pages for displaying multiple items (cars), authenticating, and creating new items, create an individual car page and see how React Router deals with parameters in the URL:</p>
			<ol class="calibre14">
				<li class="calibre15">Edit the <code>SingleCar.jsx</code> file and introduce the <code>useLoaderData</code> hook, already used for preloading data on the cars page:<pre class="source-code">
import { useLoaderData } from “react-router-dom”;
import CarCard from “../components/CarCards”;
const SingleCar = () =&gt; {
    const car = useLoaderData()
    return (
        &lt;CarCard car={car} /&gt;
    );
};
export default SingleCar</pre><p class="list-inset">To save space, we reused the <code>CarCard</code> function to display data about the car. However, in a realistic scenario, this page would contain possibly an image gallery, much more data, maybe some comments or notes, and so on. The goal here, however, is just to show another way of creating the loader function. </p></li>				<li class="calibre15">Open the <code>App.jsx</code> file that currently hosts the router and update the <code>cars/:id</code> route, bearing in mind that the colon denotes a parameter, in this case, the string version of the <code>ObjectId</code> component of the car in the MongoDB collection:<pre class="source-code">
<strong class="bold">import fetchCarData from “./utils/fetchCarData”</strong>
// continues
const router = createBrowserRouter(
  createRoutesFromElements(
    &lt;Route path=”/” element={&lt;RootLayout /&gt;}&gt;
      &lt;Route index element={&lt;Home /&gt;} /&gt;
      &lt;Route path=”cars” element={&lt;Cars /&gt;} loader={carsLoader} /&gt;
      &lt;Route path=”login” element={&lt;Login /&gt;} /&gt;
      &lt;Route element={&lt;AuthRequired /&gt;}&gt;
        &lt;Route path=”new-car” element={&lt;NewCar /&gt;} /&gt;
      &lt;/Route&gt;
      &lt;Route
        path=”cars/:id”
        element={&lt;SingleCar /&gt;}
<strong class="bold">        loader={async ({ params }) =&gt; {</strong>
<strong class="bold">          return fetchCarData(params.id);</strong>
<strong class="bold">        }}</strong>
<strong class="bold">        errorElement={&lt;NotFound /&gt;} /&gt;</strong>
      &lt;Route path=”*” element={&lt;NotFound /&gt;} /&gt;
    &lt;/Route&gt;
  )
)</pre><p class="list-inset">There are just two changes in the route: the <code>loader</code> function, which is supplied as a part of an async function that takes in the parameter ID, and <code>errorElement</code>. The <code>NotFound</code> component will be displayed, in case the <code>loader</code> function encounters an error while fetching the data. Here, again, you reuse an existing element, but it could be customized. </p></li>				<li class="calibre15">The final piece of the puzzle is the <code>fetchCarData.js</code> file, which is located in the <code>/src/utils</code> folder:<pre class="source-code">
export default async function fetchCarData(id) {
    const res = await fetch(`${import.meta.env.VITE_API_URL}/cars/${id}`)
    const response = await res.json()
    if (!res.ok) {
        throw new Error(response.message)
    }
    return response
}</pre></li>			</ol>
			<p class="calibre5">The <code>async</code> function just performs a single API call to retrieve the data related to an individual entity and, in case of an error, <code>errorElement</code> will be triggered.</p>
			<p class="calibre5">Loader functions are extremely handy. By preloading data, they enable the user to have a much better user experience and the application feels faster.</p>
			<h1 id="_idParaDest-142" class="contributor"><a id="_idTextAnchor152" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Summary</h1>
			<p class="calibre5">In this chapter, you created a React application using a modern Vite setup and implemented the basic functionality—creating new resources and, listing and displaying cars. This chapter also served as a refresher for you on the basic React hooks, such as <code>useState</code> and <code>useEffect</code>, and the Context API. You also learned the basics of React Router with its powerful loader functions. In this chapter, you created two forms using RHF and learned how to manage various steps and states involved with the use of your API.</p>
			<p class="calibre5">The following chapter will explore Next.js version 14—the most powerful and feature-rich React.js-based full-stack framework.</p>
		</div>
	</div>
</div>
</body></html>