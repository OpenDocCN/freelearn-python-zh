<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 7. Executable Documentation with doctest"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Executable Documentation with doctest</h1></div></div></div><p>Throughout this book, we have emphasized the need for code to be self-documenting as far as possible. We have mentioned how the cool docstring feature of Python helps us in this objective. There is one problem with documentation in general—it can easily go out of sync with the code. Many times we have seen changes to the code, but the corresponding change is not made to the documentation, leaving a new developer confused about how the code actually works. Enter the <code class="literal">doctest</code> module to our rescue.</p><p>The <code class="literal">doctest</code> module allows us to specify examples inside our docstrings. The module then extracts the examples, runs them, and verifies that they still work.</p><div class="section" title="Our first doctest"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec49"/>Our first doctest</h1></div></div></div><p>The <a id="id321" class="indexterm"/>following <a id="id322" class="indexterm"/>is the current version of the <code class="literal">price</code> method in the <code class="literal">Stock</code> class:</p><div class="informalexample"><pre class="programlisting">    def price(self):
        try:
            return self.history[-1].value
        except IndexError:
            return None</pre></div><p>Now, in the docstring, we add an example of how this method might be used. The examples are basically a copy-paste of a Python interactive shell. Hence, the lines containing input to be executed are prefixed with <code class="literal">&gt;&gt;&gt;</code> prompt, and the lines without the prompt indicate output, as shown in the following:</p><div class="informalexample"><pre class="programlisting">    def price(self):
        """Returns the current price of the Stock

        &gt;&gt;&gt; from datetime import datetime
        &gt;&gt;&gt; stock = Stock("GOOG")
        &gt;&gt;&gt; stock.update(datetime(2011, 10, 3), 10)
        &gt;&gt;&gt; stock.price
        10
        """
        try:
            return self.history[-1].value
        except IndexError:
            return None</pre></div><p>Now that we<a id="id323" class="indexterm"/> have the docstring, we need a way to execute it. Add the following lines to the bottom of the file:</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    import doctest
    doctest.testmod()</pre></div><div class="section" title="Running the doctest"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec55"/>Running the doctest</h2></div></div></div><p>Now we can run the tests by executing the file as a module. We need to execute the file as a module <a id="id324" class="indexterm"/>so that the relative imports work. If this was a standalone script, or we used absolute imports instead of relative imports, then we could have just directly executed the file. Since the code above is in the <code class="literal">stock.py</code> file, we have to execute the <code class="literal">stock_alerter.stock</code> module. The following is the command to execute it:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Windows: <code class="literal">python.exe -m stock_alerter.stock</code></li><li class="listitem" style="list-style-type: disc">Linux/Mac: <code class="literal">python3 -m stock_alerter.stock</code></li></ul></div><p>When we run the above command, we'll get the output as nothing. Yes, nothing. If there is no output, then it means that all the doctests passed. We can pass the <code class="literal">-v</code> command line parameter (for verbose output) to see that the test indeed passed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Windows: <code class="literal">python.exe -m stock_alerter.stock -v</code></li><li class="listitem" style="list-style-type: disc">Linux/Mac: <code class="literal">python3 -m stock_alerter.stock -v</code></li></ul></div><p>When we do this, we get the following output:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>Trying:</strong></span>
<span class="strong"><strong>    from datetime import datetime</strong></span>
<span class="strong"><strong>Expecting nothing</strong></span>
<span class="strong"><strong>ok</strong></span>
<span class="strong"><strong>Trying:</strong></span>
<span class="strong"><strong>    stock = Stock("GOOG")</strong></span>
<span class="strong"><strong>Expecting nothing</strong></span>
<span class="strong"><strong>ok</strong></span>
<span class="strong"><strong>Trying:</strong></span>
<span class="strong"><strong>    stock.update(datetime(2011, 10, 3), 10)</strong></span>
<span class="strong"><strong>Expecting nothing</strong></span>
<span class="strong"><strong>ok</strong></span>
<span class="strong"><strong>Trying:</strong></span>
<span class="strong"><strong>    stock.price</strong></span>
<span class="strong"><strong>Expecting:</strong></span>
<span class="strong"><strong>    10</strong></span>
<span class="strong"><strong>ok</strong></span>
<span class="strong"><strong>8 items had no tests:</strong></span>
<span class="strong"><strong>    __main__</strong></span>
<span class="strong"><strong>    __main__.Stock</strong></span>
<span class="strong"><strong>    __main__.Stock.__init__</strong></span>
<span class="strong"><strong>    __main__.Stock._is_crossover_below_to_above</strong></span>
<span class="strong"><strong>    __main__.Stock.get_crossover_signal</strong></span>
<span class="strong"><strong>    __main__.Stock.is_increasing_trend</strong></span>
<span class="strong"><strong>    __main__.Stock.update</strong></span>
<span class="strong"><strong>    __main__.StockSignal</strong></span>
<span class="strong"><strong>1 items passed all tests:</strong></span>
<span class="strong"><strong>   4 tests in __main__.Stock.price</strong></span>
<span class="strong"><strong>4 tests in 9 items.</strong></span>
<span class="strong"><strong>4 passed and 0 failed.</strong></span>
<span class="strong"><strong>Test passed.</strong></span>
</pre></div><p>Let us<a id="id325" class="indexterm"/> look at that output in a little more detail.</p><p>If we look at the first line of our example, it contains the following:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from datetime import datetime</strong></span>
</pre></div><p>
<code class="literal">doctest</code> picks up this line and evaluates the output:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>Trying:</strong></span>
<span class="strong"><strong>    from datetime import datetime</strong></span>
<span class="strong"><strong>Expecting nothing</strong></span>
<span class="strong"><strong>ok</strong></span>
</pre></div><p>The next line of the example is another input line starting with the <code class="literal">&gt;&gt;&gt;</code> prompt, so doctest figures that executing the first line should not have any output, hence the statement <span class="emphasis"><em>Expecting nothing</em></span>.</p><p>When this first line of the test is executed, indeed nothing is printed, so <code class="literal">doctest</code> gives the output <span class="emphasis"><em>ok</em></span>, meaning that the line executed as expected. <code class="literal">doctest</code> then goes on to the next line and follows the same procedure until the following line is encountered:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; stock.price</strong></span>
<span class="strong"><strong>10</strong></span>
</pre></div><p>Our test says that, when this line is executed, the output of <code class="literal">10</code> should be printed. That is exactly what doctest checks for as well, as shown in the following:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>Trying:</strong></span>
<span class="strong"><strong>    stock.price</strong></span>
<span class="strong"><strong>Expecting:</strong></span>
<span class="strong"><strong>    10</strong></span>
<span class="strong"><strong>ok</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>Note that we don't explicitly call <code class="literal">print(stock.price)</code>. We just put <code class="literal">stock.price</code> and expect the output of <code class="literal">10</code>. This is exactly the behavior we see in the Python interactive shell; <code class="literal">doctest</code> uses the same behavior.</p></div></div><p>After this <a id="id326" class="indexterm"/>line, our example ends and <code class="literal">doctest</code> continues on to the next method, as shown in the following:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>8 items had no tests:</strong></span>
<span class="strong"><strong>    __main__</strong></span>
<span class="strong"><strong>    __main__.Stock</strong></span>
<span class="strong"><strong>    __main__.Stock.__init__</strong></span>
<span class="strong"><strong>    __main__.Stock._is_crossover_below_to_above</strong></span>
<span class="strong"><strong>    __main__.Stock.get_crossover_signal</strong></span>
<span class="strong"><strong>    __main__.Stock.is_increasing_trend</strong></span>
<span class="strong"><strong>    __main__.Stock.update</strong></span>
<span class="strong"><strong>    __main__.StockSignal</strong></span>
<span class="strong"><strong>1 items passed all tests:</strong></span>
<span class="strong"><strong>   4 tests in __main__.Stock.price</strong></span>
<span class="strong"><strong>4 tests in 9 items.</strong></span>
<span class="strong"><strong>4 passed and 0 failed.</strong></span>
<span class="strong"><strong>Test passed.</strong></span>
</pre></div><p>It tells us that the remaining methods didn't have tests, and that all the tests passed. Note that <code class="literal">doctest</code> counts each line of the example as a separate test, hence the reason why it identified four tests. Since Python supports module-level and class-level docstrings, we could have put some examples in those as well, perhaps examples on how to use the module or the class as a whole. This is why <code class="literal">doctest</code> also tells us that <code class="literal">__main__</code> and <code class="literal">__main__.Stock</code> do not have any tests.</p><p>The beauty of doctests is that it allows us to mix documentation between the examples. This allows us to expand the docstring for the <code class="literal">price</code> method like the following:</p><div class="informalexample"><pre class="programlisting">    def price(self):
        """Returns the current price of the Stock

        &gt;&gt;&gt; from datetime import datetime
        &gt;&gt;&gt; stock = Stock("GOOG")
        &gt;&gt;&gt; stock.update(datetime(2011, 10, 3), 10)
        &gt;&gt;&gt; stock.price
        10

        The method will return the latest price by timestamp, so even if updates are out of order, it will return the latest one

        &gt;&gt;&gt; stock = Stock("GOOG")
        &gt;&gt;&gt; stock.update(datetime(2011, 10, 3), 10)

        Now, let us do an update with a date that is earlier than the
        previous one

        &gt;&gt;&gt; stock.update(datetime(2011, 10, 2), 5)

        And the method still returns the latest price

        &gt;&gt;&gt; stock.price
        10

        If there are no updates, then the method returns None

        &gt;&gt;&gt; stock = Stock("GOOG")
        &gt;&gt;&gt; print(stock.price)
        None
        """
        try:
            return self.history[-1].value
        except IndexError:
            return None</pre></div><p>Run the<a id="id327" class="indexterm"/> above and it should pass with the following new output:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>Trying:</strong></span>
<span class="strong"><strong>    stock = Stock("GOOG")</strong></span>
<span class="strong"><strong>Expecting nothing</strong></span>
<span class="strong"><strong>ok</strong></span>
<span class="strong"><strong>Trying:</strong></span>
<span class="strong"><strong>    stock.update(datetime(2011, 10, 3), 10)</strong></span>
<span class="strong"><strong>Expecting nothing</strong></span>
<span class="strong"><strong>ok</strong></span>
<span class="strong"><strong>Trying:</strong></span>
<span class="strong"><strong>    stock.update(datetime(2011, 10, 2), 5)</strong></span>
<span class="strong"><strong>Expecting nothing</strong></span>
<span class="strong"><strong>ok</strong></span>
<span class="strong"><strong>Trying:</strong></span>
<span class="strong"><strong>    stock.price</strong></span>
<span class="strong"><strong>Expecting:</strong></span>
<span class="strong"><strong>    10</strong></span>
<span class="strong"><strong>ok</strong></span>
<span class="strong"><strong>Trying:</strong></span>
<span class="strong"><strong>    stock = Stock("GOOG")</strong></span>
<span class="strong"><strong>Expecting nothing</strong></span>
<span class="strong"><strong>ok</strong></span>
<span class="strong"><strong>Trying:</strong></span>
<span class="strong"><strong>    print(stock.price)</strong></span>
<span class="strong"><strong>Expecting:</strong></span>
<span class="strong"><strong>    None</strong></span>
<span class="strong"><strong>ok</strong></span>
</pre></div><p>As we can <a id="id328" class="indexterm"/>see, <code class="literal">doctest</code> goes through the documentation and identifies the exact lines that need to be executed. This allows us to put explanations and documentation in between the code snippets. The result? Well-explained documentation plus testable code. A great combination!</p><p>Let us take one quick look at the last example:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; stock = Stock("GOOG")</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print(stock.price)</strong></span>
<span class="strong"><strong>None</strong></span>
</pre></div><p>If you notice, we explicitly print the output. The reason is that the Python interactive shell usually does not give any output when the value is <code class="literal">None</code>. Since doctest mimics the behavior of the interactive shell, we could have just had an empty line and the test would have passed, but it is not really clear what is happening. So, we call print to make it explicit that we are expecting <code class="literal">None</code> as the output.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Test failures"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec50"/>Test failures</h1></div></div></div><p>Let us now <a id="id329" class="indexterm"/>see what a test failure looks like. The following is a doctest for the <code class="literal">is_increasing_trend</code> method:</p><div class="informalexample"><pre class="programlisting">    def is_increasing_trend(self):
        """Returns True if the past three values have been strictly
        increasing

        Returns False if there have been less than three updates so far

        &gt;&gt;&gt; stock = Stock("GOOG")
        &gt;&gt;&gt; stock.is_increasing_trend()
        False
        """

        return self.history[-3].value &lt; \
            self.history[-2].value &lt; self.history[-1].value</pre></div><p>The following<a id="id330" class="indexterm"/> is what we get when we run the test:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>Failed example:</strong></span>
<span class="strong"><strong>    stock.is_increasing_trend()</strong></span>
<span class="strong"><strong>Exception raised:</strong></span>
<span class="strong"><strong>    Traceback (most recent call last):</strong></span>
<span class="strong"><strong>      File "C:\Python34\lib\doctest.py", line 1324, in __run</strong></span>
<span class="strong"><strong>        compileflags, 1), test.globs)</strong></span>
<span class="strong"><strong>      File "&lt;doctest __main__.Stock.is_increasing_trend[1]&gt;", line 1, in &lt;module&gt;</strong></span>
<span class="strong"><strong>        stock.is_increasing_trend()</strong></span>
<span class="strong"><strong>      File "c:\Projects\tdd_with_python\src\stock_alerter\stock.py", line 91, in is_increasing_trend</strong></span>
<span class="strong"><strong>        return self.history[-3].value &lt; \</strong></span>
<span class="strong"><strong>      File "c:\Projects\tdd_with_python\src\stock_alerter\timeseries.py", line 13, in __getitem__</strong></span>
<span class="strong"><strong>        return self.series[index]</strong></span>
<span class="strong"><strong>    IndexError: list index out of range</strong></span>
<span class="strong"><strong>**********************************************************************</strong></span>
<span class="strong"><strong>1 items had failures:</strong></span>
<span class="strong"><strong>   1 of   2 in __main__.Stock.is_increasing_trend</strong></span>
<span class="strong"><strong>***Test Failed*** 1 failures.</strong></span>
</pre></div><p>
<code class="literal">doctest</code> tells us which line caused the failure. It also tells us which command was executed, and what happened. We can see that an unexpected exception has failed the test.</p><p>We can now fix the code as follows:</p><div class="informalexample"><pre class="programlisting">    def is_increasing_trend(self):
        """Returns True if the past three values have been strictly increasing

        Returns False if there have been less than three updates so far

        &gt;&gt;&gt; stock = Stock("GOOG")
        &gt;&gt;&gt; stock.is_increasing_trend()
        False
        """

        try:
            return self.history[-3].value &lt; \
               self.history[-2].value &lt; self.history[-1].value
        except IndexError:
            return True</pre></div><p>The exception <a id="id331" class="indexterm"/>is now gone, but we have a bug in the fix because it has been replaced with a failure, as shown in the following:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>Failed example:</strong></span>
<span class="strong"><strong>    stock.is_increasing_trend()</strong></span>
<span class="strong"><strong>Expected:</strong></span>
<span class="strong"><strong>    False</strong></span>
<span class="strong"><strong>Got:</strong></span>
<span class="strong"><strong>    True</strong></span>
</pre></div><p>Let's fix it:</p><div class="informalexample"><pre class="programlisting">    def is_increasing_trend(self):
        """Returns True if the past three values have been strictly increasing
        Returns False if there have been less than three updates so far

        &gt;&gt;&gt; stock = Stock("GOOG")
        &gt;&gt;&gt; stock.is_increasing_trend()
        False
        """

        try:
            return self.history[-3].value &lt; \
               self.history[-2].value &lt; self.history[-1].value
        except IndexError:
            return False</pre></div><p>With this fix, all the tests are passing again.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Testing for exceptions"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec51"/>Testing for exceptions</h1></div></div></div><p>The <code class="literal">update</code> method <a id="id332" class="indexterm"/>should also raise a <code class="literal">ValueError</code> when the price is less than zero. The following is how we verify this in the doctest:</p><div class="informalexample"><pre class="programlisting">    def update(self, timestamp, price):
        """Updates the stock with the price at the given timestamp

        &gt;&gt;&gt; from datetime import datetime
        &gt;&gt;&gt; stock = Stock("GOOG")
        &gt;&gt;&gt; stock.update(datetime(2014, 10, 2), 10)
        &gt;&gt;&gt; stock.price
        10

        The method raises a ValueError exception if the price is negative

        &gt;&gt;&gt; stock.update(datetime(2014, 10, 2), -1)
        Traceback (most recent call last):
            ...
        ValueError: price should not be negative
        """

        if price &lt; 0:
            raise ValueError("price should not be negative")
        self.history.update(timestamp, price)
        self.updated.fire(self)</pre></div><p>The next section<a id="id333" class="indexterm"/> shows the expectation that <code class="literal">doctest</code> looks at:</p><div class="informalexample"><pre class="programlisting">Traceback (most recent call last):
    ...
ValueError: price should not be negative</pre></div><p>The expected output starts with the regular traceback output. This line tells <code class="literal">doctest</code> that an exception is expected. After that comes the actual traceback. Since the output often contains file paths that might change, it is very hard to match it exactly. Fortunately, we don't need to. <code class="literal">doctest</code> allows us to put three indented dots to signify the middle part of the traceback. Finally, the last line shows the expected exception and the exception message. This is the line that is matched to see whether the test passed or failed.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Package-level doctests"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec52"/>Package-level doctests</h1></div></div></div><p>As we have<a id="id334" class="indexterm"/> seen so far, doctests can be written for methods, classes, and modules. However, they can also be written for whole packages. Typically, these would be put in the <code class="literal">__init__.py</code> file of the package and would show how the package as a whole should work, including multiple interacting classes. Here is one such set of doctests from our <code class="literal">__init__.py</code> file:</p><div class="informalexample"><pre class="programlisting">r"""
The stock_alerter module allows you to set up rules and get alerted when those rules are met.

&gt;&gt;&gt; from datetime import datetime

First, we need to setup an exchange that contains all the stocks that are going to be processed. A simple dictionary will do.

&gt;&gt;&gt; from stock_alerter.stock import Stock
&gt;&gt;&gt; exchange = {"GOOG": Stock("GOOG"), "AAPL": Stock("AAPL")}

Next, we configure the reader. The reader is the source from where the stock updates are coming. The module provides two readers out of the box: A FileReader for reading updates from a comma separated file, and a ListReader to get updates from a list. You can create other readers, such as an HTTPReader, to get updates from a remote server.
Here we create a simple ListReader by passing in a list of 3-tuples containing the stock symbol, timestamp and price.

&gt;&gt;&gt; from stock_alerter.reader import ListReader
&gt;&gt;&gt; reader = ListReader([("GOOG", datetime(2014, 2, 8), 5)])

Next, we set up an Alert. We give it a rule, and an action to be taken when the rule is fired.

&gt;&gt;&gt; from stock_alerter.alert import Alert
&gt;&gt;&gt; from stock_alerter.rule import PriceRule
&gt;&gt;&gt; from stock_alerter.action import PrintAction
&gt;&gt;&gt; alert = Alert("GOOG &gt; $3", PriceRule("GOOG", lambda s: s.price &gt; 3),\
...               PrintAction())

Connect the alert to the exchange

&gt;&gt;&gt; alert.connect(exchange)

Now that everything is setup, we can start processing the updates

&gt;&gt;&gt; from stock_alerter.processor import Processor
&gt;&gt;&gt; processor = Processor(reader, exchange)
&gt;&gt;&gt; processor.process()
GOOG &gt; $3
"""

if __name__ == "__main__":
    import doctest
    doctest.testmod()</pre></div><p>We can <a id="id335" class="indexterm"/>run it like the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Windows</strong></span>: <code class="literal">python.exe -m stock_alerter.__init__</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Linux/Mac</strong></span>: <code class="literal">python3 -m stock_alerter.__init__</code></li></ul></div><p>When we do this, the tests pass.</p><p>There are a few things to note about this test:</p><p>We are using absolute imports instead of relative imports in the doctest. For example, we say <code class="literal">from stock_alerter.stock import Stock</code> instead of <code class="literal">from .stock import Stock</code>. This allows us to easily run doctests from the command line. An alternate way to run this <a id="id336" class="indexterm"/>doctest is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Windows</strong></span>: <code class="literal">python.exe -m doctest stock_alerter\__init__.py</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Linux/Mac</strong></span>: <code class="literal">python3 -m doctest stock_alerter\__init__.py</code></li></ul></div><p>This syntax only works if the file is using absolute imports. Otherwise, we'll get the error <code class="literal">SystemError: Parent module '' not loaded, cannot perform relative import</code>.</p><p>Generally, when doing package level doctests, using absolute imports is recommended.</p><p>Apart from that, some of the examples also continue across multiple lines. The following is one such example:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; alert = Alert("GOOG &gt; $3", PriceRule("GOOG", lambda s: s.price &gt; 3),\</strong></span>
<span class="strong"><strong>...               PrintAction())</strong></span>
</pre></div><p>The way to support multiple lines is just the same as in the interactive shell. End the line with a backslash <code class="literal">\</code> and start the next line with three dots <code class="literal">...</code>. This is interpreted by <code class="literal">doctest</code> as a line continuation and it will combine both lines into a single input.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>
<span class="strong"><strong>An important gotcha</strong></span>: Notice that the docstring starts with the <code class="literal">r</code> prefix, like this <code class="literal">r"""</code>. This indicates a raw string. As mentioned above, we have used the backslash in a few places to indicate continuation of input. When Python finds a backslash in a string, it interprets it as an escape character instead of a literal backslash. The solution is to either escape the backslash by putting a double backslash <code class="literal">\\</code> or to use a raw string in which no backslash interpretation is done. Rather than putting double backslashes everywhere, it is preferable to use a raw string by marking the start of the docstring with the <code class="literal">r</code> prefix.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Maintaining doctests"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec53"/>Maintaining doctests</h1></div></div></div><p>Doctests can be <a id="id337" class="indexterm"/>quite verbose, often containing a lot of explanation mixed in with the examples. These doctests can easily run into multiple pages. Sometimes, there could be many lines of doctests followed by just a few lines of code. We can see this happening in our <code class="literal">update</code> method. This can make navigating the code more difficult.</p><p>We can solve this problem by putting the doctests into a separate file. Suppose, we put the contents of the docstring into a file called <code class="literal">readme.txt</code>. We then change our <code class="literal">__init__.py</code> file like the following:</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    import doctest
    doctest.testfile("readme.txt")</pre></div><p>This will <a id="id338" class="indexterm"/>now load the contents of <code class="literal">readme.txt</code> and run it as doctests.</p><p>When writing tests in an external file, there is no need to put quotes around the contents as we would in a Python file. The entire file content is considered as doctests. Similarly, we also do not need to escape backslashes.</p><p>This feature makes it practical to just put all doctests into separate files. These files should double up as user documentation and contain the doctests in them. This way, we avoid cluttering up the actual code with pages and pages of doctrings.</p><div class="section" title="Running a suite of doctests"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec56"/>Running a suite of doctests</h2></div></div></div><p>One of the <a id="id339" class="indexterm"/>missing features of the <code class="literal">doctest</code> module is an effective autodiscovery mechanism. Unlike <code class="literal">unittest</code> that searches all files for tests and runs them, with doctest we have to execute each file explicitly on the command line. This is a big pain for large projects.</p><p>There are some ways to accomplish this, though. The most straightforward is to wrap the doctest into a <code class="literal">unittest.TestCase</code> class, like the following:</p><div class="informalexample"><pre class="programlisting">import doctest
import unittest
from stock_alerter import stock

class PackageDocTest(unittest.TestCase):
    def test_stock_module(self):
        doctest.testmod(stock)

    def test_doc(self):
        doctest.testfile(r"..\readme.txt")</pre></div><p>These doctests can then be run along with the rest of the unit tests as usual.</p><p>This works, but the problem is that the test doesn't fail if there is a failure in the doctest. The error is printed out, but it doesn't record a failure. This is okay if the tests are run manually, but causes a problem when the tests are run in an automated fashion, for example, as a part of a build or deploy process.</p><p>
<code class="literal">doctest</code> has another feature by which it can be wrapped inside a <code class="literal">unittest</code>:</p><div class="informalexample"><pre class="programlisting">import doctest
from stock_alerter import stock

def load_tests(loader, tests, pattern):
    tests.addTests(doctest.DocTestSuite(stock))
    tests.addTests(doctest.DocFileSuite("../readme.txt"))
    return tests</pre></div><p>We haven't looked <a id="id340" class="indexterm"/>at <code class="literal">load_tests</code> before, so let us take a quick look now. <code class="literal">load_tests</code> is used by the <code class="literal">unittest</code> module to load the unit tests suites from the current module. When this function is not present, <code class="literal">unittest</code> uses its default method of loading tests by looking for classes that inherit from <code class="literal">unittest.TestCase</code>. However, when this function is present, it is called and it can return a different suite of tests from the default. The returned suite is then run.</p><p>Since doctests aren't part of <code class="literal">unittest.TestCase</code>, they are not run by default when we execute the unit tests. What we do instead is implement the <code class="literal">load_tests</code> function and add the doctests to the test suite in that function. We use the <code class="literal">doctest.DocTestSuite</code> and <code class="literal">doctest.DocFileSuite</code> methods to create <code class="literal">unittest</code>-compatible test suites from the doctests. We then append these test suites to the overall tests to be executed in the <code class="literal">load_tests</code> function.</p><p>
<code class="literal">doctest.DocTestSuite</code> takes the module containing the tests as a parameter.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>Note that we have to pass in the actual module object, and not just a string.</p></div></div><p>
<code class="literal">doctest.DocFileSuite</code> takes a filename containing the doctests. The filename is relative to the current test module's directory. So, for example, if our directory structure is like the following:</p><div class="informalexample"><pre class="programlisting">src
|
+- stock_alerter
   |
   +- readme.txt
   +- tests
      |
      +- test_doctest.py</pre></div><p>Then we would use the path <code class="literal">../readme.txt</code> in <code class="literal">test_doctest.py</code> to reference this file.</p><p>Alternatively, we can specify a package name and the path can be relative to that package like the following:</p><div class="informalexample"><pre class="programlisting">tests.addTests(doctest.DocFileSuite("readme.txt",
                                    package="stock_alerter"))</pre></div></div><div class="section" title="Setup and teardown"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec57"/>Setup and teardown</h2></div></div></div><p>One of the <a id="id341" class="indexterm"/>problems with doctests is that we have to explicitly set <a id="id342" class="indexterm"/>up everything inside the docstring. For example, the following is the doctest for the <code class="literal">update</code> method that we wrote earlier:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from datetime import datetime</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; stock = Stock("GOOG")</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; stock.update(datetime(2011, 10, 3), 10)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; stock.price</strong></span>
<span class="strong"><strong>10</strong></span>
</pre></div><p>In the first line, we import the <code class="literal">datetime</code> module. This is incidental to the example and clutters it up, but we have to add it, otherwise we will get the following error:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>Failed example:</strong></span>
<span class="strong"><strong>    stock.update(datetime(2011, 10, 3), 10)</strong></span>
<span class="strong"><strong>Exception raised:</strong></span>
<span class="strong"><strong>    Traceback (most recent call last):</strong></span>
<span class="strong"><strong>       ...</strong></span>
<span class="strong"><strong>    NameError: name 'datetime' is not defined</strong></span>
</pre></div><p>Is there a way to avoid repetition of these lines? Yes, there is.</p><p>Both <code class="literal">DocFileSuite</code> and <code class="literal">DocTestSuite</code> take a <code class="literal">globs</code> parameter. This parameter takes a dictionary of items that are used for the globals of the doctests, from where they can be accessed by the examples. The following is how we would do this:</p><div class="informalexample"><pre class="programlisting">import doctest
from datetime import datetime
from stock_alerter import stock

def load_tests(loader, tests, pattern):
    tests.addTests(doctest.DocTestSuite(stock, globs={
        "datetime": datetime,
        "Stock": stock.Stock
    }))
    tests.addTests(doctest.DocFileSuite("readme.txt", package="stock_alerter"))
    return tests</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>Note that we have to pass in not only the datetime module, but also the <code class="literal">Stock</code> class. By default, <code class="literal">doctest</code> uses the module's own globals in the execution context. This is why we were able to use the <code class="literal">Stock</code> class in our doctests so far. When we replace the execution context via the <code class="literal">globs</code> parameter, then we have to explicitly set the <code class="literal">Stock</code> object to be a part of the execution context.</p></div></div><p>
<code class="literal">DocFileSuite</code> and <code class="literal">DocTestSuite</code> also take the <code class="literal">setUp</code> and <code class="literal">tearDown</code> parameters. These parameters take a function that will be called before and after each doctest. This is a good place <a id="id343" class="indexterm"/>to perform any setup or teardown of the environment<a id="id344" class="indexterm"/> that is needed by the test. The function has also passed a <code class="literal">DocTest</code> object, which can be used during setup and teardown. The <code class="literal">DocTest</code> object has many attributes, but the one most commonly used is the <code class="literal">globs</code> attribute. This is the dictionary of the execution context and it can be added to in the setup to instantiate objects that will be reused between objects. The following is an example of such a use:</p><div class="informalexample"><pre class="programlisting">import doctest
from datetime import datetime
from stock_alerter import stock

def setup_stock_doctest(doctest):
    s = stock.Stock("GOOG")
    doctest.globs.update({"stock": s})

def load_tests(loader, tests, pattern):
    tests.addTests(doctest.DocTestSuite(stock, globs={
        "datetime": datetime,
        "Stock": stock.Stock
    }, setUp=setup_stock_doctest))
    tests.addTests(doctest.DocFileSuite("readme.txt", package="stock_alerter"))
    return tests</pre></div><p>By instantiating and passing in the stock to the doctests, we can remove the need to instantiate it in the individual tests, so the test was initially like the following:</p><div class="informalexample"><pre class="programlisting">    def is_increasing_trend(self):
        """Returns True if the past three values have been strictly
        increasing

        Returns False if there have been less than three updates so far

        &gt;&gt;&gt; stock = Stock("GOOG")
        &gt;&gt;&gt; stock.is_increasing_trend()
        False
        """</pre></div><p>Now the test becomes the following:</p><div class="informalexample"><pre class="programlisting">    def is_increasing_trend(self):
        """Returns True if the past three values have been strictly
        increasing

        Returns False if there have been less than three updates so far

        &gt;&gt;&gt; stock.is_increasing_trend()
        False
        """</pre></div><p>Why do we <a id="id345" class="indexterm"/>instantiate and pass in <code class="literal">stock</code> via the <code class="literal">setUp</code> function <a id="id346" class="indexterm"/>instead of using the <code class="literal">glob</code> parameter? The reason is because we want a new instance of <code class="literal">Stock</code> for each of the tests. Since <code class="literal">setUp</code> and <code class="literal">tearDown</code> are called before each test, a new instance of stock is added to <code class="literal">doctest.glob</code> each time.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Limitations of doctest"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec54"/>Limitations of doctest</h1></div></div></div><p>The biggest limitation of <code class="literal">doctest</code> is that it only compares printed output. This means that any output<a id="id347" class="indexterm"/> that could be variable will lead to test failures. The following is an example:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; exchange</strong></span>
<span class="strong"><strong>{'GOOG': &lt;stock_alerter.stock.Stock object at 0x00000000031F8550&gt;, 'AAPL': &lt;stock_alerter.stock.Stock object at 0x00000000031F8588&gt;}</strong></span>
</pre></div><p>This doctest has the potential to fail for two reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The order in which a dictionary object is printed out is not guaranteed by Python, which means it could be printed out in the opposite order, sometimes leading to failure</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Stock</code> object might be at a different address each time, so that part will fail to match the next time the test is run</li></ul></div><p>The solution to the first problem is to ensure that the output is deterministic. For example, the following approach will work:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; for key in sorted(exchange.keys()):</strong></span>
<span class="strong"><strong>...    print(key, exchange[key])</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>AAPL &lt;stock_alerter.stock.Stock object at 0x00000000031F8550&gt;</strong></span>
<span class="strong"><strong>GOOG &lt;stock_alerter.stock.Stock object at 0x00000000031F8588&gt;</strong></span>
</pre></div><p>There is still the<a id="id348" class="indexterm"/> issue of the object address, though. To solve this, we need to use doctest directives.</p><div class="section" title="Doctest directives"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec58"/>Doctest directives</h2></div></div></div><p>
<code class="literal">doctest</code> supports a <a id="id349" class="indexterm"/>number of directives that change the behavior of the <a id="id350" class="indexterm"/>module.</p><p>The first directive that we will look at is <code class="literal">ELLIPSIS</code>. This directive allows us to use three dots <code class="literal">...</code> to match any text. We can use this to match the object address, as in the following:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; for key in sorted(exchange.keys()): #doctest: +ELLIPSIS</strong></span>
<span class="strong"><strong>...    print(key, exchange[key])</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>AAPL &lt;stock_alerter.stock.Stock object at 0x0...&gt;</strong></span>
<span class="strong"><strong>GOOG &lt;stock_alerter.stock.Stock object at 0x0...&gt;</strong></span>
</pre></div><p>The example will now pass.</p><p>
<code class="literal">...</code> will match whatever address is printed at runtime. We enable the directive by adding the comment <code class="literal">#doctest: +ELLIPSIS</code> to the example. This will turn on the directive for this example only. Subsequent examples in the same doctest will have it off unless it is specifically turned on for them.</p><p>Some other commonly used directives are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">NORMALIZE_WHITESPACE</code>: By default, doctest matches whitespace exactly. A space <a id="id351" class="indexterm"/>will not match with a tab, and newlines will not match unless they are at the exact same places. Sometimes, we might want to prettify the expected output by wrapping lines or indenting them so that they are easier to read. In such cases, the <code class="literal">NORMALIZE_WHITESPACE</code> directive can be set so that doctest will treat all counts of whitespace as equal.</li><li class="listitem" style="list-style-type: disc"><code class="literal">IGNORE_EXCEPTION_DETAIL</code>: When matching exceptions, <code class="literal">doctest</code> looks at both the<a id="id352" class="indexterm"/> type of exception as well as the exception message. When this directive is enabled, only the type is checked for a match.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SKIP</code>: An<a id="id353" class="indexterm"/> example with this directive is skipped completely. This may be because the documentation is intentionally showing an example that doesn't work or one whose output is random. It can also be used to comment out doctests that aren't working.</li><li class="listitem" style="list-style-type: disc"><code class="literal">REPORT_ONLY_FIRST_FAILURE</code>: <code class="literal">doctest</code> by default continues to execute subsequent<a id="id354" class="indexterm"/> examples after a failure, and will report failures in those as well. Many times, failure in one of the examples causes subsequent failures in following examples<a id="id355" class="indexterm"/> and can cause many error reports, making it harder to identify the first example to fail that caused all the other failures. This directive will only report the first failure.</li></ul></div><p>This is not <a id="id356" class="indexterm"/>a comprehensive list of directives, but they cover the most commonly used ones.</p><p>Multiple directives can be given on separate lines or separated by commas. The following will work:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; for key in sorted(exchange.keys()):</strong></span>
<span class="strong"><strong>...    print(key, exchange[key])</strong></span>
<span class="strong"><strong>...    #doctest: +ELLIPSIS</strong></span>
<span class="strong"><strong>...    #doctest: +NORMALIZE_WHITESPACE</strong></span>
<span class="strong"><strong>AAPL       &lt;stock_alerter.stock.Stock object at 0x0...&gt;</strong></span>
<span class="strong"><strong>GOOG       &lt;stock_alerter.stock.Stock object at 0x0...&gt;</strong></span>
</pre></div><p>Or, the following can also work:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; for key in sorted(exchange.keys()):</strong></span>
<span class="strong"><strong>...    print(key, exchange[key])</strong></span>
<span class="strong"><strong>...    #doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</strong></span>
<span class="strong"><strong>AAPL       &lt;stock_alerter.stock.Stock object at 0x0...&gt;</strong></span>
<span class="strong"><strong>GOOG       &lt;stock_alerter.stock.Stock object at 0x0...&gt;</strong></span>
</pre></div><p>Directives can also be passed via the <code class="literal">optionflags</code> parameter to <code class="literal">DocFileSuite</code> and <code class="literal">DocTestSuite</code>. The directives take effect for the entire file or module when passed in the following way:</p><div class="informalexample"><pre class="programlisting">options = doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE
tests.addTests(doctest.DocFileSuite("readme.txt",
                                    package="stock_alerter",
                                    optionflags=options))</pre></div><p>In the doctest, we can then turn off certain directives as needed, as shown in the following:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; for key in sorted(exchange.keys()):</strong></span>
<span class="strong"><strong>...    print(key, exchange[key])</strong></span>
<span class="strong"><strong>... #doctest: -NORMALIZE_WHITESPACE</strong></span>
<span class="strong"><strong>AAPL &lt;stock_alerter.stock.Stock object at 0x0...&gt;</strong></span>
<span class="strong"><strong>GOOG &lt;stock_alerter.stock.Stock object at 0x0...&gt;</strong></span>
</pre></div><p>Using directives is a good way to selectively enable or disable specific behavior on doctests.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="How do doctests fit into the TDD process?"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec55"/>How do doctests fit into the TDD process?</h1></div></div></div><p>Now that we have a pretty good idea of doctests, the next question is: how does this fit into the TDD process? Remember, in the TDD process, we write the test first, and then the implementation later. Do doctests fit in with this process?</p><p>In a way, yes. Doctests are not a particularly good fit for doing TDD for single methods. The <code class="literal">unittest</code> module<a id="id357" class="indexterm"/> is a better choice for<a id="id358" class="indexterm"/> those. Where <code class="literal">doctest</code> shines is at package-level interaction. Explanations interspersed with examples really bring out interaction between different modules and classes within the package. Such doctests can be written out at the beginning, giving a high-level overview of how we want the package as a whole to work. These tests will fail. As individual classes and methods are written, the tests will start to pass.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec56"/>Summary</h1></div></div></div><p>In this chapter, you took a look at Python's <code class="literal">doctest</code> module. You saw how it helps you embed examples within docstrings. You looked at different ways to write doctests including method and package docstrings. You also looked at moving package level doctests into a separate file and running them. Maintaining doctests is important, and you looked at ways to maintain doctests better, using setup and teardown and including them in the regular test suite. Finally, you looked at some limitations and how you can use directives to overcome some of the limitations.</p><p>In the next chapter, you will get your first introduction to third-party tools with a look at the <code class="literal">nose2</code> package.</p></div></div>
</body></html>