- en: '*Chapter 17*: The Builder Pattern'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered the first two creational patterns—the factory
    method and abstract factory, both of which offer approaches to improve the way
    we create objects in nontrivial cases. The builder design pattern, on the other
    hand, as we'll discuss in this chapter, is useful for managing objects that consist
    of multiple parts that need to be implemented sequentially. By decoupling the
    construction of an object and its representation, the builder pattern allows us
    to reuse a construction multiple times.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Just as with the previous chapter, we will discuss real-life applications that
    use this design pattern as well as implementing a hands-on example ourselves.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the builder pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-world examples
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an ordering application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, we will understand how to use the builder pattern
    and its practical benefits.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be accessed through this link:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter17](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter17)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the builder pattern
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that we want to create an object that is composed of multiple parts
    and the composition needs to be done step by step. The object is not complete
    unless all its parts are fully created. That's where the **builder-design pattern**
    can help us. The builder pattern separates the construction of a complex object
    from its representation. By keeping the construction separate from the representation,
    the same construction can be used to create several different representations
    ([j.mp/builderpat](http://j.mp/builderpat)).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'A practical example can help us understand what the purpose of the builder
    pattern is. Suppose that we want to create a `<html>` and finishes with `</html>`;
    inside the HTML section are the `<head>` and `</head>` elements; inside the head
    section are the `<title>` and `</title>` elements; and so forth. But the representation
    of the page can differ. Each page has its own title, its own headings, and different
    `<body>` contents. Moreover, the page is usually built in steps: one function
    adds the title, another adds the main heading, another the footer, and so on.
    Only after the whole structure of a page is complete can it be shown to the client
    using a final render function. We can take it even further and extend the HTML
    generator so that it can generate totally different HTML pages. One page might
    contain tables, another page might contain image galleries, yet another page contains
    the contact form, and so on.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML page-generation problem can be solved using the builder pattern. In
    this pattern, there are two main participants, outlined as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '**The builder**: The component responsible for creating the various parts of
    a complex object. In this example, these parts are the title, heading, body, and
    the footer of the page.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`builder` instance. It calls the builder''s functions for setting the title,
    the heading, and so on, and using a different `builder` instance allows us to
    create a different HTML page without touching any of the code of the director.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, let's discuss in the next section some real-life examples where this
    pattern applies.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our everyday life, the *builder design pattern* is used in fast-food restaurants.
    The same procedure is always used to prepare a burger and the packaging (box and
    paper bag), even if there are many different kinds of burgers (classic, cheeseburger,
    and more) and different packages (small-sized box, medium-sized box, and so forth).
    The difference between a classic burger and a cheeseburger is in the representation,
    and not in the construction procedure. In this case, the **director** is the cashier
    who gives the crew instructions about what needs to be prepared, and the **builder**
    is the person from the crew that takes care of a specific order.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also find software examples, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The HTML example that was mentioned at the beginning of the chapter is actually
    used by `django-widgy` ([https://wid.gy/](https://wid.gy/)), a third-party tree
    editor for Django that can be used as a `django-widgy` editor contains a page
    builder that can be used for creating HTML pages with different layouts.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `django-query-builder` library ([https://github.com/ambitioninc/django-query-builder](https://github.com/ambitioninc/django-query-builder))
    is another third-party Django library that relies on the builder pattern. This
    library can be used for building **Structured Query Language** (**SQL**) queries
    dynamically, allowing you to control all aspects of a query and create a different
    range of queries, from simple to very complex ones.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will see how this design pattern actually works.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use the builder pattern when we know that an object must be created in multiple
    steps, and different representations of the same construction are required. These
    requirements exist in many applications, such as page generators (for example,
    the HTML page generator mentioned in this chapter), document converters, and **user
    interface** (**UI**) form creators ([j.mp/pipbuild](http://j.mp/pipbuild)).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Some online resources mention that the builder pattern can also be used as
    a solution to the telescopic constructor problem. The telescopic constructor problem
    occurs when we are forced to create a new constructor for supporting different
    ways of creating an object. The problem is that we end up with many constructors
    and long parameter lists that are hard to manage. An example of the telescopic
    constructor is listed on the Stack Overflow website ([j.mp/sobuilder](http://j.mp/sobuilder)).
    Fortunately, this problem does not exist in Python, because it can be solved in
    at least two ways, as outlined here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: With named parameters that define different behaviors in the constructor of
    the class ([j.mp/sobuipython](http://j.mp/sobuipython))
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With argument list unpacking, which is similar in spirit to named parameters
    ([j.mp/arglistpy](http://j.mp/arglistpy))
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These features that are specific to Python help us control the behavior of its
    code easily, thus avoiding the problem we described previously.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the distinction between the builder pattern and the factory pattern
    might not be very clear. The main difference is that the factory pattern creates
    an object in a single step, whereas the builder pattern creates an object in multiple
    steps, and almost always through the use of a director. Some targeted implementations
    of the builder pattern, such as Java's `StringBuilder`, bypass the use of a director,
    but that's the exception to the rule.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Another difference is that while the factory pattern returns a created object
    immediately, in the builder pattern the client code explicitly asks the director
    to return the final object when it needs it ([j.mp/builderpat](http://j.mp/builderpat)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'The new computer analogy might help you to distinguish between the builder
    pattern and the factory pattern. Assume that you want to buy a new computer. If
    you decide to buy a specific, preconfigured computer model—for example, the latest
    Apple 1.4 `apple_factory.py`):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we add the main part of the program—the snippet that uses the `AppleFactory`
    class. The code is illustrated here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Notice the nested `MacMini14` class. This is a neat way of forbidding the direct
    instantiation of a class.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option would be to buy a custom PC. In this case, you use the builder
    pattern. You are the director who gives orders to the manufacturer (`builder`)
    about your ideal computer specifications. Code-wise, this is how it looks (`computer_builder.py`):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a `Computer` class, as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We define a `ComputerBuilder` class, as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We define a `HardwareEngineer` class, as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We end our code with the `main()` function, followed by a trick to call it
    when the file is called from the command line, as illustrated in the following
    code snippet:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The basic changes are the introduction of a builder (`ComputerBuilder`), a director
    (`HardwareEngineer`), and the step-by-step construction of a computer, which now
    supports different configurations (notice that `memory`, `hdd`, and `gpu` are
    parameters and are not preconfigured). What do we need to do if we want to support
    the construction of tablets? Implement this as an exercise.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: You might also want to change the computer's `serial_number` value into something
    different for each computer because as it is now, this means that all computers
    will have the same serial number (which is impractical).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an ordering application
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's see how we can use the builder design pattern to make a pizza-ordering
    application. The pizza example is particularly interesting because a pizza is
    prepared in steps that should follow a specific order. To add the sauce, you first
    need to prepare the dough. To add the topping, you first need to add the sauce.
    And you can't start baking the pizza unless both the sauce and the topping are
    placed on the dough. Moreover, each pizza usually requires a different baking
    time, depending on the thickness of its dough and the topping used.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by importing the required modules and declaring a few `Enum` parameters
    ([j.mp/pytenum](http://j.mp/pytenum)) plus a constant that is used many times
    in the application. The `STEP_DELAY` constant is used to add a time delay between
    the different steps of preparing a pizza (prepare the dough, add the sauce, and
    so on), as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our end product is a pizza, which is described by the `Pizza` class. When using
    the builder pattern, the end product does not have many responsibilities since
    it is not supposed to be instantiated directly. A builder creates an instance
    of the end product and makes sure that it is properly prepared. That's why the
    `Pizza` class is so minimal. It basically initializes all data to sane default
    values. An exception is the `prepare_dough()` method.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The `prepare_dough()` method is defined in the `Pizza` class instead of a builder
    for two reasons—first, to clarify the fact that the end product is typically minimal,
    which does not mean that you should never assign it any responsibilities; second,
    to promote code reuse through composition.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we define our `Pizza` class as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are two builders: one for creating a margarita pizza (`MargaritaBuilder`)
    and another for creating a creamy bacon pizza (`CreamyBaconBuilder`). Each builder
    creates a `Pizza` instance and contains methods that follow the pizza-making procedure:
    `prepare_dough()`, `add_sauce()`, `add_topping()`, and `bake()`. To be precise,
    `prepare_dough()` is just a wrapper to the `prepare_dough()` method of the `Pizza`
    class.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Notice how each builder takes care of all the pizza-specific details. For example,
    the topping of the margarita pizza is double mozzarella and oregano, while the
    topping of the creamy bacon pizza is mozzarella, bacon, ham, mushrooms, red onion,
    and oregano.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'This part of our code is laid out as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a `MargaritaBuilder` class, as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We define a `CreamyBaconBuilder` class, as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The director in this example is the waiter. The core of the `Waiter` class
    is the `construct_pizza()` method, which accepts a `builder` as a parameter and
    executes all the pizza-preparation steps in the right order. Choosing the appropriate
    builder, which can even be done at runtime, gives us the ability to create different
    pizza styles without modifying any of the code of the director (`Waiter`). The
    `Waiter` class also contains the `pizza()` method, which returns the end product
    (prepared pizza) as a variable to the caller, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `validate_style()` function is similar to the `validate_age()` function,
    as described in [*Chapter 16*](B17499_16_Final_SS_ePub.xhtml#_idTextAnchor276),
    *The Factory Pattern*. It is used to make sure that the user gives valid input,
    which in this case is a character that is mapped to a pizza builder. The `m` character
    uses the `MargaritaBuilder` class, and the `c` character uses the `CreamyBaconBuilder`
    class. These mappings are in the builder parameter. A tuple is returned, with
    the first element set to `True` if the input is valid or `False` if it is invalid,
    as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The last part is the `main()` function. The `main()` function contains code
    for instantiating a pizza builder. The pizza builder is then used by the `Waiter`
    director for preparing the pizza. The created pizza can be delivered to the client
    at any later point. The code is illustrated in the following snippet:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is a summary of the implementation (see the complete code in the `builder.py`
    file):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: We start with a couple of imports we need, for the standard `Enum` class and
    the `time` module.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We declare variables for a few constants: `PizzaProgress`, `PizzaDough`, `PizzaSauce`,
    `PizzaTopping`, and `STEP_DELAY`.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define our `Pizza` class.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define classes for two builders, `MargaritaBuilder` and `CreamyBaconBuilder`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define our `Waiter` class.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add the `validate_style()` function to improve things regarding exception
    handling.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we have the `main()` function, followed by the snippet for calling
    it when the program is run. In the `main` function, the following happens:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We make it possible to choose the pizza builder based on the user's input, after
    validation via the `validate_style()` function.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The pizza builder is used by the waiter for preparing the pizza.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The created pizza is then delivered.
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the output produced by calling the `python builder.py` command to execute
    this example program:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'But…supporting only two pizza types is a shame. Feel like getting a Hawaiian
    pizza builder? Consider using inheritance after thinking about the advantages
    and disadvantages. Check the ingredients of a typical Hawaiian pizza and decide
    which class you need to extend: `MargaritaBuilder` or `CreamyBaconBuilder`? Perhaps
    both ([j.mp/pymulti](http://j.mp/pymulti))?'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'In his book, *Effective Java (Second Edition)*, Joshua Bloch describes an interesting
    variation of the builder pattern where calls to builder methods are chained. This
    is accomplished by defining the builder itself as an inner class and returning
    itself from each of the setter-like methods on it. The `build()` method returns
    the final object. This pattern is called the **fluent builder**. Here''s a Python
    implementation, which was kindly provided by a reviewer of the book:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的书《有效Java（第二版）》中，Joshua Bloch描述了一种有趣的构建器模式变体，其中构建器方法的调用是链式的。这是通过将构建器本身定义为内部类，并从其上的每个setter-like方法返回自身来实现的。`build()`方法返回最终对象。这种模式被称为**流畅构建器**。以下是一个Python实现，这是由本书的一位审稿人友好地提供的：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this fluent builder pattern, we see that we could quickly build the final
    `Pizza` object by chaining the `add_garlic()`, `add_extra_cheese()`, and `build()`
    methods on one line of code, which could come in handy in many situations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种流畅的构建器模式，我们可以看到，通过在一行代码中链式调用`add_garlic()`、`add_extra_cheese()`和`build()`方法，可以快速构建最终的`Pizza`对象，这在许多情况下都很有用。
- en: Summary
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how to use the builder design pattern. We use
    the builder pattern for creating an object in situations where using the factory
    pattern (either a factory method or an abstract factory) is not a good option.
    The builder pattern is usually a better candidate than the factory pattern when
    we want to create a complex object, when different representations of an object
    are required, or when we want to create an object at one point in time but access
    it at a later point.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用构建器设计模式。当使用工厂模式（无论是工厂方法还是抽象工厂）不是一个好选择时，我们使用构建器模式来创建对象。当我们想要创建一个复杂对象，需要对象的不同表示，或者我们想要在某个时间点创建对象但在稍后访问它时，构建器模式通常比工厂模式是一个更好的选择。
- en: We saw how the builder pattern is used in fast-food restaurants for preparing
    meals, and how two third-party Django packages, `django-widgy` and `django-query-builder`,
    use it for generating HTML pages and dynamic SQL queries, respectively. We focused
    on the differences between the builder pattern and the factory pattern and provided
    a preconfigured (factory) and customer (builder) computer order analogy to clarify
    them. We also looked at how to create a pizza-ordering application with preparation
    dependencies. Throughout these examples, we have clearly seen the benefits and
    flexibility of the builder pattern, which will help you better approach future
    applications that require the design pattern.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了构建器模式如何在快餐店准备餐点时使用，以及两个第三方Django包`django-widgy`和`django-query-builder`如何分别用于生成HTML页面和动态SQL查询。我们关注了构建器模式和工厂模式之间的区别，并提供了预配置（工厂）和客户（构建器）计算机订单类比来澄清它们。我们还探讨了如何创建一个具有准备依赖关系的比萨订购应用程序。在这些示例中，我们清楚地看到了构建器模式的好处和灵活性，这将帮助你更好地处理未来需要设计模式的应用程序。
- en: In the next chapter, you will learn about other useful creational patterns.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习其他有用的创建型模式。
- en: Questions
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the high-level applications of the builder pattern?
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建器模式有哪些高级应用？
- en: What are some common computer applications that require or benefit from the
    builder pattern?
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪些常见的计算机应用程序需要或从构建器模式中受益？
- en: How does the builder pattern create an object and how is that process different
    from what the factory pattern does?
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建器模式是如何创建对象的，以及这个过程与工厂模式有何不同？
