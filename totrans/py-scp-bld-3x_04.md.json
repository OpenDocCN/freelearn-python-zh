["```py\nimport bpy\nbpy.context.object.location = 1.0, 2.0, 3.0\n```", "```py\nimport bpy\nbpy.context.object.location.xyz = 1.0, 2.0, 3.0\n```", "```py\nimport bpy\nbpy.context.object.location[0] = 1.0\nbpy.context.object.location[1] = 2.0\nbpy.context.object.location[2] = 3.0\n```", "```py\nimport bpy\nbpy.context.object.location.x = 1.0\nbpy.context.object.location.y = 2.0\nbpy.context.object.location.z = 3.0\n```", "```py\n>>> bpy.context.object.scale\nVector((1.0, 1.0, 1.0))\n```", "```py\nimport bpy\nbpy.context.object.scale.xyz = 3.0, 2.0, 1.0\n```", "```py\nimport bpy\nbpy.context.object.scale.xyz = 3.0\n```", "```py\n>>> import bpy\n>>> bpy.context.object.rotation_mode = \"this won't work\"\nTypeError: bpy_struct: item.attr = val: enum \"this won't work\" not found in ('QUATERNION', 'XYZ', 'XZY', 'YXZ', 'YZX', 'ZXY', 'ZYX', 'AXIS_ANGLE')\n```", "```py\n>>> from math import radians, degrees, pi\n>>> degrees(2 * pi)\n360.0\n>>> radians(360)\n6.283185307179586\n```", "```py\nimport bpy\nob = bpy.context.object\n# apply a 90 degrees on X axis rotation using Quaternions\nob.rotation_mode = 'QUATERNION'\nob.rotation_quaternion.w = 0.707107\nob.rotation_quaternion.x = 0.707107\nob.rotation_quaternion.y = 0.0\nob.rotation_quaternion.z = 0.0\n# apply a 90 degrees on X axis rotation using Eulers\nob.rotation_mode = 'XYZ'\nob.rotation_euler.x = radians(90)\nob.rotation_euler.y = 0.0\nob.rotation_euler.z = 0.0\n# apply a 90 degrees on X axis rotation using Axis Angle\nob.rotation_mode = 'AXIS_ANGLE'\nob.rotation_axis_angle[0] = radians(90)\nob.rotation_axis_angle[1] = 1\nob.rotation_axis_angle[1] = 0\nob.rotation_axis_angle[1] = 0\n```", "```py\nfrom mathutils import Euler\n# create a 90 degrees rotation Euler\nrot_90x_eu = Euler((radians(90), 0, 0))\n# convert to quaternion\nrot_90x_quat = rot_90x_eu.to_quaternion()\n# convert to axis angle\nrot_90x_aa = rot_90x_quat.to_axis_angle()\n```", "```py\n>>> import bpy\n>>> bpy.context.object.constraints.new(\"this won't work\")\nTypeError: ObjectConstraints.new(): error with keyword argument \"type\" -  enum \" this won't work \" not found in ('CAMERA_SOLVER', 'FOLLOW_TRACK', 'OBJECT_SOLVER', 'COPY_LOCATION', 'COPY_ROTATION', 'COPY_SCALE', 'COPY_TRANSFORMS', 'LIMIT_DISTANCE', 'LIMIT_LOCATION', ...\n```", "```py\nimport bpy\nob = bpy.context.object\nlimit = ob.constraints.new(type='LIMIT_SCALE')\nlimit.use_max_z = True  # limit the height only\nlimit.max_z = 0.5\n```", "```py\nimport bpy\nprevious = bpy.data.objects[0]\nfor ob in bpy.data.objects[1:]:\n    # parent each object under its predecessor\n    ob.parent = previous\n    previous = ob\nfor ob in bpy.data.objects:\n    # now print out the children of each object\n    print(ob.name)\n    child_names = (c.name for c in ob.children)\n    print(\"\\tchildren:\", \", \".join(child_names))\n    child_names = (c.name for c in ob.children_recursive)\n    print(\"\\tchildren recursive:\", \", \".join(child_names))\n    print(\"\")\n```", "```py\nCamera\n        children: Cube\n        children recursive: Cube, Light\nCube\n        children: Light\n        children recursive: Light\nLight\n        children:\n        children recursive:\n```", "```py\n>>> from mathutils import Matrix\n>>> Matrix()\nMatrix(((1.0, 0.0, 0.0, 0.0),\n        (0.0, 1.0, 0.0, 0.0),\n        (0.0, 0.0, 1.0, 0.0),\n        (0.0, 0.0, 0.0, 1.0)))\n```", "```py\n>>> bpy.context.object.matrix_\n                              basis\n                              local\n                              parent_inverse\n                              world\n```", "```py\n>>> a = 4\n>>> b = a\n>>> a += 1\n>>> print(b)\n4\n```", "```py\n>>> a = [4]\n>>> b = a\n>>> a[0] += 1\n>>> print(b)\n[5]\n```", "```py\n# two variables pointing to the same matrix\nmatrix_b = matrix_a  # matrix_b ALWAYS equals matrix_a\n```", "```py\n# deep copy of a matrix\nmatrix_b = matrix_a.copy()  # matrix_b stores its values\n```", "```py\nimport bpy\nprevious = bpy.data.objects[0]\nfor ob in bpy.data.objects[1:]:\n    # store a copy of the world mat\n    w_mat = ob.matrix_world.copy()  # .copy() is important!\n    # parent each object under its predecessor\n    ob.parent = previous\n    # restore world position\n    ob.matrix_world = w_mat\n    # set current object as parent of the next\n    previous = ob\n```", "```py\nimport bpy\nprevious = bpy.data.objects[0]\nfor ob in bpy.data.objects[1:]:\n    # parent each object under its predecessor\n    ob.parent = previous\n    # set parent inverse offset\n    offset_matrix = previous.matrix_world.inverted()\n    ob.matrix_parent_inverse = offset_matrix\n    # set current object as parent of the next\n    previous = ob\n```", "```py\nbl_info = {\n    \"name\": \"Elevator\",\n    \"author\": \"John Doe\",\n    \"version\": (1, 0),\n    \"blender\": (3, 00, 0),\n    \"description\": \"Move objects up to a minimum height\",\n    \"category\": \"Object\",\n}\n```", "```py\n    class OBJECT_OT_elevator(bpy.types.Operator):\n    ```", "```py\n        \"\"\"Move Objects up to a given height\"\"\"\n    ```", "```py\n        bl_idname = \"object.pckt_floor_transform\"\n    ```", "```py\n        bl_label = \"Elevate Objects\"\n    ```", "```py\n        floor = 5.0\n    ```", "```py\n        @classmethod\n    ```", "```py\n        def poll(cls, context):\n    ```", "```py\n            return len(bpy.context.selected_objects) > 0\n    ```", "```py\n        def execute(self, context):\n    ```", "```py\n            for ob in context.selected_objects:\n    ```", "```py\n                if ob.location.z > self.floor:\n    ```", "```py\n                    continue\n    ```", "```py\n                ob.location.z = self.floor\n    ```", "```py\n            return {'FINISHED'}\n    ```", "```py\n    def draw_elevator_item(self, context):\n    ```", "```py\n        # Menu draw function\n    ```", "```py\n        row = self.layout.row()\n    ```", "```py\n        row.operator(OBJECT_OT_elevator.bl_idname)\n    ```", "```py\n    def register():\n    ```", "```py\n        # add operator and menu item\n    ```", "```py\n        bpy.utils.register_class(OBJECT_OT_elevator)\n    ```", "```py\n        object_menu = bpy.types.VIEW3D_MT_object_context_menu\n    ```", "```py\n        object_menu.append(draw_elevator_item)\n    ```", "```py\n    def unregister():\n    ```", "```py\n        # remove operator and menu item\n    ```", "```py\n        bpy.utils.unregister_class(OBJECT_OT_elevator)\n    ```", "```py\n        object_menu = bpy.types.VIEW3D_MT_object_context_menu\n    ```", "```py\n        object_menu.remove(draw_elevator_item)\n    ```", "```py\n    import bpy\n    ```", "```py\n    from bpy.props import FloatProperty\n    ```", "```py\nclass OBJECT_OT_elevator(bpy.types.Operator):\n    \"\"\"Move Objects up or down by given offset\"\"\"\n    bl_idname = \"object.pckt_type_collector\"\n    bl_label = \"Create Type Collections\"\n    bl_options = {'REGISTER', 'UNDO'}\n    floor: FloatProperty(name=\"Floor\", default=0)\n```", "```py\n    def execute(self, context):\n        selected_objects = context.selected_objects\n        for ob in selected_objects:\n            matrix_world = ob.matrix_world\n            if matrix_world[2][3] > self.floor:\n                continue\n            matrix_world[2][3] = self.floor\n            # make sure next object matrix will be updated\n            context.view_layer.update()\n        return {'FINISHED'}\n```", "```py\nfrom copy import copy\n```", "```py\nselected_objects = context.selected_objects\n```", "```py\nselected_objects = copy(context.selected_objects)\n```", "```py\ndef ancestors_count(ob):\n    \"\"\"Return number of objects up in the hierarchy\"\"\"\n    ancestors = 0\n    while ob.parent:\n        ancestors += 1\n        ob = ob.parent\n    return ancestors\n```", "```py\n    def execute(self, context):\n        # sort parent objects first\n        selected_objects = copy(context.selected_objects)\n        selected_objects.sort(key=ancestors_count)\n        for ob in selected_objects:\n            world_mat = ob.matrix_world\n            if world_mat[2][3] > self.floor:\n                continue\n            # ensure update of next object's matrix\n            world_mat[2][3] = self.floor\n        return {'FINISHED'}\n```", "```py\n    from bpy.props import BoolProperty\n    ```", "```py\n    class OBJECT_OT_elevator(bpy.types.Operator):\n    ```", "```py\n        \"\"\"Move Objects up or down by given offset\"\"\"\n    ```", "```py\n        bl_idname = \"object.pckt_type_collector\"\n    ```", "```py\n        bl_label = \"Create Type Collections\"\n    ```", "```py\n        bl_options = {'REGISTER', 'UNDO'}\n    ```", "```py\n        floor: FloatProperty(name=\"Floor\", default=0)\n    ```", "```py\n        constr: BoolProperty(name=\"Constraints\", default=False)\n    ```", "```py\n    def execute(self, context):\n    ```", "```py\n        if self.constr:\n    ```", "```py\n            for ob in context.selected_objects:\n    ```", "```py\n                limit = ob.constraints.new('LIMIT_LOCATION')\n    ```", "```py\n                limit.use_min_z = True\n    ```", "```py\n                limit.min_z = self.floor\n    ```", "```py\n            return {'FINISHED'}\n    ```", "```py\n        # affect coordinates directly\n    ```", "```py\n        # sort parent objects first\n    ```", "```py\n        …\n    ```", "```py\n    reuse: BoolProperty(name=\"Reuse Constraints\", default=True)\n    ```", "```py\ndef get_constraint(ob, constr_type, reuse=True):\n    \"\"\"Return first constraint of given type.\n    If not found, a new one is created\"\"\"\n    if reuse:\n        for constr in ob.constraints:\n            if constr.type == constr_type:\n                return constr\n    return ob.constraints.new(constr_type)\n```", "```py\n    def execute(self, context):\n    ```", "```py\n        if self.constr:\n    ```", "```py\n            for ob in context.selected_objects:\n    ```", "```py\n                limit = get_constraint(ob,\n    ```", "```py\n                                      'LIMIT_LOCATION',\n    ```", "```py\n                                       self.reuse)\n    ```", "```py\n                limit.use_min_z = True\n    ```", "```py\n                limit.min_z = self.floor\n    ```", "```py\n            return {'FINISHED'}\n    ```", "```py\n        …\n    ```"]