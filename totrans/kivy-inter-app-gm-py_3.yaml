- en: Chapter 3. Widget Events – Binding Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to integrate actions into the **Graphical
    User Interface** (**GUI**) components; some of the actions will be associated
    with the canvas and others with the `Widget` management. We will learn how to
    handle events dynamically in order to make the application respond to the user
    interactions. In this chapter, you will acquire the following skills:'
  prefs: []
  type: TYPE_NORMAL
- en: Reference different parts of the GUI through IDs and properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Override, bind, unbind, and create Kivy events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add widgets to other widgets dynamically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add vertex and context instructions to the canvas dynamically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Translate relative and absolute coordinates between a widget, its parent, and
    its window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use properties to keep the GUI updated with the changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is an exciting chapter because our application will start interacting with
    the user applying the concepts acquired in the previous two chapters. All the
    basic functionality of our *Comic Creator* project will be ready by the end. This
    includes shapes that can be dragged, sizeable circles, and lines, clearing the
    widget space, removing the last added figure, grouping several widgets to drag
    them together, and keeping the *status bar* updated about the last actions of
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes, ID, and root
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](ch01.html "Chapter 1. GUI Basics – Building an Interface"),
    *GUI Basics – Building an Interface*, we distinguished between four main components
    for our *Comic Creator*: *tool box*, *drawing space*, *general options*, and *status
    bar*. In this chapter, we will make these components interact with each other
    and, therefore, we need to add some attributes to the classes of the project we
    created in the previous chapters. These attributes will reference different parts
    of the interface so that they can communicate. For example, the `ToolBox` class
    needs to have a reference to the `DrawingSpace` instance, so the `ToolButton`
    instances can draw their respective figures inside it. The following diagram shows
    all the relationships that are created in the `comiccreator.kv` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Attributes, ID, and root](img/B04244_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Internal References of the *Comic Creator*
  prefs: []
  type: TYPE_NORMAL
- en: We also learned in [Chapter 1](ch01.html "Chapter 1. GUI Basics – Building an
    Interface"), *GUI Basics – Building an Interface,* that **ID** lets us reference
    other widgets in the Kivy language.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The IDs are only meant to be used within the Kivy language. Therefore, we need
    to create attributes in order to reference the elements inside the Python code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the `comiccreator.kv` file of the *Comic Creator* project with
    some modifications to create the necessary IDs and attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The IDs in lines 7, 16, 29, and 35 have been added to the comiccreator.kv. Following
    the previous diagram (Internal References of the *Comic Creator*), the IDs are
    used to create the attributes in lines 8, 17, 18, 19, and 30.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The names of the attributes and IDs don't have to be different. In the previous
    code, we just added '_' to the IDs to distinguish them from the attributes. That
    is to say, the `_status_bar` ID, is only accessible within the `.kv` files, and
    the `status_bar` attribute, is intended to be used inside the Python code. Both
    could have had the same name without causing any conflict.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, line 8 created the attribute `drawing_space`, which references
    the `DrawingSpace` instance. This means that the `ToolBox` (line 6) instance can
    now access the `DrawingSpace` instance in order to draw figures on it.
  prefs: []
  type: TYPE_NORMAL
- en: One component that we often want to have access to is the base widget (`ComicCreator`)
    of the rule hierarchy. Lines 9 and 31 complete the referencing using **`root`**
    to have access to it through the `comic_creator` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reserved **`root`** keyword is an internal Kivy language variable that always
    refers to the base widget in the rule hierarchy. The other two important keywords
    are **`self`** and **`app`**. The keyword **`self`** refers to the current widget,
    and **`app`** refers to the instance of the application.
  prefs: []
  type: TYPE_NORMAL
- en: These are all the changes that are needed in the *Comic Creator* project to
    create the attributes. We can run the project as usual with Python `comicreator.py`
    and we will obtain the same result as [Chapter 2](ch02.html "Chapter 2. Graphics
    – the Canvas"), *Graphics – the Canvas*.
  prefs: []
  type: TYPE_NORMAL
- en: We created the links between the interface components with attributes. In the
    following sections, we will frequently use the created attributes to access different
    parts of the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Basic widget events – dragging the stickman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Basic `Widget` events correspond to touches on the screen. However, the concept
    of touch in Kivy is broader than might be intuitively assumed. It includes mouse
    events, finger touches, and magic pen touches. For the sake of simplicity, we
    will often assume in this chapter that we are using a mouse but it doesn''t really
    change if we were to use a touch screen (and the finger or magic pen instead).
    The following are the three basic `Widget` events:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`on_touch_down`**: When a new touch starts, for example, the action of clicking
    a button of the mouse or touching the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`on_touch_move`**: When the touch is moved, for example, dragging the mouse
    or sliding the finger over the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`on_touch_up`**: When the touch ends, for example, releasing the mouse button
    or lifting a finger from the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Notice that **`on_touch_down`** takes place each time before **`on_touch_move`**,
    and **`on_touch_up`** happens; the bullet list order reflects the necessary execution
    order. Finally, **`on_touch_move`** cannot happen at all if there is no moving
    action. These events allow us to add drag capability to our `Stickman` so that
    we can place it wherever we want after adding it. We modify the header of `comicwidgets.kv`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The code now includes a rule for a new `Widget` called `DraggableWidget`. Line
    41 deactivates `size_hint` so that we can use fixed sizes (for example, line 44).
    The `size_hint: None, None` instruction has been removed from the `StickMan` because
    it will inherit from `DraggableWidget` in the Python code. The **`import`** **directive**
    on line 39 is responsible for importing the respective `comicwidgets.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `comicwidgets.py` file contains the new `DraggableWidget` class. This class
    inherits from `RelativeLayout` (line 50). The `selected` attribute in line 52
    will indicate whether the `DraggableWidget` instance is selected or not. Notice
    that `selected` is not part of Kivy; it is an attribute that we just created as
    part of the `DraggableWidget` class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `__init__` constructor in Python is the right place to define class object
    attributes by simply using the `self` reference without declaring them at the
    class level; this often causes confusion to programmers coming from other object-oriented
    languages, such as C++ or Java.
  prefs: []
  type: TYPE_NORMAL
- en: In the `comicwidgets.py` file, we also have to override the three methods associated
    with the touch events (`on_touch_down`, `on_touch_move`, and `on_touch_up`). Each
    of these methods receives `MotionEvent` as a parameter (`touch`), which contains
    a lot of useful information related to the event, for instance, the coordinates
    of the touch, type of touch, the number of taps (or clicks), duration, the input
    device, and many more that can be used for advanced tasks ([http://kivy.org/docs/api-kivy.input.motionevent.html#kivy.input.motionevent.MotionEvent](http://kivy.org/docs/api-kivy.input.motionevent.html#kivy.input.motionevent.MotionEvent)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with **`on_touch_down`**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In line 55, we used the most common strategy in Kivy to detect if the touch
    is on top of a widget: the **`collide_point`** method. It allows us to detect
    whether the event actually happens inside a specific `DraggableWidget` by checking
    the coordinates of the touch.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every active `Widget` receives all the touch events (`MotionEvent`) that happen
    inside the app (coordinate space), and we can use the `collide_point` method to
    detect whether the event occurs in any particular `Widget`.
  prefs: []
  type: TYPE_NORMAL
- en: This means it is up to the programmer to implement the logic that will discriminate
    between the possibility of a particular `Widget` doing something (in this case,
    to call on the method `select` in line 56) with the event, or whether it will
    just let it pass by calling the base class method (line 58) and hence, the default
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The most common way of handling an event is by using **`collide_point`**, but
    other criteria can be used. Kivy gives us absolute freedom in this. Line 55 provides
    the simplest case of checking whether the event occurred inside the `Widget`.
    If the coordinate of the event was actually inside the `Widget`, we call on the
    `select()` method, which will set the figure as being selected (details explained
    later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand the returning value of an event (line 57) and
    also what calling the method of the base class means (line 58). The Kivy GUI has
    a hierarchical structure, so each `Widget` instance always has a corresponding
    **`parent`** `Widget` (except if the `Widget` instance is the root of the hierarchy).
  prefs: []
  type: TYPE_NORMAL
- en: The returning value of the touch event tells the **`parent`** whether we took
    care of the event or not by returning `True` or `False`, respectively. Therefore,
    we need to be careful because we are in full control of the widgets that receive
    the event. Finally, we can also use the returning value of `super` (base class
    reference) to find out whether one of the children has taken care of the event
    already.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, the structure of the `on_touch_down` method overriding lines 54
    to 58, is the most common way to take care of a basic event:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the event happens inside `Widget` (line 55).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do what has to be done (line 56).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return `True` indicating that the event was processed (line 57).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the event falls outside the `Widget`, then we propagate the event to the
    children and return the result (line 58).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Even though this is the most common way, and probably recommended for beginners,
    we can deviate from this in order to achieve different goals; we will soon expand
    this with other examples. First, let''s review the `select` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we need to ensure that nothing has been selected before (line 60) using
    the `select` attribute we created earlier (line 52). If this is the case, we save
    the center coordinates of `DraggableWidget` (lines 61 and 62), and we dynamically
    draw a rectangle on its border (line 63 and 64), as illustrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic widget events – dragging the stickman](img/B04244_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Line 63 is a convenience based on the `with` Python statement. It is equivalent
    to the call in the **`add`** method with `self.canvas.add(Rectangle(…))`, with
    the advantage that it allows us to add many instructions at the same time. For
    example, we could use it to add three instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 2](ch02.html "Chapter 2. Graphics – the Canvas"), *Graphics – the
    Canvas*, we used Kivy language to add shapes to the `canvas`. Now, we used Python
    code directly and not the Kivy language syntax anymore, although the Python `with`
    statement slightly resembles it and it is frequently used in the Kivy API. Notice
    that we kept the `Line` instance in the `selected` attribute in line 64 because
    we will need it in order to remove the rectangle once the widget is not selected
    anymore. Also, the `DraggableWidget` instance will be aware of when it is selected,
    either whether it contains a reference or is `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'That condition is used in the `on_touch_move` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this event, we control the dragging of `DraggableWidget`. In line 67, we
    make sure that `DraggableWidget` is selected. In the same line, we use `collide_point`
    again but this time, we use **`parent`** (*drawing space*) instead of `self`.
    This is the reason why the previous line (line 66) transformed the widget coordinates
    to values that are relative to the corresponding `parent` with the **`to_parent`**
    method. In other words, we have to check the `parent` (*drawing space*) because
    the `Stickman` can be dragged inside the whole of the *drawing space*, and not
    just inside `DraggableWidget` itself. The next section will explain in detail
    how to localize coordinates to different parts of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Another detail of line 67 is that we check the left corner of the future position
    of `DraggableWidget` by subtracting half its width and height from the current
    touch (`touch.x - self.width/2, touch.y - self.height/2`). This is in order to
    make sure that we don't drag the shape outside the *drawing space* because we
    will drag it from the center.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the conditions are `True`, we call the `translate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The method moves the `DraggableWidget` (`x`, `y`) pixels by assigning new values
    to the `center_x` and `center_y` properties (lines 72 and 73). It also updates
    the `ix` and `iy` properties that we created in the `select` method before lines
    61 and 62.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last two lines (lines 69 and 70) of the `on_touch_move` method follow the
    same approach of the `on_touch_down` method (line 57 and 58), and also the `on_touch_up`
    method (lines 77 and 78):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `on_touch_up` event undoes the `on_touch_down` status. First, it checks
    whether it is selected using our `selected` attribute. If it is, then it calls
    the `unselected()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This method will dynamically call the **`remove`** method to remove the `Line`
    vertex instruction from the `canvas` (line 81), and set our attribute `selected`
    to `None` (line 82) to indicate that the widget is not being dragged anymore.
    Notice the different ways in which we add the `Line` vertex instruction (line
    63 and 64) and remove it (line 81).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two more lines of code in `comicwidgets.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: These lines define our `StickMan`, which now inherits from `DraggableWidget`
    (line 83) instead of from `RelativeLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A final change is necessary in `drawingspace.kv`, which now looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We added a border to `canvas.before` of the *drawing space* (lines 87 and 88),
    which will serve us a reference to visualize where the canvas starts or ends.
    We also kept a `StickMan` instance in the *drawing space*. You can run the application
    (`python comiccreator.py`) and drag the `StickMan` over the *drawing space*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic widget events – dragging the stickman](img/B04244_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this section, you learned the three basic touch events of any `Widget`. They
    are strongly dependent on the coordinates, and therefore it will be necessary
    to learn how to properly manipulate the coordinates. We introduce this technique
    in the `on_touch_move` method, but it will be the main topic in the next section,
    which explores the possible ways that Kivy offers to localize coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Localizing coordinates – adding stickmen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section, we used the **`to_parent()`** method (line 66) to translate
    the coordinates relative to the `DrawingSpace`, to its parent. Remember that we
    were inside `DraggableWidget` and the coordinates we received were relative to
    `parent` (`DrawingSpace`).
  prefs: []
  type: TYPE_NORMAL
- en: These coordinates are convenient for `DraggableWidget` because we positioned
    it in the parent's coordinates. The method allows us to use the coordinates in
    the parent's `collide_point`. This is no longer convenient for when we want to
    check the coordinates on the parent's `parent` space or when we need to draw something
    directly on the canvas of a `Widget`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before studying more examples, let''s review the theory. You learned that `RelativeLayout`
    is very useful because it is simpler to think inside a constraint space to localize
    our objects. The problems start when we need to translate coordinates to another
    `Widget` area. Let''s consider the following screenshot of a Kivy program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Localizing coordinates – adding stickmen](img/B04244_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code to generate this example is not shown here since it is very straightforward.
    If you want to test it, you can find the code under the folder `04 - Embedding
    RelativeLayouts/` and run it with `python main.py --size=150x75`. It consists
    of three `RelativeLayouts` embedded into each other. The **Blue** (darker gray)
    is parent of the **Green** (light gray) and the **Green** is parent of **Red**
    (middle gray). The **a** (in the top-right corner) is a `Label` instance located
    at the position `(5, 5)` inside **Red** (middle gray) `RelativeLayout`. The **Blue**
    layout (dark gray) is the size of the window (150 x 75). The rest of the elements
    are indicators (no part of the code) to help you understand the example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screenshot includes some measurements that help explain the four
    methods of localizing coordinates that the `Widget` class provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`to_parent()`**: This method transforms relative coordinates inside `RelativeLayout`
    to the parent of `RelativeLayout`. For example, `red.to_parent(a.x, a.y)` returns
    the coordinates of `a` relative to the green (light gray) layout, which are `(50+5,
    25+5) = (55, 30)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`to_local()`**: This method transforms the coordinates of `parent` of `RelativeLayout`
    to `RelativeLayout`. For example, `red.to_local(55,30)` returns `(5,5)`, the coordinates
    of the `a` label relative to the red layout (middle gray).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`to_window()`**: This method transforms the coordinates of the current `Widget`
    to absolute coordinates with respect to the window. For example, `a.to_window(a.x,
    a.y)` returns the absolute coordinates of **a** which are`(100 + 5, 50 + 5) =
    (105, 55)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`to_widget()`**: This method transforms the absolute coordinates to coordinates
    within the parent of the current widget. For example, `a.to_widget(105,55)` returns
    `(5,5)`, again the coordinates of `a` relative to the `red` (middle gray) layout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last two methods don't use the `red` layout to transform the coordinates
    because in this case, Kivy assumes that the coordinates are always relative to
    the parent. There is also a `Boolean` parameter (called **`relative`**), which
    controls whether the coordinates are relative inside the `Widget`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's study a real example in the *Comic Creator* project. We will add events
    to the *tool box* buttons, so that we can add figures to the *drawing space*.
    In this process, we will encounter a scenario in which we have to use one of the
    before-mentioned methods to localize our coordinates correctly to the `Widget`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code corresponds to the header of the `toolbox.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The structure in lines 99 to 106 is already familiar. Line 102 makes sure that
    `ToolButton` is in the `'down'` state and that the event happened in the `DrawingSpace`
    instance (referenced by `ds`). Remember that the parent of `ToolButton` is `ToolBox`
    and that we added an attribute that references the `DrawingSpace` instance in
    `comiccreator.kv` at the beginning of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `draw` method is called in line 104\. It will draw the respective shapes
    according to the derived classes (`ToolStickMan`, `ToolCircle`, and `ToolLine`).
    We need to be sure that we send the right coordinates to the `draw` method. Therefore,
    before calling it, we need to translate the absolute coordinates (received in
    `on_touch_down` of `ToolButton`) to relative coordinates (appropriated for the
    *drawing space*) with the `to_widget` event (line 103).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We know that the coordinates we received (`touch.x` and `touch.y`) are absolute
    because `ToolStickman` is not `RelativeLayout`, whereas the `DrawingSpace` (`ds`)
    is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue studying the `toolbox.py` file and see how `ToolStickMan` actually
    adds `StickMan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We create an instance of `Stickman` (line 112), use the translated coordinates
    (line 103) to center the `Stickman`, and finally (line 119), add it to the `DrawingSpace`
    instance with the **`add_widget`** method (line 114). We just need to update a
    few lines in `toolbox.kv` in order to run the project with new changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to import `toolbox.py` (line 116), then we remove `@ToggleButton`
    from `ToolButton` (line 118) because we added it in `toolbox.py`, and finally
    we replace the last `ToolButton` for our new `ToolStickman` widget (line 122).
    At this point, we are able to add *stickmen* to the *drawing space* and also drag
    them over it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Localizing coordinates – adding stickmen](img/B04244_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have covered the basics now, so let's learn how to bind and unbind events
    dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Binding and unbinding events – sizing limbs and heads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous two sections, we override basic events to perform actions we
    want. In this section, you will learn how to bind and unbind events dynamically.
    It was quite an easy job to add our `Stickman` because it is a `Widget` already,
    but what about the graphics, the circle, and the rectangle? We could create some
    widgets for them, just as we did with the `Stickman`, but let''s attempt something
    braver before that. Instead of just clicking on the *drawing space*, let''s drag
    the mouse on its border to decide the size of the circle or line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Binding and unbinding events – sizing limbs and heads](img/B04244_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using mouse to set the size
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we finish the dragging (and we are satisfied with the size), let''s dynamically
    create `DraggableWidget` that will contain the shape, so we can also drag them
    over the `DrawingSpace` instance. The following class diagram will help us understand
    the whole inheritance structure of the `toolbox.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Binding and unbinding events – sizing limbs and heads](img/B04244_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The diagram includes `ToolButton` and `ToolsStickman`, which were explained
    in the last section, but it also includes three new classes called `ToolFigure`,
    `ToolLine`, and `ToolCircle`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ToolFigure` class has six methods. Let''s start with a quick overview
    of these methods and then highlight the important and new parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`draw`: This method overrides `draw` of `ToolButton` (lines 108 and 109). The
    position where we touch down indicates the starting point of our figure, either
    the center for a circle or one of the ends of a line.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`update_figure`: This method updates the end-point of the figure when we drag.
    Either the end of a line or the radius (distance from the starting point to the
    end point) of the circle.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`end_figure`: This method indicates the final end point of the figure with
    the same logic as in `update_figure`. Also, we put the final figure inside `DraggableWidget`
    (see `widgetize`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`widgetize`: This method creates `DraggableWidget` and places the figure in
    it. It uses four coordinates that have to be localized correctly with the localization
    methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`create_figure`: This method will be overridden by `ToolLine` (lines 153 and
    154) and `ToolCircle` (lines 162 to 163). It creates the respective figure, given
    four coordinates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`create_widget`: This method is also overridden by `ToolLine` (lines 156 to
    159) and `ToolCircle` (lines 165 to 169). It creates a respectively positioned
    and sized `DraggableWidget` given four coordinates.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Most of the statements from the preceding methods have already been covered.
    The new topic of this code is the dynamic **`bind`**/**`unbind`** of events. The
    main problem we needed to solve is that we didn't want the `on_touch_move` and
    `on_touch_up` events active all the time. We needed to activate them (**`bind`**)
    from the moment the user starts drawing (`on_touch_down` of `ToolButton` that
    calls on the method `draw`) until the user decides the size and does a touch up.
    Therefore, we bound `update_figure` and `end_figure`, respectively, to the `on_touch_move`
    and `on_touch_up` events of `DrawingSpace` when the method `draw` is called on
    (lines 128 and 129). Also, we unbound them when the user ends the figure on method
    `end_figure` (lines 137 and 138). Notice that we can unbind the same method that
    is being executed (`end_figure`) from the `on_touch_up` event. We want to avoid
    calling the methods `update_figure` and `end_figure` unnecessarily. With this
    approach, they are going to be called only when the figure is drawn for the first
    time.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few other interesting things in this code that deserve some attention.
    In line 125, we created two class attributes (`self.ix` and `self.iy`) to keep
    the coordinates of the initial touch. We use those coordinates each time we update
    the figure (line 135) and when we put the figure into a `Widget` (line 141).
  prefs: []
  type: TYPE_NORMAL
- en: We also use some of the localizing methods that we covered in the previous section.
    In lines 132 and 140, we used `to_widget` to translate the coordinates to the
    `DrawingSpace` instance. The lines 144 and 145 use `to_local` to translate the
    coordinates to `DraggableWidget`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`DraggableWidget` is instructed to translate the coordinates to its inner relative
    space with the parameter **`relative`**`=True` because `DraggableWidget` is relative
    and we are trying to draw inside it (not inside the parent: the *drawing space*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is some basic math involved in the calculation of the position and sizes
    of the figures and widgets. We have intentionally moved it to the deeper classes
    of the inheritance: `ToolLine` and `ToolCircle`. The following is their code,
    the last part of `toolbox.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The math involves concepts of geometry that escape the scope of this book.
    It is important to understand that the methods of this code section adapts the
    calculations to create either lines or circles. Finally, we apply some changes
    to the `ToolBox` class in `toolbox.kv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The new classes `ToolCircle` (line 179), `ToolLine` (line 184), and `ToolStickMan`
    (line 189) have replaced the previous `ToolButton` instances. Now, we can also
    add and scale lines and circles to the *drawing space*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Binding and unbinding events – sizing limbs and heads](img/B04244_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We also created some attributes (lines 176, 177, and 178) that will be useful
    in [Chapter 4](ch04.html "Chapter 4. Improving the User Experience"), *Improving
    the User Experience*, when we use gestures to create figures.
  prefs: []
  type: TYPE_NORMAL
- en: Binding events in the Kivy language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been handling events in two ways: overridding an event method
    (for example, `on_touch_event`) and binding a personalize method to a related
    event method (for example, `ds.bind(on_touch_move=self.update_figure)`). In this
    section, we will discuss a different way, that is, binding events in the Kivy
    language. Potentially, we could have done this since the beginning of this chapter
    when we started working with `DraggableWidget` but there is a difference. If we
    use the Kivy language, we can easily add the event to a specific instance and
    not to all the instances of the same class. In this sense, it resembles dinamically
    binding an instance to its callback with the `bind` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to concentrate on new events specific to `Button` and `ToggleButton`.
    The following is the code for `generaloption.kv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Button` class has two extra events: **`on_press`** and **`on_release`**.
    The former is similar to `on_touch_down` and the latter is similar to `on_touch_up`.
    However, in this case, we don''t need to worry about calling the `collide_point`
    method. We used `on_press` for the **Clear** `Button` (line 200) and the **Color**
    `Button` (line 209) and `on_release` for the **Remove** `Button` (line 203) to
    illustrate both methods, but for this particular case, it does not really matter
    which one we pick. The **`on_state`** event is already a part of the `Button`
    class, although more commonly used in the ToggleButton instances. This event is
    triggered every time the state of `ToogleButton` changes from `''normal''` to
    `''down''` and vice versa. The **`on_state`** event is used in lines 206 and 212\.
    All the events are bound to methods in the root, which are defined in the `generaloptions.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GeneralOptions` method illustrates a few other methods of the `Widget`
    class. The `clear` method removes all the widgets from the `DrawingSpace` instance
    through the **`clear_widgets`** method (line 222). The following screenshot show
    the result of clicking on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Binding events in the Kivy language](img/B04244_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **`remove_widget`** method removes the last added `Widget` instance accessing
    the **`children`** list (line 227). The `group` method modifies the `group_mode`
    attribute of line 218 according to the `'down'` or `'normal'` `ToggleButton` state.
    The `color` and `gestures` methods will be completed in [Chapter 4](ch04.html
    "Chapter 4. Improving the User Experience"), *Improving the User Experience*.
  prefs: []
  type: TYPE_NORMAL
- en: The *group mode* will allow the user to select several `DraggableWidget` instances
    in order to drag them at the same time. We activated or deactivated the *group
    mode* according to the state of the `ToggleButton`. In the next section, we will
    actually allow multiple selections and dragging in the `DraggableWidget` class.
    For now, we will just get the controls ready with the `unselect_all` and `on_translation`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: When the *group mode* is deactivated, we make sure that all the selected widgets
    are unselected, by calling the `unselect_all` method (line 242). The `unselect_all`
    method traverses the list of children calling the internal method `unselect` of
    each `DraggableWidget` (line 79).
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the `on_translation` method also traverses the children list calling
    the internal `translate` method (line 71) of each `DraggableWidget`. The question
    is; what calls the `on_translation` method? One of the most useful features of
    Kivy provides the answer to this question; this will be explained in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own events – the magical properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section covers the use of the Kivy properties. A Kivy property triggers
    an event every time we modify it. There are different types of properties, from
    the simple **`NumericProperty`** or **`StringProperty`** to much more complex
    versions such as **`ListProperty`**, **`DictProperty`**, or **`ObjectProperty`**.
    For example, if we define a **`StringProperty`** called `text`, then an `on_text`
    event is going to be triggered each time the text is modified.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we define a Kivy property, Kivy internally creates an event associated
    with that property. The property event is referenced adding the prefix `on_` to
    the name of the property. For example, the `on_translation` method (line 246)
    is associated with `ListProperty` in line 219 called `translation`.
  prefs: []
  type: TYPE_NORMAL
- en: All the properties work in the same way. For example, the `state` property that
    we used in the `ToogleButton` class is actually a property that creates the `on_state`
    event. We already used this event in line 206\. We define the property and Kivy
    creates the event for us.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the context of this book, a **property** will always refer to a Kivy property
    and it should not be confused with a Python property, which is a different concept
    not covered in this book. An **attribute** is used to describe variables (references,
    objects, and instances) that belong to the class. As a general rule, a Kivy property
    is always an attribute but an attribute is not necessarily a Kivy property.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we implement *group mode*, which offers the possibility of
    selecting and dragging several figures (`DraggableWidgets` instances) at the same
    time by pressing the **Group** button (line 204). In order to do this, we can
    take advantage of the relation between the `translation` property and the `on_translation`
    method. Basically, every time we modify the `translation` property, the `on_translation`
    event is triggered. Say that we drag three figures at the same time (with the
    *group mode*) as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating your own events – the magical properties](img/B04244_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The three figures are selected but the events are handled by the circle, since
    it is the one that has the pointer on top. The circle needs to tell the line and
    the stickman to translate. Instead of calling the `on_translation` method, it
    only needs to modify the `translation` property, and the `on_translation` event
    is triggered. Let's include these changes in `comicwidgets.py`. We need four modifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to add the `touched` attribute (line 252) to indicate which
    of the selected figures receives the event (for example, the circle in the previous
    screenshot). We do this in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we need to set the `touched` attribute to `True` (line 256) when one
    of the `DraggableWidget` instances receives the event. We do this in the `on_touch_down`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Third, we need to check that `DraggableWidget` is the one that is currently
    being touched (received the `on_touch_down` event previously). We add this to
    the condition in line 262\. The most important change is in line 264\. Instead
    of calling the `translate` method directly, we modify the `translation` property
    of *general options* (`self.parent.general_options`) setting the number of pixels
    the widget has been translated to the property. This will trigger the `on_translation`
    method of `GeneralOptions`, which at the same time calls the `translate` method
    for each selected `DraggableWidget`. This is the resulting code for `on_touch_move`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Fourth, we need to set the `touched` attribute to `False` (line 268) on the
    `on_touch_up` event, and also avoid calling the `unselect` method when we use
    `group_mode` (line 270). Here is the code for the `on_touch_up` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This example could be considered artificial, since we theoretically could have
    called the `on_translation` method from the start. However, properties are crucial
    in order to keep consistency of the internal state of a variable and the screen
    display. The example from the next section will improve your understanding of
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Kivy and its properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though we have only touched upon explanations of properties in the previous
    section, the truth is that we have been using them since the beginning of this
    chapter. Kivy's internals are full of properties. They are almost everywhere.
    For example, when we implemented `DraggableWidget`, we simply modified the `center_x`
    property (line 72 and 73), and the whole `Widget` was then kept updated because
    there is a chain of properties involved in the use of `center_x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last example in this chapter illustrates how powerful Kivy properties are.
    Here is the code for `statusbar.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The way Kivy properties work can be perceived as confusing by some advanced
    Python or Java programmers. The confusion happens when a programmer assumes that
    `counter` (line 278) is a static attribute of the `StatusBar` class because `counter`
    is defined in an equivalent way to the Python static attributes (for example,
    `previous_counter` in line 279). The assumption is incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kivy properties are declared as static attribute classes (since they belong
    to the class), but they are always internally transformed to attribute instances.
    They actually belong to the object as we would have declared them in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: We need to distinguish between a static attribute of a class and an attribute
    of a class instance. In Python, `previous_counter` (line 279) is a static attribute
    of the `StatusBar` class. This means that it is shared among all the `StatusBar`
    instances, and it can be accessed in any of the ways shown in lines 284 and 286
    (however, line 284 is recommended because it is independent of the class name).
    In contrast, the `selected` variable (line 251) is an attribute of a `DraggableWidget`
    instance. This means that there is a `selected` variable per `StatusBar` object.
    It is not shared among them. They are created until the constructor (`__init__`)
    is called. The only way to access it is through `obj.selected` (line 251). The
    `counter` property (line 278) behaves more similarly to the `selected` attribute
    than to the `previous_counter` static attribute, in the sense that there is one
    `counter` property and one `selected` attribute in each instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that this has been clarified, we can move on to study the example. The
    `counter` is defined as `NumericProperty` in line 278\. It corresponds to the
    `on_counter` method (line 281) and modifies `Label` (`msg_text`) defined in the
    `statusbar.kv` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use `id` (line 297) again in order to define `msg_text` (line 292).
    Also, we use `counter` defined in line 278 to update the **Total Figures** message
    in line 295\. The specific part (`str(root.counter)`) of `text` is updated automatically
    when `counter` is modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we just need to modify the `counter` property, and the interface is updated
    automatically. Let''s update the counter in `drawingspace.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We updated `counter` with the length of `children` of the `DrawingSpace` in
    the method `on_children`. Then, `on_children` is called every time we add (line
    114 or 147) or remove (line 222 or 227) widgets from the `children` list of the
    `DrawingSpace` because `children` is also a Kivy property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget to import this file into `drawingspace.py` in the `drawingspace.kv`
    file, in which we also removed the border of the *drawing space*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram shows a chain of elements (properties, methods, and widgets)
    that are associated with the `children` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Kivy and its properties](img/B04244_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is important to compare again the way we gain access to the `counter` property
    and the `msg_label` attribute. We defined the `counter` property in the `StatusBar`
    (line 278) and used it in `Label` through the `root` (line 295). In the `msg_label`
    case, we started defining `id` (line 297) and then the attribute of the Kivy language
    (line 292). Then, we were able used msg_label in the Python code (lines 283, 285
    and 287)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that an attribute is not necessarily a Kivy property. An attribute
    is an element of the class, whereas a Kivy property also associates the attribute
    with an event.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the complete list of available properties in the Kivy API ([http://kivy.org/docs/api-kivy.properties.html](http://kivy.org/docs/api-kivy.properties.html)).
    There are two specific properties that should at least be mentioned: **`BoundedNumericProperty`**
    and **`AliasProperty`**. The **`BoundedNumericProperty`** property allows the
    setting of the maximum and minimum values. If the value is beyond the range, an
    `Exception` is thrown. The **`AliasProperty`** property offers a way in which
    we can extend the properties; it allows us to create our own properties in case
    the necessary property does not exist.'
  prefs: []
  type: TYPE_NORMAL
- en: One last thing that deserves attention is that attributes of the vertex instructions
    are used as properties when we create them with the Kivy language. For example,
    if we change the position of the line inside `ToolLine`, it will be updated automatically.
    However, this just applies inside the Kivy language, not when we add the vertex
    instructions dynamically, as we did in `toolbox.py`. In our case, we had to remove
    and create a new vertex instruction every time we needed to update the figures
    (lines 133 to 135). However, we could have created our own properties to handle
    the updates. An example will be offered in [Chapter 6](ch06.html "Chapter 6. Kivy
    Player – a TED Video Streamer"), *Kivy Player – a TED Video Streamer*, when we
    add subtitles to the videos.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the code one last time to see the final result with the status bar
    counting figures and indicating our last action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Kivy and its properties](img/B04244_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We covered most of the topics related to event handling in this chapter. You
    learned how to override different kind of events, dynamic binding and unbinding,
    assigning events in the Kivy language, and creating our own. You also learned
    about Kivy properties, how to manage the localization of coordinates to different
    widgets, and many methods related to adding, removing, and updating objects of
    `Kivy` `Widget` and `canvas`. Here are the events, methods, properties, and attributes
    that were covered:'
  prefs: []
  type: TYPE_NORMAL
- en: The events we covered are `on_touch_up`, `on_touch_move` and `on_touch_down`
    (of `Widget`); `on_press` and `on_release` (of `Button`); and `on_state` (of `ToggleButton`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The attributes we covered are x and y of `MotionEvent` (`touch`); `center_x`,
    `center_y`, `canvas`, `parent`, and `children` of `Widget`, and `state` of `ToggleButton`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following methods of `Widget`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bind` and `unbind` to attach events dynamically'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collide_points`, `to_parent`, `to_local`, `to_window`, and `to_widget` to
    work with coordinates'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add_widget`, `remove_widget`, and `clear_widgets` to dynamically modify the
    children widgets'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The methods `add` and `remove` of canvas to dynamically add and remove vertex
    and context instructions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kivy properties: `NumericProperty` and `ListProperty`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are two other important types of events related to the clock and keyboard.
    This chapter was focused on widget and property events but we will see how to
    use other events in [Chapter 5](ch05.html "Chapter 5. Invaders Revenge – an Interactive
    Multi-touch Game"), *Invaders Revenge – an Interactive Multi-touch Game*. The
    next chapter is going to introduce a list of interesting topics on Kivy in order
    to improve the user experience with our *Comic Creator*.
  prefs: []
  type: TYPE_NORMAL
