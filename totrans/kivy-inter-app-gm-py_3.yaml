- en: Chapter 3. Widget Events – Binding Actions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。小部件事件 – 绑定动作
- en: 'In this chapter, you will learn how to integrate actions into the **Graphical
    User Interface** (**GUI**) components; some of the actions will be associated
    with the canvas and others with the `Widget` management. We will learn how to
    handle events dynamically in order to make the application respond to the user
    interactions. In this chapter, you will acquire the following skills:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何将动作集成到 **图形用户界面**（**GUI**）组件中；一些动作将与画布相关联，而其他动作将与 `Widget` 管理相关联。我们将学习如何动态处理事件，以便使应用程序能够响应用户交互。在本章中，你将获得以下技能：
- en: Reference different parts of the GUI through IDs and properties
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 ID 和属性引用 GUI 的不同部分
- en: Override, bind, unbind, and create Kivy events
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖、绑定、解绑和创建 Kivy 事件
- en: Add widgets to other widgets dynamically
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态将小部件添加到其他小部件中
- en: Add vertex and context instructions to the canvas dynamically
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态向画布添加顶点和上下文指令
- en: Translate relative and absolute coordinates between a widget, its parent, and
    its window
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在小部件、其父元素和其窗口之间转换相对和绝对坐标
- en: Use properties to keep the GUI updated with the changes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性来保持 GUI 与更改同步
- en: This is an exciting chapter because our application will start interacting with
    the user applying the concepts acquired in the previous two chapters. All the
    basic functionality of our *Comic Creator* project will be ready by the end. This
    includes shapes that can be dragged, sizeable circles, and lines, clearing the
    widget space, removing the last added figure, grouping several widgets to drag
    them together, and keeping the *status bar* updated about the last actions of
    the user.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个令人兴奋的章节，因为我们的应用程序将开始与用户交互，应用在前两个章节中获得的观念。到本章结束时，我们的 *Comic Creator* 项目的所有基本功能都将准备就绪。这包括可拖动的形状、可调整大小的圆圈和线条、清除小部件空间、删除最后添加的图形、将多个小部件分组以一起拖动，以及更新
    *状态栏* 以反映用户的最后操作。
- en: Attributes, ID, and root
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性、ID 和根
- en: 'In [Chapter 1](ch01.html "Chapter 1. GUI Basics – Building an Interface"),
    *GUI Basics – Building an Interface*, we distinguished between four main components
    for our *Comic Creator*: *tool box*, *drawing space*, *general options*, and *status
    bar*. In this chapter, we will make these components interact with each other
    and, therefore, we need to add some attributes to the classes of the project we
    created in the previous chapters. These attributes will reference different parts
    of the interface so that they can communicate. For example, the `ToolBox` class
    needs to have a reference to the `DrawingSpace` instance, so the `ToolButton`
    instances can draw their respective figures inside it. The following diagram shows
    all the relationships that are created in the `comiccreator.kv` file:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](ch01.html "第 1 章。GUI 基础 – 构建界面")，*GUI 基础 – 构建界面* 中，我们区分了 *Comic Creator*
    的四个主要组件：*工具箱*、*绘图空间*、*常规选项* 和 *状态栏*。在本章中，我们将使这些组件相互交互，因此我们需要向我们在前几章中创建的项目类中添加一些属性。这些属性将引用界面的不同部分，以便它们可以通信。例如，`ToolBox`
    类需要引用 `DrawingSpace` 实例，以便 `ToolButton` 实例可以在其中绘制各自的图形。以下图表显示了在 `comiccreator.kv`
    文件中创建的所有关系：
- en: '![Attributes, ID, and root](img/B04244_03_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![属性、ID 和根](img/B04244_03_01.jpg)'
- en: Internal References of the *Comic Creator*
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*Comic Creator* 的内部引用'
- en: We also learned in [Chapter 1](ch01.html "Chapter 1. GUI Basics – Building an
    Interface"), *GUI Basics – Building an Interface,* that **ID** lets us reference
    other widgets in the Kivy language.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在 [第 1 章](ch01.html "第 1 章。GUI 基础 – 构建界面")，*GUI 基础 – 构建界面* 中学习了，**ID** 允许我们在
    Kivy 语言中引用其他小部件。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The IDs are only meant to be used within the Kivy language. Therefore, we need
    to create attributes in order to reference the elements inside the Python code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ID 仅用于 Kivy 语言内部。因此，我们需要创建属性以便在 Python 代码中引用界面内的元素。
- en: 'Following is the `comiccreator.kv` file of the *Comic Creator* project with
    some modifications to create the necessary IDs and attributes:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对 *Comic Creator* 项目的 `comiccreator.kv` 文件进行了一些修改以创建必要的 ID 和属性：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The IDs in lines 7, 16, 29, and 35 have been added to the comiccreator.kv. Following
    the previous diagram (Internal References of the *Comic Creator*), the IDs are
    used to create the attributes in lines 8, 17, 18, 19, and 30.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7、16、29 和 35 行中的 ID 已添加到 comiccreator.kv 中。根据之前的图表（*Comic Creator* 的内部引用），ID
    用于在 8、17、18、19 和 30 行创建属性。
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The names of the attributes and IDs don't have to be different. In the previous
    code, we just added '_' to the IDs to distinguish them from the attributes. That
    is to say, the `_status_bar` ID, is only accessible within the `.kv` files, and
    the `status_bar` attribute, is intended to be used inside the Python code. Both
    could have had the same name without causing any conflict.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 属性和ID的名称不必不同。在前面的代码中，我们只是给ID添加了'_'来区分它们和属性。也就是说，`_status_bar` ID仅在`.kv`文件中可访问，而`status_bar`属性则打算在Python代码中使用。它们可以具有相同的名称而不会引起任何冲突。
- en: As an example, line 8 created the attribute `drawing_space`, which references
    the `DrawingSpace` instance. This means that the `ToolBox` (line 6) instance can
    now access the `DrawingSpace` instance in order to draw figures on it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，第8行创建了属性`drawing_space`，它引用了`DrawingSpace`实例。这意味着`ToolBox`（第6行）实例现在可以访问`DrawingSpace`实例，以便在其上绘制图形。
- en: One component that we often want to have access to is the base widget (`ComicCreator`)
    of the rule hierarchy. Lines 9 and 31 complete the referencing using **`root`**
    to have access to it through the `comic_creator` attribute.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常想要访问的是规则层次结构中基本小部件（`ComicCreator`）的基类。第9行和第31行使用**`root`**完成引用，通过`comic_creator`属性来访问它。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The reserved **`root`** keyword is an internal Kivy language variable that always
    refers to the base widget in the rule hierarchy. The other two important keywords
    are **`self`** and **`app`**. The keyword **`self`** refers to the current widget,
    and **`app`** refers to the instance of the application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 保留的**`root`**关键字是Kivy内部语言变量，它始终指向规则层次结构中的基小部件。其他两个重要关键字是**`self`**和**`app`**。关键字**`self`**指向当前小部件，而**`app`**指向应用程序的实例。
- en: These are all the changes that are needed in the *Comic Creator* project to
    create the attributes. We can run the project as usual with Python `comicreator.py`
    and we will obtain the same result as [Chapter 2](ch02.html "Chapter 2. Graphics
    – the Canvas"), *Graphics – the Canvas*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是在*漫画创作者*项目中创建属性所需的所有更改。我们可以使用Python `comicreator.py`正常运行项目，并将获得与[第2章](ch02.html
    "第2章。图形 – 画布")，*图形 – 画布*相同的结果。
- en: We created the links between the interface components with attributes. In the
    following sections, we will frequently use the created attributes to access different
    parts of the interface.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用属性创建了界面组件之间的链接。在接下来的章节中，我们将频繁使用创建的属性来访问界面的不同部分。
- en: Basic widget events – dragging the stickman
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本小部件事件 – 拖动stickman
- en: 'Basic `Widget` events correspond to touches on the screen. However, the concept
    of touch in Kivy is broader than might be intuitively assumed. It includes mouse
    events, finger touches, and magic pen touches. For the sake of simplicity, we
    will often assume in this chapter that we are using a mouse but it doesn''t really
    change if we were to use a touch screen (and the finger or magic pen instead).
    The following are the three basic `Widget` events:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的`Widget`事件对应于屏幕上的触摸。然而，在Kivy中，触摸的概念比直观上可能想象的要广泛。它包括鼠标事件、手指触摸和魔法笔触摸。为了简化，我们将在本章中经常假设我们正在使用鼠标，但实际上如果我们使用触摸屏（以及手指或魔法笔）也不会有任何改变。以下三个基本的`Widget`事件：
- en: '**`on_touch_down`**: When a new touch starts, for example, the action of clicking
    a button of the mouse or touching the screen.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`on_touch_down`**：当一个新的触摸开始时，例如，点击鼠标按钮或触摸屏幕的动作。'
- en: '**`on_touch_move`**: When the touch is moved, for example, dragging the mouse
    or sliding the finger over the screen.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`on_touch_move`**：当触摸移动时，例如，拖动鼠标或手指在屏幕上滑动。'
- en: '**`on_touch_up`**: When the touch ends, for example, releasing the mouse button
    or lifting a finger from the screen.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`on_touch_up`**：当触摸结束时，例如，释放鼠标按钮或从屏幕上抬起手指。'
- en: 'Notice that **`on_touch_down`** takes place each time before **`on_touch_move`**,
    and **`on_touch_up`** happens; the bullet list order reflects the necessary execution
    order. Finally, **`on_touch_move`** cannot happen at all if there is no moving
    action. These events allow us to add drag capability to our `Stickman` so that
    we can place it wherever we want after adding it. We modify the header of `comicwidgets.kv`
    as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到**`on_touch_down`**在每个**`on_touch_move`**之前发生，**`on_touch_up`**发生；项目符号列表的顺序反映了必要的执行顺序。最后，如果没有移动动作，则**`on_touch_move`**根本不会发生。这些事件使我们能够为我们的`Stickman`添加拖动功能，以便在添加后将其放置在想要的位置。我们按如下方式修改`comicwidgets.kv`的标题：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The code now includes a rule for a new `Widget` called `DraggableWidget`. Line
    41 deactivates `size_hint` so that we can use fixed sizes (for example, line 44).
    The `size_hint: None, None` instruction has been removed from the `StickMan` because
    it will inherit from `DraggableWidget` in the Python code. The **`import`** **directive**
    on line 39 is responsible for importing the respective `comicwidgets.py` file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '代码现在包括了一个名为`DraggableWidget`的新`Widget`的规则。第41行禁用了`size_hint`，这样我们就可以使用固定大小（例如，第44行）。`size_hint:
    None, None`指令已从`StickMan`中删除，因为它将在Python代码中继承自`DraggableWidget`。第39行的**`import`**指令负责导入相应的`comicwidgets.py`文件：'
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `comicwidgets.py` file contains the new `DraggableWidget` class. This class
    inherits from `RelativeLayout` (line 50). The `selected` attribute in line 52
    will indicate whether the `DraggableWidget` instance is selected or not. Notice
    that `selected` is not part of Kivy; it is an attribute that we just created as
    part of the `DraggableWidget` class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`comicwidgets.py`文件包含了新的`DraggableWidget`类。这个类从`RelativeLayout`继承（第50行）。第52行的`selected`属性将指示`DraggableWidget`实例是否被选中。请注意，`selected`不是Kivy的一部分；它是我们作为`DraggableWidget`类的一部分创建的属性。'
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `__init__` constructor in Python is the right place to define class object
    attributes by simply using the `self` reference without declaring them at the
    class level; this often causes confusion to programmers coming from other object-oriented
    languages, such as C++ or Java.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的`__init__`构造函数是定义类对象属性的合适位置，只需使用`self`引用而不在类级别声明它们；这常常会让来自其他面向对象语言（如C++或Java）的程序员感到困惑。
- en: In the `comicwidgets.py` file, we also have to override the three methods associated
    with the touch events (`on_touch_down`, `on_touch_move`, and `on_touch_up`). Each
    of these methods receives `MotionEvent` as a parameter (`touch`), which contains
    a lot of useful information related to the event, for instance, the coordinates
    of the touch, type of touch, the number of taps (or clicks), duration, the input
    device, and many more that can be used for advanced tasks ([http://kivy.org/docs/api-kivy.input.motionevent.html#kivy.input.motionevent.MotionEvent](http://kivy.org/docs/api-kivy.input.motionevent.html#kivy.input.motionevent.MotionEvent)).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在`comicwidgets.py`文件中，我们还需要重写与触摸事件相关的三个方法（`on_touch_down`、`on_touch_move`和`on_touch_up`）。这些方法中的每一个都接收`MotionEvent`作为参数（`touch`），它包含与事件相关的许多有用信息，例如触摸坐标、触摸类型、点击次数（或点击）、持续时间、输入设备等等，这些都可以用于高级任务（[http://kivy.org/docs/api-kivy.input.motionevent.html#kivy.input.motionevent.MotionEvent](http://kivy.org/docs/api-kivy.input.motionevent.html#kivy.input.motionevent.MotionEvent)）。
- en: 'Let''s start with **`on_touch_down`**:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从**`on_touch_down`**开始：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In line 55, we used the most common strategy in Kivy to detect if the touch
    is on top of a widget: the **`collide_point`** method. It allows us to detect
    whether the event actually happens inside a specific `DraggableWidget` by checking
    the coordinates of the touch.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在第55行，我们使用了Kivy中最常见的策略来检测触摸是否在某个小部件之上：**`collide_point`**方法。它允许我们通过检查触摸的坐标来检测事件是否实际上发生在特定的`DraggableWidget`内部。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Every active `Widget` receives all the touch events (`MotionEvent`) that happen
    inside the app (coordinate space), and we can use the `collide_point` method to
    detect whether the event occurs in any particular `Widget`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每个活动的`Widget`都会接收到在应用（坐标空间）内部发生的所有触摸事件（`MotionEvent`），我们可以使用`collide_point`方法来检测事件是否发生在任何特定的`Widget`中。
- en: This means it is up to the programmer to implement the logic that will discriminate
    between the possibility of a particular `Widget` doing something (in this case,
    to call on the method `select` in line 56) with the event, or whether it will
    just let it pass by calling the base class method (line 58) and hence, the default
    behavior.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着程序员需要实现逻辑来区分特定`Widget`执行某些操作的可能性（在这种情况下，调用第56行的`select`方法）与事件，或者它只是通过调用基类方法（第58行）并因此执行默认行为。
- en: The most common way of handling an event is by using **`collide_point`**, but
    other criteria can be used. Kivy gives us absolute freedom in this. Line 55 provides
    the simplest case of checking whether the event occurred inside the `Widget`.
    If the coordinate of the event was actually inside the `Widget`, we call on the
    `select()` method, which will set the figure as being selected (details explained
    later in this chapter).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 处理事件的常见方式是使用**`collide_point`**，但也可以使用其他标准。Kivy在这方面给了我们绝对的自由。第55行提供了检查事件是否发生在`Widget`内部的简单案例。如果事件的坐标实际上在`Widget`内部，我们将调用`select()`方法，这将设置图形为选中状态（细节将在本章后面解释）。
- en: It is important to understand the returning value of an event (line 57) and
    also what calling the method of the base class means (line 58). The Kivy GUI has
    a hierarchical structure, so each `Widget` instance always has a corresponding
    **`parent`** `Widget` (except if the `Widget` instance is the root of the hierarchy).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 理解事件的返回值（第57行）以及调用基类方法的意义（第58行）非常重要。Kivy GUI有一个层次结构，所以每个`Widget`实例都有一个对应的**`parent`**
    `Widget`（除非`Widget`实例是层次结构的根）。
- en: The returning value of the touch event tells the **`parent`** whether we took
    care of the event or not by returning `True` or `False`, respectively. Therefore,
    we need to be careful because we are in full control of the widgets that receive
    the event. Finally, we can also use the returning value of `super` (base class
    reference) to find out whether one of the children has taken care of the event
    already.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸事件的返回值告诉**`parent`**我们是否处理了事件，通过分别返回`True`或`False`。因此，我们需要小心，因为我们完全控制着接收事件的部件。最后，我们还可以使用`super`（基类引用）的返回值来找出是否已经有子部件处理了事件。
- en: 'In general, the structure of the `on_touch_down` method overriding lines 54
    to 58, is the most common way to take care of a basic event:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`on_touch_down`方法覆盖的行54到58的结构是处理基本事件的最常见方式：
- en: Make sure that the event happens inside `Widget` (line 55).
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保事件发生在`Widget`内部（第55行）。
- en: Do what has to be done (line 56).
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行必须完成的事情（第56行）。
- en: Return `True` indicating that the event was processed (line 57).
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`True`表示事件已被处理（第57行）。
- en: If the event falls outside the `Widget`, then we propagate the event to the
    children and return the result (line 58).
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果事件发生在`Widget`外部，则我们将事件传播给子部件并返回结果（第58行）。
- en: 'Even though this is the most common way, and probably recommended for beginners,
    we can deviate from this in order to achieve different goals; we will soon expand
    this with other examples. First, let''s review the `select` method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是最常见的方式，并且可能对初学者来说也是推荐的，但我们为了达到不同的目标可以偏离这种方式；我们很快会用其他示例来扩展这一点。首先，让我们回顾一下`select`方法：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'First, we need to ensure that nothing has been selected before (line 60) using
    the `select` attribute we created earlier (line 52). If this is the case, we save
    the center coordinates of `DraggableWidget` (lines 61 and 62), and we dynamically
    draw a rectangle on its border (line 63 and 64), as illustrated in the following
    screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保之前没有选择任何内容（第60行），使用我们之前创建的`select`属性（第52行）。如果是这种情况，我们保存`DraggableWidget`的中心坐标（第61和62行），并在其边界上动态绘制一个矩形（第63和64行），如下面的截图所示：
- en: '![Basic widget events – dragging the stickman](img/B04244_03_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![基本部件事件 – 拖动小人](img/B04244_03_02.jpg)'
- en: 'Line 63 is a convenience based on the `with` Python statement. It is equivalent
    to the call in the **`add`** method with `self.canvas.add(Rectangle(…))`, with
    the advantage that it allows us to add many instructions at the same time. For
    example, we could use it to add three instructions:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第63行是基于Python的`with`语句的一个便利方法。它与在**`add`**方法中的调用等效，即`self.canvas.add(Rectangle(…))`，其优点是它允许我们同时添加多个指令。例如，我们可以用它来添加三个指令：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In [Chapter 2](ch02.html "Chapter 2. Graphics – the Canvas"), *Graphics – the
    Canvas*, we used Kivy language to add shapes to the `canvas`. Now, we used Python
    code directly and not the Kivy language syntax anymore, although the Python `with`
    statement slightly resembles it and it is frequently used in the Kivy API. Notice
    that we kept the `Line` instance in the `selected` attribute in line 64 because
    we will need it in order to remove the rectangle once the widget is not selected
    anymore. Also, the `DraggableWidget` instance will be aware of when it is selected,
    either whether it contains a reference or is `None`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。图形 – 画布")，“图形 – 画布”，我们使用Kivy语言向`canvas`添加形状。现在，我们直接使用Python代码，而不是Kivy语言的语法，尽管Python的`with`语句与其略有相似，并且在Kivy
    API中经常使用。注意，我们在第64行的`selected`属性中保留了`Line`实例，因为我们需要它来在部件不再被选中时移除矩形。此外，`DraggableWidget`实例将知道何时被选中，无论是包含引用还是为`None`。
- en: 'That condition is used in the `on_touch_move` method:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 该条件用于`on_touch_move`方法：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this event, we control the dragging of `DraggableWidget`. In line 67, we
    make sure that `DraggableWidget` is selected. In the same line, we use `collide_point`
    again but this time, we use **`parent`** (*drawing space*) instead of `self`.
    This is the reason why the previous line (line 66) transformed the widget coordinates
    to values that are relative to the corresponding `parent` with the **`to_parent`**
    method. In other words, we have to check the `parent` (*drawing space*) because
    the `Stickman` can be dragged inside the whole of the *drawing space*, and not
    just inside `DraggableWidget` itself. The next section will explain in detail
    how to localize coordinates to different parts of the screen.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在此事件中，我们控制 `DraggableWidget` 的拖动。在第67行，我们确保 `DraggableWidget` 被选中。在同一行，我们再次使用
    `collide_point`，但这次我们使用 **`parent`**（*绘图空间*）而不是 `self`。这就是为什么上一行（第66行）将小部件坐标转换为相对于相应
    `parent` 的 **`to_parent`** 方法中的值。换句话说，我们必须检查 `parent`（*绘图空间*），因为 `Stickman` 可以在整个
    *绘图空间* 内拖动，而不仅仅是 `DraggableWidget` 本身。下一节将详细解释如何将坐标定位到屏幕的不同部分。
- en: Another detail of line 67 is that we check the left corner of the future position
    of `DraggableWidget` by subtracting half its width and height from the current
    touch (`touch.x - self.width/2, touch.y - self.height/2`). This is in order to
    make sure that we don't drag the shape outside the *drawing space* because we
    will drag it from the center.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第67行的另一个细节是，我们通过从当前触摸（`touch.x - self.width/2, touch.y - self.height/2`）减去小部件宽度的一半和高度的一半来检查
    `DraggableWidget` 未来位置的左角。这是为了确保我们不将形状拖出 *绘图空间*，因为我们将从中心拖动它。
- en: 'If the conditions are `True`, we call the `translate` method:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件为 `True`，我们调用 `translate` 方法：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The method moves the `DraggableWidget` (`x`, `y`) pixels by assigning new values
    to the `center_x` and `center_y` properties (lines 72 and 73). It also updates
    the `ix` and `iy` properties that we created in the `select` method before lines
    61 and 62.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法通过为新值分配 `center_x` 和 `center_y` 属性（第72行和第73行）来移动 `DraggableWidget`（`x`，`y`）像素。它还更新了我们在第61行和第62行之前的
    `select` 方法中创建的 `ix` 和 `iy` 属性。
- en: 'The last two lines (lines 69 and 70) of the `on_touch_move` method follow the
    same approach of the `on_touch_down` method (line 57 and 58), and also the `on_touch_up`
    method (lines 77 and 78):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_touch_move` 方法的最后两行（第69行和第70行）遵循与 `on_touch_down` 方法（第57行和第58行）相同的方法，同样也遵循
    `on_touch_up` 方法（第77行和第78行）：'
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `on_touch_up` event undoes the `on_touch_down` status. First, it checks
    whether it is selected using our `selected` attribute. If it is, then it calls
    the `unselected()` method:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_touch_up` 事件撤销 `on_touch_down` 状态。首先，它检查是否使用我们的 `selected` 属性选中。如果是，那么它调用
    `unselected()` 方法：'
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This method will dynamically call the **`remove`** method to remove the `Line`
    vertex instruction from the `canvas` (line 81), and set our attribute `selected`
    to `None` (line 82) to indicate that the widget is not being dragged anymore.
    Notice the different ways in which we add the `Line` vertex instruction (line
    63 and 64) and remove it (line 81).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将动态调用 **`remove`** 方法来从 `canvas`（第81行）中移除 `Line` 顶点指令，并将我们的属性 `selected`
    设置为 `None`（第82行），以表示小部件不再被拖动。注意我们添加 `Line` 顶点指令（第63行和第64行）和移除它的不同方式（第81行）。
- en: 'There are two more lines of code in `comicwidgets.py`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `comicwidgets.py` 中还有两行代码：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These lines define our `StickMan`, which now inherits from `DraggableWidget`
    (line 83) instead of from `RelativeLayout`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行定义了我们的 `StickMan`，现在它从 `DraggableWidget`（第83行）继承，而不是从 `RelativeLayout` 继承。
- en: 'A final change is necessary in `drawingspace.kv`, which now looks as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `drawingspace.kv` 中还需要进行最后的更改，现在看起来如下所示：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We added a border to `canvas.before` of the *drawing space* (lines 87 and 88),
    which will serve us a reference to visualize where the canvas starts or ends.
    We also kept a `StickMan` instance in the *drawing space*. You can run the application
    (`python comiccreator.py`) and drag the `StickMan` over the *drawing space*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *绘图空间* 的 `canvas.before` 中添加了一个边框（第87行和第88行），这将为我们提供一个参考，以可视化画布的起始或结束位置。我们还保留了一个
    `StickMan` 实例在 *绘图空间* 中。你可以运行应用程序（`python comiccreator.py`）并将 `StickMan` 拖动到 *绘图空间*
    上。
- en: '![Basic widget events – dragging the stickman](img/B04244_03_03.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![基本小部件事件 – 拖动 Stickman](img/B04244_03_03.jpg)'
- en: In this section, you learned the three basic touch events of any `Widget`. They
    are strongly dependent on the coordinates, and therefore it will be necessary
    to learn how to properly manipulate the coordinates. We introduce this technique
    in the `on_touch_move` method, but it will be the main topic in the next section,
    which explores the possible ways that Kivy offers to localize coordinates.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了任何 `Widget` 的三个基本触摸事件。它们与坐标密切相关，因此有必要学习如何正确地操作坐标。我们在 `on_touch_move`
    方法中介绍了这项技术，但它在下一节中将是主要内容，该节将探讨 Kivy 提供的定位坐标的可能方法。
- en: Localizing coordinates – adding stickmen
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地化坐标 – 添加人物
- en: In the last section, we used the **`to_parent()`** method (line 66) to translate
    the coordinates relative to the `DrawingSpace`, to its parent. Remember that we
    were inside `DraggableWidget` and the coordinates we received were relative to
    `parent` (`DrawingSpace`).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们使用了 **`to_parent()`** 方法（第 66 行）将相对于 `DrawingSpace` 的坐标转换为它的父级。记住，我们当时在
    `DraggableWidget` 内部，我们收到的坐标是相对于 `parent`（`DrawingSpace`）的。
- en: These coordinates are convenient for `DraggableWidget` because we positioned
    it in the parent's coordinates. The method allows us to use the coordinates in
    the parent's `collide_point`. This is no longer convenient for when we want to
    check the coordinates on the parent's `parent` space or when we need to draw something
    directly on the canvas of a `Widget`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些坐标对 `DraggableWidget` 非常方便，因为我们将其定位在父级坐标中。此方法允许我们在父级的 `collide_point` 中使用坐标。当我们要检查父级的
    `parent` 空间的坐标或需要直接在 `Widget` 的画布上绘制某些内容时，这就不再方便了。
- en: 'Before studying more examples, let''s review the theory. You learned that `RelativeLayout`
    is very useful because it is simpler to think inside a constraint space to localize
    our objects. The problems start when we need to translate coordinates to another
    `Widget` area. Let''s consider the following screenshot of a Kivy program:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习更多示例之前，让我们回顾一下理论。你了解到 `RelativeLayout` 非常有用，因为它在约束空间内思考定位我们的对象要简单得多。问题开始于我们需要将坐标转换为另一个
    `Widget` 区域时。让我们考虑以下 Kivy 程序的截图：
- en: '![Localizing coordinates – adding stickmen](img/B04244_03_04.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![本地化坐标 – 添加人物](img/B04244_03_04.jpg)'
- en: The code to generate this example is not shown here since it is very straightforward.
    If you want to test it, you can find the code under the folder `04 - Embedding
    RelativeLayouts/` and run it with `python main.py --size=150x75`. It consists
    of three `RelativeLayouts` embedded into each other. The **Blue** (darker gray)
    is parent of the **Green** (light gray) and the **Green** is parent of **Red**
    (middle gray). The **a** (in the top-right corner) is a `Label` instance located
    at the position `(5, 5)` inside **Red** (middle gray) `RelativeLayout`. The **Blue**
    layout (dark gray) is the size of the window (150 x 75). The rest of the elements
    are indicators (no part of the code) to help you understand the example.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 生成此示例的代码在此处未显示，因为它非常直接。如果你想测试它，可以在文件夹 `04 - Embedding RelativeLayouts/` 下找到代码，并使用
    `python main.py --size=150x75` 运行它。它由三个相互嵌套的 `RelativeLayouts` 组成。**蓝色**（较深灰色）是
    **绿色**（浅灰色）的父级，而 **绿色** 是 **红色**（中间灰色）的父级。**a**（在右上角）是一个位于 **红色**（中间灰色）`RelativeLayout`
    内部位置 `(5, 5)` 的 `Label` 实例。**蓝色**布局（深灰色）是窗口的大小（150 x 75）。其余元素是指标（代码的一部分）以帮助你理解示例。
- en: 'The preceding screenshot includes some measurements that help explain the four
    methods of localizing coordinates that the `Widget` class provides:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图包含一些测量值，有助于解释 `Widget` 类提供的四种本地化坐标的方法：
- en: '**`to_parent()`**: This method transforms relative coordinates inside `RelativeLayout`
    to the parent of `RelativeLayout`. For example, `red.to_parent(a.x, a.y)` returns
    the coordinates of `a` relative to the green (light gray) layout, which are `(50+5,
    25+5) = (55, 30)`.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`to_parent()`**: 此方法将 `RelativeLayout` 内部的相对坐标转换为 `RelativeLayout` 的父坐标。例如，`red.to_parent(a.x,
    a.y)` 返回 `a` 相对于绿色（浅灰色）布局的坐标，即 `(50+5, 25+5) = (55, 30)`。'
- en: '**`to_local()`**: This method transforms the coordinates of `parent` of `RelativeLayout`
    to `RelativeLayout`. For example, `red.to_local(55,30)` returns `(5,5)`, the coordinates
    of the `a` label relative to the red layout (middle gray).'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`to_local()`**: 此方法将 `RelativeLayout` 的 `parent` 坐标转换为 `RelativeLayout`。例如，`red.to_local(55,30)`
    返回 `(5,5)`，这是 `a` 标签相对于红色布局（中间灰色）的坐标。'
- en: '**`to_window()`**: This method transforms the coordinates of the current `Widget`
    to absolute coordinates with respect to the window. For example, `a.to_window(a.x,
    a.y)` returns the absolute coordinates of **a** which are`(100 + 5, 50 + 5) =
    (105, 55)`.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`to_window()`**：此方法将当前`Widget`的坐标转换为相对于窗口的绝对坐标。例如，`a.to_window(a.x, a.y)`返回**a**的绝对坐标，即`(100
    + 5, 50 + 5) = (105, 55)`。'
- en: '**`to_widget()`**: This method transforms the absolute coordinates to coordinates
    within the parent of the current widget. For example, `a.to_widget(105,55)` returns
    `(5,5)`, again the coordinates of `a` relative to the `red` (middle gray) layout.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`to_widget()`**：此方法将绝对坐标转换为当前小部件的父级内的坐标。例如，`a.to_widget(105,55)`返回`(5,5)`，再次是`a`相对于`red`（中间灰色）布局的坐标。'
- en: The last two methods don't use the `red` layout to transform the coordinates
    because in this case, Kivy assumes that the coordinates are always relative to
    the parent. There is also a `Boolean` parameter (called **`relative`**), which
    controls whether the coordinates are relative inside the `Widget`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个方法不使用`red`布局来转换坐标，因为在这种情况下，Kivy假设坐标总是相对于父级。还有一个`Boolean`参数（称为**`relative`**），它控制坐标是否在`Widget`内部是相对的。
- en: Let's study a real example in the *Comic Creator* project. We will add events
    to the *tool box* buttons, so that we can add figures to the *drawing space*.
    In this process, we will encounter a scenario in which we have to use one of the
    before-mentioned methods to localize our coordinates correctly to the `Widget`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在*Comic Creator*项目中研究一个真实示例。我们将向*toolbox*按钮添加事件，以便我们可以向*drawing space*添加图形。在这个过程中，我们将遇到一个场景，我们必须使用之前提到的方法来正确地将我们的坐标定位到`Widget`。
- en: 'This code corresponds to the header of the `toolbox.py` file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码对应于`toolbox.py`文件的标题：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The structure in lines 99 to 106 is already familiar. Line 102 makes sure that
    `ToolButton` is in the `'down'` state and that the event happened in the `DrawingSpace`
    instance (referenced by `ds`). Remember that the parent of `ToolButton` is `ToolBox`
    and that we added an attribute that references the `DrawingSpace` instance in
    `comiccreator.kv` at the beginning of the chapter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第99到106行的结构已经很熟悉了。第102行确保`ToolButton`处于`'down'`状态，并且事件发生在`DrawingSpace`实例（由`ds`引用）中。记住，`ToolButton`的父级是`ToolBox`，我们在本章开头在`comiccreator.kv`中添加了一个引用`DrawingSpace`实例的属性。
- en: The `draw` method is called in line 104\. It will draw the respective shapes
    according to the derived classes (`ToolStickMan`, `ToolCircle`, and `ToolLine`).
    We need to be sure that we send the right coordinates to the `draw` method. Therefore,
    before calling it, we need to translate the absolute coordinates (received in
    `on_touch_down` of `ToolButton`) to relative coordinates (appropriated for the
    *drawing space*) with the `to_widget` event (line 103).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第104行调用了`draw`方法。它将根据派生类（`ToolStickMan`、`ToolCircle`和`ToolLine`）绘制相应的形状。我们需要确保向`draw`方法发送正确的坐标。因此，在调用它之前，我们需要使用`to_widget`事件（第103行）将接收到的绝对坐标（在`ToolButton`的`on_touch_down`中接收）转换为相对坐标（适用于*drawing
    space*）。
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We know that the coordinates we received (`touch.x` and `touch.y`) are absolute
    because `ToolStickman` is not `RelativeLayout`, whereas the `DrawingSpace` (`ds`)
    is.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们接收到的坐标（`touch.x`和`touch.y`）是绝对的，因为`ToolStickman`不是`RelativeLayout`，而`DrawingSpace`（`ds`）是。
- en: 'Let''s continue studying the `toolbox.py` file and see how `ToolStickMan` actually
    adds `StickMan`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续研究`toolbox.py`文件，看看`ToolStickMan`实际上是如何添加`StickMan`的：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We create an instance of `Stickman` (line 112), use the translated coordinates
    (line 103) to center the `Stickman`, and finally (line 119), add it to the `DrawingSpace`
    instance with the **`add_widget`** method (line 114). We just need to update a
    few lines in `toolbox.kv` in order to run the project with new changes:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`Stickman`实例（第112行），使用转换后的坐标（第103行）来居中`Stickman`，最后（第119行），使用**`add_widget`**方法（第114行）将其添加到`DrawingSpace`实例中。我们只需要更新`toolbox.kv`中的几行，以便运行带有新更改的项目：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we need to import `toolbox.py` (line 116), then we remove `@ToggleButton`
    from `ToolButton` (line 118) because we added it in `toolbox.py`, and finally
    we replace the last `ToolButton` for our new `ToolStickman` widget (line 122).
    At this point, we are able to add *stickmen* to the *drawing space* and also drag
    them over it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入`toolbox.py`（第116行），然后从`ToolButton`中移除`@ToggleButton`（第118行），因为我们已经在`toolbox.py`中添加了它，并且最后我们将最后一个`ToolButton`替换为我们的新`ToolStickman`小部件（第122行）。到这个时候，我们能够向`drawing
    space`添加*stickmen*，并且也可以将它们拖拽到上面。
- en: '![Localizing coordinates – adding stickmen](img/B04244_03_05.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![本地化坐标 – 添加人物](img/B04244_03_05.jpg)'
- en: We have covered the basics now, so let's learn how to bind and unbind events
    dynamically.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了基础知识，让我们学习如何动态地绑定和解绑事件。
- en: Binding and unbinding events – sizing limbs and heads
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定和解绑事件 – 调整肢体和头部大小
- en: 'In the previous two sections, we override basic events to perform actions we
    want. In this section, you will learn how to bind and unbind events dynamically.
    It was quite an easy job to add our `Stickman` because it is a `Widget` already,
    but what about the graphics, the circle, and the rectangle? We could create some
    widgets for them, just as we did with the `Stickman`, but let''s attempt something
    braver before that. Instead of just clicking on the *drawing space*, let''s drag
    the mouse on its border to decide the size of the circle or line:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个部分中，我们覆盖了基本事件以执行我们想要的操作。在本节中，你将学习如何动态地绑定和解绑事件。添加我们的`Stickman`相当容易，因为它已经是一个`Widget`了，但图形、圆和矩形怎么办？我们可以为它们创建一些小部件，就像我们对`Stickman`所做的那样，但在那之前让我们尝试一些更勇敢的事情。不是仅仅点击在*绘图空间*上，而是拖动鼠标在其边界上以决定圆或线的尺寸：
- en: '![Binding and unbinding events – sizing limbs and heads](img/B04244_03_06.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![绑定和解绑事件 – 调整肢体和头部大小](img/B04244_03_06.jpg)'
- en: Using mouse to set the size
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用鼠标设置大小
- en: 'Once we finish the dragging (and we are satisfied with the size), let''s dynamically
    create `DraggableWidget` that will contain the shape, so we can also drag them
    over the `DrawingSpace` instance. The following class diagram will help us understand
    the whole inheritance structure of the `toolbox.py` file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成拖动（并且我们对大小满意），让我们动态创建包含形状的`DraggableWidget`，这样我们也可以在`DrawingSpace`实例上拖动它们。以下类图将帮助我们理解`toolbox.py`文件的整个继承结构：
- en: '![Binding and unbinding events – sizing limbs and heads](img/B04244_03_07.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![绑定和解绑事件 – 调整肢体和头部大小](img/B04244_03_07.jpg)'
- en: The diagram includes `ToolButton` and `ToolsStickman`, which were explained
    in the last section, but it also includes three new classes called `ToolFigure`,
    `ToolLine`, and `ToolCircle`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图表包括在上一节中解释的`ToolButton`和`ToolsStickman`，但它还包括三个新类，称为`ToolFigure`、`ToolLine`和`ToolCircle`。
- en: 'The `ToolFigure` class has six methods. Let''s start with a quick overview
    of these methods and then highlight the important and new parts:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToolFigure`类有六个方法。让我们先快速概述这些方法，然后突出显示重要和新颖的部分：'
- en: '`draw`: This method overrides `draw` of `ToolButton` (lines 108 and 109). The
    position where we touch down indicates the starting point of our figure, either
    the center for a circle or one of the ends of a line.'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`draw`：此方法覆盖了`ToolButton`的`draw`方法（第108和109行）。我们触摸下的位置表示图形的起点，对于圆来说是中心，对于线来说是线的端点之一。'
- en: '[PRE15]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`update_figure`: This method updates the end-point of the figure when we drag.
    Either the end of a line or the radius (distance from the starting point to the
    end point) of the circle.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`update_figure`：此方法在拖动时更新图形的终点。要么是线的终点，要么是圆的半径（从起点到终点的距离）。'
- en: '[PRE16]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`end_figure`: This method indicates the final end point of the figure with
    the same logic as in `update_figure`. Also, we put the final figure inside `DraggableWidget`
    (see `widgetize`).'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`end_figure`：此方法使用与`update_figure`中相同的逻辑指示图形的最终终点。我们还将最终图形放入`DraggableWidget`中（见`widgetize`）。'
- en: '[PRE17]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`widgetize`: This method creates `DraggableWidget` and places the figure in
    it. It uses four coordinates that have to be localized correctly with the localization
    methods:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`widgetize`：此方法创建`DraggableWidget`并将图形放入其中。它使用四个必须通过本地化方法正确本地化的坐标：'
- en: '[PRE18]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`create_figure`: This method will be overridden by `ToolLine` (lines 153 and
    154) and `ToolCircle` (lines 162 to 163). It creates the respective figure, given
    four coordinates:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`create_figure`：此方法将被`ToolLine`（第153和154行）和`ToolCircle`（第162至163行）覆盖。它根据四个坐标创建相应的图形：'
- en: '[PRE19]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`create_widget`: This method is also overridden by `ToolLine` (lines 156 to
    159) and `ToolCircle` (lines 165 to 169). It creates a respectively positioned
    and sized `DraggableWidget` given four coordinates.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`create_widget`：此方法也被`ToolLine`（第156至159行）和`ToolCircle`（第165至169行）覆盖。它根据四个坐标创建相应位置和大小的`DraggableWidget`。'
- en: '[PRE20]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Most of the statements from the preceding methods have already been covered.
    The new topic of this code is the dynamic **`bind`**/**`unbind`** of events. The
    main problem we needed to solve is that we didn't want the `on_touch_move` and
    `on_touch_up` events active all the time. We needed to activate them (**`bind`**)
    from the moment the user starts drawing (`on_touch_down` of `ToolButton` that
    calls on the method `draw`) until the user decides the size and does a touch up.
    Therefore, we bound `update_figure` and `end_figure`, respectively, to the `on_touch_move`
    and `on_touch_up` events of `DrawingSpace` when the method `draw` is called on
    (lines 128 and 129). Also, we unbound them when the user ends the figure on method
    `end_figure` (lines 137 and 138). Notice that we can unbind the same method that
    is being executed (`end_figure`) from the `on_touch_up` event. We want to avoid
    calling the methods `update_figure` and `end_figure` unnecessarily. With this
    approach, they are going to be called only when the figure is drawn for the first
    time.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法中的大多数语句已经介绍过了。这段代码的新主题是事件的动态**`bind`**/**`unbind`**。我们需要解决的主要问题是，我们不想`on_touch_move`和`on_touch_up`事件始终处于活动状态。我们需要从用户开始绘制（调用`draw`方法的`ToolButton`的`on_touch_down`）的那一刻起激活它们，直到用户决定大小并执行触摸抬起。因此，当调用`draw`方法时，我们将`update_figure`和`end_figure`分别绑定到`DrawingSpace`的`on_touch_move`和`on_touch_up`事件（第128行和第129行）。此外，当用户在`end_figure`方法上结束图形时，我们将它们解绑（第137行和第138行）。请注意，我们可以从`on_touch_up`事件中解绑正在执行的方法（`end_figure`）。我们希望避免不必要地调用`update_figure`和`end_figure`方法。采用这种方法，它们只会在图形第一次绘制时被调用。
- en: There are a few other interesting things in this code that deserve some attention.
    In line 125, we created two class attributes (`self.ix` and `self.iy`) to keep
    the coordinates of the initial touch. We use those coordinates each time we update
    the figure (line 135) and when we put the figure into a `Widget` (line 141).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中还有一些其他有趣的事情值得注意。在第125行，我们创建了两个类属性（`self.ix`和`self.iy`）来保存初始触摸的坐标。每次我们更新图形（第135行）和将图形放入`Widget`（第141行）时，我们都会使用这些坐标。
- en: We also use some of the localizing methods that we covered in the previous section.
    In lines 132 and 140, we used `to_widget` to translate the coordinates to the
    `DrawingSpace` instance. The lines 144 and 145 use `to_local` to translate the
    coordinates to `DraggableWidget`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了之前章节中介绍的一些本地化方法。在第132行和第140行，我们使用了`to_widget`将坐标转换到`DrawingSpace`实例。第144行和第145行使用`to_local`将坐标转换到`DraggableWidget`。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`DraggableWidget` is instructed to translate the coordinates to its inner relative
    space with the parameter **`relative`**`=True` because `DraggableWidget` is relative
    and we are trying to draw inside it (not inside the parent: the *drawing space*).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`DraggableWidget`被指示使用参数**`relative`**`=True`将坐标转换到其内部相对空间，因为`DraggableWidget`是相对的，我们试图在其中绘制（不是在父级：*绘图空间*）。'
- en: 'There is some basic math involved in the calculation of the position and sizes
    of the figures and widgets. We have intentionally moved it to the deeper classes
    of the inheritance: `ToolLine` and `ToolCircle`. The following is their code,
    the last part of `toolbox.py`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形和控件的位置和尺寸计算中涉及一些基本的数学。我们有意将其移动到继承的更深层类中：`ToolLine`和`ToolCircle`。以下是它们的代码，`toolbox.py`的最后部分：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The math involves concepts of geometry that escape the scope of this book.
    It is important to understand that the methods of this code section adapts the
    calculations to create either lines or circles. Finally, we apply some changes
    to the `ToolBox` class in `toolbox.kv`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的数学涉及几何概念，超出了本书的范围。重要的是要理解，这个代码段的这些方法将计算适应为创建线或圆。最后，我们在`toolbox.kv`中的`ToolBox`类中做了一些更改：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The new classes `ToolCircle` (line 179), `ToolLine` (line 184), and `ToolStickMan`
    (line 189) have replaced the previous `ToolButton` instances. Now, we can also
    add and scale lines and circles to the *drawing space*:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 新的类`ToolCircle`（第179行）、`ToolLine`（第184行）和`ToolStickMan`（第189行）已经替换了之前的`ToolButton`实例。现在，我们也可以将线和圆添加并缩放到*绘图空间*：
- en: '![Binding and unbinding events – sizing limbs and heads](img/B04244_03_08.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![绑定和解绑事件 – 调整肢体和头部大小](img/B04244_03_08.jpg)'
- en: We also created some attributes (lines 176, 177, and 178) that will be useful
    in [Chapter 4](ch04.html "Chapter 4. Improving the User Experience"), *Improving
    the User Experience*, when we use gestures to create figures.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一些属性（第176行、第177行和第178行），这些属性在[第4章](ch04.html "第4章。改进用户体验")中将会很有用，即*改进用户体验*，当我们使用手势创建图形时。
- en: Binding events in the Kivy language
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kivy 语言中绑定事件
- en: 'So far, we have been handling events in two ways: overridding an event method
    (for example, `on_touch_event`) and binding a personalize method to a related
    event method (for example, `ds.bind(on_touch_move=self.update_figure)`). In this
    section, we will discuss a different way, that is, binding events in the Kivy
    language. Potentially, we could have done this since the beginning of this chapter
    when we started working with `DraggableWidget` but there is a difference. If we
    use the Kivy language, we can easily add the event to a specific instance and
    not to all the instances of the same class. In this sense, it resembles dinamically
    binding an instance to its callback with the `bind` method.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在两种方式下处理事件：重写事件方法（例如，`on_touch_event`）和将自定义方法绑定到相关事件方法（例如，`ds.bind(on_touch_move=self.update_figure)`）。在本节中，我们将讨论另一种方式，即在
    Kivy 语言中绑定事件。实际上，我们可以在本章开始与 `DraggableWidget` 一起工作时就做这件事，但这里有一个区别。如果我们使用 Kivy
    语言，我们可以轻松地将事件添加到特定实例，而不是添加到同一类的所有实例。从这个意义上说，它类似于使用 `bind` 方法动态地将实例绑定到其回调。
- en: 'We are going to concentrate on new events specific to `Button` and `ToggleButton`.
    The following is the code for `generaloption.kv`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于 `Button` 和 `ToggleButton` 的特定新事件。以下是 `generaloption.kv` 的代码：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `Button` class has two extra events: **`on_press`** and **`on_release`**.
    The former is similar to `on_touch_down` and the latter is similar to `on_touch_up`.
    However, in this case, we don''t need to worry about calling the `collide_point`
    method. We used `on_press` for the **Clear** `Button` (line 200) and the **Color**
    `Button` (line 209) and `on_release` for the **Remove** `Button` (line 203) to
    illustrate both methods, but for this particular case, it does not really matter
    which one we pick. The **`on_state`** event is already a part of the `Button`
    class, although more commonly used in the ToggleButton instances. This event is
    triggered every time the state of `ToogleButton` changes from `''normal''` to
    `''down''` and vice versa. The **`on_state`** event is used in lines 206 and 212\.
    All the events are bound to methods in the root, which are defined in the `generaloptions.py`
    file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button` 类有两个额外的事件：**`on_press`** 和 **`on_release`**。前者类似于 `on_touch_down`，后者类似于
    `on_touch_up`。然而，在这种情况下，我们不需要担心调用 `collide_point` 方法。我们使用 `on_press` 为 **`Clear`**
    `Button`（第 200 行）和 **`Color`** `Button`（第 209 行），以及 `on_release` 为 **`Remove`**
    `Button`（第 203 行）来展示这两种方法，但在这个特定情况下，选择哪一个实际上并不重要。**`on_state`** 事件已经是 `Button`
    类的一部分，尽管它更常用于 `ToggleButton` 实例中。每当 `ToogleButton` 的状态从 `''normal''` 变为 `''down''`
    或相反时，都会触发 **`on_state`** 事件。**`on_state`** 事件在第 206 行和第 212 行使用。所有事件都绑定到根目录中的方法，这些方法在
    `generaloptions.py` 文件中定义：'
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `GeneralOptions` method illustrates a few other methods of the `Widget`
    class. The `clear` method removes all the widgets from the `DrawingSpace` instance
    through the **`clear_widgets`** method (line 222). The following screenshot show
    the result of clicking on it:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`GeneralOptions` 方法展示了 `Widget` 类的几种其他方法。`clear` 方法通过 **`clear_widgets`** 方法（第
    222 行）从 `DrawingSpace` 实例中删除所有小部件。以下截图显示了点击它的结果：'
- en: '![Binding events in the Kivy language](img/B04244_03_09.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![在 Kivy 语言中绑定事件](img/B04244_03_09.jpg)'
- en: The **`remove_widget`** method removes the last added `Widget` instance accessing
    the **`children`** list (line 227). The `group` method modifies the `group_mode`
    attribute of line 218 according to the `'down'` or `'normal'` `ToggleButton` state.
    The `color` and `gestures` methods will be completed in [Chapter 4](ch04.html
    "Chapter 4. Improving the User Experience"), *Improving the User Experience*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**`remove_widget`** 方法通过访问 **`children`** 列表删除最后添加的 `Widget` 实例（第 227 行）。`group`
    方法根据 `''down''` 或 `''normal''` 的 `ToggleButton` 状态修改第 218 行的 `group_mode` 属性。`color`
    和 `gestures` 方法将在 [第 4 章](ch04.html "第 4 章。改进用户体验") *改进用户体验* 中完成。'
- en: The *group mode* will allow the user to select several `DraggableWidget` instances
    in order to drag them at the same time. We activated or deactivated the *group
    mode* according to the state of the `ToggleButton`. In the next section, we will
    actually allow multiple selections and dragging in the `DraggableWidget` class.
    For now, we will just get the controls ready with the `unselect_all` and `on_translation`
    methods.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*`group mode`* 将允许用户选择多个 `DraggableWidget` 实例，以便同时拖动它们。我们根据 `ToggleButton`
    的状态激活或停用 *`group mode`*。在下一节中，我们将实际上允许在 `DraggableWidget` 类中进行多选和拖动。目前，我们只需使用
    `unselect_all` 和 `on_translation` 方法准备好控件。'
- en: When the *group mode* is deactivated, we make sure that all the selected widgets
    are unselected, by calling the `unselect_all` method (line 242). The `unselect_all`
    method traverses the list of children calling the internal method `unselect` of
    each `DraggableWidget` (line 79).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *分组模式* 被禁用时，我们通过调用 `unselect_all` 方法（第 242 行）确保所有选中的小部件都被取消选择。`unselect_all`
    方法遍历子部件列表，调用每个 `DraggableWidget` 的内部方法 `unselect`（第 79 行）。
- en: Lastly, the `on_translation` method also traverses the children list calling
    the internal `translate` method (line 71) of each `DraggableWidget`. The question
    is; what calls the `on_translation` method? One of the most useful features of
    Kivy provides the answer to this question; this will be explained in the next
    section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`on_translation` 方法也会遍历子部件列表，调用每个 `DraggableWidget` 的内部 `translate` 方法（第
    71 行）。问题是；什么调用了 `on_translation` 方法？Kivy 提供的最有用功能之一就是回答这个问题；这将在下一节中解释。
- en: Creating your own events – the magical properties
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自己的事件 – 神奇的属性
- en: This section covers the use of the Kivy properties. A Kivy property triggers
    an event every time we modify it. There are different types of properties, from
    the simple **`NumericProperty`** or **`StringProperty`** to much more complex
    versions such as **`ListProperty`**, **`DictProperty`**, or **`ObjectProperty`**.
    For example, if we define a **`StringProperty`** called `text`, then an `on_text`
    event is going to be triggered each time the text is modified.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了 Kivy 属性的使用。每次我们修改 Kivy 属性时，它都会触发一个事件。属性类型多种多样，从简单的 **`NumericProperty`**
    或 **`StringProperty`** 到更复杂的版本，如 **`ListProperty`**、**`DictProperty`** 或 **`ObjectProperty`**。例如，如果我们定义一个名为
    `text` 的 **`StringProperty`**，那么每次文本被修改时，都会触发一个 `on_text` 事件。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Once we define a Kivy property, Kivy internally creates an event associated
    with that property. The property event is referenced adding the prefix `on_` to
    the name of the property. For example, the `on_translation` method (line 246)
    is associated with `ListProperty` in line 219 called `translation`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了一个 Kivy 属性，Kivy 就会在内部创建与该属性相关联的事件。属性事件通过在属性名称前添加前缀 `on_` 来引用。例如，`on_translation`
    方法（第 246 行）与第 219 行的 `translation` **`ListProperty`** 相关联。
- en: All the properties work in the same way. For example, the `state` property that
    we used in the `ToogleButton` class is actually a property that creates the `on_state`
    event. We already used this event in line 206\. We define the property and Kivy
    creates the event for us.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 所有属性的工作方式相同。例如，我们在 `ToogleButton` 类中使用的 `state` 属性实际上是一个创建 `on_state` 事件的属性。我们已经在第
    206 行使用了这个事件。我们定义属性，Kivy 就会为我们创建事件。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the context of this book, a **property** will always refer to a Kivy property
    and it should not be confused with a Python property, which is a different concept
    not covered in this book. An **attribute** is used to describe variables (references,
    objects, and instances) that belong to the class. As a general rule, a Kivy property
    is always an attribute but an attribute is not necessarily a Kivy property.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的上下文中，一个 **属性** 总是指 Kivy 属性，不应与 Python 属性混淆，Python 属性是一个不同的概念，本书没有涉及。**属性**用于描述属于类的变量（引用、对象和实例）。作为一个一般规则，Kivy
    属性始终是一个属性，但属性不一定是 Kivy 属性。
- en: 'In this section, we implement *group mode*, which offers the possibility of
    selecting and dragging several figures (`DraggableWidgets` instances) at the same
    time by pressing the **Group** button (line 204). In order to do this, we can
    take advantage of the relation between the `translation` property and the `on_translation`
    method. Basically, every time we modify the `translation` property, the `on_translation`
    event is triggered. Say that we drag three figures at the same time (with the
    *group mode*) as shown in the following screenshot:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们实现了 *分组模式*，该模式通过按下 **分组** 按钮（第 204 行）允许同时选择和拖动多个图形（`DraggableWidgets`
    实例）。为了做到这一点，我们可以利用 `translation` 属性和 `on_translation` 方法之间的关系。基本上，每次我们修改 `translation`
    属性时，都会触发 `on_translation` 事件。假设我们同时拖动三个图形（使用 *分组模式*），如下面的截图所示：
- en: '![Creating your own events – the magical properties](img/B04244_03_10.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![创建自己的事件 – 神奇的属性](img/B04244_03_10.jpg)'
- en: The three figures are selected but the events are handled by the circle, since
    it is the one that has the pointer on top. The circle needs to tell the line and
    the stickman to translate. Instead of calling the `on_translation` method, it
    only needs to modify the `translation` property, and the `on_translation` event
    is triggered. Let's include these changes in `comicwidgets.py`. We need four modifications.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 三个图形被选中，但事件由圆圈处理，因为它是唯一一个指针在顶部的图形。圆圈需要告诉线条和人物移动。它不需要调用 `on_translation` 方法，只需要修改
    `translation` 属性，从而触发 `on_translation` 事件。让我们将这些更改包含在 `comicwidgets.py` 中。我们需要进行四个修改。
- en: 'First, we need to add the `touched` attribute (line 252) to indicate which
    of the selected figures receives the event (for example, the circle in the previous
    screenshot). We do this in the constructor:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在构造函数中添加 `touched` 属性（第 252 行），以指示哪个选中的图形接收事件（例如，上一张截图中的圆圈）。我们这样做：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Second, we need to set the `touched` attribute to `True` (line 256) when one
    of the `DraggableWidget` instances receives the event. We do this in the `on_touch_down`
    method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，当 `DraggableWidget` 中的一个实例接收事件时，我们需要将 `touched` 属性设置为 `True`（第 256 行）。我们在
    `on_touch_down` 方法中这样做：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Third, we need to check that `DraggableWidget` is the one that is currently
    being touched (received the `on_touch_down` event previously). We add this to
    the condition in line 262\. The most important change is in line 264\. Instead
    of calling the `translate` method directly, we modify the `translation` property
    of *general options* (`self.parent.general_options`) setting the number of pixels
    the widget has been translated to the property. This will trigger the `on_translation`
    method of `GeneralOptions`, which at the same time calls the `translate` method
    for each selected `DraggableWidget`. This is the resulting code for `on_touch_move`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们需要检查 `DraggableWidget` 是否是当前被触摸的图形（之前接收了 `on_touch_down` 事件）。我们在第 262 行的条件中添加了这个检查。最重要的更改在第
    264 行。我们不是直接调用 `translate` 方法，而是修改 `general options`（`self.parent.general_options`）的
    `translation` 属性，将小部件移动到的像素数设置到属性中。这将触发 `GeneralOptions` 的 `on_translation` 方法，同时为每个选中的
    `DraggableWidget` 调用 `translate` 方法。这是 `on_touch_move` 的结果代码：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Fourth, we need to set the `touched` attribute to `False` (line 268) on the
    `on_touch_up` event, and also avoid calling the `unselect` method when we use
    `group_mode` (line 270). Here is the code for the `on_touch_up` method:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，我们需要在 `on_touch_up` 事件中将 `touched` 属性设置为 `False`（第 268 行），并且在使用 `group_mode`（第
    270 行）时避免调用 `unselect` 方法。以下是 `on_touch_up` 方法的代码：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This example could be considered artificial, since we theoretically could have
    called the `on_translation` method from the start. However, properties are crucial
    in order to keep consistency of the internal state of a variable and the screen
    display. The example from the next section will improve your understanding of
    this.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以被认为是人为的，因为我们理论上可以从一开始就调用 `on_translation` 方法。然而，属性对于保持变量的内部状态和屏幕显示的一致性至关重要。下一节的示例将提高你对这一点的理解。
- en: Kivy and its properties
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kivy 及其属性
- en: Even though we have only touched upon explanations of properties in the previous
    section, the truth is that we have been using them since the beginning of this
    chapter. Kivy's internals are full of properties. They are almost everywhere.
    For example, when we implemented `DraggableWidget`, we simply modified the `center_x`
    property (line 72 and 73), and the whole `Widget` was then kept updated because
    there is a chain of properties involved in the use of `center_x`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在上一节中只简要介绍了属性的解释，但事实是我们从本章开始就已经在使用它们了。Kivy 的内部充满了属性。它们几乎无处不在。例如，当我们实现 `DraggableWidget`
    时，我们只是修改了 `center_x` 属性（第 72 行和第 73 行），然后整个 `Widget` 就会保持更新，因为 `center_x` 的使用涉及到一系列的属性。
- en: 'The last example in this chapter illustrates how powerful Kivy properties are.
    Here is the code for `statusbar.py`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一个示例说明了 Kivy 属性是多么强大。以下是 `statusbar.py` 的代码：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The way Kivy properties work can be perceived as confusing by some advanced
    Python or Java programmers. The confusion happens when a programmer assumes that
    `counter` (line 278) is a static attribute of the `StatusBar` class because `counter`
    is defined in an equivalent way to the Python static attributes (for example,
    `previous_counter` in line 279). The assumption is incorrect.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy 属性的工作方式可能会让一些高级的 Python 或 Java 程序员感到困惑。困惑发生在程序员假设 `counter`（第 278 行）是 `StatusBar`
    类的静态属性，因为 `counter` 的定义方式与 Python 的静态属性类似（例如，第 279 行的 `previous_counter`）。这种假设是不正确的。
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Kivy properties are declared as static attribute classes (since they belong
    to the class), but they are always internally transformed to attribute instances.
    They actually belong to the object as we would have declared them in the constructor.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Kivy属性被声明为静态属性类（因为它们属于类），但它们总是内部转换为属性实例。实际上，它们属于对象，就像我们在构造函数中声明的那样。
- en: We need to distinguish between a static attribute of a class and an attribute
    of a class instance. In Python, `previous_counter` (line 279) is a static attribute
    of the `StatusBar` class. This means that it is shared among all the `StatusBar`
    instances, and it can be accessed in any of the ways shown in lines 284 and 286
    (however, line 284 is recommended because it is independent of the class name).
    In contrast, the `selected` variable (line 251) is an attribute of a `DraggableWidget`
    instance. This means that there is a `selected` variable per `StatusBar` object.
    It is not shared among them. They are created until the constructor (`__init__`)
    is called. The only way to access it is through `obj.selected` (line 251). The
    `counter` property (line 278) behaves more similarly to the `selected` attribute
    than to the `previous_counter` static attribute, in the sense that there is one
    `counter` property and one `selected` attribute in each instance.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要区分类的静态属性和类的实例属性。在Python中，`previous_counter`（第279行）是`StatusBar`类的静态属性。这意味着它是所有`StatusBar`实例共享的，并且可以通过第284行和第286行所示的方式之一访问（然而，建议使用第284行，因为它与类名无关）。相比之下，`selected`变量（第251行）是`DraggableWidget`实例的属性。这意味着每个`StatusBar`对象都有一个`selected`变量。它们之间不共享。它们在构造函数（`__init__`）被调用之前创建。访问它的唯一方法是`obj.selected`（第251行）。`counter`属性（第278行）在行为上更类似于`selected`属性，而不是`previous_counter`静态属性，因为在每个实例中都有一个`counter`属性和一个`selected`属性。
- en: 'Now that this has been clarified, we can move on to study the example. The
    `counter` is defined as `NumericProperty` in line 278\. It corresponds to the
    `on_counter` method (line 281) and modifies `Label` (`msg_text`) defined in the
    `statusbar.kv` file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 既然已经澄清了这一点，我们就可以继续研究示例。`counter`在第278行定义为`NumericProperty`。它对应于`on_counter`方法（第281行）并修改了在`statusbar.kv`文件中定义的`Label`（`msg_text`）。
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that we use `id` (line 297) again in order to define `msg_text` (line 292).
    Also, we use `counter` defined in line 278 to update the **Total Figures** message
    in line 295\. The specific part (`str(root.counter)`) of `text` is updated automatically
    when `counter` is modified.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们再次使用`id`（第297行）来定义`msg_text`（第292行）。我们还使用第278行定义的`counter`来更新第295行的`**总图数**`信息。`text`的具体部分（`str(root.counter)`）在`counter`修改时自动更新。
- en: 'So, we just need to modify the `counter` property, and the interface is updated
    automatically. Let''s update the counter in `drawingspace.py`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只需修改`counter`属性，界面就会自动更新。让我们在`drawingspace.py`中更新计数器：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We updated `counter` with the length of `children` of the `DrawingSpace` in
    the method `on_children`. Then, `on_children` is called every time we add (line
    114 or 147) or remove (line 222 or 227) widgets from the `children` list of the
    `DrawingSpace` because `children` is also a Kivy property.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在`on_children`方法中，我们将`counter`更新为`DrawingSpace`的`children`长度。然后，每当我们在`DrawingSpace`的`children`列表中添加（第114行或第147行）或删除（第222行或第227行）小部件时，都会调用`on_children`，因为`children`也是一个Kivy属性。
- en: 'Don''t forget to import this file into `drawingspace.py` in the `drawingspace.kv`
    file, in which we also removed the border of the *drawing space*:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将此文件导入`drawingspace.py`文件中的`drawingspace.kv`文件，其中我们还在`*绘图空间*`中移除了边框：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following diagram shows a chain of elements (properties, methods, and widgets)
    that are associated with the `children` property:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了与`children`属性相关联的元素链（属性、方法和小部件）：
- en: '![Kivy and its properties](img/B04244_03_11.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![Kivy及其属性](img/B04244_03_11.jpg)'
- en: It is important to compare again the way we gain access to the `counter` property
    and the `msg_label` attribute. We defined the `counter` property in the `StatusBar`
    (line 278) and used it in `Label` through the `root` (line 295). In the `msg_label`
    case, we started defining `id` (line 297) and then the attribute of the Kivy language
    (line 292). Then, we were able used msg_label in the Python code (lines 283, 285
    and 287)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是再次比较我们获取`counter`属性和`msg_label`属性的方式。我们在`StatusBar`（第278行）中定义了`counter`属性，并通过`root`（第295行）在`Label`中使用它。在`msg_label`的情况下，我们首先定义了`id`（第297行），然后是Kivy语言的属性（第292行）。然后，我们能够在Python代码中使用msg_label（第283行、第285行和第287行）。
- en: Note
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that an attribute is not necessarily a Kivy property. An attribute
    is an element of the class, whereas a Kivy property also associates the attribute
    with an event.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一个属性不一定是一个Kivy属性。属性是类的一个元素，而Kivy属性还把属性与事件关联起来。
- en: 'You can find the complete list of available properties in the Kivy API ([http://kivy.org/docs/api-kivy.properties.html](http://kivy.org/docs/api-kivy.properties.html)).
    There are two specific properties that should at least be mentioned: **`BoundedNumericProperty`**
    and **`AliasProperty`**. The **`BoundedNumericProperty`** property allows the
    setting of the maximum and minimum values. If the value is beyond the range, an
    `Exception` is thrown. The **`AliasProperty`** property offers a way in which
    we can extend the properties; it allows us to create our own properties in case
    the necessary property does not exist.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Kivy API中找到完整的属性列表（[http://kivy.org/docs/api-kivy.properties.html](http://kivy.org/docs/api-kivy.properties.html)）。至少应该提到两个特定的属性：**`BoundedNumericProperty`**和**`AliasProperty`**。**`BoundedNumericProperty`**属性允许设置最大和最小值。如果值超出范围，将抛出异常。**`AliasProperty`**属性提供了一种扩展属性的方法；它允许我们在必要的属性不存在的情况下创建自己的属性。
- en: One last thing that deserves attention is that attributes of the vertex instructions
    are used as properties when we create them with the Kivy language. For example,
    if we change the position of the line inside `ToolLine`, it will be updated automatically.
    However, this just applies inside the Kivy language, not when we add the vertex
    instructions dynamically, as we did in `toolbox.py`. In our case, we had to remove
    and create a new vertex instruction every time we needed to update the figures
    (lines 133 to 135). However, we could have created our own properties to handle
    the updates. An example will be offered in [Chapter 6](ch06.html "Chapter 6. Kivy
    Player – a TED Video Streamer"), *Kivy Player – a TED Video Streamer*, when we
    add subtitles to the videos.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要注意的一点是，当我们使用Kivy语言创建顶点指令属性时，这些属性被用作属性。例如，如果我们更改`ToolLine`内线的位置，它将自动更新。然而，这仅适用于Kivy语言内部，不适用于我们动态添加顶点指令的情况，就像我们在`toolbox.py`中所做的那样。在我们的情况下，每次我们需要更新图形时（第133到135行），我们必须删除并创建一个新的顶点指令。然而，我们可以创建自己的属性来处理更新。一个例子将在[第6章](ch06.html
    "第6章。Kivy播放器 - TED视频流播放器")中提供，即当我们向视频中添加字幕时。
- en: 'Let''s run the code one last time to see the final result with the status bar
    counting figures and indicating our last action:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行代码，以查看带有状态栏计数图形并指示我们最后操作的最后结果：
- en: '![Kivy and its properties](img/B04244_03_12.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![Kivy及其属性](img/B04244_03_12.jpg)'
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We covered most of the topics related to event handling in this chapter. You
    learned how to override different kind of events, dynamic binding and unbinding,
    assigning events in the Kivy language, and creating our own. You also learned
    about Kivy properties, how to manage the localization of coordinates to different
    widgets, and many methods related to adding, removing, and updating objects of
    `Kivy` `Widget` and `canvas`. Here are the events, methods, properties, and attributes
    that were covered:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中涵盖了与事件处理相关的大部分主题。你学习了如何覆盖不同类型的事件、动态绑定和解绑、在Kivy语言中分配事件以及创建自己的事件。你还学习了Kivy属性，如何管理坐标在不同小部件中的定位，以及与添加、删除和更新`Kivy`
    `Widget`和`canvas`对象相关的许多方法。以下是所涵盖的事件、方法、属性和属性：
- en: The events we covered are `on_touch_up`, `on_touch_move` and `on_touch_down`
    (of `Widget`); `on_press` and `on_release` (of `Button`); and `on_state` (of `ToggleButton`)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们所涵盖的事件是`on_touch_up`、`on_touch_move`和`on_touch_down`（`Widget`的）；`on_press`和`on_release`（`Button`的）；以及`on_state`（`ToggleButton`的）。
- en: The attributes we covered are x and y of `MotionEvent` (`touch`); `center_x`,
    `center_y`, `canvas`, `parent`, and `children` of `Widget`, and `state` of `ToggleButton`.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在本章中讨论的属性包括`MotionEvent`（`touch`）的x和y坐标；`Widget`的`center_x`、`center_y`、`canvas`、`parent`和`children`，以及`ToggleButton`的`state`。
- en: 'The following methods of `Widget`:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Widget`的以下方法：'
- en: '`bind` and `unbind` to attach events dynamically'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bind`和`unbind`用于动态附加事件'
- en: '`collide_points`, `to_parent`, `to_local`, `to_window`, and `to_widget` to
    work with coordinates'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collide_points`、`to_parent`、`to_local`、`to_window`和`to_widget`用于处理坐标'
- en: '`add_widget`, `remove_widget`, and `clear_widgets` to dynamically modify the
    children widgets'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_widget`、`remove_widget`和`clear_widgets`用于动态修改子小部件'
- en: The methods `add` and `remove` of canvas to dynamically add and remove vertex
    and context instructions
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canvas`的`add`和`remove`方法用于动态添加和删除顶点和上下文指令'
- en: 'Kivy properties: `NumericProperty` and `ListProperty`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kivy属性：`NumericProperty` 和 `ListProperty`
- en: There are two other important types of events related to the clock and keyboard.
    This chapter was focused on widget and property events but we will see how to
    use other events in [Chapter 5](ch05.html "Chapter 5. Invaders Revenge – an Interactive
    Multi-touch Game"), *Invaders Revenge – an Interactive Multi-touch Game*. The
    next chapter is going to introduce a list of interesting topics on Kivy in order
    to improve the user experience with our *Comic Creator*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与时钟和键盘相关的重要事件类型有两种。本章主要关注小部件和属性事件，但我们将看到如何在[第5章](ch05.html "第5章。入侵者复仇 - 一个交互式多点触控游戏")
    *入侵者复仇 - 一个交互式多点触控游戏* 中使用其他事件。下一章将介绍一系列关于Kivy的有趣话题，以提高我们 *漫画创作者* 的用户体验。
