<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 8. Page Objects and Data-driven Testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Page Objects and Data-driven Testing</h1></div></div></div><p>This chapter introduces two important design patterns that are useful in creating scalable and maintainable test automation framework designs. We will explore how to use the data-driven approach to create data-driven Selenium tests using Python libraries.</p><p>In the second part of this chapter, you will learn about using the page object pattern to create highly maintainable and robust tests by separating locators and other low-level calls from the test cases into a layer of abstraction, which resembles the functionality of the application similar to what the user experiences within the browser window.</p><p>In this chapter, you will learn:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What data-driven testing is</li><li class="listitem" style="list-style-type: disc">How to use the <span class="strong"><strong>Data-driven testing</strong></span> (<span class="strong"><strong>ddt</strong></span>) library along with the <code class="literal">unittest</code> library to create data-driven tests</li><li class="listitem" style="list-style-type: disc">How to read data from external sources for data-driven testing</li><li class="listitem" style="list-style-type: disc">What the page object pattern is and how it helps in creating a maintainable test suite</li><li class="listitem" style="list-style-type: disc">How to implement the page object pattern for the sample application</li></ul></div><div class="section" title="Data-driven testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec44"/>Data-driven testing</h1></div></div></div><p>By using the <a id="id510" class="indexterm"/>data-driven testing approach, we can use a single test to verify different sets of test cases or test data by driving the test with input and expected values from an external data source instead of using the hardcoded values every time a test is run.</p><p>This becomes useful when we have similar tests that consist of the same steps but differ in the input data and expected value or the application state. Here is an example of a set of login test cases with different combinations:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Description</p>
</th><th style="text-align: left" valign="bottom">
<p>Test data</p>
</th><th style="text-align: left" valign="bottom">
<p>Expected output</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Valid username and password</p>
</td><td style="text-align: left" valign="top">
<p>A pair of valid usernames and passwords</p>
</td><td style="text-align: left" valign="top">
<p>The user should log in to the application with a success message</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Invalid username and password</p>
</td><td style="text-align: left" valign="top">
<p>An invalid username and password</p>
</td><td style="text-align: left" valign="top">
<p>The user should be displayed the login error</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Valid username and invalid password</p>
</td><td style="text-align: left" valign="top">
<p>A valid username and an invalid password</p>
</td><td style="text-align: left" valign="top">
<p>The user should be displayed the login error</p>
</td></tr></tbody></table></div><p>We can create a single script that can handle the test data and the conditions from the preceding table.</p><p>By using the <a id="id511" class="indexterm"/>data-driven testing approach, we separate the test data from the test logic by replacing the hardcoded test data with variables using the data from external sources such as CSV or a spreadsheet file. This also helps in creating reusable tests that can run with different sets of data, which can be kept outside of the test.</p><p>Data-driven testing also helps in increasing the test coverage as we can handle multiple test conditions while minimizing the amount of test code we need to write and maintain.</p><p>In this section, we will implement the data-driven testing approach to some of the tests that we created in the earlier chapters, using the <code class="literal">ddt</code> library in Python.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Using ddt for data-driven tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec45"/>Using ddt for data-driven tests</h1></div></div></div><p>The <code class="literal">ddt</code> library <a id="id512" class="indexterm"/>provides the ability to parameterize the test cases written using the <code class="literal">unittest</code> library in Python. We can provide a set of data using <code class="literal">ddt</code> to a test case for data-driven tests.</p><p>The <code class="literal">ddt</code> <a id="id513" class="indexterm"/>library provides a set of class and method decorators that we can use to create data-driven tests.</p><div class="section" title="Installing ddt"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec50"/>Installing ddt</h2></div></div></div><p>We can <a id="id514" class="indexterm"/>download and install <code class="literal">ddt</code> using the following command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>pip install ddt</strong></span>
</pre></div><p>That's it! You <a id="id515" class="indexterm"/>can find more about <code class="literal">ddt</code> at <a class="ulink" href="https://pypi.python.org/pypi/ddt">https://pypi.python.org/pypi/ddt</a>.</p></div><div class="section" title="Creating a simple data-driven test with ddt in unittest"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec51"/>Creating a simple data-driven test with ddt in unittest</h2></div></div></div><p>We will <a id="id516" class="indexterm"/>use the search test case on the sample application and convert it into a data-driven test by removing the hardcoded values to search for different products and categories.</p><p>To create a data-driven test we need to use the <code class="literal">@ddt</code> decorator for the test class and use the <code class="literal">@data</code> decorator on the data-driven test methods.</p><p>The <code class="literal">@data</code> <a id="id517" class="indexterm"/>decorator takes as many arguments as we have values that we want to feed to the test. These could be single values or lists, tuples, and dictionaries. For lists, we need to use the <code class="literal">@unpack</code> decorator, which unpacks tuples or lists into multiple arguments.</p><p>Let's implement the search test, which accepts a pair of arguments for different search terms and expected result count as shown in the following code:</p><div class="informalexample"><pre class="programlisting">import unittest
from ddt import ddt, data, unpack
from selenium import webdriver

@ddt
class SearchDDT(unittest.TestCase):
    def setUp(self):
        # create a new Firefox session
        self.driver = webdriver.Firefox()
        self.driver.implicitly_wait(30)
        self.driver.maximize_window()

        # navigate to the application home page
        self.driver.get("http://demo.magentocommerce.com/")

    # specify test data using @data decorator
    @data(("phones", 2), ("music", 5))
    @unpack
    def test_search(self, search_value, expected_count):
        # get the search textbox
        self.search_field = self.driver.find_element_by_name("q")
        self.search_field.clear()

        # enter search keyword and submit.
        # use search_value argument to pass data
        self.search_field.send_keys(search_value)
        self.search_field.submit()

        # get all the anchor elements which have
        # product names displayed
        # currently on result page using
        # find_elements_by_xpath method
        products = self.driver.find_elements_by_xpath("//h2[@class='product-name']/a")

        # check count of products shown in results
        self.assertEqual(expected_count, len(products))

    def tearDown(self):
        # close the browser window
        self.driver.quit()

if __name__ == '__main__':
    unittest.main(verbosity=2)</pre></div><p>In this test, we are passing a list of tuples using the <code class="literal">@data</code> decorator. The <code class="literal">@unpack</code> decorator is <a id="id518" class="indexterm"/>used to unpack these tuples into <a id="id519" class="indexterm"/>multiple arguments. The <code class="literal">test_search()</code> method accepts the <code class="literal">search_value</code> and <code class="literal">expected_count</code> arguments, which will be mapped to the tuple values by <code class="literal">ddt</code>, as shown:</p><div class="informalexample"><pre class="programlisting"># specify test data using @data decorator
    @data(("phones", 2), ("music", 5))
    @unpack
    def test_search(self, search_value, expected_count):</pre></div><p>When we run the test, <code class="literal">ddt</code> will generate new test methods giving them meaningful names by converting the data values to valid Python identifiers. For example, for the preceding test, <code class="literal">ddt</code> will generate new test methods with names as shown in the following screenshot:</p><div class="mediaobject"><img src="images/3506OS_08_01.jpg" alt="Creating a simple data-driven test with ddt in unittest"/></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Using external data sources for data-driven tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec46"/>Using external data sources for data-driven tests</h1></div></div></div><p>In the <a id="id520" class="indexterm"/>previous example, we supplied the test data in the test code. However, you will find situations where you already have test data defined in external sources such as text files, spreadsheets, or databases. It is <a id="id521" class="indexterm"/>also a good idea to separate the test data from the code and put it in an external source for easy maintenance and avoid changes to the test code each time you want to update the values.</p><p>Let's explore <a id="id522" class="indexterm"/>how we can read the test data from the <span class="strong"><strong>Comma separated values</strong></span> (<span class="strong"><strong>CSV</strong></span>) files or Excel spreadsheets and supply it to <code class="literal">ddt</code>.</p><div class="section" title="Reading values from CSV"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec52"/>Reading values from CSV</h2></div></div></div><p>We <a id="id523" class="indexterm"/>will use the previous test case and move the data that we supplied to the <code class="literal">@data</code> decorator into a separate <a id="id524" class="indexterm"/>CSV file called <code class="literal">testdata.csv</code> instead of keeping it in the script. This data will be stored in a tabular format as shown in the following screenshot:</p><div class="mediaobject"><img src="images/3506OS_08_02.jpg" alt="Reading values from CSV"/></div><p>Next, we will implement the <code class="literal">get_data()</code> method, which accepts the path and name of the CSV file. This method uses the <code class="literal">csv</code> library to read the values from the file and returns a list of <a id="id525" class="indexterm"/>these values. We <a id="id526" class="indexterm"/>will use the <code class="literal">get_data()</code> method in the <code class="literal">@data</code> decorator as shown in the following code:</p><div class="informalexample"><pre class="programlisting">import csv, unittest
from ddt import ddt, data, unpack
from selenium import webdriver

<span class="strong"><strong>def get_data(file_name):</strong></span>
    <span class="strong"><strong># create an empty list to store rows</strong></span>
    <span class="strong"><strong>rows = []</strong></span>
    <span class="strong"><strong># open the CSV file</strong></span>
    <span class="strong"><strong>data_file = open(file_name, "rb")</strong></span>
    <span class="strong"><strong># create a CSV Reader from CSV file</strong></span>
    <span class="strong"><strong>reader = csv.reader(data_file)</strong></span>
    <span class="strong"><strong># skip the headers</strong></span>
    <span class="strong"><strong>next(reader, None)</strong></span>
    <span class="strong"><strong># add rows from reader to list</strong></span>
    <span class="strong"><strong>for row in reader:</strong></span>
        <span class="strong"><strong>rows.append(row)</strong></span>
    <span class="strong"><strong>return rows</strong></span>

@ddt
class SearchCsvDDT(unittest.TestCase):
    def setUp(self):
        # create a new Firefox session
        self.driver = webdriver.Firefox()
        self.driver.implicitly_wait(30)
        self.driver.maximize_window()

        # navigate to the application home page
        self.driver.get("http://demo.magentocommerce.com/")

    # get the data from specified csv file by
    # calling the get_data function
    @data(*get_data("testdata.csv"))
    @unpack
    def test_search(self, search_value, expected_count):
            self.search_field = self.driver.find_element_by_name("q")
            self.search_field.clear()

            # enter search keyword and submit.
            self.search_field.send_keys(search_value)
            self.search_field.submit()

            # get all the anchor elements which have
            # product names displayed
            # currently on result page using
            # find_elements_by_xpath method
            products = self.driver.find_elements_by_xpath("//h2[@class='product-name']/a")
            expected_count = int(expected_count)
            if expected_count &gt; 0:
                # check count of products shown in results
                self.assertEqual(expected_count, len(products))
            else:
                msg = self.driver.find_element_by_class_name
                  ("note-msg")
                self.assertEqual("Your search returns no results.", msg.text)

    def tearDown(self):
        # close the browser window
        self.driver.quit()

if __name__ == '__main__':
    unittest.main()</pre></div><p>When this test is executed, <code class="literal">@data</code> will call the <code class="literal">get_data()</code> method, which will read the supplied <a id="id527" class="indexterm"/>file and return the list of values back to <code class="literal">@data</code>. These values are unpacked and the test methods are <a id="id528" class="indexterm"/>generated for each row.</p></div><div class="section" title="Reading values from Excel"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec53"/>Reading values from Excel</h2></div></div></div><p>Maintaining <a id="id529" class="indexterm"/>test data in the Excel spreadsheet is another common practice. It also helps nontechnical users to <a id="id530" class="indexterm"/>define new tests by simply adding a row of data in a spreadsheet. Consider the following screenshot as an example of maintaining the data in an Excel spreadsheet:</p><div class="mediaobject"><img src="images/3506OS_08_03.jpg" alt="Reading values from Excel"/></div><p>Reading values from the Excel spreadsheet will need another library called <code class="literal">xlrd</code>, which can be installed with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>pip install xlrd</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>The <code class="literal">xlrd</code> library provides read access to the workbook, sheet, and cells in order to read the data. It does not write to a spreadsheet. For writing the data, we can use the <code class="literal">xlwt</code> library. We can also use <code class="literal">openpyxl</code> for reading and writing data in a spreadsheet. Find more information at <a class="ulink" href="http://www.python-excel.org/">http://www.python-excel.org/</a>.</p></div></div><p>Let's modify the <code class="literal">get_data()</code> method from the previous example to read data from a spreadsheet into a list and modify the test as shown in the following code:</p><div class="informalexample"><pre class="programlisting">import xlrd, unittest
from ddt import ddt, data, unpack
from selenium import webdriver

<span class="strong"><strong>def get_data(file_name):</strong></span>
    <span class="strong"><strong># create an empty list to store rows</strong></span>
    <span class="strong"><strong>rows = []</strong></span>
    <span class="strong"><strong># open the specified Excel spreadsheet as workbook</strong></span>
    <span class="strong"><strong>book = xlrd.open_workbook(file_name)</strong></span>
    <span class="strong"><strong># get the first sheet</strong></span>
    <span class="strong"><strong>sheet = book.sheet_by_index(0)</strong></span>
    <span class="strong"><strong># iterate through the sheet and get data from rows in list</strong></span>
    <span class="strong"><strong>for row_idx in range(1, sheet.nrows):</strong></span>
        <span class="strong"><strong>rows.append(list(sheet.row_values(row_idx, 0, sheet.ncols)))</strong></span>
    <span class="strong"><strong>return rows</strong></span>

@ddt
class SearchExcelDDT(unittest.TestCase):
    def setUp(self):
        # create a new Firefox session
        self.driver = webdriver.Firefox()
        self.driver.implicitly_wait(30)
        self.driver.maximize_window()

        # navigate to the application home page
        self.driver.get("http://demo.magentocommerce.com/")

    # get the data from specified Excel spreadsheet
    # by calling the get_data function
    <span class="strong"><strong>@data(*get_data("TestData.xlsx"))</strong></span>
    <span class="strong"><strong>@unpack</strong></span>
    def test_search(self, search_value, expected_count):
            self.search_field = self.driver.find_element_by_name("q")
            self.search_field.clear()

            # enter search keyword and submit.
            self.search_field.send_keys(search_value)
            self.search_field.submit()

            # get all the anchor elements which have
            # product names displayed
            # currently on result page using
            # find_elements_by_xpath method
            products = self.driver.find_elements_by_xpath("//h2[@class='product-name']/a")
            if expected_count &gt; 0:
                # check count of products shown in results
                self.assertEqual(expected_count, len(products))
            else:
                msg = self.driver.find_element_by_class_name("note-msg")
                self.assertEqual("Your search returns no results.", msg.text)

    def tearDown(self):
        # close the browser window
        self.driver.quit()

if __name__ == '__main__':
    unittest.main()</pre></div><p>Similar <a id="id531" class="indexterm"/>to the previous example for CSV files, when this test is executed <code class="literal">@data</code> will call the <code class="literal">get_data()</code>
<a id="id532" class="indexterm"/>method, which will read the supplied file and return the list of values back to <code class="literal">@data</code> from a spreadsheet. These values are unpacked and the test methods are generated for each row.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>
<span class="strong"><strong>Reading values from a database</strong></span>
</p><p>If you need to read values from a database, you just need to modify the <code class="literal">get_data()</code> method and use the appropriate libraries to connect to the database and read values using SQL queries back into a list.</p></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="The page objects pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec47"/>The page objects pattern</h1></div></div></div><p>Until now, we <a id="id533" class="indexterm"/>were writing Selenium WebDriver tests directly into Python classes using <code class="literal">unittest</code>. We were specifying locators and test case steps into these classes. This code is good to start; however, as we progress on, adding more and more tests to our tests suite, it will become difficult to maintain. This will make tests brittle.</p><p>Developing maintainable and reusable test code is important for sustainable test automation and the test code should be treated as production code and similar standards and patterns should to be applied while developing the test code.</p><p>To overcome these problems, we can use various design patterns and principles such as <span class="strong"><strong>Don't Repeat Yourself</strong></span> (<span class="strong"><strong>DRY</strong></span>), and code refactoring techniques while creating the tests. If you're a <a id="id534" class="indexterm"/>developer, you might already be using these techniques.</p><p>The page object pattern is one of the highly used patterns among the Selenium user community to structure the tests, making them separate from low-level actions, and providing a high-level abstraction. You can compare the page object pattern to the facade pattern, which enables creating a simplified interface for complex code.</p><p>The page object <a id="id535" class="indexterm"/>pattern offers creating an object representing each web page from the application under test. We can define classes for each page, modeling all attributes and actions for that page. This creates a layer of separation between the test code and technical implementation of pages and application functionality that we will be testing, by hiding the locators, low-level methods dealing with elements, and business functionality. Instead, the page objects will provide a high-level API for tests to deal with the page functionality.</p><p>Tests should use these page objects at a high level, where any change in attributes or actions in the underlying page should not break the test. Using the page object pattern provides the following benefits:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a high-level abstraction that helps minimize changes when the underlying page is modified by developers. So, you will change only the page object and the calling tests will be unaffected.</li><li class="listitem" style="list-style-type: disc">Creating reusable code that can be shared across multiple test cases.</li><li class="listitem" style="list-style-type: disc">Tests are more readable, flexible, and maintainable.</li></ul></div><p>Let's start refactoring the test that we created in the earlier chapter and implement the page objects that provide a high-level abstraction for the application that we are testing. In this example, we will create the following structure for the selected pages in the sample application. We will start implementing a base page object, which will be used by all other pages as a template. The base object will also provide regions that are blocks of functionality available for all other pages; for example, the search feature is available on all pages of the application. We will create a search region object that will be available for all the pages inherited from the base page. We will implement a class for the home page, which represents the home page of the application; search results page, which shows the list of products matching with the search criteria; and a product page, which provides attributes <a id="id536" class="indexterm"/>and actions related to a product. We will create a structure as shown in the following diagram:</p><div class="mediaobject"><img src="images/3506OS_08_04.jpg" alt="The page objects pattern"/></div><div class="section" title="Organizing tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec54"/>Organizing tests</h2></div></div></div><p>Before we <a id="id537" class="indexterm"/>start implementing page objects for the sample application we are testing, let's implement a <code class="literal">BaseTestCase</code> class, which will provide <a id="id538" class="indexterm"/>us with the <code class="literal">setUp()</code> and <code class="literal">tearDown()</code> methods so that we don't need to write these for each test class we create. We can also put reusable code in this class. Create <code class="literal">basetestcase.py</code> and implement the <code class="literal">BaseTestCase</code> class as shown in the following code:</p><div class="informalexample"><pre class="programlisting">import unittest
from selenium import webdriver

class BaseTestCase(unittest.TestCase):
    def setUp(self):
        # create a new Firefox session
        self.driver = webdriver.Firefox()
        self.driver.implicitly_wait(30)
        self.driver.maximize_window()

        # navigate to the application home page
        self.driver.get('http://demo.magentocommerce.com/')

    def tearDown(self):
        # close the browser window
        self.driver.quit()</pre></div></div><div class="section" title="The BasePage object"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec55"/>The BasePage object</h2></div></div></div><p>The <code class="literal">BasePage</code> <a id="id539" class="indexterm"/>object will act as a parent object for all the <a id="id540" class="indexterm"/>page objects that we will create in our test suite. The base page provides common code that the page object can use. Let's create <code class="literal">base.py</code> and implement <code class="literal">BasePage</code> as shown in the following code:</p><div class="informalexample"><pre class="programlisting">from abc import abstractmethod
class BasePage(object):
    """ All page objects inherit from this """

    def __init__(self, driver):
        self._validate_page(driver)
        self.driver = driver

    @abstractmethod
    def _validate_page(self, driver):
        return

    """ Regions define functionality available throughall page objects """
    @property
    def search(self):
        from search import SearchRegion
        return SearchRegion(self.driver)

class InvalidPageException(Exception):
    """ Throw this exception when you don't find the correct page """
    pass</pre></div><p>We added an abstract method called <code class="literal">_validate_page()</code>, which will be implemented by the page objects inheriting from <code class="literal">BasePage</code> to validate that the page they represent is loaded in the browser before the test can use attributes or actions.</p><p>We also created a property called <code class="literal">search</code> that returns the <code class="literal">SearchRegion</code> object. This is similar to a page object. However, <code class="literal">SearchRegion</code> represents the search box displayed on all the pages of the application. So, adding to each page object we are sharing this from the <code class="literal">BasePage</code> class.</p><p>We also <a id="id541" class="indexterm"/>implemented <code class="literal">InvalidPageException</code>, which is used in the <code class="literal">_validate_page()</code> method. If it fails to validate the <a id="id542" class="indexterm"/>page, <code class="literal">InvalidPageExecption</code> will be raised.</p></div><div class="section" title="Implementing page objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec56"/>Implementing page objects</h2></div></div></div><p>Now, let's start <a id="id543" class="indexterm"/>implementing page objects for each page that we're going to deal with in our test.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First we will define <code class="literal">HomePage</code>. Create <code class="literal">homepage.py</code> and implement the <code class="literal">HomePage</code> class as shown in the following code:<div class="informalexample"><pre class="programlisting">from base import BasePage
from base import InvalidPageException

class HomePage(BasePage):

    _home_page_slideshow_locator = 'div.slideshow-container'

    def __init__(self, driver):
        super(HomePage, self).__init__(driver)

    def _validate_page(self, driver):
        try:
            driver.find_element_by_class_name(self._home_page_slideshow_locator)
        except:
            raise InvalidPageException("Home Page not loaded")</pre></div><p>One of the practices that we will follow is to separate the locator strings from the place where they are being used. We will create a private variable to store locators using the <code class="literal">_</code> prefix. For example, the <code class="literal">_home_page_slideshow_locator</code> variable stores the locator for the slideshow component displayed on the home page of the application. We will use this to validate whether the browser is indeed showing the home page, as follows:</p><div class="informalexample"><pre class="programlisting">_home_page_slideshow_locator = 'div.slideshow-container'</pre></div><p>We also implemented the <code class="literal">_validate_page()</code> method in the <code class="literal">HomePage</code> class. This method validates whether the home page is loaded in the browser using the element used to display a slideshow on the home page.</p></li><li class="listitem">Next, we <a id="id544" class="indexterm"/>will implement the <code class="literal">SearchRegion</code> class, which handle the search feature of the application. It provides the <code class="literal">searchFor()</code> method, which returns the <code class="literal">SearchResult</code> class representing the search results page. Create a new <code class="literal">search.py</code> file and implement both the classes as shown in the following code:<div class="informalexample"><pre class="programlisting">from base import BasePage
from base import InvalidPageException
from product import ProductPage

class SearchRegion(BasePage):
    _search_box_locator = 'q'

    def __init__(self, driver):
        super(SearchRegion, self).__init__(driver)

    def searchFor(self, term):
        self.search_field = self.driver.find_element_by_name(self._search_box_locator)
        self.search_field.clear()
        self.search_field.send_keys(term)
        self.search_field.submit()
        return SearchResults(self.driver)

class SearchResults(BasePage):
    _product_list_locator   = 'ul.products-grid &gt; li'
    _product_name_locator   = 'h2.product-name a'
    _product_image_link     = 'a.product-image'
    _page_title_locator     = 'div.page-title'


    _products_count = 0
    _products = {}

    def __init__(self, driver):
        super(SearchResults, self).__init__(driver)
        results = self.driver.find_elements_by_css_selector(self._product_list_locator)
        for product in results:
            name = product.find_element_by_css_selector(self._product_name_locator).text
            self._products[name] = product.find_element_by_css_selector(self._product_image_link)

    def _validate_page(self, driver):
        if 'Search results for' not in driver.title:
            raise InvalidPageException('Search results not loaded')

    @property
    def product_count(self):
        return len(self._products)

    def get_products(self):
        return self._products

    def open_product_page(self, product_name):
        self._products[product_name].click()
        return ProductPage(self.driver)</pre></div></li><li class="listitem">Finally, we <a id="id545" class="indexterm"/>will implement the <code class="literal">ProductPage</code> class, which has some attributes related to a product. We can access a product from the <code class="literal">SearchResults</code> class, which has a method to open the product details page for a given product. Create a <code class="literal">product.py</code> file and implement the <code class="literal">ProductPage</code> class as shown in the following code:<div class="informalexample"><pre class="programlisting">from base import BasePage
from base import InvalidPageException

class ProductPage(BasePage):
    _product_view_locator           = 'div.product-view'
    _product_name_locator           = 'div.product-name span'
    _product_description_locator    = 'div.tab-content div.std'
    _product_stock_status_locator   = 'p.availability span.value'
    _product_price_locator          = 'span.price'

    def __init__(self, driver):
        super(ProductPage, self).__init__(driver)

    @property
    def name(self):
        return self.driver.\
            find_element_by_css_selector(self._product_name_locator)\
            .text.strip()

    @property
    def description(self):
        return self.driver.\
            find_element_by_css_selector(self._product_description_locator)\
            .text.strip()

    @property
    def stock_status(self):
        return self.driver.\
            find_element_by_css_selector(self._product_stock_status_locator)\
            .text.strip()

    @property
    def price(self):
        return self.driver.\
            find_element_by_css_selector(self._product_price_locator)\
            .text.strip()

    def _validate_page(self, driver):
        try:
            driver.find_element_by_css_selector(self._product_view_locator)
        except:
            raise InvalidPageException('Product page not loaded')</pre></div></li></ol></div><p>You can <a id="id546" class="indexterm"/>further add actions on the product page to add a product to the shopping cart, or for comparison of products. Also, attributes that return the rating and other information related to the product are added back to the test.</p></div><div class="section" title="Creating a test with page objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec57"/>Creating a test with page objects</h2></div></div></div><p>Let's create <a id="id547" class="indexterm"/>a test that uses <code class="literal">BaseTestCase</code> and calls the page objects that we created to test the search feature of the application. This test creates an <a id="id548" class="indexterm"/>instance of the <code class="literal">HomePage</code> class and calls the <code class="literal">searchFor()</code> method, which returns an instance of <code class="literal">SearchResults</code>. Later, the test calls the <code class="literal">open_product_page()</code> method of the <code class="literal">SearchResults</code> class to open details for the specified product listed in the result. The test checks the attributes of a sample product. Create a <code class="literal">searchtest.py</code> file and implement the <code class="literal">SearchProductTest</code> test as shown in the following code:</p><div class="informalexample"><pre class="programlisting">import unittest
from homepage import HomePage
from BaseTestCase import BaseTestCase

class SearchProductTest(BaseTestCase):
    def testSearchForProduct(self):
        homepage = HomePage(self.driver)
        search_results = homepage.search.searchFor('earphones')
        self.assertEqual(2, search_results.product_count)
        product = search_results.open_product_page('MADISON EARBUDS')
        self.assertEqual('MADISON EARBUDS', product.name)
        self.assertEqual('$35.00', product.price)
        self.assertEqual('IN STOCK', product.stock_status)

if __name__ == '__main__':
    unittest.main(verbosity=2)</pre></div><p>Notice that we did not write the <code class="literal">setUp()</code> and <code class="literal">tearDown()</code> methods in this test. We inherited this test class from <code class="literal">BaseTestCase</code>, which implements these methods. We can overload these methods if we want to do test-specific setup or clean-up.</p><p>In this example, we implemented page objects for search workflow navigation. You can also implement <a id="id549" class="indexterm"/>similar page objects or regions for <a id="id550" class="indexterm"/>shopping cart, account registration, login, and so on.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec48"/>Summary</h1></div></div></div><p>In this chapter, we recognized the need to write data-driven tests and organize the test code using the page object pattern for reusability, scalability, and maintainability. The data-driven pattern provides us the ability to separate test data from test case, so we can reuse the test code to test multiple test data. We also looked at how to use the <code class="literal">ddt</code> library along with <code class="literal">unittest</code> to implement data-driven testing and read data from various external sources. You learned the page object pattern and how it benefits in building a maintainable test suite by implementing page objects for the sample application and creating a test that uses the page objects.</p><p>In the next chapter you will learn some advanced techniques with Selenium WebDriver API, such as capturing screenshots and movies from test runs, performing mouse and keyboard actions, handling session cookies, and so on.</p></div></div>
</body></html>