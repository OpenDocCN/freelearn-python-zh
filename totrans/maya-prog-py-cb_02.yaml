- en: Chapter 2. Creating User Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be taking a guided tour through Maya''s collection
    of user interface elements and learning how to use them to create interfaces that
    you and your teammates will love to use. The following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Making a basic window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple controls – making a button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving input from controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using classes to organize UI logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using nested layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using tabs and scrolling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding menu to your UIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it is by no means required to create a graphical user interface (GUI)
    for your scripts, you're likely to want one in almost all cases. Very often, you'll
    find yourself creating scripts that are meant to be used by your teammates, some
    of whom may be less comfortable with command-line tools.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll be looking at how to create windows, fill them with interface
    elements, and link those elements up to other functionality within Maya.
  prefs: []
  type: TYPE_NORMAL
- en: Making a basic window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All great user interfaces start with window. In this example, we'll be creating
    a simple window and using the text label control to add a simple message.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll end up with something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making a basic window](img/4657_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start by creating a new file in your scripts directory and naming it basic `Window.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you run the script, you should see a small window containing the text **Hello,
    Maya!**.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a window, you'll need to use the window command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: While all of the arguments are optional, there are a few that you'll generally
    want to include by default. Here, we're setting the title to "Simple Window" and
    the size of the window to 300 pixels wide by 200 pixels tall. Also note that we
    save the result of the command to a variable, `myWin`. This is necessary in order
    to use the `showWindow` command. More on that in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also one more requirement, that is, in order to add an element to
    a window, you must first specify a layout. Layouts are responsible for arranging
    items within a given area (either a window or another layout). If you fail to
    provide Maya with a layout, it won''t be able to properly position any controls
    you add, and your script will error out. In this example, we''re using a `columnLayout`,
    which will arrange all the controls we add in a single vertical column. We add
    a layout to the window with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once we've created a window and specified a layout, we can start adding controls.
    In this case, we're using the text control that merely adds some text to the window.
    While you won't generally use text controls by themselves (it's far more common
    to use them next to other controls to provide labels or descriptive text), it
    serves as a good example of a typical, albeit simple, control.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we''re done with our interface, but creating a window will not
    actually show anything in Maya. To have it shown up in Maya''s interface, we''ll
    also need to explicitly show it using the `showWindow` command. The reason for
    this is that you generally don''t want to show a window until it has all of the
    controls and other UI elements you want it to have. However, in order to create
    a control, you must first have a window to add them to. Maya solves this by having
    you:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add your controls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show the window once all of the controls have been added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is why, it was important to save the result of the `window()` command
    to a variable, so that we can tell Maya which window it should show to the user.
    Putting that together gives us the last line of our showUI function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note that once a layout is created, it becomes the active context in order to
    add controls. You can certainly have multiple layouts in a single window (and
    even nest them within each other), but there is always exactly one current layout
    to which Maya will insert newly created controls.
  prefs: []
  type: TYPE_NORMAL
- en: One problem with this example is that running the script multiple times will
    result in multiple copies of the window, which is usually not what you want. For
    most purposes, you'll want to ensure that there is only ever a single instance
    of your UI open at any one time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we''ll need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose a unique name for our window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before creating the window, check to see whether one already exists with that
    name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there's already a window by that name, delete it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the window using the window command, passing in the name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When choosing a name, make sure that it's something that is unlikely to conflict
    with other scripts the user might be using. Generic names such as `"MyWindow"`
    or `"MainWindow"` are likely to cause conflicts; it is much better to have something
    unique like `"CharacterRigControl"`. To make it even better, add your initials,
    or the initials of your company to the start of the name (`"ahCharacterRig"`,
    for example). Note that the name (which is not shown to the user) is distinct
    from the title (which is), so it's perfectly fine to have a long or unwieldy name.
    Just make sure that it's unique.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have a name, we''ll want to start off by testing to see if a window
    by that name exists. We can do that with the window command and the `exists` flag.
    If we *do* find that a window of that name exists, we''ll want to get rid of it
    with the `deleteUI` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Finally, when we create a new window, we'll make sure to pass in our desired
    name as the first argument, which will give the window the desired name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, we could just stop the script if there's already a window with
    the given name, but the previously mentioned approach is more common. If the user
    invokes your script, they likely want to start with a fresh slate, so replacing
    the old window is often the best option.
  prefs: []
  type: TYPE_NORMAL
- en: Simple controls – making a button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a window is only the beginning. In order to create a proper interface,
    we'll need to both add controls, and tie them to functionality. In this example,
    we'll be revisiting our good friend, the `polyCube` command, and tying it to a
    button press.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting UI (and its output) will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple controls – making a button](img/4657_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script and name it `buttonExample.py`. Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Run the script, and you should see a 200 by 200 pixel window with a single button
    inside it. Pushing the button will create a polygonal cube with the default parameters.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to trigger functionality from our UI, we''ll first need to create
    a function to contain the functionality we want to trigger. We do that in our
    `buttonFunction` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, all we''re doing is creating a polygonal cube. Note that the
    function accepts arguments, even though we aren''t making use of them. That''s
    actually necessary, since when Maya triggers a function from a control, it passes
    information to the respective function. Assume that we write the function without
    arguments, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We would get the following error when we attempted to run our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There are situations where we'll want to make use of the information that gets
    passed in, but even if we fully intend to ignore it, we *must* write our UI-driven
    functions to accept arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `*args` syntax is a bit of handy Python that allows for a variable number
    of arguments to be passed in. Technically, all that really matters is the `*`;
    `*myEpicCollectionOfArguments` would work just as well, but `*args` is the general
    convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the function we want to trigger, we set up a window in the conventional
    way, creating it and adding a `columnLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add the button itself with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is pretty straightforward—we set the text that appears within the button
    with the `label` argument, and we set the command to execute when it is pressed
    with the `command` (or "c") argument. Note that there are no parentheses after
    the name of the function. That''s because we''re not actually invoking the function;
    we''re just passing the function itself in as the value for the command flag.
    We include parentheses, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This would result in the function being invoked, and its return value (rather
    than the function itself) being used as the value of the flag. That's almost certainly
    not what you want. The only exception is if you happen to have a function that
    creates a function and returns it, which can be useful in some situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that''s left is to show our window in the normal way with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While this is the most common way to use buttons, there are a few other options
    that can be useful in specific circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `enable` flag can be a great way to prevent the user from
    taking action that they shouldn''t be able to and to provide feedback. Let''s
    say that we''ve created a button, but it shouldn''t be active until the user takes
    some other action. If we set the enable flag to False, the button will appear
    grayed out and will not respond to the user input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Later, you can make the button (or other control) active by using the edit
    mode to set the enable flag to True, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Keeping controls inactive, until it's appropriate to call them, can be a great
    way to make your scripts a bit more robust and easier to use.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving input from controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While you will often need to add one-way controls (such as buttons) that trigger
    functions upon user input, you will also often need to retrieve information from
    the user before taking an action. In this example, we'll be looking at how to
    grab input from field controls, in both integer and float varieties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The finished script will create a given number of polygonal spheres, each with
    a given radius. The resulting UI will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving input from controls](img/4657_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Pressing the **Make Spheres** button with the previously mentioned settings
    of 4 spheres at a radius of 0.5 units each will result in a line of spheres along
    the x-axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving input from controls](img/4657_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script and name it `makeSpheres.py`. Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Run the script, enter some values into the two fields, and click on the button.
    You should see a nice orderly line of polygonal spheres running along the x-axis.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few different things going on here, all of which are needed to grab
    information from the user. First, we create two variables to hold global references
    to our controls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We need variables for the fields since we'll need to call the corresponding
    functions twice—once in the create mode (to make the control) and again in the
    query mode to determine what the current value is. We'll also want to make those
    variables global in scope so that we can have separate functions to create UI
    and actually perform the action.
  prefs: []
  type: TYPE_NORMAL
- en: The "scope" of a variable or a function refers to the context in which it is
    defined. If a variable is defined outside of any function, it is *global* in scope,
    meaning that it is always accessible. Variables defined within a function, however,
    are *local*, meaning that they only exist within the function in which they are
    defined. Since we need to refer to our controls from two different functions,
    we'll need to make sure that they are global in scope.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It isn't strictly necessary to have the variables declared at the top of the
    script as I've done here. We *could* just refer to them in the individual functions,
    and as long as we're careful to include the global keyword, it would still work.
  prefs: []
  type: TYPE_NORMAL
- en: However, I think that it makes things much easier to understand if we declare
    all our global variables at the start.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we set up UI for the window. Note that we repeat the lines that we used
    to declare the global variables. This is necessary to tell Python that we want
    to use the global scope variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If we left out the `global sphereCountField`, we would still end up with a variable
    named `sphereCountField` set to the output of the intField command. However, that
    variable would be of local scope and only available from within the `showUI()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, `global sphereCountField` can almost be thought of as an import
    statement because it brings the global variable into the scope of the showUI function.
    We do the same thing in the `makeSpheres` function to make sure that we use the
    same variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we set up a window as we''ve done in the past, with the `window()` and
    `columnLayout()` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve done this, we can use two fields to collect input from the user.
    Since the number of spheres should always be a whole number value, and we should
    always make at least one sphere, we use an `intField` and set the minimum value
    to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'For the radius of the spheres, we''ll want to allow for non-integer values,
    but we likely want to ensure a reasonable minimum size. To do this, we create
    a `floatField` with a minimum value of 0.5\. We have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we add a button to trigger the creation of the spheres and show the
    window with the `showWindow()` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving to the function to create the spheres, we start by (once again) telling
    Python that we want to make use of our two global variables, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve done this, we retrieve the current values of the `intField` and
    `floatField`. In both cases, we do that by rerunning the same command that we
    used to create the control, but with the following differences:'
  prefs: []
  type: TYPE_NORMAL
- en: We pass the name of the control (saved when we created it) as the first argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set `query=True` to indicate to Maya that we want to retrieve information
    about the control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set `value=True` to indicate that the specific attribute that we want to
    retrieve is the control's value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Putting that all together give us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It may seem better to combine the two lines into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: However, that doesn't actually work, owing to the way that Python works with
    global variables. Python requires that the declaration of a global variable remains
    separate from any commands that set the value of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we know how many spheres to create and how big to make each of them, we
    use a for loop to make and position them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For loops allow you to repeat the same code multiple times. Python implements
    them slightly differently than most other languages in which they always iterate
    over a list of some kind. This means that if we want to do something X times,
    we have to have a list of X items. For this, we'll want the built-in `range()`
    function. By passing `numSpheres` into `range()`, we are asking Python to create
    a list of numbers that starts at 0 and goes up to (numSpheres-1). We can then
    use that list with the for keyword to set our index variable (i) to each of the
    values in our list, which in this case means stepping from 0 to (numSpheres-1).
  prefs: []
  type: TYPE_NORMAL
- en: Note that we set the radius of each sphere with the radius flag. We also use
    the move function to separate each sphere from its neighbors by slightly more
    than their diameters (myRadius * 2.2). By default, the move command will affect
    the currently selected object (or objects). Since the `polySphere` command leaves
    the created sphere as the only selected object, that's what we'll move.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the move command will accept three numbers for the amount by which
    to move the selected object(s)—one for each of the axes. There are a number of
    other ways that the move command can be used; be sure to check the documentation
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Using classes to organize UI logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using global variables is one way to allow the different parts of your script
    communicate with each other, but there's a better way. Instead of using globals,
    you can organize your script using custom class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class for your script will not only allow you to easily access UI
    elements from various functions, but it will also make it easy to neatly contain
    other kinds of data, useful in more advanced scripts.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script and name it `SpheresClass.py`. Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Run the script, and you should get a window that allows you to create a line
    of polygonal spheres along the x-axis.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The overall layout of the script is similar to what we''ve done before, in
    that we have one function to set up the interface and another function to actually
    perform the work. However, in this case, we wrap everything in a class, with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the name of the class has been capitalized, which may seem odd, given
    that all of our functions have been lowercase so far. Although that''s by no means
    required, it''s generally common practice to capitalize class names, as it helps
    to distinguish classes from functions. Otherwise, invoking a function can look
    very similar to instantiating a class, leading to confusion. We have the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Instantiating a class means that you create a brand new copy of that class,
    and the new copy is referred to as an "instance" of the class. Defining a class
    and instantiating it are two separate actions. The entire block of code that starts
    with the "class" keyword makes up the class definition and defines all of the
    attributes and capabilities of a class. It can be thought of as the blueprint
    for that class. However, to actually make use of a class, we have to actually
    create one. Once you've defined a class, you can make as many instances as you
    want, each with their own properties. The class definition is like the CAD files
    for a product, whereas the instance is like the actual physical product that rolls
    off the assembly line.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a class, we can add functionality to it by adding functions. We
    have to at least create a function named `__init__` that will be responsible for
    initializing each class instance. This function will be called automatically each
    time an instance of the class is called.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `__init__` function takes one argument, which we've labeled "self".
    When Python instantiates a class, it always passes a reference to the instance
    itself to all of the member functions. We could call it anything we want, but
    "self" is the convention and one that we'll adhere to.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `__init__` function, we''ll do everything we need to do to set up out
    UI. In this case, we''ll create one field and one button. We store references
    to the field in an instance variable as properties of the self-object (which remember,
    is just the class instance itself). Doing this will allow us to retrieve the values
    of the controls later in the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, when we want to tie our controls to actual functionality, we''ll
    need to preface our functions with "self." to refer to the method of our class.
    We do this with the button code in the next line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Setting variables as properties of the class via self will make them accessible
    to other functions within the class. Note that we stored a reference to the field,
    but not to the button; this is because we're not likely to want to query anything
    about the button or to change anything about it after it's been created. In such
    cases, it's fine to just use local variables or to not store the results at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have both our field and our button, we show the window. Now we''re
    ready to add the `makeSpheres` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note that the function signature includes "self" as the first argument and has
    "*args", our catch-all for any passed values as the second argument. This is another
    example of how Python passes the class instance into all of its member functions
    each time they are called.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code for the `makeSpheres` function is very similar to what
    we wrote in the non-class-based example. We use the query mode to retrieve the
    number in the `intField`, then we make that many spheres, moving each one by the
    corresponding multiple of the radius to space them out nicely.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And with this, we''re done defining our class. However, we also need to actually
    create an instance of it in order to see anything happen. The last line of the
    script does exactly this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This creates a new instance of our `SpheresClass` class and, in so doing, runs
    the `__init__` function, which in turn, sets up our UI and shows it to the user.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Object-oriented programming** (**OOP**) is a huge topic, and a full treatment
    of all of the ins and outs is beyond the scope of this book. It''s also something
    you''re likely to be familiar with if you''ve been using Python (or any other
    object-oriented language) for any length of time.'
  prefs: []
  type: TYPE_NORMAL
- en: If this is the first time you're seeing it, be sure to read through the Python
    documentation on classes. OOP practices may seem like a lot of unnecessary overhead
    at first, but they ultimately make it much easier to tackle complex problems.
  prefs: []
  type: TYPE_NORMAL
- en: Using nested layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Very often, the interfaces that you'll want to create cannot be implemented
    with a single layout. In those cases, you'll need to nest layouts inside each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we'll create `rowLayouts` within a single columnLayout. Each
    `rowLayout` will allow us to have two controls (in this case, some text and `intField`)
    next to each other horizontally, and the parent `columnLayout` will stack the
    combined text/field pairs on top of each other vertically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The end result will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using nested layouts](img/4657_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Make a new script and name it `nestedLayouts.py`. Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Run the script, and you should see two rows, each with a bit of text and an
    `intField`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we start out by creating a `columnLayout`, just as we''ve
    done in other examples so far. Then, we immediately create another layout, and
    this time, it is a rowLayout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When you create a layout, it immediately becomes the default parent for any
    other elements (either controls or other layouts) that you create. So, in this
    case, we have a columnLayout that contains a two-column rowLayout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve done this, we can add elements to our rowLayout, which we do with
    the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, our first rowLayout is filled because we created it with two
    columns and we''ve added two controls to it. If we attempt to add another control,
    we''ll get an error similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to continue to add elements to our UI, we''ll need to jump up a level
    back to the `columnLayout`. At any given moment, there is exactly one and only
    one default parent to which Maya will add controls to. Every time you create a
    new layout, it becomes the default parent automatically. Sometimes, you''ll need
    to change the default parent directly, which can be accomplished with the `setParent`
    command, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `setParent` and passing `".."` as the argument will move up a single
    level in the hierarchy of layouts. In this case, it means that we move up from
    the rowLayout back to the columnLayout. Once we''ve done this, we can create the
    second rowLayout, again with two columns. We are then free to add a second group
    of a text field and an int field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jumping around the hierarchy can get a bit tedious. If you're going to have
    a number of controls that you want to add label text to, it might be best to create
    a helper function to your script's class to add a new control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of what that might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we take in the text to use for the label, and we return a reference to
    the newly created intField. Rewriting our example using the above would give us
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This is quite a bit neater, indeed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that our addLabeledIntField accepts two arguments, but we only pass a single
    one to it when we call it. This is due to the way that Python handles classes;
    every class method *always* receives a reference to the class itself. So, any
    arguments that we want to make use of start at the second one.
  prefs: []
  type: TYPE_NORMAL
- en: Using tabs and scrolling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll be looking at how to create UIs that contain tabs and
    how to provide scrollable containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our UI will contain two tabs arranged horizontally, with each tab containing
    a scrollable column of 20 buttons. The final result will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using tabs and scrolling](img/4657_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script, name it `tabExample.py` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a tab layout is quite easy; all that's required is a call to the `tabLayout`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note that we save the output of the `tabLayout` command to an instance variable,
    and we'll need that later. So now we have the tab layout, but we're still not
    ready to add any controls just yet. That's because the tab layout cannot actually
    contain controls directly; it is only meant to hold other layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first tab, we''ll keep it simple and just add a `columnLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note that we also store the output, which in this case is the name of the column
    layout (something like "columnLayout17" or similar). Now we can start adding controls
    if we want, but there's one more thing we'll want to do first.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the text that is displayed in the actual tab of the tabbed layout
    will be the name of the child layout. This will almost never be what you want;
    you'll generally want to give your tabs nice, sensible labels instead of leaving
    them with names like "columnLayout23" and "scrollLayout19".
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we''ll need to edit our tab layout and use the `tabLabel` argument.
    The `tabLabel` argument expects a two-element array of strings, where the first
    string is the name of a child of the tab layout (in this case, our column layout),
    and the second is the text you want to display. Putting this all together gives
    us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We invoke the tabLayout command in the edit mode, direct it at our tab layout
    (which we stored in the `self.tabs` variable) and set the input to tabLabel such
    that we give our columnLayout the label of "Simple Tab".
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add a single button, just so that we have something inside the tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we''re done with the first tab and ready to start on the second
    tab. But before we can do this, we need to jump up a level in the hierarchy so
    that we can add new content to the tab layout, rather than continuing to add to
    the column layout we created within it. We do this with the `setParent` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re ready to start on our second tab. This time, we''ll add a scroll
    layout as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we'll edit the original tab layout so that the second tab has a
    proper name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: To finish things off, we'll create a column layout within the scroll layout
    and add some buttons.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll use setParent twice (once for the column layout and again for
    the scroll layout) to move back up the hierarchy to the tab layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We're now ready to add more tabs, if we want.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you ever need to know which tab is currently selected, you can find out
    via the `selectTabIndex` or sti flag. One gotcha to be aware of is that the number
    returned is indexed based on 1, rather than 0 as you might expect. If you *do*
    receive zero, it means that the tab layout in question doesn''t have any children:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `selectTabIndex` to set which tab is currently active.
    For example, if we wanted to ensure that our example started out with the second
    tab selected, we could add the following line to our `__init__` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: When building complex UIs, having the ability to change behavior based on what
    part of the interface is currently active, or to start the script with a different
    part showing, can be a great way to make your scripts more responsive and easier
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: Adding menus to your UIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more complex scripts, it can be helpful to add a drop-down menu to the top
    of your window. For example, you might want to have your script support custom
    configuration files and allow users to both save the current settings to disk,
    or to load previously saved settings. In that case, implementing the **File**
    menu with suboptions for **Save** and **Load** could be a very user-friendly option.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we'll be creating a window with its own menu, as well as looking
    at how to offer the user additional options via an option box, just like Maya's
    built-in menus.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding menus to your UIs](img/4657_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script and name it `customMenu.py`. Once again, we''ll be creating
    a custom class to handle both our UI creation and functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If you run this code, you'll get a window with a two-item menu (**File** and
    **Objects**), each one of which provides two options.
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually have something happen when the user selects an option, we''ll need
    to provide a value for the command flag for one or more of our menuItem controls,
    as in the following (some of the preceding code has been removed to make the example
    shorter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This would enable both of the **Make Sphere** and **Make Cube** menu items to
    create the respective polygonal geometry.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating menus is pretty easy, and it is mainly just required that you:'
  prefs: []
  type: TYPE_NORMAL
- en: Include the `menuBare=True` option when creating the initial window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add one or more menus with the `menu()` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each menu, add one or more menuItem controls, providing a command for each.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many of Maya's commands offer the user two ways to trigger them—the default
    way and via the command's corresponding option box, which offers the user additional
    options for the command. You can do the same thing with your own menus by adding
    the second menuItem directly after the one to which you want to add an option
    box and setting the second menuItem's `optionBox` flag to true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we want to offer a command to create a polygonal sphere. We
    want the default radius to be 1 unit, but we also want to provide an option box,
    which when selected, will allow the user to specify a custom radius. To do this,
    we would want to add something like the following to our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Even though we're creating two menuItem controls, they would be presented to
    the user as a single entry in the `"Objects"` menu though one with an option box.
    When you add the `optionBox=True` flag to a menuItem control, Maya will add an
    option to the most recently created menuItem. Creating menuItem and setting `optionBox=True`
    without first creating a normal menuItem will leave Maya without anything to add
    the option box to and will result in an error.
  prefs: []
  type: TYPE_NORMAL
- en: This may seem a bit odd, but it makes a bit of sense since the default command
    and the option box are two separate clickable areas, so it's not totally unreasonable
    to implement them as separate controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve set up the two controls, we''ll want to make sure that they both
    do similar things, but one of them (the option box) provides additional input.
    An easy way to do it is with the `promptDialog` command, which provides an easy
    way to get a single value from the user. To ask the user to input a value for
    the sphere''s radius, we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code would result in a new popup window with a single field and
    two buttons labeled **OK** and **CANCEL**. You'll note that we're storing the
    result of the promptDialog to a variable named promptInput.
  prefs: []
  type: TYPE_NORMAL
- en: You might think that this variable would hold the value that the user has entered,
    but that would be incorrect. Instead, it holds the value of the button that they
    pressed to dismiss the dialog. That probably seems strange, but it's necessary
    so that we can determine if the user has actually finalized the command or if
    they are decided to be canceled.
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually make use of the input, we''ll want to start by checking to see
    whether the user did, in fact, press the **OK** button. The promptDialog will
    return one of the two values:'
  prefs: []
  type: TYPE_NORMAL
- en: If the user pressed one of the buttons, the return value will be the text associated
    with that button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the dialog was dismissed in some other way (like by clicking the X), whatever
    was provided as the dismissString will be returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our example, if the user pressed one of the buttons, we will have either
    **OK** or **CANCEL** as the return value. Notice that we''ve also set the dismissString
    to **CANCEL** as well. So, all we have to do is to check to see whether **OK**
    was returned, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that there are `two` equals signs, not one. This is a common source of
    error when people are new to Python. The key thing to remember is that a single
    equals sign always results in an `assignment`, and that you need to use two equals
    signs to perform a check for equality. This is true in many languages (not just
    Python) and stems from the fact that setting a variable to a given value is a
    very different operation than checking two values against each other. Since they
    are two different actions, Python (and most other languages) signifies each in
    a different way—one equals for assignment and two for comparison.
  prefs: []
  type: TYPE_NORMAL
- en: If that check passes, then we know that the user pressed **OK** and that we
    should grab the input value. We'll have to do that in a slightly different way
    than we have previously though. In the other examples, we've saved a reference
    to the created control and used that to specify the control when using the query
    mode to grab the value.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, however, the `promptDialog` command returns the button pressed,
    rather than a reference to its field. So how are we to refer to the proper control?
  prefs: []
  type: TYPE_NORMAL
- en: 'As it turns out, we can just use the `promptDialog` command the second time,
    but in the query mode. Even though we don''t specify the specific `promptDialog`
    to query, it will still work since Maya will default to the one that was most
    recently created. Since we''re grabbing the value immediately after creating the
    dialog, this will work just fine. Putting that all together, gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have to query "text" rather than "value". Also note that once we
    have the input, it gets passed to a separate function to actually do the work.
    This's important so that we can ensure that the exactly same code is triggered
    by both the default (non-option box) and option box versions of our menu item.
  prefs: []
  type: TYPE_NORMAL
- en: This may seem redundant here because we're just creating a sphere, but it's
    still a good idea. Don't duplicate code!
  prefs: []
  type: TYPE_NORMAL
- en: 'We would end up with three functions—first, to actually perform the work (in
    this case, creating a sphere), second, to call that function with default values
    (for the base menuItem), and third, to call that function after retrieving some
    additional information from the user. Putting all that together would give us
    something like this (the `__init__` method omitted for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
