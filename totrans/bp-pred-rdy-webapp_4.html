<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-104"><a id="_idTextAnchor111"/>4</h1>
<h1 id="_idParaDest-105"><a id="_idTextAnchor112"/>Creating a Reusable Frontend with React</h1>
<p>In the previous chapter, we built an API to manage sessions, members, and to-dos. In this chapter, we will create a frontend that is capable of connecting to that API or any other you may wish to use. In addition, we’ll add styling, routing, validated data entry, and feedback via toasts. </p>
<p>Styling, routing, data entry, and feedback are all features that will be useful in your app and are not specific to to-dos. Therefore, at the end of this chapter, we’ll have created a frontend to which we can add a user interface with any specific functionality.</p>
<p>So, in this chapter, we will cover the following topics:</p>
<ul>
<li>Enhancing the basic React app</li>
<li>Adding routing</li>
<li>Enabling data entry</li>
<li>Managing the app state</li>
<li>Supporting toast feedback</li>
</ul>
<h1 id="_idParaDest-106"><a id="_idTextAnchor113"/>Technical requirements</h1>
<p>The following additional folders are required in this chapter and should be created:</p>
<pre class="source-code">
tozo
└── frontend
    └── src
        └── components</pre>
<p>To follow the development in this chapter using the companion repository, <a href="https://github.com/pgjones/tozo">https://github.com/pgjones/tozo</a>, see the commits between the <code>r1-ch4-start</code> and <code>r1-ch4-end</code> tags.</p>
<h1 id="_idParaDest-107"><a id="_idTextAnchor114"/>Enhancing the basic React app</h1>
<p>In the <em class="italic">Installing NodeJS for frontend development</em> section of <a href="B18727_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a><em class="italic">, Setting Up Our System for Development</em>, we used the <code>create-react-app</code> tool<a id="_idIndexMarker247"/> to<a id="_idIndexMarker248"/> create a standard React app, which we can now configure for our usage. </p>
<p>First, as we are using a frontend development server, we will need to proxy API requests to our backend by adding the following to <em class="italic">frontend/package.json</em>:</p>
<pre class="source-code">
{
<strong class="bold">  ...</strong>,
  "proxy": "http://localhost:5050"
}</pre>
<p>The highlighted ellipsis represents the existing code; note the additional trailing comma that has been added.</p>
<p>Next, we’ll configure the import system so that we can use full paths with <em class="italic">src</em> as the root (i.e., <em class="italic">src/components/Component</em>) rather than, for example, <em class="italic">../components/Component</em>. This makes the imported file easier to find as we can always relate the path to the <em class="italic">src</em> directory. It also matches the type of import paths we’ve used already in the backend. To do so, we need to add the following to <em class="italic">frontend/tsconfig.json</em>:</p>
<pre class="source-code">
{
  "compilerOptions": {
    "baseUrl": "./",
<strong class="bold">    ...</strong>
  }
}</pre>
<p>The <code>compilerOptions</code> section should already exist, to which the <code>baseUrl</code> entry should be added (the highlighted ellipsis represents the existing code). In addition, we need to install <code>eslint-import-resolver-typescript</code> to inform <code>eslint</code> to use the<a id="_idIndexMarker249"/> same <code>baseUrl</code> by running the following in the <em class="italic">frontend</em> directory:</p>
<pre>npm install --save-dev eslint-import-resolver-typescript</pre>
<p>This is then configured by adding the following to the <code>eslintConfig</code> section in <em class="italic">frontend/package.json</em>:</p>
<pre class="source-code">
"eslintConfig": {
<strong class="bold">  "extends": [...],</strong>
  "settings": {
    "import/resolver": {
      "typescript": {}
    }
  }
}</pre>
<p>The <a id="_idIndexMarker250"/>highlighted line represents the existing code within the existing <code>eslintConfig</code> section. </p>
<p>With these small configuration changes, we can now focus on styling the app, adding page titles, and adding an authentication context.</p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor115"/>Styling the app</h2>
<p>It <a id="_idIndexMarker251"/>takes a lot of effort to build a design system and use it consistently to style an app. Fortunately, <code>MUI</code> (<a href="http://mui.com">mui.com</a>) is an <a id="_idIndexMarker252"/>existing React component library that can be used to create apps using the Material Design System pioneered by Google. <code>MUI</code> is installed by running the following in the <em class="italic">frontend</em> directory:</p>
<pre>npm install @mui/material @mui/icons-material @mui/lab @emotion/react @emotion/styled </pre>
<p>As material design and MUI are based on the Roboto font, we will need to install that as well by running the following in the <em class="italic">frontend</em> directory:</p>
<pre>npm install @fontsource/roboto</pre>
<p>This font <a id="_idIndexMarker253"/>also needs to be included in the bundle and hence the following imports should be added to <em class="italic">frontend/src/App.tsx</em>:</p>
<pre class="source-code">
import "@fontsource/roboto/300.css";
import "@fontsource/roboto/400.css";
import "@fontsource/roboto/500.css";
import "@fontsource/roboto/700.css";</pre>
<p>The number refers to the font weight (boldness); by default, <code>MUI</code> only uses <code>300</code>, <code>400</code>, <code>500</code>, and <code>700</code> weights, so these are the only ones we need. </p>
<p class="callout-heading">Semantic HTML</p>
<p class="callout">MUI<a id="_idIndexMarker254"/> is very good at using the most descriptive HTML tags for the elements; for example, MUI buttons use the <code>Button</code> tag rather than styling a <code>div</code> tag. This is called <strong class="bold">semantic HTML</strong> as it uses <a id="_idIndexMarker255"/>HTML to reinforce the semantics of the content. This is an important thing to do as it aids accessibility and improves the user experience.</p>
<p>So far, our app will look exactly the same as the default <code>MUI</code> app, but we can change that by theming our app. To do so, let’s create a <code>ThemeProvider</code> element by placing the following in <em class="italic">frontend/src/ThemeProvider.tsx</em>:</p>
<pre class="source-code">
import { useMemo } from "react";
import { PaletteMode } from "@mui/material";
import CssBaseline from "@mui/material/CssBaseline";
import useMediaQuery from "@mui/material/useMediaQuery";
import { createTheme, ThemeProvider as MuiThemeProvider } from "@mui/material/styles";
interface IProps {
  children: React.ReactNode;
}
const ThemeProvider = ({ children }: IProps) =&gt; {
  const prefersDarkMode = useMediaQuery("(prefers-color-scheme:     dark)"); 
  const theme = useMemo(
    () =&gt; {
      const palette = { 
        mode: (prefersDarkMode ? "dark" : "light") as           PaletteMode,
      }; 
      return createTheme({ palette }); 
    }, 
    [prefersDarkMode] 
  );
  return (
    &lt;MuiThemeProvider theme={theme}&gt;
      &lt;CssBaseline enableColorScheme /&gt;
      { children }
    &lt;/MuiThemeProvider&gt;
  );
};
export default ThemeProvider;</pre>
<p>Here, we’ve<a id="_idIndexMarker256"/> used the <code>CssBaseline</code> component to reset and normalize the browser’s styling, thereby ensuring our app looks the same in all browsers. We’ve also used the <code>prefers-color-scheme</code> system preference to switch the app to a dark mode if the user’s system indicates that’s their preference.</p>
<p>The <code>ThemeProvider</code> should be rendered in the <code>App</code> component as the parent of any styled components, i.e. <em class="italic">fro<a id="_idTextAnchor116"/>ntend/src/App.tsx</em> should be as follows:</p>
<pre class="source-code">
import ThemeProvider from "src/ThemeProvider";
const App = () =&gt; {
  return (
    &lt;ThemeProvider&gt;
    &lt;/ThemeProvider&gt;
  );
}</pre>
<p>Note that I’ve changed the <code>App</code> function definition syntax to use the arrow function syntax rather than the function definition syntax as created for us by <code>create-react-app</code>.</p>
<p class="callout-heading">Function style</p>
<p class="callout">TypeScript allows for functions to be defined with a <code>function</code> keyword or via the arrow <code>=&gt;</code> syntax. While there are differences between these two styles, for a React component it makes no practical difference which style is used. In this book, I’ll use the arrow syntax based on my preference.</p>
<p>As we’ve changed the <code>App</code> component, we also need to update the test by replacing <em class="italic">frontend/src/App.test.tsx</em> with the following:</p>
<pre class="source-code">
import React from "react";
import { render } from "@testing-library/react";
import App from "./App";
test("renders the app", () =&gt; {
  render(&lt;App /&gt;);
});</pre>
<p>We are <a id="_idIndexMarker257"/>aiming for our app to be usable on small mobile screens, large desktop screens, and everything in-between. We can achieve this by building the app for small mobile screens and allowing it to resize with the screen size. However, as you can see in <em class="italic">Figure 4.1</em>, this starts to look odd with large horizontal widths: </p>
<div><div><img alt="Figure 4.1: How the app would look without a Container  " height="254" src="img/B18727_04_01.jpg" width="879"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1: How the app would look without a Container </p>
<p>This is fixed by adding a <code>Container</code> within the <code>ThemeProvider</code> in <em class="italic">frontend/src/App.tsx</em>:</p>
<pre class="source-code">
<strong class="bold">import Container from "@mui/material/Container";</strong>
const App = () =&gt; {
  return (
    &lt;ThemeProvider&gt;
<strong class="bold">      &lt;Container maxWidth="md"&gt;</strong>
<strong class="bold">      &lt;/Container&gt;</strong>
    &lt;/ThemeProvider&gt;
  );
}</pre>
<p>The highlighted lines show the additions, and the result is shown in <em class="italic">Figure 4.2</em>:</p>
<div><div><img alt="Figure 4.2: How the app looks with the Container " height="254" src="img/B18727_04_02.jpg" width="986"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2: How the app looks with the Container</p>
<p>With the<a id="_idIndexMarker258"/> styling in place, we can now add a title for each page.</p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor117"/>Adding page titles</h2>
<p>We<a id="_idIndexMarker259"/> can give the user a better experience by configuring the page title as it is displayed in the user’s browser, as seen in <em class="italic">Figure 4.3</em>:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div><div><img alt="Figure 4.3: The title (as displayed by Chrome)  " height="107" src="img/B18727_04_03.jpg" width="1153"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3: The title (as displayed by Chrome) </p>
<p>To set the title, we can use <code>react-helmet-async</code>, which is installed by running the following in the <em class="italic">frontend</em> directory:</p>
<pre>npm install react-helmet-async</pre>
<p>To use <code>react-helmet-async</code>, we need to add <code>HelmetProvider</code> as an ancestor to our components by adding the following to <em class="italic">frontend/src/App.tsx</em>:</p>
<pre class="source-code">
<strong class="bold">import { Helmet, HelmetProvider } from "react-helmet-async";</strong>
const App = () =&gt; {
  return (
<strong class="bold">    &lt;HelmetProvider&gt;</strong>
<strong class="bold">      &lt;Helmet&gt;</strong>
<strong class="bold">        &lt;title&gt;Tozo&lt;/title&gt;</strong>
<strong class="bold">      &lt;/Helmet&gt;</strong>
      &lt;ThemeProvider&gt;
        &lt;Container maxWidth="md"&gt;
        &lt;/Container&gt;
      &lt;/ThemeProvider&gt; 
<strong class="bold">    &lt;/HelmetProvider&gt;</strong>
  );
}</pre>
<p>The<a id="_idIndexMarker260"/> highlighted lines will set the default page title to be <code>Tozo</code> and should be added to the existing code. </p>
<p>We can now create a <code>Title</code> component that both sets the title displayed by the browser and displays clear title text on the page, by adding the following to <em class="italic">frontend/src/components/Title.tsx</em>:</p>
<pre class="source-code">
import Typography from "@mui/material/Typography";
import { Helmet } from "react-helmet-async";
interface IProps {
  title: string;
}
const Title = ({ title }: IProps) =&gt; (
  &lt;&gt;
    &lt;Helmet&gt;
      &lt;title&gt;Tozo | {title}&lt;/title&gt;
    &lt;/Helmet&gt;
    &lt;Typography component="h1" variant="h5"&gt;{title}    &lt;/Typography&gt;
  &lt;/&gt;
);
export default Title;</pre>
<p>With this <a id="_idIndexMarker261"/>small addition, we can now consider how the app knows whether the user is authenticated or not. </p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor118"/>Adding an authentication context</h2>
<p>The<a id="_idIndexMarker262"/> frontend app will need to track whether the user is currently authenticated (logged in) and show the login or registration page if they are not. This is something that will be useful throughout the app and hence we’ll use a React context, specifically called <code>AuthContext</code>, by adding the following to <em class="italic">frontend/src/AuthContext.tsx</em>:</p>
<pre class="source-code">
import { createContext, useState } from "react";
 
interface IAuth {
  authenticated: boolean;
  setAuthenticated: (value: boolean) =&gt; void;
}
 
export const AuthContext = createContext&lt;IAuth&gt;({
  authenticated: true,
  setAuthenticated: (value: boolean) =&gt; {},
});
 
interface IProps {
  children?: React.ReactNode;
}
 
export const AuthContextProvider = ({ children }: IProps) =&gt; {
  const [authenticated, setAuthenticated] = useState(true);
 
  return (
    &lt;AuthContext.Provider 
      value={{ authenticated, setAuthenticated }}
    &gt;
      {children}
    &lt;/AuthContext.Provider&gt;
  );
};</pre>
<p class="callout-heading">React context and prop drilling</p>
<p class="callout">React context<a id="_idIndexMarker263"/> is best used to share things globally within a React component tree. This is because any descendant of the provider will be able to access the context. We could also achieve this by <a id="_idIndexMarker264"/>passing the context via props through the tree, called prop drilling. However, prop drilling soon becomes cumbersome when there are many components to pass through.</p>
<p>To make <a id="_idIndexMarker265"/>this context available throughout the app, we can add the provider to <em class="italic">frontend/src/App.tsx</em>:</p>
<pre class="source-code">
<strong class="bold">import { AuthContextProvider } from "src/AuthContext";</strong>
 
const App = () =&gt; {
  return (
<strong class="bold">    &lt;AuthContextProvider&gt;</strong>
      &lt;HelmetProvider&gt;
        &lt;Helmet&gt;
          &lt;title&gt;Tozo&lt;/title&gt;
        &lt;/Helmet&gt;
        &lt;ThemeProvider&gt;
          &lt;Container maxWidth="md"&gt;
          &lt;/Container&gt;
        &lt;/ThemeProvider&gt; 
      &lt;/HelmetProvider&gt;
<strong class="bold">    &lt;/AuthContextProvider&gt;</strong>
  );
}</pre>
<p>The highlighted lines should be added to the existing code.</p>
<p>This then <a id="_idIndexMarker266"/>allows the authentication state to be accessed in any component via a <code>useContext</code> hook:</p>
<pre class="source-code">
import { AuthContext } from "src/AuthContext";
const { authenticated } = React.useContext(AuthContext);</pre>
<p>We’ll make use of this context next, as we set up the routing.</p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor119"/>Adding routing </h1>
<p>Frontend apps <a id="_idIndexMarker267"/>are usually made up of multiple pages, as is our to-do app. We will achieve this with routing, which allows different page components to render, depending on the app’s path. As we are building a single-page app, this routing will be done in the frontend code, rather than the backend, which would be the case for a multi-page app. </p>
<p>We’ll use <a id="_idIndexMarker268"/>React Router (<a href="http://reactrouter.com">reactrouter.com</a>) to handle routing in our app. It is installed by running the following command in the <em class="italic">frontend</em> directory:</p>
<pre>npm install react-router-dom</pre>
<p class="callout-heading">Single-page app</p>
<p class="callout">A <strong class="bold">single-page app</strong>, often called an <strong class="bold">SPA</strong>, refers to a web app whereby only a single page is fetched from the backend <a id="_idIndexMarker269"/>server. This single page is then able to render all the pages within the app. This is an advantage as navigating from one page to another is typically quicker in an SPA; however, this comes with the cost of a larger initial download.</p>
<p>I find it clearer to<a id="_idIndexMarker270"/> place all the routing into a single component called <code>Router</code>, with each page being an individual <code>Route</code>. The <code>Router</code> is defined by adding the following to <em class="italic">frontend/src/Router.tsx</em>:</p>
<pre class="source-code">
import { BrowserRouter, Routes } from "react-router-dom";
const Router = () =&gt; (
  &lt;BrowserRouter&gt;
    &lt;Routes&gt;
      {/* Place routes here */}
    &lt;/Routes&gt;
  &lt;/BrowserRouter&gt;
); 
export default Router;</pre>
<p>The <code>Router</code> component<a id="_idIndexMarker271"/> should then be rendered within the <code>Container</code> component as shown by the following, which should be added to <em class="italic">frontend/src/App.tsx</em>:</p>
<pre class="source-code">
<strong class="bold">import Router from "src/Router";</strong>
 
const App = () =&gt; {
  return (
    &lt;AuthContextProvider&gt;
      &lt;HelmetProvider&gt;
        &lt;Helmet&gt;
          &lt;title&gt;Tozo&lt;/title&gt;
        &lt;/Helmet&gt;
        &lt;ThemeProvider&gt;
          &lt;Container maxWidth="md"&gt;
<strong class="bold">            &lt;Router /&gt;</strong>
          &lt;/Container&gt;
        &lt;/ThemeProvider&gt; 
      &lt;/HelmetProvider&gt;
    &lt;/AuthContextProvider&gt;
  );
}</pre>
<p>The highlighted lines should be added to the existing code.</p>
<p>We can now add authentication to our routing to ensure that some of the pages only render for a logged-in user.</p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor120"/>Requiring authentication</h2>
<p>A significant<a id="_idIndexMarker272"/> fraction of the routes in the app should only be available for users who are logged in. Therefore, we need a component that checks whether the user is authenticated and renders the page. Alternatively, if the user isn’t authenticated, the app redirects the user to the login page. This is done by creating the following component in <em class="italic">frontend/src/components/RequireAuth.tsx</em>:</p>
<pre class="source-code">
import { useContext } from "react";
import { Navigate, useLocation } from "react-router-dom";
import { AuthContext } from "src/AuthContext";
interface IProps {
  children: React.ReactNode;
}
const RequireAuth = ({ children }: IProps) =&gt; {
  const { authenticated } = useContext(AuthContext);
  const location = useLocation();
  if (authenticated) {
    return &lt;&gt;{children}&lt;/&gt;;
  } else {
    return &lt;Navigate state={{ from: location }} to="/login/" /&gt;;
  }
};
export default RequireAuth;</pre>
<p>The navigation state is set to include the current location so that the user can be redirected back to the page after successfully authenticating.</p>
<p>We can then <a id="_idIndexMarker273"/>use <code>RequireAuth</code> as a wrapper around a <code>Page</code> component within a <code>Route</code>, as this ensures that the <code>Page</code> only renders if the user is authenticated, for example (this shouldn’t be added to our app):</p>
<pre class="source-code">
&lt;Route 
  element={&lt;RequireAuth&gt;&lt;Page /&gt;&lt;/RequireAuth&gt;} 
  path= "/private/" 
/&gt;</pre>
<p>The final aspect of the routing setup is to control the scrolling when navigating.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor121"/>Resetting scrolling on navigation</h2>
<p>When a <a id="_idIndexMarker274"/>user navigates and changes the page in the app, they will expect to view the new page from the start (i.e., the top of the page). As the view, or scroll position, will remain fixed on a React Router navigation, we will need to reset it to the top ourselves. We can do this We can do this by scrolling up to the window top on a change in the path via the following component, as placed in <em class="italic">frontend/src/components/ScrollToTop.tsx</em>:</p>
<pre class="source-code">
import { useEffect } from "react";
import { useLocation } from "react-router";
 
const ScrollToTop = () =&gt; {
  const { pathname } = useLocation();
 
  useEffect(() =&gt; {
    window.scrollTo(0, 0);
  }, [pathname]);
 
  return null;
};
 
export default ScrollToTop;</pre>
<p>The <code>useEffect</code> will only trigger when its <code>pathname</code> dependency changes, hence the scrolling only occurs on navigation.</p>
<p>This component should be rendered within <code>BrowserRouter</code> in the <code>Router</code> component by adding the following to <em class="italic">frontend/src/Router.tsx</em>:</p>
<pre class="source-code">
<strong class="bold">import ScrollToTop from "src/components/ScrollToTop";</strong>
 
const Router = () =&gt; (
  &lt;BrowserRouter&gt;
<strong class="bold">    &lt;ScrollToTop /&gt;</strong>
    &lt;Routes&gt;
      {/* Place routes here */}
    &lt;/Routes&gt;
  &lt;/BrowserRouter&gt;
);</pre>
<p>The <a id="_idIndexMarker275"/>highlighted lines should be added to the existing code.</p>
<p>In order for the frontend tests to pass, we will need to define the <code>window.scrollTo</code> function by adding the following to <em class="italic">frontend/src/setupTests.ts</em>:</p>
<pre class="source-code">
window.scrollTo = (x, y) =&gt; {
  document.documentElement.scrollTop = y;
}</pre>
<p>This is all we <a id="_idIndexMarker276"/>require to enable pages via routing in our app; now, we can focus on how the user will enter data.</p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor122"/>Enabling data entry</h1>
<p>Users of our app <a id="_idIndexMarker277"/>will need to enter their email and password to log in, and then a description, due date, and completion for their to-do tasks. These fields will need to be grouped into forms; building forms with a good user experience takes a lot of effort as the form must be validated and the touched state, error state, and focused state must be managed for each field and the form itself. </p>
<p class="callout-heading">Form input states</p>
<p class="callout">A form input box<a id="_idIndexMarker278"/> will need to display a variety of different states to help the user understand how it is used and when there is an issue. To start, the input will be in an empty state with no value and no error. This is important as the input should not show an error until the user touches/interacts with it. Then, while the user is interacting with it, the input should show that it is focused. Finally, after the input has been touched, if the value doesn’t validate, it needs to show an error state.</p>
<p>We’ll use Formik (<a href="http://formik.org">formik.org</a>) to <a id="_idIndexMarker279"/>manage the form and field states and <a id="_idIndexMarker280"/>Yup (<a href="http://github.com/jquense/yup">github.com/jquense/yup</a>) to validate the inputted data. These are installed by running the following in the <em class="italic">frontend</em> directory:</p>
<pre>npm install formik yup</pre>
<p>As we will use MUI for styling and Formik to manage the state, we will need to create field components that combine the two. While this will differ for each field, the following function is useful to all the components and should be placed in <em class="italic">frontend/src/utils.tsx</em>:</p>
<pre class="source-code">
import { FieldMetaProps } from "formik";
import React from "react";
export const combineHelperText = &lt;T, &gt;(
    helperText: React.ReactNode | string | undefined, 
    meta: FieldMetaProps&lt;T&gt;,
) =&gt; {
  if (Boolean(meta.error) &amp;&amp; meta.touched) {
    if (typeof helperText === "string") {
      return `${meta.error}. ${helperText ?? ""}`;
    } else {
      return (&lt;&gt;{meta.error}. {helperText}&lt;/&gt;);
    }
  } else {
    return helperText;
  }
}</pre>
<p>This generic<a id="_idIndexMarker281"/> function works by extracting the error from the Formik meta props and displaying it alongside the helper text if there is an error and the user has touched the input. The comma in <code>&lt;T, &gt;</code> is required to distinguish between the generic usage we desire and what a <code>&lt;T&gt;</code> JSX element alone implies.</p>
<p>With Formik installed and the helper function ready to use, we can start creating the field components, beginning with a checkbox field.</p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor123"/>Implementing a styled checkbox field</h2>
<p>In our app, we’ll need a <a id="_idIndexMarker282"/>checkbox field to indicate whether a to-do is complete or to indicate whether the user wants to be remembered when logging in. The following should be added to <em class="italic">frontend/src/components/CheckboxField.tsx</em>:</p>
<pre class="source-code">
import Checkbox from "@mui/material/Checkbox";
import FormControl from "@mui/material/FormControl";
import FormControlLabel from "@mui/material/FormControlLabel";
import FormHelperText from "@mui/material/FormHelperText";
import { FieldHookConfig, useField } from "formik";
import { combineHelperText } from "src/utils";
 
type IProps = FieldHookConfig&lt;boolean&gt; &amp; {
  fullWidth?: boolean;
  helperText?: string;
  label: string;
  required?: boolean;
};
 
const CheckboxField = (props: IProps) =&gt; {
  const [field, meta] = useField&lt;boolean&gt;(props);
 
  return (
    &lt;FormControl
      component="fieldset"
      error={Boolean(meta.error) &amp;&amp; meta.touched}
      fullWidth={props.fullWidth}
      margin="normal"
      required={props.required}
    &gt;
      &lt;FormControlLabel
        control={&lt;Checkbox {...field} checked={field.value} /&gt;}
        label={props.label}
      /&gt;
      &lt;FormHelperText&gt;
        {combineHelperText(props.helperText, meta)}
      &lt;/FormHelperText&gt;
    &lt;/FormControl&gt;
  );
};
 
export default CheckboxField;</pre>
<p>While most of this code is to style a checkbox as specified in the material design system, the key aspect is the usage of the <code>useField</code> hook to extract the Formik state for usage in the MUI<a id="_idIndexMarker283"/> components.</p>
<p>We can now move on to the next field, for date entry.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor124"/>Implementing a styled date field</h2>
<p>We’ll need a date field <a id="_idIndexMarker284"/>for the user to specify a due date for a to-do, which will look like <em class="italic">Figure 4.4</em>:</p>
<div><div><img alt="Figure 4.4: The date picker on a mobile screen " height="828" src="img/B18727_04_04.jpg" width="550"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4: The date picker on a mobile screen</p>
<p>To do so, we’ll <a id="_idIndexMarker285"/>make use of a <code>MUI-X</code> (<a href="http://mui.com/x">mui.com/x</a>) component rather than the inbuilt browser date picker, as the <code>MUI-X</code> picker is much easier for users to use. <code>MUI-X</code> is a set of advanced <code>MUI</code> components and hence works with, and follows, the same styling as <code>MUI</code>. Alongside <code>MUI-X</code>, we also need <code>date-fns</code> to parse strings into the <code>Date</code> instances. </p>
<p>Both are installed by running the following in the <em class="italic">frontend</em> folder:</p>
<pre>npm install @mui/x-date-pickers date-fns</pre>
<p>With these libraries installed, we can create a <code>DateField</code> component that provides a date picker as seen in <em class="italic">Figure 4.4</em> by adding the following to <em class="italic">frontend/src/components/DateField.tsx</em>:</p>
<pre class="source-code">
import TextField, { TextFieldProps } from "@mui/material/TextField";
import { AdapterDateFns } from "@mui/x-date-pickers/AdapterDateFns";
import { DatePicker } from "@mui/x-date-pickers/DatePicker";
import { LocalizationProvider } from "@mui/x-date-pickers/LocalizationProvider";
import { FieldHookConfig, useField } from "formik";
import { combineHelperText } from "src/utils";
 
const DateField = (
  props: FieldHookConfig&lt;Date | null&gt; &amp; TextFieldProps
) =&gt; {
  const [field, meta, helpers] = useField&lt;Date | null&gt;(props);
  return (
    &lt;LocalizationProvider dateAdapter={AdapterDateFns}&gt;
      &lt;DatePicker
        label={props.label}
        value={field.value}
        onChange={(newValue) =&gt; helpers.setValue(newValue)}
        renderInput={(params) =&gt; (
          &lt;TextField 
            fullWidth={props.fullWidth}
            {...params} 
            helperText={combineHelperText(props.helperText, meta)} 
          /&gt;
        )}
      /&gt;
    &lt;/LocalizationProvider&gt;
  );
}; 
export default DateField;</pre>
<p>Next, we can add a <a id="_idIndexMarker286"/>field component for entering emails.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor125"/>Implementing a styled email field</h2>
<p>We’ll need an email field for <a id="_idIndexMarker287"/>the user to log in and register. To do so, the following should be added to <em class="italic">frontend/src/components/EmailField.tsx</em>:</p>
<pre class="source-code">
import TextField, { TextFieldProps } from "@mui/material/TextField";
import { FieldHookConfig, useField } from "formik";
import { combineHelperText } from "src/utils";
 
const EmailField = (props: FieldHookConfig&lt;string&gt; &amp; TextFieldProps) =&gt; {
  const [field, meta] = useField&lt;string&gt;(props);
  return (
    &lt;TextField
      {...props}
      autoComplete="email"
      error={Boolean(meta.error) &amp;&amp; meta.touched}
      helperText={combineHelperText(props.helperText, meta)}
      margin="normal"
      type="email"
      {...field}
    /&gt;
  );
};
 
export default EmailField;</pre>
<p>Next, we can <a id="_idIndexMarker288"/>add a simple text field.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor126"/>Implementing a styled text field</h2>
<p>We’ll need a<a id="_idIndexMarker289"/> text field for the user to enter the to-do task information. To do so, the following should be added to <em class="italic">frontend/src/components/TextField.tsx</em>:</p>
<pre class="source-code">
import MUITextField, { TextFieldProps } from "@mui/material/TextField";
import { FieldHookConfig, useField } from "formik";
import { combineHelperText } from "src/utils";
 
const TextField = (props: FieldHookConfig&lt;string&gt; &amp; TextFieldProps) =&gt; {
  const [field, meta] = useField&lt;string&gt;(props);
  return (
    &lt;MUITextField
      {...props}
      error={Boolean(meta.error) &amp;&amp; meta.touched}
      helperText={combineHelperText(props.helperText, meta)}
      margin="normal"
      type="text"
      {...field}
    /&gt;
  );
};
 
export default TextField;</pre>
<p>Finally, we <a id="_idIndexMarker290"/>can add a password entry field.</p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor127"/>Implementing a styled password field</h2>
<p>We’ll need a <a id="_idIndexMarker291"/>password field for the user to enter their existing password when logging in or changing their password. This field should have a visibility toggle button that makes the password visible, as this helps the user get their password correct. </p>
<p>To do this, the following should be added to <em class="italic">frontend/src/components/PasswordField.tsx</em>:</p>
<pre class="source-code">
import IconButton from "@mui/material/IconButton";
import InputAdornment from "@mui/material/InputAdornment";
import TextField, { TextFieldProps } from "@mui/material/TextField";
import Visibility from "@mui/icons-material/Visibility";
import VisibilityOff from "@mui/icons-material/VisibilityOff";
import { FieldHookConfig, useField } from "formik";
import { useState } from "react";
import { combineHelperText } from "src/utils";
 
const PasswordField = (props: FieldHookConfig&lt;string&gt; &amp; TextFieldProps) =&gt; {
  const [field, meta] = useField&lt;string&gt;(props);
  const [showPassword, setShowPassword] = useState(false);
 
  return (
    &lt;TextField
      {...props}
      InputProps={{
        endAdornment: (
          &lt;InputAdornment position="end"&gt;
            &lt;IconButton
              onClick={() =&gt; setShowPassword((value) =&gt;                 !value)}
              tabIndex={-1}
            &gt;
              {showPassword ? &lt;Visibility /&gt; :                 &lt;VisibilityOff /&gt;}
            &lt;/IconButton&gt;
          &lt;/InputAdornment&gt;
        ),
      }}
      error={Boolean(meta.error) &amp;&amp; meta.touched}
      helperText={combineHelperText(props.helperText, meta)}
      margin="normal"
      type={showPassword ? "text" : "password"}
      {...field}
    /&gt;
  );
};
 
export default PasswordField;</pre>
<p>The <a id="_idIndexMarker292"/>visibility button is given a <code>tabIndex</code> value of <code>–1</code> to take it out of the tab flow, so that pressing the <em class="italic">Tab</em> key after entering the password takes the focus to the next field and not the visibility button, thereby matching the user’s expectations.</p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor128"/>Implementing a styled password strength field</h2>
<p>The existing password <a id="_idIndexMarker293"/>field allows users to enter a password but gives them no indication of how strong the password is. This is something that will be useful when the user is registering or changing their password. In the past, apps would mandate that special uppercase and lowercase characters should be present for a strong password. Yet this, sadly, leads to weaker passwords. So instead, we will require the password to be strong enough by calculating its entropy (this is something we already did in <a href="B18727_02.xhtml#_idTextAnchor053"><em class="italic">Chapter 2</em></a>, <em class="italic">Creating a Reusable Backend with Quart</em>).</p>
<p>Only checking the strength in the backend API call leads to a poor user experience as it takes too long for the user to receive feedback on the strength of their password. Fortunately, there is a <code>zxcvbn</code> version that we can use to provide users instant feedback on the strength of their password in the frontend. </p>
<p>To start, we should install it by running the following in the <em class="italic">frontend</em> directory:</p>
<pre class="source-code">
npm install zxcvbn 
npm install --save-dev @types/zxcvbn</pre>
<p>We’ll want this <a id="_idIndexMarker294"/>field to give immediate visual feedback to the user o<a id="_idTextAnchor129"/>n the strength of their password, both as a color that turns more green as the password strength improves, and as text that says <strong class="bold">Good</strong> or <strong class="bold">Strong</strong> as appropriate. So, let’s add the following function to <em class="italic">frontend/src/components/PasswordWithStrengthField.tsx</em>:</p>
<pre class="source-code">
const scoreToDisplay = (score: number) =&gt; {
  let progressColor = "other.red";
  let helperText = "Weak";
  switch (score) {
    case 25:
      progressColor = "other.pink";
      break;
    case 50:
      progressColor = "other.orange";
      break;
    case 75:
      progressColor = "other.yellow";
      helperText = "Good";
      break;
    case 100:
      progressColor = "other.green";
      helperText = "Strong";
      break;
  }
  return [progressColor, helperText];
};</pre>
<p>We can then<a id="_idIndexMarker295"/> use this function in the field itself by adding the following to <em class="italic">frontend/src/components/PasswordWithStrengthField.tsx</em>:</p>
<pre class="source-code">
import LinearProgress from "@mui/material/LinearProgress";
import { TextFieldProps } from "@mui/material/TextField";
import { FieldHookConfig, useField } from "formik";
import zxcvbn from "zxcvbn";
import PasswordField from "src/components/PasswordField";
const PasswordWithStrengthField = (
  props: FieldHookConfig&lt;string&gt; &amp; TextFieldProps,
) =&gt; {
  const [field] = useField&lt;string&gt;(props);
  const result = zxcvbn(field.value ?? "");
  const score = (result.score * 100) / 4;
  const [progressColor, helperText] = scoreToDisplay(score);
  return (
    &lt;&gt;
      &lt;PasswordField {...props} helperText={helperText} /&gt;
      &lt;LinearProgress
        sx={{
          "&amp; .MuiLinearProgress-barColorPrimary": {
            backgroundColor: progressColor,
          },
          backgroundColor: "action.selected",
          margin: "0 4px 24px 4px",
        }}
        value={score}
        variant="determinate"
      /&gt;
    &lt;/&gt;
  );
};
export default PasswordWithStrengthField;</pre>
<p>This code <a id="_idIndexMarker296"/>renders a <code>LinearProgress</code> c<a id="_idTextAnchor130"/>omponent below the existing <code>PasswordField</code> and colors it based on the <code>scoreToDisplay</code> function already added.</p>
<p>The <code>PasswordWithStrengthField</code> uses <code>zxcvbn</code> to determine the strength of the password. This means that any component that directly imports <code>PasswordWithStrengthField</code> will add <code>zxcvbn</code> to the bundle it is in, which is a problem, as <code>zxcvbn</code> is very large. Therefore, to only load <code>zxcvbn</code> when required, we can use React’s <a id="_idIndexMarker297"/>lazy loading and suspense system by adding the following to <em class="italic">frontend/src/components/LazyPasswordWithStrengthField.tsx</em>:</p>
<pre class="source-code">
import { TextFieldProps } from "@mui/material/TextField"; 
import { lazy, Suspense } from "react";
import { FieldHookConfig } from "formik";
import PasswordField from "src/components/PasswordField";
const PasswordWithStrengthField = lazy( 
  () =&gt; import("src/components/PasswordWithStrengthField"), 
);
const LazyPasswordWithStrengthField = (
  props: FieldHookConfig&lt;string&gt; &amp; TextFieldProps, 
) =&gt; (
  &lt;Suspense fallback={&lt;PasswordField {...props} /&gt;}&gt;
    &lt;PasswordWithStrengthField {...props} /&gt;
  &lt;/Suspense&gt;
);
export default LazyPasswordWithStrengthField;</pre>
<p>Now the <code>PasswordField</code> will be shown to the user until <code>zxcvbn</code> has been downloaded, thereby<a id="_idIndexMarker298"/> improving the user experience by ensuring it is only downloaded if the user needs it. </p>
<p>These are all the custom fields we need for our to-do app; next, we need a set of styled action buttons.</p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor131"/>Implementing styled form actions</h2>
<p>The fields we’ve <a id="_idIndexMarker299"/>implemented will be contained in forms that will need to be submitted. Therefore, let’s add a useful helper <code>FormActions</code> component that allows the user to submit the form as the primary action or to navigate elsewhere instead as secondary actions. The code for this follows and should be added to <em class="italic">frontend/src/components/FormActions.tsx</em>:</p>
<pre class="source-code">
import Button from "@mui/material/Button"; 
import LoadingButton from "@mui/lab/LoadingButton"; 
import Stack from "@mui/material/Stack";
import { Link } from "react-router-dom";
interface ILink {
  label: string;
  to: string;
  state?: any;
}
interface IProps {
  disabled: boolean;
  isSubmitting: boolean;
  label: string;
  links?: ILink[];
}
const FormActions = ({ disabled, isSubmitting, label, links }: IProps) =&gt; (
  &lt;Stack direction="row" spacing={1} sx={{ marginTop: 2 }}&gt;
    &lt;LoadingButton
      disabled={disabled}
      loading={isSubmitting}
      type="submit"
      variant="contained"
    &gt; 
      {label}
    &lt;/LoadingButton&gt; 
    {(links ?? []).map(({ label, to, state }) =&gt; (
      &lt;Button 
        component={Link}
        key={to}
        state={state}
        to={to}
        variant="outlined" 
      &gt;
        {label}
      &lt;/Button&gt;
    ))}
  &lt;/Stack&gt;
);
export default FormActions;</pre>
<p>The primary <a id="_idIndexMarker300"/>action is displayed using a <code>LoadingButton</code> component as it allows us to indicate to the user that the form submission is in progress via a spinning circle. Without this feedback, the user may think the app has frozen or ignored their click.</p>
<p>We now have all the fields and helper components we need for users to enter data. This means we can focus on how we will manage the app’s state and particularly how data is fetched from the backend and stored in the app’s state.</p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor132"/>Managing the app state</h1>
<p>As with the<a id="_idIndexMarker301"/> backend, it helps to have models that represent the data used in the app. These models will validate the data, help the linters ensure that we are using the data correctly, and ensure that the correct types are used. We will also use the model to correctly convert to and from the JSON representation used to communicate with the backend API.</p>
<p>The to-do model needs to be constructed from JSON, based on what is received from the backend or from data that the user entered. Then, the model needs to output as JSON so that this output can be sent to the backend. In addition, the model should validate that the data it is constructed from is of the correct structure and convert types (i.e., from strings representing dates in JSON to <code>Date</code> instances). </p>
<p>We only need a model for to-dos in the frontend, and hence we need the following in <em class="italic">frontend/src/models.ts</em>:</p>
<pre class="source-code">
import { formatISO } from "date-fns";
import * as yup from "yup";
const todoSchema = yup.object({
  complete: yup.boolean().required(),
  due: yup.date().nullable(),
  id: yup.number().required().positive().integer(),
  task: yup.string().trim().min(1).defined().strict(true), 
});
export class Todo {
  complete: boolean;
  due: Date | null;
  id: number;
  task: string;
 
  constructor(data: any) {
    const validatedData = todoSchema.validateSync(data);  
    this.complete = validatedData.complete;
    this.due = validatedData.due ?? null;
    this.id = validatedData.id;
    this.task = validatedData.task;
  }
 
  toJSON(): any {
    return {
      complete: this.complete,
      due:
        this.due !== null
          ? formatISO(this.due, { representation: "date" })
          : null,
      id: this.id,
      task: this.task,
    };
  }
}</pre>
<p>The <code>todoSchema</code> is used in the constructor to confirm the data is of the correct structure and to convert the types. The <code>toJSON</code> method is a standard JavaScript method to convert objects to JSON-compatible structures, which is done by converting the due date to an ISO 8601 formatted string.</p>
<p>While this model <a id="_idIndexMarker302"/>is specific to our app, using a class with <code>yup</code> validation is a good pattern for any app’s data. </p>
<p>With a model in place, we can now communicate with the backend, which we’ll focus on next.</p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor133"/>Communicating with the backend </h2>
<p>We’ll need to <a id="_idIndexMarker303"/>send and receive data from the backend API and then store it in the local state for usage in the various components that will render it. To begin, let’s install <code>axios</code> as it has a nicer API for sending and receiving JSON than the inbuilt <code>fetch</code> function. It is installed by running the following in the <em class="italic">frontend</em> folder:</p>
<pre>npm install axios</pre>
<p>We will need to store the data received in a way that allows it to be used across multiple components. To manage this state, we’ll use <code>React-Query</code> (<a href="https://tanstack.com/query/v4">https://tanstack.com/query/v4</a>), as it is pleasant and easy to use. To start, let’s install it by running the following in the <em class="italic">frontend</em> directory:</p>
<pre>npm install @tanstack/react-query</pre>
<p>To use <code>React-Query</code>, a <code>QueryClient</code> must be provided via React-Query’s <code>QueryClientProvider</code>. This is achieved by adding the following to <em class="italic">frontend/src/App.tsx</em>:</p>
<pre class="source-code">
<strong class="bold">import { QueryClient, QueryClientProvider } from "@tanstack/react-query";</strong>
<strong class="bold">const queryClient = new QueryClient();</strong>
 
const App =&gt; {
  return (
<strong class="bold">    &lt;QueryClientProvider client={queryClient}&gt;</strong>
      &lt;AuthContextProvider&gt;
        &lt;HelmetProvider&gt;
          &lt;Helmet&gt;
            &lt;title&gt;Tozo&lt;/title&gt;
          &lt;/Helmet&gt;
          &lt;ThemeProvider&gt;
            &lt;Container maxWidth="md"&gt;
              &lt;Router /&gt;
            &lt;/Container&gt;
          &lt;/ThemeProvider&gt; 
        &lt;/HelmetProvider&gt;
      &lt;/AuthContextProvider&gt;
<strong class="bold">    &lt;/QueryClientProvider&gt;</strong>
  );
};</pre>
<p>The highlighted<a id="_idIndexMarker304"/> lines should be added to the existing code.</p>
<p>We need to adapt React-Query so that requests that aren’t authenticated result in changes to the <code>AuthContext</code>. This is to handle cases where a user visits a page without logging in first. We’ll also only allow retries if the server doesn’t respond or responds with <a id="_idIndexMarker305"/>a <code>5XX</code> status code.</p>
<p class="callout-heading">State management</p>
<p class="callout">The rendered output in React must be a function of the current state. Therefore, when fetching data from the backend, we need to manage the various states of the fetch. These states start with the fetch loading and progress to success or error states, depending on the result. Assuming the fetch succeeds, there is then the question of how long the data is valid before it needs to be fetched again. All of these states are helpfully managed for us by React-Query.</p>
<p>To do so, we’ll first write a wrapper around React-Query’s <code>useQuery</code>, which is used to fetch data from the backend API, by adding the following to <em class="italic">frontend/src/query.ts</em>:</p>
<pre class="source-code">
import axios, { AxiosError } from "axios";
import { useContext } from "react";
import {
  QueryFunction,
  QueryFunctionContext,
  QueryKey,
  useQuery as useReactQuery,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";
 
import { AuthContext } from "src/AuthContext";
 
const MAX_FAILURES = 2;
 
export function useQuery&lt;
  TQueryFnData = unknown,
  TData = TQueryFnData,
  TQueryKey extends QueryKey = QueryKey,
&gt;(
  queryKey: TQueryKey,
  queryFn: QueryFunction&lt;TQueryFnData, TQueryKey&gt;,
  options?: UseQueryOptions&lt;TQueryFnData, AxiosError, TData, TQueryKey&gt;,
): UseQueryResult&lt;TData, AxiosError&gt; {
  const { setAuthenticated } = useContext(AuthContext);
 
  return useReactQuery&lt;TQueryFnData, AxiosError, TData, TQueryKey&gt;(
    queryKey,
    async (context: QueryFunctionContext&lt;TQueryKey&gt;) =&gt; {
      try {
        return await queryFn(context);
      } catch (error) {
        <strong class="bold">if (axios.isAxiosError(error) &amp;&amp; error.response?.status === 401) {</strong>
<strong class="bold">          setAuthenticated(false);</strong>
<strong class="bold">        }</strong>
        throw error;
      }
    },
    {
      <strong class="bold">retry: (failureCount: number, error: AxiosError) =&gt;</strong>
<strong class="bold">        failureCount &lt; MAX_FAILURES &amp;&amp;</strong>
<strong class="bold">        (!error.response || error.response.status &gt;= 500)</strong>,
      ...options,
    },
  );
}</pre>
<p>This code wraps<a id="_idIndexMarker306"/> the standard <code>useQuery</code> hook by checking any errors for a 401-response status code, as shown by the first highlighted block. As a 401-response indicates the user is unauthenticated, the local authentication state is then updated. </p>
<p>The code also provides logic to decide when the request should be retried, as shown by the second highlighted block. The logic will retry the request up to a maximum of two times if there is a network error (no response) or a server error (as indicated by a <code>5XX</code> response code). Note, therefore, that the query will be in the loading state until all three attempts have failed in the case of network failure.</p>
<p>We’ll now add the same logic to React-Query’s <code>useMutation</code>, which is used to send data to the backend API by adding the following to <em class="italic">frontend/src/query.ts</em>:</p>
<pre class="source-code">
import {
  MutationFunction,
  useMutation as useReactMutation,
  UseMutationOptions,
  UseMutationResult,
} from "@tanstack/react-query";
export function useMutation&lt;
  TData = unknown,
  TVariables = void,
  TContext = unknown,
&gt;(
  mutationFn: MutationFunction&lt;TData, TVariables&gt;,
  options?: UseMutationOptions&lt;TData, AxiosError, TVariables, TContext&gt;,
): UseMutationResult&lt;TData, AxiosError, TVariables, TContext&gt; {
  const { setAuthenticated } = useContext(AuthContext);
 
  return useReactMutation&lt;TData, AxiosError, TVariables, TContext&gt;(
    async (variables: TVariables) =&gt; {
      try {
        return await mutationFn(variables);
      } catch (error) {
        if (axios.isAxiosError(error) &amp;&amp; error.response?.status === 401) {
          setAuthenticated(false);
        }
        throw error;
      }
    },
    {
      retry: (failureCount: number, error: AxiosError) =&gt;
        failureCount &lt; MAX_FAILURES &amp;&amp;
        (!error.response || error.response.status &gt;= 500),
      ...options,
    },
  );
}</pre>
<p>This <code>useMutation</code> hook has the same authentication wrapper and retry logic as the <code>useQuery</code> hook.</p>
<p>These two new<a id="_idIndexMarker307"/> hooks can then be used in any part of the app in the same way as the standard React-Query hooks are. For example, the <code>useQuery</code> hook can be used like this:</p>
<pre class="source-code">
import { useQuery } from "src/queries";
const Component = () =&gt; {
  const { data } = useQuery(
    ["key"], 
    async () =&gt; {
      const response = await axios.get&lt;any&gt;("/");
      return response.data;
    },
  );
  return (&lt;&gt;{ data }&lt;/&gt;);
};</pre>
<p>We can now fully interact with the backend and store the appropriate state locally, which allows us to focus on giving feedback to the user. </p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor134"/>Supporting toast feedback</h1>
<p><strong class="bold">Toasts</strong> (called <strong class="bold">Snackbar</strong> in <a id="_idIndexMarker308"/>MUI) can be used to show feedback <a id="_idIndexMarker309"/>to the user that doesn’t relate to a direct element on the page. Good usage of a toast is showing<a id="_idIndexMarker310"/> an error message if a request to the backend fails, as shown in <em class="italic">Figure 4.5</em>, or showing a success message after the user changes their password, as there is no direct confirmation via the page content. A bad usage would be to report that the entered email is invalid as, in this case, the email field should show an error.</p>
<div><div><img alt="Figure 4.5: An example of a toast error " height="322" src="img/B18727_04_05.jpg" width="550"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5: An example of a toast error</p>
<p>To support toasts, we need to be able to add a toast from any component in the app and have that toast displayed. Crucially, if there are multiple toasts, they should be displayed one after another so that there is never more than one toast displayed. This is another React context use case, much like the authentication context added earlier. So, let’s start by adding the following toast context to <em class="italic">frontend/src/ToastContext.tsx</em>:</p>
<pre class="source-code">
import { AlertColor } from "@mui/material/Alert";
import React, { createContext, useState } from "react";
 
export interface IToast {
  category?: AlertColor;
  key: number;
  message: string;
}
 
interface IToastContext {
  addToast: (message: string, category: AlertColor | undefined) =&gt; void;
  setToasts: React.Dispatch&lt;React.SetStateAction&lt;IToast[]&gt;&gt;;
  toasts: IToast[];
}
 
export const ToastContext = createContext&lt;IToastContext&gt;({
  addToast: () =&gt; {},
  setToasts: () =&gt; {},
  toasts: [],
});
 
interface IProps {
  children?: React.ReactNode;
}
 
export const ToastContextProvider = ({ children }: IProps) =&gt; {
  const [toasts, setToasts] = useState&lt;IToast[]&gt;([]);
 
  const addToast = (
    message: string,
    category: AlertColor | undefined = undefined,
  ) =&gt; {
    setToasts((prev) =&gt; [
      ...prev,
      {
        category,
        key: new Date().getTime(),
        message,
      },
    ]);
  };
 
  return (
    &lt;ToastContext.Provider value={{ addToast, setToasts, toasts }}&gt;
      {children}
    &lt;/ToastContext.Provider&gt;
  );
};</pre>
<p>As the <code>ToastContextProvider</code> needs to be an ancestor of any of the components that use toasts <a id="_idIndexMarker311"/>in the app, we can add it to <em class="italic">frontend/src/App.tsx</em>:</p>
<pre class="source-code">
<strong class="bold">import { ToastContextProvider } from "src/ToastContext";</strong>
 
const App = () =&gt; {
  return (
    &lt;QueryClientProvider client={queryClient}&gt;
      &lt;AuthContextProvider&gt;
        &lt;HelmetProvider&gt;
          &lt;Helmet&gt;
            &lt;title&gt;Tozo&lt;/title&gt;
          &lt;/Helmet&gt;
          &lt;ThemeProvider&gt;
<strong class="bold">            &lt;ToastContextProvider&gt;</strong>
              &lt;Container maxWidth="md"&gt;
                &lt;Router /&gt;
              &lt;/Container&gt;
<strong class="bold">            &lt;/ToastContextProvider&gt;</strong>
          &lt;/ThemeProvider&gt; 
        &lt;/HelmetProvider&gt;
      &lt;/AuthContextProvider&gt;
    &lt;/QueryClientProvider&gt;
  );
}</pre>
<p>The <a id="_idIndexMarker312"/>highlighted lines should be added to the existing code.</p>
<p>Finally, we need to display the toasts. We can do this via a Toasts component, by adding the following to<em class="italic"> frontend/src/components/Toasts.tsx</em>:</p>
<pre class="source-code">
import Alert from "@mui/material/Alert"; 
import Snackbar from "@mui/material/Snackbar";
import React, { useContext, useEffect, useState } from "react";
 
import { ToastContext, IToast } from "src/ToastContext";
 
const Toasts = () =&gt; {
  const { toasts, setToasts } = useContext(ToastContext);
  const [open, setOpen] = useState(false);
  const [currentToast, setCurrentToast] = useState&lt;IToast | undefined&gt;();
 
  useEffect(() =&gt; {
    if (!open &amp;&amp; toasts.length) {
      setCurrentToast(toasts[0]);
      setToasts((prev) =&gt; prev.slice(1));
      setOpen(true);
    }
  }, [open, setCurrentToast, setOpen, setToasts, toasts]);
 
  const onClose = (
    event?: React.SyntheticEvent | Event, reason?: string
  ) =&gt; {
    if (reason !== "clickaway") {
      setOpen(false);
    }
  };
 
  return (
    &lt;Snackbar
      anchorOrigin={{
        horizontal: "center",
        vertical: "top",
      }}
      autoHideDuration={6000}
      key={currentToast?.key}
      onClose={onClose}
      open={open}
      TransitionProps={{
        onExited: () =&gt; setCurrentToast(undefined),
      }}
    &gt;
      &lt;Alert
        onClose={onClose}
        severity={currentToast?.category}
      &gt;
        {currentToast?.message}
      &lt;/Alert&gt;
    &lt;/Snackbar&gt;
  );
};
 
export default Toasts;</pre>
<p>The key aspect of this code is <code>useEffect</code>, which will take a toast from the list of toasts and set it as the current toast whenever there are toasts to display and there isn’t an open one. The toasts are also set to automatically close after 6 seconds, giving the user enough time to register it.</p>
<p>We now <a id="_idIndexMarker313"/>need to render the <code>Toasts</code> component in the <code>App</code> component, leaving the final version of <em class="italic">frontend/src/App.tsx</em> as the following:</p>
<pre class="source-code">
import "@fontsource/roboto/300.css";
import "@fontsource/roboto/400.css";
import "@fontsource/roboto/500.css";
import "@fontsource/roboto/700.css";
import Container from "@mui/material/Container";
import { HelmetProvider } from "react-helmet-async";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { AuthContextProvider } from "src/AuthContext";
<strong class="bold">import Toasts from "src/components/Toasts";</strong>
import Router from "src/Router";
import ThemeProvider from "src/ThemeProvider";
import { ToastContextProvider } from "src/ToastContext";
const queryClient = new QueryClient();
const App = () =&gt; (
  &lt;QueryClientProvider client={queryClient}&gt;
    &lt;AuthContextProvider&gt;
      &lt;HelmetProvider&gt;
        &lt;ThemeProvider&gt;
          &lt;ToastContextProvider&gt;
            &lt;Container maxWidth="md"&gt;
<strong class="bold">              &lt;Toasts /&gt;</strong>
              &lt;Router /&gt;
            &lt;/Container&gt;
          &lt;/ToastContextProvider&gt;
        &lt;/ThemeProvider&gt;
      &lt;/HelmetProvider&gt;
    &lt;/AuthContextProvider&gt;
  &lt;/QueryClientProvider&gt;
);
export default App;</pre>
<p>The <a id="_idIndexMarker314"/>highlighted lines are to be added to provide toasts.</p>
<p>Now, when a toast is added by any compone<a id="_idTextAnchor135"/>nt, it will show for 6 seconds as an alert snackbar at the top center of the screen.</p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor136"/>Summary</h1>
<p>In this chapter, we’ve created a styled frontend that includes routing, validated data entry, and toast feedback, and can connect to the backend API we built in the last chapter. This will allow us to add the specific pages and functionality we need for our to-do app.</p>
<p>The functionality added in this chapter can serve as the basis for any app, not just the one specific to the to-do app being developed in this book. You can take this basis and add any user interface you need for your functionality.</p>
<p>In the next chapter, we’ll build the pages and add the functionality that makes up the to-do app.</p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor137"/>Further reading</h1>
<p>If you find you can’t represent the state of your app using React-Query, it is probably time to use a full state management tool such as Redux, <a href="https://redux.js.org">https://redux.js.org</a>.</p>
</div>
</div></body></html>