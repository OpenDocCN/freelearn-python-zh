<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2.  Working with Class-Based Views and Hyperlinked APIs in Django </h1></div></div></div><p>In this chapter, we will expand the capabilities of the RESTful API that we started in the previous chapter. We will change the ORM settings to work with a more powerful PostgreSQL database and we will take advantage of the advanced features included in Django REST Framework that allow us to reduce the boilerplate code for complex APIs, such as class-based views. We will:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use model serializers to eliminate duplicate code</li><li class="listitem" style="list-style-type: disc">Work with wrappers to write API views</li><li class="listitem" style="list-style-type: disc">Use the default parsing and rendering options and move beyond JSON</li><li class="listitem" style="list-style-type: disc">Browse the API</li><li class="listitem" style="list-style-type: disc">Design a RESTful API to interact with a complex PostgreSQL database</li><li class="listitem" style="list-style-type: disc">Understand the tasks performed by each <code class="literal">HTTP</code> method</li><li class="listitem" style="list-style-type: disc">Declare relationships with the models</li><li class="listitem" style="list-style-type: disc">Manage serialization and deserialization with relationships and hyperlinks</li><li class="listitem" style="list-style-type: disc">Create class based views and use generic classes</li><li class="listitem" style="list-style-type: disc">Work with endpoints for the API</li><li class="listitem" style="list-style-type: disc">Create and retrieve related resources</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Using model serializers to eliminate duplicate code</h1></div></div></div><p>The <code class="literal">GameSerializer</code> class declares many attributes with the same names that we used in the <code class="literal">Game</code> model and repeats information, such as the types and the <code class="literal">max_length</code> values. The <code class="literal">GameSerializer</code> class is a subclass of <code class="literal">rest_framework.serializers.Serializer</code>, it declares attributes that we manually mapped to the appropriate types and overrides the <code class="literal">create</code> and <code class="literal">update</code> methods.</p><p>Now, we will create a new version of the <code class="literal">GameSerializer</code> class that will inherit from the <code class="literal">rest_framework.serializers.ModelSerializer</code> class. The <code class="literal">ModelSerializer</code> class automatically populates both set of default fields and a set of default validators. In addition, the class provides default implementations for the <code class="literal">create</code> and <code class="literal">update</code> methods.</p><div><div><h3 class="title"><a id="tip18"/>Tip</h3><p>In case you have any experience with Django Web Framework, you will notice that the <code class="literal">Serializer</code> and <code class="literal">ModelSerializer</code> classes are similar to the <code class="literal">Form</code> and <code class="literal">ModelForm</code> classes.</p></div></div><p>Now, go to the <code class="literal">gamesapi/games</code> folder and open the <code class="literal">serializers.py</code> file. Replace the code in this file with the following code, that declares the new version of the <code class="literal">GameSerializer</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_02_01</code> folder:</p><pre class="programlisting">from rest_framework import serializers 
from games.models import Game 
 
 
class GameSerializer(serializers.ModelSerializer): 
    class Meta: 
        model = Game 
        fields = ('id',  
                  'name',  
                  'release_date', 
                  'game_category',  
                  'played') 
</pre><p>The new <code class="literal">GameSerializer</code> class declares a <code class="literal">Meta</code> inner class that declares two attributes: <code class="literal">model</code> and <code class="literal">fields</code>. The <code class="literal">model</code> attribute specifies the model related to the serializer, that is, the <code class="literal">Game</code> class. The <code class="literal">fields</code> attribute specifies a tuple of string whose values indicate the field names that we want to include in the serialization from the related model.</p><p>There is no need to override either <code class="literal">create</code> or <code class="literal">update</code> methods because the generic behavior will be enough in this case. The <code class="literal">ModelSerializer</code> superclass provides implementations for both methods.</p><p>We have reduced the boilerplate code that we didn't require in the <code class="literal">GameSerializer</code> class. We just needed to specify the desired set of fields in a tuple. Now, the types related to the game fields are included only in the <code class="literal">Game</code> class.</p><div><div><h3 class="title"><a id="tip19"/>Tip</h3><p>Press <em>Ctrl + C</em> to quit Django's development server and execute the following command to start it again:</p></div></div><pre class="programlisting">
<strong>python manage.py runserver</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Working with wrappers to write API views</h1></div></div></div><p>Our code in the <code class="literal">games/views.py</code> file declared a <code class="literal">JSONResponse</code> class and two function-based views. These functions returned <code class="literal">JSONResponse</code> when it was necessary to return JSON data and a <code class="literal">django.Http.Response.HttpResponse</code> instance when the response was just of an HTTP status code.</p><p>No matter the accepted content type specified in the HTTP request header, the view functions always provide the same content in the response body-JSON. Run the following two commands to retrieve all the games with different values for the <code class="literal">Accept</code> request header-<code class="literal">text/html</code> and <code class="literal">application/json </code>:</p><pre class="programlisting">
<strong>http :8000/games/ Accept:text/html</strong>
<strong>http :8000/games/ Accept:application/json</strong>
</pre><p>The following are the equivalent curl commands:</p><pre class="programlisting">
<strong>curl -H 'Accept: text/html' -iX GET :8000/games/</strong>
<strong>curl -H 'Accept: application/json' -iX GET :8000/games/</strong>
</pre><p>The preceding commands will compose and send the following HTTP request: <code class="literal">GET http://localhost:8000/games/</code>. The first command defines the <code class="literal">text/html</code> value for the <code class="literal">Accept</code> request header. The second command defines the <code class="literal">application/json</code> value for the <code class="literal">Accept</code> request header.</p><p>You will notice that both the commands produce the same results, and therefore, the view functions don't take into account the value specified for the <code class="literal">Accept</code> request header in the HTTP requests. The header response for both commands will include the following line:</p><pre class="programlisting">
<strong>Content-Type: application/json</strong>
</pre><p>The second request specified that it will only accept <code class="literal">text/html</code> but the response included a JSON body, that is, <code class="literal">application/json</code> content. Thus, our first version of the RESTful API is not prepared to render content other from JSON. We will make some changes to enable the API to render other contents.</p><p>Whenever we have doubts about the methods supported by a resource or resource collection in a RESTful API, we can compose and send an HTTP request with the <code class="literal">OPTIONS</code> HTTP verb and the URL for the resource or resource collection. If the RESTful API implements the OPTIONS HTTP verb for a resource or resource collection, it provides a comma-separated list of HTTP verbs or methods that it supports as a value for the <code class="literal">Allow</code> header in the response. In addition, the response header will include additional information about other supported options, such as the content type it is capable of parsing from the request and the content type it is capable of rendering on the response.</p><p>For example, if we want to know the HTTP verbs that the games collection supports, we can run the following command:</p><pre class="programlisting">
<strong>http OPTIONS :8000/games/</strong>
</pre><p>The following is the equivalent curl command:</p><pre class="programlisting">
<strong>curl -iX OPTIONS :8000/games/</strong>
</pre><p>The previous command will compose and send the following HTTP request: <code class="literal">OPTIONS http://localhost:8000/games/</code>. The request will match and run the <code class="literal">views.game_list</code> function, that is, the <code class="literal">game_list</code> function declared within the <code class="literal">games/views.py</code> file. This function only runs the code when the <code class="literal">request.method</code> is equal to <code class="literal">'GET'</code> or <code class="literal">'POST'</code>. In this case, <code class="literal">request.method</code> is equal to <code class="literal">'OPTIONS'</code>, and therefore, the function won't run any code and won't return any response, specifically, it won't return an <code class="literal">HttpResponse</code> instance. As a result, we will see the following <code class="literal">Internal Server Error</code> listed in Django's development server console output:</p><pre class="programlisting">Internal Server Error: /games/ 
Traceback (most recent call last): 
  File "/Users/gaston/Projects/PythonRESTfulWebAPI/Django01/lib/python3.5/site-packages/django/core/handlers/base.py", line 158, in get_response 
    % (callback.__module__, view_name)) 
ValueError: The view games.views.game_list didn't return an HttpResponse object. It returned None instead. 
[08/Jun/2016 20:21:40] "OPTIONS /games/ HTTP/1.1" 500 49173 
</pre><p>The following lines show the header for the output that also includes a detailed HTML document with detailed information about the error because the debug mode is activated for Django. We receive a <code class="literal">500 Internal Server Error</code> status code:</p><pre class="programlisting">HTTP/1.0 500 Internal Server Error 
Content-Type: text/html 
Date: Wed, 08 Jun 2016 20:21:40 GMT 
Server: WSGIServer/0.2 CPython/3.5.1 
X-Frame-Options: SAMEORIGIN 
</pre><p>Obviously, we want to provide a more consistent API and we want to provide an accurate response when we receive a request with the <code class="literal">OPTIONS</code> verbs for either a game resource or the games collection.</p><p>If we compose and send an HTTP request with the <code class="literal">OPTIONS</code> verb for a game resource, we will see the same error and we will have a similar response because the <code class="literal">views.game_detail</code> function only runs the code when the <code class="literal">request.method</code> is equal to <code class="literal">'GET'</code>, <code class="literal">'PUT'</code>, or <code class="literal">'DELETE'</code>.</p><p>The following commands will produce the explained error when we try to see the options offered for the game resource whose id or primary key is equal to <code class="literal">3</code>. Don't forget to replace <code class="literal">3</code> with a primary key value of an existing game in your configuration:</p><pre class="programlisting">
<strong>http OPTIONS :8000/games/3/</strong>
</pre><p>The following is the equivalent curl command:</p><pre class="programlisting">
<strong>curl -iX OPTIONS :8000/games/3/</strong>
</pre><p>We just need to make a few changes in the <code class="literal">games/views.py</code> file to solve the issues we have been analyzing for our RESTful API. We will use the <code class="literal">@api_view</code> decorator, declared in <code class="literal">rest_framework.decorators</code>, for our function-based views. This decorator allows us to specify the HTTP verbs that our function can process. If the request that has to be processed by the view function has an HTTP verb that isn't included in the string list specified as the <code class="literal">http_method_names</code> argument for the <code class="literal">@api_view</code> decorator, the default behavior returns a <code class="literal">405 Method Not Allowed</code> status code. This way, we make sure that whenever we receive an HTTP verb that isn't considered within our function view, we won't generate an unexpected error as the decorator handles the response for the unsupported HTTP verbs or methods.</p><div><div><h3 class="title"><a id="tip20"/>Tip</h3><p>Under the hoods, the <code class="literal">@api_view</code> decorator is a wrapper that converts a function-based views  into a subclass of the <code class="literal">rest_framework.views.APIView</code> class. This class is the base class for all views in Django REST Framework. As we might guess, in case we want to work with class-based view, we can create classes that inherit from this class and we will have the same benefits that we analyzed for the function-based views that use the decorator. We will work with class-based views in the forthcoming examples.</p></div></div><p>In addition, as we specify a string list with the supported HTTP verbs, the decorator automatically builds the response for the <code class="literal">OPTIONS</code> HTTP verb with the supported methods and parser and render capabilities. Our actual version of the API is just capable of rendering JSON as its output. The usage of the decorator makes sure that we always receive an instance of the <code class="literal">rest_framework.request.Request</code> class in the <code class="literal">request</code> argument when Django calls our view function. The decorator also handles the <code class="literal">ParserError</code> exceptions when our function views access the <code class="literal">request.data</code> attribute that might cause parsing problems.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Using the default parsing and rendering options and move beyond JSON</h1></div></div></div><p>The <code class="literal">APIView</code> class specifies default settings for each view that we can override by specifying appropriate values in the <code class="literal">gamesapi/settings.py</code> file or by overriding the class attributes in subclasses. As previously explained, the usage of the <code class="literal">APIView</code> class under the hoods makes the decorator apply these default settings. Thus, whenever we use the decorator, the default parser classes and the default renderer classes will be associated with the function views.</p><p>By default, the value for the <code class="literal">DEFAULT_PARSER_CLASSES</code> is the following tuple of classes:</p><pre class="programlisting">( 
    'rest_framework.parsers.JSONParser', 
    'rest_framework.parsers.FormParser', 
    'rest_framework.parsers.MultiPartParser' 
) 
</pre><p>When we use the decorator, the API will be able to handle any of the following content types through the appropriate parsers when accessing the <code class="literal">request.data</code> attribute:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">application/json</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">application/x-www-form-urlencoded</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">multipart/form-data</code></li></ul></div><div><div><h3 class="title"><a id="tip21"/>Tip</h3><p>When we access the <code class="literal">request.data</code> attribute in the functions, Django REST Framework examines the value for the <code class="literal">Content-Type</code> header in the incoming request and determines the appropriate parser to parse the request content. If we use the previously explained default values, the Django REST Framework will be able to parse the previously listed content types. However, it is extremely important that the request specifies the appropriate value in the <code class="literal">Content-Type</code> header.</p></div></div><p>We have to remove the usage of the <code class="literal">rest_framework.parsers.JSONParser</code> class in the functions to make it possible to be able to work with all the configured parsers and stop working with a parser that only works with JSON. The <code class="literal">game_list</code> function executes the following two lines when <code class="literal">request.method</code> is equal to <code class="literal">'POST'</code>:</p><pre class="programlisting">game_data = JSONParser().parse(request) 
game_serializer = GameSerializer(data=game_data) 
</pre><p>We will remove the first line that uses the <code class="literal">JSONParser</code> and we will pass <code class="literal">request.data</code> as the data argument for the <code class="literal">GameSerializer</code>. The following line will replace the previous lines:</p><pre class="programlisting">game_serializer = GameSerializer(data=request.data) 
</pre><p>The <code class="literal">game_detail</code> function executes the following two lines when <code class="literal">request.method</code> is equal to <code class="literal">'PUT'</code>:</p><pre class="programlisting">game_data = JSONParser().parse(request) 
game_serializer = GameSerializer(game, data=game_data) 
</pre><p>We will make the same edits done for the code in the <code class="literal">game_list</code> function. We will remove the first line that uses the <code class="literal">JSONParser</code> and we will pass <code class="literal">request.data</code> as the data argument for the <code class="literal">GameSerializer</code>. The following line will replace the previous lines:</p><pre class="programlisting">game_serializer = GameSerializer(game, data=request.data) 
</pre><p>By default, the value for the <code class="literal">DEFAULT_RENDERER_CLASSES</code> is the following tuple of classes:</p><pre class="programlisting">( 
    'rest_framework.renderers.JSONRenderer', 
    'rest_framework.renderers.BrowsableAPIRenderer', 
) 
</pre><p>When we use the decorator, the API will be able to render the following content types in the response, through the appropriate renderers, when working with the <code class="literal">rest_framework.response.Response</code> object:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">application/json</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">text/html</code></li></ul></div><p>By default, the value for the <code class="literal">DEFAULT_CONTENT_NEGOTIATION_CLASS</code> is the <code class="literal">rest_framework.negotiation.DefaultContentNegotiation</code> class. When we use the decorator, the API will use this content negotiation class to select the appropriate renderer for the response based on the incoming request. This way, when a request specifies that it will accept <code class="literal">text/html</code>, the content negotiation class selects the <code class="literal">rest_framework.renderers.BrowsableAPIRenderer</code> to render the response and generate <code class="literal">text/html</code> instead of <code class="literal">application/json</code>.</p><p>We have to replace the usage of both the <code class="literal">JSONResponse</code> and <code class="literal">HttpResponse</code> classes in the functions with the <code class="literal">rest_framework.response.Response</code> class. The <code class="literal">Response</code> class uses the previously explained content negotiation features, renders the received data into the appropriate content type, and returns it to the client.</p><p>Now, go to the <code class="literal">gamesapi/games</code> folder and open the <code class="literal">views.py</code> file. Replace the code in this file with the following code that removes the <code class="literal">JSONResponse</code> class and uses the <code class="literal">@api_view</code> decorator for the functions and the <code class="literal">rest_framework.response.Response</code> class. The modified lines are highlighted. The code file for the sample is included in the <code class="literal">restful_python_chapter_02_02</code> folder:</p><pre class="programlisting">from rest_framework.parsers import JSONParser 
from rest_framework import status 
from rest_framework.decorators import api_view 
from rest_framework.response import Response 
from games.models import Game 
from games.serializers import GameSerializer 
 
 
<strong>@api_view(['GET', 'POST'])</strong> 
def game_list(request): 
    if request.method == 'GET': 
        games = Game.objects.all() 
        games_serializer = GameSerializer(games, many=True) 
        return Response(games_serializer.data) 
 
    elif request.method == 'POST': 
        <strong>game_serializer = GameSerializer(data=request.data)</strong> 
        if game_serializer.is_valid(): 
            game_serializer.save() 
            <strong>return Response(game_serializer.data, status=status.HTTP_201_CREATED) 
</strong>
<strong>return Response(game_serializer.errors, status=status.HTTP_400_BAD_REQUEST) 
 
 
@api_view(['GET', 'PUT', 'POST'])</strong> 
def game_detail(request, pk): 
    try: 
        game = Game.objects.get(pk=pk) 
    except Game.DoesNotExist: 
     <strong>   return Response(status=status.HTTP_404_NOT_FOUND)</strong> 
 
    if request.method == 'GET': 
        game_serializer = GameSerializer(game) 
       <strong> return Response(game_serializer.data)</strong> 
 
    elif request.method == 'PUT': 
      <strong>  game_serializer = GameSerializer(game, data=request.data)</strong> 
        if game_serializer.is_valid(): 
            game_serializer.save() 
            <strong>return Response(game_serializer.data) 
        return Response(game_serializer.errors, status=status.HTTP_400_BAD_REQUEST)</strong> 
 
    elif request.method == 'DELETE': 
        game.delete() 
    <strong>    return Response(status=status.HTTP_204_NO_CONTENT) 
</strong>
</pre><p>After you save the preceding changes, run the following command:</p><pre class="programlisting">
<strong>http OPTIONS :8000/games/</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl -iX OPTIONS :8000/games/</strong>
</pre><p>The previous command will compose and send the following HTTP request: <code class="literal">OPTIONS http://localhost:8000/games/</code>. The request will match and run the <code class="literal">views.game_list</code> function, that is, the <code class="literal">game_list</code> function declared within the <code class="literal">games/views.py</code> file. We added the <code class="literal">@api_view</code> decorator to this function, and therefore, it is now capable of determining the supported HTTP verbs, parsing, and rendering capabilities. The following lines show the output:</p><pre class="programlisting">
<strong>HTTP/1.0 200 OK</strong>
<strong>Allow: GET, POST, OPTIONS</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Thu, 09 Jun 2016 20:24:31 GMT</strong>
<strong>Server: WSGIServer/0.2 CPython/3.5.1</strong>
<strong>Vary: Accept, Cookie</strong>
<strong>X-Frame-Options: SAMEORIGIN</strong>
<strong>{</strong>
<strong>    "description": "", </strong>
<strong>    "name": "Game List", </strong>
<strong>    "parses": [</strong>
<strong>        "application/json", </strong>
<strong>        "application/x-www-form-urlencoded", </strong>
<strong>        "multipart/form-data"</strong>
<strong>    ], </strong>
<strong>    "renders": [</strong>
<strong>        "application/json", </strong>
<strong>        "text/html"</strong>
<strong>    ]</strong>
<strong>}</strong>
</pre><p>The response header includes an <code class="literal">Allow</code> key with a comma-separated list of HTTP verbs supported by the resource collection as its value: <code class="literal">GET, POST, OPTIONS</code>. As our request didn't specify the allowed content type, the function rendered the response with the default <code class="literal">application/json</code> content type. The response body specifies the <code class="literal">Content-type</code> that the resource collection parses and the <code class="literal">Content-type</code> that it renders.</p><p>Run the following command to compose and send an HTTP request with the <code class="literal">OPTIONS</code> verb for a game resource. Don't forget to replace <code class="literal">3</code> with a primary key value of an existing game in your configuration.</p><pre class="programlisting">
<strong>http OPTIONS :8000/games/3/</strong>
</pre><p>The following is the equivalent curl command:</p><pre class="programlisting">
<strong>curl -iX OPTIONS :8000/games/3/</strong>
</pre><p>The preceding command will compose and send the following HTTP request: <code class="literal">OPTIONS http://localhost:8000/games/3/</code>. The request will match and run the <code class="literal">views.game_detail</code> function, that is, the <code class="literal">game_detail</code> function declared within the <code class="literal">games/views.py</code> file. We also added the <code class="literal">@api_view</code> decorator to this function, and therefore, it is capable of determining the supported HTTP verbs, parsing, and rendering capabilities. The following lines show the output:</p><pre class="programlisting">
<strong>HTTP/1.0 200 OK</strong>
<strong>Allow: GET, POST, OPTIONS, PUT</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Thu, 09 Jun 2016 21:35:58 GMT</strong>
<strong>Server: WSGIServer/0.2 CPython/3.5.1</strong>
<strong>Vary: Accept, Cookie</strong>
<strong>X-Frame-Options: SAMEORIGIN</strong>
<strong>{</strong>
<strong>    "description": "", </strong>
<strong>    "name": "Game Detail", </strong>
<strong>    "parses": [</strong>
<strong>        "application/json", </strong>
<strong>        "application/x-www-form-urlencoded", </strong>
<strong>        "multipart/form-data"</strong>
<strong>    ], </strong>
<strong>    "renders": [</strong>
<strong>        "application/json", </strong>
<strong>        "text/html"</strong>
<strong>    ]</strong>
<strong>}</strong>
</pre><p>The response header includes an <code class="literal">Allow</code> key with a comma-separated list of HTTP verbs supported by the resource as its value: <code class="literal">GET, POST, OPTIONS, PUT</code>. The response body specifies the content-type that the resource parses and the content-type that it renders, with the same contents received in the previous <code class="literal">OPTIONS</code> request applied to a resource collection, that is, to a games collection.</p><p>In <a class="link" href="ch01.html" title="Chapter 1. Developing RESTful APIs with Django">Chapter 1</a>, <em>Developing RESTful APIs with Django</em>, when we composed and sent POST and PUT commands, we had to use the use the <code class="literal">-H "Content-Type: application/json"</code> option to tell curl to send the data specified after the <code class="literal">-d</code> option as <code class="literal">application/json</code> instead of the default <code class="literal">application/x-www-form-urlencoded</code>. Now, in addition to <code class="literal">application/json</code>, our API is capable of parsing <code class="literal">application/x-www-form-urlencoded</code> and <code class="literal">multipart/form-data</code> data specified in the <code class="literal">POST</code> and <code class="literal">PUT</code> requests. Thus, we can compose and send a POST command that sends the data as <code class="literal">application/x-www-form-urlencoded</code>, with the changes made to our API.</p><p>We will compose and send an HTTP request to create a new game. In this case, we will use the -f option for HTTPie, that serializes data items from the command line as form fields and sets the <code class="literal">Content-Type</code> header key to the <code class="literal">application/x-www-form-urlencoded</code> value:</p><pre class="programlisting">
<strong>http -f POST :8000/games/ name='Toy Story 4' game_category='3D RPG'
    played=false release_date='2016-05-18T03:02:00.776594Z'</strong>
</pre><p>The following is the equivalent curl command. Note that we don't use the <code class="literal">-H</code> option and curl will send the data in the default <code class="literal">application/x-www-form-urlencoded</code>:</p><pre class="programlisting">
<strong>curl -iX POST -d '{"name":"Toy Story 4", "game_category":"3D RPG", "played":
    "false", "release_date": "2016-05-18T03:02:00.776594Z"}' :8000/games/</strong>
</pre><p>The previous commands will compose and send the following HTTP request: <code class="literal">POST http://localhost:8000/games/</code> with the <code class="literal">Content-Type</code> header key set to the <code class="literal">application/x-www-form-urlencoded</code> value and the following data:</p><pre class="programlisting">name=Toy+Story+4&amp;game_category=3D+RPG&amp;played=false&amp;release_date=2016-05-18T03%3A02%3A00.776594Z 
</pre><p>The request specifies <code class="literal">/games/</code>, and therefore, it will match <code class="literal">'^games/$'</code> and run the <code class="literal">views.game_list</code> function, that is, the updated <code class="literal">game_detail</code> function declared within the <code class="literal">games/views.py</code> file. As the HTTP verb for the request is <code class="literal">POST</code>, the <code class="literal">request.method</code> property is equal to <code class="literal">'POST'</code>, and therefore, the function will execute the code that creates a <code class="literal">GameSerializer</code> instance and passes <code class="literal">request.data</code> as the data argument for its creation. The <code class="literal">rest_framework.parsers.FormParser</code> class will parse the data received in the request, the code creates a new <code class="literal">Game</code> and, if the data is valid, it saves the new <code class="literal">Game</code>. If the new <code class="literal">Game</code> was successfully persisted in the database, the function returns an <code class="literal">HTTP 201 Created</code> status code and the recently persisted <code class="literal">Game</code> serialized to JSON in the response body. The following lines show an example response for the HTTP request, with the new <code class="literal">Game</code> object in the JSON response:</p><pre class="programlisting">
<strong>HTTP/1.0 201 Created</strong>
<strong>Allow: OPTIONS, POST, GET</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Fri, 10 Jun 2016 20:38:40 GMT</strong>
<strong>Server: WSGIServer/0.2 CPython/3.5.1</strong>
<strong>Vary: Accept, Cookie</strong>
<strong>X-Frame-Options: SAMEORIGIN</strong>
<strong>{</strong>
<strong>    "game_category": "3D RPG", </strong>
<strong>    "id": 20, </strong>
<strong>    "name": "Toy Story 4", </strong>
<strong>    "played": false, </strong>
<strong>    "release_date": "2016-05-18T03:02:00.776594Z"</strong>
<strong>}</strong>
</pre><p>We can run the following command after we make the changes in the code, to see what happens when we compose and send an HTTP request with an HTTP verb that is not supported:</p><pre class="programlisting">
<strong>http PUT :8000/games/</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl -iX PUT :8000/games/</strong>
</pre><p>The previous command will compose and send the following HTTP request: <code class="literal">PUT http://localhost:8000/games/</code>. The request will match and try to run the <code class="literal">views.game_list</code> function, that is, the <code class="literal">game_list</code> function declared within the <code class="literal">games/views.py</code> file. The <code class="literal">@api_view</code> decorator we added to this function doesn't include <code class="literal">'PUT'</code> in the string list with the allowed HTTP verbs, and therefore, the default behavior returns a <code class="literal">405 Method Not Allowed</code> status code. The following lines show the output along with the response from the previous request. A JSON content provides a <code class="literal">detail</code> key with a string value, which indicates that the <code class="literal">PUT</code> method is not allowed:</p><pre class="programlisting">
<strong>HTTP/1.0 405 Method Not Allowed</strong>
<strong>Allow: GET, OPTIONS, POST</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Sat, 11 Jun 2016 00:49:30 GMT</strong>
<strong>Server: WSGIServer/0.2 CPython/3.5.1</strong>
<strong>Vary: Accept, Cookie</strong>
<strong>X-Frame-Options: SAMEORIGIN</strong>
<strong>{</strong>
<strong>    "detail": "Method "PUT" not allowed."</strong>
<strong>}</strong>
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Browsing the API</h1></div></div></div><p>With the recent edits, we made it possible for our API to use the default content renderers configured in Django REST Framework, and therefore, our API is capable of rendering the <code class="literal">text/html</code> content. We can take advantage of the browsable API, a feature included in Django REST Framework that generates human-friendly HTML output for each resource whenever the request specifies <code class="literal">text/html</code> as the value for the <code class="literal">Content-type</code> key in the request header.</p><p>Whenever we enter a URL for an API resource in a web browser, the browser will require an HTML response, and therefore, Django REST Framework will provide an HTML response built with Bootstrap (<a class="ulink" href="http://getbootstrap.com">http://getbootstrap.com</a>). This response will include a section that displays the resource content in JSON, buttons to perform different requests, and forms to submit data to the resources. As everything in Django REST Framework, we can customize the templates and themes used to generate the browsable API.</p><p>Open a web browser and enter <code class="literal">http://localhost:8000/games/</code>. The browsable API will compose and send a <code class="literal">GET</code> request to <code class="literal">/games/</code> and will display the results of its execution, that is, the headers and the JSON games list. The following screenshot shows the rendered web page after entering the URL in a web browser with the resource description-<strong>Game List</strong>:</p><p>
</p><div><img src="img/image_02_001.jpg" alt="Browsing the API"/></div><p>
</p><div><div><h3 class="title"><a id="tip22"/>Tip</h3><p>If you decide to browse the API in a web browser running on another computer or device connected to the LAN, remember that you have to use the development computer's assigned IP address instead of <code class="literal">localhost</code>. For example, if the computer's assigned IPv4 IP address is <code class="literal">192.168.1.106</code>, instead of <code class="literal">http://localhost:8000/games/</code>, you should use <code class="literal">http://192.168.1.106:8000/games/</code>. Of course, you can also use the host name instead of the IP address.</p></div></div><p>The browsable API uses the information about the allowed methods for a resource to provide us with buttons to run these methods. At the right-hand side of the resource description, the browsable API shows an <strong>OPTIONS</strong> button and a <strong>GET</strong> drop-down button. The <strong>OPTIONS</strong> button allows us to make an <code class="literal">OPTIONS</code> request to <code class="literal">/games/</code>, that is, to the current resource. The <strong>GET</strong> drop-down button allows us to make a <code class="literal">GET</code> request to <code class="literal">/games/</code> again. If we click on or tap the down arrow, we can select the <strong>json</strong> option and the browsable API will display the raw JSON result of a <code class="literal">GET</code> request to <code class="literal">/games/</code> without the headers.</p><p>At the bottom of the rendered web page, the browsable API provides us some control to generate a <code class="literal">POST</code> request to <code class="literal">/games/</code>. The <strong>Media type</strong> dropdown allows us to select between the configured supported parsers for our API:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">application/json</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">application/x-www-form-urlencoded</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">multipart/form-data</code></li></ul></div><p>The <strong>Content</strong> textbox allows us to specify the data to be sent to the <code class="literal">POST</code> request formatted as specified in the <strong>Media type</strong> dropdown. Select <strong>application/json</strong> in the <strong>Media type</strong> dropdown and enter the following JSON content in the <strong>Content</strong> textbox:</p><pre class="programlisting">{ 
    "name": "Chuzzle 2", 
    "release_date": "2016-05-18T03:02:00.776594Z", 
    "game_category": "2D mobile", 
    "played": false 
} 
</pre><p>Click or tap on <code class="literal">POST</code>. The browsable API will compose and send a <code class="literal">POST</code> request to <code class="literal">/games/</code> with the previously specified data as JSON, and we will see the results of the call in the web browser.</p><p>The following screenshot shows a web browser displaying the HTTP status code <code class="literal">201 Created</code> in the response and the previously explained dropdown and textbox with the <code class="literal">POST</code> button to allow us to continue composing and sending <code class="literal">POST</code> requests to <code class="literal">/games/</code>:</p><p>
</p><div><img src="img/image_02_002.jpg" alt="Browsing the API"/></div><p>
</p><p>Now, enter the URL for an existing game resource, such as <code class="literal">http://localhost:8000/games/2/</code>. Make sure you replace 2 with the id or primary key of an existing game in the previously rendered <strong>Games List</strong>. The browsable API will compose and send a <code class="literal">GET</code> request to <code class="literal">/games/2/</code> and will display the results of its execution, that is, the headers and the JSON data for the game.</p><p>The following screenshot shows the rendered web page after entering the URL in a web browser with the resource description-<strong>Game Detail:</strong>
</p><p>
</p><div><img src="img/image_02_003.jpg" alt="Browsing the API"/></div><p>
</p><div><div><h3 class="title"><a id="tip23"/>Tip</h3><p>The browsable API feature allows us to easily check how the API works and to compose and send HTTP requests with different methods to any web browser that has access to our LAN. We will take advantage of the additional features included in the browsable API, such as HTML forms that allow us to easily create new resources, later, after we build a new RESTful API with Python and Django REST Framework.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Designing a RESTful API to interact with a complex PostgreSQL database</h1></div></div></div><p>So far, our RESTful API has performed CRUD operations on a single database table. Now, we want to create a more complex RESTful API with Django REST Framework to interact with a complex database model that has to allow us to register player scores for played games that are grouped into game categories. In our previous RESTful API, we used a string field to specify the game category for a game. In this case, we want to be able to easily retrieve all the games that belong to a specific game category, and therefore, we will have a relationship between a game and a game category.</p><p>We should be able to perform CRUD operations on different related resources and resource collections. The following list enumerates the resources and the model names that we will use to represent them in Django REST Framework:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Game categories (<code class="literal">GameCategory</code> model)</li><li class="listitem" style="list-style-type: disc">Games (<code class="literal">Game</code> model)</li><li class="listitem" style="list-style-type: disc">Players (<code class="literal">Player</code> model)</li><li class="listitem" style="list-style-type: disc">Player scores (<code class="literal">PlayerScore</code> model)</li></ul></div><p>The game category (<code class="literal">GameCategory</code>) just requires a name, and we need the following data for a game (<code class="literal">Game</code>):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A foreign key to a game category (<code class="literal">GameCategory</code>)</li><li class="listitem" style="list-style-type: disc">A name</li><li class="listitem" style="list-style-type: disc">A release date</li><li class="listitem" style="list-style-type: disc">A bool value indicating whether the game was played at least once by a player or not</li><li class="listitem" style="list-style-type: disc">A timestamp with the date and time in which the game was inserted in the database</li></ul></div><p>We need the following data for a player (<code class="literal">Player</code>):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A gender value</li><li class="listitem" style="list-style-type: disc">A name</li><li class="listitem" style="list-style-type: disc">A timestamp with the date and time in which the player was inserted in the database</li></ul></div><p>We need the following data for the score achieved by a player (<code class="literal">PlayerScore</code>):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A foreign key to a player (<code class="literal">Player</code>)</li><li class="listitem" style="list-style-type: disc">A foreign key to a game (<code class="literal">Game</code>)</li><li class="listitem" style="list-style-type: disc">A score value</li><li class="listitem" style="list-style-type: disc">A date in which the score value was achieved by the player</li></ul></div><div><div><h3 class="title"><a id="tip24"/>Tip</h3><p>We will take advantage of all the resources and their relationships to analyze different options that Django REST Framework provides us when working with related resources. Instead of building an API that uses the same configuration to display related resources, we will use diverse configurations that will allow us to select the most appropriate options based on the particular requirements of the APIs that we are developing.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Understanding the tasks performed by each HTTP method</h1></div></div></div><p>The following table shows the HTTP verbs, the scope, and the semantics for the methods that our new API must support. Each method is composed by an HTTP verb and a scope and all the methods have well-defined meanings for all the resources and collections.</p><div><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p>
<strong>HTTP verb</strong>
</p>
</td><td>
<p>
<strong>Scope</strong>
</p>
</td><td>
<p>
<strong>Semantics</strong>
</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Collection of game categories</p>
</td><td>
<p>Retrieve all the stored game categories in the collection, sorted by their name in ascending order. Each game category must include a list of URLs for each game resource that belongs to the category.</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Game category</p>
</td><td>
<p>Retrieve a single game category. The game category must include a list of URLs for each game resource that belongs to the category.</p>
</td></tr><tr><td>
<p>
<code class="literal">POST</code>
</p>
</td><td>
<p>Collection of game categories</p>
</td><td>
<p>Create a new game category in the collection.</p>
</td></tr><tr><td>
<p>
<code class="literal">PUT</code>
</p>
</td><td>
<p>Game category</p>
</td><td>
<p>Update an existing game category.</p>
</td></tr><tr><td>
<p>
<code class="literal">PATCH</code>
</p>
</td><td>
<p>Game category</p>
</td><td>
<p>Update one or more fields of an existing game category.</p>
</td></tr><tr><td>
<p>
<code class="literal">DELETE</code>
</p>
</td><td>
<p>
</p><p>Game category</p><p>
</p>
</td><td>
<p>Delete an existing game category.</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Collection of games</p>
</td><td>
<p>Retrieve all the stored games in the collection, sorted by their name in ascending order. Each game must include its game category description.</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Game</p>
</td><td>
<p>Retrieve a single game. The game must include its game category description.</p>
</td></tr><tr><td>
<p>
<code class="literal">POST</code>
</p>
</td><td>
<p>Collection of games</p>
</td><td>
<p>Create a new game in the collection.</p>
</td></tr><tr><td>
<p>
<code class="literal">PUT</code>
</p>
</td><td>
<p>Game category</p>
</td><td>
<p>Update an existing game.</p>
</td></tr><tr><td>
<p>
<code class="literal">PATCH</code>
</p>
</td><td>
<p>Game category</p>
</td><td>
<p>Update one or more fields of an existing game.</p>
</td></tr><tr><td>
<p>
<code class="literal">DELETE</code>
</p>
</td><td>
<p>Game category</p>
</td><td>
<p>Delete an existing game.</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Collection of players</p>
</td><td>
<p>Retrieve all the stored players in the collection, sorted by their name in ascending order. Each player must include a list of the registered scores, sorted by score in descending order. The list must include all the details for the score achieved by the player and its related game.</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Player</p>
</td><td>
<p>Retrieve a single player. The player must include a list of the registered scores, sorted by score in descending order. The list must include all the details for the score achieved by the player and its related game.</p>
</td></tr><tr><td>
<p>
<code class="literal">POST</code>
</p>
</td><td>
<p>Collection of players</p>
</td><td>
<p>Create a new player in the collection.</p>
</td></tr><tr><td>
<p>
<code class="literal">PUT</code>
</p>
</td><td>
<p>Player</p>
</td><td>
<p>Update an existing player.</p>
</td></tr><tr><td>
<p>
<code class="literal">PATCH</code>
</p>
</td><td>
<p>Player</p>
</td><td>
<p>Update one or more fields of an existing player.</p>
</td></tr><tr><td>
<p>
<code class="literal">DELETE</code>
</p>
</td><td>
<p>Player</p>
</td><td>
<p>Delete an existing player.</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Collection of scores</p>
</td><td>
<p>Retrieve all the stored scores in the collection, sorted by score in descending order. Each score must include the player's name that achieved the score and the game's name.</p>
</td></tr><tr><td>
<p>
<code class="literal">GET</code>
</p>
</td><td>
<p>Score</p>
</td><td>
<p>Retrieve a single score. The score must include the player's name that achieved the score and the game's name.</p>
</td></tr><tr><td>
<p>
<code class="literal">POST</code>
</p>
</td><td>
<p>Collection of scores</p>
</td><td>
<p>Create a new score in the collection. The score must be related to an existing player and an existing game.</p>
</td></tr><tr><td>
<p>
<code class="literal">PUT</code>
</p>
</td><td>
<p>
</p><p>Score</p><p>
</p>
</td><td>
<p>Update an existing score.</p>
</td></tr><tr><td>
<p>
<code class="literal">PATCH</code>
</p>
</td><td>
<p>Score</p>
</td><td>
<p>Update one or more fields of an existing score.</p>
</td></tr><tr><td>
<p>
<code class="literal">DELETE</code>
</p>
</td><td>
<p>Score</p>
</td><td>
<p>Delete an existing score.</p>
</td></tr></tbody></table></div><p>We want our API to be able to update a single field for an existing resource, and therefore, we will provide an implementation for the <code class="literal">PATCH</code> method. The <code class="literal">PUT</code> method is meant to replace an entire resource and the <code class="literal">PATCH</code> method is meant to apply a delta to an existing resource. In addition, our RESTful API must support the <code class="literal">OPTIONS</code> method for all the resources and collection of resources.</p><p>We don't want to spend time choosing and configuring the most appropriate ORM, as seen in our previous API; we just want to finish the RESTful API as soon as possible to start interacting with it. We will use all the features and reusable elements included in Django REST Framework to make it easy to build our API. We will work with a PostgreSQL database. However, in case you don't want to spend time installing PostgreSQL, you can skip the changes we make in Django REST Framework ORM configuration and continue working with the default SQLite database.</p><p>In the preceding table, we have a huge number of methods and scopes. The following list enumerates the URIs for each scope mentioned in the table, where <code class="literal">{id}</code> has to be replaced with the numeric id or the primary key of the resource:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Collection of game categories</strong>: <code class="literal">/game-categories/</code></li><li class="listitem" style="list-style-type: disc"><strong>Game category</strong>: <code class="literal">/game-category/{id}/</code></li><li class="listitem" style="list-style-type: disc"><strong>Collection of games</strong>: <code class="literal">/games/</code></li><li class="listitem" style="list-style-type: disc"><strong>Game</strong>: <code class="literal">/game/{id}/</code></li><li class="listitem" style="list-style-type: disc"><strong>Collection of players</strong>: <code class="literal">/players/</code></li><li class="listitem" style="list-style-type: disc"><strong>Player</strong>: <code class="literal">/player/{id}/</code></li><li class="listitem" style="list-style-type: disc"><strong>Collection of scores</strong>: <code class="literal">/player-scores/</code></li><li class="listitem" style="list-style-type: disc"><strong>Score</strong>: <code class="literal">/player-score/{id}/</code></li></ul></div><p>Let's consider that <code class="literal">http://localhost:8000/</code> is the URL for the API running on the Django development server. We have to compose and send an HTTP request with the following HTTP verb (<code class="literal">GET</code>) and request URL (<code class="literal">http://localhost:8000/game-categories/</code>) to retrieve all the stored game categories in the collection:</p><pre class="programlisting">GET http://localhost:8000/game-categories/ 
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Declaring relationships with the models</h1></div></div></div><p>Make sure you quit the Django's development server. Remember that you just need to press <em>
<strong>Ctrl</strong>
</em> + <em>
<strong>C</strong>
</em> in the terminal or command-prompt window in which it is running. Now, we will create the models that we are going to use to represent and persist the game categories, games, players and scores, and their relationships. Open the <code class="literal">games/models.py</code> file and replace its contents with the following code. The lines that declare fields related to other models are highlighted in the code listing. The code file for the sample is included in the <code class="literal">restful_python_chapter_02_03</code> folder.</p><pre class="programlisting">from django.db import models 
 
 
class GameCategory(models.Model): 
    name = models.CharField(max_length=200) 
 
    class Meta: 
        ordering = ('name',) 
 
    def __str__(self): 
        return self.name 
 
 
class Game(models.Model): 
    created = models.DateTimeField(auto_now_add=True) 
    name = models.CharField(max_length=200) 
  <strong>  game_category = models.ForeignKey( 
        GameCategory,  
        related_name='games',  
        on_delete=models.CASCADE)</strong> 
    release_date = models.DateTimeField() 
    played = models.BooleanField(default=False) 
 
    class Meta: 
        ordering = ('name',) 
 
    def __str__(self): 
        return self.name 
 
 
class Player(models.Model): 
    MALE = 'M' 
    FEMALE = 'F' 
    GENDER_CHOICES = ( 
         (MALE, 'Male'), 
         (FEMALE, 'Female'), 
    ) 
    created = models.DateTimeField(auto_now_add=True) 
    name = models.CharField(max_length=50, blank=False, default='') 
    gender = models.CharField( 
        max_length=2, 
        choices=GENDER_CHOICES, 
        default=MALE, 
    ) 
 
    class Meta: 
        ordering = ('name',) 
 
    def __str__(self): 
        return self.name 
 
 
class PlayerScore(models.Model): 
    <strong>player = models.ForeignKey( 
        Player,  
        related_name='scores',  
        on_delete=models.CASCADE)</strong> 
    game = models.ForeignKey( 
        Game,  
        on_delete=models.CASCADE) 
    score = models.IntegerField() 
    score_date = models.DateTimeField() 
 
    class Meta: 
        # Order by score descending 
        ordering = ('-score',) 
</pre><p>The preceding code declares the following four models, specifically four classes as subclasses of the <code class="literal">django.db.models.Model</code> class:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">GameCategory</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Game</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Player</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">PlayerScore</code></li></ul></div><p>Django automatically adds an auto-increment integer primary key column named <code class="literal">id</code> when it creates the database table related to each model. We specified the field types, maximum lengths, and defaults for many attributes. Each class declares a <code class="literal">Meta</code> inner class that declares an ordering attribute. The <code class="literal">Meta</code> inner class declared within the <code class="literal">PlayerScore</code> class specifies <code class="literal">'-score'</code> as the value of the <code class="literal">ordering</code> tuple, with a dash as a prefix of the field name and ordered by <code class="literal">score</code> in descending order, instead of the default ascending order.</p><p>The <code class="literal">GameCategory</code>, <code class="literal">Game</code>, and <code class="literal">Player</code> classes declare the <code class="literal">__str__</code> method that returns the contents of the <code class="literal">name</code> attribute that provides the name or title for each of these models. So, Django will call this method whenever it has to provide a human-readable representation for the model.</p><p>The <code class="literal">Game</code> model declares the <code class="literal">game_category</code> field with the following line:</p><pre class="programlisting">game_category = models.ForeignKey( 
    GameCategory,  
    related_name='games',  
    on_delete=models.CASCADE) 
</pre><p>The preceding line uses the django.db.models.ForeignKey class to provide a many-to-one relationship to the GameCategory model. The 'games' value specified for the related_name argument creates a backwards relation from the GameCategory model to the Game model. This value indicates the name to be used for the relation from the related GameCategory object back to a Game object. Now, we will be able to access all the games that belong to a specific game category. Whenever we delete a game category, we want all the games that belong to this category to be deleted too, and therefore, we specified the models.CASCADE value for the on_delete argument.</p><p>The <code class="literal">PlayerScore</code> model declares the <code class="literal">player</code> field with the following line:</p><pre class="programlisting">player = models.ForeignKey( 
    Player,  
    related_name='scores',  
    on_delete=models.CASCADE) 
</pre><p>The preceding line uses the django.db.models.ForeignKey class to provide a many-to-one relationship to the Player model. The 'scores' value specified for the related_name argument creates a backwards relation from the Player model to the PlayerScore model. This value indicates the name to be used for the relation from the related Player object back to a PlayerScore object. Now, we will be able to access all the scores archive by a specific player. Whenever we delete a player, we want all the scores achieved by this player to be deleted too, and therefore, we specified the models.CASCADE value for the on_delete argument.</p><p>The <code class="literal">PlayerScore</code> model declares the <code class="literal">game</code> field with the following line:</p><pre class="programlisting">game = models.ForeignKey( 
    Game,  
    on_delete=models.CASCADE) 
</pre><p>The preceding line uses the django.db.models.ForeignKey class to provide a many-to-one relationship to the Game model. In this case, we don't create a backwards relation because we don't need it. Thus, we don't specify a value for the related_name argument. Whenever we delete a game, we want all the registered scores for this game to be deleted too, and therefore, we specified the models.CASCADE value for the on_delete argument.</p><p>In case you created a new virtual environment to work with this example or you downloaded the sample code for the book, you don't need to delete any existing database. However, in case you are making changes to the code for our previous API example, you have to delete the gamesapi/db.sqlite3 file and the games/migrations folder.</p><p>Then, it is necessary to create the initial migration for the new models we recently coded. We just need to run the following Python scripts and we will also synchronize the database for the first time. As we learned from our previous example API, by default, Django uses an SQLite database. In this example, we will be working with a PostgreSQL database. However, in case you want to use SQLite, you can skip the steps related to PostgreSQL, its configuration in Django, and jump to the migrations generation command.</p><p>You will have to download and install a PostgreSQL database in case you aren't already running it in your computer or in a development server. You can download and install this database management system from its web page-<a class="ulink" href="http://www.postgresql.org">http://www.postgresql.org</a>. In case you are working with macOS, <code class="literal">Postgres.app</code> provides an easy way to install and use PostgreSQL on this operating system-<a class="ulink" href="http://postgresapp.com">http://postgresapp.com</a>.</p><div><div><h3 class="title"><a id="tip25"/>Tip</h3><p>You have to make sure that the PostgreSQL bin folder is included in the <code class="literal">PATH</code> environmental variable. You should be able to execute the <code class="literal">psql</code> command-line utility from your current terminal or command prompt. In case the folder isn't included in the PATH, you will receive an error indicating that the <code class="literal">pg_config</code> file cannot be found when trying to install the <code class="literal">psycopg2</code> package. In addition, you will have to use the full path to each of the PostgreSQL command-line tools we will use in the subsequent steps.</p></div></div><p>We will use the PostgreSQL command-line tools to create a new database named <code class="literal">games</code>. In case you already have a PostgreSQL database with this name, make sure that you use another name in all the commands and configurations. You can perform the same task with any PostgreSQL GUI tool. In case you are developing on Linux, it is necessary to run the commands as the <code class="literal">postgres</code> user. Run the following command in macOS or Windows to create a new database named <code class="literal">games</code>. Note that the command won't produce any output:</p><pre class="programlisting">
<strong>createdb games</strong>
</pre><p>In Linux, run the following command to use the <code class="literal">postgres</code> user:</p><pre class="programlisting">
<strong>sudo -u postgres createdb games</strong>
</pre><p>Now, we will use the <code class="literal">psql</code> command-line tool to run some SQL statements to create a specific user that we will use in Django and assign the necessary roles for it. In macOS or Windows, run the following command to launch <code class="literal">psql</code>:</p><pre class="programlisting">
<strong>psql</strong>
</pre><p>In macOS, you might need to run the following command to launch psql with the <code class="literal">postgres</code> in case the previous command doesn't work, as it will depend on the way in which you installed PostgreSQL:</p><pre class="programlisting">
<strong>sudo -u postgres psql</strong>
</pre><p>
In Linux, run the following command to use the <code class="literal">postgres</code> user.</p><pre class="programlisting">
<strong>sudo -u psql</strong>
</pre><p>Then, run the following SQL statements and finally enter <code class="literal">\q</code> to exit the psql command-line tool. Replace <code class="literal">user_name</code> with your desired user name to use in the new database and password with your chosen password. We will use the username and password in the Django configuration. You don't need to run the steps if you are already working with a specific user in PostgreSQL and you have already granted privileges to the database for the user:</p><pre class="programlisting">
<strong>CREATE ROLE user_name WITH LOGIN PASSWORD 'password';</strong>
<strong>GRANT ALL PRIVILEGES ON DATABASE games TO user_name;</strong>
<strong>ALTER USER user_name CREATEDB;</strong>
<strong>\q</strong>
</pre><p>The default SQLite database engine and the database file name are specified in the <code class="literal">gamesapi/settings.py</code> Python file. In case you decide to work with PostgreSQL instead of SQLite for this example, replace the declaration of the <code class="literal">DATABASES</code> dictionary with the following lines. The nested dictionary maps the database named <code class="literal">default</code> with the <code class="literal">django.db.backends.postgresql</code> database engine, the desired database name, and its settings. In this case, we will create a database named <code class="literal">games</code>. Make sure you specify the desired database name in the value for the <code class="literal">'NAME'</code> key and that you configure the user, password, host, and port based on your PostgreSQL configuration. In case you followed the previous steps, use the settings specified in these steps:</p><pre class="programlisting">DATABASES = { 
    'default': { 
        'ENGINE': 'django.db.backends.postgresql', 
        # Replace games with your desired database name 
        'NAME': 'games', 
        # Replace username with your desired user name 
        'USER': 'user_name', 
        # Replace password with your desired password 
        'PASSWORD': 'password', 
        # Replace 127.0.0.1 with the PostgreSQL host 
        'HOST': '127.0.0.1', 
        # Replace 5432 with the PostgreSQL configured port 
        # in case you aren't using the default port 
        'PORT': '5432', 
    } 
} 
</pre><p>In case you decided to use PostgreSQL, after making the preceding changes, it is necessary to install the Psycopg 2 package (psycopg2). This package is a Python-PostgreSQL Database Adapter and Django uses it to interact with a PostgreSQL database.</p><p>In macOS installations, we have to make sure that the PostgreSQL bin folder is included in the <code class="literal">PATH</code> environmental variable. For example, in case the path to the bin folder is <code class="literal">/Applications/Postgres.app/Contents/Versions/latest/bin</code>, we must execute the following command to add this folder to the <code class="literal">PATH</code> environmental variable:</p><pre class="programlisting">
<strong>export PATH=$PATH:/Applications/Postgres.app/Contents/Versions/latest/bin</strong>
</pre><p>Once we have made sure that the PostgreSQL <code class="literal">bin</code> folder is included in the PATH environmental variable, we just need to run the following command to install this package:</p><pre class="programlisting">
<strong>pip install psycopg2</strong>
</pre><p>The last lines of the output will indicate that the <code class="literal">psycopg2</code> package has been successfully installed:</p><pre class="programlisting">
<strong>Collecting psycopg2</strong>
<strong>Installing collected packages: psycopg2</strong>
<strong>Running setup.py install for psycopg2</strong>
<strong>Successfully installed psycopg2-2.6.2</strong>
</pre><p>Now, run the following Python script to generate the migrations that will allow us to synchronize the database for the first time:</p><pre class="programlisting">
<strong>python manage.py makemigrations games</strong>
</pre><p>The following lines show the output generated after running the previous command:</p><pre class="programlisting">
<strong>Migrations for 'games':</strong>
<strong>  0001_initial.py:</strong>
<strong>    - Create model Game</strong>
<strong>    - Create model GameCategory</strong>
<strong>    - Create model Player</strong>
<strong>    - Create model PlayerScore</strong>
<strong>    - Add field game_category to game</strong>
</pre><p>The output indicates that the <code class="literal">gamesapi/games/migrations/0001_initial.py</code> file includes the code to create the <code class="literal">Game</code>, <code class="literal">GameCategory</code>, <code class="literal">Player</code> , and <code class="literal">PlayerScore</code> models. The following lines show the code for this file that was automatically generated by Django. The code file for the sample is included in the <code class="literal">restful_python_chapter_02_03</code> folder:</p><pre class="programlisting"># -*- coding: utf-8 -*- 
# Generated by Django 1.9.7 on 2016-06-17 20:39 
from __future__ import unicode_literals 
 
from django.db import migrations, models 
import django.db.models.deletion 
 
 
class Migration(migrations.Migration): 
 
    initial = True 
 
    dependencies = [ 
    ] 
 
    operations = [ 
        migrations.CreateModel( 
            name='Game', 
            fields=[ 
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')), 
                ('created', models.DateTimeField(auto_now_add=True)), 
                ('name', models.CharField(max_length=200)), 
                ('release_date', models.DateTimeField()), 
                ('played', models.BooleanField(default=False)), 
            ], 
            options={ 
                'ordering': ('name',), 
            }, 
        ), 
        migrations.CreateModel( 
            name='GameCategory', 
            fields=[ 
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')), 
                ('name', models.CharField(max_length=200)), 
            ], 
            options={ 
                'ordering': ('name',), 
            }, 
        ), 
        migrations.CreateModel( 
            name='Player', 
            fields=[ 
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')), 
                ('created', models.DateTimeField(auto_now_add=True)), 
                ('name', models.CharField(default='', max_length=50)), 
                ('gender', models.CharField(choices=[('M', 'Male'), ('F', 'Female')], default='M', max_length=2)), 
            ], 
            options={ 
                'ordering': ('name',), 
            }, 
        ), 
        migrations.CreateModel( 
            name='PlayerScore', 
            fields=[ 
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')), 
                ('score', models.IntegerField()), 
                ('score_date', models.DateTimeField()), 
                ('game', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='games.Game')), 
                ('player', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='scores', to='games.Player')), 
            ], 
            options={ 
                'ordering': ('-score',), 
            }, 
        ), 
        migrations.AddField( 
            model_name='game', 
            name='game_category', 
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='games', to='games.GameCategory'), 
        ), 
    ] 
</pre><p>The preceding code defines a subclass of the <code class="literal">django.db.migrations.Migration</code> class named <code class="literal">Migration</code> that defines an <code class="literal">operations</code> list with many <code class="literal">migrations.CreateModel</code>. Each <code class="literal">migrations.CreateModel</code> will create the table for each of the related models. Note that Django has automatically added an <code class="literal">id</code> field for each of the models. The <code class="literal">operations</code> are executed in the same order in which they appear in the list. The code creates <code class="literal">Game</code>, <code class="literal">GameCategory</code>, <code class="literal">Player</code>, <code class="literal">PlayerScore</code>, and finally adds the <code class="literal">game_category</code> field to <code class="literal">Game</code> with the foreign key to <code class="literal">GameCategory</code> because it created the <code class="literal">Game</code> model before the <code class="literal">GameCategory</code> model. The code creates the foreign keys for <code class="literal">PlayerScore</code> when it creates the model:</p><p>Now, run the following Python script to apply all the generated migrations.</p><pre class="programlisting">
<strong>python manage.py migrate</strong>
</pre><p>The following lines show the output generated after running the previous command:</p><pre class="programlisting">
<strong>Operations to perform:</strong>
<strong>  Apply all migrations: sessions, contenttypes, games, admin, auth</strong>
<strong>Running migrations:</strong>
<strong>  Rendering model states... DONE</strong>
<strong>  Applying contenttypes.0001_initial... OK</strong>
<strong>  Applying auth.0001_initial... OK</strong>
<strong>  Applying admin.0001_initial... OK</strong>
<strong>  Applying admin.0002_logentry_remove_auto_add... OK</strong>
<strong>  Applying contenttypes.0002_remove_content_type_name... OK</strong>
<strong>  Applying auth.0002_alter_permission_name_max_length... OK</strong>
<strong>  Applying auth.0003_alter_user_email_max_length... OK</strong>
<strong>  Applying auth.0004_alter_user_username_opts... OK</strong>
<strong>  Applying auth.0005_alter_user_last_login_null... OK</strong>
<strong>  Applying auth.0006_require_contenttypes_0002... OK</strong>
<strong>  Applying auth.0007_alter_validators_add_error_messages... OK</strong>
<strong>  Applying games.0001_initial... OK</strong>
<strong>  Applying sessions.0001_initial... OK</strong>
</pre><p>After we run the previous command, we can use the PostgreSQL command line or any other application that allows us to easily check the contents of the PostreSQL database to check the tables that Django generated. In case you are working with SQLite, we have already learned how to check the tables in <a class="link" href="ch01.html" title="Chapter 1. Developing RESTful APIs with Django">Chapter 1</a>, <em>Developing RESTful APIs with Django</em>.</p><p>Run the following command to list the generated tables:</p><pre class="programlisting">
<strong>psql --username=user_name --dbname=games --command="\dt"</strong>
</pre><p>The following lines show the output with all the generated table names:</p><pre class="programlisting">
<strong>                    List of relations</strong>
<strong> Schema |            Name            | Type  |   Owner   </strong>
<strong>--------+----------------------------+-------+-----------</strong>
<strong> public | auth_group                 | table | user_name</strong>
<strong> public | auth_group_permissions     | table | user_name</strong>
<strong> public | auth_permission            | table | user_name</strong>
<strong> public | auth_user                  | table | user_name</strong>
<strong> public | auth_user_groups           | table | user_name</strong>
<strong> public | auth_user_user_permissions | table | user_name</strong>
<strong> public | django_admin_log           | table | user_name</strong>
<strong> public | django_content_type        | table | user_name</strong>
<strong> public | django_migrations          | table | user_name</strong>
<strong> public | django_session             | table | user_name</strong>
<strong> public | games_game                 | table | user_name</strong>
<strong> public | games_gamecategory         | table | user_name</strong>
<strong> public | games_player               | table | user_name</strong>
<strong> public | games_playerscore          | table | user_name</strong>
<strong>(14 rows)</strong>
</pre><p>As seen in our previous example, Django uses the <code class="literal">games_</code> prefix for the following four table names related to the <code class="literal">games</code> application. Django's integrated ORM generated these tables and the foreign keys, based on the information included in our models:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">games_game</code>: Persists the <code class="literal">Game</code> model</li><li class="listitem" style="list-style-type: disc"><code class="literal">games_gamecategory</code>: Persists the <code class="literal">GameCategory</code> model</li><li class="listitem" style="list-style-type: disc"><code class="literal">games_player</code>: Persists the <code class="literal">Player</code> model</li><li class="listitem" style="list-style-type: disc"><code class="literal">games_playerscore</code>: Persists the <code class="literal">PlayerScore</code> model</li></ul></div><p>The following command will allow you to check the contents of the four tables after we compose and send HTTP requests to the RESTful API and make CRUD operations to the four tables. The commands assume that you are running PostgreSQL on the same computer in which you are running the command.</p><pre class="programlisting">
<strong>psql --username=user_name --dbname=games --command="SELECT * FROM games_gamecategory;"</strong>
<strong>psql --username=user_name --dbname=games --command="SELECT * FROM games_game;"</strong>
<strong>psql --username=user_name --dbname=games --command="SELECT * FROM games_player;"</strong>
<strong>psql --username=user_name --dbname=games --command="SELECT * FROM games_playerscore;"</strong>
</pre><div><div><h3 class="title"><a id="tip26"/>Tip</h3><p>Instead of working with the PostgreSQL command-line utility, you can use a GUI tool to check the contents of the PostgreSQL database. You can also use the database tools included in your favorite IDE to check the contents for the SQLite database.</p></div></div><p>Django generates additional tables that it requires to support the web framework and the authentication features that we will use later.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Managing serialization and deserialization with relationships and hyperlinks</h1></div></div></div><p>Our new RESTful Web API has to be able to serialize and deserialize the <code class="literal">GameCategory</code>, <code class="literal">Game</code>, <code class="literal">Player</code>, and <code class="literal">PlayerScore</code> instances into JSON representations. In this case, we also have to pay special attention to the relationships between the different models when we create the serializer classes to manage serialization to JSON and deserialization from JSON.</p><p>In our last version of the previous API, we created a subclass of the <code class="literal">rest_framework.serializers.ModelSerializer</code> class to make it easier to generate a serializer and reduce boilerplate code. In this case, we will also declare a class that inherits from <code class="literal">ModelSerializer</code>, but the other classes will inherit from the <code class="literal">rest_framework.serializers.HyperlinkedModelSerializer</code> class.</p><p>The <code class="literal">HyperlinkedModelSerializer</code> is a type of <code class="literal">ModelSerializer</code> that uses hyperlinked relationships instead of primary key relationships, and therefore, it represents the realationships to other model instances with hyperlinks instead of primary key values. In addition, the <code class="literal">HyperlinkedModelSerializer</code> generated a field named <code class="literal">url</code> with the URL for the resource as its value. As seen in the case of <code class="literal">ModelSerializer</code>, the <code class="literal">HyperlinkedModelSerializer</code> class provides default implementations for the <code class="literal">create</code> and <code class="literal">update</code> methods.</p><p>Now, go to the <code class="literal">gamesapi/games</code> folder and open the <code class="literal">serializers.py</code> file. Replace the code in this file with the following code that declares the required imports and the <code class="literal">GameCategorySerializer</code> class. We will add more classes to this file later. The code file for the sample is included in the <code class="literal">restful_python_chapter_02_03</code> folder:</p><pre class="programlisting">from rest_framework import serializers 
from games.models import GameCategory 
from games.models import Game 
from games.models import Player 
from games.models import PlayerScore 
import games.views 
 
 
class GameCategorySerializer(serializers.HyperlinkedModelSerializer): 
    games = serializers.HyperlinkedRelatedField( 
        many=True, 
        read_only=True, 
        view_name='game-detail') 
 
    class Meta: 
        model = GameCategory 
        fields = ( 
            'url', 
            'pk', 
            'name', 
            'games') 
</pre><p>The <code class="literal">GameCategorySerializer</code> class is a subclass of the <code class="literal">HyperlinkedModelSerializer</code> class. The <code class="literal">GameCategorySerializer</code> class declares a <code class="literal">games</code> attribute as an instance of <code class="literal">serializers.HyperlinkedRelatedField</code> with <code class="literal">many</code> and <code class="literal">read_only</code> equal to <code class="literal">True</code> because it is a one-to-many relationship and it is read-only. We use the <code class="literal">games</code> name that we specified as the <code class="literal">related_name</code> string value when we created the <code class="literal">game_category</code> field as a <code class="literal">models.ForeignKey</code> instance in the <code class="literal">Game</code> model. This way, the <code class="literal">games</code> field will provide us with an array of hyperlinks to each game that belong to the game category. The <code class="literal">view_name</code> value is '<code class="literal">game-detail</code>' because we want the browsable API feature to use the game detail view to render the hyperlink when the user clicks or taps on it.</p><p>The <code class="literal">GameCategorySerializer</code> class declares a <code class="literal">Meta</code> inner class that declares two attributes: <code class="literal">model</code> and <code class="literal">fields</code>. The <code class="literal">model</code> attribute specifies the model related to the serializer, that is, the <code class="literal">GameCategory</code> class. The <code class="literal">fields</code> attribute specifies a tuple of string whose values indicates the field names that we want to include in the serialization from the related model. We want to include both the primary key and the URL, and therefore, the code specified both <code class="literal">'pk'</code> and <code class="literal">'url'</code> as members of the tuple. There is no need to override either the <code class="literal">create</code> , or <code class="literal">update</code> method because the generic behavior will be enough in this case. The <code class="literal">HyperlinkedModelSerializer</code> superclass provides implementations for both methods.</p><p>Now, add the following code to the <code class="literal">serializers.py</code> file to declare the <code class="literal">GameSerializer</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_02_03</code> folder:</p><pre class="programlisting">class GameSerializer(serializers.HyperlinkedModelSerializer): 
    # We want to display the game cagory's name instead of the id 
    game_category = serializers.SlugRelatedField(queryset=GameCategory.objects.all(), slug_field='name') 
 
    class Meta: 
        model = Game 
        fields = ( 
            'url', 
            'game_category', 
            'name', 
            'release_date', 
            'played') 
</pre><p>The <code class="literal">GameSerializer</code> class is a subclass of the <code class="literal">HyperlinkedModelSerializer</code> class. The <code class="literal">GameSerializer</code> class declares a <code class="literal">game_category</code> attribute as an instance of <code class="literal">serializers.SlugRelatedField</code> with its <code class="literal">queryset</code> argument set to <code class="literal">GameCategory.objects.all()</code> and its <code class="literal">slug_field</code> argument set to <code class="literal">'name'</code>. A <code class="literal">SlugRelatedField</code> is a read-write field that represents the target of the relationship by a unique slug attribute, that is, the description. We created the <code class="literal">game_category</code> field as a <code class="literal">models.ForeignKey</code> instance in the <code class="literal">Game</code> model and we want to display the game category's name as the description (slug field) for the related <code class="literal">GameCategory</code>. Thus, we specified <code class="literal">'name'</code> as the <code class="literal">slug_field</code>. In case it is necessary to display the possible options for the related game category in a form in the browsable API, Django will use the expression specified in the <code class="literal">queryset</code> argument to retrieve all the possible instances and display their specified slug field.</p><p>The <code class="literal">GameCategorySerializer</code> class declares a <code class="literal">Meta</code> inner class that declares two attributes: <code class="literal">model</code> and <code class="literal">fields</code>. The <code class="literal">model</code> attribute specifies the model related to the serializer, that is, the <code class="literal">Game</code> class. The <code class="literal">fields</code> attribute specifies a tuple of string whose values indicate the field names that we want to include in the serialization from the related model. We just want to include the URL, and therefore, the code specified both <code class="literal">'url'</code> as a member of the tuple. The <code class="literal">game_category</code> field will specify the <code class="literal">name</code> field for the related <code class="literal">GameCategory</code>.</p><p>Now, add the following code to the <code class="literal">serializers.py</code> file to declare the <code class="literal">ScoreSerializer</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_02_03</code> folder:</p><pre class="programlisting">class ScoreSerializer(serializers.HyperlinkedModelSerializer): 
    # We want to display all the details for the game 
    game = GameSerializer() 
    # We don't include the player because it will be nested in the player 
    class Meta: 
        model = PlayerScore 
        fields = ( 
            'url', 
            'pk', 
            'score', 
            'score_date', 
            'game', 
            ) 
</pre><p>The <code class="literal">ScoreSerializer</code> class is a subclass of the <code class="literal">HyperlinkedModelSerializer</code> class. We will use the <code class="literal">ScoreSerializer</code> class to serialize <code class="literal">PlayerScore</code> instances related to a <code class="literal">Player</code>, that is, to display all the scores for a specific player when we serialize a <code class="literal">Player</code>. We want to display all the details for the related <code class="literal">Game</code> but we don't include the related <code class="literal">Player</code> because the <code class="literal">Player</code> will use this <code class="literal">ScoreSerializer</code> serializer.</p><p>The <code class="literal">ScoreSerializer</code> class declares a <code class="literal">game</code> attribute as an instance of the previously coded <code class="literal">GameSerializer</code> class. We created the <code class="literal">game</code> field as a <code class="literal">models.ForeignKey</code> instance in the <code class="literal">PlayerScore</code> model and we want to serialize the same data for the game that we coded in the <code class="literal">GameSerializer</code> class.</p><p>The <code class="literal">ScoreSerializer</code> class declares a <code class="literal">Meta</code> inner class that declares two attributes: <code class="literal">model</code> and <code class="literal">fields</code>. The <code class="literal">model</code> attribute specifies the model related to the serializer, that is, the <code class="literal">PlayerScore</code> class. As previously explain, we don't include the <code class="literal">'player'</code> field name in the <code class="literal">fields</code> tuple of string to avoid serializing the player again. We will use a <code class="literal">PlayerSerializer</code> as a master and the <code class="literal">ScoreSerializer</code> as the detail.</p><p>Now, add the following code to the <code class="literal">serializers.py</code> file to declare the <code class="literal">PlayerSerializer</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_02_03</code> folder:</p><pre class="programlisting">class PlayerSerializer(serializers.HyperlinkedModelSerializer): 
    scores = ScoreSerializer(many=True, read_only=True) 
    gender = serializers.ChoiceField( 
        choices=Player.GENDER_CHOICES) 
    gender_description = serializers.CharField( 
        source='get_gender_display',  
        read_only=True) 
 
    class Meta: 
        model = Player 
        fields = ( 
            'url', 
            'name', 
            'gender', 
            'gender_description', 
            'scores', 
            ) 
</pre><p>The <code class="literal">PlayerSerializer</code> class is a subclass of the <code class="literal">HyperlinkedModelSerializer</code> class. We will use the <code class="literal">PlayerSerializer</code> class to serialize <code class="literal">Player</code> instances and we will use the previously declared <code class="literal">ScoreSerializer</code> class to serialize all the <code class="literal">PlayerScore</code> instances related to the <code class="literal">Player</code>.</p><p>The <code class="literal">PlayerSerializer</code> class declares a <code class="literal">scores</code> attribute as an instance of the previously coded <code class="literal">ScoreSerializer</code> class. The <code class="literal">many</code> argument is set to <code class="literal">True</code> because it is a one-to-many relationship. We use the <code class="literal">scores</code> name that we specified as the <code class="literal">related_name</code> string value when we created the <code class="literal">player</code> field as a <code class="literal">models.ForeignKey</code> instance in the <code class="literal">PlayerScore</code> model. This way, the <code class="literal">scores</code> field will render each <code class="literal">PlayerScore</code> that belongs to the <code class="literal">Player</code> using the previously declared <code class="literal">ScoreSerializer</code>.</p><p>The <code class="literal">Player</code> model declared <code class="literal">gender</code> as an instance of <code class="literal">models.CharField</code> with the <code class="literal">choices</code> attribute set to the <code class="literal">Player.GENDER_CHOICES</code> string tuple. The <code class="literal">ScoreSerializer</code> class declares a <code class="literal">gender</code> attribute as an instance of <code class="literal">serializers.ChoiceField</code> with the <code class="literal">choices</code> argument set to the <code class="literal">Player.GENDER_CHOICES</code> string tuple. In addition, the class declares a <code class="literal">gender_description</code> attribute with <code class="literal">read_only</code> set to <code class="literal">True</code> and the <code class="literal">source</code> argument set to <code class="literal">'get_gender_display'</code>. The <code class="literal">source</code> string is built with <code class="literal">get_</code> followed by the field name, <code class="literal">gender</code>, and <code class="literal">_display</code>. This way, the read-only <code class="literal">gender_description</code> attribute will render the description for the gender choices instead of the single char stored values.</p><p>The <code class="literal">ScoreSerializer</code> class declares a <code class="literal">Meta</code> inner class that declares two attributes: <code class="literal">model</code> and <code class="literal">fields</code>. The <code class="literal">model</code> attribute specifies the model related to the serializer, that is, the <code class="literal">PlayerScore</code> class. As previously explained, we don't include the <code class="literal">'player'</code> field name in the <code class="literal">fields</code> tuple of string to avoid serializing the player again. We will use a <code class="literal">PlayerSerializer</code> as a master and the <code class="literal">ScoreSerializer</code> as the detail.</p><p>Finally, add the following code to the <code class="literal">serializers.py</code> file to declare the <code class="literal">PlayerScoreSerializer</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_02_03</code> folder:</p><pre class="programlisting">class PlayerScoreSerializer(serializers.ModelSerializer): 
    player = serializers.SlugRelatedField(queryset=Player.objects.all(), slug_field='name') 
    # We want to display the game's name instead of the id 
    game = serializers.SlugRelatedField(queryset=Game.objects.all(), slug_field='name') 
 
    class Meta: 
        model = PlayerScore 
        fields = ( 
            'url', 
            'pk', 
            'score', 
            'score_date', 
            'player', 
            'game', 
            ) 
</pre><p>The <code class="literal">PlayerScoreSerializer</code> class is a subclass of the <code class="literal">HyperlinkedModelSerializer</code> class. We will use the <code class="literal">PlayerScoreSerializer</code> class to serialize <code class="literal">PlayerScore</code> instances. Previously, we created the <code class="literal">ScoreSerializer</code> class to serialize <code class="literal">PlayerScore</code> instances as the detail of a player. We will use the new <code class="literal">PlayerScoreSerializer</code> class when we want to display the related player's name and the related game's name. In the other <code class="literal">serializer</code> class, we didn't include any information related to the player and we included all the details for the game.</p><p>The <code class="literal">PlayerScoreSerializer</code> class declares a <code class="literal">player</code> attribute as an instance of <code class="literal">serializers.SlugRelatedField</code> with its <code class="literal">queryset</code> argument set to <code class="literal">Player.objects.all()</code> and its <code class="literal">slug_field</code> argument set to <code class="literal">'name'</code>. We created the <code class="literal">player</code> field as a <code class="literal">models.ForeignKey</code> instance in the <code class="literal">PlayerScore</code> model and we want to display the player's name as the description (slug field) for the related <code class="literal">Player</code>. Thus, we specified <code class="literal">'name'</code> as the <code class="literal">slug_field</code>. In case it is necessary to display the possible options for the related game category in a form in the browsable API, Django will use the expression specified in the <code class="literal">queryset</code> argument to retrieve all the possible players and display their specified slug field.</p><p>The <code class="literal">PlayerScoreSerializer</code> class declares a <code class="literal">game</code> attribute as an instance of <code class="literal">serializers.SlugRelatedField</code> with its <code class="literal">queryset</code> argument set to <code class="literal">Game.objects.all()</code> and its <code class="literal">slug_field</code> argument set to <code class="literal">'name'</code>. We created the <code class="literal">game</code> field as a <code class="literal">models.ForeignKey</code> instance in the <code class="literal">PlayerScore</code> model and we want to display the game's name as the description (slug field) for the related <code class="literal">Game</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Creating class-based views and using generic classes</h1></div></div></div><p>This time, we will write our API views by declaring class-based views, instead of function-based views. We might code classes that inherit from the <code class="literal">rest_framework.views.APIView</code> class and declare methods with the same names than the HTTP verbs we want to process: <code class="literal">get</code>, <code class="literal">post</code>, <code class="literal">put</code>, <code class="literal">patch</code>, <code class="literal">delete</code>, and so on. These methods receive a <code class="literal">request</code> argument as happened with the functions that we created for the views. However, this approach would require us to write a lot of code. Instead, we can take advantage of a set of generic views that we can use as our base classes for our class-based views to reduce the required code to the minimum and take advantage of the behavior that has been generalized in Django REST Framework.</p><p>We will create subclasses of the two following generic class views declared in <code class="literal">rest_framework.generics</code>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ListCreateAPIView</code>: Implements the <code class="literal">get</code> method that retrieves a listing of a queryset and the <code class="literal">post</code> method that creates a model instance.</li><li class="listitem" style="list-style-type: disc"><code class="literal">RetrieveUpdateDestroyAPIView</code>: Implements the <code class="literal">get</code>, <code class="literal">put</code>, <code class="literal">patch</code>, and <code class="literal">delete</code> methods to retreive, completely update, partially update or delete a model instance.</li></ul></div><p>Those two generic views are composed by combining reusable bits of behavior in Django REST Framework implemented as mixin classes declared in <code class="literal">rest_framework.mixins</code>. We can create a class that uses multiple inheritance and combine the features provided by many of these mixin classes. The following line shows the declaration of the <code class="literal">ListCreateAPIView</code> class as the composition of <code class="literal">ListModelMixin</code>, <code class="literal">CreateModelMixin</code> and <code class="literal">rest_framework.generics.GenericAPIView</code>:</p><pre class="programlisting">class ListCreateAPIView(mixins.ListModelMixin, 
                        mixins.CreateModelMixin, 
                        GenericAPIView): 
</pre><p>The following line shows the declaration of the <code class="literal">RetrieveUpdateDestroyAPIView</code> class as the composition of <code class="literal">RetrieveModelMixin</code>, <code class="literal">UpdateModelMixin</code>, <code class="literal">DestroyModelMixin</code> and <code class="literal">rest_framework.generics.GenericAPIView</code>:</p><pre class="programlisting">class RetrieveUpdateDestroyAPIView(mixins.RetrieveModelMixin, 
                                   mixins.UpdateModelMixin, 
                                   mixins.DestroyModelMixin, 
                                   GenericAPIView): 
</pre><p>Now, we will create a Django class based views that will use the previously explained generic classes and the serializer classes to return JSON representations for each HTTP request that our API will handle. We will just have to specify a <code class="literal">queryset</code> that retrieves all the objects in the <code class="literal">queryset</code> attribute and the serializer class in the <code class="literal">serializer_class</code> attribute for each subclass that we declare. The generic classes will do the rest for us. In addition, we will declare a <code class="literal">name</code> attribute with the string name we will use to identify the view.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Taking advantage of generic class based views</h1></div></div></div><p>Go to the <code class="literal">gamesapi/games</code> folder and open the <code class="literal">views.py</code> file. Replace the code in this file with the following code that declares the required imports and the class based views. We will add more classes to this file later. The code file for the sample is included in the <code class="literal">restful_python_chapter_02_03</code> folder:</p><pre class="programlisting">from games.models import GameCategory 
from games.models import Game 
from games.models import Player 
from games.models import PlayerScore 
from games.serializers import GameCategorySerializer 
from games.serializers import GameSerializer 
from games.serializers import PlayerSerializer 
from games.serializers import PlayerScoreSerializer 
from rest_framework import generics 
from rest_framework.response import Response 
from rest_framework.reverse import reverse 
 
 
<strong>class GameCategoryList(generics.ListCreateAPIView):</strong> 
    queryset = GameCategory.objects.all() 
    serializer_class = GameCategorySerializer 
    name = 'gamecategory-list' 
 
 
<strong>class GameCategoryDetail(generics.RetrieveUpdateDestroyAPIView):</strong> 
    queryset = GameCategory.objects.all() 
    serializer_class = GameCategorySerializer 
    name = 'gamecategory-detail' 
 
 
<strong>class GameList(generics.ListCreateAPIView):</strong> 
    queryset = Game.objects.all() 
    serializer_class = GameSerializer 
    name = 'game-list' 
 
 
<strong>class GameDetail(generics.RetrieveUpdateDestroyAPIView):</strong> 
    queryset = Game.objects.all() 
    serializer_class = GameSerializer 
    name = 'game-detail' 
 
 
<strong>class PlayerList(generics.ListCreateAPIView):</strong> 
    queryset = Player.objects.all() 
    serializer_class = PlayerSerializer 
    name = 'player-list' 
 
 
<strong>class PlayerDetail(generics.RetrieveUpdateDestroyAPIView):</strong> 
    queryset = Player.objects.all() 
    serializer_class = PlayerSerializer 
    name = 'player-detail' 
 
 
<strong>class PlayerScoreList(generics.ListCreateAPIView):</strong> 
    queryset = PlayerScore.objects.all() 
    serializer_class = PlayerScoreSerializer 
    name = 'playerscore-list' 
 
 
<strong>class PlayerScoreDetail(generics.RetrieveUpdateDestroyAPIView):</strong> 
    queryset = PlayerScore.objects.all() 
    serializer_class = PlayerScoreSerializer 
    name = 'playerscore-detail' 
</pre><p>The following table summarizes the methods that each class-based view is going to process:</p><div><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p>
<strong>Scope</strong>
</p>
</td><td>
<p>
<strong>Class based view name</strong>
</p>
</td><td>
<p>
<strong>HTTP verbs that it will process</strong>
</p>
</td></tr><tr><td>
<p>Collection of game categories-<code class="literal">/game-categories/</code>
</p>
</td><td>
<p>
<code class="literal">GameCategoryList</code>
</p>
</td><td>
<p>
<code class="literal">GET</code> and <code class="literal">POST</code>
</p>
</td></tr><tr><td>
<p>Game category-<code class="literal">/game-category/{id}/</code>
</p>
</td><td>
<p>
<code class="literal">GameCategoryDetail</code>
</p>
</td><td>
<p>
<code class="literal">GET</code>, <code class="literal">PUT</code>, <code class="literal">PATCH</code> and <code class="literal">DELETE</code>
</p>
</td></tr><tr><td>
<p>Collection of games-<code class="literal">/games/</code>
</p>
</td><td>
<p>
<code class="literal">GameList</code>
</p>
</td><td>
<p>
<code class="literal">GET</code> and <code class="literal">POST</code>
</p>
</td></tr><tr><td>
<p>Game-<code class="literal">/game/{id}/</code>
</p>
</td><td>
<p>
<code class="literal">GameDetail</code>
</p>
</td><td>
<p>
<code class="literal">GET</code>, <code class="literal">PUT</code>, <code class="literal">PATCH</code> and <code class="literal">DELETE</code>
</p>
</td></tr><tr><td>
<p>Collection of players-<code class="literal">/players/</code>
</p>
</td><td>
<p>
<code class="literal">PlayerList</code>
</p>
</td><td>
<p>
<code class="literal">GET</code> and <code class="literal">POST</code>
</p>
</td></tr><tr><td>
<p>Player-<code class="literal">/player/{id}/</code>
</p>
</td><td>
<p>
<code class="literal">PlayerDetail</code>
</p>
</td><td>
<p>
<code class="literal">GET</code>, <code class="literal">PUT</code>, <code class="literal">PATCH</code> and <code class="literal">DELETE</code>
</p>
</td></tr><tr><td>
<p>Collection of scores-<code class="literal">/player-scores/</code>
</p>
</td><td>
<p>PlayerScoreList</p>
</td><td>
<p>
<code class="literal">GET</code> and <code class="literal">POST</code>
</p>
</td></tr><tr><td>
<p>Score-<code class="literal">/player-score/{id}/</code>
</p>
</td><td>
<p>PlayerScoreDetail</p>
</td><td>
<p>
<code class="literal">GET</code>, <code class="literal">PUT</code>, <code class="literal">PATCH</code> and <code class="literal">DELETE</code>
</p>
</td></tr></tbody></table></div><p>In addition, we will be able to execute the <code class="literal">OPTIONS</code> HTTP verb on any of the scopes.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Working with endpoints for the API</h1></div></div></div><p>We want to create an endpoint for the root of our API to make it easier to browse the API with the browsable API feature and understand how everything works. Add the following code to the <code class="literal">views.py</code> file to declare the <code class="literal">ApiRoot</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_02_03</code> folder.</p><pre class="programlisting">class ApiRoot(generics.GenericAPIView): 
    name = 'api-root' 
    def get(self, request, *args, **kwargs): 
        return Response({ 
            'players': reverse(PlayerList.name, request=request), 
            'game-categories': reverse(GameCategoryList.name, request=request), 
            'games': reverse(GameList.name, request=request), 
            'scores': reverse(PlayerScoreList.name, request=request) 
            }) 
</pre><p>The <code class="literal">ApiRoot</code> class is a subclass of the <code class="literal">rest_framework.generics.GenericAPIView</code> class and declares the get method. The <code class="literal">GenericAPIView</code> class is the base class for all the other generic views. The <code class="literal">ApiRoot</code> class defines the <code class="literal">get</code> method that returns a <code class="literal">Response</code> object with key-value pairs of string that provide a descriptive name for the view and its URL, generated with the <code class="literal">rest_framework.reverse.reverse</code> function. This URL resolver function returns a fully qualified URL for the view.</p><p>Go to the <code class="literal">gamesapi/games</code> folder and open the <code class="literal">urls.py</code> file. Replace the code in this file with the following code. The following lines show the code for this file that defines the URL patterns that specifies the regular expressions that have to be matched in the request to run a specific method for a class-based view defined in the <code class="literal">views.py</code> file. Instead of specifying a function that represents a view we call the <code class="literal">as_view</code> method for the class-based view. We use the <code class="literal">as_view</code> method. The code file for the sample is included in the <code class="literal">restful_python_chapter_02_03</code> folder:</p><pre class="programlisting">from django.conf.urls import url 
from games import views 
 
 
urlpatterns = [ 
    url(r'^game-categories/$',  
        views.GameCategoryList.as_view(),  
        name=views.GameCategoryList.name), 
    url(r'^game-categories/(?P&lt;pk&gt;[0-9]+)/$',  
        views.GameCategoryDetail.as_view(), 
        name=views.GameCategoryDetail.name), 
    url(r'^games/$',  
        views.GameList.as_view(), 
        name=views.GameList.name), 
    url(r'^games/(?P&lt;pk&gt;[0-9]+)/$',  
        views.GameDetail.as_view(), 
        name=views.GameDetail.name), 
    url(r'^players/$',  
        views.PlayerList.as_view(), 
        name=views.PlayerList.name), 
    url(r'^players/(?P&lt;pk&gt;[0-9]+)/$',  
        views.PlayerDetail.as_view(), 
        name=views.PlayerDetail.name), 
    url(r'^player-scores/$',  
        views.PlayerScoreList.as_view(), 
        name=views.PlayerScoreList.name), 
    url(r'^player-scores/(?P&lt;pk&gt;[0-9]+)/$',  
        views.PlayerScoreDetail.as_view(), 
        name=views.PlayerScoreDetail.name), 
    url(r'^$', 
        views.ApiRoot.as_view(), 
        name=views.ApiRoot.name), 
] 
</pre><p>When we coded our previous version of the API, we replaced the code in the <code class="literal">urls.py</code> file in the <code class="literal">gamesapi</code> folder, specifically, the <code class="literal">gamesapi/urls.py</code> file. We made the necessary changes to define the root URL configuration and include the URL pattern declared in the previously coded <code class="literal">games/urls.py</code> file.</p><p>Now, we can launch Django's development server to compose and send HTTP requests to our still unsecure, yet much more complex Web API (we will definitely add security later). Execute any of the following two commands based on your needs to access the API in other devices or computers connected to your LAN. Remember that we analyzed the difference between them in <a class="link" href="ch01.html" title="Chapter 1. Developing RESTful APIs with Django">Chapter 1</a>, <em>Developing RESTful APIs with Django</em>:</p><pre class="programlisting">
<strong>python manage.py runserver</strong>
<strong>python manage.py runserver 0.0.0.0:8000</strong>
</pre><p>After we run any of the previous commands, the development server will start listening at port <code class="literal">8000</code>.</p><p>Open a web browser and enter <code class="literal">http://localhost:8000/</code> or the appropriate URL in case you are using another computer or device to access the browsable API. The browsable API will compose and send a <code class="literal">GET</code> request to <code class="literal">/</code> and will display the results of its execution, that is, the headers and the JSON response from the execution of the <code class="literal">get</code> method defined in the <code class="literal">ApiRoot</code> class within the <code class="literal">views.py</code> file. The following screenshot shows the rendered web page after entering the URL in a web browser with the resource description: <strong>Api Root</strong>.</p><p>The API Root provides us hyperlinks to see the list of game categories, games, players, and scores. This way, it becomes extremely easy to access the lists and perform operations on the different resources through the browsable API. In addition, when we visit the other URLs, the breadcrumb will allow us to go back to the <strong>Api Root</strong>.</p><p>In this new version of the API, we worked with the generic views that provide many featured under the hoods, and therefore, the browsable API will provide us additional features compared with the previous version. Click or tap on the URL on the right-hand side of <strong>game-categories</strong>. In case you are browsing in localhost, the URL will be <code class="literal">http://localhost:8000/game-categories/</code>. The browsable API will render the web page for the <strong>Game Category List</strong>.</p><p>At the bottom of the rendered web page, the browsable API provides us some controls to generate a <code class="literal">POST</code> request to <code class="literal">/game-categories/</code>. In this case, by default, the browsable API displays the HTML form tab with an automatically generated form that we can use to generate a POST request without having to deal with the raw data as we did in our previous version. The HTML forms make it easy to generate requests to test our API. The following screenshot shows the HTML form to create a new game category:</p><p>
</p><div><img src="img/image_02_004.jpg" alt="Working with endpoints for the API"/></div><p>
</p><p>We just need to enter the desired name, <strong>3D RPG</strong>, in the <strong>Name</strong> textbox and click or tap on <strong>POST</strong> to create a new game category. The browsable API will compose and send a <code class="literal">POST</code> request to <code class="literal">/game-categories/</code> with the previously specified data and we will see the results of the call in the web browser. The following screenshot shows a web browser displaying the HTTP status code <code class="literal">201 Created</code> in the response and the previously explained HTML form with the <strong>POST</strong> button to allow us to continue composing and sending <code class="literal">POST</code> requests to <code class="literal">/game-categories/</code>:</p><p>
</p><div><img src="img/image_02_005.jpg" alt="Working with endpoints for the API"/></div><p>
</p><p>Now, click on the URL displayed as a value for the url key in the JSON data displayed for the game category, such as <code class="literal">http://localhost:8000/game-categories/3/</code>. Make sure you replace 2 with the id or primary key of an existing game category in the previously rendered <strong>Games List</strong>. The browsable API will compose and send a <code class="literal">GET</code> request to <code class="literal">/game-categories/3/</code> and will display the results of its execution, that is, the headers and the JSON data for the game category. The web page will display a <strong>DELETE</strong> button because we are working with the <strong>Game Category Detail</strong> view.</p><div><div><h3 class="title"><a id="tip27"/>Tip</h3><p>We can use the breadcrumb to go back to the Api Root and start creating games related to a game category, players, and finally scores related to a game and a player. We can do all this with easy to use HTML forms and the browsable API feature.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec28"/>Creating and retrieving related resources</h1></div></div></div><p>Now, we will use the HTTPie command or its curl equivalents to compose and send HTTP requests to the API. We will use JSON for the requests that require additional data. Remember that you can perform the same tasks with your favorite GUI-based tool or with the browsable API.</p><p>First, we will compose and send an HTTP request to create a new game category. Remember that we used the browsable API to create a game category named <code class="literal">'3D RPG'</code>.</p><pre class="programlisting">
<strong>http POST :8000/game-categories/ name='2D mobile arcade'</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"2D mobile arcade"}' :8000/game-categories/</strong>
</pre><p>The preceding command will compose and send a <code class="literal">POST</code> HTTP request with the specified JSON key-value pair. The request specifies <code class="literal">/game-categories/</code>, and therefore, it will match <code class="literal">'^game-categories/$'</code> and run the <code class="literal">post</code> method for the <code class="literal">views.GameCategoryList</code> class-based view. Remember that the method is defined in the <code class="literal">ListCreateAPIView</code> superclass and it ends up calling the create method defined in <code class="literal">mixins.CreateModelMixin</code>. If the new <code class="literal">GameCategory</code> instance was successfully persisted in the database, the call to the method will return an <code class="literal">HTTP 201 Created</code> status code and the recently persisted <code class="literal">GameCategory</code> serialized to JSON in the response body. The following line shows a sample response for the HTTP request with the new <code class="literal">GameCategory</code> object in the JSON response. The response doesn't include the header. Note that the response includes both the primary key, <code class="literal">pk</code>, and the url, <code class="literal">url</code>, for the created category. The <code class="literal">games</code> array is empty because there aren't games related to the new category yet:</p><pre class="programlisting">{ 
    "games": [],  
    "name": "2D mobile arcade",  
    "pk": 4,  
    "url": "http://localhost:8000/game-categories/4/" 
} 
</pre><p>Now, we will compose and send HTTP requests to create two games that belong to the first category we recently created: <code class="literal">3D RPG</code>. We will specify the <code class="literal">game_category</code> value with the name of the desired <code class="literal">game category</code>. However, the database table that persists the <code class="literal">Game</code> model will save the value of the primary key of the related <code class="literal">GameCategory</code> whose name value matches the one we provide:</p><pre class="programlisting">
<strong>http POST :8000/games/ name='PvZ Garden Warfare 4' game_category='3D RPG' played=false release_date='2016-06-21T03:02:00.776594Z'</strong>
<strong>http POST :8000/games/ name='Superman vs Aquaman' game_category='3D RPG' played=false release_date='2016-06-21T03:02:00.776594Z'</strong>
</pre><p>The following are the equivalent <code class="literal">curl</code> commands:</p><pre class="programlisting">
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"PvZ Garden Warfare 4", "game_category":"3D RPG", "played": "false", "release_date": "2016-06-21T03:02:00.776594Z"}' :8000/games/</strong>
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":" Superman vs Aquaman", "game_category":"3D RPG", "played": "false", "release_date": "2016-06-21T03:02:00.776594Z"}' :8000/games/</strong>
</pre><p>The previous commands will compose and send two <code class="literal">POST</code> HTTP requests with the specified JSON key-value pairs. The request specifies <code class="literal">/games/</code>, and therefore, it will match <code class="literal">'^games/$'</code> and run the <code class="literal">post</code> method for the <code class="literal">views.GameList</code> class-based view. The following lines show sample responses for the two HTTP requests with the new <code class="literal">Game</code> objects in the JSON responses. The responses don't include the headers. Note that the response includes only the url, <code class="literal">url</code>, for the created games and doesn't include the primary key. The value for <code class="literal">game_category</code> is the <code class="literal">name</code> for the related <code class="literal">GameCategory</code>:</p><pre class="programlisting">{ 
    "game_category": "3D RPG",  
    "name": "PvZ Garden Warfare 4",  
    "played": false,  
    "release_date": "2016-06-21T03:02:00.776594Z",  
    "url": "http://localhost:8000/games/2/" 
} 
{ 
    "game_category": "3D RPG",  
    "name": "Superman vs Aquaman",  
    "played": false,  
    "release_date": "2016-06-21T03:02:00.776594Z",  
    "url": "http://localhost:8000/games/3/" 
} 
</pre><p>We can run the previously explained commands to check the contents of the tables that Django created in the PostgreSQL database. We will notice that the <code class="literal">game_category_id</code> column for the <code class="literal">games_game</code> table saves the value of the primary key of the related row in the <code class="literal">games_game_category</code> table. The <code class="literal">GameSerializer</code> class uses the <code class="literal">SlugRelatedField</code> to display the name value for the related <code class="literal">GameCategory</code>. The following screenshot shows the contents of the <code class="literal">games_game_category</code> and the <code class="literal">games_game</code> table in a PostgreSQL database after running the HTTP requests:</p><p>
</p><div><img src="img/image_02_006.jpg" alt="Creating and retrieving related resources"/></div><p>
</p><p>Now, we will compose and send an HTTP request to retrieve the game category that is contains two games, that is the game category resource whose id or primary key is equal to <code class="literal">3</code>. Don't forget to replace <code class="literal">3</code> with the primary key value of the game whose name is equal to <code class="literal">'3D RPG'</code> in your configuration:</p><pre class="programlisting">
<strong>http :8000/game-categories/3/</strong>
</pre><p>The following is the equivalent curl command:</p><pre class="programlisting">
<strong>curl -iX GET :8000/game-categories/3/</strong>
</pre><p>The previous commands will compose and send the following HTTP request: <code class="literal">GET http://localhost:8000/game-categories/3/</code>. The request has a number after <code class="literal">/game-categories/</code>, and therefore, it will match <code class="literal">'^game-categories/(?P&lt;pk&gt;[0-9]+)/$'</code> and run the <code class="literal">get</code> method for the <code class="literal">views.GameCategoryDetail</code> class based view. Remember that the method is defined in the <code class="literal">RetrieveUpdateDestroyAPIView</code> superclass and it ends up calling the <code class="literal">retrieve</code> method defined in <code class="literal">mixins.RetrieveModelMixin</code>. The following lines show a sample response for the HTTP request, with the <code class="literal">GameCategory</code> object and the hyperlinks of the related games in the JSON response:</p><pre class="programlisting">
<strong>HTTP/1.0 200 OK</strong>
<strong>Allow: GET, PUT, PATCH, DELETE, HEAD, OPTIONS</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Tue, 21 Jun 2016 23:32:04 GMT</strong>
<strong>Server: WSGIServer/0.2 CPython/3.5.1</strong>
<strong>Vary: Accept, Cookie</strong>
<strong>X-Frame-Options: SAMEORIGIN</strong>
<strong>{</strong>
<strong>    "games": [</strong>
<strong>        "http://localhost:8000/games/2/", </strong>
<strong>        "http://localhost:8000/games/3/"</strong>
<strong>    ], </strong>
<strong>    "name": "3D RPG", </strong>
<strong>    "pk": 3, </strong>
<strong>    "url": "http://localhost:8000/game-categories/3/"</strong>
<strong>}</strong>
</pre><p>The <code class="literal">GameCategorySerializer</code> class defined the <code class="literal">games</code> attribute as a <code class="literal">HyperlinkedRelatedField</code>, and therefore, the serializer renders the URL for each related <code class="literal">Game</code> instance in the value for the <code class="literal">games</code> array. If we view the results in a web browser through the browsable API, we will be able to click or tap on the hyperlink to see the details for each game.</p><p>Now, we will compose and send a <code class="literal">POST</code> HTTP request to create a game related to a game category name that doesn't exist: <code class="literal">'Virtual reality'</code>:</p><pre class="programlisting">
<strong>http POST :8000/games/ name='Captain America vs Thor' game_category='Virtual reality' played=false release_date='2016-06-21T03:02:00.776594Z'</strong>
</pre><p>The following is the equivalent curl command:</p><pre class="programlisting">
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"'Captain America vs Thor", "game_category":"Virtual reality", "played": "false", "release_date": "2016-06-21T03:02:00.776594Z"}' :8000/games/</strong>
</pre><p>Django won't be able to retrieve a <code class="literal">GameCategory</code> instance whose <code class="literal">name</code> is equal to the specified value, and therefore, we will receive a <code class="literal">400 Bad Request</code> status code in the response header and a message related to the value specified in for <code class="literal">game_category</code> in the JSON body. The following lines show a sample response:</p><pre class="programlisting">
<strong>HTTP/1.0 400 Bad Request</strong>
<strong>Allow: GET, POST, HEAD, OPTIONS</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Tue, 21 Jun 2016 23:51:19 GMT</strong>
<strong>Server: WSGIServer/0.2 CPython/3.5.1</strong>
<strong>Vary: Accept, Cookie</strong>
<strong>X-Frame-Options: SAMEORIGIN</strong>
<strong>{</strong>
<strong>    "game_category": [</strong>
<strong>        "Object with name=Virtual reality does not exist."</strong>
<strong>    ]</strong>
<strong>}</strong>
</pre><p>Now, we will compose and send HTTP requests to create two players:</p><pre class="programlisting">
<strong>http POST :8000/players/ name='Brandon' gender='M'</strong>
<strong>http POST :8000/players/ name='Kevin' gender='M'</strong>
</pre><p>The following are the equivalent <code class="literal">curl</code> commands:</p><pre class="programlisting">
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"Brandon", "gender":"M"}' :8000/players/</strong>
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":" Kevin", "gender":"M"}' :8000/players/</strong>
</pre><p>The previous commands will compose and send two <code class="literal">POST</code> HTTP requests with the specified JSON key-value pairs. The request specifies <code class="literal">/players/</code>, and therefore, it will match <code class="literal">'^players/$'</code> and run the <code class="literal">post</code> method for the <code class="literal">views.PlayerList</code> class based view. The following lines show sample responses for the two HTTP requests with the new <code class="literal">Player</code> objects in the JSON responses. The responses don't include the headers. Notice that the response includes only the url, <code class="literal">url</code>, for the created players and doesn't include the primary key. The value for <code class="literal">gender_description</code> is the choice description for the <code class="literal">gender</code> char. The <code class="literal">scores</code> array is empty because there aren't scores related to each new player yet:</p><pre class="programlisting">{ 
    "gender": "M",  
    "name": "Brandon",  
    "scores": [],  
    "url": "http://localhost:8000/players/2/" 
} 
{ 
    "gender": "M",  
    "name": "Kevin",  
    "scores": [],  
    "url": "http://localhost:8000/players/3/" 
} 
</pre><p>Now, we will compose and send HTTP requests to create four scores:</p><pre class="programlisting">
<strong>http POST :8000/player-scores/ score=35000 score_date='2016-06-21T03:02:00.776594Z' player='Brandon' game='PvZ Garden Warfare 4'</strong>
<strong>http POST :8000/player-scores/ score=85125 score_date='2016-06-22T01:02:00.776594Z' player='Brandon' game='PvZ Garden Warfare 4'</strong>
<strong>http POST :8000/player-scores/ score=123200 score_date='2016-06-22T03:02:00.776594Z' player='Kevin' game='Superman vs Aquaman'</strong>
<strong>http POST :8000/player-scores/ score=11200 score_date='2016-06-22T05:02:00.776594Z' player='Kevin' game='PvZ Garden Warfare 4'</strong>
</pre><p>The following are the equivalent curl commands:</p><pre class="programlisting">
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"score":"35000", "score_date":"2016-06-21T03:02:00.776594Z", "player":"Brandon", "game":"PvZ Garden Warfare 4"}' :8000/player-scores/</strong>
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"score":"85125", "score_date":"2016-06-22T01:02:00.776594Z", "player":"Brandon", "game":"PvZ Garden Warfare 4"}' :8000/player-scores/</strong>
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"score":"123200", "score_date":"2016-06-22T03:02:00.776594Z", "player":"Kevin", "game":"'Superman vs Aquaman"}' :8000/player-scores/</strong>
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"score":"11200", "score_date":"2016-06-22T05:02:00.776594Z", "player":"Kevin", "game":"PvZ Garden Warfare 4"}' :8000/player-scores/</strong>
</pre><p>The previous commands will compose and send four <code class="literal">POST</code> HTTP requests with the specified JSON key-value pairs. The request specifies <code class="literal">/player-scores/</code>, and therefore, it will match <code class="literal">'^player-scores/$'</code> and run the <code class="literal">post</code> method for the <code class="literal">views.PlayerScoreList</code> class based view. The following lines show sample responses for the four HTTP requests with the new <code class="literal">Player</code> objects in the JSON responses. The responses don't include the headers.</p><p>Django REST Framework uses the <code class="literal">PlayerScoreSerializer</code> class to generate the JSON response. Thus, the value for <code class="literal">game</code> is the name for the related <code class="literal">Game</code> instance and the value for <code class="literal">player</code> is the name for the related <code class="literal">Player</code> instance. The <code class="literal">PlayerScoreSerializer</code> class used <code class="literal">SlugRelatedField</code> for both fields:</p><pre class="programlisting">{ 
    "game": "PvZ Garden Warfare 4",  
    "pk": 3,  
    "player": "Brandon",  
    "score": 35000,  
    "score_date": "2016-06-21T03:02:00.776594Z",  
    "url": "http://localhost:8000/player-scores/3/" 
} 
{ 
    "game": "PvZ Garden Warfare 4",  
    "pk": 4,  
    "player": "Brandon",  
    "score": 85125,  
    "score_date": "2016-06-22T01:02:00.776594Z",  
    "url": "http://localhost:8000/player-scores/4/" 
} 
{ 
    "game": "Superman vs Aquaman",  
    "pk": 5,  
    "player": "Kevin",  
    "score": 123200,  
    "score_date": "2016-06-22T03:02:00.776594Z",  
    "url": "http://localhost:8000/player-scores/5/" 
} 
{ 
    "game": "PvZ Garden Warfare 4",  
    "pk": 6,  
    "player": "Kevin",  
    "score": 11200,  
    "score_date": "2016-06-22T05:02:00.776594Z",  
    "url": "http://localhost:8000/player-scores/6/" 
} 
</pre><p>We can run the previously explained commands to check the contents of the tables that Django created in the PostgreSQL database. We will notice that the <code class="literal">game_id</code> column for the <code class="literal">games_playerscore</code> table saves the value of the primary key of the related row in the <code class="literal">games_game</code> table. In addition, the <code class="literal">player_id</code> column for the <code class="literal">games_playerscore</code> table saves the value of the primary key of the related row in the <code class="literal">games_player</code> table. The following screenshot shows the contents for the <code class="literal">games_game_category</code>, <code class="literal">games_game</code>, <code class="literal">games_player</code> and <code class="literal">games_playerscore</code> tables in a PostgreSQL database after running the HTTP requests:</p><p>
</p><div><img src="img/image_02_007.jpg" alt="Creating and retrieving related resources"/></div><p>
</p><p>Now, we will compose and send an HTTP request to retrieve a specific player that contains two scores, which is the player resource whose id or primary key is equal to <code class="literal">3</code>. Don't forget to replace <code class="literal">3</code> with the primary key value of the player whose name is equal to <code class="literal">'Kevin'</code> in your configuration:</p><pre class="programlisting">
<strong>http :8000/players/3/</strong>
</pre><p>The following is the equivalent curl command:</p><pre class="programlisting">
<strong>curl -iX GET :8000/players/3/</strong>
</pre><p>The previous commands will compose and send the following HTTP request: <code class="literal">GET http://localhost:8000/players/3/</code>. The request has a number after <code class="literal">/players/</code>, and therefore, it will match <code class="literal">'^players/(?P&lt;pk&gt;[0-9]+)/$'</code> and run the <code class="literal">get</code> method for the <code class="literal">views.PlayerDetail</code> class based view. Remember that the method is defined in the <code class="literal">RetrieveUpdateDestroyAPIView</code> superclass and it ends up calling the <code class="literal">retrieve</code> method defined in <code class="literal">mixins.RetrieveModelMixin</code>. The following lines show a sample response for the HTTP request, with the <code class="literal">Player</code> object, the related <code class="literal">PlayerScore</code> objects and the <code class="literal">Game</code> object related to each <code class="literal">PlayerScore</code> object in the JSON response:</p><pre class="programlisting">
<strong>HTTP 200 OK</strong>
<strong>Allow: GET, PUT, PATCH, DELETE, HEAD, OPTIONS</strong>
<strong>Content-Type: application/json</strong>
<strong>Vary: Accept</strong>
<strong>{</strong>
<strong>    "url": "http://localhost:8000/players/3/",</strong>
<strong>    "name": "Kevin",</strong>
<strong>    "gender": "M",</strong>
<strong>    "gender_description": "Male",</strong>
<strong>    "scores": [</strong>
<strong>        {</strong>
<strong>            "url": "http://localhost:8000/player-scores/5/",</strong>
<strong>            "pk": 5,</strong>
<strong>            "score": 123200,</strong>
<strong>            "score_date": "2016-06-22T03:02:00.776594Z",</strong>
<strong>            "game": {</strong>
<strong>                "url": "http://localhost:8000/games/3/",</strong>
<strong>                "game_category": "3D RPG",</strong>
<strong>                "name": "Superman vs Aquaman",</strong>
<strong>                "release_date": "2016-06-21T03:02:00.776594Z",</strong>
<strong>                "played": false</strong>
<strong>            }</strong>
<strong>        },</strong>
<strong>        {</strong>
<strong>            "url": "http://localhost:8000/player-scores/6/",</strong>
<strong>            "pk": 6,</strong>
<strong>            "score": 11200,</strong>
<strong>            "score_date": "2016-06-22T05:02:00.776594Z",</strong>
<strong>            "game": {</strong>
<strong>                "url": "http://localhost:8000/games/2/",</strong>
<strong>                "game_category": "3D RPG",</strong>
<strong>                "name": "PvZ Garden Warfare 4",</strong>
<strong>                "release_date": "2016-06-21T03:02:00.776594Z",</strong>
<strong>                "played": false</strong>
<strong>            }</strong>
<strong>        }</strong>
<strong>    ]</strong>
<strong>}</strong>
</pre><p>The <code class="literal">PlayerSerializer</code> class defined the <code class="literal">scores</code> attribute as a <code class="literal">ScoreSerializer</code> with <code class="literal">many</code> equal to <code class="literal">True</code>, and therefore, this serializer renders each score related to the player. The <code class="literal">ScoreSerializer</code> class defined the <code class="literal">game</code> attribute as a <code class="literal">GameSerializer</code>, and therefore, this serializer renders each game related to the score. If we view the results in a web browser through the browsable API, we will be able to click or tap on the hyperlink of each of the related resources. However, in this case, we also see all their details without having to follow the hyperlink.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec29"/>Test your knowledge</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Under the hoods, the <code class="literal">@api_view</code> decorator is:<div><ol class="orderedlist arabic"><li class="listitem">A wrapper that converts a function-based view into a subclass of the <code class="literal">rest_framework.views.APIView</code> class.</li><li class="listitem">A wrapper that converts a function-based view into a serializer.</li><li class="listitem">A wrapper that converts a function-based view into a subclass of the <code class="literal">rest_framework.views.api_view</code> class.</li></ol></div><p>
</p></li><li class="listitem">The browsable API, a feature included in Django REST Framework that:<div><ol class="orderedlist arabic"><li class="listitem">Generates human-friendly JSON output for each resource whenever the request specifies <code class="literal">application/json</code> as the value for the <code class="literal">Content-type</code> key in the request header.</li><li class="listitem">Generates human-friendly HTML output for each resource whenever the request specifies <code class="literal">text/html</code> as the value for the <code class="literal">Content-type</code> key in the request header.</li><li class="listitem">Generates human-friendly HTML output for each resource whenever the request specifies <code class="literal">application/json</code> as the value for the <code class="literal">Content-type</code> key in the request header.</li></ol></div><p>
</p></li><li class="listitem">The <code class="literal">rest_framework.serializers.ModelSerializer</code> class:<div><ol class="orderedlist arabic"><li class="listitem">Automatically populates both a set of default constraints and a set of default parsers.</li><li class="listitem"> populates both a set of default fields but doesn't automatically populate a set of default validators.</li></ol></div><p>
</p><p>Automatically populates both a set of default fields but doesn't automatically populate a set of default validators. Automatically populates both a set of default fields and a set of default validators.
</p></li><li class="listitem">The <code class="literal">rest_framework.serializers.ModelSerializer</code> class:<div><ol class="orderedlist arabic"><li class="listitem">Provides default implementations for the <code class="literal">get</code> and <code class="literal">patch</code> methods.</li><li class="listitem">Provides default implementations for the <code class="literal">get</code> and <code class="literal">put</code> methods.</li><li class="listitem">Provides default implementations for the <code class="literal">create</code> and <code class="literal">update</code> methods.</li></ol></div><p>
</p></li><li class="listitem">The <code class="literal">Serializer</code> and <code class="literal">ModelSerializer</code> classes in Django REST Framework are similar to the following two classes in Django Web Framework:<div><ol class="orderedlist arabic"><li class="listitem"> <code class="literal">Form</code> and <code class="literal">ModelForm</code> classes.</li><li class="listitem"> <code class="literal">View</code> and <code class="literal">ModelView</code> classes.</li><li class="listitem"> <code class="literal">Controller</code> and <code class="literal">ModelController</code> classes.</li></ol></div><p>
</p></li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec30"/>Summary</h1></div></div></div><p>In this chapter, we took advantage of the various features included in Django REST Framework that allowed us to eliminate duplicate code and build our API reusing generalized behaviors. We used model serializers, wrappers, default parsing, and rendering options, class based views, and generic classes.</p><p>We used the browsable API feature and we designed a RESTful API that interacted with a complex PostgreSQL database. We declared relationships with the models, managed serialization and deserialization with relationships, and hyperlinks. Finally, we created and retrieved related resources and we understood how things work under the hoods.</p><p>Now that we have built a complex API with Django REST Framework, we will use additional abstractions included in the framework to improve our API, we will add security and authentication, which is what we are going to discuss in the next chapter.</p></div></body></html>