<html><head></head><body>
<div id="book-content" class="calibre2">
<div id="sbo-rt-content" class="calibre3"><div id="_idContainer038" class="calibre4">
			<h1 id="_idParaDest-143" class="contributor"><a id="_idTextAnchor153" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/><a id="_idTextAnchor154" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>9</h1>
			<h1 id="_idParaDest-144" class="contributor"><a id="_idTextAnchor155" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Third-Party Services Integration with FastAPI and Beanie</h1>
			<p class="calibre5">After learning about the tools that compose the FARM stack, you will see them combined in a more complex setting in this chapter. You will build on your knowledge of Pydantic and FastAPI to learn about <strong class="bold">Beanie,</strong> one of the most popular MongoDB <strong class="bold">Object-Document Mappers</strong> (<strong class="bold">ODMs</strong>), and how it can make your code more efficient and enhance your <span>developer experience.</span></p>
			<p class="calibre5">Finally, you will see how the stack’s flexibility is useful when you need to extend your application with external, third-party functionality. In this chapter, you will add a fully AI-based salesperson assistant that will make use of OpenAI to create catchy car descriptions, and then you will use the <strong class="bold">Resend</strong> API service to send <span>automated emails.</span></p>
			<p class="calibre5">These functionalities are becoming more and more central to web application requirements in the modern web, and through this chapter, you will see how the right set of tools can make application development <span>more efficient.</span></p>
			<p class="calibre5">This chapter will walk you through the <span>following tasks:</span></p>
			<ul class="calibre14">
				<li class="calibre17">Installing and using Beanie – a Python <span>MongoDB ODM</span></li>
				<li class="calibre17">Learning about the basic Beanie features (connections, CRUD operations, <span>and aggregations)</span></li>
				<li class="calibre17">Using FastAPI’s background tasks to handle long-running processes while maintaining the responsiveness of <span>the application</span></li>
				<li class="calibre17">Programmatically sending emails from <span>an application</span></li>
				<li class="calibre17">Integrating OpenAI’s ChatGPT (or any other <strong class="bold">Large Language </strong><span><strong class="bold">Model</strong></span><span> (</span><span><strong class="bold">LLM</strong></span><span>))</span></li>
			</ul>
			<h1 id="_idParaDest-145" class="contributor"><a id="_idTextAnchor156" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Technical requirements</h1>
			<p class="calibre5">The technical requirements for this chapter are similar to the requirements in the chapters in which we created backends with FastAPI, with the addition of a couple of libraries and services for the email-sending functionality and <span>AI integration:</span></p>
			<ul class="calibre14">
				<li class="calibre17">Python 3.11.7 <span>or higher</span></li>
				<li class="calibre17">Visual Studio Code with the Python extensions set up (same as in <a href="B22406_03.xhtml#_idTextAnchor051" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><em class="italic">Chapter 3</em></span></a><span>)</span></li>
				<li class="calibre17">An account on <span>MongoDB Atlas</span></li>
				<li class="calibre17">An account on Render.com (if you wish to deploy the <span>FastAPI backend)</span></li>
				<li class="calibre17">An OpenAI account with API access, or a free, locally run LLM such as Llama 2 or Llama 3 in case you do not want to deploy the app and <span>incur costs</span></li>
				<li class="calibre17">A Netlify account (<span>free tier)</span></li>
			</ul>
			<p class="calibre5">We strongly recommend starting with the free (or cheapest) tiers of the previous accounts and making sure that you feel comfortable within <span>these environments.</span></p>
			<p class="calibre5">With the technical requirements out of the way, let’s discuss the project you will build throughout <span>this chapter.</span></p>
			<h1 id="_idParaDest-146" class="contributor"><a id="_idTextAnchor157" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Project outline</h1>
			<p class="calibre5">Staying with the situation that you operate a (small) used car sales agency, the requirements are somewhat similar to the ones in the previous chapters. You will build a backend for a web app that displays information and pictures of cars that are for sale. Unlike the previous chapters, now you will use an ODM, and you will include email sending and OpenAI integration, which will be handled by FastAPI’s <span>background tasks.</span></p>
			<p class="calibre5">The car data model will be handled by Pydantic and Beanie. The application will need authenticated users and, while you will use <strong class="bold">JSON Web Tokens</strong> (<strong class="bold">JWTs</strong>) again in the backend, on the frontend, which you will develop in the next chapter, they will be handled by cookies, with the help of a package <span>called </span><span><strong class="source-inline">iron-session</strong></span><span>.</span></p>
			<p class="calibre5">Finally, you will integrate an LLM API (in this case, OpenAI) to help create useful car model descriptions, list the pros and cons of the newly inserted car model for the marketing pages, and send tailored emails to specified recipients on every new car <span>ad insertion.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">LLMs are machine learning systems designed specifically to generate and understand human language. Trained on huge datasets, they are able to perform efficiently on tasks such as text summarization and generation, translation, and image generation. In the last couple of years, LLMs have gained popularity and adoption, and their fields of implementation will only grow <span>over time.</span></p>
			<p class="calibre5">In the next section, you will learn how to create a backend with FastAPI and Beanie and how to integrate OpenAI and <span>email-sending functionality.</span></p>
			<h1 id="_idParaDest-147" class="contributor"><a id="_idTextAnchor158" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Building the backend with FastAPI and Beanie</h1>
			<p class="calibre5">For simplicity’s sake and to make the application as illustrative as possible, the API that you will build in this chapter will not differ too much from the one built in <a href="B22406_07.xhtml#_idTextAnchor118" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><em class="italic">Chapter 7</em></span></a>, <em class="italic">Building a Backend with FastAPI</em>. This way, you will be able to naturally pick up the main differences in the approaches of using Motor (or PyMongo) directly and the <span>Beanie ODM.</span></p>
			<p class="calibre5"><strong class="bold">Object-Relational Mappers</strong> (<strong class="bold">ORMs</strong>) and <strong class="bold">ODMs </strong>are tools whose main purpose is to abstract the underlying database (whether it’s a relational or non-relational database) and facilitate the development process. Some famous Python examples include the <strong class="bold">Django ORM</strong> and <strong class="bold">SQLAlchemy</strong>—two proven and battle-tested solutions—as well as <strong class="bold">SQLModel</strong>, which was created by the creator of FastAPI and tightly integrated into the <span>FastAPI/Pydantic world.</span></p>
			<p class="calibre5">Two modern ODMs that are gaining traction and popularity among the Python and MongoDB community are <strong class="bold">Beanie</strong> (<a href="https://beanie-odm.dev/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span>https://beanie-odm.dev/</span></a>) and <strong class="bold">Odmantic </strong>(<a href="https://art049.github.io/odmantic/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span>https://art049.github.io/odmantic/</span></a>). In this project, you will be working with the more mature and older one of the two—the <span>Beanie ODM.</span></p>
			<h2 id="_idParaDest-148" class="about-the-author"><a id="_idTextAnchor159" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Introduction to the Beanie ODM</h2>
			<p class="calibre5">Beanie is one of the most popular MongoDB ODMs for Python. ODMs are a programming technique that allows developers to work directly with classes (Python classes in our case) representing NoSQL documents. When using Beanie, each MongoDB collection is mapped to a corresponding document class that allows you to retrieve or aggregate data and perform CRUD operations, saving time by removing the necessity of <span>boilerplate code.</span></p>
			<p class="calibre5">Beanie also handles MongoDB’s <strong class="source-inline">ObjectId</strong> type elegantly, and since its document class is based on Pydantic, you get to use all of the powerful validation and parsing features of Pydantic right out of <span>the box.</span></p>
			<p class="calibre5">In brief, some of Beanie’s salient features include <span>the following:</span></p>
			<ul class="calibre14">
				<li class="calibre17">Asynchronous, based on the Motor driver and ideal for performant <span>FastAPI apps</span></li>
				<li class="calibre17">Based on Pydantic and compatible with Pydantic <span>version 2</span></li>
				<li class="calibre17">Schema-based, with seamless handling of <strong class="source-inline">ObjectId</strong> <span>string conversions</span></li>
				<li class="calibre17">Simple CRUD operations, as well as support for MongoDB’s powerful <span>aggregation framework</span></li>
			</ul>
			<p class="calibre5">In the following section, you will begin creating a Beanie-powered application through which you will learn some features of <span>the ODM.</span></p>
			<h3 class="calibre8">Creating the Beanie application</h3>
			<p class="calibre5">You will learn how to use Beanie by creating a new application and exploring the functionality provided by the ODM—connecting to a database, mapping collections to document classes, and performing CRUD operations on <span>the documents.</span></p>
			<p class="calibre5">To begin the project and scaffold the FastAPI application, perform the <span>following steps:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Create a new folder (<strong class="source-inline">chapter9</strong>) and a virtual environment with the <span>following command:</span><pre class="source-code">
python -m venv venv</pre></li>				<li class="calibre15">Activate the virtual environment with the following command (for Linux <span>or Mac):</span><pre class="source-code">
source venv/bin/activate</pre><p class="list-inset">Or, for a Windows system, use <span>the following:</span></p><pre class="source-code">venv\Scripts\activate.bat</pre></li>				<li class="calibre15">Activate it and lay out an initial <strong class="source-inline">requirements.txt</strong> file with the <span>following packages:</span><pre class="source-code">
fastapi==0.111.0
<strong class="bold">fastapi_cors==0.0.6</strong>
beanie==1.26.00
bcrypt==4.0.1
cloudinary==1.40.0
uvicorn==0.30.1
pydantic-settings
PyJWT==2.8.0
python-multipart==0.0.9
openai==1.33.0
resend==2.0.0</pre></li>				<li class="calibre15">Install the required packages by running the <span>following command:</span><pre class="source-code">
pip install –r requirements.txt</pre><p class="list-inset">If you look closely at the <strong class="source-inline">requirements.txt</strong> file you will notice that you are installing a new package—<strong class="source-inline">fastapi-cors</strong>—that is useful for managing the <strong class="bold">Cross-Origin Resource Sharing </strong>(<strong class="bold">CORS</strong>) settings through <span>environment variables.</span></p></li>				<li class="calibre15">In the same working directory, create an empty <strong class="source-inline">.env</strong> file and then create a <strong class="source-inline">.gitignore</strong> file with the <span>following content:</span><pre class="source-code">
.env
.venv
env/
venv/</pre></li>			</ol>
			<p class="calibre5">After getting the basic packages and settings ready, you will now create the models <span>with Beanie.</span></p>
			<h2 id="_idParaDest-149" class="about-the-author"><a id="_idTextAnchor160" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Defining the models with Beanie</h2>
			<p class="calibre5">Before scaffolding the main FastAPI application, you will learn how Beanie handles data models. As mentioned earlier, Beanie’s <strong class="source-inline">Document</strong> class represents documents that will eventually be saved into a MongoDB database, and these models inherit Beanie’s <strong class="source-inline">Document</strong> class, which itself is a Pydantic’s <strong class="source-inline">BaseModel</strong>-based class. As stated on the Beanie website: "The <strong class="source-inline">Document</strong> class in Beanie is responsible for mapping and handling the data from the collection. It is inherited from the <strong class="source-inline">BaseModel</strong> Pydantic class, so it follows the same data typing and parsing <span>behavior." (</span><a href="https://beanie-odm.dev/tutorial/defining-a-document/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><span>https://beanie-odm.dev/tutorial/defining-a-document/</span></span></a><span>)</span></p>
			<p class="calibre5">Let’s begin creating the models, bearing in mind that the file will also contain several pure Pydantic models for validation of inputs and outputs (not all models will be Beanie-based, only the ones that map documents <span>in collections):</span></p>
			<ol class="calibre14">
				<li class="calibre15">Create a file named <strong class="source-inline">models.py</strong> in the root of the directory, and import the <span>necessary modules:</span><pre class="source-code">
from datetime import datetime
from typing import List, Optional
<strong class="bold">from beanie import Document, Link, PydanticObjectId</strong>
from pydantic import BaseModel, Field</pre><p class="list-inset">The only new import in this code is from Beanie: you are importing the <strong class="source-inline">Document</strong> class—the workhorse of Beanie for working with data—as well as <strong class="source-inline">Link</strong> (needed for referencing data, since you will not be embedding user data in car documents but referencing the users) and <strong class="source-inline">PydanticObjectId</strong>—a field type representing <strong class="source-inline">ObjectId</strong> compatible <span>with Pydantic.</span></p></li>				<li class="calibre15">Continue working on the <strong class="source-inline">models.py</strong> file and create the base <span>user model:</span><pre class="source-code">
class User(Document):
    username: str = Field(min_length=3, max_length=50)
    password: str
    email: str
    created: datetime = Field(default_factory=datetime.now)
    class Settings:
        name = "user"
    class Config:
        json_schema_extra = {
            "example": {
                "username": "John",
                "password": "password",
                "email": "john@mail.com",
            }
        }</pre><p class="list-inset">The <strong class="source-inline">User</strong> model inherits from the Beanie <strong class="source-inline">Document</strong> class instead of the <strong class="source-inline">BaseModel</strong> class of Pydantic, but the rest is largely the same. In fact, the <strong class="source-inline">Document</strong> class is based on the <strong class="source-inline">BaseModel</strong> class and inherits its functionality—you were able to use a Pydantic field with the default factory for creating the <span><strong class="source-inline">datetime</strong></span><span> type.</span></p><p class="list-inset">Then, you used the <strong class="source-inline">Settings</strong> class to specify the name of the collection that will be used in MongoDB. This class is quite powerful and allows setting caching, indexing, validations upon saving, and much more, as you can see on the documentation <span>page: </span><a href="https://beanie-odm.dev/tutorial/defining-a-document/#settings" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><span>https://beanie-odm.dev/tutorial/defining-a-document/#settings</span></span></a><span>.</span></p></li>				<li class="calibre15">Continuing with the same <strong class="source-inline">models.py</strong> file, you will now provide a couple of Pydantic models used for specific purposes: registering a new user, logging the user in, and providing information about the <span>current user:</span><pre class="source-code">
class RegisterUser(BaseModel):
    username: str
    password: str
    email: str
class LoginUser(BaseModel):
    username: str
    password: str
class CurrentUser(BaseModel):
    username: str
    email: str
    id: PydanticObjectId</pre></li>				<li class="calibre15">The previous code should feel familiar as it is completely based on Pydantic, so define the document model for <span>the cars:</span><pre class="source-code">
class Car(Document):
    brand: str
    make: str
    year: int
    cm3: int
    price: float
    description: Optional[str] = None
    picture_url: Optional[str] = None
    pros: List[str] = []
    cons: List[str] = []
    date: datetime = datetime.now()
    user: Link[User] = None
    class Settings:
        name = "car"</pre><p class="list-inset">The Beanie document model contains all the fields that you have used throughout the book, and a couple of new ones: two lists of strings that will include small text snippets of pros and cons for each car model—something along the lines of <em class="italic">c</em><em class="italic">ompact and easy to park</em>. Also, the car description is intentionally left blank—these fields will be populated later, in a background task, by an OpenAI <span>chat-completion prompt.</span></p><p class="list-inset">The interesting part of this model is the <strong class="source-inline">user</strong> part: the <strong class="source-inline">Link</strong> field type provides a direct link to the user. You can check the documentation to see what is possible with Beanie relations and what the current limitations <span>are: </span><a href="https://beanie-odm.dev/tutorial/relations/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><span>https://beanie-odm.dev/tutorial/relations/</span></span></a><span>.</span></p><p class="list-inset">Beanie manages relationships through links in the respective fields, and at the time of writing, only top-level fields are supported. Links to related documents can be links, optional links, and lists of links, as well as <span>backward links.</span></p><p class="list-inset">Backward links are reverse relationships: if an object called <strong class="source-inline">House</strong> has a link to an owner—a <strong class="source-inline">Person</strong> object, for instance—then that <strong class="source-inline">Person</strong> object can have a backward link to all the houses that they own, through <span>a backlink.</span></p></li>				<li class="calibre15">Finally, add an <strong class="source-inline">UpdateCar</strong> Pydantic model that will be used for <span>updating cars:</span><pre class="source-code">
class UpdateCar(BaseModel):
    price: Optional[float] = None
    description: Optional[str] = None
    pros: Optional[List[str]] = None
    cons: Optional[List[str]] = None</pre></li>			</ol>
			<p class="calibre5">Notice that you haven’t defined almost any validation on the fields—this is done only to save some space and simplify the model. Since Beanie is based on Pydantic, it can count on the full functionality of Pydantic and, thus, implement complex and <span>powerful validations.</span></p>
			<p class="calibre5">With the models now defined, you can proceed to connect to the MongoDB database. It is important to have the models defined upfront, as their names will be fed to the Beanie initialization code, as you will see in the <span>next section.</span></p>
			<h2 id="_idParaDest-150" class="about-the-author"><a id="_idTextAnchor161" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Connecting to the MongoDB database</h2>
			<p class="calibre5">The Beanie ODM uses the <strong class="bold">Motor</strong> asynchronous driver as its engine. To be able to operate on documents, it needs two things: a Motor database instance, and the list of document models that are going to be used and that can be seen by Beanie. The documentation page describes this process: <a href="https://beanie-odm.dev/tutorial/initialization/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span>https://beanie-odm.dev/tutorial/initialization/</span></a>. In order to configure Beanie and the environment variables, you are going to use <strong class="source-inline">pydantic-settings</strong> and its <strong class="source-inline">BasicSettings</strong> class for easy access to the environment variables inside <span>your application.</span></p>
			<p class="calibre5">The process is very similar to the one used in <a href="B22406_07.xhtml#_idTextAnchor118" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><em class="italic">Chapter 7</em></span></a>, <em class="italic">Building a Backend </em><span><em class="italic">with FastAPI</em></span><span>:</span></p>
			<ul class="calibre14">
				<li class="calibre17">Environment variables are stored in the <strong class="source-inline">.</strong><span><strong class="source-inline">env</strong></span><span> file.</span></li>
				<li class="calibre17"><strong class="source-inline">pydantic-settings</strong> is used to read the environment variables and create a settings object (through the <span><strong class="source-inline">config.py</strong></span><span> file).</span></li>
				<li class="calibre17">These settings, together with the models, are used to initialize the database connection <span>to Atlas.</span></li>
			</ul>
			<p class="calibre5">To create the database connection and use the models, perform the <span>following steps:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Define the configuration and environment variables by using <strong class="source-inline">pydantic-settings</strong>. Since you need the settings <em class="italic">before</em> initializing the database connection, and they are read from the environment, populate the <strong class="source-inline">.env</strong> file that will host the environment variables, which are then going to be read through the <strong class="source-inline">config.py</strong> file and instantiated into a <span>settings object.</span><p class="list-inset">The <strong class="source-inline">.env</strong> file should contain the <span>following entries:</span></p><pre class="source-code">
DB_URL=mongodb://localhost:27017/ or the Atlas address
CLOUDINARY_SECRET_KEY=&lt;cloudinary.secret.key&gt;
CLOUDINARY_API_KEY=&lt;cloudinary.api.key&gt;
CLOUDINARY_CLOUD_NAME=&lt;cloudinary.cloud.name&gt;
OPENAI_API_KEY=&lt;openai.api.key&gt;
RESEND_API_KEY=&lt;resend.api.key&gt;</pre><p class="list-inset">You will set up the OpenAI and Resend API keys later, but for now, you can insert the other values for MongoDB Atlas and the <span><strong class="bold">Cloudinary</strong></span><span> keys.</span></p></li>				<li class="calibre15">Create a file in the root of the same working folder in which you created the models and name it <strong class="source-inline">config.py</strong>. Open the <strong class="source-inline">config.py</strong> file and create the <strong class="source-inline">BaseConfig</strong> class for reading the environment values and easy overriding of these values, based on the <span>desired configuration:</span><pre class="source-code">
from typing import Optional
from pydantic_settings import BaseSettings, SettingsConfigDict
class BaseConfig(BaseSettings):
    DB_URL: Optional[str]
    CLOUDINARY_SECRET_KEY: Optional[str]
    CLOUDINARY_API_KEY: Optional[str]
    CLOUDINARY_CLOUD_NAME: Optional[str]
    OPENAI_API_KEY: Optional[str]
    RESEND_API_KEY: Optional[str]
    model_config = SettingsConfigDict(
        env_file=".env", extra="ignore"
    )</pre></li>				<li class="calibre15">The differences in connecting to a MongoDB database with Beanie compared to plain Motor-based connections become apparent in the <strong class="source-inline">database.py</strong> file that you will create in the same root directory and populate with the <span>following code:</span><pre class="source-code">
import motor.motor_asyncio
<strong class="bold">from beanie import init_beanie</strong>
from config import BaseConfig
from models import Car, User
settings = BaseConfig()
async def init_db():
    client = motor.motor_asyncio.AsyncIOMotorClient(
        settings.DB_URL
    )
    await <strong class="bold">init_beanie</strong>(database=client.carAds,
        document_models=[User, Car]
    )</pre></li>			</ol>
			<p class="calibre5">The initialization code is highlighted: the async <strong class="source-inline">init_beanie</strong> function needs the Motor client and the <span>document models.</span></p>
			<p class="calibre5">With the models defined and the database connection in place, you will now begin crafting the FastAPI application and <span>the routers.</span></p>
			<h2 id="_idParaDest-151" class="about-the-author"><a id="_idTextAnchor162" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Creating the FastAPI application</h2>
			<p class="calibre5">All the necessary pieces are ready, and now that you have the connection to the MongoDB database ready, you can start building the application. Use the freshly created <strong class="source-inline">database.py</strong> file for connecting to your MongoDB instance and wrap it into the lifespan context manager to ensure that the application connects when started and that the connection is deleted <span>on shutdown.</span></p>
			<p class="calibre5">To create the main FastAPI application file (<strong class="source-inline">app.py</strong>), perform the <span>following steps:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Create the <strong class="source-inline">app.py</strong> file in the root directory, which will be very similar to the one created in <a href="B22406_07.xhtml#_idTextAnchor118" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><em class="italic">Chapter 7</em></span></a>, <em class="italic">Building a Backend </em><span><em class="italic">with FastAPI</em></span><span>:</span><pre class="source-code">
from contextlib import asynccontextmanager
from fastapi import FastAPI
<strong class="bold">from fastapi_cors import CORS</strong>
<strong class="bold">from database import init_db</strong>
@asynccontextmanager
async def lifespan(app: FastAPI):
    <strong class="bold">await init_db()</strong>
    yield
app = FastAPI(lifespan=lifespan)
<strong class="bold">CORS(app)</strong></pre><p class="list-inset">Apart from the <strong class="source-inline">init_db</strong> function, you imported the <strong class="source-inline">fastapi_cors</strong> package, which allows easier management <span>of CORS.</span></p><p class="list-inset">All you need to do now is add one line to the <strong class="source-inline">.env</strong> file to specify the allowed <span>origins: </span><span><strong class="source-inline">ALLOW_ORIGINS=*</strong></span><span>.</span></p><p class="list-inset">You can explore the documentation of this simple package <span>here: </span><a href="https://pypi.org/project/fastapi-cors/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><span>https://pypi.org/project/fastapi-cors/</span></span></a><span>.</span></p></li>				<li class="calibre15">The connection initialization code is nested inside a lifespan event, like the previously used solution with Motor, while the rest of the code is just the inclusion of the routers that you will be creating soon and a <span>root endpoint:</span><pre class="source-code">
@app.get("/", tags=["Root"])
async def read_root() -&gt; dict:
    return {"message": "Welcome to your beanie powered app!"}</pre></li>				<li class="calibre15">If you have installed a recent version of FastAPI (0.111 or later) that installs the <strong class="source-inline">fastapi-cli</strong> package, you can now start the development FastAPI server with the <span>following command:</span><pre class="source-code">
fastapi dev</pre><p class="list-inset">Alternatively, you can use the following standard <span>code line:</span></p><pre class="source-code">uvicorn app:app --reload</pre></li>			</ol>
			<p class="calibre5">The preceding code uses the new <strong class="source-inline">fastapi-cli</strong> package for easier development (<a href="https://fastapi.tiangolo.com/fastapi-cli/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span>https://fastapi.tiangolo.com/fastapi-cli/</span></a>). <strong class="source-inline">fastapi-cors</strong> will provide a new endpoint called “health check.” If you try it out, you will see the environment variables related to CORS (<strong class="source-inline">ALLOWED_CREDENTIALS</strong>, <strong class="source-inline">ALLOWED_METHODS</strong>, <strong class="source-inline">ALLOWED_ORIGINS</strong>, and others), and they are now settable through the <strong class="source-inline">.</strong><span><strong class="source-inline">env</strong></span><span> file.</span></p>
			<p class="calibre5">The FastAPI main application is now ready, but it needs two routers: one for users and one for cars, as well as the authentication logic. First, you will handle the authentication class along with the <span><strong class="source-inline">users</strong></span><span> router.</span></p>
			<h3 class="calibre8">Creating the APIRouter class for the users and the authentication class</h3>
			<p class="calibre5">The authentication class will encapsulate the authentication logic, similar to the one shown in <a href="B22406_06.xhtml#_idTextAnchor105" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><em class="italic">Chapter 6</em></span></a>, <em class="italic">Authentication and Authorization</em>, and create the accompanying <strong class="bold">APIRouter</strong> for managing users—registration, logging in, <span>and verification.</span></p>
			<p class="calibre5">The <strong class="source-inline">authentication.py</strong> file will be identical to the previously used one for simplicity’s sake. The <strong class="source-inline">authentication.py</strong> file, located in the root of the project, contains the encoding and decoding JWT logic, the password encryption, and the dependency injection, as shown in <a href="B22406_07.xhtml#_idTextAnchor118" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><em class="italic">Chapter 7</em></span></a>, <em class="italic">Building a Backend </em><span><em class="italic">with FastAPI</em></span><span>.</span></p>
			<p class="calibre5">We provide the file contents here, for <span>your convenience:</span></p>
			<pre class="source-code">
import datetime
import jwt
from fastapi import HTTPException, Security
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
from passlib.context import CryptContext
class AuthHandler:
    security = HTTPBearer()
    pwd_context = CryptContext(
        schemes=["bcrypt"], deprecated="auto"
        )
    secret = "FARMSTACKsecretString"
    def get_password_hash(self, password):
        return self.pwd_context.hash(password)
    def verify_password(
        self, plain_password, hashed_password
    ):
        return self.pwd_context.verify(
            plain_password, hashed_password
        )
    def encode_token(self, user_id, username):
        payload = {
            "exp": datetime.datetime.now(datetime.timezone.utc)
            + datetime.timedelta(minutes=30),
            "iat": datetime.datetime.now(datetime.timezone.utc),
            "sub": {"user_id": user_id, "username": username},
        }
        return jwt.encode(payload, self.secret, algorithm="HS256")
    def decode_token(self, token):
        try:
            payload = jwt.decode(token, self.secret, algorithms=["HS256"])
            return payload["sub"]
        except jwt.ExpiredSignatureError:
            raise HTTPException(
              status_code=401,
              detail="Signature has expired"
            )
        except jwt.InvalidTokenError:
            raise HTTPException(status_code=401, detail="Invalid token")
    def auth_wrapper(self, auth: HTTPAuthorizationCredentials = Security(security)):
        return self.decode_token(auth.credentials)</pre>			<p class="calibre5">The <strong class="source-inline">user.py</strong> router will be placed in the <strong class="source-inline">/routers</strong> folder, and it will expose three endpoints: for registering new users, for logging users in, and for verifying the user—given a <strong class="source-inline">Bearer</strong> token in the header. This last route is optional, as you will not use it directly in the next chapter (on Next.js) since we are opting for a simple <span>cookie-based solution.</span></p>
			<p class="calibre5">To create the API router for users, perform the <span>following steps:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Create a <strong class="source-inline">routers/user.py</strong> file and populate it to create the router for the users. This router is again similar to the Motor version, and it shares the same logic, but some differences are highlighted in the <span>following code:</span><pre class="source-code">
from fastapi import APIRouter, Body, Depends, HTTPException
from fastapi.responses import JSONResponse
from authentication import AuthHandler
from models import CurrentUser, LoginUser, RegisterUser, User
auth_handler = AuthHandler()
router = APIRouter()
@router.post(
    "/register",
    response_description="Register user",
    response_model=CurrentUser
)
async def register(
    newUser: RegisterUser = Body(...),
    response_model=User):
    newUser.password = auth_handler.get_password_hash(
        newUser.password)
<strong class="bold">    query = {</strong>
<strong class="bold">"$or": [{"username": newUser.username},</strong>
<strong class="bold">    	{"email": newUser.email}]}</strong>
<strong class="bold">    existing_user = await User.find_one(query)</strong>
    if existing_user is not None:
        raise HTTPException(
            status_code=409,
            detail=f"{newUser.username} or {newUser.email}
            already exists"
        )
    <strong class="bold">user = await User(**newUser.model_dump()).save()</strong>
    return user</pre><p class="list-inset">The router showcases some of Beanie’s features: the direct querying of the <strong class="source-inline">User</strong> model (the <strong class="source-inline">users</strong> collection) with a MongoDB query, and the simple async creation of a new instance if the checks for existing users pass. In this case, you have two conditions: the username and the email must be available (not present in the collection). The querying syntax of Beanie is very <span>intuitive: </span><a href="https://beanie-odm.dev/tutorial/finding-documents/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><span>https://beanie-odm.dev/tutorial/finding-documents/</span></span></a><span>.</span></p></li>				<li class="calibre15">Create the login route in the <span><strong class="source-inline">user.py</strong></span><span> file:</span><pre class="source-code">
@router.post("/login", response_description="Login user and return token")
async def login(loginUser: LoginUser = Body(...)) -&gt; str:
    <strong class="bold">user = await User.find_one(</strong>
<strong class="bold">        User.username == loginUser.username</strong>
<strong class="bold">    )</strong>
    if user and auth_handler.verify_password(
        loginUser.password, user.password):
        token = auth_handler.encode_token(
          str(user.id),
          user.username
          )
        response = JSONResponse(
            content={
                "token": token,
                "username": user.username})
        return response
    else:
        raise HTTPException(
            status_code=401,
            detail="Invalid username or password")</pre><p class="list-inset">The login functionality uses the <strong class="source-inline">find_one</strong> MongoDB method, which is available <span>in Beanie.</span></p></li>				<li class="calibre15">Finally, add the <strong class="source-inline">/me</strong> route, for verifying the logged-in user. This method uses the <strong class="source-inline">get</strong> method, which accepts <span>an </span><span><strong class="source-inline">ObjectId</strong></span><span>:</span><pre class="source-code">
@router.get(
    "/me", response_description="Logged in user data", response_model=CurrentUser
)
async def me(
    user_data=Depends(auth_handler.auth_wrapper)
):
    currentUser = await User.get(user_data["user_id"])
    return currentUser</pre></li>			</ol>
			<p class="calibre5">This completes the <strong class="source-inline">users.py</strong> APIRouter, which uses several Beanie querying methods. Now, you will create the <strong class="source-inline">Car</strong> router with <span>Beanie ODM.</span></p>
			<h3 class="calibre8">The Car APIRouter</h3>
			<p class="calibre5">Similar to what you have accomplished in the previous chapters, the <strong class="source-inline">Cars</strong> router will be in charge of performing some CRUD operations. For simplicity, you will implement only partial updates of the car instances: you will be able to update the fields defined in the <strong class="source-inline">UpdateCar</strong> model. Since the description and the lists of pros and cons will initially be empty, they need to be able to be updated later (by a call to <span>OpenAI’s API).</span></p>
			<p class="calibre5">To create the <strong class="source-inline">Cars</strong> router, in the <strong class="source-inline">/routers</strong> folder and the <strong class="source-inline">cars.py</strong> file, perform the <span>following steps:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Begin by creating a <strong class="source-inline">/routers/cars.py</strong> file and list the initial imports (there will be some more added later, when you start implementing <span>background tasks):</span><pre class="source-code">
from typing import List
import cloudinary
<strong class="bold">from beanie import PydanticObjectId, WriteRules</strong>
from cloudinary import uploader  # noqa: F401
from fastapi import (APIRouter, Depends, File, Form,
    HTTPException, UploadFile, status)
from authentication import AuthHandler
from config import BaseConfig
from models import Car, UpdateCar, User</pre><p class="list-inset">These imports are similar to the ones used when working with Motor directly; the main difference is the Beanie imports: <strong class="source-inline">PydanticObjectId</strong> (for handling ObjectIds with Pydantic) and <strong class="source-inline">WriteRules</strong>, which will enable the relationship of <strong class="source-inline">Car</strong> and <strong class="source-inline">User</strong> to be written to the MongoDB database as <span>a reference.</span></p></li>				<li class="calibre15">Continuing with the file, you can now instantiate the authentication handler (<strong class="source-inline">auth_handler</strong>) class, the settings, and the router, as well as the <span>Cloudinary configuration:</span><pre class="source-code">
auth_handler = AuthHandler()
settings = BaseConfig()
cloudinary.config(
    cloud_name=settings.CLOUDINARY_CLOUD_NAME,
    api_key=settings.CLOUDINARY_API_KEY,
    api_secret=settings.CLOUDINARY_SECRET_KEY,
)
router = APIRouter()</pre></li>				<li class="calibre15">After having the necessary settings and authentication ready, you can create the first route—the <strong class="source-inline">GET</strong> handler, which in this case simply retrieves all the cars in <span>the database:</span><pre class="source-code">
@router.get("/", response_model=List[Car])
async def get_cars():
    return await <strong class="bold">Car.find_all()</strong>.to_list()</pre><p class="list-inset">The <strong class="source-inline">find_all()</strong> Beanie method is asynchronous, like all Beanie methods, and it simply returns all the documents in the database. Other querying methods are <strong class="source-inline">.find(search query)</strong> and <strong class="source-inline">.first_or_none()</strong>, which are often used to check for the existence of a certain condition (such as a user with a given username or email). Finally, the <strong class="source-inline">to_list()</strong> method, like with Motor, returns a list of documents, but you could also use the <strong class="source-inline">async for</strong> construct (shown in <a href="B22406_04.xhtml#_idTextAnchor071" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><em class="italic">Chapter 4</em></span></a>, <em class="italic">Getting Started with FastAPI</em>) and generate a list <span>that way.</span></p></li>				<li class="calibre15">Create the <strong class="source-inline">GET</strong> method for getting one car instance by <span>its ID:</span><pre class="source-code">
@router.get("/{car_id}", response_model=Car)
async def get_car(car_id: PydanticObjectId):
    <strong class="bold">car = await Car.get(car_id)</strong>
    if not car:
        raise HTTPException(status_code=404, detail="Car not found")
    return car</pre><p class="list-inset">This implementation is also simple—it uses the <strong class="source-inline">get()</strong> shortcut to query the collection by <strong class="source-inline">ObjectId</strong>, which is elegantly handled <span>by Beanie.</span></p></li>				<li class="calibre15">The method for creating the new car instances is a bit more complex, but not too heavy. Since you are uploading an image (a file), you are using form data instead of JSON and the endpoint must upload the image to Cloudinary, obtain an image URL from Cloudinary, and only then insert it into the MongoDB database along with the <span>other data:</span><pre class="source-code">
@router.post(
    "/",
    response_description="Add new car with picture",
    response_model=Car,
    status_code=status.HTTP_201_CREATED,
)
async def add_car_with_picture(
    brand: str = Form("brand"),
    make: str = Form("make"),
    year: int = Form("year"),
    cm3: int = Form("cm3"),
    km: int = Form("km"),
    price: int = Form("price"),
    picture: UploadFile = File("picture"),
    user_data=Depends(auth_handler.auth_wrapper),
):
    cloudinary_image = cloudinary.uploader.upload(
      picture.file,
      folder="FARM2",
      crop="fill",
      width=800,
      gravity="auto" )
    picture_url = cloudinary_image["url"]
    <strong class="bold">user = await User.get(user_data["user_id"])</strong>
    car = Car(
        brand=brand,
        make=make,
        year=year,
        cm3=cm3,
        km=km,
        price=price,
        picture_url=picture_url,
        user=user,
    )
    return await car.insert(link_rule=WriteRules.WRITE)</pre><p class="list-inset">The route for creating new resources uses the Beanie methods for getting a user by the ID (provided in the <strong class="source-inline">Bearer</strong> token in the header) and the <strong class="source-inline">insert()</strong> method for inserting a <span>new car.</span></p><p class="list-inset">Finally, <strong class="source-inline">link_rule</strong> allows you to save the salesperson’s <span>ID (</span><a href="https://beanie-odm.dev/tutorial/relations/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><span>https://beanie-odm.dev/tutorial/relations/</span></span></a><span>).</span></p></li>				<li class="calibre15">The <strong class="source-inline">update</strong> method is similar to its Motor counterpart, and it could be easily incorporated into a dashboard to update or delete car <span>model adverts:</span><pre class="source-code">
@router.put("/{car_id}", response_model=Car)
async def update_car(
    car_id: PydanticObjectId,
    cardata: UpdateCar):
    car = await Car.get(car_id)
    if not car:
        raise HTTPException(
            status_code=404,
            detail="Car not found")
    updated_car = {
        k: v for k, v in cardata.model_dump().items()   if v is not None}
    return await car.set(updated_car)</pre><p class="list-inset">Once again, you only update the fields that are provided in the request, using the Pydantic <strong class="source-inline">model_dump</strong> method to verify which fields are actually provided, leaving the other ones (which are <strong class="source-inline">null</strong> or <strong class="source-inline">None</strong>, in Python <span>terminology) unaltered.</span></p></li>				<li class="calibre15">In the <strong class="source-inline">delete</strong> method, you only need to provide the selected document and invoke the <span><strong class="source-inline">delete()</strong></span><span> method:</span><pre class="source-code">
@router.delete("/{car_id}")
async def delete_car(car_id: PydanticObjectId):
    car = await Car.get(car_id)
    if not car:
        raise HTTPException(status_code=404, detail="Car not found")
    await car.delete()</pre></li>			</ol>
			<p class="calibre5">You have now completed your API routers, and you are ready to implement some more advanced functionality, which FastAPI and the FARM stack in general make a quick and fun task. Before being able to use the routers, however, you will need to import them into the <strong class="source-inline">app.py</strong> file. Open the <strong class="source-inline">app.py</strong> file and modify the imports at the top, adding the routers and aliasing them as cars <span>and users:</span></p>
			<pre class="source-code">
from contextlib import asynccontextmanager
from fastapi import FastAPI
from database import init_db
<strong class="bold">from routers import cars as cars_router</strong>
<strong class="bold">from routers import user as user_router</strong>
from fastapi_cors import CORS</pre>			<p class="calibre5">Finally, integrate them in the application by modifying the same <span><strong class="source-inline">app.py</strong></span><span> file:</span></p>
			<pre class="source-code">
@asynccontextmanager
async def lifespan(app: FastAPI):
    await init_db()
    yield
app = FastAPI(lifespan=lifespan)
CORS(app)
<strong class="bold">app.include_router(</strong>
<strong class="bold">    cars_router.router,</strong>
<strong class="bold">    prefix="/cars",</strong>
<strong class="bold">    tags=["Cars"]</strong>
<strong class="bold">)</strong>
<strong class="bold">app.include_router(</strong>
<strong class="bold">    user_router.router,</strong>
<strong class="bold">    prefix="/users",</strong>
<strong class="bold">    tags=["Users"]</strong>
<strong class="bold">)</strong>
@app.get("/", tags=["Root"])
async def read_root() -&gt; dict:
    return {"message": "Welcome to your beanie powered app!"}</pre>			<p class="calibre5">With the routers hooked up, you will integrate a simple, yet functional, AI assistant that will provide marketing information about the newly inserted cars, and automatically send emails to the salespersons, to a list of customers, or to a group <span>of subscribers.</span></p>
			<h2 id="_idParaDest-152" class="about-the-author"><a id="_idTextAnchor163" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Background tasks with FastAPI</h2>
			<p class="calibre5">One of the most interesting features of FastAPI is how it handles background tasks—functions that should be run asynchronously after the response has already been sent to <span>the client.</span></p>
			<p class="calibre5">There are many use cases for background tasks. Any operation that could potentially take some time, such as waiting for an external API call to return a response, sending emails, or creating a complex document based on data processing in the endpoint, is a potential candidate for a background task. In all these cases, it would be bad practice and lead to a horrible user experience to just let the application hang while waiting for the result. Instead, these tasks are handed to the background to be processed while the response is <span>returned immediately.</span></p>
			<p class="calibre5">While very useful for simple tasks, background tasks shouldn’t be used for processes that require significant processing power and/or multitasking. In this case, a more robust tool such as <strong class="bold">Celery</strong> (<a href="https://docs.celeryq.dev/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span>https://docs.celeryq.dev/</span></a>) might be the best solution. Celery is a Python task queue framework that distributes work across threads or <span>different machines.</span></p>
			<p class="calibre5">FastAPI defines a class called <strong class="source-inline">BackgroundTasks</strong>, inherited from the <strong class="bold">Starlette</strong> web framework, which works simply and intuitively, as you will see in the following section when you use it to plug external services into your <span>FastAPI application.</span></p>
			<p class="calibre5">Before using background tasks for interfacing with third-party services, create a very simple task for <span>demonstration purposes:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Create a file called <strong class="source-inline">background.py</strong> in the root of the project and populate it with the <span>following code:</span><pre class="source-code">
from time import sleep
def delayed_task(username: str) -&gt; None:
    sleep(5)
    print(
        f"User just logged in: {username}"
    )</pre><p class="list-inset">This function is very simple—it sleeps for five seconds and then prints a message on <span>the console.</span></p><p class="list-inset">The syntax for integrating the task into an endpoint will be shown in the following <span>API router.</span></p></li>				<li class="calibre15">Open the <strong class="source-inline">/routers/user.py</strong> file because you will attach this simple background task to the <span><strong class="source-inline">login</strong></span><span> function.</span><p class="list-inset">This function could also perform some logging or some more complex and time-consuming operations that would block the response until completion, but in this case, a simple <strong class="source-inline">print</strong> statement will <span>be used.</span></p></li>
				<li class="calibre15">At the top of the file, import the background tasks and modify only the <strong class="source-inline">login</strong> endpoint in the <span>following way:</span><pre class="source-code">
from fastapi import APIRouter, <strong class="bold">BackgroundTasks</strong>, Body, Depends, HTTPException
from background import delayed_task
# code continues …
@router.post("/login", response_description="Login user and return token")
async def login(
    <strong class="bold">background_tasks: BackgroundTasks</strong>,
    loginUser: LoginUser = Body(...)
) -&gt; str:
    user = await User.find_one(
        User.username == loginUser.username
    )
    if user and auth_handler.verify_password(
        loginUser.password, user.password
    ):
        token = auth_handler.encode_token(
            str(user.id), user.username
        )
        <strong class="bold">background_tasks.add_task(</strong>
<strong class="bold">            delayed_task,</strong>
<strong class="bold">            username=user.username</strong>
        )
        response = JSONResponse(
            content={
                "token": token,
                "username": user.username
                }
            )
        return response
    else:
        raise HTTPException(
                status_code=401,
                detail="Invalid username or password"
    )</pre><p class="list-inset">The background tasks syntax is as follows: the first argument is the name of the function to be invoked, and the next arguments are the arguments passed to <span>this function.</span></p><p class="list-inset">Now, run the development server with the following line <span>of code:</span></p><pre class="source-code">fastapi dev</pre><p class="list-inset">You can navigate to the address of the interactive documentation (<span>127.0.0.1:8000/docs</span>) and try to <span>log in.</span></p></li>				<li class="calibre15">If you have also installed HTTPie, you can leave one terminal running the FastAPI application in development mode, open another terminal, and issue a login POST request, making sure to use the correct username and password of a user that you have created before. For example, the following command tests logging in for the <span>user </span><span><strong class="source-inline">tanja</strong></span><span>:</span><pre class="source-code">
http POST 127.0.0.1:8000/users/login username=tanja password=tanja123</pre><p class="list-inset">If you look at the first terminal, you will see the following message after <span>five seconds:</span></p><pre class="source-code">User just logged in: tanja</pre></li>			</ol>
			<p class="calibre5">You have just created a straightforward, but potentially useful, background task and learned <span>the syntax.</span></p>
			<p class="calibre5">In the next section, you will create two background tasks that will create a new car description using OpenAI’s API and email the logged-in user—the user that inserted the car—with the description and the <span>car data.</span></p>
			<h2 id="_idParaDest-153" class="about-the-author"><a id="_idTextAnchor164" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Integrating OpenAI with FastAPI</h2>
			<p class="calibre5">LLMs have been the buzzword in the last couple of years and they have been dominating the web development discourse, and it is becoming hard to find successful applications that aren’t using some form of LLM integration. Modern applications make use of image, text, and audio processing, and they might provide an edge to your next web application <span>as well.</span></p>
			<p class="calibre5">In your car-selling and advertising application, you are going to use one of the simplest features of a behemoth such as OpenAI—the task at hand is to make things a bit easier on the salespersons and provide them a baseline marketing line for each new car that gets put <span>on sale:</span></p>
			<ol class="calibre14">
				<li class="calibre15">After having obtained the OpenAI key and setting your environment variable, modify the <span><strong class="source-inline">background.py</strong></span><span> file:</span><pre class="source-code">
import json
<strong class="bold">from openai import OpenAI</strong>
from config import BaseConfig
from models import Car
settings = BaseConfig()
<strong class="bold">client = OpenAI(api_key=settings.OPENAI_API_KEY)</strong></pre><p class="list-inset">In the previous code, you imported a couple of necessary libraries: <strong class="source-inline">json</strong> for decoding the OpenAI response, the <strong class="source-inline">openai</strong> module, as well as the <strong class="source-inline">config</strong> module for reading the API keys. After instantiating the settings and the OpenAI client, you will create a helper function that will generate the prompt <span>for OpenAI.</span></p><p class="list-inset">Although these tasks are handled much more elegantly with a library called LangChain—the de facto standard when working with LLMs in Python—for simplicity’s sake, you will use a simple Python <strong class="source-inline">f-string</strong> to regenerate the prompt on <span>each request.</span></p><p class="list-inset">Remember, the prompt needs to provide a text description and two arrays—one for the positive aspects and one for the negative aspects of <span>the car.</span></p></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">You can easily swap OpenAI for another LLM, such as <span><strong class="bold">Google Gemini</strong></span><span>.</span></p>
			<ol class="calibre14">
				<li value="2" class="calibre15">The following is one way to create a prompt for generating car data, but you will probably want to get more creative or conservative in the descriptions provided by OpenAI, depending on <span>your case:</span><pre class="source-code">
def generate_prompt(brand: str, model: str, year: int) -&gt; str:
    return f"""
    You are a helpful car sales assistant. Describe the <strong class="bold">{brand} {model}</strong> from {year} in a playful manner.
    Also, provide five pros and five cons of the model, but formulate the cons in a not overly negative way.
    You will respond with a JSON format consisting of the following:
    a brief description of the <strong class="bold">{brand}</strong> <strong class="bold">{model}</strong>, playful and positive, but not over the top.
    This will be called *description*. Make it at least 350 characters.
    an array of 5 brief *pros* of the car model, short and concise, maximum 12 words, slightly positive and playful
    an array of 5 brief *cons* drawbacks of the car model, short and concise, maximum 12 words, not too negative, but in a slightly negative tone
    make the *pros* sound very positive and the *cons* sound negative, but not too much
    """</pre></li>				<li class="calibre15">Now that the prompt is ready to be generated, it is time to perform a call to the OpenAI API. Please always refer to the latest OpenAI API documentation (<a href="https://platform.openai.com/docs/overview" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span>https://platform.openai.com/docs/overview</span></a>), as it is subject to frequent modifications. Currently, at the time of writing, the following code demonstrates the way to communicate with the API, which you should paste into your <span><strong class="source-inline">background.py</strong></span><span> file:</span><pre class="source-code">
async def create_description(
    brand,
    make,
    year,
    picture_url):
    prompt = generate_prompt(brand, make, year)
    try:
        response = client.chat.completions.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}],
            max_tokens=500,
            temperature=0.2,
        )
        content = response.choices[0].message.content
        car_info = json.loads(content)
        await Car.find(
            Car.brand == brand,
            Car.make == make,
            Car.year == year
        ).set(
            {
                "description": car_info["description"],
                "pros": car_info["pros"],
                "cons": car_info["cons"],
            }
        )
    except Exception as e:
        print(e)</pre><p class="list-inset">The preceding code makes a call to the OpenAI client through the chat completion method. You have selected a model (<strong class="source-inline">gpt-4</strong>), started the <strong class="source-inline">messages</strong> array, and set <strong class="source-inline">max_tokens</strong> and <strong class="source-inline">temperature</strong>. Again, for all the parameter settings, refer to the latest OpenAI documentation. In this case, you are limiting the number of tokens to 500 and setting the temperature to <strong class="source-inline">0.2</strong> (this quantity impacts the “creativity” and the “conservativeness” of <span>the responses).</span></p><p class="list-inset">After receiving the response from OpenAI, you parsed the JSON content (<strong class="source-inline">car_info</strong>) into a Python dictionary containing the desired keys: description (text) and two arrays of strings (pros and cons). Armed with this newly generated data, you performed a MongoDB update (through Beanie) that selects all the cars that match the brand, the make, and the production year, and you set their description, pros, and cons to the data returned by OpenAI. In case of an error, we simply display <span>the error.</span></p></li>				<li class="calibre15">Now plug the background task into the <strong class="source-inline">POST</strong> endpoint. Open the <strong class="source-inline">/routers/cars.py</strong> file and import the newly created background function at <span>the top:</span><pre class="source-code">
from background import create_description</pre></li>				<li class="calibre15">The rest of the code will remain unaltered; you are only modifying the <span><strong class="source-inline">POST</strong></span><span> endpoint:</span><pre class="source-code">
@router.post(
    "/",
    response_description="Add new car with picture",
    response_model=Car,
    status_code=status.HTTP_201_CREATED,
)
async def add_car_with_picture(
    <strong class="bold">background_tasks: BackgroundTasks,</strong>
    brand: str = Form("brand"),
    make: str = Form("make"),
    year: int = Form("year"),
    cm3: int = Form("cm3"),
    km: int = Form("km"),
    price: int = Form("price"),
    picture: UploadFile = File("picture"),
    user_data=Depends(auth_handler.auth_wrapper),
):
    cloudinary_image = cloudinary.uploader.upload(
      picture.file,
      folder="FARM2",
      crop="fill",
      width=800,
      height=600,
      gravity="auto"
    )
    picture_url = cloudinary_image["url"]
    user = await User.get(user_data["user_id"])
    car = Car(
        brand=brand,
        make=make,
        year=year,
        cm3=cm3,
        km=km,
        price=price,
        picture_url=picture_url,
        user=user,
    )
<strong class="bold">    background_tasks.add_task(</strong>
<strong class="bold">        create_description, brand=brand, make=make,</strong>
<strong class="bold">        year=year, picture_url=picture_url</strong>
<strong class="bold">    )</strong>
    return await car.insert(link_rule=WriteRules.WRITE)</pre></li>			</ol>
			<p class="calibre5">This could be performed in a much more granular way: you could await the generated ID of the newly inserted car and update only that particular instance. The function also lacks some basic validation for cases in which the provided car brand and make don’t exist, or in cases in which OpenAI doesn’t provide a valid response. The point is that the endpoint function returns the response immediately—that is, almost immediately, after performing the MongoDB insertion, and the description and the two arrays are <span>updated later.</span></p>
			<p class="calibre5">If you try to rerun the development server and insert a car, you should see the newly created document (in Compass or Atlas) and, after a couple of seconds, the document will be updated with the initially empty fields: <strong class="source-inline">description</strong>, <strong class="source-inline">pros</strong>, <span>and </span><span><strong class="source-inline">cons</strong></span><span>.</span></p>
			<p class="calibre5">You can imagine different scenarios that could be covered by this functionality: maybe the car description needs to be approved by a human being and then the advert is set to be published (by adding a published Boolean variable), maybe you want to send the email to all the registered users, and <span>so on.</span></p>
			<p class="calibre5">The next section will take this background job a bit further and show you how you can quickly integrate emails into <span>your application.</span></p>
			<h3 class="calibre8">Integrating emails into FastAPI</h3>
			<p class="calibre5">One of the most frequent requirements of modern web applications is sending automated emails. Today, there are numerous options for sending emails, and two of the most popular options are <strong class="bold">Mailgun</strong> and <strong class="bold">SendGrid</strong> <span>by Twilio.</span></p>
			<p class="calibre5">Through this application, you will learn how to set up email functionality using a relatively new service called <strong class="bold">Resend</strong>. Their API-centric approach is very developer-friendly and easy to <span>start with.</span></p>
			<p class="calibre5">Navigate to the Resend home page (<a href="https://resend.com" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span>https://resend.com</span></a>) and create a free account. After logging in, navigate to the <strong class="bold">API keys</strong> page (<a href="https://resend.com/api-keys" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span>https://resend.com/api-keys</span></a>), generate a key, and give it a memorable name, such as <strong class="source-inline">FARMstack</strong>. The key will be visible only once, so make sure to copy it and store it in the <strong class="source-inline">.</strong><span><strong class="source-inline">env</strong></span><span> file.</span></p>
			<p class="calibre5">Perform the following steps to add Resend functionality to <span>your application:</span></p>
			<ol class="calibre14">
				<li class="calibre15">Install the <span><strong class="source-inline">resend</strong></span><span> package:</span><pre class="source-code">
pip install resend==2.0.0</pre></li>				<li class="calibre15">After installing the <strong class="source-inline">resend</strong> package, update the <span><strong class="source-inline">background.py</strong></span><span> file:</span><pre class="source-code">
import json
<strong class="bold">import resend</strong>
from openai import OpenAI
from config import BaseConfig
from models import Car
settings = BaseConfig()
client = OpenAI(api_key=settings.OPENAI_API_KEY)
<strong class="bold">resend.api_key = settings.RESEND_API_KEY</strong>
# code continues …</pre></li>				<li class="calibre15">Update the <strong class="source-inline">create_description</strong> function to send a message once the response is returned <span>from OpenAI:</span><pre class="source-code">
async def create_description(brand, make, year, picture_url):
    prompt = generate_prompt(brand, make, year)
    try:
        response = client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "user", "content": prompt}],
            max_tokens=500,
            temperature=0.2,
        )
        content = response.choices[0].message.content
        car_info = json.loads(content)
        await Car.find(
            Car.brand == brand,
            Car.make == make,
             Car.year == year).set(
            {
                "description": car_info["description"],
                "pros": car_info["pros"],
                "cons": car_info["cons"],
            }
        )
        <strong class="bold">def generate_email():</strong>
<strong class="bold">            pros_list = "&lt;br&gt;".join([f"- {pro}" for pro in car_info["pros"]])</strong>
<strong class="bold">            cons_list = "&lt;br&gt;".join([f"- {con}" for con in car_info["cons"]])</strong>
<strong class="bold">            return f"""</strong>
<strong class="bold">            Hello,</strong>
<strong class="bold">            We have a new car for you: {brand} {make} from {year}.</strong>
<strong class="bold">            &lt;p&gt;&lt;img src="{picture_url}"/&gt;&lt;/p&gt;</strong>
<strong class="bold">            {car_info['description']}</strong>
<strong class="bold">            &lt;h3&gt;Pros&lt;/h3&gt;</strong>
<strong class="bold">            {pros_list}</strong>
<strong class="bold">            &lt;h3&gt;Cons&lt;/h3&gt;</strong>
<strong class="bold">            {cons_list}</strong>
<strong class="bold">            """</strong>
        <strong class="bold">params: resend.Emails.SendParams = {</strong>
<strong class="bold">            "from":"FARM Cars &lt;onboarding@resend.dev&gt;",</strong>
<strong class="bold">            "to": ["youremail@gmail.com"],</strong>
<strong class="bold">            "subject": "New Car On Sale!",</strong>
<strong class="bold">            "html": generate_email(),</strong>
<strong class="bold">        }</strong>
<strong class="bold">        resend.Emails.send(params)</strong>
    except Exception as e:
        print(e)</pre></li>			</ol>
			<p class="calibre5">The recipient email should be the same email that you have signed up with Resend as it will be the only option until you register and verify your domain, but more than enough for development and testing <span>purposes: </span><a href="https://resend.com/docs/knowledge-base/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><span>https://resend.com/docs/knowledge-base/</span></span></a><span>.</span></p>
			<p class="calibre5">The <strong class="source-inline">resend</strong> package makes sending emails simple—you just perform a single call to the <strong class="source-inline">resend.Emails.Send</strong> function and define the parameters. In your case, the parameters are <span>the following:</span></p>
			<ul class="calibre14">
				<li class="calibre17"><strong class="source-inline">to</strong> – a list of <span>recipient emails.</span></li>
				<li class="calibre17"><strong class="source-inline">from</strong> – the email address of the sender. In this case, you will leave the default provided by Resend, but later on, you will replace it with your own <span>domain address.</span></li>
				<li class="calibre17"><strong class="source-inline">subject</strong> – the subject of <span>the email.</span></li>
				<li class="calibre17"><strong class="source-inline">html</strong> – the HTML content of <span>the email.</span></li>
			</ul>
			<p class="calibre5">The parameters are fed to the <strong class="source-inline">resend.Email.send()</strong> function as <span>a dictionary.</span></p>
			<p class="calibre5">The email HTML in this app is constructed directly from an <strong class="source-inline">f-string</strong> in Python, but you could always resort to more sophisticated and complex solutions with <strong class="bold">Jinja2</strong> (for a purely Python solution, since the backend is written in Python) or use React Email by Resend (<a href="https://react.email/" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span>https://react.email/</span></a>). Jinja2 is arguably the most popular Python HTML templating engine, and it is used by the Flask web framework, while React Email provides React-based <span>email templates.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Please refer to <a href="B22406_07.xhtml#_idTextAnchor118" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"><span><em class="italic">Chapter 7</em></span></a>, <em class="italic">Building a Backend with FastAPI,</em> on deploying your backend to Render.com. The procedure will remain largely unchanged: just keep track of the environment variables and make sure to add the newly created ones (the OpenAI and Render keys). Alternatively, you can run the backend from this chapter in order to use it in the <span>next chapter.</span></p>
			<h1 id="_idParaDest-154" class="contributor"><a id="_idTextAnchor165" class="calibre7 pcalibre3 pcalibre pcalibre4 pcalibre1 pcalibre2"/>Summary</h1>
			<p class="calibre5">In this chapter, you learned the basics of Beanie, a popular ODM library for MongoDB, built on top of Motor and Pydantic. You learned how to define models and define Beanie documents that map to MongoDB collections and how to query and perform CRUD operations with <span>the ODM.</span></p>
			<p class="calibre5">You built another FastAPI application in which you integrated third-party services with the help of background tasks, which is a FastAPI feature that allows slow- and long-running tasks to be executed in the background, while maintaining the <span>app’s responsiveness.</span></p>
			<p class="calibre5">This chapter also covered integrating the most popular AI service, ChatGPT, into your applications, providing intelligent additional data about your newly inserted entities. Finally, you learned how to implement a simple email-sending solution, which is common in many <span>web applications.</span></p>
			<p class="calibre5">In the next chapter, you will dive into the most popular and advanced web framework based on React.js: <strong class="bold">Next.js</strong>. You will learn the basics of the latest version of Next.js (14) and discover the most important features that set it apart from other frontend or even full <span>stack solutions.</span></p>
		</div>
	</div>
</div>
</body></html>