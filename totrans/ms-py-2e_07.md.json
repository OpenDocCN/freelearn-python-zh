["```py\n>>> def generator():\n...     yield 1\n...     yield 'a'\n...     yield []\n...     return 'end'\n\n>>> result = generator()\n\n>>> result\n<generator object generator at ...>\n\n>>> len(result)\nTraceback (most recent call last):\n    ...\nTypeError: object of type 'generator' has no len()\n\n>>> result[:10]\nTraceback (most recent call last):\n    ...\nTypeError: 'generator' object is not subscriptable\n\n>>> list(result)\n[1, 'a', []]\n\n>>> list(result)\n[] \n```", "```py\n>>> def generator_with_return():\n...     yield 'some_value'\n...     return 'The end of our generator'\n\n>>> result = generator_with_return()\n\n>>> next(result)\n'some_value'\n>>> next(result)\nTraceback (most recent call last):\n    ...\nStopIteration: The end of our generator \n```", "```py\n>>> def lazy():\n...     print('before the yield')\n...     yield 'yielding'\n...     print('after the yield')\n\n>>> generator = lazy()\n\n>>> next(generator)\nbefore the yield\n'yielding'\n\n>>> next(generator)\nTraceback (most recent call last):\n    ...\nStopIteration \n```", "```py\n>>> def lazy():\n...     print('before the yield')\n...     yield 'yielding'\n...     print('after the yield')\n\n>>> generator = lazy()\n\n>>> next(generator)\nbefore the yield\n'yielding'\n\n>>> try:\n...     next(generator)\n... except StopIteration:\n...     pass\nafter the yield\n\n>>> for item in lazy():\n...     print(item)\nbefore the yield\nyielding\nafter the yield \n```", "```py\n>>> def count(start=0, step=1, stop=None):\n...     n = start\n...     while stop is not None and n < stop:\n...         yield n\n...         n += step\n\n>>> list(count(10, 2.5, 20))\n[10, 12.5, 15.0, 17.5] \n```", "```py\n>>> def square(iterable):\n...     for i in iterable:\n...         yield i ** 2\n\n>>> list(square(range(5)))\n[0, 1, 4, 9, 16] \n```", "```py\n>>> def padded_square(iterable):\n...     yield 'begin'\n...     for i in iterable:\n...         yield i ** 2\n...     yield 'end'\n\n>>> list(padded_square(range(5)))\n['begin', 0, 1, 4, 9, 16, 'end'] \n```", "```py\n>>> import itertools\n\n>>> def odd(iterable):\n...     for i in iterable:\n...         if i % 2:\n...             yield i\n\n>>> def square(iterable):\n...     for i in iterable:\n...         yield i ** 2\n\n>>> list(square(odd(range(10))))\n[1, 9, 25, 49, 81] \n```", "```py\n>>> squares = (x ** 2 for x in range(4))\n\n>>> squares\n<generator object <genexpr> at 0x...>\n\n>>> list(squares)\n[0, 1, 4, 9] \n```", "```py\n>>> import itertools\n\n>>> result = itertools.count()\n>>> odd = (x for x in result if x % 2)\n>>> sliced_odd = itertools.islice(odd, 5)\n>>> list(sliced_odd)\n[1, 3, 5, 7, 9]\n\n>>> result = itertools.count()\n>>> sliced_result = itertools.islice(result, 5)\n>>> odd = (x for x in sliced_result if x % 2)\n>>> list(odd)\n[1, 3] \n```", "```py\n>>> class CountGenerator:\n...     def __init__(self, start=0, step=1, stop=None):\n...         self.start = start\n...         self.step = step\n...         self.stop = stop\n...\n...     def __iter__(self):\n...         i = self.start\n...         while self.stop is None or i < self.stop:\n...             yield i\n...             i += self.step\n\n>>> list(CountGenerator(start=2.5, step=0.5, stop=5))\n[2.5, 3.0, 3.5, 4.0, 4.5] \n```", "```py\n>>> class CountIterator:\n...     def __init__(self, start=0, step=1, stop=None):\n...         self.i = start\n...         self.start = start\n...         self.step = step\n...         self.stop = stop\n...\n...     def __iter__(self):\n...         return self\n...\n...     def __next__(self):\n...         if self.stop is not None and self.i >= self.stop:\n...             raise StopIteration\n...\n...         # We need to return the value before we increment to\n...         # maintain identical behavior\n...         value = self.i\n...         self.i += self.step\n...         return value\n\n>>> list(CountIterator(start=2.5, step=0.5, stop=5))\n[2.5, 3.0, 3.5, 4.0, 4.5] \n```", "```py\n>>> import itertools\n\n>>> class AdvancedCountIterator:\n...     def __init__(self, start=0, step=1, stop=None):\n...         self.i = start\n...         self.start = start\n...         self.step = step\n...         self.stop = stop\n...\n...     def __iter__(self):\n...         return self\n...\n...     def __next__(self):\n...         if self.stop is not None and self.i >= self.stop:\n...             raise StopIteration\n...\n...         value = self.i\n...         self.i += self.step\n...         return value\n...\n...     def __len__(self):\n...         return int((self.stop - self.start) // self.step)\n...\n...     def __contains__(self, key):\n...         # To check 'if 123 in count'.\n...         # Note that this does not look at 'step'!\n...         return self.start < key < self.stop\n...\n...     def __repr__(self):\n...         return (\n...             f'{self.__class__.__name__}(start={self.start}, '\n...             f'step={self.step}, stop={self.stop})')\n...\n...     def __getitem__(self, slice_):\n...         return itertools.islice(self, slice_.start,\n...                                 slice_.stop, slice_.step) \n```", "```py\n>>> count = AdvancedCountIterator(start=2.5, step=0.5, stop=5)\n\n# Pretty representation using '__repr__'\n>>> count\nAdvancedCountIterator(start=2.5, step=0.5, stop=5)\n\n# Check if item exists using '__contains__'\n>>> 3 in count\nTrue\n>>> 3.1 in count\nTrue\n>>> 1 in count\nFalse\n\n# Getting the length using '__len__'\n>>> len(count)\n5\n# Slicing using '__getitem__' with a slice as a parameter\n>>> count[:3]\n<itertools.islice object at 0x...>\n\n>>> list(count[:3])\n[2.5, 3.0, 3.5]\n\n>>> list(count[:3])\n[4.0, 4.5] \n```", "```py\n>>> import itertools\n\n>>> def grouper(iterable, n, fillvalue=None):\n...     '''Collect data into fixed-length chunks or blocks'''\n...     args = [iter(iterable)] * n \n...     return itertools.zip_longest(*args, fillvalue=fillvalue)\n\n>>> list(grouper('ABCDEFG', 3, 'x'))\n[('A', 'B', 'C'), ('D', 'E', 'F'), ('G', 'x', 'x')] \n```", "```py\n>>> def chunker(iterable, chunk_size):\n...     # Make sure 'iterable' is an iterator\n...     iterable = iter(iterable)\n...\n...     def chunk(value):\n...         # Make sure not to skip the given value\n...         yield value\n...         # We already yielded a value so reduce the chunk_size\n...         for _ in range(chunk_size - 1):\n...             try:\n...                 yield next(iterable)\n...             except StopIteration:\n...                 break\n...\n...     while True:\n...         try:\n...             # Check if we're at the end by using 'next()'\n...             yield chunk(next(iterable))\n...         except StopIteration:\n...             break\n\n>>> for chunk in chunker('ABCDEFG', 3):\n...     for value in chunk:\n...         print(value, end=', ')\n...     print()\nA, B, C,\nD, E, F,\nG, \n```", "```py\n>>> import itertools\n\n>>> some_list = list(range(1000))\n>>> some_list[:5]\n[0, 1, 2, 3, 4]\n>>> list(itertools.islice(some_list, 5))\n[0, 1, 2, 3, 4]\n\n>>> some_list[10:20:2]\n[10, 12, 14, 16, 18]\n>>> list(itertools.islice(some_list, 10, 20, 2))\n[10, 12, 14, 16, 18] \n```", "```py\n>>> def islice(iterable, start, stop=None, step=1):\n...     # 'islice' has signatures: 'islice(iterable, stop)' and:\n...     # 'islice(iterable, start, stop[, step])'\n...     # 'fill' stop with 'start' if needed\n...     if stop is None and step == 1 and start is not None:\n...         start, stop = 0, start\n...\n...     # Create an iterator and discard the first 'start' items\n...     iterator = iter(iterable)\n...     for _ in range(start):\n...         next(iterator)\n...\n...     # Enumerate the iterator making 'i' start at 'start'\n...     for i, item in enumerate(iterator, start):\n...         # Stop when we've reached 'stop' items\n...         if i >= stop:\n...             return\n...         # Use modulo 'step' to discard non-matching items\n...         if i % step:\n...             continue\n...         yield item\n\n>>> list(islice(range(1000), 10))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n>>> list(islice(range(1000), 900, 920, 2))\n[900, 902, 904, 906, 908, 910, 912, 914, 916, 918]\n\n>>> list(islice(range(1000), 900, 910))\n[900, 901, 902, 903, 904, 905, 906, 907, 908, 909] \n```", "```py\n>>> def chain(*iterables):\n...     for iterable in iterables:\n...         yield from iterable\n\n>>> a = 1, 2, 3\n>>> b = [4, 5, 6]\n>>> c = 'abc'\n>>> list(chain(a, b, c))\n[1, 2, 3, 4, 5, 6, 'a', 'b', 'c']\n\n>>> a + b + c\nTraceback (most recent call last):\n    ...\nTypeError: can only concatenate tuple (not \"list\") to tuple \n```", "```py\n>>> def chain(*iterables):\n...     for iterable in iterables:\n...         for i in iterable:\n...             yield i \n```", "```py\n>>> import itertools\n\n>>> def spam_and_eggs():\n...     yield 'spam'\n...     yield 'eggs'\n\n>>> a, b = itertools.tee(spam_and_eggs())\n>>> next(a)\n'spam'\n>>> next(a)\n'eggs'\n>>> next(b)\n'spam'\n>>> next(b)\n'eggs'\n>>> next(b)\nTraceback (most recent call last):\n    ...\nStopIteration \n```", "```py\n>>> import time\n>>> import datetime\n>>> import contextlib\n\n# Context manager that shows how long a context was active\n>>> @contextlib.contextmanager\n... def timer(name):\n...     start_time = datetime.datetime.now()\n...     yield\n...     stop_time = datetime.datetime.now()\n...     print('%s took %s' % (name, stop_time - start_time))\n\n>>> with timer('basic timer'):\n...     time.sleep(0.1)\nbasic timer took 0:00:00.1...\n\n# Write standard print output to a file temporarily\n>>> @contextlib.contextmanager\n... def write_to_log(name):\n...     with open(f'{name}.txt', 'w') as fh:\n...         with contextlib.redirect_stdout(fh):\n...             with timer(name):\n...                 yield\n\n# Using as a decorator also works in addition to with-statements\n>>> @write_to_log('some_name')\n... def some_function():\n...     print('This will be written to 'some_name.txt'')\n\n>>> some_function() \n```", "```py\n>>> import contextlib\n\n>>> @contextlib.contextmanager\n... def write_to_log(name):\n...     with contextlib.ExitStack() as stack:\n...         fh = stack.enter_context(open(f'{name}.txt', 'w'))\n...         stack.enter_context(contextlib.redirect_stdout(fh))\n...         stack.enter_context(timer(name))\n...         yield\n\n>>> @write_to_log('some_name')\n... def some_function():\n...     print('This will be written to 'some_name.txt'')\n\n>>> some_function() \n```", "```py\n>>> import contextlib\n\n>>> with contextlib.ExitStack() as stack:\n...     fh = stack.enter_context(open('file.txt', 'w'))\n...     # Move the context(s) to a new ExitStack\n...     new_stack = stack.pop_all()\n\n>>> bytes_written = fh.write('fh is still open')\n\n# After closing we can't write anymore\n>>> new_stack.close()\n>>> fh.write('cant write anymore')\nTraceback (most recent call last):\n    ...\nValueError: I/O operation on closed file. \n```", "```py\n>>> def generator():\n...     value = yield 'value from generator'\n...     print('Generator received:', value)\n...     yield f'Previous value: {value!r}'\n\n>>> g = generator()\n>>> print('Result from generator:', next(g))\nResult from generator: value from generator\n\n>>> print(g.send('value from caller'))\nGenerator received: value from caller\nPrevious value: 'value from caller' \n```", "```py\n>>> import functools\n\n>>> def coroutine(function):\n...     # Copy the 'function' description with 'functools.wraps'\n...     @functools.wraps(function)\n...     def _coroutine(*args, **kwargs):\n...         active_coroutine = function(*args, **kwargs)\n...         # Prime the coroutine and make sure we get no values\n...         assert not next(active_coroutine)\n...         return active_coroutine\n...\n...     return _coroutine\n\n>>> @coroutine\n... def our_coroutine():\n...     while True:\n...         print('Waiting for yield...')\n...         value = yield\n...         print('our coroutine received:', value)\n\n>>> generator = our_coroutine()\nWaiting for yield...\n\n>>> generator.send('a')\nour coroutine received: a\nWaiting for yield... \n```", "```py\n>>> from coroutine_decorator import coroutine\n\n>>> @coroutine\n... def simple_coroutine():\n...     print('Setting up the coroutine')\n...     try:\n...         while True:\n...             item = yield\n...             print('Got item:', item)\n...     except GeneratorExit:\n...         print('Normal exit')\n...     except Exception as e:\n...         print('Exception exit:', e)\n...         raise\n...     finally:\n...         print('Any exit') \n```", "```py\n>>> active_coroutine = simple_coroutine()\nSetting up the coroutine\n>>> active_coroutine.send('from caller')\nGot item: from caller\n>>> active_coroutine.close()\nNormal exit\nAny exit\n\n>>> active_coroutine = simple_coroutine()\nSetting up the coroutine\n>>> active_coroutine.throw(RuntimeError, 'caller sent an error')\nTraceback (most recent call last):\n    ...\nRuntimeError: caller sent an error\n\n>>> active_coroutine = simple_coroutine()\nSetting up the coroutine\n>>> try:\n...     active_coroutine.throw(RuntimeError, 'caller sent an error')\n... except RuntimeError as exception:\n...     print('Exception:', exception)\nException exit: caller sent an error\nAny exit\nException: caller sent an error \n```", "```py\n# The decorator from the Priming section in this chapter\n>>> from coroutine_decorator import coroutine\n\n>>> lines = 'some old text', 'really really old', 'old old old'\n\n>>> @coroutine\n... def replace(search, replace):\n...     while True:\n...         item = yield\n...         print(item.replace(search, replace))\n\n>>> old_replace = replace('old', 'new')\n>>> for line in lines:\n...     old_replace.send(line)\nsome new text\nreally really new\nnew new new \n```", "```py\n>>> @coroutine\n... def replace(search, replace):\n...     while True:\n...         item = yield\n...         yield item.replace(search, replace)\n\n>>> old_replace = replace('old', 'new')\n>>> for line in lines:\n...     old_replace.send(line)\n'some new text'\n'new new new' \n```", "```py\n>>> @coroutine\n... def replace(search, replace):\n...     item = yield\n...     while True:\n...         item = yield item.replace(search, replace)\n\n>>> old_replace = replace('old', 'new')\n>>> for line in lines:\n...     old_replace.send(line)\n'some new text'\n'really really new'\n'new new new' \n```", "```py\n>>> @coroutine\n... def replace(target, search, replace):\n...     while True:\n...         target.send((yield).replace(search, replace))\n\n# Print will print the items using the provided formatstring\n>>> @coroutine\n... def print_(formatstring):\n...     count = 0\n...     while True:\n...         count += 1\n...         print(count, formatstring.format((yield)))\n# tee multiplexes the items to multiple targets\n>>> @coroutine\n... def tee(*targets):\n...     while True:\n...         item = yield\n...         for target in targets:\n...             target.send(item) \n```", "```py\n# Because we wrap the results we need to work backwards from the\n# inner layer to the outer layer.\n\n# First, create a printer for the items:\n>>> printer = print_('print: {}')\n\n# Create replacers that send the output to the printer\n>>> old_replace = replace(printer, 'old', 'new')\n>>> current_replace = replace(printer, 'old', 'current')\n\n# Send the input to both replacers\n>>> branch = tee(old_replace, current_replace)\n\n# Send the data to the tee routine for processing\n>>> for line in lines:\n...     branch.send(line)\n1 print: some new text\n2 print: some current text\n3 print: really really new\n4 print: really really current\n5 print: new new new\n6 print: current current current \n```", "```py\n>>> import itertools\n\n>>> @coroutine\n... def average():\n...     total = yield\n...     for count in itertools.count(start=1):\n...         total += yield total / count\n\n>>> averager = average()\n>>> averager.send(20)\n20.0\n>>> averager.send(10)\n15.0 \n```", "```py\n>>> import itertools\n\n>>> @coroutine\n... def print_(formatstring):\n...     while True:\n...         print(formatstring.format((yield)))\n\n>>> @coroutine\n... def average(target):\n...     total = 0\n...     for count in itertools.count(start=1):\n...         total += yield\n...         target.send(total / count)\n\n>>> printer = print_('{:.1f}')\n>>> averager = average(printer)\n>>> averager.send(20)\n20.0\n>>> averager.send(10)\n15.0 \n```", "```py\n>>> @coroutine\n... def groupby():\n...     # Fetch the first key and value and initialize the state\n...     # variables\n...     key, value = yield\n...     old_key, values = key, []\n...     while True:\n...         # Store the previous value so we can store it in the\n...         # list\n...         old_value = value\n...         if key == old_key:\n...             key, value = yield\n...         else:\n...             key, value = yield old_key, values\n...             old_key, values = key, []\n...         values.append(old_value)\n\n>>> grouper = groupby()\n>>> grouper.send('a1')\n>>> grouper.send('a2')\n>>> grouper.send('a3')\n>>> grouper.send('b1')\n('a', ['1', '2', '3'])\n>>> grouper.send('b2')\n>>> grouper.send('a1')\n('b', ['1', '2'])\n>>> grouper.send('a2')\n>>> grouper.send((None, None))\n('a', ['1', '2']) \n```", "```py\n>>> @coroutine\n... def print_(formatstring):\n...     while True:\n...         print(formatstring.format(*(yield)))\n\n>>> @coroutine\n... def groupby(target):\n...     old_key = None\n...     while True:\n...         key, value = yield\n...         if old_key != key:\n...             # A different key means a new group so send the\n...             # previous group and restart the cycle.\n...             if old_key and values:\n...                 target.send((old_key, values))\n...             values = []\n...             old_key = key\n...         values.append(value)\n\n>>> grouper = groupby(print_('group: {}, values: {}'))\n>>> grouper.send('a1')\n>>> grouper.send('a2')\n>>> grouper.send('a3')\n>>> grouper.send('b1')\ngroup: a, values: ['1', '2', '3']\n>>> grouper.send('b2')\n>>> grouper.send('a1')\ngroup: b, values: ['1', '2']\n>>> grouper.send('a2')\n>>> grouper.send((None, None))\ngroup: a, values: ['1', '2'] \n```"]