<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Using Generalized Behavior from the APIView Class</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using Generalized Behavior from the APIView Class</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will improve our simple RESTful Web Service. We will make it possible for it to work with diverse content types without writing a huge amount of code. We will take advantage of advanced features and generalized behaviors included in the Django REST framework to enable multiple parsers and renderers. We will gain an understanding of:</p>
<ul>
<li>Taking advantage of model serializers</li>
<li>Understanding accepted and returned content types</li>
<li>Making unsupported HTTP OPTIONS requests with command-line tools</li>
<li>Understanding decorators that work as wrappers</li>
<li>Using decorators to enable different parsers and renderers</li>
<li>Taking advantage of content negotiation classes</li>
<li>Making supported HTTP OPTIONS requests with command-line tools</li>
<li>Working with different content types</li>
<li>Sending HTTP requests with unsupported HTTP verbs</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Taking advantage of model serializers</h1>
                </header>
            
            <article>
                
<p>In <a href="dj-rst-websvc_ch11.html" target="_blank">Chapter 1</a>,&#160;<em>Installing the Required Software and Tools</em>, we created the toy model (the <kbd>Toy</kbd> class) and its serializer (the <kbd>ToySerializer</kbd> class). When we wrote the code for the <kbd>ToySerializer</kbd> class, we had to declare many attributes with the same names that we used in the <kbd>Toy</kbd> class. The <kbd>ToySerializer</kbd> class is a subclass of the <kbd>rest_framework.serializers.Serializer</kbd> superclass; it declares attributes that we manually mapped to the appropriate types, and overrides the <kbd>create</kbd> and <kbd>update</kbd> methods. However, we repeated a lot of code and information that was already included in the toy model, such as the types and the <kbd>max_length</kbd> values that specify the maximum length for each string field.</p>
<p>Now, we will take advantage of model serializers to simplify code and to avoid repeating information that is already included in the model. We will create a new version of the existing <kbd>ToySerializer</kbd> class that will inherit from the <kbd>rest_framework.serializers.ModelSerializer</kbd> superclass instead of inheriting from the <kbd>rest_framework.serializers.ModelSerializer</kbd> superclass.</p>
<p>The <kbd>ModelSerializer</kbd> class automatically populates a set of default fields and default validators by retrieving metadata from the related model class that we must specify. In addition, the <kbd>ModelSerializer</kbd> class provides default implementations for the <kbd>create</kbd> and <kbd>update</kbd> methods. In this case, we will take advantage of these default implementations because they will be suitable to provide our necessary <kbd>create</kbd> and <kbd>update</kbd> methods.</p>
<p>Go to the <kbd>restful01/toys</kbd> folder and open the <kbd>serializers.py</kbd> file.&#160;The code file for the sample is included in the <kbd>hillar_django_restful_04_01</kbd> folder, in the <kbd>restful01/toys/serializers.py</kbd> file.&#160;Replace the code in this file with the following code that declares the new version of the<span>&#160;</span><kbd>ToySerializer</kbd><span>&#160;class:</span></p>
<pre>from rest_framework import serializers 
from toys.models import Toy 
 
 
class ToySerializer(serializers.ModelSerializer): 
    class Meta: 
        model = Toy 
        fields = ('id',  
                  'name',  
                  'description', 
                  'release_date', 
                  'toy_category',  
                  'was_included_in_home')</pre>
<p>The new version of the <kbd>ToySerializer</kbd> class declares a <kbd>Meta</kbd> inner class that declares the following two attributes:</p>
<ul>
<li><kbd>model</kbd>: This attribute specifies the model related to the serializer, that is, the <kbd>Toy</kbd> class</li>
<li><kbd>fields</kbd>: This attribute specifies a tuple of <kbd>string</kbd> whose values indicate the field names that we want to include in the serialization from the related model (the <kbd>Toy</kbd> class)</li>
</ul>
<p>The new version of the <kbd>ToySerializer</kbd> class doesn't need to override either the <kbd>create</kbd> or <kbd>update</kbd> methods because the generic behavior provided by the <kbd>ModelSerializer</kbd> class will be enough in this case. The <kbd>ModelSerializer</kbd> superclass provides implementations for both methods.</p>
<p>With the changes we have made, we removed a nice amount of code from the <kbd>ToySerializer</kbd> class. In the new version, we just had to specify the related model and the desired set of fields in a tuple. Now, the types and <kbd>max_length</kbd> values related to the toy fields are only included in the <kbd>Toy</kbd> class.</p>
<div class="packt_tip">If you have previous experience with the Django Web framework, you will realize that the <kbd>Serializer</kbd> and <kbd>ModelSerializer</kbd> classes in the Django REST framework are similar to the <kbd>Form</kbd> and <kbd>ModelForm</kbd> classes in Django.</div>
<p>You can press <em>Ctrl</em> + <em>C</em> to quit Django's development server and execute the command that we learned in <a href="dj-rst-websvc_ch13.html" target="_blank">Chapter 3</a>,&#160;<em>Creating API Views</em>, to run the server to start it again. In this case, we just edited one file, and in case you didn't stop the development server, Django will detect the changes when we save the changes to the file and it will automatically restart the server.</p>
<p>The following lines show sample output that you will see after you save the changes in the edited Python file. The lines indicate that Django has restarted the development server and successfully performed a system check that identified no issues:</p>
<pre>    <strong>System check identified no issues (0 silenced).</strong>
    <strong>October 13, 2017 - 04:11:13</strong>
    <strong>Django version 1.11.5, using settings 'restful01.settings'</strong>
    <strong>Starting development server at http://0.0.0.0:8000/</strong>
    <strong>Quit the server with CONTROL-C.</strong> </pre>
<p>You can use the command-line and GUI tools we used in <a href="dj-rst-websvc_ch13.html" target="_blank">Chapter 3</a>, <em>Creating API Views</em>, to test the new version of our RESTful Web Service that takes advantage of model serializers. The behavior will be the same as in the previous version. However, we definitely have less code to maintain and we have removed duplicated data.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding accepted and returned content types</h1>
                </header>
            
            <article>
                
<p>So far, our RESTful Web Service has been working with JSON for the response body. The code we wrote in the <kbd>toys/views.py</kbd> file in <a href="https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=61&amp;action=edit#post_56" target="_blank">Chapter 3</a><span>,&#160;</span><em>Creating API Views</em><span>,</span> declares a <kbd>JSONResponse</kbd> class and two function-based views. These functions return a <kbd>JSONResponse</kbd> when it is necessary to return JSON data and a <kbd>django.Http.Response.HttpResponse</kbd> instance when the response is just an HTTP status code. No matter the accepted content type specified in the HTTP request header, the view functions always provide the same content in the response body: JSON.</p>
<p>Run the following command to retrieve all the toys with the <kbd>Accept</kbd> request header key set to <kbd>text/html</kbd>. Remember that the virtual environment we have created in&#160;<a href="https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=61&amp;action=edit#post_56" target="_blank">Chapter 3</a><span>,&#160;</span><em>Creating API Views</em><span>,</span> must be activated in order to run the next <kbd>http</kbd> command:</p>
<pre>    <strong>http :8000/toys/ Accept:text/html</strong> </pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre><strong>    curl -H "Accept: text/html" -iX GET localhost:8000/toys/<br/></strong></pre>
<p>The previous commands will compose and send the following HTTP request: <kbd>GET http://localhost:8000/toys/</kbd>. These commands specify the <kbd>text/html</kbd> value for the <kbd>Accept</kbd> key in the request header. This way, the HTTP request indicates that it accepts a response of <kbd>text/html</kbd>.</p>
<p>The header response for the request will include the following line:</p>
<pre>    <strong>Content-Type: application/json</strong> </pre>
<p>Now, run the following command to retrieve all the toys with different values with the <kbd>Accept</kbd> request header key set to <kbd>text/html</kbd>.</p>
<p>Run the following command to retrieve all the toys with the <kbd>Accept</kbd> request header key set to <kbd>application/json</kbd>:</p>
<pre>   <strong>http :8000/toys/ Accept:application/json</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre><strong>  curl -H "Accept: application/json" -iX GET localhost:8000/toys/<br/></strong></pre>
<p>The previous commands will compose and send the following HTTP request: <kbd>GET http://localhost:8000/toys/</kbd>. These commands specify the <kbd>application/json</kbd> value for the <kbd>Accept</kbd> key in the request header. This way, the HTTP request indicates that it accepts a response of <kbd>application/json</kbd>.</p>
<p>The header response for the request will include the following line:</p>
<pre>    <strong>Content-Type: application/json</strong></pre>
<p>The first group of commands defined the <kbd>text/html</kbd> value for the <kbd>Accept</kbd> request header key. The second group of commands defined the <kbd>application/json</kbd> value for the <kbd>Accept</kbd> request header key. However, both produced the same results and the responses were always in the JSON format. The view functions don't take into account the value specified for the <kbd>Accept</kbd> request header key in the HTTP requests. No matter the value indicated for the <kbd>Accept</kbd> request header key, the response is always in the JSON format.</p>
<p>We want to provide support for other formats. However, we don't want to write a huge amount of code to do so. Thus, we will take advantage of additional features included in the Django REST framework that will make it easy for us to support additional formats for our RESTful Web Service.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making unsupported HTTP OPTIONS requests with command-line tools</h1>
                </header>
            
            <article>
                
<p>Sometimes, we don't know which are the HTTP methods or verbs that a resource or resource collection supports in a RESTful Web Service. In order to provide a solution to this problem, we can compose and send an HTTP request with the <kbd>OPTIONS</kbd> HTTP verb and the URL for the resource or the resource collection.</p>
<p>If the RESTful Web Service implements the <kbd>OPTIONS</kbd> HTTP verb for a resource or resource collection, it will build a response with an <kbd>Allow</kbd> key in the response header. The value for this key will include a comma-separated list of HTTP verbs or methods that it supports. In addition, the response header will include additional information about other supported options, such as the content type it is capable of parsing from the request and the content type it is capable of rendering in the response.</p>
<p>For example, if we want to know which HTTP verbs the toys collection supports, we can run the following command:</p>
<pre>    <strong>http OPTIONS :8000/toys/</strong></pre>
<p><span>Notice that the command will generate an error in the Django development server.</span></p>
<p>The following is the equivalent curl command:</p>
<pre>    <strong>curl -iX OPTIONS localhost:8000/toys/</strong></pre>
<p>The previous command will compose and send the following HTTP request: <kbd>OPTIONS http://localhost:8000/toys/</kbd>. The request specifies <kbd>/toys/</kbd>, and therefore, it will match the <kbd>'^toys/$'</kbd> regular expression and run the <kbd>views.toy_list</kbd> function, that is, the <kbd>toy_list</kbd> function declared within the <kbd>toys/views.py</kbd> file. This function only runs code when the <kbd>request.method</kbd> is equal to either <kbd>'GET'</kbd> or <kbd>'POST'</kbd>. In this case, <kbd>request.method</kbd> is equal to <kbd>'OPTIONS'</kbd>, and therefore, the function won't run any code. The function won't return the expected <kbd>HttpResponse</kbd> instance.</p>
<p>The lack of the expected <kbd>HttpResponse</kbd> instance generates an internal server error in Django's development server. The console output for the development server will display details about the internal server error and a traceback similar to the one shown in the next screenshot. The last lines indicate that there is a <kbd>ValueError</kbd> because the <kbd>toys_list</kbd> function didn't return an <kbd>HttpResponse</kbd> instance and returned <kbd>None</kbd> instead:</p>
<div class="CDPAlignCenter CDPAlign"><img height="293" width="430" src="images/55ab16b6-55f0-468f-9018-5fb984162f02.png"/></div>
<p>The following lines show the header for the output displayed as a result of the HTTP request. The response also includes a detailed HTML document with a huge amount of information about the error because the debug mode is activated for Django. We receive an HTTP <kbd>500 Internal Server Error</kbd> status code. Obviously, we don't want all this information to be provided in a production-ready web service, in which we will deactivate the debug mode:</p>
<pre>    <strong>HTTP/1.0 500 Internal Server Error</strong>
    <strong>Content-Length: 52222</strong>
    <strong>Content-Type: text/html</strong>
    <strong>Date: Tue, 10 Oct 2017 17:46:34 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.6.2</strong>
    <strong>Vary: Cookie</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong></pre>
<p>We don't want our web service to provide a response with an HTTP <kbd>500 Internal Server Error status</kbd> code when we receive a request with the <kbd>OPTIONS</kbd> verb to either a valid resource or resource collection. Obviously, we want to provide a more consistent web service and we want to provide an accurate response when we receive a request with the <kbd>OPTIONS</kbd> verbs, for either a toy resource or the toys collection.</p>
<p>If we compose and send an HTTP request with the <kbd>OPTIONS</kbd> verb for an existing toy resource, we will see the same error in the console output for the development server and a similar response with the HTTP <kbd>500 Internal Server Error status</kbd> code. The <kbd>views.toy_detail</kbd> function only runs code when the <kbd>request.method</kbd> is equal to <kbd>'GET'</kbd>, <kbd>'PUT',</kbd> or <kbd>'DELETE'</kbd>. Thus, as happened with the previous case, the <kbd>toys_detail</kbd> function won't return an <kbd>HttpResponse</kbd> instance and it will return <kbd>None</kbd> instead.</p>
<p>The following commands will produce the explained error when we try to see the options offered for the toy resource whose <kbd>id</kbd> or primary key is equal to <kbd>2</kbd>. Make sure you replace <kbd>2</kbd> with a primary key value of an existing toy in your configuration:</p>
<pre>    <strong>http OPTIONS :8000/toys/2</strong></pre>
<p>The following is the equivalent curl command:</p>
<pre>    <strong>curl -iX OPTIONS localhost:8000/toys/2</strong></pre>
<p>The following screenshot shows the details of the internal server error and a traceback displayed in the console output for the development server after we run the previous HTTP request:</p>
<div class="CDPAlignCenter CDPAlign"><img height="190" width="455" src="images/a26ced03-ebeb-4d84-ae13-0a5cdc08ec29.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding decorators that work as wrappers</h1>
                </header>
            
            <article>
                
<p>Now, we will make a few changes to the code in the <kbd>toys/views.py</kbd> file to provide support for the <kbd>OPTIONS</kbd> verb in our RESTful Web Service. Specifically, we will take advantage of a decorator provided by the Django REST framework.</p>
<p>We will use the <kbd>@api_view</kbd> decorator that is declared in the <kbd>rest_framework.decorators</kbd> module. We will apply this decorator to our function-based views: <kbd>toys_list</kbd> and <kbd>toys_detail</kbd>.</p>
<p>The <kbd>@api_view</kbd> decorator allows us to specify which are the HTTP verbs that the function to which it is applied can process. If the request that has been routed to the view function has an HTTP verb that isn't included in the string list specified as the <kbd>http_method_names</kbd> argument for the <kbd>@api_view</kbd> decorator, the default behavior returns a response with an HTTP <kbd>405 Method Not Allowed</kbd> status code.</p>
<p>This way, we make sure that whenever the RESTful Web Service receives an HTTP verb that isn't considered within our function views, we won't generate an unexpected and undesired error in Django. The decorator generates the appropriate response for the unsupported HTTP verbs or methods. In addition, by reading the declaration of our function views, we can easily understand which HTTP verbs are handled by the function.</p>
<p>It is very important to understand what happens under the hood whenever we use the <kbd>@api_view</kbd> decorator. This decorator is a wrapper that converts a function-based view into a subclass of the <kbd>rest_framework.views.APIView</kbd> class. This class is the base class for all the views in the Django REST framework.</p>
<div class="packt_tip">We will work with class-based views in the forthcoming examples and we will have the same benefits we have analyzed for the function-based views that use the decorator.</div>
<p>In addition, the decorator uses the string list we specify with the supported HTTP verbs to build the response for a request with the <kbd>OPTIONS</kbd> HTTP verb. The automatically generated response includes the supported method, and the parser and the render capabilities. In other words, the response includes the format that the function is capable of understanding and the format that the function can generate for the response.</p>
<p>As previously explained, the current version of our RESTful Web Service is only capable of rendering JSON as its output. The usage of the decorator makes sure that we always receive an instance of the <kbd>rest_framework.request.Request</kbd> class in the <kbd>request</kbd> argument when Django calls our view function. In addition, the decorator handles the <kbd>ParserError</kbd> exceptions when our function views access the <kbd>request.data</kbd> attribute and there are parsing problems.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using decorators to enable different parsers and renderers</h1>
                </header>
            
            <article>
                
<p>We will make changes to just one file. After you save the changes, Django's development server will automatically restart. However, you can decide to stop Django's development server and start it again after you finish all the necessary changes.</p>
<p>We will make the necessary changes to use the previously introduced <kbd>@api_view</kbd> decorator to make it possible for the RESTful Web Service to work with different parsers and renderers, by taking advantage of generalized behaviors provided by the <kbd>APIView</kbd> class.</p>
<p>Now, go to the <kbd>restful01/toys</kbd> folder and open the <kbd>views.py</kbd> file. Replace the code in this file with the following lines. However, take into account that many lines have been removed, such as the lines that declared the <kbd>JSONResponse</kbd> class. The code file for the sample is included in the <kbd>hillar_django_restful_04_02</kbd> folder, in the <kbd>restful01/toys/views.py</kbd> file:</p>
<pre>from django.shortcuts import render 
from rest_framework import status 
from toys.models import Toy 
from toys.serializers import ToySerializer
from rest_framework.decorators import api_view 
from rest_framework.response import Response 
 
 
@api_view(['GET', 'POST']) 
def toy_list(request): 
    if request.method == 'GET': 
        toys = Toy.objects.all() 
        toys_serializer = ToySerializer(toys, many=True) 
        return Response(toys_serializer.data) 
 
    elif request.method == 'POST': 
        toy_serializer = ToySerializer(data=request.data) 
        if toy_serializer.is_valid(): 
            toy_serializer.save() 
            return Response(toy_serializer.data, status=status.HTTP_201_CREATED) 
        return Response(toy_serializer.errors, status=status.HTTP_400_BAD_REQUEST) 
 
 
@api_view(['GET', 'PUT', 'DELETE']) 
def toy_detail(request, pk): 
    try: 
        toy = Toy.objects.get(pk=pk) 
    except Toy.DoesNotExist: 
        return Response(status=status.HTTP_404_NOT_FOUND) 
 
    if request.method == 'GET': 
        toy_serializer = ToySerializer(toy) 
        return Response(toy_serializer.data) 
 
    elif request.method == 'PUT': 
        toy_serializer = ToySerializer(toy, data=request.data) 
        if toy_serializer.is_valid(): 
            toy_serializer.save() 
            return Response(toy_serializer.data) 
        return Response(toy_serializer.errors, status=status.HTTP_400_BAD_REQUEST) 
 
    elif request.method == 'DELETE': 
        toy.delete() 
        return Response(status=status.HTTP_204_NO_CONTENT) </pre>
<p>The new code applies the <kbd>@api_view</kbd> decorator for the two functions: <kbd>toy_list</kbd> and <kbd>toy_detail</kbd>. In addition, the new code removes the <kbd>JSONResponse</kbd> class and uses the more generic <kbd>rest_framework.response.Response</kbd> class.</p>
<p>We had to remove the usage of the <kbd>rest_framework.parsers.JSONParser</kbd> class in the functions to make it possible to work with different parsers. This way, we stopped working with a parser that only works with JSON. In the older version of the code, the <kbd>toy_list</kbd> function executed the following two lines when the <kbd>request.method</kbd> attribute was equal to <kbd>'POST'</kbd>:</p>
<pre>toy_data = JSONParser().parse(request) 
toy_serializer = ToySerializer(data=toy_data) </pre>
<p>In the new code, we removed the first line that called the <kbd>JSONParser().parse</kbd> method that was only capable of parsing JSON content. The new code replaces the two previous lines with the following single line that passes <kbd>request.data</kbd> as the <kbd>data</kbd> argument to create a new <kbd>ToySerializer</kbd> instance:</p>
<pre>toy_serializer = ToySerializer(data=request.data) </pre>
<p>In the older version of the code, the <kbd>toy_detail</kbd> function executed the following two lines when the <kbd>request.method</kbd> attribute was equal to <kbd>'PUT'</kbd>:</p>
<pre>toy_data = JSONParser().parse(request) 
toy_serializer = ToySerializer(toy, data=toy_data)</pre>
<p>We made edits that are similar to the changes done for the code in the <kbd>toy_list</kbd> function. We removed the first line that called the <kbd>JSONParser().parse</kbd> method that was only capable of parsing JSON content. The new code replaces the two previous lines with the following single line that passes <kbd>toy</kbd> as the first argument and <kbd>request.data</kbd> as the <kbd>data</kbd> argument to create a new <kbd>ToySerializer</kbd> instance:</p>
<pre>toy_serializer = ToySerializer(toy, data=request.data) </pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Taking advantage of content negotiation classes</h1>
                </header>
            
            <article>
                
<p>The <kbd>APIView</kbd> class defines default settings for each view that we can override by specifying the desired values in the settings module, that is, the <kbd>restful01/settings.py</kbd> file. It is also possible to override the class attributes in subclasses. In this case, we won't make changes in the settings module, but we have to understand which are the default settings that the <kbd>APIView</kbd> class uses. We added the&#160;&#160;<kbd>@api_view</kbd> decorator, and it automatically makes the <kbd>APIView</kbd> use these settings.</p>
<p>The value for the <kbd>DEFAULT_PARSER_CLASSES</kbd> setting key specifies a tuple of string whose values indicate the default classes that we want to use for parsing backends. The following lines show the default values:</p>
<pre>( 
    'rest_framework.parsers.JSONParser', 
    'rest_framework.parsers.FormParser', 
    'rest_framework.parsers.MultiPartParser' 
) </pre>
<p>When we use the <kbd>@api_view</kbd> decorator, the RESTful Web Service will be able to handle any of the following content types through the appropriate parsers. Thus, we will be able to work with the <kbd>request.data</kbd> attribute to retrieve the keys and values for each of these content types:</p>
<ul>
<li><kbd>application/json</kbd>: Parsed by the <kbd>rest_framework.parsers.JSONParser</kbd> class</li>
<li><kbd>application/x-www-form-urlencoded</kbd>: Parsed by the <kbd>rest_framework.parsers.FormParser</kbd> class</li>
<li><kbd>multipart/form-data</kbd>: Parsed by the <kbd>rest_framework.parsers.MultiPartParser</kbd> class</li>
</ul>
<p>When we access the <kbd>request.data</kbd> attribute in the functions, the Django REST framework examines the value for the <kbd>Content-Type</kbd> header in the incoming request and determines the appropriate parser to parse the request content. If we use the previously explained default values, the Django REST Framework will be able to parse all of the previously listed content types. Notice that the request must specify the appropriate value for the <kbd>Content-Type</kbd> key in the request header.</p>
<p>The value for the <kbd>DEFAULT_RENDERER_CLASSES</kbd> setting key specifies a tuple of string whose values indicate the default classes that we want to use for rendering backends. The following lines show the default values:</p>
<pre>( 
    'rest_framework.renderers.JSONRenderer', 
    'rest_framework.renderers.BrowsableAPIRenderer', 
) </pre>
<p>When we use the <kbd>@api_view</kbd> decorator, the RESTful Web Service will be able to render any of the following content types through the appropriate renderers. We made the necessary changes to work with a <kbd>rest_framework.response.Response</kbd> instance to be able to work with these content types:</p>
<ul>
<li><kbd>application/json</kbd>: Rendered by the <kbd>rest_framework.response.JSONRenderer</kbd> class</li>
<li><kbd>text/html</kbd>: Rendered by the <kbd>rest_framework.response.BrowsableAPIRenderer</kbd> class</li>
</ul>
<p>So far, we understand the default settings for parsers and renderers. There is an additional part of this puzzle that must select the appropriate renderer for the response based on the requirements specified in the incoming request.</p>
<p>By default, the value for the <kbd>DEFAULT_CONTENT_NEGOTIATION_CLASS</kbd> is the <kbd>rest_framework.negotiation.DefaultContentNegotiation</kbd> class. When we use the decorator, the web service will use this content negotiation class to select the appropriate renderer for the response, based on the incoming request. This way, when a request specifies that it will accept <kbd>text/html</kbd>, the content negotiation class selects the <kbd>rest_framework.renderers.BrowsableAPIRenderer</kbd> to render the response and generate <kbd>text/html</kbd> instead of <kbd>application/json</kbd>.</p>
<p>In the old version of the code, we used the <kbd>JSONResponse</kbd> and <kbd>HttpResponse</kbd> classes in the functions. The new version replaced the usages of both classes with the&#160;<kbd>rest_framework.response.Response</kbd> class. This way, the code takes advantage of the content negotiation features. The <kbd>Response</kbd> class renders the provided data into the appropriate content type and returns it to the client that made the request.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making supported HTTP OPTIONS requests with command-line tools</h1>
                </header>
            
            <article>
                
<p>Now, we will take advantage of all the changes we've made in the code and we will compose and send HTTP requests to make our RESTful Web Service work with different content types. Make sure you've saved all the changes. In case you stopped Django's development server, you will have to start it again as we learned in <a href="dj-rst-websvc_ch13.html" target="_blank">Chapter 3</a>,&#160;<em>Creating API Views</em>, in the section <em>Launching Django's development server</em>, to start running the Django development server.</p>
<p>We want to know which HTTP verbs the toys, collection supports, that is, we want to take advantage of the <kbd>OPTIONS</kbd> verb. Run the following command. This time, the command won't produce errors. Remember that the virtual environment we have created in the previous chapters must be activated in order to run the next <kbd>http</kbd> command:</p>
<pre>    <strong>http OPTIONS :8000/toys/</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre><strong>    curl -iX OPTIONS localhost:8000/toys/</strong></pre>
<p>The previous command will compose and send the following HTTP request: <kbd>OPTIONS http://localhost:8000/toys/</kbd>. The request will end up running the <kbd>views.toy_list</kbd> function, that is, the <kbd>toy_list</kbd> function declared within the <kbd>toys/views.py</kbd> file. We added the <kbd>@api_view</kbd> decorator to this function, and therefore, the function is capable of determining the supported HTTP verbs, the enabled parsing and rendering options. The following lines show the output:</p>
<pre><strong>    HTTP/1.0 200 OK
    Allow: POST, OPTIONS, GET
    Content-Length: 167
    Content-Type: application/json
    Date: Mon, 16 Oct 2017 04:28:32 GMT
    Server: WSGIServer/0.2 CPython/3.6.2
    Vary: Accept, Cookie
    X-Frame-Options: SAMEORIGIN</strong>
    
    {
        "description": "", 
        "name": "Toy List", 
        "parses": [
            "application/json", 
            "application/x-www-form-urlencoded", 
            "multipart/form-data"
        ], 
        "renders": [
            "application/json", 
            "text/html"
        ]
    }
 </pre>
<p>The response header includes an <kbd>Allow</kbd> key with a comma-separated list of HTTP verbs supported by the resource collection as its value: <kbd>POST, OPTIONS, GET</kbd>. Our request didn't specify the allowed content type, and therefore, the function rendered the response with the default <kbd>application/json</kbd> content type.</p>
<p>The response body specifies the <kbd>Content-type</kbd> that the resource collection is capable of parsing in the values for the <kbd>"parses"</kbd> key and the <kbd>Content-type</kbd> that the resource collection is capable of rendering in the values for the <kbd>"renders"</kbd> key.</p>
<p>Run the following command to compose and send an HTTP request with the <kbd>OPTIONS</kbd> verb for a toy resource. Don't forget to replace <kbd>2</kbd> with a primary key value of an existing toy in your configuration:</p>
<pre>    <strong>http OPTIONS :8000/toys/2</strong></pre>
<p>The following is the equivalent curl command:</p>
<pre>    <strong>curl -iX OPTIONS localhost:8000/toys/2</strong></pre>
<p>The previous command will compose and send the following HTTP request: <kbd>OPTIONS http://localhost:8000/toys/2</kbd>. The request will end up running the <kbd>views.toy_detail</kbd> function, that is, the <kbd>toy_detail</kbd> function declared within the <kbd>toys/views.py</kbd> file. We also added the <kbd>@api_view</kbd> decorator to this function, and therefore, it is capable of determining the supported HTTP verbs, the enabled parsing and rendering options. The following lines show a sample output:</p>
<pre>    <strong>HTTP/1.0 200 OK</strong>
    <strong>Allow: DELETE, PUT, OPTIONS, GET</strong>
    <strong>Content-Length: 169</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Mon, 16 Oct 2017 04:30:04 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.6.2</strong>
    <strong>Vary: Accept, Cookie</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    {
        "description": "", 
        "name": "Toy Detail", 
        "parses": [
            "application/json", 
            "application/x-www-form-urlencoded", 
            "multipart/form-data"
        ], 
        "renders": [
            "application/json", 
            "text/html"
        ]
    }
  </pre>
<p>The response header includes an <kbd>Allow</kbd> key with a comma-separated list of HTTP verbs supported by the resource as its value: <kbd>DELETE, PUT, OPTIONS, GET</kbd>. The response body specifies the <kbd>Content-type</kbd> that the resource is capable of parsing in the values for the <kbd>"parses"</kbd> key and the <kbd>Content-type</kbd> that the resource collection is capable of rendering in the values for the <kbd>"renders"</kbd> key. The resource and the resource collection can parse and render the same content types because everything is handled by the decorator and the <kbd>APIView</kbd> class.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with different content types</h1>
                </header>
            
            <article>
                
<p>In <a href="dj-rst-websvc_ch13.html" target="_blank">Chapter 3</a><em>, Creating API Views</em>, when we composed and sent <kbd>POST</kbd> and <kbd>PUT</kbd> commands, we had to use the use the <kbd>-H "Content-Type: application/json"</kbd> option to indicate curl to send the data specified after the <kbd>-d</kbd> option as <kbd>application/json</kbd>. We had to use this option because the default content-type in curl is <kbd>application/x-www-form-urlencoded</kbd>.</p>
<p>Now, our RESTful Web Service goes beyond JSON and it can also parse <kbd>application/x-www-form-urlencoded</kbd> and <kbd>multipart/form-data</kbd> data specified in the <kbd>POST</kbd> and <kbd>PUT</kbd> requests. Hence, we can compose and send a <kbd>POST</kbd> command that sends the data as <kbd>application/x-www-form-urlencoded</kbd>.</p>
<p>We will compose and send an HTTP request to create a new toy. In this case, we will use the <kbd>-f</kbd> option for HTTP.</p>
<p>This option serializes data items from the command line as form fields and sets the <kbd>Content-Type</kbd> header key to the <kbd>application/x-www-form-urlencoded</kbd> value. Run the next command:</p>
<pre><strong>http -f POST :8000/toys/ name="Ken in Rome" description="Ken loves Rome" toy_category="Dolls" was_included_in_home=false release_date="2017-10-09T12:11:37.090335Z"  </strong></pre>
<p>The following is the equivalent curl command that creates a new toy. Notice that we don't use the <kbd>-H</kbd> option and curl will send the data in the default <kbd>application/x-www-form-urlencoded</kbd>:</p>
<pre><strong>curl -iX POST -d '{"name":"Ken in Rome", "description": "Ken loves Rome", "toy_category":"Dolls", "was_included_in_home": "false", "release_date": "2017-10-09T12:11:37.090335Z"}' localhost:8000/toys/</strong> </pre>
<p>The previous commands will compose and send the following HTTP request: <kbd>POST http://localhost:8000/toys/</kbd> with the <kbd>Content-Type</kbd> header key set to the <kbd>application/x-www-form-urlencoded</kbd> value and the following data:</p>
<pre>name=Ken+in+Rome&amp;description=Ken+loves+Rome&amp;toy_category=Dolls&amp;was_included_in_home=false&amp;release_date=2017-10-09T12%3A11%3A37.090335Z </pre>
<p>The request specifies <kbd>/toys/</kbd>, and therefore, it will match the <kbd>'^toys/$'</kbd> regular expression and Django will run the <kbd>views.toy_list</kbd> function, that is, the updated <kbd>toy_detail</kbd> function declared within the <kbd>toys/views.py</kbd> file. The HTTP verb for the request is <kbd>POST</kbd>, and therefore, the <kbd>request.method</kbd> property is equal to <kbd>'POST'</kbd>. The function will execute the code that creates a <kbd>ToySerializer</kbd> instance and passes <kbd>request.data</kbd> as the <kbd>data</kbd> argument to create the new instance.</p>
<p>The <kbd>rest_framework.parsers.FormParser</kbd> class will parse the data received in the request, the code creates a new <kbd>Toy</kbd> and, if the data is valid, it saves the new <kbd>Toy</kbd>. If the new <kbd>Toy</kbd> instance was successfully persisted in the database, the function returns an HTTP <kbd>201 Created</kbd> status code and the recently persisted <kbd>Toy</kbd> serialized to JSON in the response body. The following lines show an example response for the HTTP request, with the new <kbd>Toy</kbd> object in the JSON response:</p>
<pre>HTTP/1.0 201 Created<br/>Allow: GET, OPTIONS, POST<br/>Content-Length: 157<br/>Content-Type: application/json<br/>Date: Mon, 16 Oct 2017 04:40:02 GMT<br/>Server: WSGIServer/0.2 CPython/3.6.2<br/>Vary: Accept, Cookie<br/>X-Frame-Options: SAMEORIGIN<br/>{<br/>    "description": "Ken loves Rome",<br/>    "id": 6,<br/>    "name": "Ken in Rome",<br/>    "release_date": "2017-10-09T12:11:37.090335Z",<br/>    "toy_category": "Dolls",<br/>    "was_included_in_home": false<br/>}</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sending HTTP requests with unsupported HTTP verbs</h1>
                </header>
            
            <article>
                
<p>Now, we will compose and send HTTP requests with an HTTP verb that isn't supported for the toys resource collection. Run the following command:</p>
<pre><strong>http PATCH :8000/toys/</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre><strong>curl -iX PATCH localhost:8000/toys/</strong></pre>
<p>The previous command will compose and send the following HTTP request: <kbd>PATCH http://localhost:8000/toys/</kbd>. The request will try to run the <kbd>views.toy_list</kbd> function, that is, the <kbd>toy_list</kbd> function declared within the <kbd>toys/views.py</kbd> file. The <kbd>@api_view</kbd> decorator we added to this function doesn't include <kbd>'PATCH'</kbd> in the string list with the allowed HTTP verbs. The default behavior when this happens in the <kbd>APIView</kbd> class is to return an HTTP <kbd>405 Method Not Allowed</kbd> status code. The following lines show a sample output with the response from the previous request. A JSON content provides a <kbd>detail</kbd> key with a string value that indicates the <kbd>PATCH</kbd> method is not allowed in the response body:</p>
<pre>    <strong>HTTP/1.0 405 Method Not Allowed</strong>
    <strong>Allow: GET, OPTIONS, POST</strong>
    <strong>Content-Length: 42</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Mon, 16 Oct 2017 04:41:35 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.6.2</strong>
    <strong>Vary: Accept, Cookie</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>{</strong>
    <strong>    "detail": "Method \"PATCH\" not allowed."</strong>
    <strong>}</strong></pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Test your knowledge</h1>
                </header>
            
            <article>
                
<p>Let's see whether you can answer the following questions correctly:</p>
<ol>
<li>The <kbd>@api_view</kbd>&#160;decorator declared in the <kbd>rest_framework.decorators</kbd> module allows you to:
<ol>
<li>Specify which is the model related to the function based view</li>
<li>Specify which are the HTTP verbs that the function based view to which it is applied can process</li>
<li>Specify which is the serializer related to the function based view</li>
</ol>
</li>
<li>The <kbd>@api_view</kbd> decorator is a wrapper that converts a function based view into a subclass of which of the following classes:
<ol>
<li><kbd>django.Http.Response.HttpResponse</kbd></li>
<li><kbd>rest_framework.views.APIView</kbd></li>
<li><kbd>rest_framework.serializers.Serializer</kbd></li>
</ol>
</li>
<li>Which of the following settings key in the REST_FRAMEWORK dictionary allows you to override the global setting with a tuple of string whose values indicate the default classes that you want to use for parsing backends:
<ol>
<li><kbd>'DEFAULT_PARSER_CLASSES'</kbd></li>
<li><kbd>'GLOBAL_PARSER_CLASSES'</kbd></li>
<li><kbd>'REST_FRAMEWORK_PARSING_CLASSES'</kbd></li>
</ol>
</li>
<li>Which of the following classes is able to parse application/json content type when we work with the <kbd>@api_view</kbd> decorator and its default settings:
<ol>
<li><kbd>django.parsers.JSONParser</kbd></li>
<li><kbd>rest_framework.classes.JSONParser</kbd></li>
<li><kbd>rest_framework.parsers.JSONParser</kbd></li>
</ol>
</li>
<li>Which of the following classes is able to parse application/x-www-form-urlencoded content type when we work with the <kbd>@api_view</kbd> decorator and its default settings:
<ol>
<li><kbd>django.parsers.XWWWUrlEncodedParser</kbd></li>
<li><kbd>rest_framework.classes.XWWWUrlEncodedParser</kbd></li>
<li><kbd>rest_framework.parsers.FormParser</kbd></li>
</ol>
</li>
</ol>
<p>&#160;</p>
<p><span>The rights answers are included in the&#160;<a href="https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=44&amp;action=edit#post_454" target="_blank">Appendix</a>,&#160;<em>Solutions</em>.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we improved our simple Django RESTful Web Service. We took advantage of many features included in the Django REST framework to remove duplicate code and to add many features for the web service. We just needed to edit a few lines of code to enable an important amount of features.</p>
<p>First, we took advantage of model serializers. Then, we understood the different accepted and returned content types and the importance of providing accurate responses to the HTTP OPTIONS requests.</p>
<p>We incorporated the <kbd>@api_view</kbd> decorator and made the necessary changes to the existing code to enable diverse parsers and renderers. We understood how things worked under the hood in the Django REST framework. We worked with different content types and noticed the improvement of the RESTful Web Service compared with its previous versions.</p>
<p>Now that we understand how easy it is to work with different content types with the Django REST framework, we will work with one of the most interesting and powerful features: the browsable API. We will cover this topic in <a href="dj-rst-websvc_ch15.html" target="_blank">Chapter 5</a>,&#160;<em>Understanding and Customizing the Browsable API Feature</em>.</p>
<p class="mce-root"></p>


            </article>

            
        </section>
    </div>
</body>
</html>