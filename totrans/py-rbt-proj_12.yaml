- en: Recognizing Humans with Jarvis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jarvis 识别人类
- en: By now  we have understood in the last chapter how multiple layers of conditions
    can be clubbed together to get the functionality that is desired. We have just
    completed the first step in making Jarvis work for you. Now, it's time to make
    it even more capable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在上一章中已经了解到如何将多个条件层叠在一起以获得所需的功能。我们刚刚完成了让 Jarvis 为你工作的第一步。现在，是时候让它变得更加强大。
- en: In this chapter, we will make it control more electronics at your home, which
    can be controlled autonomously without you telling anything to the system. So
    without delay, let's get straight into it and see what we have in our bucket.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将让它控制你家里的更多电子设备，这些设备可以在不告诉你任何信息的情况下自主控制。所以，不要拖延，让我们直接进入主题，看看我们的桶里有什么。
- en: Turn on the light Jarvis
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开 Jarvis 的灯光
- en: One of the basic functionalities of a smart home is to turn on the lights for
    you whenever you are around. It is one of the most basic things that any system
    can do for you. We will start off by turning on the light as soon as you come
    inside the room, thereafter, we will make the system more and more intelligent.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 智能家居的一个基本功能是在你周围时为你打开灯光。这是任何系统可以为你做的最基本的事情之一。我们将从一进入房间就打开灯光开始，然后我们将使系统变得越来越智能。
- en: So, the first thing we need to do is recognize whether you are in a room or
    not. There are multiple ways to do that. One important characteristic of life
    is the presence of movement. You may say plants don't move, well they do; they
    grow, don't they? So detecting movement can be a key step in detecting whether
    someone is there or not!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们首先需要做的是识别你是否在房间里。有多种方法可以做到这一点。生命的一个重要特征是运动的存。你可能会说植物不动，但它们确实会动；它们会生长，不是吗？所以检测运动可以是检测是否有人在场的关键步骤！
- en: 'This step will not be so difficult for you, as we have already interfaced this
    sensor previously. We are talking about the good old PIR sensor. So the sensor
    will sense any movement in the area. If there is any movement, then Jarvis will
    switch on the lights. I am sure this is something you can do by yourself by now.
    You can still refer to the code and the circuit diagram here:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步对你来说不会太难，因为我们之前已经接口了这个传感器。我们说的是那个古老的 PIR 传感器。所以，传感器会检测到该区域内的任何运动。如果有任何运动，Jarvis
    将会打开灯光。我相信你现在可以自己完成这个任务。你仍然可以参考这里的代码和电路图：
- en: '![](img/831a5983-5954-4b4b-82ec-fe5b34c2edc8.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](img/831a5983-5954-4b4b-82ec-fe5b34c2edc8.png)'
- en: 'Now upload the following code:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请上传以下代码：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we are simply turning on the light as soon as the motion
    is detected, but the problem is that it will only switch on the light for the
    time the motion is there. What does that mean? Simple, while there is some movement,
    will keep the lights on and as soon as the movement stops, it will switch off
    the light.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们只是在检测到运动时立即打开灯光，但问题是它只会打开灯光，直到运动停止。这意味着什么？简单来说，只要有运动，就会保持灯光开启，一旦运动停止，就会关闭灯光。
- en: 'This can be a very good code for a person who wants to lose weight, but for
    most of us, it will be annoying. So, let''s include a small loop, which we have
    used in the previous chapter and make this a little better:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个想要减肥的人的好代码，但对于我们大多数人来说，这会让人烦恼。所以，让我们加入一个小循环，这是我们之前章节中使用过的，让这个功能变得更好：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, in this program, all we have done is we have added a `for` loop, which switches
    on the light for a set amount of time. How long that time will be can be toggled
    by changing the value of the variable `TIME`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个程序中，我们所做的一切就是添加了一个 `for` 循环，它会打开灯光一段时间。这个时间可以通过改变变量 `TIME` 的值来切换。
- en: 'There is one more interesting part in that loop which is as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个循环中还有一个更有趣的部分，如下所示：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Why did we do this you might wonder? Whenever the light will be switched on,
    it will remain on for 5 minutes. Then, it will switch off and wait for movement
    to occur. So, essentially, the problem with this code will be that if you are
    in the room and the light switches on, then for 5 minutes it will see if there
    is any motion detected or not. There is a chance that you will be in motion when
    it searches for the motion after 5 minutes. But for most of the time, it won't
    be the case. So we are detecting the movement using the PIR sensor. Whenever movement
    is detected, the value of `M_final` is incremented using the line `M_final = M_final
    + 1`, thereby increasing the time until which the light will be switched on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道我们为什么要这样做？每当灯光打开时，它会持续5分钟。然后，它会关闭并等待运动发生。所以，本质上，这个代码的问题在于如果你在房间里，灯光打开后，它会持续5分钟检查是否有运动检测到。有可能你在5分钟后搜索运动时正在移动。但大多数时间，情况并非如此。因此，我们使用PIR传感器来检测运动。一旦检测到运动，`M_final`的值就会通过`M_final
    = M_final + 1`这一行增加，从而增加灯光开启的时间。
- en: Understanding motion
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解运动
- en: By now you must have figured that the PIR sensor is not the most idealistic
    sensor for us to switch the lights on or off. Mostly because, although the motion
    is one of the best indicators of presence, there can be times when you might not
    move at all, for example, while resting, reading a book, watching a movie, and
    so on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你必须已经意识到PIR传感器并不是我们用来开关灯的最理想的传感器。主要是因为，尽管运动是存在的一个最好的指标，但有时你可能根本不会移动，例如，在休息、读书、看电影等等。
- en: What do we do now? Well, we can do a little trick. Remember in the last chapter
    we used our proximity sensor to sense whether a person has crossed a specific
    area or not? We will implant a similar logic here; but rather than just copy pasting
    the code, we will improve it and make it even better.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在该做什么呢？嗯，我们可以玩一个小技巧。记得在上一个章节中，我们使用我们的接近传感器来检测一个人是否穿过了特定的区域吗？我们在这里将植入类似的逻辑；但不是简单地复制粘贴代码，我们将改进它，让它变得更好。
- en: 'So rather than using one single IR proximity sensor, we will be using two of
    these things. The mounting will be as shown in the following diagram:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不会使用单个红外接近传感器，而是将使用两个这样的设备。安装方式如下所示：
- en: '![](img/09728605-7f11-4f9c-bf51-35889757bffa.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09728605-7f11-4f9c-bf51-35889757bffa.png)'
- en: Now it is very evident that whenever a person walks in from the door side to
    the room side the **Sensor 1** will show a lower reading when detecting a body.
    Then, while he is walking towards the room side, **Sensor 2** will show a similar
    reading.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很明显，当一个人从门口走到房间那边时，**传感器1**在检测到人体时会显示较低的读数。然后，当他朝房间方向走时，**传感器2**将显示类似的读数。
- en: If first **Sensor 1** is triggered and thereafter **Sensor 2** is triggered,
    then we can safely assume that the person is travelling from the door side to
    the room side. Similarly, if the opposite is happening, then it is understood
    that the person is walking out of the room.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果首先**传感器1**被触发，然后**传感器2**被触发，那么我们可以安全地假设这个人是从门口走到房间那边。同样，如果情况相反，那么可以理解这个人是从房间里走出来的。
- en: 'Now, this is fairly simple. But how do we implement it in a real-life situation?
    Firstly, we need to connect the circuit as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这一点相当简单。但如何在现实生活中实现它呢？首先，我们需要按照以下方式连接电路：
- en: '![](img/0dfd0653-10b4-4311-8c2c-f4ebe1a71e48.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0dfd0653-10b4-4311-8c2c-f4ebe1a71e48.png)'
- en: 'Once that is done, upload the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，上传以下代码：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, let's see what are we doing here. As always, most of the syntax is very
    simple and straightforward. The most important part is the logic. So, let's understand
    in proper steps as to what we are doing.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们在做什么。像往常一样，大多数语法都非常简单直接。最重要的是逻辑。所以，让我们按照适当的步骤来理解我们在做什么。
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding lines of code, we are taking the value of the IR proximity
    sensor and calculating the distance corresponding to it and storing that value
    in a variable called `F1`. Once that is done, we are stopping for a brief period
    of `0.1` seconds using the `time.sleep(0.1)` function. Thereafter, we are taking
    the reading from the same sensor again and storing the value in a variable called
    `F2`. Why are we doing this? We have already understood that in the previous chapters.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的前几行中，我们正在读取红外接近传感器的值，并计算相应的距离，然后将该值存储在一个名为`F1`的变量中。一旦完成，我们使用`time.sleep(0.1)`函数暂停短暂的`0.1`秒。之后，我们再次从同一传感器读取值，并将该值存储在名为`F2`的变量中。我们为什么要这样做？我们已经在之前的章节中理解了这一点。
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once the value of `F1` and `F0` is acquired, we will calculate the difference
    to find out whether someone has passed through it or not. If no one has passed,
    then the reading will almost be the same and the difference will not be considerable.
    However, if a person does pass, then the reading will be considerable and that
    value will be stored in a variable called `F0_final`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获得了`F1`和`F0`的值，我们将计算差值以确定是否有人通过它。如果没有人在通过，那么读数几乎会相同，差异不会很大。然而，如果有人通过，那么读数将相当明显，并且该值将存储在一个名为`F0_final`的变量中。
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If the value of the `F0` or the difference in distance between the first and
    the second reading is more than 10 centimeters, then the `if` condition will be
    true. Once true, it will set the value of the `Time0` variable as the current
    value of time. The `time.time()` function will make a note of the exact time.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`F0`的值或第一次和第二次读数之间的距离超过10厘米，那么`if`条件将为真。一旦为真，它将设置`Time0`变量的值为当前时间。`time.time()`函数将记录确切的时间。
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, we'll perform the exact same step for **Sensor 2** as well. There is nothing
    new to tell here; it's all self explanatory.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对**传感器2**执行完全相同的步骤。这里没有什么新的内容要说明；一切都是不言自明的。
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once all of this is done, we compare `if Time1 > Time0`. Why are we comparing
    it? Because `Time0` is the time noted for **Sensor 1**. If the person is moving
    inside, then **Sensor 1** would be the first one to be triggered and then the
    **Sensor 2** would be triggered. Hence, the time noted would be greater for **Sensor
    2** and relatively earlier for **Sensor 1**. If that happens, then we can assume
    that the person is coming inside. Well, if a person is coming inside, then we
    simply need to switch the light on, which is exactly what we are doing here.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都完成后，我们比较`if Time1 > Time0`。我们为什么要比较它？因为`Time0`是**传感器1**记录的时间。如果有人进入房间，那么**传感器1**将是第一个被触发的，然后是**传感器2**。因此，记录的时间对于**传感器2**会更大，而对于**传感器1**则相对较早。如果发生这种情况，那么我们可以假设有人正在进入房间。嗯，如果有人进入房间，那么我们只需要打开灯光，这正是我们在这里所做的事情。
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Similarly, when a person is going out, the first sensor to be triggered would
    be **Sensor 2**, thereafter **Sensor 1** will be triggered. Making the time noted
    for `Time1` earlier than `Time2`; hence, whenever this condition is true, we will
    know that the person is moving out of the room and the lights can be switched
    off.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当有人离开时，首先被触发的传感器将是**传感器2**，然后**传感器1**将被触发。这使得记录的`Time1`早于`Time2`；因此，每当这个条件为真时，我们就知道有人正在离开房间，可以关闭灯光。
- en: Go ahead and mount it near the door and see how it reacts. I'm sure this will
    be way better than what we had done through PIR. Have fun with it and try to find
    any flaws that it might have.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，把它安装在门附近，看看它的反应。我相信这会比我们通过PIR所做的好得多。享受这个过程，并尝试找出它可能存在的任何缺陷。
- en: Perfecting motion
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完善运动
- en: Were you able to find any flaws in the previous code? They are not hard to find;
    the code works brilliantly when it's only a single person in the room. If this
    is installed somewhere where multiple people are coming and going, then it might
    be challenging. This is because whenever a person moves outside, the light will
    be turned off.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否在之前的代码中发现了任何缺陷？它们并不难找；当房间里只有一个人时，代码工作得非常出色。如果这个系统安装在一个有很多人进出的地方，那么可能会有些挑战。这是因为每当有人离开房间时，灯光就会熄灭。
- en: 'So now that the problem is evident, it''s time to make the code even more better.
    To do this, the hardware will remain exactly the same; we simply need to make
    the code smarter. Let''s see how we can do that:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 既然问题已经很明显，是时候让代码变得更加完美了。为此，硬件将保持完全不变；我们只需要让代码更智能。让我们看看我们如何做到这一点：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: What we have done is something really basic. We have declared a variable called `PCount`.
    This variable is declared to count the number of people who are there inside a
    room or a home. As you can see in the first few lines of the code, we have declared
    the value of `PCount` as `0`. We are assuming that once we start this, the number
    of people inside would be `0`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是一些非常基础的事情。我们声明了一个名为 `PCount` 的变量。这个变量是用来计算在一个房间或家中的人数。正如您可以在代码的前几行中看到的那样，我们已将
    `PCount` 的值声明为 `0`。我们假设一旦开始这个操作，室内的人数将是 `0`。
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Whenever the condition `if Time1 > Time0:` is satisfied, the `PCount` value
    is incremented by `1`. As we all know, the condition will only be true when a
    person is walking inside the home.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每当满足条件 `if Time1 > Time0:` 时，`PCount` 值会增加 `1`。众所周知，只有当有人在室内行走时，这个条件才会为真。
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Similarly, when a person is walking outside, the condition `if Time1 < Time0:`
    is true; whenever that happens, the value of `PCount` is decremented by `1`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当一个人在室外行走时，条件 `if Time1 < Time0:` 为真；每当这种情况发生时，`PCount` 的值会减少 `1`。
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that we have started counting the number of people in the room, we are now
    applying the condition, which will turn on if the number of `PCount` is more than
    `0`. Hence, the light will be on for the time when the number of people inside
    the home is more than `0`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经开始计算房间内的人数，我们现在应用的条件是，如果 `PCount` 的值大于 `0`，则该条件会被触发。因此，当室内的人数大于 `0` 时，灯光将会亮起。
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In a very similar fashion, the lights will be turned off if the value of `PCount`
    or the number of people inside the home gets to `0`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以非常相似的方式，如果 `PCount` 的值或室内的人数达到 `0`，灯光将会关闭。
- en: Hence, nailed!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，大功告成！
- en: Controlling the intensity
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制强度
- en: We have controlled a lot of light now. It's time that we control our fans and
    other air circulation systems. Whenever we talk about fans or any other air circulation
    devices, then essentially we are talking about motors. As we have learned earlier,
    motors are simple devices, which can be controlled every easily using a motor
    driver. But as you know, back then we were controlling DC motors. DC motors are
    extremely simple devices. But when we talk about our household appliances, then
    most of these devices will be working on AC or alternating current. I am assuming
    that you must be aware of what that is and how it is different from DC.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经控制了很多灯光。现在是时候控制我们的风扇和其他空气循环系统了。当我们谈论风扇或任何其他空气循环设备时，本质上我们是在谈论电机。正如我们之前所学，电机是简单的设备，可以很容易地使用电机驱动器来控制。但是，正如您所知，当时我们是在控制直流电机。直流电机是极其简单的设备。但是当我们谈论我们的家用电器时，那么这些设备中的大多数都将使用交流电或交流电流。我假设您必须知道这是什么以及它与直流电的不同之处。
- en: Now that you know that the motors used in our households are working on AC,
    you must also think about the fact that their control mechanism will be much different
    to DC motors. You are right, if you thought so. However, the good thing about
    electronics is, nothing is really difficult or complicated. The basics are pretty
    much the same. So, let's see how we can control the speed of the motors in AC
    supply.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道了我们家庭中使用的电机是使用交流电工作的，您也必须考虑这样一个事实，它们的控制机制将与直流电机大不相同。您想得没错。然而，电子学的好处是，没有什么真的是困难的或复杂的。基础原理基本上是相同的。那么，让我们看看我们如何控制交流电源中电机的速度。
- en: 'As we have seen earlier, we can simply have a PWM signal given to the DC motor
    and the motor will run at the speed of the average voltage as a result of the
    PWM signal. Now, you must be thinking that this can be applied to AC as well.
    The thing is, yes it can be done if you want to control a light or similar devices,
    which do not have any major change in the characteristics in case the wave form
    is distorted. However, when we are talking about any other component, then we
    come across a big problem. The AC wave form looks like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，我们可以简单地给直流电机一个PWM信号，电机就会以PWM信号的平均电压速度运行。现在，您可能正在想这也可以应用于交流电。事实上，如果想要控制灯光或类似设备，这是可以做到的，因为这些设备在波形失真时没有太大的特性变化。然而，当我们谈论其他任何组件时，我们就会遇到一个大问题。交流波形看起来是这样的：
- en: '![](img/88cbcaf7-ac59-4dd4-bd1a-4b0689d10a23.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/88cbcaf7-ac59-4dd4-bd1a-4b0689d10a23.png)'
- en: This basically means that the potential is changing periodically. In most of
    the households, this is 50 times per second. Now, imagine if we have a PWM-controlled
    device that is switching the circuit that only lets the power supply to pass at
    certain intervals. Then, the different parts of the sinusoidal waves would be
    passed on to the final output.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上意味着电位在周期性地变化。在大多数家庭中，这是每秒50次。现在，想象一下，如果我们有一个PWM控制的设备，它只允许在特定间隔内让电源通过电路。那么，正弦波的不同部分就会被传输到最终的输出。
- en: '![](img/00216168-787b-4c9a-adad-d1a3432e2d5d.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00216168-787b-4c9a-adad-d1a3432e2d5d.png)'
- en: As you can see in the preceding PWM, fortunately the PWM signal has matched
    with the phase of the AC power; however, due to this, only the positive end of
    the phase is being transferred to the final output and not the negative end. This
    will cause a severe problem to our load and there is a very good chance that the
    appliance that is connected will not work.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的PWM中看到的，幸运的是，PWM信号与交流电的相位匹配；然而，由于这个原因，只有相位的正端被传输到最终的输出，而负端没有。这将给我们的负载带来严重问题，而且有很大可能性连接的设备将无法工作。
- en: '![](img/03c40308-32cd-4111-a608-85e99d49da28.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/03c40308-32cd-4111-a608-85e99d49da28.png)'
- en: We have another example in which the PWM is random and it lets random parts
    of the wave pass by. In this, we can clearly see that randomly any part of the
    wave is being transferred and the positive and negative end voltage is not in
    sync, which again will be a huge problem. Hence, instead of using PWM, we use
    something really interesting.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个例子，其中PWM是随机的，它让波的随机部分通过。在这个例子中，我们可以清楚地看到波的任何部分都在被传输，正负端电压没有同步，这又是一个大问题。因此，我们不是使用PWM，而是使用一些真正有趣的东西。
- en: 'The method that is most commonly used is called **phase fired control**. Sometimes
    it is also called phase angle control or phase cutting. What it essentially does
    is, it cuts the wave at certain parts of the phase letting the rest of the wave
    cross by. Confused? Let me show you here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的方法是称为**相位触发控制**。有时它也被称为相位角控制或相位斩波。它本质上是在相位的某些部分进行斩波，让其余的波通过。困惑吗？让我在这里展示给你：
- en: '![](img/1887c541-2bc4-452c-ad7c-b09527637d84.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1887c541-2bc4-452c-ad7c-b09527637d84.png)'
- en: 'Now, as you can see the phase behind the second half of the AC wave is getting
    chopped and is not getting passed in the final output. This makes the final output
    to be only 50% of the overall input. What this technique does is, it maintains
    the AC nature of the power supply while still being able to reduce the overall
    resulting voltage. Likewise, as you can see in the next diagram, the wave is getting
    chopped after 75% of the wave has already passed. This results in the output being
    relatively lower:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如你所见，交流波后半部分的相位正在被斩波，并且没有通过到最终的输出中。这使得最终的输出只有整体输入的50%。这种技术的作用是，在保持电源的交流特性的同时，还能降低整体输出电压。同样，正如你在下一张图中可以看到的，波在75%已经通过后开始斩波。这导致输出相对较低：
- en: '![](img/4a68f836-fb99-4f70-99ce-f1e98e907137.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a68f836-fb99-4f70-99ce-f1e98e907137.png)'
- en: Now you must be asking, how did we actually go ahead and do this? It is done
    by a relatively complex circuit that detects the phase angle of the wave and then
    opens or controls a triac, which is a high power bi-directional semiconductor.
    This leads the power supply to pass or to be stopped at certain phases. We will
    leave the exact working of this circuit for the next time as it is fairly complex
    and will not be relevant to this book.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能想知道，我们是如何实际进行这一操作的？这是通过一个相对复杂的电路来完成的，该电路检测波的相位角，然后打开或控制一个晶闸管，这是一个高功率的双向半导体。这导致电源在特定相位通过或停止。我们将具体电路的工作原理留到下次讨论，因为它相当复杂，并且与这本书的内容不太相关。
- en: Now coming to the basic point, we know what phase cutting is, we also know that
    triac is the basic device that lets us do that. But how do we go ahead and do
    it using Raspberry Pi is the question.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到基本点，我们知道什么是相位斩波，我们也知道晶闸管是我们做这件事的基本设备。但问题是，我们如何使用Raspberry Pi来实现它。
- en: So firstly, we will need an AC-dimmer module. This module already has all the
    components of phase detection and chopping. So all we need to do is simply control
    it using simple PWM.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个交流调光模块。这个模块已经包含了相位检测和斩波的所有组件。所以我们只需要简单地通过简单的PWM来控制它。
- en: 'Though I might not have to demonstrate how to connect the circuit or what the
    code should be, for the sake of understanding, let''s connect a light bulb to
    our Arduino using this module and then control the bulb. Now, the first thing
    to remember is that the load should be a bulb and not anything else such as an
    LED light. So go ahead and connect the circuit as shown in the following figure:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我可能不需要演示如何连接电路或代码应该是什么，但为了理解，让我们使用这个模块将灯泡连接到我们的Arduino上，然后控制灯泡。现在，首先要记住的是，负载应该是灯泡，而不是其他任何东西，比如LED灯。所以，按照以下图示连接电路：
- en: '![](img/87ff5a87-1bdd-4990-92b5-08e1fc8e5f47.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/87ff5a87-1bdd-4990-92b5-08e1fc8e5f47.png)'
- en: 'Once this is done, go ahead and upload the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，继续上传以下代码：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As expected, the attached light will start to glow very faintly first and will
    increase the intensity gradually until it reaches 100%. That is how simple it
    is to control such a complex process.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，附带的灯光将首先开始微弱地发光，并逐渐增加强度，直到达到100%。这就是控制如此复杂过程如此简单的原因。
- en: Intelligent temperature control
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能温度控制
- en: Now that the basics are done, let's go ahead and build something meaningful
    using this system. Isn't it difficult to set your air-conditioner to the perfect temperature?
    No matter what you do, you end up feeling not in the most comfortable spot. This
    happens due to physiological changes in the body temperature over the course of
    the day.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基础知识已经完成，让我们继续使用这个系统构建一些有意义的东西。调整空调到完美的温度是不是很难？无论你做什么，你最终都会感到不舒服。这是由于一天中体温的生理变化所导致的。
- en: When you wake up, your body temperature is relatively low. It is as much as
    1° F, which is lower than the normal body temperature. As the day progresses,
    the body temperature rises until the time you hit the bed. Once you sleep, again
    your body temperature starts to dip reaching its lowest point around 4:00-6:00
    am in the morning. That's the reason why what might feel warm while you go to
    bed, can be pretty cold when you wake up. Modern air-conditioners have something
    called a sleep mode. What this does is, it simply increases the temperature through
    the night. So that you do not feel cold at any point. But then again, how well
    it works is also a question.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当你醒来时，你的体温相对较低。它低至1°F，低于正常体温。随着一天的发展，体温升高，直到你上床睡觉的时间。一旦你入睡，你的体温又开始下降，在早上4:00-6:00达到最低点。这就是为什么当你上床睡觉时可能感觉温暖，但醒来时可能会非常冷的原因。现代空调有一种叫做睡眠模式的功能。这样做就是，它简单地通过整夜提高温度。这样你就不在任何时候感到冷。但话又说回来，它工作得有多好也是一个问题。
- en: So, now that we know the robotics very well, we will go ahead and make a system
    of our own that will take care of everything.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，既然我们已经非常了解机器人技术，我们将继续前进，制作我们自己的系统，该系统将负责一切。
- en: 'In this part, we will connect both the air-conditioner and your fan together
    so that they can both work in tandem and make you sleep well. Now, before jumping
    straight into it, I would like you to see the ratings that are mentioned on the
    relay. As you can see, the relay can handle only 250V and 5 ampere. Now, if you
    go through the brochure of your air-conditioner, you will easily understand why
    I am showing all of this to you. The power consumption of the air-conditioner
    will be much higher than what your relays can handle. So, if you try to run your
    air conditioner using the normal relays, then you will surely end up blowing the
    relay. There might be a chance that your appliance will be of a lower current
    rating than your relay. But with any device that has motors in it just keep in
    mind that the initial power consumption of that device is much higher than the
    nominal power consumption. Hence, if your air-conditioner needs 10 ampere nominal,
    then the starting load may be as much as 15 ampere. You must be thinking, it''s
    not a problem, why don''t we just purchase a relay that has a higher rating. Well,
    correct! That''s exactly what we will be doing. But the naming of electronics
    can be tricky at times. The devices that deal with a higher-power higher-voltage
    electro-mechanical switching is generally called contractor instead of relay.
    Technically, they have the same working principal; However, there are construction
    differences, which at this point would not be our concern. So we will be using
    a contractor for the air conditioner switching and a dimmer for the fan speed
    control. Now that this has been cleared up, let''s go ahead and attach the hardware
    as shown in the following diagram:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将空调和你的风扇连接在一起，这样它们就可以协同工作，让你睡得更好。现在，在我们直接进入之前，我想让你看看继电器上提到的评级。正如你所见，继电器只能处理250伏和5安培。现在，如果你查看你的空调手册，你很容易理解为什么我要向你展示所有这些。空调的功耗将远高于继电器可以处理的功耗。所以，如果你尝试使用普通继电器来运行你的空调，你肯定会烧毁继电器。可能你的电器电流额定值低于你的继电器。但是，对于任何内部有电机的设备，请记住，该设备的初始功耗远高于标称功耗。因此，如果你的空调标称需要10安培，那么启动负载可能高达15安培。你可能正在想，这不是问题，我们为什么不去购买一个更高额定值的继电器呢？好吧，正确！这正是我们将要做的。但是，电子设备的命名有时可能会很棘手。处理高功率、高电压机电开关的设备通常被称为接触器，而不是继电器。技术上，它们有相同的工作原理；然而，在这一点上，这不会是我们的关注点。因此，我们将使用接触器来切换空调，使用调光器来控制风扇速度。现在，这个问题已经澄清，让我们继续按照以下图示安装硬件：
- en: '![](img/816fa8b1-760c-4d1c-89c3-2e4609965bc4.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/816fa8b1-760c-4d1c-89c3-2e4609965bc4.png)'
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The logic used here is pretty basic. Let''s see what it is doing:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的逻辑相当基础。让我们看看它在做什么：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here we are taking the value of `humidity` and `temperature`. So far so good,
    but can we take it a step further and make it even more intelligent? The previous
    logic must have helped you sleep better, but can we make it just perfect for you?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在获取`湿度`和`温度`的值。到目前为止，一切顺利，但我们能否更进一步，让它变得更加智能？之前的逻辑可能已经帮助你睡得更好，但我们能否让它对你来说更加完美？
- en: There are multiple indicators in our body that give us an idea of what the state
    of the body is. For example, if you are tired, you will probably not be walking
    very fast or talking very loud. Instead, you would be doing the opposite! Similarly,
    there are multiple factors that indicate how our sleep cycle is going.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的身体中有多个指标，可以让我们了解身体的状况。例如，如果你感到疲倦，你可能不会走得很快或说话很大声。相反，你可能会做相反的事情！同样，也有多个因素可以指示我们的睡眠周期如何进行。
- en: 'Some of these factors are: body temperature, respiration rate, REM sleep, and
    body movements. Measuring the exact body temperature or respiration rate and REM
    sleep is something of a challenge. But when we talk about body movements, I think
    we have already perfected it. So based on the body movements, we will be sensing
    how well we are sleeping and what kind of temperature adjustment is needed.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些因素包括：体温、呼吸速率、REM睡眠和身体运动。精确测量体温或呼吸速率以及REM睡眠是一项挑战。但是当我们谈到身体运动时，我认为我们已经做得很好了。因此，基于身体运动，我们将感知我们睡眠得如何以及需要什么样的温度调整。
- en: If you notice, whenever someone is sleeping and starts feeling cold, the body
    will go to a fetal position and will move much less. This happens automatically.
    However, when a person is comfortable, there are some inevitable movements such
    as changing sides and movement of arms or legs. This does not happen when a person
    is feeling cold. So with these movements we can figure out whether a person is
    feeling cold or not. Now that we have understood the physiological changes of
    the body, let's try to build a program around it and see what we can achieve.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意的话，当有人睡觉并开始感到冷时，身体会采取胎儿姿势，并且动作会减少很多。这是自动发生的。然而，当一个人感到舒适时，会有一些不可避免的动作，比如翻身和手臂或腿部的移动。当一个人感到冷时，这种情况不会发生。所以通过这些动作，我们可以判断一个人是否感到冷。既然我们已经了解了身体的生理变化，那么让我们尝试围绕它构建一个程序，看看我们能实现什么。
- en: 'To do this, firstly, we need to connect the circuit as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，首先，我们需要按照以下方式连接电路：
- en: '![](img/dadeba11-0e9a-4d06-bb94-5f8d2184e8b5.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dadeba11-0e9a-4d06-bb94-5f8d2184e8b5.png)'
- en: 'Once this is done, go ahead and write the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这些，就继续编写以下代码：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s have a look at what is going on under the hood:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看内部发生了什么：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first thing you will see is that we have a condition: `if H,= 6 && H<= 22:`.
    This condition will only be true if the time frame is between 10 o'clock in the
    morning and  6 o'clock in the night. That is because this is the time when we
    generally sleep. Hence, the logic under this head will only work if it's time
    to sleep.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先会看到我们有一个条件：`if H,= 6 && H<= 22:`。这个条件只有在时间在上午10点和晚上6点之间时才会为真。这是因为这是我们通常睡觉的时间。因此，这个标题下的逻辑只有在睡觉时间才会起作用。
- en: The second condition is `if M <= 58`, which will be true only when the time
    is between `0` and `58` minutes. So when the time is `M = 59`, then this condition
    will not work. We will see the reason for having this logic.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个条件是`if M <= 58`，只有当时间在`0`到`58`分钟之间时，这个条件才会为真。所以当时间是`M = 59`时，这个条件将不起作用。我们将看到这个逻辑的原因。
- en: 'Thereafter, we are calculating the time and storing the value in a variable
    called `M`. We are also calculating the humidity and temperature values and storing
    it in variables called `temperature` and `humidity`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，我们计算时间并将值存储在名为`M`的变量中。我们还计算湿度和温度值，并将它们存储在名为`temperature`和`humidity`的变量中：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, in this line, we are implementing a condition which will be true if the
    reading from the PIR is high. That is, there is some motion that will be detected.
    Whenever this happens, the `Movement` variable will be incremented by `1`. Finally,
    we are using the `time.sleep(10)` function to wait for `10` seconds. This is done
    as the PIR might be high for a momentary period. In that case, the condition will
    be true over and over again which in turn will increment the value of `Movement`
    multiple times.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这一行中，我们实现了一个条件，如果PIR的读数高，这个条件将是真实的。也就是说，会检测到一些运动。每当这种情况发生时，`Movement`变量将增加`1`。最后，我们使用`time.sleep(10)`函数等待`10`秒。这样做是因为PIR可能在一小段时间内读数高。在这种情况下，条件会反复为真，从而多次增加`Movement`的值。
- en: Our purpose of incrementing the value of `Movement` is to count the number of
    times the person has moved. Hence, incrementing it multiples times in one single
    time will defy the objective.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们增加`Movement`值的目的是为了计算一个人移动的次数。因此，在短时间内多次增加它将违背我们的目标。
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now we have another condition, which says `if temperature < 28`. Not much explanation
    is needed for when the condition will be true. So whenever the condition is true
    and if the counted number of `Movement` is more than `5`, the value of `Duty`
    will be incremented by `10`. Therefore, we are sending the PWM to the AC dimmer,
    which in turn will increase the speed of the fan. Finally, we are resetting the
    value of `Movement` to `0`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有另一个条件，即`if temperature < 28`。当条件为真时不需要太多解释。所以每当条件为真，并且计数的`Movement`数量超过`5`时，`Duty`的值将增加`10`。因此，我们将PWM发送到AC调光器，这反过来会增加风扇的速度。最后，我们将`Movement`的值重置为`0`。
- en: So essentially, we are just counting the number of movements. This movement
    is counted only if the temperature is less than 28° C. If the movement is more
    than `5`, then we will increase the speed of the fan by 10%.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 所以本质上，我们只是在计算动作的数量。只有当温度低于28° C时，这个动作才会被计算。如果动作超过`5`次，那么我们将风扇的速度提高10%。
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the previous section, the logic will only work when the time is between `0`
    and `58`, that is, the time in which the counting will happen. When the value
    of `M` is `59`, then the condition `if Movement = 0` will be checked, and if true,
    then the value of `Duty` will be decremented by `10`. This in turn will reduce
    the speed of the fan by 10%. Also, once this condition is executed, the value
    of `Movement` will be reset to `0`. So then a new cycle can start for the next
    hour.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，逻辑只有在时间在`0`到`58`之间时才会起作用，即计数发生的时间。当`M`的值为`59`时，将检查条件`if Movement = 0`，如果为真，则`Duty`的值将减少`10`。这反过来又会将风扇速度降低10%。此外，一旦执行了这个条件，`Movement`的值将被重置为`0`。因此，新的周期可以开始，为下一个小时做准备。
- en: Now what it basically means is that counting will happen on an hourly basis.
    If the `Movement` is more than `5` then immediately the value of the `Duty` would
    be increased. However, if that is not the case, then the program will wait until
    the minute approaches the value of `59` and whenever that happens, it will check
    whether there is any movement, in which case, the fan speed will be decreased.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它基本上意味着计数将按小时进行。如果`Movement`超过`5`，那么`Duty`的值将立即增加。然而，如果不是这种情况，程序将等待直到分钟接近`59`的值，每当这种情况发生时，它将检查是否有任何移动，在这种情况下，风扇速度将降低。
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: All of this code is very straightforward. If the temperature is less than `22`,
    then the AC will be switched off. Furthermore, if the temperature is equal to
    or more than `24`, and time is between 10:00 p.m. and 6:00 a.m., then the AC will
    be turned on. Finally, if the temperature is more than `27`, then the fan will
    be switch on to 100% speed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些代码都非常简单易懂。如果温度低于`22`，那么空调将被关闭。此外，如果温度等于或高于`24`，并且时间在晚上10:00到早上6:00之间，那么空调将被打开。最后，如果温度高于`27`，那么风扇将切换到100%的速度。
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finally, we are making sure by using the condition `for H > 7 && H <20` that
    during this time the AC is always switched off. Also, if `H = 20`, then the AC
    should be turned on so that the room is cooled before you are ready to sleep.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过使用条件`for H > 7 && H <20`确保在这个时间段内空调始终关闭。此外，如果`H = 20`，那么空调应该打开，以便在你准备睡觉之前房间冷却下来。
- en: Adding more
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加更多
- en: As you would have understood by now, we can control any AC electrical appliances
    as per our needs. We have understood switching and have also perfected the way
    we can vary the intensity of light and the speed of fans. But did you notice one
    thing? Sooner or later as our system gets more and more complex, the number of
    GPIOs needed will increase. There will come a moment when you will want to have
    more and more devices connected to your Raspberry Pi; however, you will not be
    able to do so due to lack of physical ports.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如你现在所理解的，我们可以根据我们的需求控制任何交流电器。我们已经理解了开关，并且也完善了我们可以调节灯光强度和风扇速度的方法。但是你注意到一件事了吗？迟早，随着我们的系统变得越来越复杂，所需的GPIO数量将会增加。会有这样一个时刻，你希望有越来越多的设备连接到你的Raspberry
    Pi；然而，由于物理端口不足，你将无法做到这一点。
- en: This is a very common situation in electronics. As always, there is a solution
    for this problem as well. This solution is known as a multiplexer. The basic job
    of a multiplexer is to multiply the number of ports in any computer system. Now
    you must be thinking, how is it able to do so?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这在电子学中是一个非常常见的情况。就像往常一样，这个问题也有解决方案。这个解决方案被称为多路复用器。多路复用器的基本任务是增加任何计算机系统的端口数量。现在你可能想知道，它是如何做到这一点的？
- en: 'The concept is extremely simple. Let''s first look at the diagram of a multiplexer
    here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念极其简单。让我们首先看看多路复用器的图示：
- en: '![](img/791608bb-5514-40a0-a239-ccbd83872423.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/791608bb-5514-40a0-a239-ccbd83872423.png)'
- en: In the preceding diagram, you can see that there are two ends to the multiplexer—one
    being the signal output lines and the other opposite to it. The first thing we
    need to understand is that the multiplexer is a bidirectional device, that is,
    it sends the data from the multiplexer to the connected devices and also vice
    versa.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，你可以看到多路复用器有两个端点——一个是有信号输出线，另一个与之相对。我们需要首先理解的是，多路复用器是一个双向设备，即它从多路复用器向连接的设备发送数据，同时也相反。
- en: 'Now, firstly, we have the power line, which is pretty basic. It is there to
    power up the multiplexer itself. Then, we have **Signal Lines**, which have two
    ports, the **Sig** and **EN**. **EN** stands for enable, which means that until
    the time **EN** is not high, the data communication will not happen either way.
    Then we have something called **Sig**. This is the port that is connected to the
    GPIO of Raspberry Pi for data communication. Next we have the selection line.
    As you can see, we have four ports for it, namely, **S0**, **S1**, **S2**, and **S3**.
    The selection lines have a purpose of selecting a particular port that needs to
    be selected. The following is a table that will clarify what exactly is happening:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '| **S0** | **S1** | **S3** | **S4** | **Selected output** |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 | C0 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 0 | C1 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 0 | C2 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 0 | C3 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 0 | C4 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 0 | C5 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 0 | C6 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 0 | C7 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 1 | C8 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 1 | C9 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 1 | C10 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 1 | C11 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 1 | C12 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 1 | C13 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 1 | C14 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | C15 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: In the preceding table, you can see that by using various logic combinations
    on the selection lines, various lines can be addressed. Let's say, for example,
    we have the following sequence on the selection pins—S0 = 1, S1 = 0, S2 = 1, S3
    = 1\. If this is the input on the selection pins from Raspberry Pi, then the pin
    number C13 will be selected. This basically means that now C13 can communicate
    the data to and from the pin **Sig** for the multiplexer. Also, we must remember
    that the enable pin must be high for the data transfer to happen.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: In a similar fashion, we can go ahead and address all the 16 pins of the multiplexer.
    Hence, if we see it logically, then by using six pins of Raspberry Pi, we can
    go ahead and utilize 16 GPIOs. Now that we have understood the basics of multiplexing,
    let's go ahead and try using one of them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5ee592f-1b26-414f-9a0e-1dedf0b903c1.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: 'Once the hardware is connected, let''s go ahead and upload the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, what we are essentially doing is, triggering the selection lines one by
    one to address every single port where the LED is connected. Whenever that happens,
    the LED corresponding to it glows. Also, the reason it glows is because the signal
    port `Sig` is connected to 3.3V of Raspberry Pi. Hence, send a logic high to whichever
    port it is connected to.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the basic ways in which the multiplexer works. This can be incredibly
    useful when we will be using multiple devices and sensors.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we enabled Jarvis to automate your home appliances under different
    conditions, also applying various properties to the system. So go on and try many
    other scenarios under which you can enhance your home automation system.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will enable Jarvis IoT, thus controlling the appliances
    from your mobile phone using Wi-Fi and the internet.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将启用Jarvis物联网功能，从而可以通过Wi-Fi和互联网使用您的手机控制家电。
