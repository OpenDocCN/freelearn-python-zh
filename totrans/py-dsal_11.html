<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Selection Algorithms</h1>
            </header>

            <article>
                
<p>One interesting set of algorithms related to finding elements in an unordered list of items is selection algorithms. In doing so, we shall be answering questions that have to do with selecting the median of a set of numbers and selecting the ith-smallest or -largest element in a list, among other things.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Selection by sorting</li>
<li>Randomized selection</li>
<li>Deterministic selection</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Selection by sorting</h1>
            </header>

            <article>
                
<p>Items in a list may undergo statistical enquiries such as finding the mean, median, and mode values. Finding the mean and mode values do not require the list to be ordered. However, to find the median in a list of numbers, the list must first be ordered. Finding the median requires one to find the element in the middle position of the ordered list. But what if we want to find the last-smallest item in the list or the first-smallest item in the list?</p>
<p>To find the ith-smallest number in an unordered list of items, the index of where that item occurs is important to obtain. But because the elements have not been sorted, it is difficult to know whether the element at index 0 in a list is really the first-smallest number.</p>
<p>A pragmatic and obvious thing to do when dealing with unordered lists is to first sort the list. Once the list is sorted, one is assured that the zeroth element in the list will house the first-smallest element in the list. Likewise, the last element in the list will house the last-smallest element in the list.</p>
<p>Assume that perhaps the luxury of sorting before performing the search cannot be afforded. Is it possible to find the ith-smallest element without having to sort the list in the first place?</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Randomized selection</h1>
            </header>

            <article>
                
<p>In the previous chapter, we examined the quick sort algorithm. The quick sort algorithm allows us to sort an unordered list of items but has a way of preserving the index of elements as the sorting algorithm runs. Generally speaking, the quick sort algorithm does the following:</p>
<ol>
<li>Selects a pivot.</li>
<li>Partitions the unsorted list around the pivot.</li>
<li>Recursively sorts the two halves of the partitioned list using <em>step 1</em> and <em>step 2</em>.</li>
</ol>
<p>One interesting and important fact is that after every partitioning step, the index of the pivot will not change even after the list has become sorted. It is this property that enables us to be able to work with a not-so-fully sorted list to obtain the ith-smallest number. Because randomized selection is based on the quick sort algorithm, it is generally referred to as quick select.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Quick select</h1>
            </header>

            <article>
                
<p>The quick select algorithm is used to obtain the ith-smallest element in an unordered list of items, in this case, numbers. We declare the main method of the algorithm as follows:</p>
<pre>
    def quick_select(array_list, left, right, k): <br/><br/>        split = partition(array_list, left, right) <br/><br/>        if split == k: <br/>            return array_list[split] <br/>        elif split &lt; k: <br/>            return quick_select(array_list, split + 1, right, k) <br/>        else: <br/>            return quick_select(array_list, left, split-1, k) 
</pre>
<p>The <kbd>quick_select</kbd> function takes as parameters the index of the first element in the list as well as the last. The ith element is specified by the third parameter <kbd>k</kbd>. Values greater or equal to zero (0) are allowed in such a way that when <kbd>k</kbd> is 0, we know to search for the first-smallest item in the list. Others like to treat the <kbd>k</kbd> parameter so that it maps directly with the index that the user is searching for, so that the first-smallest number maps to the 0 index of a sorted list. It's all a matter of preference.</p>
<p>A method call to the partition function, <kbd>split = partition(array_list, left, right),</kbd> returns the <kbd>split</kbd> index. This index of <kbd>split</kbd> array is the position in the unordered list where all elements between <kbd>right</kbd> to <kbd>split-1</kbd> are less than the element contained in the array <kbd>split</kbd>, while all elements between <kbd>split+1</kbd> to <kbd>left</kbd> are greater.</p>
<p>When the <kbd>partition</kbd> function returns the <kbd>split</kbd> value, we compare it with <kbd>k</kbd> to find out if the <kbd>split</kbd> corresponds to the kth items.</p>
<p>If <kbd>split</kbd> is less than <kbd>k</kbd>, then it means that the kth-smallest item should exist or be found between <kbd>split+1</kbd> and <kbd>right</kbd>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" height="145" src="assets/image_11_001.jpg" width="320"/></div>
<p>In the preceding example, a split within an imaginary unordered list occurs at index 5, while we are searching for the second-smallest number. Since 5&lt;2 yields <kbd>false</kbd>, a recursive call to return <kbd>quick_select(array_list, left, split-1, k)</kbd> is made so that the other half of the list is searched:</p>
<p>If the <kbd>split</kbd> index was less than <kbd>k</kbd>, then we would make a call to <kbd>quick_select</kbd> like this:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" height="140" src="assets/image_11_003-1.jpg" width="333"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Partition step</h1>
            </header>

            <article>
                
<p>The partition step is exactly like we had in the quick sort algorithm. There are a couple of things worthy of note:</p>
<pre>
    def partition(unsorted_array, first_index, last_index): <br/>        if first_index == last_index: <br/>            return first_index <br/><br/>        pivot = unsorted_array[first_index] <br/>        pivot_index = first_index <br/>        index_of_last_element = last_index <br/><br/>        less_than_pivot_index = index_of_last_element <br/>        greater_than_pivot_index = first_index + 1 <br/><br/>        while True: <br/><br/>            while unsorted_array[greater_than_pivot_index] &lt; pivot and  <br/>                  greater_than_pivot_index &lt; last_index: <br/>                  greater_than_pivot_index += 1 <br/>            while unsorted_array[less_than_pivot_index] &gt; pivot and <br/>                  less_than_pivot_index &gt;= first_index: <br/>                  less_than_pivot_index -= 1 <br/><br/>            if greater_than_pivot_index &lt; less_than_pivot_index: <br/>                temp = unsorted_array[greater_than_pivot_index] <br/>                unsorted_array[greater_than_pivot_index] = <br/>                    unsorted_array[less_than_pivot_index] <br/>                unsorted_array[less_than_pivot_index] = temp <br/>            else: <br/>                break <br/><br/>        unsorted_array[pivot_index] =  <br/>            unsorted_array[less_than_pivot_index] <br/>        unsorted_array[less_than_pivot_index] = pivot <br/><br/>        return less_than_pivot_index 
</pre>
<p>An if statement has been inserted at the beginning of the function definition to cater for situations where <kbd>first_index</kbd> is equal to <kbd>last_index</kbd>. In such cases, it means there is only one element in our sublist. We therefore simply return any of the function parameters, in this case, <kbd>first_index</kbd>.</p>
<p>The first element is always chosen as the pivot. This choice to make the first element the pivot is a random decision. It often does not yield a good split and subsequently a good partition. However, the ith element will eventually be found even though the pivot is chosen at random.</p>
<p>The <kbd>partition</kbd> function returns the pivot index pointed to by <kbd>less_than_pivot_index</kbd>, as we saw in the preceding chapter.</p>
<p>From this point on, you will need to follow the program execution with a pencil and paper to get a better feel of how the split variable is being used to determine the section of the list to search for the ith-smallest item.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Deterministic selection</h1>
            </header>

            <article>
                
<p>The worst-case performance of a randomized selection algorithm is <strong>O</strong>(<em>n<sup>2</sup></em>). It is possible to improve on a section of the randomized selection algorithm to obtain a worst-case performance of <strong>O</strong>(<em>n</em>). This kind of algorithm is called <strong>deterministic selection</strong>.</p>
<p>The general approach to the deterministic algorithm is listed here:</p>
<ol>
<li>Select a pivot:
<ol>
<li>Split a list of unordered items into groups of five elements each.</li>
<li>Sort and find the median of all the groups.</li>
<li>Repeat <em>step 1</em> and <em>step 2</em> recursively to obtain the true median of the list.</li>
</ol>
</li>
<li>Use the true median to partition the list of unordered items.</li>
<li>Recurse into the part of the partitioned list that may contain the ith-smallest element.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Pivot selection</h1>
            </header>

            <article>
                
<p>Previously, in the random selection algorithm, we selected the first element as the pivot. We shall replace that step with a sequence of steps that enables us to obtain the true or approximate median. This will improve the partitioning of the list about the pivot:</p>
<pre>
    def partition(unsorted_array, first_index, last_index): <br/><br/>        if first_index == last_index: <br/>            return first_index <br/>        else: <br/>            nearest_median =     <br/>            median_of_medians(unsorted_array[first_index:last_index]) <br/><br/>        index_of_nearest_median = <br/>            get_index_of_nearest_median(unsorted_array, first_index, <br/>                                        last_index, nearest_median) <br/><br/>        swap(unsorted_array, first_index, index_of_nearest_median) <br/><br/>        pivot = unsorted_array[first_index] <br/>        pivot_index = first_index <br/>        index_of_last_element = last_index <br/><br/>        less_than_pivot_index = index_of_last_element <br/>        greater_than_pivot_index = first_index + 1 
</pre>
<p>Let's now study the code for the partition function. The <kbd>nearest_median</kbd> variable stores the true or approximate median of a given list:</p>
<pre>
    def partition(unsorted_array, first_index, last_index): <br/><br/>        if first_index == last_index: <br/>            return first_index <br/>        else: <br/>            nearest_median =   <br/>            median_of_medians(unsorted_array[first_index:last_index]) <br/>        .... 
</pre>
<p>If the <kbd>unsorted_array</kbd> parameter has only one element, <kbd>first_index</kbd> and <kbd>last_index</kbd> will be equal. <kbd>first_index</kbd> is therefore returned anyway.</p>
<p>However, if the list size is greater than one, we call the <kbd>median_of_medians</kbd> function with the section of the array, demarcated by <kbd>first_index</kbd> and <kbd>last_index</kbd>. The return value is yet again stored in <kbd>nearest_median</kbd>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Median of medians</h1>
            </header>

            <article>
                
<p>The <kbd>median_of_medians</kbd> function is responsible for finding the approximate median of any given list of items. The function uses recursion to return the true median:</p>
<pre>
def median_of_medians(elems): <br/><br/>    sublists = [elems[j:j+5] for j in range(0, len(elems), 5)] <br/><br/>    medians = [] <br/>    for sublist in sublists: <br/>        medians.append(sorted(sublist)[len(sublist)/2]) <br/><br/>    if len(medians) &lt;= 5: <br/>        return sorted(medians)[len(medians)/2] <br/>    else: <br/>        return median_of_medians(medians) 
</pre>
<p>The function begins by splitting the list, <kbd>elems</kbd>, into groups of five elements each. This means that if <kbd>elems</kbd> contains 100 items, there will be 20 groups created by the statement <kbd>sublists = [elems[j:j+5] for j in range(0, len(elems), 5)],</kbd> with each containing exactly five elements or fewer:</p>
<pre>
    medians = [] <br/>        for sublist in sublists: <br/>            medians.append(sorted(sublist)[len(sublist)/2]) 
</pre>
<p>An empty array is created and assigned to <kbd>medians,</kbd> which stores the medians in each of the five element arrays assigned to <kbd>sublists</kbd>.</p>
<p>The for loop iterates over the list of lists inside <kbd>sublists</kbd>. Each sublist is sorted, the median found, and stored in the <kbd>medians</kbd> list.</p>
<p>The <kbd>medians.append(sorted(sublist)[len(sublist)/2])</kbd> statement will sort the list and obtain the element stored in its middle index. This becomes the median of the five-element list. The use of an existing sorting function will not impact the performance of the algorithm due to the list's small size.</p>
<div class="packt_infobox">We understood from the outset that we would not sort the list in order to find the ith-smallest element, so why employ Python's sorted method? Well, since we are sorting a very small list of five elements or fewer, the impact of that operation on the overall performance of the algorithm is considered negligible.</div>
<p>Thereafter, if the list now contains five or fewer elements, we shall sort the <kbd>medians</kbd> list and return the element located in its middle index:</p>
<pre>
    if len(medians) &lt;= 5: <br/>            return sorted(medians)[len(medians)/2] 
</pre>
<p>If, on the other hand, the size of the list is greater than five, we recursively call the <kbd>median_of_medians</kbd> function again, supplying it with the list of the medians stored in <kbd>medians</kbd>.</p>
<p>Take, for instance, the following list of numbers:</p>
<p><em>[2, 3, 5, 4, 1, 12, 11, 13, 16, 7, 8, 6, 10, 9, 17, 15, 19, 20, 18, 23, 21, 22, 25, 24, 14]</em></p>
<p>We can break this list into groups of five elements each with the code statement <kbd>sublists = [elems[j:j+5] for j in range(0, len(elems), 5)]</kbd>, to obtain the following list:</p>
<p><em>[[2, 3, 5, 4, 1], [12, 11, 13, 16, 7], [8, 6, 10, 9, 17], [15, 19, 20, 18, 23], [21, 22, 25, 24, 14]]</em></p>
<p>Sorting each of the five-element lists and obtaining their medians produces the following list:</p>
<p><em>[3, 12, 9, 19, 22]</em></p>
<p>Since the list is five elements in size, we only return the median of the sorted list, or we would have made another call to the <kbd>median_of_median</kbd> function.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Partitioning step</h1>
            </header>

            <article>
                
<p>Now that we have obtained the approximate median, the <kbd>get_index_of_nearest_median</kbd> function takes the bounds of the list indicated by the <kbd>first</kbd> and <kbd>last</kbd> parameters:</p>
<pre>
    def get_index_of_nearest_median(array_list, first, second, median): <br/>        if first == second: <br/>            return first <br/>        else: <br/>            return first + array_list[first:second].index(median) 
</pre>
<p>Once again, we only return the first index if there is only one element in the list. The <kbd>arraylist[first:second]</kbd> returns an array with index 0 up to the size of the <kbd>list -1</kbd>. When we find the index of the median, we lose the portion in the list where it occurs because of the new range indexing the <kbd>[first:second]</kbd> code returns. Therefore, we must add whatever index is returned by <kbd>arraylist[first:second]</kbd> to <kbd>first</kbd> to obtain the true index where the median was found:</p>
<pre>
    swap(unsorted_array, first_index, index_of_nearest_median) 
</pre>
<p>We then swap the first element in <kbd>unsorted_array</kbd> with <kbd>index_of_nearest_median</kbd>, using the swap function.</p>
<p>The utility function to swap two array elements is shown here:</p>
<pre>
def swap(array_list, first, second): <br/>    temp = array_list[first] <br/>    array_list[first] = array_list[second] <br/>    array_list[second] = temp 
</pre>
<p>Our approximate median is now stored at <kbd>first_index</kbd> of the unsorted list.</p>
<p>The partition function continues as it would in the code of the quick select algorithm. After the partitioning step, the array looks like this:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" height="119" src="assets/image_11_004-1.jpg" width="402"/></div>
<pre>
<br/> def deterministic_select(array_list, left, right, k): <br/><br/>        split = partition(array_list, left, right) <br/><br/><br/>        if split == k: <br/>            return array_list[split] <br/>        elif split &lt; k : <br/>            return deterministic_select(array_list, split + 1, right, k) <br/>        else: <br/>            return deterministic_select(array_list, left, split-1, k) 
</pre>
<p>As you will have already observed, the main function of the deterministic selection algorithm looks exactly the same as its random selection counterpart. After the initial <kbd>array_list</kbd> has been partitioned about the approximate median, a comparison with the kth element is made.</p>
<p>If <kbd>split</kbd> is less than <kbd>k</kbd>, then a recursive call to <kbd>deterministic_select(array_list, split + 1, right, k)</kbd> is made. This will look for the kth element in that half of the array. Otherwise the function call to <kbd>deterministic_select(array_list, left, split-1, k)</kbd> is made.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>This chapter has examined ways to answer the question of how to find the ith-smallest element in a list. The trivial solution of simply sorting a list to perform the operation of finding the ith-smallest has been explored.</p>
<p>There is also the possibility of not necessarily sorting the list before we can determine the ith-smallest element. The random selection algorithm allows us to modify the quick sort algorithm to determine the ith-smallest element.</p>
<p>To further improve upon the random selection algorithm so that we can obtain a time complexity of <strong>O</strong>(<em>n</em>), we embark on finding the median of medians to enable us find a good split during partitioning.</p>
<p>In the next chapter, we will explore the world of strings. We will learn how to efficiently store and manipulate large amounts of text. Data structures and common string operations will be covered too.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>