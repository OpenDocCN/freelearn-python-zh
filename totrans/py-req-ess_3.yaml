- en: Chapter 3. Authenticating with Requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Requests supports diverse kinds of authentication procedures, and it is built
    in such a way that the method of authentication feels like a cakewalk. In this
    chapter, we opt to throw light on various types of authentication procedures that
    are used by various tech giants for accessing the web resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digest authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kerberos authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Basic authentication is a popular, industry-standard scheme of authentication,
    which is specified in `HTTP 1.0`. This method makes use of a `user-ID` and `password`
    submitted by the user to get authenticated. The submitted `user-ID` and `password`
    are encoded using `Base64` encoding standards and transmitted across HTTP. The
    server gives access to the user only if the `user-ID` and the `password` are valid.
    The following are the advantages of using basic authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of using this scheme is that it is supported by most of the
    web browsers and servers. Even though it is simple and straightforward, it does
    have some disadvantages. Though all the credentials are encoded and transferred
    in the requests, they are not encrypted which makes the process insecure. One
    way to overcome this problem is by using SSL support while initiating a secure
    session.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, the credentials persist on the server until the end of the browser
    session, which may lead to the seizure of the resources. And also, this authentication
    process is wide open to **Cross Site Request Forgery** (**CSRF**) attacks, as
    the browser automatically sends the credentials of the user in the subsequent
    requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The basic authentication flow contains two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If a requested resource needs authentication, the server returns `http 401`
    response containing a `WWW-Authenticate` header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user sends another request with the user ID and password in the `Authorization`
    header, the server processes the submitted credentials and gives the access.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can see this in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic authentication](img/3661_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using basic authentication with Requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the `requests` module to send a request to undergo basic authentication
    very easily. The process can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding lines of code, we performed basic authentication by creating
    an `HTTPBasicAuth` object; then we passed it to the `auth` parameter, which will
    be submitted to the server. If the submitted credentials gets authenticated successfully,
    the server returns a `200` (Successful) response, otherwise, it will return a
    `401` (Unauthorized) response.
  prefs: []
  type: TYPE_NORMAL
- en: Digest authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Digest authentication is one of the well known HTTP authentication schemes,
    which were introduced to overcome most of the drawbacks of basic authentication.
    This type of authentication makes use of `user-ID` and `password` just like Basic
    authentication, but the major difference comes in the picture, when the credentials
    get transferred to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Digest authentication increases the security of the credentials by going an
    extra mile with the concept of cryptographic encryption. When the user submits
    the password for the sake of authentication, the browser will apply an MD5 hashing
    scheme on it. The crux of the process lies in using nonce values (pseudo-random
    numbers) while encrypting the password which decreases the replay attacks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Digest authentication](img/3661_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This type of authentication gains more strength, as the password in this encryption
    is not used in the form of plain text. The cracking of the password hashes becomes
    difficult in digest authentication with the use of a nonce, which counters the
    chosen plain text attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Even though Digest authentication overcomes most of the drawbacks of Basic authentication,
    it does have some disadvantages. This scheme of authentication is vulnerable to
    man-in-the-middle attacks. It reduces the flexibility of storing the password
    in the password's database, as all the well designed password databases use other
    encryption methods to store them.
  prefs: []
  type: TYPE_NORMAL
- en: Using Digest authentication with Requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using Digest authentication with `requests` is very simple. Let us see how
    it''s done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding lines of code, we carried out digest authentication by creating
    an `HTTPDigestAuth` object and setting it to the 'auth' parameter which will be
    submitted to the server. If the submitted credentials gets authenticated successfully,
    the server returns a `200` response, otherwise, it will return a `401` response.
  prefs: []
  type: TYPE_NORMAL
- en: Kerberos authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kerberos is a type of Network authentication protocol, which uses a secret key
    cryptography to communicate between the client and the server. It was developed
    at MIT to mitigate many security problems like replay attacks and spying. It makes
    use of *tickets* to provide authentication for the server-side resources. It followed
    the idea of avoiding additional logins (single sign on) and storing the passwords
    at a centralized location.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, the authentication server, the ticket granting server and the
    host machine act as the leading cast in the process of authentication.
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication Server**: A server-side application which aids in the process
    of authentication by making the use of submitted credentials of a user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ticket Granting Server**: A logical **key distribution center** (**KDC**)
    which validates the tickets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Host Machine**: A server which accepts the requests and provides the resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see this in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Kerberos authentication](img/B03661_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Authentication with Kerberos takes place in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: When a person logs into his machine with the credentials, a request will be
    sent to **ticket** **granting ticket** (**TGT**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the verification of the user turns out to be true, when checked from the
    user database, a session key and a TGT will be created by the authentication server
    (AS).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thus, the obtained TGT and session key will be sent back to the user in the
    form of two messages, in which TGT will be encrypted with the ticket granting
    the server's secret key. The session key will be encrypted with the client secret
    key and it contains a time stamp, life time, TGS name and TGS session key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user on the other end, after receiving the two messages, uses the client
    secret key that is, the user's password to decrypt the messages of the session
    key. The TGT cannot be decrypted without the TGS secret key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the available information of the `session` key and the TGT, the user can
    send a request for accessing the service. The request contains two messages and
    some information at this point. In the two messages, one is an encrypted message,
    containing a user ID and timestamp. The other is a decrypted message, containing
    the HTTP service name and the life time of the ticket. With the above two messages,
    an authenticator and TGT will be sent to the ticket granting server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The messages and the information (Authenticator and TGT) will be received by
    the TGS, and it will check for the credibility of the HTTP service from the KDC
    database and decrypt both the authenticator and the TGT. Once everything goes
    fine, the TGS tries to verify some important parts like client ID, time stamp,
    lifetime of TGT and authenticator. If the verification turns out to be successful,
    then the TGS generates an encrypted HTTP service ticket, HTTP service name, time
    stamp, information about the ticket validity and the session key of HTTP service.
    All of the preceding ones will be encrypted by the HTTP Service session key and
    will be sent back to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the user receives the information and decrypts it with the TGS session
    key that he/she received in the earlier step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next step, to access the HTTP service, the user sends an encrypted HTTP
    service ticket and an authenticator which is encrypted with the HTTP service session
    key to the HTTP service. The HTTP service uses its secret key to decrypt the ticket
    and takes hold of the HTTP service session key. With the acquired HTTP service
    session key, it decrypts the authenticator and verifies the client ID time stamp,
    lifetime of ticket, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the verification turns out to be successful, the HTTP service sends an authenticator
    message with its ID and time stamp to confirm its identity to the user. The user's
    machine verifies the authenticator by making use of HTTP service session key and
    identifies the user as an authenticated one who accesses the HTTP service. From
    then onwards, the HTTP service can be accessed by the user without any bumps,
    until the session key expires.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kerberos is a secure protocol as the passwords from the user can never be sent
    as plain text. As the process of authentication takes place with the agreement
    of both the client and the server through encryption and decryption, it turns
    out to be a rigid one to break to some extent. The other advantage comes from
    its capability to give server access to the user until the session key expires
    without reentering the password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kerberos does have some disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: The server must be continuously available for the verification of the tickets
    which may result in blocking, if the server goes down.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User's keys are saved on a central server. A breach of this server may compromise
    security for the whole infrastructure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kerberos necessitates a heavy infrastructure, which means a simple web server
    is not sufficient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The setup and the administration of Kerberos requires specialized skills.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Kerberos authentication with Requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Requests takes the support of the `requests-kerberos` library for the purpose
    of authentication. For this reason, we should first install the `requests-kerberos`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding lines of code, we carried out Kerberos authentication by creating
    an `HTTPKerberosAuth` object and setting it to the `auth` parameter which will
    be submitted to the server.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OAuth is an open standard authorization protocol, which allows client applications
    a *secure delegated access* to the user accounts on third party services such
    as Google, Twitter, GitHub and so on. In this topic, we are going to introduce
    the two versions:- OAuth 1.0 and OAuth 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 1.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OAuth authentication protocol came up with an idea of mitigating the usage of
    passwords, replacing them with secure handshakes with API calls between the applications.
    This was developed by a small group of web developers who are inspired by OpenID.
  prefs: []
  type: TYPE_NORMAL
- en: Here are the Key terms used in the process of OAuth authentication.
  prefs: []
  type: TYPE_NORMAL
- en: '**Consumer**: The HTTP Client who can make authenticated requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service Provider**: The HTTP Server, which deals with the requests of OAuth'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User**: A person who has the control over the protected resources on the
    HTTP Server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consumer Key and Secret**: Identifiers which have the capability to authenticate
    and authorize a request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request Token and Secret**: Credentials used to gain authorization from the
    user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access Token and Secret**: Credentials to get access to the protected resources
    of the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see this in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![OAuth 1.0](img/B03661_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Initially, the client application asks the service provider to grant a request
    token. A user can be identified as an approved user by taking the credibility
    of the request token. It also helps in acquiring the access token with which the
    client application can access the service provider's resources.
  prefs: []
  type: TYPE_NORMAL
- en: In the second step, the service provider receives the request and issues request
    token, which will be sent back to the client application. Later, the user gets
    redirected to the service provider's authorization page along with the request
    token received before as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, the user grants permission to use the consumer application.
    Now, the service provider returns the user back to the client application, where
    the application accepts an authorized request token and gives back an access token.
    Using the access token, the user will gain an access to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Using OAuth 1.0 authentication with Requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `requests_oauthlib` is a an optional library for `oauth` which is not included
    in the Requests module. For this reason, we should install `requests_oauthlib`
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: OAuth 2.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OAuth 2.0 is next in line to OAuth 1.0 which has been developed to overcome
    the drawbacks of its predecessor. In modern days, OAuth 2.0 has been used vividly
    in almost all leading web services. Due to its ease of use with more security,
    it has attracted many people. The beauty of OAuth 2.0 comes from its simplicity
    and its capability to provide specific authorization methods for different types
    of application like web, mobile and desktop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, there are four workflows available while using OAuth 2.0, which
    are also called **grant types**. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authorization code grant**: This is basically used in web applications for
    the ease of authorization and secure resource delegation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implicit grant**: This flow is used to provide OAuth authorization in Mobile
    Applications.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Resource owner password credentials grant**: This type of grant is used for
    applications using trusted clients.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Client credentials grant**: This type of grant is used in machine to machine
    authentication. An in-depth explanation about grant types is out of the scope
    of this book.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: OAuth 2.0 came up with capabilities which could overcome the concerns of OAuth
    1.0\. The process of using signatures to verify the credibility of API requests
    has been replaced by the use of SSL in OAuth 2.0\. It came up with the idea of
    supporting different types of flow for different environments ranging from web
    to mobile applications. Also, the concept of refresh tokens has been introduced
    to increase the security.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at the usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Custom authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Requests also provides the ability to write a new or custom authentication based
    on the user's needs and flexibility. It is equipped with `requests.auth.AuthBase`
    class which is a base class for all the authentication types. This can be achieved
    by implementing the custom authentication in the `__call__()` of `requests.auth.AuthBase`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we gained knowledge of various types of authentication like
    Basic authentication, Digest authentication, Kerberos authentication, OAuth 1.0
    authentication and OAuth 2.0 authentication which are supported by Requests. Later,
    we got an idea of how to use various types of authentications and the flows of
    the process. We also learned to use our own custom authentication and gained the
    knowledge of making different authentications work with Requests and the ways
    to use them with Requests.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be getting to know all about a handy module, `HTTPretty`.
  prefs: []
  type: TYPE_NORMAL
