- en: Chapter 3. Authenticating with Requests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 使用请求进行身份验证
- en: Requests supports diverse kinds of authentication procedures, and it is built
    in such a way that the method of authentication feels like a cakewalk. In this
    chapter, we opt to throw light on various types of authentication procedures that
    are used by various tech giants for accessing the web resources.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Requests 支持多种认证流程，并且其构建方式使得认证方法感觉像轻松的散步。在本章中，我们选择详细探讨各种技术巨头用于访问网络资源的不同类型的认证流程。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Basic authentication
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本认证
- en: Digest authentication
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摘要认证
- en: Kerberos authentication
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kerberos认证
- en: OAuth authentication
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth认证
- en: Custom authentication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义认证
- en: Basic authentication
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本认证
- en: 'Basic authentication is a popular, industry-standard scheme of authentication,
    which is specified in `HTTP 1.0`. This method makes use of a `user-ID` and `password`
    submitted by the user to get authenticated. The submitted `user-ID` and `password`
    are encoded using `Base64` encoding standards and transmitted across HTTP. The
    server gives access to the user only if the `user-ID` and the `password` are valid.
    The following are the advantages of using basic authentication:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 基本认证是一种流行的、行业标准的认证方案，它在`HTTP 1.0`中被指定。这种方法利用用户提交的`用户ID`和`密码`来进行认证。提交的`用户ID`和`密码`使用`Base64`编码标准进行编码，并通过HTTP传输。只有当`用户ID`和`密码`有效时，服务器才会向用户提供访问权限。以下使用基本认证的优点：
- en: The main advantage of using this scheme is that it is supported by most of the
    web browsers and servers. Even though it is simple and straightforward, it does
    have some disadvantages. Though all the credentials are encoded and transferred
    in the requests, they are not encrypted which makes the process insecure. One
    way to overcome this problem is by using SSL support while initiating a secure
    session.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用此方案的主要优势是它被大多数网络浏览器和服务器支持。尽管它简单直接，但它确实存在一些缺点。尽管所有凭证都在请求中编码和传输，但它们并未加密，这使得整个过程不安全。克服这个问题的方法之一是在启动安全会话时使用SSL支持。
- en: Secondly, the credentials persist on the server until the end of the browser
    session, which may lead to the seizure of the resources. And also, this authentication
    process is wide open to **Cross Site Request Forgery** (**CSRF**) attacks, as
    the browser automatically sends the credentials of the user in the subsequent
    requests.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，凭证在服务器上持续存在，直到浏览器会话结束，这可能会导致资源被占用。此外，这个认证过程很容易受到**跨站请求伪造**（**CSRF**）攻击的影响，因为浏览器会自动在后续请求中发送用户的凭证。
- en: 'The basic authentication flow contains two steps:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 基本认证流程包含两个步骤：
- en: If a requested resource needs authentication, the server returns `http 401`
    response containing a `WWW-Authenticate` header.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果请求的资源需要身份验证，服务器将返回包含`WWW-Authenticate`头部的`http 401`响应。
- en: If the user sends another request with the user ID and password in the `Authorization`
    header, the server processes the submitted credentials and gives the access.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户在`Authorization`头中发送带有用户ID和密码的另一个请求，服务器将处理提交的凭据并授予访问权限。
- en: 'You can see this in the following diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下图表中看到这一点：
- en: '![Basic authentication](img/3661_03_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![基本认证](img/3661_03_01.jpg)'
- en: Using basic authentication with Requests
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Requests进行基本身份验证
- en: 'We can use the `requests` module to send a request to undergo basic authentication
    very easily. The process can be seen as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`requests`模块非常容易地发送一个请求进行基本认证。这个过程可以看作如下：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding lines of code, we performed basic authentication by creating
    an `HTTPBasicAuth` object; then we passed it to the `auth` parameter, which will
    be submitted to the server. If the submitted credentials gets authenticated successfully,
    the server returns a `200` (Successful) response, otherwise, it will return a
    `401` (Unauthorized) response.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，我们通过创建一个`HTTPBasicAuth`对象来执行基本认证；然后将其传递给`auth`参数，该参数将被提交到服务器。如果提交的凭据认证成功，服务器将返回一个`200`（成功）响应，否则，它将返回一个`401`（未授权）响应。
- en: Digest authentication
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要认证
- en: Digest authentication is one of the well known HTTP authentication schemes,
    which were introduced to overcome most of the drawbacks of basic authentication.
    This type of authentication makes use of `user-ID` and `password` just like Basic
    authentication, but the major difference comes in the picture, when the credentials
    get transferred to the server.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要认证是众所周知的一种HTTP认证方案，它被引入以克服基本认证的大部分缺点。这种认证方式与基本认证类似，都使用`用户ID`和`密码`，但主要区别在于凭证传输到服务器时的过程。
- en: Digest authentication increases the security of the credentials by going an
    extra mile with the concept of cryptographic encryption. When the user submits
    the password for the sake of authentication, the browser will apply an MD5 hashing
    scheme on it. The crux of the process lies in using nonce values (pseudo-random
    numbers) while encrypting the password which decreases the replay attacks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要认证通过在加密加密概念上更进一步，增加了凭证的安全性。当用户提交密码以进行身份验证时，浏览器将对其应用MD5散列方案。这个过程的核心在于在加密密码时使用nonce值（伪随机数），这减少了重放攻击。
- en: '![Digest authentication](img/3661_03_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![摘要认证](img/3661_03_02.jpg)'
- en: This type of authentication gains more strength, as the password in this encryption
    is not used in the form of plain text. The cracking of the password hashes becomes
    difficult in digest authentication with the use of a nonce, which counters the
    chosen plain text attacks.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种认证方式变得更加强大，因为在这个加密过程中，密码不是以纯文本形式使用。在摘要认证中使用nonce（一次性随机数），使得密码散列的破解变得困难，从而抵消了选择纯文本攻击。
- en: Even though Digest authentication overcomes most of the drawbacks of Basic authentication,
    it does have some disadvantages. This scheme of authentication is vulnerable to
    man-in-the-middle attacks. It reduces the flexibility of storing the password
    in the password's database, as all the well designed password databases use other
    encryption methods to store them.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 即使摘要认证克服了基本认证的大部分缺点，但它确实存在一些不足。这种认证方案容易受到中间人攻击。它降低了将密码存储在密码数据库中的灵活性，因为所有设计良好的密码数据库都使用其他加密方法来存储密码。
- en: Using Digest authentication with Requests
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Requests库进行摘要认证
- en: 'Using Digest authentication with `requests` is very simple. Let us see how
    it''s done:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`requests`库进行摘要认证非常简单。让我们看看它是如何实现的：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding lines of code, we carried out digest authentication by creating
    an `HTTPDigestAuth` object and setting it to the 'auth' parameter which will be
    submitted to the server. If the submitted credentials gets authenticated successfully,
    the server returns a `200` response, otherwise, it will return a `401` response.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Kerberos authentication
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kerberos认证
- en: Kerberos is a type of Network authentication protocol, which uses a secret key
    cryptography to communicate between the client and the server. It was developed
    at MIT to mitigate many security problems like replay attacks and spying. It makes
    use of *tickets* to provide authentication for the server-side resources. It followed
    the idea of avoiding additional logins (single sign on) and storing the passwords
    at a centralized location.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, the authentication server, the ticket granting server and the
    host machine act as the leading cast in the process of authentication.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，认证服务器、票据授权服务器和主机机作为认证过程中的主要角色。
- en: '**Authentication Server**: A server-side application which aids in the process
    of authentication by making the use of submitted credentials of a user'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证服务器**：一种服务器端应用程序，通过使用用户提交的凭据来辅助认证过程'
- en: '**Ticket Granting Server**: A logical **key distribution center** (**KDC**)
    which validates the tickets'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**票据授权服务器**：一个验证票据的逻辑**密钥分发中心**（**KDC**）'
- en: '**Host Machine**: A server which accepts the requests and provides the resources'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机**: 接受请求并提供资源的服务器'
- en: 'You can see this in the following diagram:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下图表中看到这一点：
- en: '![Kerberos authentication](img/B03661_03_03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: 'Authentication with Kerberos takes place in the following steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: When a person logs into his machine with the credentials, a request will be
    sent to **ticket** **granting ticket** (**TGT**).
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the verification of the user turns out to be true, when checked from the
    user database, a session key and a TGT will be created by the authentication server
    (AS).
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thus, the obtained TGT and session key will be sent back to the user in the
    form of two messages, in which TGT will be encrypted with the ticket granting
    the server's secret key. The session key will be encrypted with the client secret
    key and it contains a time stamp, life time, TGS name and TGS session key.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user on the other end, after receiving the two messages, uses the client
    secret key that is, the user's password to decrypt the messages of the session
    key. The TGT cannot be decrypted without the TGS secret key.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the available information of the `session` key and the TGT, the user can
    send a request for accessing the service. The request contains two messages and
    some information at this point. In the two messages, one is an encrypted message,
    containing a user ID and timestamp. The other is a decrypted message, containing
    the HTTP service name and the life time of the ticket. With the above two messages,
    an authenticator and TGT will be sent to the ticket granting server.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The messages and the information (Authenticator and TGT) will be received by
    the TGS, and it will check for the credibility of the HTTP service from the KDC
    database and decrypt both the authenticator and the TGT. Once everything goes
    fine, the TGS tries to verify some important parts like client ID, time stamp,
    lifetime of TGT and authenticator. If the verification turns out to be successful,
    then the TGS generates an encrypted HTTP service ticket, HTTP service name, time
    stamp, information about the ticket validity and the session key of HTTP service.
    All of the preceding ones will be encrypted by the HTTP Service session key and
    will be sent back to the user.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the user receives the information and decrypts it with the TGS session
    key that he/she received in the earlier step.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next step, to access the HTTP service, the user sends an encrypted HTTP
    service ticket and an authenticator which is encrypted with the HTTP service session
    key to the HTTP service. The HTTP service uses its secret key to decrypt the ticket
    and takes hold of the HTTP service session key. With the acquired HTTP service
    session key, it decrypts the authenticator and verifies the client ID time stamp,
    lifetime of ticket, and so on.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the verification turns out to be successful, the HTTP service sends an authenticator
    message with its ID and time stamp to confirm its identity to the user. The user's
    machine verifies the authenticator by making use of HTTP service session key and
    identifies the user as an authenticated one who accesses the HTTP service. From
    then onwards, the HTTP service can be accessed by the user without any bumps,
    until the session key expires.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kerberos is a secure protocol as the passwords from the user can never be sent
    as plain text. As the process of authentication takes place with the agreement
    of both the client and the server through encryption and decryption, it turns
    out to be a rigid one to break to some extent. The other advantage comes from
    its capability to give server access to the user until the session key expires
    without reentering the password.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Kerberos does have some disadvantages:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The server must be continuously available for the verification of the tickets
    which may result in blocking, if the server goes down.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User's keys are saved on a central server. A breach of this server may compromise
    security for the whole infrastructure.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kerberos necessitates a heavy infrastructure, which means a simple web server
    is not sufficient.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The setup and the administration of Kerberos requires specialized skills.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Kerberos authentication with Requests
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Requests takes the support of the `requests-kerberos` library for the purpose
    of authentication. For this reason, we should first install the `requests-kerberos`
    module.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s have a look at the syntax:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding lines of code, we carried out Kerberos authentication by creating
    an `HTTPKerberosAuth` object and setting it to the `auth` parameter which will
    be submitted to the server.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: OAuth authentication
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OAuth is an open standard authorization protocol, which allows client applications
    a *secure delegated access* to the user accounts on third party services such
    as Google, Twitter, GitHub and so on. In this topic, we are going to introduce
    the two versions:- OAuth 1.0 and OAuth 2.0.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 1.0
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OAuth authentication protocol came up with an idea of mitigating the usage of
    passwords, replacing them with secure handshakes with API calls between the applications.
    This was developed by a small group of web developers who are inspired by OpenID.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Here are the Key terms used in the process of OAuth authentication.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '**Consumer**: The HTTP Client who can make authenticated requests'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service Provider**: The HTTP Server, which deals with the requests of OAuth'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User**: A person who has the control over the protected resources on the
    HTTP Server'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consumer Key and Secret**: Identifiers which have the capability to authenticate
    and authorize a request'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request Token and Secret**: Credentials used to gain authorization from the
    user'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access Token and Secret**: Credentials to get access to the protected resources
    of the user'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see this in the following diagram:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![OAuth 1.0](img/B03661_03_04.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: Initially, the client application asks the service provider to grant a request
    token. A user can be identified as an approved user by taking the credibility
    of the request token. It also helps in acquiring the access token with which the
    client application can access the service provider's resources.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: In the second step, the service provider receives the request and issues request
    token, which will be sent back to the client application. Later, the user gets
    redirected to the service provider's authorization page along with the request
    token received before as an argument.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, the user grants permission to use the consumer application.
    Now, the service provider returns the user back to the client application, where
    the application accepts an authorized request token and gives back an access token.
    Using the access token, the user will gain an access to the application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Using OAuth 1.0 authentication with Requests
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `requests_oauthlib` is a an optional library for `oauth` which is not included
    in the Requests module. For this reason, we should install `requests_oauthlib`
    separately.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at the syntax:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: OAuth 2.0
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OAuth 2.0 is next in line to OAuth 1.0 which has been developed to overcome
    the drawbacks of its predecessor. In modern days, OAuth 2.0 has been used vividly
    in almost all leading web services. Due to its ease of use with more security,
    it has attracted many people. The beauty of OAuth 2.0 comes from its simplicity
    and its capability to provide specific authorization methods for different types
    of application like web, mobile and desktop.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, there are four workflows available while using OAuth 2.0, which
    are also called **grant types**. They are:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '**Authorization code grant**: This is basically used in web applications for
    the ease of authorization and secure resource delegation.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implicit grant**: This flow is used to provide OAuth authorization in Mobile
    Applications.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Resource owner password credentials grant**: This type of grant is used for
    applications using trusted clients.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Client credentials grant**: This type of grant is used in machine to machine
    authentication. An in-depth explanation about grant types is out of the scope
    of this book.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: OAuth 2.0 came up with capabilities which could overcome the concerns of OAuth
    1.0\. The process of using signatures to verify the credibility of API requests
    has been replaced by the use of SSL in OAuth 2.0\. It came up with the idea of
    supporting different types of flow for different environments ranging from web
    to mobile applications. Also, the concept of refresh tokens has been introduced
    to increase the security.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at the usage:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Custom authentication
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Requests also provides the ability to write a new or custom authentication based
    on the user's needs and flexibility. It is equipped with `requests.auth.AuthBase`
    class which is a base class for all the authentication types. This can be achieved
    by implementing the custom authentication in the `__call__()` of `requests.auth.AuthBase`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at its syntax:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Summary
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we gained knowledge of various types of authentication like
    Basic authentication, Digest authentication, Kerberos authentication, OAuth 1.0
    authentication and OAuth 2.0 authentication which are supported by Requests. Later,
    we got an idea of how to use various types of authentications and the flows of
    the process. We also learned to use our own custom authentication and gained the
    knowledge of making different authentications work with Requests and the ways
    to use them with Requests.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be getting to know all about a handy module, `HTTPretty`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
