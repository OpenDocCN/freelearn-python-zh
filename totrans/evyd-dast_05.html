<html><head></head><body>
<div class="book" title="Chapter&#xA0;5.&#xA0;Queues: FIFO Collections" id="VF2I1-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. Queues: FIFO Collections</h1></div></div></div><p class="calibre7">A <span class="strong"><strong class="calibre16">queue</strong></span> is an abstract data structure that serves as a linear collection of objects that are inserted and removed based on the <span class="strong"><strong class="calibre16">first-in first-out</strong></span> (<span class="strong"><strong class="calibre16">FIFO</strong></span>) principle. The two most notable operations of a queue are <span class="strong"><strong class="calibre16">enqueue</strong></span>, which adds objects to the tail or back of the collection, and <span class="strong"><strong class="calibre16">dequeue</strong></span>, which removes objects from the head or front of the collection. The following figure demonstrates the queue data structure as well as these two basic operations. Other common operations include <span class="strong"><strong class="calibre16">peek</strong></span>, <span class="strong"><strong class="calibre16">empty</strong></span>, and <span class="strong"><strong class="calibre16">full</strong></span>, all of which will be examined later in this chapter:</p><p class="calibre7">
</p><div class="mediaobject"><img src="../images/00007.jpeg" alt="Queues: FIFO Collections" class="calibre17"/></div><p class="calibre18"> </p><p class="calibre7">
</p><p class="calibre7">Queues are very similar to stacks and they share some of the same functionality. Even two of their primary operations are very similar, just implemented on opposite principles. Like a stack, a queue can be either array-based or linked list-based, and the linked list based version is more efficient in most cases. However, unlike a stack, which can be sorted or unsorted, a queue is not intended to be sorted at all and sorting a queue whenever an object is added to the collection results in a terrible <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n.log(n)</em></span>) operational cost. One alternative version of the queue, called a <span class="strong"><strong class="calibre16">priority queue</strong></span>, is based on a <span class="strong"><strong class="calibre16">heap</strong></span> data structure. The priority queue does support a type of sorting, but it is still expensive and not generally used outside special applications.</p><p class="calibre7">Overall, a queue data structure is well suited for any application that requires the ability to prioritize operations on a <span class="strong"><em class="calibre20">first-come first-served</em></span> basis. If you are having trouble visualizing a queue structure, just think of any time you had to stand in line. In primary school, we waited for the drinking fountain; in supermarkets, we wait for the cashier; in the deli, we wait for <span class="strong"><em class="calibre20">our number</em></span>; in various government offices, we wait (and wait) for the next available teller. In fact, we have all been queuing since the day we were born... unless you are a twin in which case you started just a little sooner than most of us.</p><p class="calibre7">In this chapter, we will cover the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Definition of a queue data structure</li><li class="listitem">Initializing queues</li><li class="listitem">Case study - customer service</li><li class="listitem">Queue implementations</li><li class="listitem">Common queue operations</li><li class="listitem">Array-based queues</li><li class="listitem">List-based queues</li><li class="listitem">Heap-based queues</li><li class="listitem">Double-ended queues</li><li class="listitem">Priority queues</li></ul></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Queues: FIFO Collections" id="VF2I1-77f2b5b248f04368a6f723b0e9357ef3">
<div class="book" title="Initializing queues"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec25" class="calibre1"/>Initializing queues</h1></div></div></div><p class="calibre7">Each language provides varying levels of support for the queue data structure. Here are some examples of initializing the collection, adding an object to the back of the collection, and then removing the head object from the head of the collection.</p><p class="calibre7"><span class="strong"><strong class="calibre16">C#</strong></span></p><p class="calibre7">C# provides a concrete implementation of the queue data structure through the <code class="literal">Queue&lt;T&gt;</code> generic class:</p><pre class="programlisting">    Queue&lt;MyObject&gt; aQueue = new Queue&lt;MyObject&gt;(); 
    aQueue.Enqueue(anObject); 
    aQueue.Dequeue(); 
</pre><span class="strong"><strong class="calibre16">Java</strong></span><p class="calibre7">Java provides the abstract <code class="literal">Queue&lt;E&gt;</code> interface, and several concrete implementations of the queue data structure use this interface. Queue is also extended to the <code class="literal">Deque&lt;E&gt;</code> interface that represents a <span class="strong"><strong class="calibre16">double-ended queue</strong></span>. The <code class="literal">ArrayDeque&lt;E&gt;</code> class is one concrete implementation of the <code class="literal">Deque&lt;E&gt;</code> interface:</p><pre class="programlisting">    ArrayDeque&lt;MyObject&gt; aQueue = new ArrayDeque&lt;MyObject&gt;(); 
    aQueue.addLast(anObject); 
    aQueue.getFirst(); 
</pre><p class="calibre7"><span class="strong"><strong class="calibre16">Objective-C</strong></span></p><p class="calibre7">Objective-C does not provide a concrete implementation of the queue data structure, but one can be easily created using the <code class="literal">NSMutableArray</code> class cluster. Be aware that this will create an array-based implementation of the queue, which is <span class="strong"><em class="calibre20">generally</em></span> less efficient than a linked list-based implementation:</p><pre class="programlisting">    NSMutableArray&lt;MyObject *&gt; *aStack = [NSMutableArray array]; 
    [aStack addObject:anObject]; 
    [aStack removeObjectAtIndex:0]; 
</pre><div class="informaltable" title="Note"><h3 class="title1"><a id="note25" class="calibre1"/>Note</h3><p class="calibre7">I was curious about the measurable difference in efficiency between a stack and a queue implemented with <code class="literal">NSMutableArray</code>, so I performed a series of simple tests. In these tests, I began by instantiating an <code class="literal">NSMutableArray</code> object with 1,000,000 <code class="literal">EDSUser</code> objects. In the first test, I treated the array as a stack and sequentially <span class="strong"><em class="calibre20">popped</em></span> each item from the tail of the array by calling the <code class="literal">removeLastObject</code> object. In the second test, I treated the array as a queue and sequentially <span class="strong"><em class="calibre20">dequeued</em></span> each user from the head of the array by calling <code class="literal">removeObjectAtIndex:0</code>. Using a <code class="literal">for</code> loop, I performed each series of tests 1,000 times, then averaged the time it took to remove all of the objects through each iteration. I was expecting the queue structure to operate on-par, or slightly less efficiently than, the stack structure, so I was surprised by these results:</p><p class="calibre7">Average stack time: 0.202993</p><p class="calibre7">Average queue time: 0.184913</p><p class="calibre7">As you can see, the queue structure actually performed slightly <span class="strong"><em class="calibre20">better</em></span> than the stack structure, clocking in at about 18 milliseconds faster on average. Of course, results will vary between environments and 18 milliseconds is hardly worth noting, but following these tests, I feel confident in saying that the <code class="literal">NSMutableArray</code> class is suitably efficient to function as a queue structure. If you would like to run the test yourself, execute the static methods <code class="literal">stackTest</code> and <code class="literal">queueTest</code> in <code class="literal">EDSCollectionTests</code> found in the Objective-C code files for this text.</p></div><p class="calibre7"><span class="strong"><strong class="calibre16">Swift</strong></span></p><p class="calibre7">Like Objective-C, Swift does not provide a concrete implementation of the queue data structure, but the <code class="literal">Array</code> class can be used to implement the structure. The following example demonstrates the <code class="literal">append()</code> and <code class="literal">popLast()</code> methods:</p><pre class="programlisting">    var aStack: Array [MyObject](); 
    aStack.append(anObject) 
    aStack.popLast() 
</pre></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Queues: FIFO Collections" id="VF2I1-77f2b5b248f04368a6f723b0e9357ef3">
<div class="book" title="Initializing queues">
<div class="book" title="Queue operations"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch05lvl2sec27" class="calibre1"/>Queue operations</h2></div></div></div><p class="calibre7">Not all implementations of queue data structures expose the same operational methods. However, the more common operations should be available or made available as needed by the developer:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre16">enqueue</strong></span>: The enqueue operation adds a new object into the back of the queue by either appending to the collection, if it is array-based, or adding a new node to the collection if it is linked list-based.</li><li class="listitem"><span class="strong"><strong class="calibre16">dequeue</strong></span>: The dequeue operation is the opposite of enqueue. In most implementations, the dequeue operation both removes and returns the first object from the array or list to the caller.</li><li class="listitem"><span class="strong"><strong class="calibre16">peek</strong></span>: The peek operation returns the first object from the array or list to the caller, but does not remove the object from the collection.</li><li class="listitem"><span class="strong"><strong class="calibre16">count</strong></span>: The count operation returns the total number of objects or nodes currently in the collection.</li><li class="listitem"><span class="strong"><strong class="calibre16">empty</strong></span>: The empty operation typically returns a boolean value denoting whether the collection has any objects.</li><li class="listitem"><span class="strong"><strong class="calibre16">full</strong></span>: The full operation typically returns a boolean value denoting whether the collection is at capacity or if there is still room to add more objects. Not all implementations allow the caller to define the capacity, but this detail can be easily added using the queue count.</li></ul></div></div></div></div>
<div class="book" title="Case study: customer service"><div class="book" id="10DJ42-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec26" class="calibre1"/>Case study: customer service</h1></div></div></div><p class="calibre7"><span class="strong"><strong class="calibre16">Business problem</strong></span>: A small software firm wants to break into a new market with a mobile app for tracking customer service requests at <span class="strong"><strong class="calibre16">Department of Motor Vehicles</strong></span> (<span class="strong"><strong class="calibre16">DMV</strong></span>) service locations. The app will allow users to <span class="strong"><em class="calibre20">take a number</em></span> with their mobile device as they pass into a <span class="strong"><strong class="calibre16">geofence</strong></span> representing the service area. This will allow customers to immediately move to the next available window or to take a seat and wait comfortably for an associate to assist them. One primary business requirement states that service will be delivered to customers on a first-come, first-served basis. In addition to the business requirements, the team wants to implement the core functionality with a generic design so that they can expand to new markets without the need to modify the underlying business logic.</p><p class="calibre7">The developer in charge of creating the core functionality decides that the class that keeps track of each customer's position in line should be bundled with the web service. This class will require some mechanism for adding and removing customers as part of normal operation, as well as the ability to clear all of the customers from the waiting list when the office closes for the day. As customers will typically like to know how long they can expect to wait before speaking with an associate; the class must also be able to report the number of customers currently waiting to be seen in total as well as those in front of the current customer. In the event that the customer's mobile device crosses the geofence again, they have effectively left the service area and forfeited their place in line. Therefore, although removing an object from the middle of a queue is not a queue-like operation, the class should also be able to cancel a customer's position from the line when they leave before speaking with an associate. Finally, the class should be able to report when the customer list is empty and when it has reached the occupancy limit of the location.</p><p class="calibre7"><span class="strong"><strong class="calibre16">C#</strong></span></p><p class="calibre7">As seen in the implementation examples, C# has queue support in the <code class="literal">Queue&lt;T&gt;</code> class. This class is generic, and it includes all of the basic operations that we need to implement the <code class="literal">CustomerQueue</code> class. Here's an example of what a simple implementation using C# might look like:</p><pre class="programlisting">    Queue&lt;Customer&gt; _custQueue; 
    int _cap; 
 
    public CustomerQueue(int capacity) 
    { 
        _custQueue = new Queue&lt;Customer&gt;(); 
        _cap = capacity; 
    } 
</pre><p class="calibre7">Our class declares two fields. The first is <code class="literal">_custQueue</code>, which represents our queue data structure and the core of this class. The field is private, so only methods within our class can modify it. The second field is <code class="literal">_cap</code> and it maintains our caller-defined maximum number of customers in the collection. Finally, the constructor initializes <code class="literal">_custQueue</code> and assigns <code class="literal">capacity</code> to <code class="literal">_cap</code>:</p><pre class="programlisting">    private bool CanCheckinCustomer() 
    { 
        return this._custQueue.Count &lt; this._cap; 
    } 
</pre><p class="calibre7">The <code class="literal">CanCheckinCustomer()</code> method adds simple validation to <code class="literal">CustomerQueue</code> by confirming that <code class="literal">_custQueue.Count</code> is less than the defined capacity and returning the result:</p><pre class="programlisting">    public void CustomerCheckin(Customer c) 
    { 
        if (this.CanCheckinCustomer()) 
        { 
            this._custQueue.Enqueue(c); 
        } 
    } 
</pre><p class="calibre7">The first of the two basic queue operations, <span class="strong"><em class="calibre20">enqueue</em></span>, is wrapped in the <code class="literal">CustomerCheckin(Customer)</code> method. This method validates that a new <code class="literal">Customer</code> object can be added and then calls <code class="literal">Enqueue(T)</code> to add <code class="literal">c</code> to the <code class="literal">_custQueue</code> collection. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost:</p><pre class="programlisting">    public Customer CustomerConsultation() 
    { 
        return this._custQueue.Peek(); 
    } 
</pre><p class="calibre7">In order to maintain an accurate number of customers currently waiting in line, we don't want to dequeue a customer until an associate has attended to their needs or inquiry. Therefore, when a customer has reached the head of the queue, the <code class="literal">CustomerConsultation()</code> method calls <code class="literal">Peek()</code>. This returns the next <code class="literal">Customer</code> object in <code class="literal">_custQueue</code> but does not remove that object from the collection. Effectively, this method provides the necessary data for a <code class="literal">Now Serving:</code> message or something equivalent. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost:</p><pre class="programlisting">    public void CustomerCheckout() 
    { 
        this._custQueue.Dequeue(); 
    } 
</pre><p class="calibre7">Once an associate has completed a transaction with their current customer, the customer's place in the queue can be cleared. The <code class="literal">CustomerCheckout()</code> method calls the <code class="literal">Dequeue()</code> method, which removes the <code class="literal">Customer</code> object from the front position of <code class="literal">_custQueue</code>. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost:</p><pre class="programlisting">    public void ClearCustomers() 
    { 
        this._custQueue.Clear(); 
    } 
</pre><p class="calibre7">When it's time to close the doors our class needs a way to clear out stragglers. The <code class="literal">ClearCustomers()</code> method provides the <span class="strong"><em class="calibre20">clear</em></span> functionality, so our class can reset the collection to an empty state:</p><pre class="programlisting">    public void CustomerCancel(Customer c) 
    { 
        Queue&lt;Customer&gt; tempQueue = new Queue&lt;Customer&gt;(); 
        foreach (Customer cust in this._custQueue) 
        { 
            if (cust.Equals(c)) 
            { 
                continue; 
            } 
            tempQueue.Enqueue(c); 
        } 
        this._custQueue = tempQueue; 
    } 
</pre><p class="calibre7">The <code class="literal">CustomerCancel(Customer)</code> method introduces the non-queue operation to remove the <code class="literal">Customer</code> objects from the <code class="literal">_custQueue</code> collection. As <code class="literal">Queue&lt;T&gt;</code> provides no interface for this operation, we need to improvise. This method first creates a temporary queue collection, <code class="literal">tempQueue</code>, then loops through every <code class="literal">Customer</code> object in <code class="literal">_custQueue</code>. If <code class="literal">cust</code> is not equal to <code class="literal">c</code>, it is added to <code class="literal">tempQueue</code>. When our <code class="literal">for</code> loop has finished, only those customers who are still in line will have been added to <code class="literal">tempQueue</code>. Finally, <code class="literal">tempQueue</code> is assigned to <code class="literal">_custQueue</code>. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>) cost, but this is acceptable as the method should not be called often as part of normal operations:</p><pre class="programlisting">    public int CustomerPosition(Customer c) 
    { 
        if (this._custQueue.Contains(c)) 
        { 
            int i = 0; 
            foreach (Customer cust in this._custQueue) 
            {  
                if (cust.Equals(c)) 
                { 
                    return i; 
                } 
                i++; 
            } 
        } 
        return -1;  
    } 
</pre><p class="calibre7">In order to estimate a customer's current wait time with any sort of accuracy, it is necessary to know their position in the queue and <code class="literal">CustomerPosition(Customer)</code> gives our class that functionality. Again, <code class="literal">Queue&lt;T&gt;</code> does not provide the functionality, so we need to write our own. The <code class="literal">CustomerPosition(Customer)</code> method checks whether <code class="literal">_custQueue</code> contains the <code class="literal">Customer</code> we are looking for. If the collection does not contain <code class="literal">Customer c</code>, the method returns <code class="literal">-1</code>. Otherwise, it loops through the entire collection until <code class="literal">c</code> is located. The <code class="literal">Customer c</code> object located at the back of the queue is the worst case for both the <code class="literal">Queue&lt;T&gt;.Contains(T)</code> method and the <code class="literal">foreach</code> loop, each representing an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>) cost. Since these operations are nested, this method carries an overall cost of <span class="strong"><strong class="calibre16">O</strong></span>(2<span class="strong"><em class="calibre20">n</em></span>):</p><pre class="programlisting">    public int CustomersInLine() 
    { 
        return this._custQueue.Count; 
    } 
 
    public bool IsLineEmpty() 
    { 
        return this._custQueue.Count == 0; 
    } 
 
    public bool IsLineFull() 
    { 
        return this._custQueue.Count == this.cap; 
    } 
</pre><p class="calibre7">The final three methods, <code class="literal">CustomersInLine()</code>, <code class="literal">IsLineEmpty()</code>, and <code class="literal">IsLineFull()</code>, introduce the <span class="strong"><em class="calibre20">count</em></span>, <span class="strong"><em class="calibre20">empty</em></span>, and <span class="strong"><em class="calibre20">full</em></span> functionality for our class. Each of these operations has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="tip26" class="calibre1"/>Tip</h3><p class="calibre7"><span class="strong"><strong class="calibre16">Nested Loops</strong></span></p><p class="calibre7">Always look twice when you find yourself nesting loops. Looking at this implementation as a whole, the <code class="literal">CustomerPosition()</code> method is of particular concern for two reasons. An <span class="strong"><strong class="calibre16">O</strong></span>(2<span class="strong"><em class="calibre20">n</em></span>) operational cost is extremely pricey for such a simple operation. This is compounded by the fact that users have a tendency to be impatient under the best of circumstances and could, therefore, monitor the expected wait time almost constantly. This user behavior will translate into multiple calls to the <code class="literal">CustomerPosition()</code> method. Arguably, this inefficiency can be ignored in practice as the time needed to process a list of people standing in a physical line, even a line waiting to enter a stadium, would be minimal. However, an algorithm whose cost is <span class="strong"><em class="calibre20">x<sup class="calibre21">n</sup></em></span>, where <span class="strong"><em class="calibre20">x</em></span> &gt; 1, has a bad <span class="strong"><em class="calibre20">code smell</em></span> and most developers would try to architect a better solution to the problem before releasing this one into the wild.</p></div><p class="calibre7"><span class="strong"><strong class="calibre16">Java</strong></span></p><p class="calibre7">As discussed in the implementation examples, Java supports several concrete implementations of lists that could be used for a queue class, but the most appropriate versions conform to the double-ended queue <code class="literal">Dequeue&lt;E&gt;</code> interface. One concrete implementation is the <code class="literal">ArrayQueue&lt;E&gt;</code> class. Here's an example of what a simple implementation using Java's <code class="literal">ArrayQueue&lt;E&gt;</code> class might look like:</p><pre class="programlisting">    ArrayQueue&lt;Customer&gt; _custQueue; 
    int _cap; 

    public CustomerQueue(int capacity) 
    { 
        _custQueue = new ArrayDeque&lt;Customer&gt;(); 
        _cap = capacity; 
    } 
</pre><p class="calibre7">Our class declares two fields. The first is <code class="literal">_custQueue</code>, which represents our queue data structure and the core of this class. The field is private, so only methods within our class can modify it. The second field is <code class="literal">_cap</code>, which maintains our caller-defined maximum number of customers in the collection. Finally, the constructor initializes <code class="literal">_custQueue</code> and assigns <code class="literal">capacity</code> to <code class="literal">_cap</code>:</p><pre class="programlisting">    private boolean canCheckinCustomer() 
    { 
        return this._custQueue.size() &lt; this._cap; 
    }   
</pre><p class="calibre7">The <code class="literal">canCheckinCustomer()</code> method adds simple validation to <code class="literal">CustomerQueue</code> by confirming that <code class="literal">_custQueue.size()</code> is less than the defined capacity and returning the result:</p><pre class="programlisting">    public void customerCheckin(Customer c) 
    { 
        if (this.canCheckinCustomer()) 
        { 
            this._custQueue.addLast(c); 
        } 
    }  
</pre><p class="calibre7">The first of the two basic queue operations, <span class="strong"><em class="calibre20">enqueue</em></span>, is wrapped in the <code class="literal">customerCheckin(Customer)</code> method. This method confirms that we can add a new <code class="literal">Customer</code> to the queue then calls <code class="literal">AddLast(E)</code> to add <code class="literal">c</code> to the <code class="literal">_custQueue</code> collection. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost:</p><pre class="programlisting">    public Customer customerConsultation() 
    { 
        return this._custQueue.peek(); 
    } 
</pre><p class="calibre7">In order to maintain an accurate number of customers currently waiting in line, we don't want to dequeue a customer until an associate has attended to their needs or inquiry. Therefore, when a customer has reached the head of the queue the <code class="literal">customerConsultation()</code> method calls <code class="literal">peek()</code>. This returns the next <code class="literal">Customer</code> in <code class="literal">_custQueue</code>, but it does not remove that object from the collection. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost:</p><pre class="programlisting">    public void customerCheckout() 
    { 
        this._custQueue.removeFirst(); 
    } 
</pre><p class="calibre7">Once an associate has completed a transaction with their current customer, the customer's place in the queue can be cleared. The <code class="literal">customerCheckout()</code> method calls <code class="literal">Dequeue()</code>, which removes the <code class="literal">Customer</code> object from the front position of <code class="literal">_custQueue</code>. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost:</p><pre class="programlisting">    public void clearCustomers() 
    { 
        this._custQueue.clear(); 
    } 
</pre><p class="calibre7">The <code class="literal">ClearCustomers()</code> method provides the <span class="strong"><em class="calibre20">clear</em></span> functionality, so our class can reset the collection to an empty state:</p><pre class="programlisting">    public void customerCancel(Customer c) 
    { 
        this._custQueue.remove(c); 
    } 
</pre><p class="calibre7">The <code class="literal">customerCancel(Customer)</code> method introduces the non-queue operation to remove <code class="literal">Customer</code> objects from the <code class="literal">_custQueue</code> collection. As <code class="literal">ArrayQueue&lt;E&gt;</code> provides the <code class="literal">remove(E)</code> method to remove any objects matching <code class="literal">E</code> from the queue, <code class="literal">customerCancel(Customer)</code> simply calls that method. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>) cost, but this is acceptable as the method should not be called often during normal operations:</p><pre class="programlisting">    public int customerPosition(Customer c) 
    { 
        if (this._custQueue.contains(c)) 
        { 
            int i = 0; 
            for (Customer cust : this._custQueue) 
            { 
                if (cust.equals(c)) 
                { 
                    return i; 
                } 
                i++; 
            } 
        } 
 
        return -1; 
    } 
</pre><p class="calibre7">In order to estimate a customer's current wait time with any sort of accuracy, it is necessary to know their position in the queue. The <code class="literal">customerPosition(Customer)</code> method gives our class a position functionality. The <code class="literal">ArrayQueue&lt;E&gt;</code> interface does not provide this functionality, so we need to write our own. <code class="literal">CustomerPosition(Customer)</code> checks whether <code class="literal">_custQueue</code> contains the <code class="literal">Customer</code> we are looking for. If the collection does not contain <code class="literal">Customer c</code>, the method returns <code class="literal">-1</code>. Otherwise, it loops through the entire collection until <code class="literal">c</code> is located. The <code class="literal">Customer c</code> object located at the back of the queue is the worst case for both the <code class="literal">Queue&lt;T&gt;.Contains(T)</code> method and the <code class="literal">foreach</code> loop, each representing an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>) cost. Since these operations are nested, this method carries an overall cost of <span class="strong"><strong class="calibre16">O</strong></span>(2<span class="strong"><em class="calibre20">n</em></span>):</p><pre class="programlisting">    public int customersInLine() 
    { 
        return this._custQueue.size(); 
    } 
 
    public boolean isLineEmpty() 
    { 
        return this._custQueue.size() == 0;  
    } 
 
    public boolean isLineFull() 
    { 
        return this._custQueue.size() == this._cap; 
    } 
</pre><p class="calibre7">The final three methods, <code class="literal">customersInLine()</code>, <code class="literal">isLineEmpty()</code>, and <code class="literal">isLineFull()</code>, introduce the <span class="strong"><em class="calibre20">count</em></span>, <span class="strong"><em class="calibre20">empty</em></span>, and <span class="strong"><em class="calibre20">full</em></span> functionality for our class. Each of these operations have an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Objective-C</strong></span></p><p class="calibre7">As discussed earlier, Objective-C does not provide a concrete implementation of a queue data structure, but one can be mimicked easily using the <code class="literal">NSMutableArray</code> class cluster. Here's what a simple example of that implementation might look like:</p><pre class="programlisting">    NSMutableArray *_custQueue; 
    int _cap; 
 
    -(instancetype)initWithCapacity:(int)capacity 
    { 
        if (self = [super init]) 
        { 
            _custQueue = [NSMutableArray array]; 
            _cap = capacity; 
        } 
        return self; 
    } 
</pre><p class="calibre7">Our class declares two <span class="strong"><strong class="calibre16">ivar</strong></span> properties. The first is an <code class="literal">NSMutableArray</code> object named <code class="literal">_custQueue</code>, which represents our queue data structure and the core of this class. The second field is <code class="literal">_cap</code>. This field maintains our caller-defined maximum number of customers in the collection. Both of these are ivars, so only methods in our class can modify their values. Finally, the constructor initializes <code class="literal">_custQueue</code> and assigns <code class="literal">capacity</code> to <code class="literal">_cap</code>:</p><pre class="programlisting">    -(BOOL)canCheckinCustomer 
    { 
        return [_custQueue count] &lt; _cap; 
    } 
</pre><p class="calibre7">The <code class="literal">canCheckinCustomer:</code> adds simple validation to <code class="literal">CustomerQueue</code> by confirming that <code class="literal">[_custQueue count]</code> is less than the defined capacity and returning the result:</p><pre class="programlisting">    -(void)checkInCustomer:(EDSCustomer*)c 
    { 
        if ([self canCheckinCustomer]) 
        { 
            [_custQueue addObject:c]; 
        } 
    } 
</pre><p class="calibre7">The first of the two basic queue operations, <span class="strong"><em class="calibre20">enqueue</em></span>, is wrapped in the <code class="literal">checkInCustomer:</code> method. This method confirms that we can add a new <code class="literal">Customer</code> to the queue and then calls <code class="literal">addObject:</code> method to add <code class="literal">c</code> to the <code class="literal">_custQueue</code> collection. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost:</p><pre class="programlisting">    -(EDSCustomer*)customerConsultation 
    { 
        return [_custQueue firstObject]; 
    } 
</pre><p class="calibre7">In order to maintain an accurate number of customers currently waiting in line, we don't want to <span class="strong"><em class="calibre20">dequeue</em></span> a customer until an associate has attended to their needs or inquiry. Therefore, when a customer has reached the head of the queue, the <code class="literal">customerConsultation:</code> method returns <code class="literal">firstObject</code>. This returns the next <code class="literal">Customer</code> in <code class="literal">_custQueue</code>, but it does not remove that object from the collection. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost:</p><pre class="programlisting">    -(void)checkoutCustomer 
    { 
        [_custQueue removeObjectAtIndex:0]; 
    } 
</pre><p class="calibre7">Once an associate has completed a transaction with their current customer, the customer's place in the queue can be cleared. The <code class="literal">checkoutCustomer:</code> method calls <code class="literal">removeObjectAtIndex:0</code>, which removes the <code class="literal">Customer</code> object from the front position of <code class="literal">_custQueue</code>. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost:</p><pre class="programlisting">-(void)clearCustomers 
{ 
    [_custQueue removeAllObjects]; 
} 
</pre><p class="calibre7">The <code class="literal">clearCustomers:</code> method provides the <span class="strong"><em class="calibre20">clear</em></span> functionality, so our class can reset the collection to an empty state:</p><pre class="programlisting">    -(void)cancelCustomer:(EDSCustomer*)c 
    { 
        NSUInteger index = [self positionOfCustomer:c]; 
        if (index != -1) 
        { 
            [_custQueue removeObjectAtIndex:index]; 
        } 
    } 
</pre><p class="calibre7">The <code class="literal">cancelCustomer:</code> method introduces the non-queue operation to remove the <code class="literal">Customer</code> objects from the <code class="literal">_custQueue</code> collection. As <code class="literal">NSMutableArray</code> provides the <code class="literal">removeObjectAtIndex:</code> property, <code class="literal">cancelCustomer:</code> simply calls that method. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>+1) cost, but this is acceptable as the method should not be called often during normal operations:</p><pre class="programlisting">    -(NSUInteger)positionOfCustomer:(EDSCustomer*)c 
    { 
        return [_custQueue indexOfObject:c]; 
    } 
</pre><p class="calibre7">In order to estimate a customer's current wait time with any sort of accuracy, it is necessary to know their position in the queue. The <code class="literal">positionOfCustomer:</code> property gives our class a position functionality by simply returning <code class="literal">indexOfObject:</code>. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>) cost:</p><pre class="programlisting">    -(NSUInteger)customersInLine 
    { 
        return [_custQueue count]; 
    } 
 
    -(BOOL)isLineEmpty 
    { 
        return [_custQueue count] == 0; 
    } 
 
    -(BOOL)isLineFull 
    { 
        return [_custQueue count] == _cap; 
    } 
</pre><p class="calibre7">The final three methods, <code class="literal">customersInLine()</code>, <code class="literal">isLineEmpty()</code>, and <code class="literal">isLineFull()</code>, introduce the <span class="strong"><em class="calibre20">count</em></span>, <span class="strong"><em class="calibre20">empty</em></span>, and <span class="strong"><em class="calibre20">full</em></span> functionality for our class. Each of these operations has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Swift</strong></span></p><p class="calibre7">As discussed earlier, Swift does not provide a concrete implementation of a queue data structure, but one can be mimicked easily using the <code class="literal">Array</code> class. Here's what a simple example of that implementation might look like:</p><pre class="programlisting">    var _custQueue: Array = [Customer]() 
    var _cap: Int; 
 
    public init(capacity: Int) 
    { 
        _cap = capacity; 
    } 
</pre><p class="calibre7">Our class declares two properties. The first is an <code class="literal">Array</code> of <code class="literal">Customer</code> named <code class="literal">_custQueue</code>, which represents our queue data structure and the core of this class. The second field is <code class="literal">_cap</code>. This field maintains our caller-defined maximum number of customers in the collection. Both of these are private, so only methods in our class can modify their values. Finally, the constructor initializes <code class="literal">_custQueue</code> and assigns <code class="literal">capacity</code> to <code class="literal">_cap</code>:</p><pre class="programlisting">    public func canCheckinCustomer() -&gt; Bool 
    { 
        return _custQueue.count &lt; _cap 
    } 
</pre><p class="calibre7">The <code class="literal">canCheckinCustomer()</code> method adds simple validation to <code class="literal">CustomerQueue</code> by confirming that <code class="literal">_custQueue.count</code> is less than the defined capacity and returning the result:</p><pre class="programlisting">    public func checkInCustomer(c: Customer) 
    { 
        if canCheckinCustomer() 
        { 
            _custQueue.append
        } 
    } 
</pre><p class="calibre7">The first of the two basic queue operations, <span class="strong"><em class="calibre20">enqueue</em></span>, is wrapped in the <code class="literal">checkInCustomer()</code> method. This method confirms that we can add a new <code class="literal">Customer</code> to the queue and then calls <code class="literal">append()</code> to add <code class="literal">c</code> to the <code class="literal">_custQueue</code> collection. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(1) cost:</p><pre class="programlisting">    public func customerConsultation() -&gt; Customer 
    { 
        return _custQueue.first! 
    } 
</pre><p class="calibre7">When a customer has reached the head of the queue, the <code class="literal">customerConsultation()</code> method calls <code class="literal">first!</code>. This returns the next <code class="literal">Customer</code> in <code class="literal">_custQueue</code>, but does not remove that object from the collection. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost:</p><pre class="programlisting">    public func checkoutCustomer() 
    { 
        _custQueue.removeFirst() 
    } 
</pre><p class="calibre7">Once an associate has completed a transaction with their current customer, the customer's place in the queue can be cleared. The <code class="literal">checkoutCustomer()</code> method calls <code class="literal">removeFirst</code>, which removes the <code class="literal">Customer</code> object from the front position of <code class="literal">_custQueue</code>. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost:</p><pre class="programlisting">    public func clearCustomers() 
    { 
        _custQueue.removeAll() 
    } 
</pre><p class="calibre7">The <code class="literal">clearCustomers()</code> method provides the <span class="strong"><em class="calibre20">clear</em></span> functionality, so our class can reset the collection to an empty state:</p><pre class="programlisting">    public func cancelCustomer(c: Customer) 
    { 
        if let index = _custQueue.index(of: c) 
        { 
            _custQueue.removeAtIndex(at: index) 
        } 
    } 
</pre><p class="calibre7">The <code class="literal">cancelCustomer(Customer)</code> method introduces the non-queue operation to remove <code class="literal">Customer</code> objects from the <code class="literal">_custQueue</code> collection. As <code class="literal">Array</code> does not provide a simple remove type method, we need to improvise once again. Our code first sets the conditional <code class="literal">var index</code> using <code class="literal">indexOf()</code>. If <code class="literal">index</code> has a value, the method passes <code class="literal">index</code> to <code class="literal">removeAtIndex()</code>. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>+1) cost.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note27" class="calibre1"/>Note</h3><p class="calibre7">In the Swift implementation, we are not calling the instance method <code class="literal">positionOfCustomer()</code>. This is because the <code class="literal">let ... =</code> notation is an initializer for a <span class="strong"><strong class="calibre16">conditional binding</strong></span>, and <code class="literal">positionOfCustomer()</code> returns <code class="literal">Int</code>, which is not an optional value. Since both <code class="literal">positionOfCustomer()</code> and this method use the same <code class="literal">indexOf()</code> method call, there is no difference in the operational cost.</p></div><p class="calibre7">The code for this is shown as follows:</p><pre class="programlisting">    public func positionOfCustomer(c: Customer) -&gt; Int 
    { 
        return _custQueue.index(of:c)! 
    } 
</pre><p class="calibre7">In order to estimate a customer's current wait time with any sort of accuracy, it is necessary to know their position in the queue. The <code class="literal">positionOfCustomer()</code> method gives our class position functionality by simply returning <code class="literal">indexOf()</code>. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>) cost:</p><pre class="programlisting">    public func customersInLine() -&gt; Int 
    { 
        return _custQueue.count 
    } 
 
    public func isLineEmpty() -&gt; Bool 
    { 
        return _custQueue.count == 0 
    } 
 
    public func isLineFull() -&gt; Bool 
    { 
        return _custQueue.count == _cap 
    } 
</pre><p class="calibre7">The final three methods, <code class="literal">customersInLine()</code>, <code class="literal">isLineEmpty()</code>, and <code class="literal">isLineFull()</code>, introduce the <span class="strong"><em class="calibre20">count</em></span>, <span class="strong"><em class="calibre20">empty</em></span>, and <span class="strong"><em class="calibre20">full</em></span> functionality for our class. Each of these operations has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost. Overall, the Swift queue implementation is very similar to its counterparts in C#, Java, and Objective-C even though the Swift language is considerably different from the others.</p></div>

<div class="book" title="Advanced topics" id="11C3M1-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec27" class="calibre1"/>Advanced topics</h1></div></div></div><p class="calibre7">Queue data structures can be built on several different underlying data structures. Each foundation provides different advantages, and the type that is chosen typically depends on the application's needs. The three most common implementations are array based, linked list based, and heap-based.</p><p class="calibre7">Queue data structures are also found in two additional variations, including the double-ended queue and the priority queue. Again, each variation offers advantages and disadvantages and the type that is chosen will largely depend on the needs of your application.</p></div>

<div class="book" title="Advanced topics" id="11C3M1-77f2b5b248f04368a6f723b0e9357ef3">
<div class="book" title="Array-based queues"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch05lvl2sec28" class="calibre1"/>Array-based queues</h2></div></div></div><p class="calibre7"><span class="strong"><strong class="calibre16">Array-based queues</strong></span> utilize a mutable array to represent the queue. Both of the examples in Objective-C and Swift take this form. In this implementation, the <code class="literal">[0]</code> position of the array represents the head or front of the queue. Although, generally speaking, queues are strictly FIFO collections and developers should not attempt to sort them, array-based queues are particularly difficult and costly to sort. If your application absolutely requires a sorted collection, you should consider using some other data structure entirely, such as a list.</p></div></div>

<div class="book" title="Advanced topics" id="11C3M1-77f2b5b248f04368a6f723b0e9357ef3">
<div class="book" title="Linked list-based queues"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch05lvl2sec29" class="calibre1"/>Linked list-based queues</h2></div></div></div><p class="calibre7">The <span class="strong"><strong class="calibre16">linked list-based queues</strong></span> utilize a pointer to the front of the queue, and subsequent pointers as each new object is appended onto the collection. Dequeing an object from the front of the line simply involves moving the head pointer from the object at node 0 to the object at node 1. If your collection of objects must be a sorted queue, prefer a link-based queue to an array-based one.</p></div></div>

<div class="book" title="Advanced topics" id="11C3M1-77f2b5b248f04368a6f723b0e9357ef3">
<div class="book" title="Heap-based queues"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_3"><a id="ch05lvl2sec30" class="calibre1"/>Heap-based queues</h2></div></div></div><p class="calibre7">A <span class="strong"><strong class="calibre16">heap-based queue</strong></span> is a queue created with a <span class="strong"><strong class="calibre16">heap</strong></span> collection as it's backer. Heaps are themselves specialized <span class="strong"><strong class="calibre16">tree-based data structures</strong></span> where the objects are naturally sorted in ascending (<span class="strong"><strong class="calibre16">min heap</strong></span>) or descending (<span class="strong"><strong class="calibre16">max heap</strong></span>) order based on some value or property native to the object.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note28" class="calibre1"/>Note</h3><p class="calibre7">Heaps should not be confused with the heap, or the pool of dynamically allocated memory, of a computer system. We will discuss the concept of heaps in greater detail in <a class="calibre1" title="Chapter 10. Heaps: Ordered Trees" href="part0058_split_000.html#1NA0K1-77f2b5b248f04368a6f723b0e9357ef3">Chapter 10</a>, <span class="strong"><em class="calibre20">Heaps: Ordered Trees</em></span>. Methods for sorting heap data structures will be discussed extensively in <a class="calibre1" title="Chapter 12. Sorting: Bringing Order Out Of Chaos" href="part0069_split_000.html#21PMQ2-77f2b5b248f04368a6f723b0e9357ef3">Chapter 12</a>, <span class="strong"><em class="calibre20">Sorting: Bringing Order Out Of Chaos</em></span>.</p></div></div></div>

<div class="book" title="Advanced topics" id="11C3M1-77f2b5b248f04368a6f723b0e9357ef3">
<div class="book" title="Double-ended queues"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_4"><a id="ch05lvl2sec31" class="calibre1"/>Double-ended queues</h2></div></div></div><p class="calibre7">A <span class="strong"><strong class="calibre16">double-ended queue</strong></span> is a collection where objects can be added to or removed from either the front or the back. The <code class="literal">ArrayQueue&lt;E&gt;</code> interface is Java's concrete implementation of the <code class="literal">Queue&lt;E&gt;</code> interface and is an example of a double-ended queue.</p></div></div>

<div class="book" title="Advanced topics" id="11C3M1-77f2b5b248f04368a6f723b0e9357ef3">
<div class="book" title="Priority queues"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_5"><a id="ch05lvl2sec32" class="calibre1"/>Priority queues</h2></div></div></div><p class="calibre7">A <span class="strong"><strong class="calibre16">priority queue</strong></span> sorts objects in the collection based on some value or <span class="strong"><strong class="calibre16">priority</strong></span>. Due to the natural hierarchical structure of a heap, priority queues are most often implemented as a heap-based queue. In this design, objects with a higher priority naturally sort closest to the front of the line so that, each time an object is dequeued, it is always the one with the highest priority. In the case where two or more objects share a priority, the object that has been in the queue longest will be dequeued first.</p></div></div>
<div class="book" title="Summary" id="12AK81-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec28" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, you learned the basic definition of the queue data structure, including how to initialize concrete implementations of the structure in each of the four languages we are discussing. Next, we discussed the most common operations associated with the queue data structure and their operational cost. We examined an example application using queues to track customers waiting in a <span class="strong"><em class="calibre20">first-come, first-served</em></span> line. These examples demonstrated how C# and Java provided concrete implementations of a queue, whereas Objective-C and Swift do not. Following this, we examined the three most common types of queue implementations, including array-based, linked-list based, and heap-based queues. Finally, we looked at double-ended and priority variations of the queue data structure.</p></div></body></html>