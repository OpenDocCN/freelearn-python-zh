["```py\n>>> cur = con.cursor()\n\n>>> cur.execute('''CREATE TABLE pens (id INTEGER PRIMARY KEY DESC, name, color)''')\n\n<sqlite3.Cursor object at 0x10c484c70>\n\n>>> con.commit()\n\n>>> cur.execute('''INSERT INTO pens VALUES (1, 'Waldorf', 'blue')''')\n\n<sqlite3.Cursor object at 0x10c484c70>\n\n>>> con.commit()\n\n>>> cur.execute('SELECT * FROM pens');\n\n<sqlite3.Cursor object at 0x10c484c70>\n\n>>> cur.fetchall()\n\n[(1, 'Waldorf', 'blue')] \n```", "```py\nfrom django.db import models\n\nclass Pens(models.Model):\n\n     name = models.CharField(max_length=140)\n\n     color = models.CharField(max_length=30) \n```", "```py\n>>> new_pen = Pens(name='Waldorf', color='blue')\n\n>>> new_pen.save()\n\n>>> all_pens = Pens.objects.all()\n\n>>> all_pens[0].name\n\n'Waldorf' \n```", "```py\n>>> red_pens = Pens.objects.filter(color='red') \n```", "```py\nSELECT * FROM Pens WHERE color = 'red; \n```", "```py\nfor book in Books.objects.find(publisher='packt'):\n\n    author = book.author\n\n    do_something(author) \n```", "```py\nProduce a query to retrieve all the books from publisher 'packt'\n\nFor each book, make a query to retrieve the author\n\nPerform the action with the author \n```", "```py\nProduce a query to retrieve all the books from publisher 'packt', joining with their authors\n\nFor each book, perform the action with the author \n```", "```py\nfor book in Books.objects.find(publisher='packt').select_related('author'):\n\n    author = book.author\n\n    do_something(author) \n```", "```py\n>>> color_list = ','.join(colors)\n\n>>> query = 'SELECT * FROM Pens WHERE color IN (' + color_list + ')' \n```", "```py\ndb.execute('SELECT * FROM Pens WHERE color={color}', color=color_input) \n```", "```py\n# Input list\n\n>>> color_list = ['red', 'green', 'blue']\n\n# Create a dictionary with a unique name per parameter (color_X) and the value\n\n>>> parameters = {f'color_{index}': value for index, value in enumerate(color_list)}\n\n>>> parameters\n\n{'color_0': 'red', 'color_1': 'green', 'color_2': 'blue'}\n\n# Create a clausule with the name of the parameters to be replaced\n\n# by string substitution\n\n# Note that {{ will be replaced by a single {\n\n>>> query_params = ','.join(f'{{{param}}}' for param in  parameters.keys())\n\n>>> query_params\n\n'{color_0},{color_1},{color_2}'\n\n# Compose the full query, replacing the prepared string\n\n>>> query = f'SELECT * FROM Pens WHERE color IN ({query_params})'\n\n>>> query\n\n'SELECT * FROM Pens WHERE color IN ({color_0},{color_1},{color_2})'\n\n# To execute, using ** on front of a dictionary will put all its keys as \n\n# input parameters\n\n>>> query.format(**parameters)\n\n'SELECT * FROM Pens WHERE color IN (red,green,blue)'\n\n# Execute the query in a similar way, it will handle all \n\n# required encoding and escaping from the string input\n\n   >>> db.execute(query, **query_params) \n```", "```py\n>>> cur.execute('SELECT * FROM pens');\n\n<sqlite3.Cursor object at 0x10e640810>\n\n# This returns a row\n\n>>> cur.fetchone()\n\n(1, 'Waldorf', 'blue')\n\n>>> cur.execute('ALTER TABLE pens ADD brand')\n\n<sqlite3.Cursor object at 0x10e640810>\n\n>>> cur.execute('SELECT * FROM pens');\n\n<sqlite3.Cursor object at 0x10e640810>\n\n# This is the same row as above, but now it returns an extra element\n\n>>> cur.fetchone()\n\n(1, 'Waldorf', 'blue', None) \n```", "```py\n>>> cur.execute('SELECT name, color FROM pens');\n\n<sqlite3.Cursor object at 0x10e640810>\n\n>>> cur.fetchone()\n\n('Waldorf', 'blue') \n```", "```py\nclass InternalAccount(models.Model):\n\n    ''' This is the model related to a DB table '''\n\n    account_number = models.IntegerField(unique=True)\n\n    initial_amount = models.IntegerField(default=0)\n\n     amount = models.IntegerField(default=0)\n\nclass Log(models.Model):\n\n    ''' This models stores the operations '''\n\n    source = models.ForeignKey('InternalAccount', \n\n                               related_name='debit')\n\n    destination = models.ForeignKey('InternalAccount',  \n\n                                    related_name='credit')\n\n    amount = models.IntegerField()\n\n    timestamp = models.DateTimeField(auto_now=True)\n\n    def commit():\n\n        ''' this produces the operation '''\n\n        with transaction.atomic():\n\n            # Update the amounts\n\n               self.source.amount -= self.amount\n\n        self.destination.amount += self.amount\n\n            # save everything\n\n            self.source.save()\n\n            self.destination.save()\n\n            self.save()\n\nclass Account(object):\n\n    ''' This is the exposed object that handled the operations '''\n\n    def __init__(self, account_number, amount=0):\n\n        # Retrieve or create the account\n\n        self.internal, _ = InternalAccount.objects.get_or_create(\n\n            account_number=account_number,\n\n            initial_amount=amount,\n\n            amount=amount)\n\n       @property\n\n       def amount(self):\n\n           return self.internal.amount\n\n    def lodge(source_account, amount):\n\n        '''\n\n        This operation adds funds from the source\n\n        '''\n\n        log = Log(source=source_account, destination=self,\n\n                   amount=amount)\n\n        log.commit()\n\n    def withdraw(dest_account, amount):\n\n        '''\n\n        This operation transfer funds to the destination\n\n        '''\n\n        log = Log(source=self, destination=dest_account,\n\n                   amount=amount)\n\n        log.commit() \n```", "```py\n def commit():\n\n        ''' this produces the operation '''\n\n        with transaction.atomic():\n\n            # Update the amounts\n\n               self.source.amount -= self.amount\n\n               self.destination.amount += self.amount\n\n            # save everything\n\n            self.source.save()\n\n            self.destination.save()\n\n            self.save() \n```", "```py\nclass InternalAccount(models.Model):\n\n    ...\n\n    def recalculate(self):\n\n        '''\n\n        Recalculate the amount, based on the logs\n\n        '''\n\n        total_credit = sum(log.amount for log in self.credit.all())\n\n        total_debit = sum(log.amount for log in self.debit.all())\n\n        return self.initial_amount + total_credit - total_debit \n```", "```py\nClass SaleModel(models.Model):\n\n    ''' This is the usual ORM model '''\n\n    Sale_id = models.IntegerField(unique=True)\n\n    sku = models.IntegerField()\n\n    amount = models.IntegerField()\n\n    price = models.IntegerField()\n\nclass Sale(object):\n\n    ''' \n\n        This is the exposed Domain Model that handled the operations \n\n        In a domain meaningful way, without exposing internal info\n\n    '''\n\n    def __init__(self, sale_id, sku, amount):\n\n        self.sale_id = sale_id\n\n        self.sku = sku\n\n        self.amount = amount\n\n        # These elements are won't be filled when creating a new element\n\n        self._price = None\n\n        self._profit = None\n\n    @property\n\n    def price(self):\n\n        if self._price is None:\n\n            raise Exception('No price yet for this sale')\n\n        return self._price\n\n    @property\n\n    def profit(self):\n\n        if self._profit is None:\n\n            raise Exception('No price yet for this sale')\n\n        return self._profit\n\n       def save(self):\n\n            # This sends the sale to the queue\n\n            event = {\n\n                'sale_id': self.sale_id,\n\n                'sku': self.sku,\n\n                'amount': self.amount,\n\n            }\n\n            # This sends the event to the external queue\n\n            Queue.send(event)\n\n       @classmethod\n\n       def get(cls, sale_id):\n\n           # if the sale is still not available it will raise an\n\n           # Exception\n\n           sale = SaleModel.objects.get(sale_id=sale_id)\n\n           full_sale = Sale(sale_id=sale_id, sku=sale.sku,\n\n                            amount=sale.amount)\n\n           # fill the private attributes\n\n           full_sale._price = sale.price\n\n           full_sale._profit = sale.amount - full_sale._price\n\n           return full_sale \n```", "```py\n # Create a new sale\n\n      sale = Sale(sale_id=sale_id, sku=sale.sku, amount=sale.amount)\n\n      sale.save()\n\n      # Wait some time until totally processed\n\n      full_sale = Sale.get(sale_id=sale_id)\n\n      # retrieve the profit\n\n      full_sale.profit \n```", "```py\nclass InternalAccount(models.Model):\n\n    ''' This is the model related to a DB table '''\n\n    account_number = models.IntegerField(unique=True)\n\n    initial_amount = models.IntegerField(default=0)\n\n    amount = models.IntegerField(default=0)\n\n    branch_id = models.IntegerField() \n```", "```py\n$ python3 manage.py makemigrations\n\nMigrations for 'example':\n\n  example/migrations/0002_auto_20210501_1843.py\n\n    - Add field branch_id to internalaccount \n```", "```py\n$ python3 manage.py migrate\n\nOperations to perform:\n\n  Apply all migrations: admin, auth, contenttypes, example, sessions\n\nRunning migrations:\n\n  Applying example.0002_auto_20210501_1843... OK \n```", "```py\n>>> from sqlalchemy.ext.automap import automap_base\n\n>>> from sqlalchemy.sql import select\n\n>>> from sqlalchemy import create_engine\n\n# Read the database and detect it\n\n>>> engine = create_engine(\"sqlite:///database.db\")\n\n>>> Base = automap_base()\n\n>>> Base.prepare(engine, reflect=True)\n\n# The Pens class maps the table called \"pens\" in the DB\n\n>>> Pens = Base.classes.pens\n\n# Create a session to query \n\n>>> session = Session(engine)\n\n# Create a select query\n\n>>> query = select(Pens).where(Pens.color=='blue')\n\n# Execute the query\n\n>>> result = session.execute(query)\n\n>>> for row, in result:\n\n...     print(row.id, row.name, row.color)\n\n...\n\n1 Waldorf blue \n```", "```py\n$ python3 manage.py inspectdb > models.py \n```"]