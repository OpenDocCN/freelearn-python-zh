- en: Chapter 30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One-Dimensional Lists and Dictionaries
  prefs: []
  type: TYPE_NORMAL
- en: 30.1 Introduction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Variables are a good way to store values in memory but they have one limitation—they
    can hold only one value at a time. There are many cases, however, where a program
    needs to keep a large amount of data in memory, and variables are not the best
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter three numbers. It then displays
    them sorted in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following code fragment. It lets the user enter the three numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(3):'
  prefs: []
  type: TYPE_NORMAL
- en: number = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: When the loop finally finishes iterating, the variable number contains only
    that last number that was provided. Unfortunately, all the previous two numbers
    have been lost! Using this code fragment, it is not quite possible to display
    them sorted in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: One possible solution would be to use three individual variables, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: num1 = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: num2 = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: num3 = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'if num1 <= num2 <= num3:'
  prefs: []
  type: TYPE_NORMAL
- en: print(num1, num2, num3)
  prefs: []
  type: TYPE_NORMAL
- en: 'elif num1 <= num3 <= num2:'
  prefs: []
  type: TYPE_NORMAL
- en: print(num1, num3, num2)
  prefs: []
  type: TYPE_NORMAL
- en: 'elif num2 <= num1 <= num3:'
  prefs: []
  type: TYPE_NORMAL
- en: print(num2, num1, num3)
  prefs: []
  type: TYPE_NORMAL
- en: 'elif num2 <= num3 <= num1:'
  prefs: []
  type: TYPE_NORMAL
- en: print(num2, num3, num1)
  prefs: []
  type: TYPE_NORMAL
- en: 'elif num3 <= num1 <= num2:'
  prefs: []
  type: TYPE_NORMAL
- en: print(num3, num1, num2)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print(num3, num2, num1)
  prefs: []
  type: TYPE_NORMAL
- en: Not a perfect solution, but it works! However, what if the wording of this exercise
    asked the user to enter 1,000 numbers instead of three? Think about it! Can you
    write a similar Python program for all those numbers? Of course not! Fortunately,
    there are data structures!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)In computer science, a data structure is a collection of
    data organized so that you can perform operations on it in the most effective
    way.'
  prefs: []
  type: TYPE_NORMAL
- en: There are several data structures available in Python, such as lists, tuples,
    dictionaries, sets, frozensets, and strings. Yes, you heard that right! Since
    a string is a collection of alphanumeric characters, it is considered a data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond strings (for which you have already learned enough), lists and dictionaries
    are the most commonly used data structures in Python. The following chapters will
    analyze both of them.
  prefs: []
  type: TYPE_NORMAL
- en: 30.2 What is a List?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A list is a type of data structure that can hold multiple values under one common
    name. It can be thought of as a collection of elements where each element is assigned
    a unique number known as an index position, or simply an index. Lists are mutable
    (changeable), which means that once a list is created, the values of its elements
    can be changed, and new elements can be added to or removed from the list.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Lists in computer science resemble the matrices used in
    mathematics. A mathematical matrix is a collection of numbers or other mathematical
    objects, arranged in rows and columns.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)In many computer languages, such as Java, C++, and C# (to
    name a few), there are no lists. These languages support another kind of data
    structure that is called an “array”. Lists, however, are more powerful than arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)There are one-dimensional and multidimensional lists. A
    multidimensional list can be two-dimensional, three-dimensional, four-dimensional,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: One-Dimensional Lists
  prefs: []
  type: TYPE_NORMAL
- en: The following example presents a one-dimensional list that holds the grades
    of six students. The name of the list is grades. For your convenience, the corresponding
    index is written above each element. By default, in Python, index numbering always
    starts at zero.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter30-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/remember.jpg)Since index numbering starts at zero, the index of the
    last element of a list is 1 less than the total number of elements in the list.
    In the list grades, the index of the last element is 5 while the total number
    of elements is 6.'
  prefs: []
  type: TYPE_NORMAL
- en: You can think of a list as if it were six individual variables—grades0, grades1,
    grades2, ... grades5—with each variable holding the grade of one student. The
    advantage of the list, however, is that it can hold multiple values under one
    common name.
  prefs: []
  type: TYPE_NORMAL
- en: Two-Dimensional Lists
  prefs: []
  type: TYPE_NORMAL
- en: In general, multidimensional lists are useful for working with multiple sets
    of data. For example, suppose you want to hold the daily high temperatures for
    California for the four weeks of April. One approach would be to use four one-dimensional
    lists, one for each week. Furthermore, each list would have seven elements, one
    for each day of the week, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter30-02.png)'
  prefs: []
  type: TYPE_IMG
- en: However, this approach is a bit awkward because you would have to process each
    list separately. A better approach would be to use a two-dimensional list with
    four rows (one for each week) and seven columns (one for each day of the week),
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter30-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Three-Dimensional Lists
  prefs: []
  type: TYPE_NORMAL
- en: The next example shows a three-dimensional list that holds the daily high temperatures
    for California for the four weeks of April for the years 2013 and 2014.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter30-04.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/notice.jpg)Note that four-dimensional, five-dimensional, or even one-hundred–dimensional
    lists can exist. However, experience shows that the maximum list dimension that
    you will need in your life as a programmer is probably two or three.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 30.2-1 Designing a List
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Design a list that can hold the ages of 8 people, and then add some typical
    values to the list.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: This is an easy one. All you have to do is design a list with 8 elements (indexes
    0 to 7). It can be a list with either one row or one column, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter30-05.png)'
  prefs: []
  type: TYPE_IMG
- en: Keep in mind, however, that there are no lists with one row or one column in
    Python. These concepts may exist in mathematical matrices (or in your imagination!)
    but not in Python. The lists in Python are one-dimensional—end of story! If you
    want to visualize them having one row or one column, that is up to you.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 30.2-2 Designing Lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Design the necessary lists to hold the names and the ages of seven people, and
    then add some typical values to the lists.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: This exercise can be implemented with two lists. Let's design them with one
    column each.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter30-06.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there is a one-to-one correspondence between the elements in
    the list names and those in the list ages. The first of the seven people is John
    Thompson, and he is 17 year old. The name “John Thompson” is stored at index 0
    of the list names, and at exactly the same index in the list ages, his age is
    stored. The next person's name (Ava Miller) and her age (25) are stored at index
    1 of the lists names, and ages, respectively, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 30.2-3 Designing Lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Design the necessary lists to hold the names of ten people as well as the average
    weight (in pounds) of each person for January, February, and March. Then add some
    typical values to the lists.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you need a one-dimensional list for names, and a two-dimensional
    list for people's weights, having a one-to-one correspondence between their elements.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter30-07.png)'
  prefs: []
  type: TYPE_IMG
- en: 30.3 Creating One-Dimensional Lists in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python has many ways to create a list and add elements (and values) to it. Depending
    on the given problem, it's up to you which one to use.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to create the following list using the most common approaches.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter30-08.png)'
  prefs: []
  type: TYPE_IMG
- en: First approach
  prefs: []
  type: TYPE_NORMAL
- en: To create a list and directly assign values to its elements, you can use the
    next Python statement, given in general form.
  prefs: []
  type: TYPE_NORMAL
- en: list_name = [ value0, value1, value2, …, valueM ]
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: ►list_name is the name of the list.
  prefs: []
  type: TYPE_NORMAL
- en: ►value0, value1, value2, … , valueM are the values of the list elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this approach, you can create the list ages using the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: ages = [12, 25, 9, 11]
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Indexes are set automatically. The value 12 is assigned
    to the element at index position 0, value 25 is assigned to the element at index
    position 1, and so on. Index numbering always starts at zero by default.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)In [Section 5.4](chapter05.html#toc_4) you learned about
    the rules that must be followed when assigning names to variables. Assigning names
    to lists follows exactly the same rules!'
  prefs: []
  type: TYPE_NORMAL
- en: Second approach
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a list of size empty elements in Python using the following
    statement given in general form:'
  prefs: []
  type: TYPE_NORMAL
- en: list_name = [None] * size
  prefs: []
  type: TYPE_NORMAL
- en: where size can be any positive integer value, or it can even be a variable that
    contains any positive integer value.
  prefs: []
  type: TYPE_NORMAL
- en: The next statement creates the list ages with 4 empty elements.
  prefs: []
  type: TYPE_NORMAL
- en: ages = [None] * 4
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The statement ages = [None] * 4 reserves four locations
    in main memory (RAM).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To assign a value to a list element, you can use the following statement, given
    in general form:'
  prefs: []
  type: TYPE_NORMAL
- en: list_name[index] = value
  prefs: []
  type: TYPE_NORMAL
- en: where index is the index position of the element in the list.
  prefs: []
  type: TYPE_NORMAL
- en: The next code fragment creates the list ages (reserving four locations in main
    memory) and then assigns values to its elements.
  prefs: []
  type: TYPE_NORMAL
- en: ages = [None] * 4
  prefs: []
  type: TYPE_NORMAL
- en: ages[0] = 12
  prefs: []
  type: TYPE_NORMAL
- en: ages[1] = 25
  prefs: []
  type: TYPE_NORMAL
- en: ages[2] = 9
  prefs: []
  type: TYPE_NORMAL
- en: ages[3] = 11
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The size of the list ages is 4.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, instead of using constant values for index, you can also use variables
    or expressions, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: ages = [None] * 4
  prefs: []
  type: TYPE_NORMAL
- en: k = 0
  prefs: []
  type: TYPE_NORMAL
- en: ages[k] = 12
  prefs: []
  type: TYPE_NORMAL
- en: ages[k + 1] = 25
  prefs: []
  type: TYPE_NORMAL
- en: ages[k + 2] = 9
  prefs: []
  type: TYPE_NORMAL
- en: ages[k + 3] = 11
  prefs: []
  type: TYPE_NORMAL
- en: Third approach
  prefs: []
  type: TYPE_NORMAL
- en: In this approach, you can create a totally empty list (without elements) and
    then add elements (and values) to it using the append() method, as shown in the
    following Python statements, given in general form.
  prefs: []
  type: TYPE_NORMAL
- en: list_name = []
  prefs: []
  type: TYPE_NORMAL
- en: list_name.append(value0)
  prefs: []
  type: TYPE_NORMAL
- en: list_name.append(value1)
  prefs: []
  type: TYPE_NORMAL
- en: list_name.append(value2)
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: list_name.append(valueM)
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this approach, you can create the list ages using the following code
    fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: ages = []
  prefs: []
  type: TYPE_NORMAL
- en: ages.append(12)
  prefs: []
  type: TYPE_NORMAL
- en: ages.append(25)
  prefs: []
  type: TYPE_NORMAL
- en: ages.append(9)
  prefs: []
  type: TYPE_NORMAL
- en: ages.append(11)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that in this approach as well, index numbering starts
    at zero by default, meaning that the value 12 is stored at index position 0, the
    value 25 at index position 1 and so forth.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The statement ages = [] does not reserve any locations in
    main memory (RAM). It just states that the list ages is ready to accept new elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 30.4 How to Get Values from a One-Dimensional List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Getting values from a list is just a matter of pointing to a specific element.
    Each element of a one-dimensional list can be uniquely identified using an index.
    The following code fragment creates a list and displays “A+” (without the double
    quotes) on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: grades = ["B+", "A+", "A", "C-"]
  prefs: []
  type: TYPE_NORMAL
- en: print(grades[1])
  prefs: []
  type: TYPE_NORMAL
- en: Of course, instead of using constant values for index, you can also use variables
    or expressions. The following example creates a list and displays “Aphrodite and
    Hera” (without the double quotes) on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: gods = ["Zeus", "Ares", "Hera", "Aphrodite", "Hermes"]
  prefs: []
  type: TYPE_NORMAL
- en: k = 2
  prefs: []
  type: TYPE_NORMAL
- en: print(gods[k + 1], "and", gods[k])
  prefs: []
  type: TYPE_NORMAL
- en: A negative index accesses an element by starting to count from the end of the
    list. In the following list grades, the index position of each element (using
    negative indexes) is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter30-09.png)'
  prefs: []
  type: TYPE_IMG
- en: The following example
  prefs: []
  type: TYPE_NORMAL
- en: grades = ["B+", "A+", "A", "C-"]
  prefs: []
  type: TYPE_NORMAL
- en: print(grades[-1] , "and", grades[-3])
  prefs: []
  type: TYPE_NORMAL
- en: displays “C− and A+” (without the double quotes) on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to display all the elements of a list, you can do the following
  prefs: []
  type: TYPE_NORMAL
- en: grades = ["B+", "A+", "A", "C-"]
  prefs: []
  type: TYPE_NORMAL
- en: 'print(grades)        #It displays: [''B+'', ''A+'', ''A'', ''C-'']'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)In Python, you can define a string using either single
    or double quotes.'
  prefs: []
  type: TYPE_NORMAL
- en: Just like in strings, you can get a subset of a list, called a “slice”, as shown
    here.
  prefs: []
  type: TYPE_NORMAL
- en: grades = ["B+", "A+", "A", "C-"]
  prefs: []
  type: TYPE_NORMAL
- en: 'print(grades[1:3])        #It displays: ["A+", "A"]'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Slicing in Python is a mechanism to select a range of elements
    from a list (or from a sequence, in general).'
  prefs: []
  type: TYPE_NORMAL
- en: The slicing mechanism can also have a third argument, called step, as shown
    here.
  prefs: []
  type: TYPE_NORMAL
- en: grades = ["B+", "A+", "A", "C-", "A-", "B-", "C", "B", "C+"]
  prefs: []
  type: TYPE_NORMAL
- en: 'print(grades[1:7:2])        #It displays: [''A+'', ''C-'', ''B-'']'
  prefs: []
  type: TYPE_NORMAL
- en: A negative step returns a subset of a list in reverse order
  prefs: []
  type: TYPE_NORMAL
- en: gods = ["Ares", "Hera", "Aphrodite", "Hermes"]
  prefs: []
  type: TYPE_NORMAL
- en: 'print(gods[2:0:-1])   #It displays: [''Aphrodite'', ''Hera'']'
  prefs: []
  type: TYPE_NORMAL
- en: 'print(gods[::-1])     #It displays: [''Hermes'', ''Aphrodite'', ''Hera'', ''Ares'']'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)The slicing mechanism uses the notation'
  prefs: []
  type: TYPE_NORMAL
- en: 'list[[beginIndex] : [endIndex] [: step]]'
  prefs: []
  type: TYPE_NORMAL
- en: and returns a portion of list. Specifically, it returns the sublist starting
    from position beginIndex and running up to, but not including, position endIndex
    or up to the end of list, whichever comes first. Both arguments beginIndex and
    endIndex are optional. If beginIndex is omitted, the sublist starting from position
    0 and running up to, but not including, position endIndex is returned. If endIndex
    is omitted, the sublist starting from position beginIndex until the end of list
    is returned. The last argument step is optional as well. If omitted, its default
    value is 1\. If supplied, it defines the number of elements you want to move forward
    after each element is retrieved from the original list.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 30.4-1 Creating the Trace Table
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Create the trace table for the next code fragment.
  prefs: []
  type: TYPE_NORMAL
- en: a = [None] * 4
  prefs: []
  type: TYPE_NORMAL
- en: a[3] = 9
  prefs: []
  type: TYPE_NORMAL
- en: x = 0
  prefs: []
  type: TYPE_NORMAL
- en: a[x] = a[3] + 4
  prefs: []
  type: TYPE_NORMAL
- en: a[x + 1] = a[x] * 3
  prefs: []
  type: TYPE_NORMAL
- en: x += 1
  prefs: []
  type: TYPE_NORMAL
- en: a[x + 2] = a[x - 1]
  prefs: []
  type: TYPE_NORMAL
- en: a[2] = a[1] + 5
  prefs: []
  type: TYPE_NORMAL
- en: a[3] = a[3] + 1
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget that you can manipulate each element of a list as if it were a
    variable. Thus, when you create a trace table for a Python program that uses lists,
    you can have one column for each element as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '| Step | Statement | Notes | x | a[0] | a[1] | a[2] | a[3] |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | a = [None] * 4 | This creates list a with no values in it | ? | ? | ?
    | ? | ? |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | a[3] = 9 |   | ? | ? | ? | ? | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | x = 0 |   | 0 | ? | ? | ? | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | a[x] = a[3] + 4 |   | 0 | 13 | ? | ? | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | a[x + 1] = a[x] * 3 |   | 0 | 13 | 39 | ? | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | x += 1 |   | 1 | 13 | 39 | ? | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | a[x + 2] = a[x − 1] |   | 1 | 13 | 39 | ? | 13 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | a[2] = a[1] + 5 |   | 1 | 13 | 39 | 44 | 13 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | a[3] = a[3] + 1 |   | 1 | 13 | 39 | 44 | 14 |'
  prefs: []
  type: TYPE_TB
- en: Exercise 30.4-2 Using a Non-Existing Index
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Which properties of an algorithm are not satisfied by the following Python program?
  prefs: []
  type: TYPE_NORMAL
- en: grades = ["B+", "A+", "A", "C-"]
  prefs: []
  type: TYPE_NORMAL
- en: print(grades[100])
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: 'Two properties are not satisfied by this Python program. The first one is obvious:
    there is no data input. The second one is the property of definiteness. You must
    never reference a non-existing element of a list. In this exercise, since there
    is no element at index position 100, the last statement throws a runtime error.'
  prefs: []
  type: TYPE_NORMAL
- en: 30.5 How to Alter the Value of a List Element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To alter the value of an existing list element is a piece of cake. All you need
    to do is use the appropriate index and assign a new value to that element. The
    example that follows shows exactly this.
  prefs: []
  type: TYPE_NORMAL
- en: '#Create a list'
  prefs: []
  type: TYPE_NORMAL
- en: tribes = ["Navajo", "Cherokee", "Sioux"]
  prefs: []
  type: TYPE_NORMAL
- en: 'print(tribes)    #It displays: [''Navajo'', ''Cherokee'', ''Sioux'']'
  prefs: []
  type: TYPE_NORMAL
- en: '#Alter the value of an existing element'
  prefs: []
  type: TYPE_NORMAL
- en: tribes[1] = "Apache"
  prefs: []
  type: TYPE_NORMAL
- en: 'print(tribes)    #It displays: [''Navajo'', ''Apache'', ''Sioux'']'
  prefs: []
  type: TYPE_NORMAL
- en: 30.6 How to Iterate Through a One-Dimensional List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now comes the interesting part. A program can iterate through the elements of
    a list using a loop control structure (usually a for-loop). There are two approaches
    you can use to iterate through a one-dimensional list.
  prefs: []
  type: TYPE_NORMAL
- en: First approach
  prefs: []
  type: TYPE_NORMAL
- en: This approach refers to each list element using its index. Following is a code
    fragment, written in general form
  prefs: []
  type: TYPE_NORMAL
- en: 'for index in range(size):'
  prefs: []
  type: TYPE_NORMAL
- en: process structure_name[index]
  prefs: []
  type: TYPE_NORMAL
- en: in which, process is any Python statement or block of statements that processes
    one element of the list structure_name at each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: The following Python program displays all elements of the list gods, one at
    each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: gods = ["Zeus", "Ares", "Hera", "Aphrodite", "Hermes"]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(5):'
  prefs: []
  type: TYPE_NORMAL
- en: print(gods[i])
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The name of the variable i is not binding. You can use any
    variable name you want, such as index, ind, j, and many more.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that since the list gods contains five elements, the
    for-loop must iterate from 0 to 4 and not from 1 to 5\. This is because the indexes
    of the four elements are 0, 1, 2, 3, and 4, correspondingly.'
  prefs: []
  type: TYPE_NORMAL
- en: Since lists are mutable, you can use a loop control structure to alter all or
    some of its values. The following code fragment doubles the values of some elements
    of the list b.
  prefs: []
  type: TYPE_NORMAL
- en: b = [80, 65, 60, 72, 30, 40]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(3):'
  prefs: []
  type: TYPE_NORMAL
- en: b[i] = b[i] * 2
  prefs: []
  type: TYPE_NORMAL
- en: Second approach
  prefs: []
  type: TYPE_NORMAL
- en: This approach is very simple but not as flexible as the previous one. There
    are cases where it cannot be used, as you will see below. Following is a code
    fragment, written in general form
  prefs: []
  type: TYPE_NORMAL
- en: 'for element in structure_name:'
  prefs: []
  type: TYPE_NORMAL
- en: process element
  prefs: []
  type: TYPE_NORMAL
- en: in which process is any Python statement or block of statements that processes
    one element of the list structure_name at each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: The following Python program, displays all elements of the list grades, one
    at each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: grades = ["B+", "A+", "A", "C-"]
  prefs: []
  type: TYPE_NORMAL
- en: 'for grade in grades:'
  prefs: []
  type: TYPE_NORMAL
- en: print(grade)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)In the first iteration, the value of the first element is
    assigned to variable grade. In the second iteration, the value of the second element
    is assigned to variable grade and so on!'
  prefs: []
  type: TYPE_NORMAL
- en: The following Python program displays all elements of the list gods, one at
    each iteration, in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: gods = ["Hera", "Zeus", "Ares", "Aphrodite", "Hermes"]
  prefs: []
  type: TYPE_NORMAL
- en: 'for god in gods[::-1]:'
  prefs: []
  type: TYPE_NORMAL
- en: print(god)
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind, though, that this approach cannot be used to alter the values
    of the elements in a list. For example, if you want to double the values of all
    elements in the list numbers, you cannot do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: numbers = [5, 10, 3, 2]
  prefs: []
  type: TYPE_NORMAL
- en: 'for number in numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: number = number * 2
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)number is a simple variable where, at each iteration, each
    successive value of the list numbers is assigned to. However, the opposite never
    happens! The value of number is never assigned back to any element!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)If you want to alter the values of the elements in a list,
    you should use the first approach.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 30.6-1 Finding the Sum
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that creates a list with the following values
  prefs: []
  type: TYPE_NORMAL
- en: 56, 12, 33, 8, 3, 2, 98
  prefs: []
  type: TYPE_NORMAL
- en: and then calculates and displays their sum.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: You learned two approaches to iterate through the list elements. Let's use both
    approaches and see the differences. You will find an extra third approach below,
    which is the Pythonic way to calculate the sum of the elements of a one-dimensional
    list.
  prefs: []
  type: TYPE_NORMAL
- en: First approach
  prefs: []
  type: TYPE_NORMAL
- en: The solution is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_30.6-1a'
  prefs: []
  type: TYPE_NORMAL
- en: values = [56, 12, 33, 8, 3, 2, 98]
  prefs: []
  type: TYPE_NORMAL
- en: total = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(7):'
  prefs: []
  type: TYPE_NORMAL
- en: total += values[i]  #This is equivalent to total = total + values[i]
  prefs: []
  type: TYPE_NORMAL
- en: print(total)
  prefs: []
  type: TYPE_NORMAL
- en: Second approach
  prefs: []
  type: TYPE_NORMAL
- en: The solution is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_30.6-1b'
  prefs: []
  type: TYPE_NORMAL
- en: values = [56, 12, 33, 8, 3, 2, 98]
  prefs: []
  type: TYPE_NORMAL
- en: total = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for value in values:'
  prefs: []
  type: TYPE_NORMAL
- en: total += value
  prefs: []
  type: TYPE_NORMAL
- en: print(total)
  prefs: []
  type: TYPE_NORMAL
- en: Third approach
  prefs: []
  type: TYPE_NORMAL
- en: This approach uses no loop structures. It just uses the fsum() function of the
    math module.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_30.6-1c'
  prefs: []
  type: TYPE_NORMAL
- en: from math import fsum
  prefs: []
  type: TYPE_NORMAL
- en: values = [56, 12, 33, 8, 3, 2, 98]
  prefs: []
  type: TYPE_NORMAL
- en: total = fsum(values)
  prefs: []
  type: TYPE_NORMAL
- en: print(total)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)If you don''t remember anything about the fsum() function,
    refresh your memory by re-reading [Section 11.2](chapter11.html#toc_2).'
  prefs: []
  type: TYPE_NORMAL
- en: 30.7 How to Add User-Entered Values to a One-Dimensional List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is nothing new here. Instead of reading a value from the keyboard and
    assigning that value to a variable, you can directly assign that value to a specific
    list element. The next code fragment prompts the user to enter the names of four
    people, and assigns them to the elements at index positions 0, 1, 2, and 3, of
    the list names.
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * 4    #Pre-reserve 4 locations in main memory (RAM)
  prefs: []
  type: TYPE_NORMAL
- en: 'names[0] = input("Enter name No 1: ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'names[1] = input("Enter name No 2: ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'names[2] = input("Enter name No 3: ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'names[3] = input("Enter name No 4: ")'
  prefs: []
  type: TYPE_NORMAL
- en: Using a for-loop, this code fragment can equivalently be written as
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 4
  prefs: []
  type: TYPE_NORMAL
- en: 'names = [None] * ELEMENTS   #Pre-reserve 4 locations in main memory (RAM)'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'names[i] = input("Enter name No " + str(i + 1)  + ": ")'
  prefs: []
  type: TYPE_NORMAL
- en: You can, of course, do the same, using the append() method instead, as shown
    in the code fragment that follows.
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 4
  prefs: []
  type: TYPE_NORMAL
- en: names = []    #Create a totally empty list
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'name = input("Enter name No " + str(i + 1)  + ": ")'
  prefs: []
  type: TYPE_NORMAL
- en: names.append(name)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)When the append() method is used, elements are appended
    to a list (added at the end of the list).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)A very good tactic for dealing with list sizes is to use
    constants. However, unlike some other programming languages (such as C# or C++),
    Python does not inherently support constants. Instead, you can use a variable
    to achieve similar results. It is advisable, though, to use only uppercase letters.
    This helps you to visually distinguish those variables that are used as constants
    from regular variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 30.7-1 Displaying Words in Reverse Order
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter 20 words. The program must then
    display them in the exact reverse of the order in which they were provided.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: Lists are perfect for problems like this one. The following is an appropriate
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_30.7-1a'
  prefs: []
  type: TYPE_NORMAL
- en: 'words = [None] * 20   #Pre-reserve 20 locations in main memory (RAM)'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(20):'
  prefs: []
  type: TYPE_NORMAL
- en: words[i] = input()
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(19, -1, -1):'
  prefs: []
  type: TYPE_NORMAL
- en: print(words[i])
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)Since index numbering starts at zero, the index of the
    last list element is 1 less than the total number of elements in the list.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that in Python you can iterate in reverse order through the list
    elements using the slicing mechanism and a value of −1 for step. The following
    program creates a totally empty list and then uses the append() method to add
    elements to the list. Finally, the slicing mechanism is used to display them in
    the exact reverse of the order in which they were provided.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_30.7-1b'
  prefs: []
  type: TYPE_NORMAL
- en: 'words = []   #Create a totally empty list'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(20):'
  prefs: []
  type: TYPE_NORMAL
- en: words.append(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'for word in words[::-1]:'
  prefs: []
  type: TYPE_NORMAL
- en: print(word)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Sometimes the wording of an exercise may say nothing about
    using a data structure. However, this doesn''t mean that you can''t use one. Use
    data structures (lists, tuples, dictionaries etc.) whenever you find them necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)A “tuple” is almost identical to a list. The main difference
    is that tuples are immutable (unchangeable).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)An “immutable” data structure is a structure in which the
    value of its elements cannot be changed once the data structure is created. Obviously,
    you cannot add new elements to an immutable data structure or remove existing
    elements from it.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 30.7-2 Displaying Positive Numbers in Reverse Order
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter 100 numbers into a list. It
    then displays only the positive ones in the exact reverse of the order in which
    they were provided.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, the program must accept all values from the user and store
    them into a list. However, within the for-loop that is responsible for displaying
    the list elements, a nested decision control structure must check for and display
    only the positive values. The solution is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_30.7-2'
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 100
  prefs: []
  type: TYPE_NORMAL
- en: values = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: values[i] = float(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'for value in values[::-1]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if value > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print(value)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)Unlike some other programming languages (such as C# or
    C++), Python does not inherently support constants. Instead, you can use a variable
    to achieve similar results. It is advisable, though, to use only uppercase letters.
    This helps you to visually distinguish those variables that are used as constants
    from regular variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 30.7-3 Finding the Average Value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter 20 numbers into a list.
    It then displays a message only when their average value is less than 10.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: To find the average value of the user-provided numbers the program must first
    find their sum and then divide that sum by 20\. Once the average value is found,
    the program must check whether to display the corresponding message.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_30.7-3a'
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 20
  prefs: []
  type: TYPE_NORMAL
- en: values = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'values[i] = float(input("Enter a value: "))'
  prefs: []
  type: TYPE_NORMAL
- en: '#Accumulate values in total'
  prefs: []
  type: TYPE_NORMAL
- en: total = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: total += values[i]
  prefs: []
  type: TYPE_NORMAL
- en: average = total / ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'if average < 10:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Average value is less than 10")
  prefs: []
  type: TYPE_NORMAL
- en: If you are wondering whether or not this exercise could have been solved using
    just one for-loop, the answer is “yes”. An alternative solution is presented next.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_30.7-3b'
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 20
  prefs: []
  type: TYPE_NORMAL
- en: total = 0
  prefs: []
  type: TYPE_NORMAL
- en: values = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'values[i] = float(input("Enter a value: "))'
  prefs: []
  type: TYPE_NORMAL
- en: total += values[i]
  prefs: []
  type: TYPE_NORMAL
- en: average = total / ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'if average < 10:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Average value is less than 10")
  prefs: []
  type: TYPE_NORMAL
- en: But let's clarify something! Even though many processes can be performed inside
    just one for-loop, it is simpler to carry out each individual process in a separate
    for-loop. This is probably not so efficient but, since you are still a novice
    programmer, try to adopt this programming style just for now. Later, when you
    have the experience and become a Python guru, you will be able to “merge” many
    processes in just one for-loop!
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see a more Pythonic approach using the fsum() function.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_30.7-3c'
  prefs: []
  type: TYPE_NORMAL
- en: from math import fsum
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 20
  prefs: []
  type: TYPE_NORMAL
- en: values = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'values.append(float(input("Enter a value: ")))'
  prefs: []
  type: TYPE_NORMAL
- en: 'if fsum(values) / ELEMENTS < 10:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Average value is less than 10")
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 30.7-4 Displaying Reals Only
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter 10 numeric values into
    a list. The program must then display the indexes of the elements that contain
    reals.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: In [Exercise 22.1-1](chapter22.html#toc_2) you learned how to check whether
    or not, a number is an integer. Accordingly, to check whether or not, a number
    is a real (float), you can use the Boolean expression
  prefs: []
  type: TYPE_NORMAL
- en: number != int(number)
  prefs: []
  type: TYPE_NORMAL
- en: The solution is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_30.7-4'
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 10
  prefs: []
  type: TYPE_NORMAL
- en: b = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'b[i] = float(input("Enter a value for element " + str(i) + ": "))'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if b[i] != int(b[i]):'
  prefs: []
  type: TYPE_NORMAL
- en: print("A real found at index:", i)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise 30.7-5 Displaying Elements with Odd-Numbered Indexes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that prompts the user to enter 8 numeric values into
    a list. The program must then display the elements with odd-numbered indexes (that
    is, indexes 1, 3, 5, and 7).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: Following is one possible solution.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_30.7-5a'
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 8
  prefs: []
  type: TYPE_NORMAL
- en: values = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'values[i] = float(input("Enter a value for element " + str(i) + ": "))'
  prefs: []
  type: TYPE_NORMAL
- en: '#Display the elements with odd-numbered indexes'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if i % 2 != 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print(values[i])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: However, you know that only the values in odd-numbered index positions must
    be displayed. Therefore, the for-loop that is responsible for displaying the elements
    of the list, instead of starting counting from 0 and using a step of +1, it can
    start counting from 1 and use a step of +2\. This modification decreases the number
    of iterations by half. The modified Python program follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_30.7-5b'
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 8
  prefs: []
  type: TYPE_NORMAL
- en: values = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'values[i] = float(input("Enter a value for element " + str(i) + ": "))'
  prefs: []
  type: TYPE_NORMAL
- en: '#Display the elements with odd-numbered indexes'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, ELEMENTS, 2):         #Start from 1 and increment by 2'
  prefs: []
  type: TYPE_NORMAL
- en: print(values[i])
  prefs: []
  type: TYPE_NORMAL
- en: As already stated, in Python you can iterate through the list elements using
    the slicing mechanism. In the following program the slicing mechanism is used
    to display only the elements with odd-numbered indexes.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_30.7-5c'
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 8
  prefs: []
  type: TYPE_NORMAL
- en: values = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'values[i] = float(input("Enter a value for element " + str(i) + ": "))'
  prefs: []
  type: TYPE_NORMAL
- en: '#Display the elements with odd-numbered indexes'
  prefs: []
  type: TYPE_NORMAL
- en: 'for value in values[1::2]:      #Start from 1 and increment by 2'
  prefs: []
  type: TYPE_NORMAL
- en: print(value)
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 30.7-6 Displaying Even Numbers in Odd–Numbered Index Positions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Python program that lets the user enter 100 integers into a list and
    then displays any even values that are stored in odd–numbered index positions.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: Following is one possible solution.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_30.7-6a'
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 100
  prefs: []
  type: TYPE_NORMAL
- en: values = [None] * ELEMENTS
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: values[i] = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, ELEMENTS, 2):      #Start from 1 and increment by 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'if values[i] % 2 == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print(values[i])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: However, a more Pythonic way is to use the slicing mechanism as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_30.7-6b'
  prefs: []
  type: TYPE_NORMAL
- en: ELEMENTS = 100
  prefs: []
  type: TYPE_NORMAL
- en: values = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(ELEMENTS):'
  prefs: []
  type: TYPE_NORMAL
- en: values.append(int(input()))
  prefs: []
  type: TYPE_NORMAL
- en: 'for value in values[1::2]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if value % 2 == 0:'
  prefs: []
  type: TYPE_NORMAL
- en: print(value)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 30.8 More about the Concatenation and Repetition Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Section 7.5](chapter07.html#toc_7), you learned how to concatenate and how
    to repeat strings using the string operators ( + ) and ( * ) correspondingly.
    The same operators, as well as their corresponding assignment operators ( += )
    and ( *= ), can also be used in lists. To be more specific, the concatenation
    operator ( + ) and the concatenation assignment operator ( += ) can be used to
    join two (or more) lists, whereas the repetition operator ( * ) and the repetition
    assignment operator ( *= ) can be used to repeat the same list multiple times.
    Let's see some examples.
  prefs: []
  type: TYPE_NORMAL
- en: The following code fragment creates list x, which, in the end, contains the
    values [1, 2, 3, 4, 5, 6].
  prefs: []
  type: TYPE_NORMAL
- en: a = [1, 2]
  prefs: []
  type: TYPE_NORMAL
- en: b = [3, 4]
  prefs: []
  type: TYPE_NORMAL
- en: x = a + b    #List x contains the values [1, 2, 3, 4]
  prefs: []
  type: TYPE_NORMAL
- en: x += [5, 6]  #List x contains the values [1, 2, 3, 4, 5, 6]
  prefs: []
  type: TYPE_NORMAL
- en: 'You have already used the repetition operator ( * ) in [Section 30.3](#toc_6)
    to create a list with empty elements using the following statement given in general
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: list_name = [None] * size
  prefs: []
  type: TYPE_NORMAL
- en: What this statement actually did was to repeat a list of one empty element (this
    is the [None] list) size times. For example, the following code fragment iterates
    the list [None] 3 times.
  prefs: []
  type: TYPE_NORMAL
- en: 'x = [None] * 3   #List x contains the values [None, None, None]'
  prefs: []
  type: TYPE_NORMAL
- en: The following code fragment creates list x, which, in the end, contains the
    values [5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6].
  prefs: []
  type: TYPE_NORMAL
- en: 'x = [5, 6] * 2   #List x contains the values [5, 6, 5, 6]'
  prefs: []
  type: TYPE_NORMAL
- en: 'x *= 3   #List x contains the values [5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6]'
  prefs: []
  type: TYPE_NORMAL
- en: 30.9 What is a Dictionary?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In computer science, the main difference between a dictionary and a list is
    that the dictionary elements can be uniquely identified using a key and not necessarily
    an integer value. Each key of a dictionary is associated (or mapped, if you prefer)
    to an element. The keys of a dictionary can be of type string, integer, float,
    or tuple.
  prefs: []
  type: TYPE_NORMAL
- en: The following example presents a dictionary that holds the names of a family.
    The name of the dictionary is family and the corresponding keys are written above
    each element.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter30-10.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/notice.jpg)The keys of dictionary elements must be unique within the
    dictionary. This means that in the dictionary family, for example, you cannot
    have two keys named father.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The values of dictionary elements can be of any type.'
  prefs: []
  type: TYPE_NORMAL
- en: 30.10 Creating Dictionaries in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's try to create the following dictionary using the most common approaches.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter30-11.png)'
  prefs: []
  type: TYPE_IMG
- en: First approach
  prefs: []
  type: TYPE_NORMAL
- en: To create a dictionary and directly assign values to its elements, you can use
    the next Python statement, given in general form.
  prefs: []
  type: TYPE_NORMAL
- en: 'dict_name = {key0: value0, key1: value1, key2: value2, …, keyM: valueM }'
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: ►dict_name is the name of the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: ►key0, key1, key2, … , keyM are the keys of the dictionary elements.
  prefs: []
  type: TYPE_NORMAL
- en: ►value0, value1, value2, … , valueM are the values of the dictionary elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this approach, the dictionary pupil can be created using the following
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: 'pupil = {"firstName": "Ann", "lastName": "Fox", "age": 8, "class": "2nd"}'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Each key is separated from its value by a colon ( : ), the
    elements are separated by commas, and everything is enclosed within curly brackets
    { }.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)In [Section 5.4](chapter05.html#toc_4) you learned about
    the rules that must be followed when assigning names to variables. Assigning names
    to dictionaries follows exactly the same rules!'
  prefs: []
  type: TYPE_NORMAL
- en: Second approach
  prefs: []
  type: TYPE_NORMAL
- en: In this approach, you can create a totally empty dictionary using the following
    statement, given in general form
  prefs: []
  type: TYPE_NORMAL
- en: dict_name = {}
  prefs: []
  type: TYPE_NORMAL
- en: and then add an element (key-value), as shown in the following Python statement,
    given in general form.
  prefs: []
  type: TYPE_NORMAL
- en: dict_name[key] = value
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this approach, the dictionary pupil can be created using the following
    code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: pupil = {}
  prefs: []
  type: TYPE_NORMAL
- en: pupil["firstName"] = "Ann"
  prefs: []
  type: TYPE_NORMAL
- en: pupil["lastName"] = "Fox"
  prefs: []
  type: TYPE_NORMAL
- en: pupil["age"] = 8
  prefs: []
  type: TYPE_NORMAL
- en: pupil["class"] = "2nd"
  prefs: []
  type: TYPE_NORMAL
- en: 30.11 How to Get a Value from a Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get the value of a specific dictionary element, you must point to that element
    using its corresponding key. The following code fragment creates a dictionary,
    and then displays “Ares is the God of War”, without the double quotes, on the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: olympians = {
  prefs: []
  type: TYPE_NORMAL
- en: '"Zeus": "King of the Gods",'
  prefs: []
  type: TYPE_NORMAL
- en: '"Hera": "Goddess of Marriage",'
  prefs: []
  type: TYPE_NORMAL
- en: '"Ares": "God of War",'
  prefs: []
  type: TYPE_NORMAL
- en: '"Poseidon": "God of the Sea",'
  prefs: []
  type: TYPE_NORMAL
- en: '"Demeter": "Goddess of the Harvest",'
  prefs: []
  type: TYPE_NORMAL
- en: '"Artemis": "Goddess of the Hunt",'
  prefs: []
  type: TYPE_NORMAL
- en: '"Apollo": "God of Music and Medicine",'
  prefs: []
  type: TYPE_NORMAL
- en: '"Aphrodite": "Goddess of Love and Beauty",'
  prefs: []
  type: TYPE_NORMAL
- en: '"Hermes": "Messenger of the Gods",'
  prefs: []
  type: TYPE_NORMAL
- en: '"Athena": "Goddess of Wisdom",'
  prefs: []
  type: TYPE_NORMAL
- en: '"Hephaistos": "God of Fire and the Forge",'
  prefs: []
  type: TYPE_NORMAL
- en: '"Dionysus": "God of the Wine"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: print("Ares is the", olympians["Ares"])
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Only keys can be used to access an element. This means that
    olympians["Ares"] correctly returns “God of War” but olympians["God of War"] cannot
    return “Ares”.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 30.11-1 Roman Numerals to Numbers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Roman numerals are shown in the following table.
  prefs: []
  type: TYPE_NORMAL
- en: '| Number | Roman Numeral |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | I |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | II |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | III |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | IV |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | V |'
  prefs: []
  type: TYPE_TB
- en: Write a Python program that prompts the user to enter a Roman numeral between
    I and V, and then displays the corresponding number. Assume that the user enters
    a valid value.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: The obvious solution would be the use of a multiple-alternative decision structure,
    similar to the one shown in the code fragment that follows.
  prefs: []
  type: TYPE_NORMAL
- en: if romanNumeral == "I"
  prefs: []
  type: TYPE_NORMAL
- en: number = 1
  prefs: []
  type: TYPE_NORMAL
- en: elif romanNumeral == "II"
  prefs: []
  type: TYPE_NORMAL
- en: number = 2
  prefs: []
  type: TYPE_NORMAL
- en: elif romanNumeral == "III"
  prefs: []
  type: TYPE_NORMAL
- en: number = 3
  prefs: []
  type: TYPE_NORMAL
- en: elif romanNumeral == "IV"
  prefs: []
  type: TYPE_NORMAL
- en: number = 4
  prefs: []
  type: TYPE_NORMAL
- en: elif romanNumeral == "V"
  prefs: []
  type: TYPE_NORMAL
- en: number = 5
  prefs: []
  type: TYPE_NORMAL
- en: However, this approach is quite lengthy, and it could become even more extensive
    if you want to expand your program to work with additional Roman numerals. Therefore,
    armed with knowledge about dictionaries, you can employ a more efficient approach,
    as demonstrated in the code fragment that follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'roman2number = {"I": 1, "II": 2, "III": 3, "IV": 4, "V": 5}'
  prefs: []
  type: TYPE_NORMAL
- en: number = roman2number[romanNumeral]
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this exercise is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_30.11-1'
  prefs: []
  type: TYPE_NORMAL
- en: 'roman2number = {"I": 1, "II": 2, "III": 3, "IV": 4, "V": 5}'
  prefs: []
  type: TYPE_NORMAL
- en: 'romanNumeral = input("Enter a Roman numeral: ")'
  prefs: []
  type: TYPE_NORMAL
- en: number = roman2number[romanNumeral]
  prefs: []
  type: TYPE_NORMAL
- en: print(romanNumeral + ":", number)
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 30.11-2 Using a Non-Existing Key in Dictionaries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What is wrong in the following Python program?
  prefs: []
  type: TYPE_NORMAL
- en: 'family = {"father": "John", "mother": "Maria", "son": "George"}'
  prefs: []
  type: TYPE_NORMAL
- en: print(family["daughter"])
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: Similar to lists, this code does not satisfy the property of definiteness. You
    must never reference a non-existing dictionary element. Since there is no key
    “daughter”, the last statement throws a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: 30.12 How to Alter the Value of a Dictionary Element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To alter the value of an existing dictionary element you need to use the appropriate
    key and assign a new value to that element. The example that follows shows exactly
    this.
  prefs: []
  type: TYPE_NORMAL
- en: '#Create a dictionary'
  prefs: []
  type: TYPE_NORMAL
- en: 'tribes = {"Indian": "Navajo", "African": "Zulu"}'
  prefs: []
  type: TYPE_NORMAL
- en: 'print(tribes) #It displays: {''Indian'': ''Navajo'', ''African'': ''Zulu''}'
  prefs: []
  type: TYPE_NORMAL
- en: '#Alter the value of an existing element'
  prefs: []
  type: TYPE_NORMAL
- en: tribes["Indian"] = "Apache"
  prefs: []
  type: TYPE_NORMAL
- en: 'print(tribes) #It displays: {''Indian'': ''Apache'', ''African'': ''Zulu''}'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 30.12-1 Assigning a Value to a Non-Existing Key
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Is there anything wrong in the following code fragment?
  prefs: []
  type: TYPE_NORMAL
- en: 'tribes = {0: "Navajo", 1: "Cherokee", 2: "Sioux"}'
  prefs: []
  type: TYPE_NORMAL
- en: tribes[3] = "Apache"
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: No, this time there is absolutely nothing wrong in this code fragment. At first
    glance, you might have thought that the last statement tries to alter the value
    of a non-existing key and it will throw an error. This is not true for Python's
    dictionaries, though. Since tribes is a dictionary and key “3” does not exist,
    the last statement adds a brand new fourth element to the dictionary!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)The keys of a dictionary can be of type string, integer,
    float, or tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind though, if tribes were actually a list, the last statement would
    certainly throw an error. Take a look at the following code fragment
  prefs: []
  type: TYPE_NORMAL
- en: tribes = ["Navajo", "Cherokee", "Sioux"]
  prefs: []
  type: TYPE_NORMAL
- en: tribes[3] = "Apache"
  prefs: []
  type: TYPE_NORMAL
- en: In this example, since tribes is a list and index 3 does not exist, the last
    statement tries to alter the value of a non-existing element and obviously throws
    an error!
  prefs: []
  type: TYPE_NORMAL
- en: 30.13 How to Iterate Through a Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To iterate through the elements of a dictionary you can use a for-loop. There
    are two approaches actually. Let's study them both!
  prefs: []
  type: TYPE_NORMAL
- en: First approach
  prefs: []
  type: TYPE_NORMAL
- en: Following is a code fragment, written in general form
  prefs: []
  type: TYPE_NORMAL
- en: 'for key in structure_name:'
  prefs: []
  type: TYPE_NORMAL
- en: process structure_name[key]
  prefs: []
  type: TYPE_NORMAL
- en: in which process is any Python statement or block of statements that processes
    one element of the dictionary structure_name at each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: The following Python program displays the letters A, B, C, and D, and their
    corresponding Morse^([[23]](footnotes.html#Endnote_23)) code.
  prefs: []
  type: TYPE_NORMAL
- en: 'morseCode = {"A": ".-", "B": "-...", "C": "-.-.", "D": "-.."}'
  prefs: []
  type: TYPE_NORMAL
- en: 'for letter in morseCode:'
  prefs: []
  type: TYPE_NORMAL
- en: print(letter, morseCode[letter])
  prefs: []
  type: TYPE_NORMAL
- en: The next example gives a bonus of $2000 to each employee of a computer software
    company!
  prefs: []
  type: TYPE_NORMAL
- en: salaries = {
  prefs: []
  type: TYPE_NORMAL
- en: '"Project Manager": 83000,'
  prefs: []
  type: TYPE_NORMAL
- en: '"Software Engineer": 81000,'
  prefs: []
  type: TYPE_NORMAL
- en: '"Network Engineer": 64000,'
  prefs: []
  type: TYPE_NORMAL
- en: '"Systems Administrator": 61000,'
  prefs: []
  type: TYPE_NORMAL
- en: '"Software Developer": 70000'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'for title in salaries:'
  prefs: []
  type: TYPE_NORMAL
- en: salaries[title] += 2000
  prefs: []
  type: TYPE_NORMAL
- en: Second approach
  prefs: []
  type: TYPE_NORMAL
- en: Following is a code fragment, written in general form
  prefs: []
  type: TYPE_NORMAL
- en: 'for key, value in structure_name.items():'
  prefs: []
  type: TYPE_NORMAL
- en: process key, value
  prefs: []
  type: TYPE_NORMAL
- en: in which process is any Python statement or block of statements that processes
    one element of the dictionary structure_name at each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: The following Python program displays all elements of the dictionary grades,
    one at each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'grades = {"John": "B+", "George": "A+", "Maria": "A", "Helen": "A-"}'
  prefs: []
  type: TYPE_NORMAL
- en: 'for name, grade in grades.items():'
  prefs: []
  type: TYPE_NORMAL
- en: print(name, "got", grade)
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, this approach cannot be used to alter the values of the elements
    of a dictionary. For example, if you want to double the values of all elements
    of the dictionary salaries, you cannot do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: salaries = {
  prefs: []
  type: TYPE_NORMAL
- en: '"Project Manager": 83000,'
  prefs: []
  type: TYPE_NORMAL
- en: '"Software Engineer": 81000,'
  prefs: []
  type: TYPE_NORMAL
- en: '"Network Engineer": 64000,'
  prefs: []
  type: TYPE_NORMAL
- en: '"Systems Administrator": 61000,'
  prefs: []
  type: TYPE_NORMAL
- en: '"Software Developer": 70000'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'for title, salary in salaries.items():'
  prefs: []
  type: TYPE_NORMAL
- en: salary *= 2
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)salary is a simple variable that, at each iteration, each
    successive value of the dictionary salaries is assigned to. However, the opposite
    never happens! The value of salary is never assigned back to any element!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)If you want to alter the values of the elements of a dictionary,
    you should use the first approach.'
  prefs: []
  type: TYPE_NORMAL
- en: 30.14 More about the Membership Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Section 15.5](chapter15.html#toc_7), you learned about Python's membership
    operators in and not in. You can, as well, use the same operators to evaluate
    whether or not an operand exists in a specified data structure. Let's see some
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: The following example displays “It exists!”
  prefs: []
  type: TYPE_NORMAL
- en: x = [1, 2, 3, 4, 5, 6]
  prefs: []
  type: TYPE_NORMAL
- en: 'if 3 in x:'
  prefs: []
  type: TYPE_NORMAL
- en: print("It exists!")
  prefs: []
  type: TYPE_NORMAL
- en: The following example looks for “George” in list y.
  prefs: []
  type: TYPE_NORMAL
- en: y = ["John", "Maria", "Anna", "George", "Tes"]
  prefs: []
  type: TYPE_NORMAL
- en: 'if "George" in y:'
  prefs: []
  type: TYPE_NORMAL
- en: print("I found George!!!!")
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that the in operator checks whether an operand exists
    in a data structure. It cannot find the index position where the operand is found!'
  prefs: []
  type: TYPE_NORMAL
- en: The following example prompts the user to enter a name and then checks whether
    it does not exist in the list y.
  prefs: []
  type: TYPE_NORMAL
- en: y = ["John", "Maria", "Anna", "George", "Tes"]
  prefs: []
  type: TYPE_NORMAL
- en: 'name = input("Enter a name to search: ")'
  prefs: []
  type: TYPE_NORMAL
- en: 'if name not in y:'
  prefs: []
  type: TYPE_NORMAL
- en: print(name, "not found!!!!")
  prefs: []
  type: TYPE_NORMAL
- en: The following example checks whether key “Son” exists in dictionary family.
  prefs: []
  type: TYPE_NORMAL
- en: 'family = {"Father": "John", "Mother": "Maria", "Son": "George"}'
  prefs: []
  type: TYPE_NORMAL
- en: 'if "Son" in family:'
  prefs: []
  type: TYPE_NORMAL
- en: print("Key 'Son' found!")
  prefs: []
  type: TYPE_NORMAL
- en: '30.15 Review Questions: True/False'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Choose true or false for each of the following statements.
  prefs: []
  type: TYPE_NORMAL
- en: 1)Lists are structures that can hold multiple values.
  prefs: []
  type: TYPE_NORMAL
- en: 2)List elements are located in main memory (RAM).
  prefs: []
  type: TYPE_NORMAL
- en: 3)There can be only one-dimensional and two-dimensional lists.
  prefs: []
  type: TYPE_NORMAL
- en: 4)There cannot be four-dimensional lists.
  prefs: []
  type: TYPE_NORMAL
- en: 5)A list is called “multidimensional” because it can hold values of different
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 6)Each list element has a unique non-negative index.
  prefs: []
  type: TYPE_NORMAL
- en: 7)There can be two identical keys within a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 8)In lists, index numbering always starts at zero by default.
  prefs: []
  type: TYPE_NORMAL
- en: 9)The index of the last list element is equal to the total number of its elements.
  prefs: []
  type: TYPE_NORMAL
- en: 10)A two-hundred–dimensional list can exist.
  prefs: []
  type: TYPE_NORMAL
- en: 11)The next statement contains a syntax error.
  prefs: []
  type: TYPE_NORMAL
- en: studentNames = None * 10
  prefs: []
  type: TYPE_NORMAL
- en: 12)In a Python program, two lists cannot have the same name.
  prefs: []
  type: TYPE_NORMAL
- en: 13)The next statement is syntactically correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'student = {"firstName": "Ann" - "lastName": "Fox" - "age": 8}'
  prefs: []
  type: TYPE_NORMAL
- en: 14)In a Python program, two lists cannot have the same number of elements.
  prefs: []
  type: TYPE_NORMAL
- en: 15)You cannot use a variable as an index in a list.
  prefs: []
  type: TYPE_NORMAL
- en: 16)You can use a mathematical expression as an index in a list.
  prefs: []
  type: TYPE_NORMAL
- en: 17)You cannot use a variable as a key in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 18)The following code fragment throws no errors.
  prefs: []
  type: TYPE_NORMAL
- en: a = "a"
  prefs: []
  type: TYPE_NORMAL
- en: 'fruits = {"o": "Orange", "a": "Apple", "w": "Watermelon"}'
  prefs: []
  type: TYPE_NORMAL
- en: print(fruits[a])
  prefs: []
  type: TYPE_NORMAL
- en: 19)If you use a variable as an index in a list, this variable must contain an
    integer value.
  prefs: []
  type: TYPE_NORMAL
- en: 20)In order to calculate the sum of 20 numeric user-provided values, you must
    use a list.
  prefs: []
  type: TYPE_NORMAL
- en: 21)You can let the user enter a value into list b using the statement b[k] =
    input()
  prefs: []
  type: TYPE_NORMAL
- en: 22)The following statement creates a one-dimensional list of two empty elements.
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * 3
  prefs: []
  type: TYPE_NORMAL
- en: 23)The following code fragment assigns the value 10 to the element at index
    7.
  prefs: []
  type: TYPE_NORMAL
- en: values[5] = 7
  prefs: []
  type: TYPE_NORMAL
- en: values[values[5]] = 10
  prefs: []
  type: TYPE_NORMAL
- en: 24)The following code fragment assigns the value “Sally” without the double
    quotes to the element at index 2.
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * 3
  prefs: []
  type: TYPE_NORMAL
- en: names[2] = "John"
  prefs: []
  type: TYPE_NORMAL
- en: names[1] = "George"
  prefs: []
  type: TYPE_NORMAL
- en: names[0] = "Sally"
  prefs: []
  type: TYPE_NORMAL
- en: 25)The following statement assigns the value “Sally” without the double quotes
    to the element at index 2.
  prefs: []
  type: TYPE_NORMAL
- en: names = ["John", "George", "Sally"]
  prefs: []
  type: TYPE_NORMAL
- en: 26)The following code fragment displays “Sally”, without the double quotes,
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: names = [None] * 3
  prefs: []
  type: TYPE_NORMAL
- en: k = 0
  prefs: []
  type: TYPE_NORMAL
- en: names[k] = "John"
  prefs: []
  type: TYPE_NORMAL
- en: k += 1
  prefs: []
  type: TYPE_NORMAL
- en: names[k] = "George"
  prefs: []
  type: TYPE_NORMAL
- en: k += 1
  prefs: []
  type: TYPE_NORMAL
- en: names[k] = "Sally"
  prefs: []
  type: TYPE_NORMAL
- en: k -= 1
  prefs: []
  type: TYPE_NORMAL
- en: print(names[k])
  prefs: []
  type: TYPE_NORMAL
- en: 27)The following code fragment is syntactically correct.
  prefs: []
  type: TYPE_NORMAL
- en: names = ["John", "George", "Sally"]
  prefs: []
  type: TYPE_NORMAL
- en: print(names[])
  prefs: []
  type: TYPE_NORMAL
- en: 28)The following code fragment displays “Maria”, without the double quotes,
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: from math import pi
  prefs: []
  type: TYPE_NORMAL
- en: names = ["John", "George", "Sally", "Maria"]
  prefs: []
  type: TYPE_NORMAL
- en: print(names[int(pi)])
  prefs: []
  type: TYPE_NORMAL
- en: 29)The following code fragment satisfies the property of definiteness.
  prefs: []
  type: TYPE_NORMAL
- en: grades = ["B+", "A+", "A"]
  prefs: []
  type: TYPE_NORMAL
- en: print(grades[3])
  prefs: []
  type: TYPE_NORMAL
- en: 30)The following code fragment satisfies the property of definiteness.
  prefs: []
  type: TYPE_NORMAL
- en: v = [1, 3, 2, 9]
  prefs: []
  type: TYPE_NORMAL
- en: print(v[v[v[0]]])
  prefs: []
  type: TYPE_NORMAL
- en: 31)The following code fragment displays the value of 1 on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: v = [1, 3, 2, 0]
  prefs: []
  type: TYPE_NORMAL
- en: print(v[v[v[v[0]]]])
  prefs: []
  type: TYPE_NORMAL
- en: 32)The following code fragment displays all the elements of the list names.
  prefs: []
  type: TYPE_NORMAL
- en: names = ["John", "George", "Sally", "Maria"]
  prefs: []
  type: TYPE_NORMAL
- en: i = i
  prefs: []
  type: TYPE_NORMAL
- en: 'while i < 4:'
  prefs: []
  type: TYPE_NORMAL
- en: print(names[i])
  prefs: []
  type: TYPE_NORMAL
- en: i += 1
  prefs: []
  type: TYPE_NORMAL
- en: 33)The following code fragment satisfies the property of definiteness.
  prefs: []
  type: TYPE_NORMAL
- en: names = ["John", "George", "Sally", "Maria"]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(2, 5):'
  prefs: []
  type: TYPE_NORMAL
- en: print(names[i])
  prefs: []
  type: TYPE_NORMAL
- en: 34)The following code fragment lets the user enter 100 values into list b.
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(100):'
  prefs: []
  type: TYPE_NORMAL
- en: b[i] = input()
  prefs: []
  type: TYPE_NORMAL
- en: 35)If list b contains 30 elements (arithmetic values), the following code fragment
    doubles the values of all of its elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(29, -1, -1):'
  prefs: []
  type: TYPE_NORMAL
- en: b[i] = b[i] * 2
  prefs: []
  type: TYPE_NORMAL
- en: 36)It is possible to use a for-loop to double the values of some of the elements
    of a list.
  prefs: []
  type: TYPE_NORMAL
- en: 37)If list b contains 30 elements, the following code fragment displays all
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'for element in b[0:29]:'
  prefs: []
  type: TYPE_NORMAL
- en: print(element)
  prefs: []
  type: TYPE_NORMAL
- en: 38)If b is a dictionary, the following code fragment displays all of its elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'for key, element in b:'
  prefs: []
  type: TYPE_NORMAL
- en: print(element)
  prefs: []
  type: TYPE_NORMAL
- en: 39)The following code fragment throws an error.
  prefs: []
  type: TYPE_NORMAL
- en: fruits = {
  prefs: []
  type: TYPE_NORMAL
- en: '"O": "Orange",'
  prefs: []
  type: TYPE_NORMAL
- en: '"A": "Apple",'
  prefs: []
  type: TYPE_NORMAL
- en: '"W": "Watermelon"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: print(fruits["Orange"])
  prefs: []
  type: TYPE_NORMAL
- en: '30.16 Review Questions: Multiple Choice'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Select the correct answer for each of the following statements.
  prefs: []
  type: TYPE_NORMAL
- en: 1)The following statement
  prefs: []
  type: TYPE_NORMAL
- en: lastNames = [NONE] * 5
  prefs: []
  type: TYPE_NORMAL
- en: a)contains a logic error.
  prefs: []
  type: TYPE_NORMAL
- en: b)contains a syntax error.
  prefs: []
  type: TYPE_NORMAL
- en: c)is a correct statement.
  prefs: []
  type: TYPE_NORMAL
- en: d)none of the above
  prefs: []
  type: TYPE_NORMAL
- en: 2)The following code fragment
  prefs: []
  type: TYPE_NORMAL
- en: x = 5
  prefs: []
  type: TYPE_NORMAL
- en: values[x / 2] = 10
  prefs: []
  type: TYPE_NORMAL
- en: a)does not satisfy the property of definiteness.
  prefs: []
  type: TYPE_NORMAL
- en: b)does not satisfy the property of finiteness.
  prefs: []
  type: TYPE_NORMAL
- en: c)does not satisfy the property of effectiveness.
  prefs: []
  type: TYPE_NORMAL
- en: d)none of the above
  prefs: []
  type: TYPE_NORMAL
- en: 3)If variable x contains the value 4, the following statement
  prefs: []
  type: TYPE_NORMAL
- en: values[x + 1] = 5
  prefs: []
  type: TYPE_NORMAL
- en: a)assigns the value 4 to the element at index 5.
  prefs: []
  type: TYPE_NORMAL
- en: b)assigns the value 5 to the element at index 4.
  prefs: []
  type: TYPE_NORMAL
- en: c)assigns the value 5 to the element at index 5.
  prefs: []
  type: TYPE_NORMAL
- en: d)none of the above
  prefs: []
  type: TYPE_NORMAL
- en: 4)The following statement
  prefs: []
  type: TYPE_NORMAL
- en: values = []
  prefs: []
  type: TYPE_NORMAL
- en: values.append(5)
  prefs: []
  type: TYPE_NORMAL
- en: a)assigns the value 5 to the element at index 1.
  prefs: []
  type: TYPE_NORMAL
- en: b)assigns the value 5 to the element at index 0.
  prefs: []
  type: TYPE_NORMAL
- en: c)does not satisfy the property of definiteness.
  prefs: []
  type: TYPE_NORMAL
- en: d)none of the above
  prefs: []
  type: TYPE_NORMAL
- en: 5)The following code fragment
  prefs: []
  type: TYPE_NORMAL
- en: values[0] = 1
  prefs: []
  type: TYPE_NORMAL
- en: values[values[0]] = 2
  prefs: []
  type: TYPE_NORMAL
- en: values[values[1]] = 3
  prefs: []
  type: TYPE_NORMAL
- en: values[values[2]] = 4
  prefs: []
  type: TYPE_NORMAL
- en: a)assigns the value 4 to the element at index 3.
  prefs: []
  type: TYPE_NORMAL
- en: b)assigns the value 3 to the element at index 2.
  prefs: []
  type: TYPE_NORMAL
- en: c)assigns the value 2 to the element at index 1.
  prefs: []
  type: TYPE_NORMAL
- en: d)all of the above
  prefs: []
  type: TYPE_NORMAL
- en: e)none of the above
  prefs: []
  type: TYPE_NORMAL
- en: 6)If list values contains numeric values, the following statement
  prefs: []
  type: TYPE_NORMAL
- en: print(values[values[1] − values[1 % 2]] − values[int(1/2)])
  prefs: []
  type: TYPE_NORMAL
- en: a)does not satisfy the property of definiteness.
  prefs: []
  type: TYPE_NORMAL
- en: b)always displays 0.
  prefs: []
  type: TYPE_NORMAL
- en: c)always displays 1.
  prefs: []
  type: TYPE_NORMAL
- en: d)none of the above
  prefs: []
  type: TYPE_NORMAL
- en: 7)You can iterate through a one-dimensional list with a for-loop that uses
  prefs: []
  type: TYPE_NORMAL
- en: a)variable i as a counter.
  prefs: []
  type: TYPE_NORMAL
- en: b)variable j as a counter.
  prefs: []
  type: TYPE_NORMAL
- en: c)variable k as a counter.
  prefs: []
  type: TYPE_NORMAL
- en: d)any variable as a counter.
  prefs: []
  type: TYPE_NORMAL
- en: 8)The following code fragment
  prefs: []
  type: TYPE_NORMAL
- en: names = ["George", "John", "Maria", "Sally"]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(3, 0, -1):'
  prefs: []
  type: TYPE_NORMAL
- en: print(names[i])
  prefs: []
  type: TYPE_NORMAL
- en: a)displays all names in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: b)displays some names in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: c)displays all names in descending order.
  prefs: []
  type: TYPE_NORMAL
- en: d)displays some names in descending order.
  prefs: []
  type: TYPE_NORMAL
- en: e)none of the above
  prefs: []
  type: TYPE_NORMAL
- en: 9)The following code fragment
  prefs: []
  type: TYPE_NORMAL
- en: fruits = ["apple", "orange", "onion", "watermelon"]
  prefs: []
  type: TYPE_NORMAL
- en: print(fruits[1])
  prefs: []
  type: TYPE_NORMAL
- en: 'a)displays: "orange"'
  prefs: []
  type: TYPE_NORMAL
- en: 'b)displays: apple'
  prefs: []
  type: TYPE_NORMAL
- en: 'c)displays: orange'
  prefs: []
  type: TYPE_NORMAL
- en: d)throws an error because onion is not a fruit!
  prefs: []
  type: TYPE_NORMAL
- en: e)none of the above
  prefs: []
  type: TYPE_NORMAL
- en: 10)If list b contains 30 elements (arithmetic values), the following code fragment
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(29, 0, -1):'
  prefs: []
  type: TYPE_NORMAL
- en: b[i] = b[i] * 2
  prefs: []
  type: TYPE_NORMAL
- en: a)doubles the values of some of its elements.
  prefs: []
  type: TYPE_NORMAL
- en: b)doubles the values of all of its elements.
  prefs: []
  type: TYPE_NORMAL
- en: c)none of the above
  prefs: []
  type: TYPE_NORMAL
- en: 11)The following code fragment
  prefs: []
  type: TYPE_NORMAL
- en: 'struct = {"firstName": "George", "lastName": "Miles", "age": 28}'
  prefs: []
  type: TYPE_NORMAL
- en: 'for a, b in struct.items():'
  prefs: []
  type: TYPE_NORMAL
- en: print(b)
  prefs: []
  type: TYPE_NORMAL
- en: a)displays all the keys of the dictionary elements.
  prefs: []
  type: TYPE_NORMAL
- en: b)displays all the values of the dictionary elements.
  prefs: []
  type: TYPE_NORMAL
- en: c)displays all the key-value pairs of the dictionary elements.
  prefs: []
  type: TYPE_NORMAL
- en: d)none of the above
  prefs: []
  type: TYPE_NORMAL
- en: 12)The following code fragment
  prefs: []
  type: TYPE_NORMAL
- en: 'struct = {"firstName": "George", "lastName": "Miles", "age": 28}'
  prefs: []
  type: TYPE_NORMAL
- en: 'for x in struct:'
  prefs: []
  type: TYPE_NORMAL
- en: print(x)
  prefs: []
  type: TYPE_NORMAL
- en: a)displays all the keys of the dictionary elements.
  prefs: []
  type: TYPE_NORMAL
- en: b)displays all the values of the dictionary elements.
  prefs: []
  type: TYPE_NORMAL
- en: c)displays all the key-value pairs of the dictionary elements.
  prefs: []
  type: TYPE_NORMAL
- en: d)none of the above
  prefs: []
  type: TYPE_NORMAL
- en: 13)The following code fragment
  prefs: []
  type: TYPE_NORMAL
- en: 'tribes = {0: "Navajo", 1: "Cherokee", 2: "Sioux", 3: "Apache"}'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(4):'
  prefs: []
  type: TYPE_NORMAL
- en: print(tribes[i])
  prefs: []
  type: TYPE_NORMAL
- en: a)displays all the keys of the dictionary elements.
  prefs: []
  type: TYPE_NORMAL
- en: b)displays all the values of the dictionary elements.
  prefs: []
  type: TYPE_NORMAL
- en: c)displays all the key-value pairs of the dictionary elements.
  prefs: []
  type: TYPE_NORMAL
- en: d)none of the above
  prefs: []
  type: TYPE_NORMAL
- en: 14)The following code fragment
  prefs: []
  type: TYPE_NORMAL
- en: 'tribes = {"tribeA": "Navajo", "tribeB": "Cherokee", "tribeC": "Sioux"}'
  prefs: []
  type: TYPE_NORMAL
- en: 'for x in tribes:'
  prefs: []
  type: TYPE_NORMAL
- en: tribes[x] = tribes[x].upper()
  prefs: []
  type: TYPE_NORMAL
- en: a)converts all the keys of the dictionary elements to uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: b)converts all the values of the dictionary elements to uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: c)convert all the key-value pairs of the dictionary elements to uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: d)none of the above
  prefs: []
  type: TYPE_NORMAL
- en: 30.17 Review Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete the following exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 1)Design a data structure to hold the weights (in pounds) of five people, and
    then add some typical values to the structure.
  prefs: []
  type: TYPE_NORMAL
- en: 2)Design the necessary data structures to hold the names and the weights (in
    pounds) of seven people, and then add some typical values to the structures.
  prefs: []
  type: TYPE_NORMAL
- en: 3)Design the necessary data structures to hold the names of five lakes as well
    as the average area (in square miles) of each lake in June, July, and August.
    Then add some typical values to the structures.
  prefs: []
  type: TYPE_NORMAL
- en: 4)Design a data structure to hold the three dimensions (width, height, and depth
    in inches) of 10 boxes. Then add some typical values to the structure.
  prefs: []
  type: TYPE_NORMAL
- en: 5)Design the necessary data structures to hold the names of eight lakes as well
    as the average area (in square miles) and maximum depth (in feet) of each lake.
    Then add some typical values to the structures.
  prefs: []
  type: TYPE_NORMAL
- en: 6)Design the necessary data structures to hold the names of four lakes as well
    as their average areas (in square miles) for the first week of June, the first
    week of July, and the first week of August.
  prefs: []
  type: TYPE_NORMAL
- en: 7)Create the trace table for the following code fragment.
  prefs: []
  type: TYPE_NORMAL
- en: a = [None] * 3
  prefs: []
  type: TYPE_NORMAL
- en: a[2] = 1
  prefs: []
  type: TYPE_NORMAL
- en: x = 0
  prefs: []
  type: TYPE_NORMAL
- en: a[x + a[2]] = 4
  prefs: []
  type: TYPE_NORMAL
- en: a[x] = a[x + 1] * 4
  prefs: []
  type: TYPE_NORMAL
- en: 8)Create the trace table for the following code fragment.
  prefs: []
  type: TYPE_NORMAL
- en: a = [None] * 5
  prefs: []
  type: TYPE_NORMAL
- en: a[1] = 5
  prefs: []
  type: TYPE_NORMAL
- en: x = 0
  prefs: []
  type: TYPE_NORMAL
- en: a[x] = 4
  prefs: []
  type: TYPE_NORMAL
- en: a[a[0]] = a[x + 1] % 3
  prefs: []
  type: TYPE_NORMAL
- en: a[a[0] / 2] = 10
  prefs: []
  type: TYPE_NORMAL
- en: x += 2
  prefs: []
  type: TYPE_NORMAL
- en: a[x + 1] = a[x] + 9
  prefs: []
  type: TYPE_NORMAL
- en: 9)Create the trace table for the following code fragment for three different
    executions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The input values for the three executions are: (i) 3, (ii) 4, and (iii) 1.'
  prefs: []
  type: TYPE_NORMAL
- en: a = [None] * 4
  prefs: []
  type: TYPE_NORMAL
- en: a[1] = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: x = 0
  prefs: []
  type: TYPE_NORMAL
- en: a[x] = 3
  prefs: []
  type: TYPE_NORMAL
- en: a[a[0]] = a[x + 1] % 2
  prefs: []
  type: TYPE_NORMAL
- en: a[a[0] % 2] = 10
  prefs: []
  type: TYPE_NORMAL
- en: x += 1
  prefs: []
  type: TYPE_NORMAL
- en: a[x + 1] = a[x] + 9
  prefs: []
  type: TYPE_NORMAL
- en: 10)Create the trace table for the following code fragment for three different
    executions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The input values for the three executions are: (i) 100, (ii) 108, and (iii)
    1.'
  prefs: []
  type: TYPE_NORMAL
- en: a = [None] * 4
  prefs: []
  type: TYPE_NORMAL
- en: a[1] = int(input())
  prefs: []
  type: TYPE_NORMAL
- en: x = 0
  prefs: []
  type: TYPE_NORMAL
- en: a[x] = 3
  prefs: []
  type: TYPE_NORMAL
- en: a[a[0]] = a[x + 1] % 10
  prefs: []
  type: TYPE_NORMAL
- en: 'if a[3] > 5:'
  prefs: []
  type: TYPE_NORMAL
- en: a[a[0] % 2] = 9
  prefs: []
  type: TYPE_NORMAL
- en: x += 1
  prefs: []
  type: TYPE_NORMAL
- en: a[x + 1] = a[x] + 9
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: a[2] = 3
  prefs: []
  type: TYPE_NORMAL
- en: 11)Fill in the gaps in the following trace table. In steps 6 and 7, fill in
    the name of a variable; for all other cases, fill in constant values, arithmetic,
    or comparison operators.
  prefs: []
  type: TYPE_NORMAL
- en: '| Step | Statement | x | y | a[0] | a[1] | a[2] |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | a = [None] * 3 | ? | ? | ? | ? | ? |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | x = …… | 4 | ? | ? | ? | ? |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | y = x ‑ …… | 4 | 3 | ? | ? | ? |'
  prefs: []
  type: TYPE_TB
- en: '| 4, 5 | if x …… y:     a[0] = ……'
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: a[0] = y | 4 | 3 | 1 | ? | ? |
  prefs: []
  type: TYPE_NORMAL
- en: '| 6 | a[1] = …… + 3 | 4 | 3 | 1 | 7 | ? |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | y = …… ‑ 1 | 4 | 2 | 1 | 7 | ? |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | a[y] = (x + 5) …… 2 | 4 | 2 | 1 | 7 | 1 |'
  prefs: []
  type: TYPE_TB
- en: 12)Create the trace table for the following code fragment.
  prefs: []
  type: TYPE_NORMAL
- en: a = [17, 12, 45, 12, 12, 49]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(6):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if a[i] == 12:'
  prefs: []
  type: TYPE_NORMAL
- en: a[i] -= 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: a[i] += 1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 13)Create the trace table for the following code fragment.
  prefs: []
  type: TYPE_NORMAL
- en: a = [10, 15, 12, 23, 22, 19]
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(1, 5):'
  prefs: []
  type: TYPE_NORMAL
- en: a[i] = a[i + 1] + a[i - 1]
  prefs: []
  type: TYPE_NORMAL
- en: 14)Try, without using a trace table, to determine the values that are displayed
    when the following code fragment is executed.
  prefs: []
  type: TYPE_NORMAL
- en: tribes = {
  prefs: []
  type: TYPE_NORMAL
- en: '"Indian-1": "Navajo",'
  prefs: []
  type: TYPE_NORMAL
- en: '"Indian-2": "Cherokee",'
  prefs: []
  type: TYPE_NORMAL
- en: '"Indian-3" : "Sioux",'
  prefs: []
  type: TYPE_NORMAL
- en: '"African-1": "Zulu",'
  prefs: []
  type: TYPE_NORMAL
- en: '"African-2": "Maasai",'
  prefs: []
  type: TYPE_NORMAL
- en: '"African-3": "Yoruba"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'for x, y in tribes.items():'
  prefs: []
  type: TYPE_NORMAL
- en: 'if x[:6] == "Indian":'
  prefs: []
  type: TYPE_NORMAL
- en: print(y)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 15)Write a Python program that lets the user enter 100 numbers into a list and
    then displays these values raised to the power of three.
  prefs: []
  type: TYPE_NORMAL
- en: 16)Write a Python program that lets the user enter 80 numbers into a list. Then,
    the program must raise the list values to the power of two, and finally display
    them in the exact reverse of the order in which they were provided.
  prefs: []
  type: TYPE_NORMAL
- en: 17)Write a Python program that lets the user enter 90 integers into a list and
    then displays those that are exactly divisible by 5 in the exact reverse of the
    order in which they were provided.
  prefs: []
  type: TYPE_NORMAL
- en: 18)Write a Python program that lets the user enter 50 integers into a list and
    then displays those that are even or greater than 10.
  prefs: []
  type: TYPE_NORMAL
- en: 19)Write a Python program that lets the user enter 30 numbers into a list and
    then calculates and displays the sum of those that are positive.
  prefs: []
  type: TYPE_NORMAL
- en: 20)Write a Python program that lets the user enter 50 integers into a list and
    then calculates and displays the sum of those that have two digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: All two-digit integers are between 10 and 99.'
  prefs: []
  type: TYPE_NORMAL
- en: 21)Write a Python program that lets the user enter 40 numbers into a list and
    then calculates and displays the sum of the positive numbers and the sum of the
    negative ones.
  prefs: []
  type: TYPE_NORMAL
- en: 22)Write a Python program that lets the user enter 20 numbers into a list and
    then calculates and displays their average value.
  prefs: []
  type: TYPE_NORMAL
- en: 23)Write a Python program that prompts the user to enter 50 integer values into
    a list. It then displays the indexes of the elements that contain values lower
    than 20.
  prefs: []
  type: TYPE_NORMAL
- en: 24)Write a Python program that prompts the user to enter 60 numeric values into
    a list. It then displays the elements with even-numbered indexes (that is, indexes
    0, 2, 4, 6, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 25)Write a Python program that prompts the user to enter 20 numeric values into
    into a list. It then calculates and displays the sum of the elements that have
    even indexes.
  prefs: []
  type: TYPE_NORMAL
- en: 26)Write a code fragment in Python that creates the following list of 100 elements.
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter30-12.png)
  prefs: []
  type: TYPE_NORMAL
- en: 27)Write a code fragment in Python that creates the following list of 100 elements.
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter30-13.png)
  prefs: []
  type: TYPE_NORMAL
- en: 28)Write a Python program that prompts the user to enter an integer N and then
    creates and displays the following list of N elements. Using a loop control structure,
    the program must also validate data input and display an error message when the
    user enters any value less than 1.
  prefs: []
  type: TYPE_NORMAL
- en: .![Image](img/chapter30-14.png)
  prefs: []
  type: TYPE_NORMAL
- en: 29)Write a Python program that prompts the user to enter 10 numeric values into
    a list and then displays the indexes of the elements that contain integers.
  prefs: []
  type: TYPE_NORMAL
- en: 30)Write a Python program that prompts the user to enter 50 numeric values into
    a list and then counts and displays the total number of negative elements.
  prefs: []
  type: TYPE_NORMAL
- en: 31)Write a Python program that prompts the user to enter 50 words into a list
    and then displays those that contain at least 10 characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Use the len() function.'
  prefs: []
  type: TYPE_NORMAL
- en: 32)Write a Python program that lets the user enter 30 words into a list. It
    then displays those words that have less than 5 characters, then those that have
    less than 10 characters, and finally those that have less than 20 characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Try to display the words using two for-loops nested one within the other.'
  prefs: []
  type: TYPE_NORMAL
- en: 33)Write a Python program that prompts the user to enter 40 words into a list
    and then displays those that contain the letter “w” at least twice.
  prefs: []
  type: TYPE_NORMAL
- en: 34)Roman numerals are shown in the following table.
  prefs: []
  type: TYPE_NORMAL
- en: '| Digit | Roman Numeral (Tens digits) | Roman Numeral (Ones digits) |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | X | I |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | XX | I |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | XXX | III |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | XL | IV |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | L | V |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | LX | VI |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | LXX | VII |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | LXXX | VIII |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | XC | IX |'
  prefs: []
  type: TYPE_TB
- en: Each Roman numeral is a combination of tens and ones digits. For example, the
    Roman numeral representation of the number 45 is XLV (4 tens represented by XL
    and 5 ones represented by V). Write a Python program that prompts the user to
    enter an integer between 1 and 99 and displays the corresponding Roman numeral.
    Assume that the user enters a valid value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Avoid checking each integer individually, as this would require a multiple-alternative
    decision structure with 99 cases. Try to find a more efficient and clever approach
    instead!'
  prefs: []
  type: TYPE_NORMAL
