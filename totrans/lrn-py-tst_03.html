<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Unit Testing with doctest</h1></div></div></div><p>In the last chapter, we talked about what <code class="literal">doctest</code> does, how it works, and what you can expect out of it. Why are we devoting another chapter to it?</p><p>We're not. This chapter isn't really about <code class="literal">doctest</code>. It's about the testing discipline called <strong>unit testing</strong>. Since unit testing is an idea, not a piece of software, we'll be using <code class="literal">doctest</code> to practice with it.</p><p>In this chapter, we're going to see:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What unit testing actually is</li><li class="listitem" style="list-style-type: disc">How unit testing helps</li><li class="listitem" style="list-style-type: disc">How <code class="literal">doctest</code> relates to unit testing</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec30"/>What is unit testing?</h1></div></div></div><p>First of all, why <a id="id104" class="indexterm"/>do we care what unit testing is? One answer is that unit testing is a best practice that has been evolving toward its current form over most of the time that programming has existed. Another answer is that the core principles of unit testing are just good sense. It might actually be a little embarrassing to our community as a whole that it took us so long to recognize this.</p><p>So what is it? Unit testing means testing the smallest meaningful pieces of code (such pieces are called units), in such a way that guarantees that the success or failure of each test depends only on the unit and nothing else.</p><p>There's a reason for each part of this definition:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We test the smallest meaningful pieces of code so that failed tests tell us where the problem is. The larger the tested chunk of code, the larger the area where a problem might originate.</li><li class="listitem" style="list-style-type: disc">We make sure that each test depends only on the tested unit for success or failure because, if it invokes any code outside the unit, we can't guarantee that the test's success or failure is actually due to that unit. When tests aren't independent, you can't trust them to tell you what the problem is and where to find it.</li></ul></div><p>We made some efforts to write our tests in <a class="link" href="ch02.html" title="Chapter 2. Working with doctest">Chapter 2</a>, <em>Working with doctest</em>, according to this discipline, although we allowed ourselves some wiggle room because we were focusing on writing a testable specification. In this chapter, we're going to be more rigorous.</p><p>Automated testing is often associated with unit testing. Automated testing makes it fast and easy to run unit tests, and unit tests tend to be amenable to automation. We're certainly going to make <a id="id105" class="indexterm"/>heavy use of automated testing, both with <code class="literal">doctest</code> now, and later with tools such as unittest and Nose as well. However, strictly speaking, unit testing is not tied to automated testing. You can do unit testing with nothing but your own code and some discipline.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec31"/>The limitations of unit testing</h1></div></div></div><p>Any test <a id="id106" class="indexterm"/>that involves more than one unit is automatically not a unit test. That matters because the results of unit tests tend to be particularly clear about what a problem is and where to find it.</p><p>When you test multiple units at once, the results of the various units get mixed together. In the end, you have to wonder about both what the problem is (is the mistake in this piece of code, or is it correctly handling bad input from some other piece of code?), and where the problem is (this output is wrong, but how do the involved units work together to create the error?).</p><p>Empirical scientists must perform experiments that check only one hypothesis at a time, whether the subject at hand is Chemistry, Physics, or the behavior of a body of program code.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Example – identifying units</h2></div></div></div><p>Imagine for a <a id="id107" class="indexterm"/>moment that one of your coworkers has written the <a id="id108" class="indexterm"/>following code, and it's your responsibility to test it:</p><div><pre class="programlisting">class Testable:
    def method1(self, number):
        number += 4
        number **= 0.5
        number *= 7
        return number

    def method2(self, number):
        return ((number * 2) ** 1.27) * 0.3

    def method3(self, number):
        return self.method1(number) + self.method2(number)

    def method4(self):
        return 1.713 * self.method3(id(self))</pre></div><p>Here are some things to think about: Which sections of this code are the units? Is there only one unit consisting of the entire class? Is each method a separate unit? What about each statement, or maybe each expression?</p><p>In some sense, the answer is subjective because part of the definition of a unit is that it is meaningful. You can say that the whole class is a single unit, and in some circumstances that might be the best answer. However, it is easy to subdivide most classes into methods, and normally methods make <a id="id109" class="indexterm"/>better units because they have well-defined interfaces and partially isolated behaviors, and because their intent and meaning should be well understood.</p><p>Statements and expressions don't make good units because they are almost never particularly meaningful in isolation. Furthermore, statements and expressions are difficult to target: unlike classes and methods, they don't have names or easy ways to focus a test on them.</p><p>Here are some things to think about: What will be the consequences of choosing a different definition of unit for this code? If you have <a id="id110" class="indexterm"/>decided that methods are the best units, what would be different if you had picked classes? Likewise, if you picked classes, what would be different if you'd picked methods?</p><p>Here are some things to think about: Take a look at <code class="literal">method4</code>. The result of this method depends on all of the other methods working correctly; worse, it depends on the unique ID of the self object. Can <code class="literal">method4</code> be treated as a unit? If we could change anything except <code class="literal">method4</code>, what is that we have to change to allow it to be tested as a unit and produce a predictable result?</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Choosing units</h2></div></div></div><p>You can't organize a <a id="id111" class="indexterm"/>suite of unit tests until you decide what constitutes a unit. The capabilities of your chosen programming language affect this choice. For <a id="id112" class="indexterm"/>example, C++ and Java make it difficult or impossible to treat methods as units (because you can't access a method without first instantiating the class it's part of); thus, in these languages each class is usually treated as a single unit, or metaprogramming tricks are used to force the methods into isolation so that they can be tested as units. C, on the other hand, doesn't support classes as language features at all, so the obvious choice of unit is the function. Python is flexible enough that either classes or methods can be considered as units and, of course, it has standalone functions as well; it is also natural to think of them as units.</p><p>The smaller the units are, the more useful the tests tend to be because they narrow down the location and nature of bugs more quickly. For example, if you choose to treat the <code class="literal">Testable</code> class as a unit, tests of the class will fail if there is a mistake in any of the methods. This tells you that there's a mistake in <code class="literal">Testable</code>, but not that it's in <code class="literal">method2</code>, or wherever it actually is. On the other hand, there is a certain amount of rigamarole involved in treating <code class="literal">method4</code> and its like as units, to such an extent that the next chapter of the book is dedicated to dealing with such situations. Even so, I recommend using methods and functions as units most of the time because it pays off in the long run.</p><p>When you were thinking about <code class="literal">method4</code>, you probably realized that the function calls to <code class="literal">id</code> and <code class="literal">self.method3</code> <a id="id113" class="indexterm"/>were the problem, and that the method can be tested as a unit if they didn't invoke other units. In Python, replacing the functions with stand-ins <a id="id114" class="indexterm"/>at runtime is fairly easy to do, and we'll be discussing a structured approach to this in the next chapter.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Check your understanding</h1></div></div></div><p>Take a look at <a id="id115" class="indexterm"/>the code for this simple class, and use it to figure <a id="id116" class="indexterm"/>out the answers to the questions. It's okay to check back through the book. This is just a way for you to make sure you're ready to move on:</p><div><pre class="programlisting">class ClassOne:
    def __init__(self, arg1, arg2):
        self.arg1 = int(arg1)
        self.arg2 = arg2

    def method1(self, x):
        return x * self.arg1

    def method2(self, x):
        return self.method1(self.arg2) * x</pre></div><p>Here are the questions:</p><div><ol class="orderedlist arabic"><li class="listitem">Assuming that we're using methods as units, how many units exist in the preceding code? <p>Answer: There are three units that exist in the preceding code and that are as follows: <code class="literal">__init__</code>, <code class="literal">method1</code>, and <code class="literal">method2</code>. <code class="literal">__init__</code> is a method, just as <code class="literal">method1</code> and <code class="literal">method2</code>. The fact that it's a constructor means that it's all tangled up with the other units, but it's still a method containing code and a possible location for bugs, and so we cannot afford to treat this as anything other than a unit.</p></li><li class="listitem">Which units make <a id="id117" class="indexterm"/>assumptions about the correct operation <a id="id118" class="indexterm"/>of other units? In other words, which units are not independent?<p>Answer: Both <code class="literal">method1</code> and <code class="literal">method2</code> assume that <code class="literal">__init__</code> works right, and <code class="literal">method2</code> makes the same assumption as that of <code class="literal">method1</code>.</p></li><li class="listitem">How can you write a test for <code class="literal">method2</code> that does not assume that other units work correctly?<p>Answer: The tests for <code class="literal">method2</code> will need to use a fake <code class="literal">method1</code> that is a part of the test code, and not a part of the code being tested.</p></li></ol></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Unit testing during the development process</h1></div></div></div><p>We're going to <a id="id119" class="indexterm"/>walk through the development of one class, treating it as a complete programming project and integrating unit testing at <a id="id120" class="indexterm"/>each step of the process. For something as small as a single standalone class, this may seem silly, but it illustrates the practices that keep larger projects from getting bogged down in a tangle of bugs.</p><p>We're going to create a PID controller class. A PID controller is a tool from control theory, a way of controlling machines so that they move smoothly and efficiently. The robot arms that assemble cars in factories are controlled by PID controllers. We'll be using a PID controller for this demonstration because it's a very useful, and a very real-world idea. Many programmers have been asked to implement PID controllers at some point in their careers. This example is meant to be read as if we are contractors and are being paid to produce results.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>If you find that the <a id="id121" class="indexterm"/>PID controllers are more interesting than simply an example in a programming book, wikipedia's article is a good place to begin learning about this: <a class="ulink" href="http://en.wikipedia.org/wiki/PID_controller">http://en.wikipedia.org/wiki/PID_controller</a>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Design</h2></div></div></div><p>Our imaginary <a id="id122" class="indexterm"/>client gives us the following specification:</p><div><blockquote class="blockquote"><p>We want a class that implements a PID controller for a single variable. The measurement, setpoint and output should all be real numbers.</p><p>We need to be able to adjust the setpoint at runtime, but we want it to have a memory, so we can easily return to the previous setpoint.</p></blockquote></div><p>We'll take this and make it more formal, not to mention complete, by writing a set of acceptance tests as unit tests that describe the behavior. This way we'll at least have it set down precisely as what we believe the client intended.</p><p>We need to write a set of tests that describe the constructor. After looking up what a PID controller actually is, we have learned that they are defined by three gains and a setpoint. The controller has three components: proportional, integral, and derivative (this is where the name PID comes from). Each gain is a number that determines how much effect one of the three parts of the controller has on the final result. The setpoint determines what the goal of the controller is; in other words, to where it's trying to move the controlled variable. Looking at all this, we decide that the constructor should just store the gains and the setpoint along with initializing some internal state that we know we'll need because we read about PID controllers. With this, we know enough to write some constructor tests:</p><div><pre class="programlisting">&gt;&gt;&gt; import pid

&gt;&gt;&gt; controller = pid.PID(P=0.5, I=0.5, D=0.5, setpoint=0)

&gt;&gt;&gt; controller.gains
(0.5, 0.5, 0.5)
&gt;&gt;&gt; controller.setpoint
[0.0]
&gt;&gt;&gt; controller.previous_time is None
True
&gt;&gt;&gt; controller.previous_error
0.0
&gt;&gt;&gt; controller.integrated_error
0.0</pre></div><p>We also need tests that describe measurement processing. This means testing the actual use of the controller, taking a measured value as its input, and producing a control signal that should smoothly move the measured variable toward the setpoint.</p><p>The behavior of a PID controller is based on time; we know that, so we're going to need to be able to feed the controller time values that we choose if we expect the tests to produce predictable results. We do this by replacing <code class="literal">time.time</code> with a different function of the same signature, which produces predictable results.</p><p>Once we have <a id="id123" class="indexterm"/>that taken care of, we plug our test input values into the math that defines a PID controller along with the gains to figure out what the correct outputs will be, and use these numbers to write the tests:</p><div><pre class="programlisting">Replace time.time with a predictable fake
&gt;&gt;&gt; import time
&gt;&gt;&gt; real_time = time.time
&gt;&gt;&gt; time.time = (float(x) for x in range(1, 1000)).__next__

Make sure we're not inheriting old state from the constructor tests
&gt;&gt;&gt; import imp
&gt;&gt;&gt; pid = imp.reload(pid)

Actual tests. These test values are nearly arbitrary, having been chosen for no reason other than that they should produce easily recognized values.
&gt;&gt;&gt; controller = pid.PID(P=0.5, I=0.5, D=0.5, setpoint=0)
&gt;&gt;&gt; controller.calculate_response(12)
-6.0
&gt;&gt;&gt; controller.calculate_response(6)
-3.0
&gt;&gt;&gt; controller.calculate_response(3)
-4.5
&gt;&gt;&gt; controller.calculate_response(-1.5)
-0.75
&gt;&gt;&gt; controller.calculate_response(-2.25)
-1.125

Undo the fake
&gt;&gt;&gt; time.time = real_time</pre></div><p>We need to write tests that describe setpoint handling. Our client asked for a "memory" for setpoints, which we'll interpret as a stack, so we write tests that ensure that the setpoint stack works. Writing code that uses this stack behavior brings to our attention the fact that a PID controller with no setpoint is not a meaningful entity, so we add a test that checks that the <a id="id124" class="indexterm"/>PID class rejects this situation by raising an exception:</p><div><pre class="programlisting">&gt;&gt;&gt; pid = imp.reload(pid)
&gt;&gt;&gt; controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 0)

&gt;&gt;&gt; controller.push_setpoint(7)
&gt;&gt;&gt; controller.setpoint
[0.0, 7.0]

&gt;&gt;&gt; controller.push_setpoint(8.5)
&gt;&gt;&gt; controller.setpoint
[0.0, 7.0, 8.5]

&gt;&gt;&gt; controller.pop_setpoint()
8.5
&gt;&gt;&gt; controller.setpoint
[0.0, 7.0]

&gt;&gt;&gt; controller.pop_setpoint()
7.0
&gt;&gt;&gt; controller.setpoint
[0.0]

&gt;&gt;&gt; controller.pop_setpoint()
Traceback (most recent call last):
ValueError: PID controller must have a setpoint</pre></div><p>PID controllers are well-defined elsewhere, so the sparse specification that our client gave us works pretty well over all. Still, we had to codify several assumptions when we wrote our acceptance tests; it would probably be wise to check with the client and make sure that we didn't go astray, which means that, before we even ran the tests, they already helped us by pointing out questions we needed to ask them.</p><p>We took extra steps in the tests to help isolate them from each other, by forcing the <code class="literal">pid</code> module to reimport before each group of test statements. This has the effect of resetting anything that might have changed in the module, and causes it to reimport any modules that it depends on. This is particularly important, since we replaced <code class="literal">time.time</code> with a dummy function. We want to be sure that the <code class="literal">pid</code> module uses the dummy time function, so we reload the <code class="literal">pid</code> module. If the real-time function is used instead of the dummy, the test won't be useful because it will succeed only once. Tests need to be repeatable.</p><p>The stand-in time function was created by making an iterator that counts through the integers from 1 to 999 (as floating point values), and binding <code class="literal">time.time</code> to that iterator's <code class="literal">__next__</code> method. Once we were done with the time-dependent tests, we replaced the original <code class="literal">time.time</code>.</p><p>We did get a little bit lazy, though, because we didn't bother to isolate the assorted tests from the PID constructor. If there's a bug in the constructor, it might cause a false error report in any of the tests that are dependent on it. We could have been more rigorous by using a mock object instead of an actual PID object, and thus even skipped invoking the constructor during the tests of other units but, as we aren't talking about mock objects until the next chapter, we'll allow ourselves a bit of laziness here.</p><p>Right now, we have tests for a module that doesn't exist. That's good! Writing the tests was easier than <a id="id125" class="indexterm"/>writing the module, and this gives us a stepping stone towards getting the module right, quickly and easily. As a general rule, you always want to have tests ready before the code that the test is written for.</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>Note that I said "you want to have tests ready," not "you want to have all of the tests ready." You don't want, or need, to have every test in place before you start writing code. What you want is to have the tests in place that define the things you already know at the start of the process.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Development</h2></div></div></div><p>Now that we <a id="id126" class="indexterm"/>have some tests, we can begin writing code to satisfy the tests, and thus also the specification.</p><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>What if the code is already written? We can still write tests for its units. This isn't as productive as writing the tests in parallel with the code, but this at least gives us a way to check our assumptions and make sure that we don't introduce regressions. A test suite written late is better than no test suite at all.</p></div></div><p>The first step is to run the tests because this is always the first thing you do when you need to decide what to do next. If all the tests pass, either you're done with the program or you need to write more tests. If one or more tests fail, you pick one and make it pass.</p><p>So, we run the tests as follows:</p><div><pre class="programlisting"><strong>python3 -m doctest PID.txt</strong></pre></div><p>The first time they <a id="id127" class="indexterm"/>tell us that we don't have a <code class="literal">pid</code> module. Let's create one and fill it with a first attempt at a <code class="literal">PID</code> class:</p><div><pre class="programlisting">from time import time

class PID:
    def __init__(self, P, I, D, setpoint):
        self.gains = (float(P), float(I), float(D))
        self.setpoint = [float(setpoint)]
        self.previous_time = None
        self.previous_error = 0.0
        self.integrated_error = 0.0

    def push_setpoint(self, target):
        self.setpoint.append(float(target))

    def pop_setpoint(self):
        if len(self.setpoint) &gt; 1:
            return self.setpoint.pop()
        raise ValueError('PID controller must have a setpoint')

    def calculate_response(self, value):
        now = time()
        P, I, D = self.gains

        err = value - self.setpoint[-1]

        result = P * err
        if self.previous_time is not None:
            delta = now - self.previous_time
            self.integrated_error += err * delta
            result += I * self.integrated_error
            result += D * (err - self.previous_error) / delta

        self.previous_error = err
        self.previous_time = now

        return result</pre></div><p>Now, we'll run the tests again, and see how we did as follows:</p><div><pre class="programlisting"><strong>python3 -m doctest PIDflawed.txt</strong></pre></div><p>This immediately tells us that there's a bug in the <code class="literal">calculate_response</code> method:</p><div><img src="img/3211OS_03_01.jpg" alt="Development"/></div><p>There are more error reports in the same vein. There should be five in total. It seems that the <code class="literal">calculate_response</code> method is working backwards, producing negatives when it should give us positives, and vice-versa.</p><p>We know that we <a id="id128" class="indexterm"/>need to look for a sign error in <code class="literal">calculate_response</code>, and we find it on the fourth line, where the input value should be subtracted from the setpoint and not the other way around. Things should work better if we change this line to the following:</p><div><pre class="programlisting">err = self.setpoint[-1] - value</pre></div><p>As expected, that change fixes things. The tests all pass, now.</p><p>We used our tests to tell us what was needed to be done, and to tell us when our code was complete. Our first run of the tests gave us a list of things that needed to be written; a to-do list of sorts. After we wrote some code, we ran the tests again to see if it was doing what we expected, which gave us a new to-do list. We kept on alternately running the tests and writing code to make one of the tests pass until they all did. When all the tests pass, either we're done, or we need to write more tests.</p><p>Whenever we find a bug that isn't already caught by a test, the right thing to do is to add a test that catches it, and then we need to fix the bug. This gives a fixed bug, but also a test that covers some part of the program that wasn't tested before. Your new test might well catch more bugs that you weren't even aware of, and it will help you avoid recreating the fixed bug.</p><p>This "test a little, code a little" style of programming is called <strong>Test-driven Development</strong>, and you'll find that <a id="id129" class="indexterm"/>it's very productive.</p><p>Notice that the pattern <a id="id130" class="indexterm"/>in the way the tests failed was immediately apparent. There's no guarantee that will be the case, of course, but it often is. Combined with the ability to narrow your attention to the specific units that are having problems, debugging is usually a snap.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Feedback</h2></div></div></div><p>So, we <a id="id131" class="indexterm"/>have a PID controller, it passes our tests... are we done? Maybe. Let's ask the client.</p><p>The good news is that they mostly like it. They have a few things they'd like to be changed, though. They want us to be able to optionally specify the current time as a parameter to <code class="literal">calculate_response</code>, so that the specified time is used instead of the current system time. They also want us to change the signature of the constructor so that it accepts an initial measurement and optionally a measurement time as parameters.</p><p>So, the program passes all of our tests, but the tests don't correctly describe the requirements anymore. What to do?</p><p>First, we'll add the initial value parameter to the constructor tests, and update the expected results as follows:</p><div><pre class="programlisting">&gt;&gt;&gt; import time
&gt;&gt;&gt; real_time = time.time
&gt;&gt;&gt; time.time = (float(x) for x in range(1, 1000)).__next__
&gt;&gt;&gt; import pid
&gt;&gt;&gt; <strong>controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 0,...                      initial = 12)</strong>
&gt;&gt;&gt; controller.gains
(0.5, 0.5, 0.5)
&gt;&gt;&gt; controller.setpoint
[0.0]
&gt;&gt;&gt; controller.previous_time
1.0
&gt;&gt;&gt; controller.previous_error
-12.0
&gt;&gt;&gt; controller.integrated_error
0.0
&gt;&gt;&gt; time.time = real_time</pre></div><p>Now, we'll add another test of the constructor, a test that checks the correct behavior when the <a id="id132" class="indexterm"/>optional initial time parameter is provided:</p><div><pre class="programlisting">&gt;&gt;&gt; import imp
&gt;&gt;&gt; pid = imp.reload(pid)
&gt;&gt;&gt; controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 1,
...                      initial = 12, when = 43)
&gt;&gt;&gt; controller.gains
(0.5, 0.5, 0.5)
&gt;&gt;&gt; controller.setpoint
[1.0]
&gt;&gt;&gt; controller.previous_time
43.0
&gt;&gt;&gt; controller.previous_error
-11.0
&gt;&gt;&gt; controller.integrated_error
0.0</pre></div><p>Next, we change the <code class="literal">calculate_response</code> tests to use the new signature for the constructor:</p><div><pre class="programlisting">&gt;&gt;&gt; controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 0,...                      initial = 12)</pre></div><p>We need to add a second <code class="literal">calculate_response</code> test that checks whether the function behaves properly when the optional time parameter is passed to it:</p><div><pre class="programlisting">&gt;&gt;&gt; pid = imp.reload(pid)
&gt;&gt;&gt; controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 0,
...                      initial = 12, when = 1)
&gt;&gt;&gt; controller.calculate_response(6, 2)
-3.0
&gt;&gt;&gt; controller.calculate_response(3, 3)
-4.5
&gt;&gt;&gt; controller.calculate_response(-1.5, 4)
-0.75
&gt;&gt;&gt; controller.calculate_response(-2.25, 5)
-1.125</pre></div><p>Finally, we adjust the constructor call in the setpoint method tests. This change looks the same as the constructor call changes in the other tests.</p><p>When we're adjusting the tests, we discover that the behavior of the <code class="literal">calculate_response</code> method has changed due to the addition of the initial value and initial time parameters to the constructor. The tests will report this as an error but it's not clear that if it really is wrong, so we check this with the client. After talking it over, the client decides that this is actually correct behavior, so we change our tests to reflect that.</p><p>Our complete <a id="id133" class="indexterm"/>specification and test document now looks like this (new or changed lines are highlighted):</p><div><pre class="programlisting">We want a class that implements a PID controller for a single
variable. The measurement, setpoint, and output should all be real
numbers. The constructor should accept an initial measurement value in
addition to the gains and setpoint.

&gt;&gt;&gt; import time
&gt;&gt;&gt; real_time = time.time
&gt;&gt;&gt; time.time = (float(x) for x in range(1, 1000)).__next__
&gt;&gt;&gt; import pid
<strong>&gt;&gt;&gt; controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 0,...                      initial = 12)</strong>
&gt;&gt;&gt; controller.gains
(0.5, 0.5, 0.5)
&gt;&gt;&gt; controller.setpoint
[0.0]
<strong>&gt;&gt;&gt; controller.previous_time</strong>
1.0
&gt;&gt;&gt; controller.previous_error
-12.0
&gt;&gt;&gt; controller.integrated_error
0.0
&gt;&gt;&gt; time.time = real_time

<strong>The constructor should also optionally accept a parameter specifying</strong>
<strong>when the initial measurement was taken.</strong>

<strong>&gt;&gt;&gt; import imp</strong>
<strong>&gt;&gt;&gt; pid = imp.reload(pid)</strong>
<strong>&gt;&gt;&gt; controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 1,</strong>
<strong>...                      initial = 12, when = 43)</strong>
<strong>&gt;&gt;&gt; controller.gains</strong>
<strong>(0.5, 0.5, 0.5)</strong>
<strong>&gt;&gt;&gt; controller.setpoint</strong>
<strong>[1.0]</strong>
<strong>&gt;&gt;&gt; controller.previous_time</strong>
<strong>43.0</strong>
<strong>&gt;&gt;&gt; controller.previous_error</strong>
<strong>-11.0</strong>
<strong>&gt;&gt;&gt; controller.integrated_error</strong>
<strong>0.0</strong>

The calculate response method receives the measured value as input,
and returns the control signal.

&gt;&gt;&gt; import time
&gt;&gt;&gt; real_time = time.time
&gt;&gt;&gt; time.time = (float(x) for x in range(1, 1000)).__next__
&gt;&gt;&gt; pid = imp.reload(pid)
<strong>&gt;&gt;&gt; controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 0,...                      initial = 12)</strong>
<strong>&gt;&gt;&gt; controller.calculate_response(6)</strong>
<strong>-3.0</strong>
<strong>&gt;&gt;&gt; controller.calculate_response(3)</strong>
<strong>-4.5</strong>
<strong>&gt;&gt;&gt; controller.calculate_response(-1.5)</strong>
<strong>-0.75</strong>
<strong>&gt;&gt;&gt; controller.calculate_response(-2.25)</strong>
<strong>-1.125</strong>
&gt;&gt;&gt; time.time = real_time

<strong>The calculate_response method should be willing to accept a parameter</strong>
<strong>specifying at what time the call is happening.</strong>

<strong>&gt;&gt;&gt; pid = imp.reload(pid)</strong>
<strong>&gt;&gt;&gt; controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 0,</strong>
<strong>...                      initial = 12, when = 1)</strong>
<strong>&gt;&gt;&gt; controller.calculate_response(6, 2)</strong>
<strong>-3.0</strong>
<strong>&gt;&gt;&gt; controller.calculate_response(3, 3)</strong>
<strong>-4.5</strong>
<strong>&gt;&gt;&gt; controller.calculate_response(-1.5, 4)</strong>
<strong>-0.75</strong>
<strong>&gt;&gt;&gt; controller.calculate_response(-2.25, 5)</strong>
<strong>-1.125</strong>

We need to be able to adjust the setpoint at runtime, but we want it to have a memory, so that we can easily return to the previous
setpoint.

&gt;&gt;&gt; pid = imp.reload(pid)
<strong>&gt;&gt;&gt; controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 0,...                      initial = 12)</strong>
&gt;&gt;&gt; controller.push_setpoint(7)
&gt;&gt;&gt; controller.setpoint
[0.0, 7.0]
&gt;&gt;&gt; controller.push_setpoint(8.5)
&gt;&gt;&gt; controller.setpoint
[0.0, 7.0, 8.5]
&gt;&gt;&gt; controller.pop_setpoint()
8.5
&gt;&gt;&gt; controller.setpoint
[0.0, 7.0]
&gt;&gt;&gt; controller.pop_setpoint()
7.0
&gt;&gt;&gt; controller.setpoint
[0.0]
&gt;&gt;&gt; controller.pop_setpoint()
Traceback (most recent call last):
ValueError: PID controller must have a setpoint</pre></div><p>Our tests didn't match the requirements and so we needed to change them. That's fine, but we don't want to change them too much because the tests we have already help us to avoid some problems that we've previously spotted or had to fix. The last thing we want for the computer is to <a id="id134" class="indexterm"/>stop checking for known problems. Because of this, we very much prefer adding new tests, instead of changing old ones.</p><p>This is one reason why we added new tests to check the behavior when the optional time parameters were supplied. The other reason is that, if we added these parameters to the existing tests, we wouldn't have any tests of what happens when you don't use these parameters. We always want to check every code path through each unit.</p><p>The addition of the initial parameter to the constructor is a big deal. It not only changes the way the constructor should behave, it also changes the way the <code class="literal">calculate_response</code> method should behave in a rather dramatic way. Since there is a change in the correct behavior (a fact that we didn't realize until the tests pointed it out to us, which in turn allowed us to get a confirmation of what the correct behavior should be from our clients before we started writing the code), we have no choice but to go through and change the tests, recalculating the expected outputs and all. Doing all that work has a benefit, though, over and above the future ability to check whether the function is working correctly: this makes it much easier to comprehend how the function should work when we actually write it.</p><p>When we change a test to reflect new correct behavior, we still try to change it as little as possible. After all, we don't want the test to stop checking for old behavior that's still correct, and we don't want <a id="id135" class="indexterm"/>to introduce a bug in the test itself.</p><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>To a certain extent, the code being tested acts as a test of the test, so even bugs in your tests don't survive very long when you use good testing discipline.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Development, again</h2></div></div></div><p>Time to do some more coding. In real life, we might cycle between development and feedback any number of <a id="id136" class="indexterm"/>times, depending on how well we're able to communicate with our clients. In fact, it might be a good thing to increase the number of times we go back and forth, even if this means that each cycle is short. Keeping the clients in the loop and up-to-date is a good thing.</p><p>The first step, as always, is to run the tests and get an updated list of the things that need to be done:</p><div><pre class="programlisting"><strong>Python3 -m doctest PID.txt</strong></pre></div><div><img src="img/3211OS_03_02.jpg" alt="Development, again"/></div><p>There are actually a lot more errors that are reported, but the very first one gives us a good hint about what we need to fix right off. The constructor needs to change to match the tests' expectations.</p><p>Using the <code class="literal">doctest</code> error report to guide us, and rerunning the tests frequently, we can quickly get our PID class into shape. In practice, this works best using short development cycles where you make only <a id="id137" class="indexterm"/>a few changes to the code, and then run the tests again. Fix one thing, and then test again.</p><p>Once we've gone back and forth between coding and testing enough times, we'll end up with something like this:</p><div><pre class="programlisting">from time import time

class PID:
    def __init__(self, P, I, D, setpoint, initial, when = None):
        self.gains = (float(P), float(I), float(D))

        if P &lt; 0 or I &lt; 0 or D &lt; 0:
            raise ValueError('PID controller gains must be non-negative')

        if not isinstance(setpoint, complex):
            setpoint = float(setpoint)

        if not isinstance(initial, complex):
            initial = float(initial)

        self.setpoint = [setpoint]

        if when is None:
            self.previous_time = time()
        else:
            self.previous_time = float(when)

        self.previous_error = self.setpoint[-1] - initial
        self.integrated_error = 0.0

    def push_setpoint(self, target):
        self.setpoint.append(float(target))

    def pop_setpoint(self):
        if len(self.setpoint) &gt; 1:
            return self.setpoint.pop()
        raise ValueError('PID controller must have a setpoint')

    def calculate_response(self, value, now = None):
        if now is None:
            now = time()
        else:
            now = float(now)

        P, I, D = self.gains

        err = self.setpoint[-1] - value

        result = P * err
        delta = now - self.previous_time
        self.integrated_error += err * delta
        result += I * self.integrated_error
        result += D * (err - self.previous_error) / delta

        self.previous_error = err
        self.previous_time = now

        return result</pre></div><p>Once again, all of the tests pass including all of the revised tests from the client, and it's remarkable how rewarding that <a id="id138" class="indexterm"/>lack of an error report can be. We're ready to see whether the client is willing to accept delivery of the code yet.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Later stages of the process</h2></div></div></div><p>There are later <a id="id139" class="indexterm"/>phases of development when it's your job to maintain the code, or to integrate it into another product. Functionally, they work in the same way as the development phase. If you're handling pre-existing code and are asked to maintain or integrate it, you'll be much happier if it comes to you with a test suite already written because, until you've mastered the intricacies of the code, the test suite is the only way in which you'll be able to modify the code with confidence.</p><p>If you're unfortunate enough to be handed a pile of code with no tests, writing tests is a good first step. Each test you write is one more unit of the code that you can honestly say you understand, and know what to expect from. And, of course, each test you write is one more unit that you can count on to tell you if you introduce a bug.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Summary</h1></div></div></div><p>We've walked through the process of developing a project using unit testing and test-driven development, paying attention to the ways that we can identify units, and covering some of the ways in which we can isolate <code class="literal">doctest</code> tests for individual units.</p><p>We've also talked about the philosophy and discipline of unit testing, what it is in detail, and why it is valuable.</p><p>In the next chapter, we'll discuss mock objects, a powerful tool for isolating units.</p></div></div>
</body></html>