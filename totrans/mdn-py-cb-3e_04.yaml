- en: '4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '4'
- en: 'Built-In Data Structures Part 1: Lists and Sets'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 内置数据结构第1部分：列表和集合
- en: Python has a rich collection of built-in data structures. These data structures
    are sometimes called ”containers” or ”collections” because they contain a collection
    of individual items. These structures cover a wide variety of common programming
    situations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python拥有丰富的内置数据结构。这些数据结构有时被称为“容器”或“集合”，因为它们包含一系列单独的项目。这些结构涵盖了广泛的常见编程场景。
- en: We’ll look at an overview of the various collections that are built in and what
    problems they solve. After the overview, we will look at the list and set collections
    in detail.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将概述内置的各种集合以及它们解决的问题。概述之后，我们将详细探讨列表和集合。
- en: The built-in tuple and string types were part of Chapter [1](ch005_split_000.xhtml#x1-170001),
    [Numbers, Strings, and Tuples](ch005_split_000.xhtml#x1-170001). These structures
    are sequences, making them similar in many ways to the list collection. However,
    strings and tuples seem to have more in common with immutable numbers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的元组和字符串类型是第[1](ch005_split_000.xhtml#x1-170001)章[数字、字符串和元组](ch005_split_000.xhtml#x1-170001)的一部分。这些结构是序列，因此在许多方面与列表集合相似。然而，字符串和元组似乎与不可变的数字有更多的共同点。
- en: The next chapter, Chapter [5](ch009.xhtml#x1-2890005), will look at dictionaries,
    as well as some more advanced topics also related to lists and sets. In particular,
    it will look at how Python handles references to mutable collection objects. This
    has consequences in the way functions need to be defined that accept lists or
    sets as parameters.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章，第[5](ch009.xhtml#x1-2890005)章，将探讨字典，以及一些与列表和集合相关的高级主题。特别是，它将探讨Python如何处理可变集合对象的引用。这在需要将列表或集合作为参数的函数定义方式上有影响。
- en: 'In this chapter, we’ll look at the following recipes, all related to Python’s
    built-in data structures:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下配方，所有这些都与Python的内置数据结构相关：
- en: '[Choosing a data structure](ch008_split_000.xhtml#x1-2250001)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[选择数据结构](ch008_split_000.xhtml#x1-2250001)'
- en: '[Building lists – literals, appending, and comprehensions](ch008_split_000.xhtml#x1-2310002)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[构建列表 - 字面量、追加和推导式](ch008_split_000.xhtml#x1-2310002)'
- en: '[Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[切片和切块列表](ch008_split_000.xhtml#x1-2400003)'
- en: '[Shrinking lists – deleting, removing, and popping](ch008_split_000.xhtml#x1-2460004)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[缩小列表 - 删除、移除和弹出](ch008_split_000.xhtml#x1-2460004)'
- en: '[Writing list-related type hints](ch008_split_001.xhtml#x1-2560005)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[编写与列表相关的类型提示](ch008_split_001.xhtml#x1-2560005)'
- en: '[Reversing a copy of a list](ch008_split_001.xhtml#x1-2620006)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[反转列表的副本](ch008_split_001.xhtml#x1-2620006)'
- en: '[Building sets – literals, adding, comprehensions, and operators](ch008_split_001.xhtml#x1-2670007)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[构建集合 - 字面量、添加、推导式和运算符](ch008_split_001.xhtml#x1-2670007)'
- en: '[Shrinking sets – remove(), pop(), and difference](ch008_split_001.xhtml#x1-2750008)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[缩小集合 - remove()、pop()和差集](ch008_split_001.xhtml#x1-2750008)'
- en: '[Writing set-related type hints](ch008_split_001.xhtml#x1-2800009)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[编写与集合相关的类型提示](ch008_split_001.xhtml#x1-2800009)'
- en: 4.1 Choosing a data structure
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.1 选择数据结构
- en: Python offers a number of built-in data structures to help us work with collections
    of data. It can be confusing to match the data structure features with the problem
    we’re trying to solve.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一些内置数据结构来帮助我们处理数据集合。将数据结构功能与我们要解决的问题相匹配可能会令人困惑。
- en: How do we choose which structure to use?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何选择使用哪种结构？
- en: 4.1.1 Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1.1 准备工作
- en: Before we put data into a collection, we’ll need to consider how we’ll gather
    the data, and what we’ll do with the collection once we have it. One big question
    is how to identify a particular item within the collection. Python offers a variety
    of choices.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将数据放入集合之前，我们需要考虑我们将如何收集数据，以及我们拥有集合后我们将做什么。一个重要的问题是如何在集合中识别特定的项目。Python提供了多种选择。
- en: 4.1.2 How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1.2 如何做...
- en: 'Is the programming focused on the existence of a value? An example of this
    is validating an input value. When the user enters something that’s in a collection,
    their input is valid; otherwise, the entry is invalid. Simple membership tests
    suggest using a set:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编程是否关注值的存不存在？一个例子是验证输入值。当用户输入集合中的内容时，他们的输入是有效的；否则，输入无效。简单的成员资格测试建议使用集合：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A set holds items in no particular order. If order matters, then a list is more
    appropriate.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 集合以无特定顺序的方式存储项目。如果顺序很重要，那么列表更合适。
- en: 'Are we going to identify items by their position in the collection? An example
    includes the lines in an input file—the line number is its position in the collection.
    When we identify an item using an index or position, we must use a list:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们是否将通过在集合中的位置来识别项？一个例子包括输入文件中的行——行号是其在集合中的位置。当我们使用索引或位置来识别项时，我们必须使用列表：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have created a list, month_name_list, with 12 string items in a specific
    order. We can pick an item by providing the index position. We can also use the
    index() method to return the index position of an item in the list. List index
    values in Python always start with zero. While a list has a simple membership
    test, the test can be slow for a very large list, and a set might be a better
    idea if many such tests will be needed.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经创建了一个名为`month_name_list`的列表，其中包含12个字符串项，并按照特定顺序排列。我们可以通过提供索引位置来选择一个项。我们还可以使用`index()`方法来返回列表中项的索引位置。Python中的列表索引值始终从零开始。虽然列表具有简单的成员资格测试，但对于非常大的列表，这种测试可能会很慢，如果需要执行许多此类测试，那么集合可能是一个更好的选择。
- en: If the number of items in the collection is fixed—for example, RGB colors have
    three values—this suggests a tuple instead of a list. If the number of items will
    grow and change, then the list collection is a better choice than the tuple collection.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果集合中的项数是固定的——例如，RGB颜色有三个值——这表明元组而不是列表是一个更好的选择。如果项的数量将增长和变化，那么列表集合比元组集合是一个更好的选择。
- en: 'Are we going to identify the items in a collection by a key value that’s distinct
    from the item’s index? An example might include a mapping between strings of characters—words,
    for example—and integers that represent the frequencies of those words. Another
    example might be a mapping between a color name and the RGB tuple for that color.
    We’ll look at mappings and dictionaries in Chapter [5](ch009.xhtml#x1-2890005),
    [Built-In Data Structures Part 2: Dictionaries](ch009.xhtml#x1-2890005). The important
    distinction is mappings do not locate items by a numerical index position the
    way lists do.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们是否将通过与项的索引不同的键值来识别集合中的项？一个例子可能包括字符字符串（例如单词）与表示这些单词频率的整数之间的映射。另一个例子可能是一个颜色名称与该颜色的RGB元组之间的映射。我们将在第[5](ch009.xhtml#x1-2890005)章“内置数据结构第2部分：字典”中查看映射和字典。重要的区别是映射不像列表那样通过数值索引位置来定位项。
- en: Consider the mutability of items in a set collection (and the keys in a dictionary).
    Each item in a set must be an immutable object. Numbers, strings, and tuples are
    all immutable and can be collected into sets. Since list, dictionary, and set
    objects are mutable, they can’t be used as items in a set. It’s impossible to
    build a set of list objects, for example.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑集合中项的可变性（以及字典中的键）。集合中的每个项都必须是不可变对象。数字、字符串和元组都是不可变的，可以收集到集合中。由于列表、字典和集合对象是可变的，因此不能用作集合中的项。例如，不可能构建一个由列表对象组成的集合。
- en: Rather than create a set of list items, we can transform each item into an immutable
    tuple object. Similarly, dictionary keys must be immutable. We can use a number,
    a string, or a tuple as a dictionary key. We can’t use a list, or a set, or any
    other mutable object as a dictionary key.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以选择将每个列表项转换为一个不可变的元组对象，而不是创建一组列表项。同样，字典键也必须是不可变的。我们可以使用数字、字符串或元组作为字典键。我们不能使用列表、集合或任何其他可变对象作为字典键。
- en: 4.1.3 How it works...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1.3 它是如何工作的...
- en: Each of Python’s built-in collections offers a specific set of unique features.
    The collections also offer a large number of overlapping features. The challenge
    for programmers new to Python is to map the unique features of each collection
    to the problem they are trying to solve.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Python内置的集合都提供了一组独特的功能。集合还提供了大量重叠的功能。对于Python新手程序员来说，挑战在于将每个集合的独特功能映射到他们试图解决的问题。
- en: The collections.abc module provides a kind of road map through the built-in
    container classes. This module defines the Abstract Base Classes (ABCs) underlying
    the concrete classes we use. We’ll use the names from this set of definitions
    to guide us through the features.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections.abc`模块提供了一种通过内置容器类的路线图。该模块定义了我们使用的具体类背后的抽象基类（ABC）。我们将使用这些定义中的名称来指导我们了解其功能。'
- en: 'From the ABCs, we can see that there are places for a total of three general
    kinds of collections with six implementation choices:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从ABC中，我们可以看到有三类总共有六种实现选择的集合：
- en: 'Set: Its unique feature is that items are either members or not. This means
    duplicates are ignored:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合：它的独特之处在于项要么是成员，要么不是。这意味着重复项被忽略：
- en: 'Mutable set: The built-in set collection'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变集合：内置的 set 集合
- en: 'Immutable set: The built-in frozenset collection'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变集合：内置的 frozenset 集合
- en: 'Sequence: Its unique feature is that items are provided with an index position:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列：其独特之处在于项目提供了索引位置：
- en: 'Mutable sequence: The built-in list collection'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变序列：内置的列表集合
- en: 'Immutable sequence: The built-in tuple collection. This is the subject of some
    recipes in Chapter [1](ch005_split_000.xhtml#x1-170001).'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变序列：内置的 tuple 集合。这是第 [1](ch005_split_000.xhtml#x1-170001) 章中一些菜谱的主题。
- en: 'Mapping: Its unique feature is that each item has a key that refers to a value:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射：其独特之处在于每个项目都有一个键，该键指向一个值：
- en: 'Mutable mapping: The built-in dict collection. This is the subject of Chapter [5](ch009.xhtml#x1-2890005).'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变映射：内置的 dict 集合。这是第 [5](ch009.xhtml#x1-2890005) 章的主题。
- en: 'Immutable mapping: Interestingly, there’s no built-in frozen mapping.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变映射：有趣的是，没有内置的 frozen 映射。
- en: 'Python’s libraries offer additional implementations of these core collection
    types. The collections module include:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的库提供了这些核心集合类型的额外实现。collections 模块包括：
- en: 'namedtuple: A tuple that offers names for each item in a tuple. It’s slightly
    clearer to use rgb_color.red than rgb_color[0].'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: namedtuple：一个元组，为元组中的每个项目提供名称。使用 rgb_color.red 比使用 rgb_color[0] 更清晰。
- en: 'deque: A double-ended queue. It’s a mutable sequence with optimizations for
    pushing and popping from each end. We can do similar things with a list, but deque
    is more efficient when changes at both ends are needed.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: deque：一个双端队列。它是一个可变序列，对从两端推入和弹出进行了优化。我们可以用列表做类似的事情，但当需要两端的变化时，deque 更有效率。
- en: 'defaultdict: A dict that can provide a default value for a missing key.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: defaultdict：一个 dict，可以为缺失的键提供一个默认值。
- en: 'Counter: A dict that is designed to count occurrences of a key. This is sometimes
    called a multiset or a bag.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Counter：一个 dict，设计用来计数键的出现的次数。这有时被称为多重集合或包。
- en: 'ChainMap: A dict that combines several dictionaries into a single mapping.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ChainMap：一个 dict，可以将多个字典组合成一个映射。
- en: Additionally, there’s an older OrderedDict class. This class retains the keys
    in the order in which they were created. Starting with Python 3.7, the dictionary
    keys for an ordinary dictionary are retained in the order they were created, making
    the OrderedDict class redundant.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个较旧的 OrderedDict 类。这个类保留了键的创建顺序。从 Python 3.7 开始，普通字典的键保留了创建顺序，使得 OrderedDict
    类变得冗余。
- en: 4.1.4 There’s more...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1.4 更多...
- en: There’s still more in the Python Standard Library. We can also use the heapq
    module, which defines a kind of list that acts as a high-performance priority
    queue. The bisect module includes methods for searching a sorted list very quickly.
    This lets us create a list object, which can have performance that is a little
    closer to the very fast lookups of a dictionary.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Python 标准库中还有更多。我们还可以使用 heapq 模块，它定义了一种列表，充当高性能优先队列。bisect 模块包括快速搜索排序列表的方法。这使得我们可以创建一个列表对象，其性能可以接近字典的非常快速的查找。
- en: 'We can find descriptions of data structures on summary web pages, like this
    one: [https://thealgorist.com](https://thealgorist.com). We’ll take a quick look
    at four additional families of data structures:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在总结网页上找到数据结构的描述，如这个：[https://thealgorist.com](https://thealgorist.com)。我们将快速查看四个额外的数据结构家族：
- en: 'Arrays: The Python array module supports densely packed arrays of values. The
    numpy module also offers very sophisticated array processing.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组：Python 的 array 模块支持密集填充的值数组。numpy 模块也提供了非常复杂化的数组处理。
- en: 'Trees: Generally, tree structures can be used to create sets, sequential lists,
    or key-value mappings. We can look at a tree as an implementation technique for
    building sets or dictionaries. We often build tree structures using objects and
    class definitions.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树：通常，树结构可以用来创建集合、顺序列表或键值映射。我们可以将树视为构建集合或字典的实现技术。我们通常使用对象和类定义来构建树结构。
- en: 'Hashes: Python uses hashes to implement dictionaries and sets. This leads to
    good speed but potentially large memory consumption.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希：Python 使用哈希来实现字典和集合。这导致速度良好，但可能消耗大量内存。
- en: 'Graphs: Python doesn’t have a built-in graph data structure. However, we can
    easily represent a graph structure with a dictionary where each node has a list
    of adjacent nodes. External libraries like NetworkX, Pyoxigraph, and RDFLib support
    sophisticated graph databases.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图：Python 没有内置的图数据结构。然而，我们可以通过一个字典轻松地表示图结构，其中每个节点都有一个相邻节点的列表。像 NetworkX、Pyoxigraph
    和 RDFLib 这样的外部库支持复杂的图数据库。
- en: 'We can—with a little cleverness—implement almost any kind of data structure
    in Python. While it’s often the case that the built-in structures have the essential
    we may be able to locate a built-in structure that can be pressed into service.
    We’ll look at mappings and dictionaries in Chapter [5](ch009.xhtml#x1-2890005),
    [Built-In Data Structures Part 2: Dictionaries](ch009.xhtml#x1-2890005).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一点巧妙的方法，我们可以在Python中实现几乎任何类型的数据结构。虽然内置结构通常具有基本功能，但我们可能能够找到可以投入使用的内置结构。我们将在第[5](ch009.xhtml#x1-2890005)章[内置数据结构第2部分：字典](ch009.xhtml#x1-2890005)中探讨映射和字典。
- en: 4.1.5 See also
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1.5 参见
- en: For high-performance array processing, see [https://numpy.org](https://numpy.org).
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于高性能数组处理，请参阅[https://numpy.org](https://numpy.org)。
- en: For advanced graph analysis, see [https://networkx.github.io](https://networkx.github.io).
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于高级图分析，请参阅[https://networkx.github.io](https://networkx.github.io)。
- en: For graph manipulation and storage, see [https://pyoxigraph.readthedocs.io/en/stable/](https://pyoxigraph.readthedocs.io/en/stable/).
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于图操作和存储，请参阅[https://pyoxigraph.readthedocs.io/en/stable/](https://pyoxigraph.readthedocs.io/en/stable/)。
- en: For graph manipulation, see [https://rdflib.readthedocs.io/en/stable/](https://rdflib.readthedocs.io/en/stable/).
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于图操作，请参阅[https://rdflib.readthedocs.io/en/stable/](https://rdflib.readthedocs.io/en/stable/)。
- en: 4.2 Building lists – literals, appending, and comprehensions
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.2 构建列表 – 字面量、追加和推导式
- en: If we’ve decided to create a collection based on each item’s position in the
    container—a list—we have several ways of building this structure. We’ll look at
    a number of ways we can assemble a list object from the individual items.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定根据容器中每个项目的位置创建一个集合——列表——我们有几种构建这种结构的方法。我们将探讨从单个项目组装列表对象的各种方法。
- en: In some cases, we’ll need a list because it allows duplicate values, unlike
    a set. This is common in statistical work. A different structure, called a multiset,
    can also be useful for a statistically oriented collection that permits duplicates.
    This collection is available in the standard library as collections.Counter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们需要一个列表，因为它允许重复的值，与集合不同。这在统计工作中很常见。另一种称为多重集的结构，对于允许重复的统计导向集合也很有用。这个集合在标准库中作为collections.Counter提供。
- en: 4.2.1 Getting ready
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2.1 准备工作
- en: 'Let’s say we need to do some statistical analyses of some file sizes. Here’s
    a short script that will provide us with the sizes of some files:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要对一些文件大小进行统计分析。以下是一个简短的脚本，它将为我们提供一些文件的大小：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We’ve used a pathlib.Path object to represent a directory in our filesystem.
    The glob() method expands all names that match a given pattern.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用pathlib.Path对象来表示文件系统中的目录。glob()方法扩展所有与给定模式匹配的名称。
- en: We’d like to accumulate a list object that has the various file sizes. From
    that list, we can compute the total size and average size.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望累积一个包含各种文件大小的列表对象。从该列表中，我们可以计算总大小和平均大小。
- en: 4.2.2 How to do it...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2.2 如何做...
- en: 'We have many ways to create list objects:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有许多创建列表对象的方法：
- en: 'Literal: We can create a literal display of a list using a sequence of values
    surrounded by [] characters. For example, [1, 2, 3]. Python needs to match an
    opening [ and a closing ] to see a complete logical line, so the literal can span
    physical lines. For more information, refer to the [Writing long lines of code](ch006_split_000.xhtml#x1-910002)
    recipe in Chapter [2](ch006_split_000.xhtml#x1-840002).'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字面量：我们可以使用方括号[]字符包围的值序列创建列表的字面量显示。例如，[1, 2, 3]。Python需要匹配一个开方括号[和一个闭方括号]来看到一条完整的逻辑行，因此字面量可以跨越物理行。有关更多信息，请参阅第[2](ch006_split_000.xhtml#x1-840002)章[编写长行代码](ch006_split_000.xhtml#x1-910002)食谱。
- en: 'Conversion function: We can convert some other data collection into a list
    using the list() function.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换函数：我们可以使用list()函数将其他数据集合转换为列表。
- en: 'Append method: We have list methods that allow us to build a list one item
    at a time. These methods include append(), extend(), and insert(). We’ll look
    at the append() method in the [Building a list with the append() method](ch008_split_000.xhtml#x1-2340002)
    section of this recipe.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追加方法：我们有允许我们逐个构建列表的方法。这些方法包括append()、extend()和insert()。我们将在本食谱的[使用append()方法构建列表](ch008_split_000.xhtml#x1-2340002)部分探讨append()方法。
- en: 'Comprehension: A comprehension is a specialized generator expression that computes
    a list from a source object. We’ll look at this in detail in the [Writing a list
    comprehension](ch008_split_000.xhtml#x1-2350002) section of this recipe.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解：理解是一种特殊的生成器表达式，它从源对象计算出一个列表。我们将在本食谱的[编写列表理解](ch008_split_000.xhtml#x1-2350002)部分详细探讨这一点。
- en: The first two ways to create a list are single Python expressions. The last
    two are more complex, and we’ll show recipes for each of them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 创建列表的前两种方法是单个Python表达式。最后两种更复杂，我们将展示每种方法的配方。
- en: Building a list with the append() method
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用append()方法构建列表
- en: 'Create an empty list using literal syntax, [], or the list() function:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用字面语法[]或list()函数创建一个空列表：
- en: '[PRE3]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Iterate through some source of data. Append the items to the list using the
    append() method:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过append()方法遍历一些数据源。将项目添加到列表中：
- en: '[PRE4]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When we print the list, Python displays it in literal notation. This is handy
    if we ever need to copy and paste the list into another script.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印列表时，Python会以字面符号显示它。如果我们需要将列表复制并粘贴到另一个脚本中，这很方便。
- en: It’s very important to note that the append() method does not return a value.
    The append() method mutates the list object, and does not return anything.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要注意，append()方法不返回任何值。append()方法会修改列表对象，并且不返回任何内容。
- en: Writing a list comprehension
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写列表推导式
- en: 'The goal of a list comprehension is to create an object that occupies the syntax
    role of a literal:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式的目标是创建一个对象，它占据字面表达式的语法角色：
- en: Write the wrapping [] brackets that surround the list object to be built.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写出包围要构建的列表对象的[]括号。
- en: 'Write the source of the data. This will include the target variable. Note that
    there’s no : at the end of the for clause because we’re not writing a complete
    statement:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写出数据源。这将包括目标变量。请注意，for子句的末尾没有冒号，因为我们不是在写一个完整的语句：
- en: '[PRE5]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Prefix the for clause with an expression to evaluate to create each value that
    goes into the sequence from the value of target variable. Again, since this is
    only a single expression, we cannot use complex statements here:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在for子句前加上一个表达式来评估，以创建每个值，这些值来自目标变量的值。再次强调，由于这只是一个单一的表达式，我们在这里不能使用复杂语句：
- en: '[PRE6]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here’s an example of list object construction:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个列表对象构建的例子：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we’ve created a list object, we can assign it to a variable and do
    other calculations and summaries on the data.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个列表对象，我们可以将其分配给一个变量，并对数据进行其他计算和总结。
- en: 'The list comprehension is built around a central generator expression, called
    a comprehension in the language manual. The comprehension has two parts: the data
    expression clause and a for clause. The data expression clause is evaluated repeatedly,
    driven by the variables assigned in the for clause.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式是围绕一个中心生成器表达式构建的，在语言手册中称为推导式。推导式有两个部分：数据表达式子句和for子句。数据表达式子句会被反复评估，由for子句中分配的变量驱动。
- en: We can replace the enclosing [ and ] with the list() function. Using the explicit
    list() function had an advantage when we consider the possibility of changing
    the data structure. We can easily replace list() with set() or Counter() to make
    use of the core generator, but creating a distinct collection type.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用list()函数替换包围要构建的列表对象的[]括号。当我们考虑数据结构可能发生变化的可能性时，使用显式的list()函数有一个优点。我们可以轻松地将list()替换为set()或Counter()，以利用核心生成器，同时创建一个不同的集合类型。
- en: 4.2.3 How it works...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2.3 它是如何工作的...
- en: A Python list object has a dynamic size. The size is adjusted when items are
    appended or inserted, or the list is extended with items from another sequence.
    Similarly, the size shrinks when items are popped or deleted.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Python列表对象具有动态大小。当项目被追加或插入，或者列表通过另一个序列的项目扩展时，大小会调整。同样，当项目被弹出或删除时，大小会缩小。
- en: 'In rare cases, we might want to create a list with a given initial size, and
    then set the values of the items separately. We can do this with a list comprehension,
    like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在罕见的情况下，我们可能想要创建一个具有给定初始大小的列表，然后分别设置项目的值。我们可以使用列表推导式来完成这个操作，如下所示：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will create a list with an initial size of 100 items, each of which is
    True. We might need this kind of initialization to implement the [Sieve of Eratosthenes](https://math.libretexts.org/Bookshelves/Combinatorics_and_Discrete_Mathematics/Elementary_Number_Theory_(Raji)/02%3A_Prime_Numbers/2.01%3A_The_Sieve_of_Eratosthenes)
    algorithm:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含100个初始项的列表，每个项都是True。我们可能需要这种初始化来实现埃拉托斯特尼筛法（Sieve of Eratosthenes）算法：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The sieve collection has a sequence of True and False values. The index position
    of each True is a prime number. Multiples of each prime, p, starting with p²,
    are set to False. The prime collection is a sequence of values, p for which the
    expression sieve[p] is True.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 筛选集合包含一系列 True 和 False 值。每个 True 的索引位置是一个素数。从 p² 开始的每个素数 p 的倍数被设置为 False。素数集合是一个值序列，p
    是 sieve[p] 表达式为 True 的素数。
- en: 4.2.4 There’s more...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2.4 更多内容...
- en: 'A common goal for creating a list object is to be able to summarize it. We
    can use a variety of Python functions for this. Here are some examples:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 创建列表对象的一个常见目标是能够总结它。我们可以使用各种 Python 函数来做这件事。以下是一些示例：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We’ve used the built-in sum(), min(), and max() methods to produce some descriptive
    statistics of these document sizes. Which of these index files is the smallest?
    We want to know the position of the minimum in the list of values. We can use
    the index() method for this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了内置的 sum()、min() 和 max() 方法来生成这些文档大小的描述性统计信息。哪个索引文件是最小的？我们想知道值列表中最小值的索引位置。我们可以使用
    index() 方法来做这件事：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We found the minimum, and then used the index() method to locate the position
    of that minimal value.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到了最小值，然后使用 index() 方法定位那个最小值的索引位置。
- en: Other ways to extend a list
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展列表的其他方法
- en: 'We can extend a list object, as well as insert one into the middle or beginning
    of a list. We have two ways to extend a list: we can use the + operator or we
    can use the extend() method. Here’s an example of creating two lists and putting
    them together with the + operator:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展列表对象，也可以将其插入到列表的中间或开头。我们有两种扩展列表的方法：我们可以使用 + 运算符，或者我们可以使用 extend() 方法。以下是一个使用
    + 运算符将两个列表合并的示例：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have created a list of sizes of documents with names like Chapter_03/*.py.
    We then created a second list of sizes of documents with a slightly different
    name pattern, Chapter_04/*.py. We then combined the two lists into a final list.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个包含文档大小的列表，文档名称类似于 Chapter_03/*.py。然后我们创建了一个包含文档大小的第二个列表，其名称模式略有不同，Chapter_04/*.py。然后我们将这两个列表合并成一个最终的列表。
- en: 'We can insert a value prior to any particular position in a list. The insert()
    method accepts the position of an item; the new value will be before the given
    position:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在列表中的任何特定位置之前插入一个值。insert() 方法接受一个项目的位置；新值将在给定位置之前：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We’ve inserted two new values into a list object. As with the append() and extend()
    methods, the insert() method does not return a value. It mutates the list object.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向列表对象中插入了两个新值。与 append() 和 extend() 方法一样，insert() 方法不返回任何值。它修改了列表对象。
- en: 4.2.5 See also
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2.5 参考信息
- en: Refer to the [Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003) recipe
    for ways to copy lists and pick sublists from a list.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考关于[切片和切块列表](ch008_split_000.xhtml#x1-2400003)的配方，了解复制列表和从列表中挑选子列表的方法。
- en: Refer to the [Shrinking lists – deleting, removing, and popping](ch008_split_000.xhtml#x1-2460004)
    recipe for other ways to remove items from a list.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考关于[缩小列表 - 删除、移除和弹出](ch008_split_000.xhtml#x1-2460004)的配方，了解从列表中移除项目的其他方法。
- en: In the [Reversing a copy of a list](ch008_split_001.xhtml#x1-2620006) recipe,
    we’ll look at reversing a list.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[反转列表副本](ch008_split_001.xhtml#x1-2620006)的配方中，我们将查看如何反转列表。
- en: 'This article provides some insights into how Python collections work internally:
    [https://wiki.python.org/moin/TimeComplexity](https://wiki.python.org/moin/TimeComplexity).'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本文提供了一些关于 Python 集合内部工作方式的见解：[https://wiki.python.org/moin/TimeComplexity](https://wiki.python.org/moin/TimeComplexity)。
- en: When looking at the tables, it’s important to note the expression O(1) means
    that the cost is essentially constant. The expression O(n) means the cost grows
    as the size of the collection grows.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在查看表格时，重要的是要注意表达式 O(1) 表示成本基本上是常数。表达式 O(n) 表示成本随着集合大小的增长而增长。
- en: 4.3 Slicing and dicing a list
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.3 切片和切块列表
- en: There are many times when we’ll want to pick items from a list. One of the most
    common kinds of processing is to treat the first item of a list as a special case.
    This leads to a kind of head-tail processing where we treat the head of a list
    differently from the items in the tail of a list.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多次我们想要从列表中挑选项目。最常见的一种处理方式是将列表的第一个项目视为特殊情况。这导致了一种头尾处理方式，其中我们对待列表的头与对待列表尾的项目不同。
- en: We can use these techniques to make a copy of a list too.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些技术来复制列表。
- en: 4.3.1 Getting ready
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3.1 准备工作
- en: 'We have a spreadsheet that was used to record fuel consumption on a large sailboat.
    It has rows that look like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个用于记录大型帆船燃油消耗的电子表格。它的行看起来像这样：
- en: '|'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| date | engine on | fuel height |  |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 日期 | 引擎开启 | 燃料高度 |  |'
- en: '|  | engine off | fuel height |  |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|  | 引擎关闭 | 燃料高度 |  |'
- en: '|  | Other notes |  |  |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '|  | 其他备注 |  |  |'
- en: '|'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 10/25/2013 | 08:24:00 AM | 29 |  |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 10/25/2013 | 08:24:00 AM | 29 |  |'
- en: '|  | 01:15:00 PM | 27 |  |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '|  | 01:15:00 PM | 27 |  |'
- en: '|  | calm seas – anchor solomon’s island |  |  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|  | 平静大海 – 锚定所罗门岛 |  |  |'
- en: '|'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 10/26/2013 | 09:12:00 AM | 27 |  |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 10/26/2013 | 09:12:00 AM | 27 |  |'
- en: '|  | 06:25:00 PM | 22 |  |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '|  | 06:25:00 PM | 22 |  |'
- en: '|  | choppy – anchor in jackson’s creek |  |  |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|  | choppy – 锚定在杰克逊溪 |  |  |'
- en: '|'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  |  |  |  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |'
- en: 'Table 4.1: Example of sailboat fuel use'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1：帆船燃油使用示例
- en: In this dataset, fuel is measured by height. This is because a sight-gauge is
    used, calibrated in inches of depth. For all practical purposes, the tank is rectangular,
    so the depth shown can be converted into volume since we know 31 inches of depth
    is about 75 gallons.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个数据集中，燃料是通过高度来测量的。这是因为使用了深度为英寸的视距计，校准。对于所有实际目的，油箱是矩形的，所以显示的深度可以转换成体积，因为我们知道31英寸的深度大约是75加仑。
- en: 'This example of spreadsheet data is not properly normalized. Ideally, all rows
    follow the First Normal Form for data: a row should have identical content, and
    each cell should have only atomic values. In this data, there are three subtypes
    of row:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个电子表格数据的例子没有正确规范化。理想情况下，所有行都遵循数据的第一范式：一行应该有相同的内容，每个单元格应该只有原子值。在这个数据中，有三种子类型的行：
- en: The first row of a three-row group has engine on date, time, and a measurement.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三行组的第一行包含引擎开启日期、时间和一个测量值。
- en: The second row of a group has engine off time and a measurement.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一组中的第二行包含引擎关闭时间和一个测量值。
- en: The third row has some notes that aren’t too useful.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三行有一些不太有用的备注。
- en: 'This kind of denormalized data includes the following two problems:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这种非规范化数据包括以下两个问题：
- en: The .csv file has four rows of headings. (The fourth row is a blank line that’s
    not shown here in this nicely formatted book.) This is something the csv module
    can’t deal with directly.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .csv文件有四行标题。（第四行是一个空白行，在此格式良好的书中未显示。）这是csv模块无法直接处理的事情。
- en: Each day’s travel is spread across three rows. These rows must be combined to
    make it easier to compute an elapsed time and the number of inches of fuel used.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每天的旅行分布在三行中。这些行必须合并起来，以便更容易计算经过的时间和使用的燃料英寸数。
- en: 'We can read the data with a function defined like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用如下定义的函数来读取数据：
- en: '[PRE14]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We’ve used the csv module to read the log details. The object returned by the
    csv.reader() function is iterable. In order to collect the items into a single
    list, we applied the list() function to the iterable; this creates a list object
    from the reader.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用csv模块读取了日志细节。csv.reader()函数返回的对象是可迭代的。为了将项目收集到一个单独的列表中，我们对可迭代对象应用了list()函数；这从读取器创建了一个列表对象。
- en: 'Each row of the original CSV file is a list. Here’s what the first and last
    rows look like:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 原始CSV文件的每一行都是一个列表。以下是第一行和最后一行的样子：
- en: '[PRE15]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For this recipe, we’ll use an extension of a list index expression to slice
    items from the list of rows. The slice, like an index expression, follows the
    list object in [] characters. Python offers several variations of the slice expression
    so that we can extract useful subsets of the list of rows.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将使用列表索引表达式的扩展来从行列表中切片项。切片，就像索引表达式一样，跟在列表对象后面的[]字符中。Python提供了几种切片表达式的变体，以便我们可以从行列表中提取有用的子集。
- en: 4.3.2 How to do it...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3.2 如何操作...
- en: 'The first thing we need to do is remove the four lines of headings from the
    list of rows. We’ll use two partial slice expressions to divide the list by the
    fourth row:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是从行列表中删除四行标题。我们将使用两个部分切片表达式来通过第四行分割列表：
- en: '[PRE16]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We’ve sliced the list into two sections using log_rows[:4] and log_rows[4:].
    The first slice expression selects the first four lines; this is assigned to the
    head variable. The second slice expression selects rows from 4 to the end of the
    list. This is assigned to the tail variable. These are the rows of the sheet we
    care about.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用log_rows[:4]和log_rows[4:]将列表切分成两部分。第一个切片表达式选择前四行；这被分配给head变量。第二个切片表达式选择从第4行到列表末尾的行。这被分配给tail变量。这是我们关心的表格行。
- en: We’ll use slices with steps to pick the interesting rows. The [start:stop:step]
    version of a slice will pick rows in groups based on the step value. In our case,
    we’ll take two slices. One slice starts on row zero—the “engine on” lines—and
    the other slice starts on row one—the “engine off” lines.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用带有步骤的切片来选择有趣的行。切片的 [start:stop:step] 版本将根据步骤值分组选择行。在我们的例子中，我们将取两个切片。一个切片从行零开始——“引擎开启”行——另一个切片从行一开始——“引擎关闭”行。
- en: 'Here’s a slice of every third row, starting with row zero:'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是每第三行的切片，从行零开始：
- en: '[PRE17]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We’ve used the pprint() function from the pprint module to make the output much
    easier to read.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经使用了来自 pprint 模块的 pprint() 函数来使输出更容易阅读。
- en: 'There’s additional data in every third row, starting with row one:'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从行一开始，每第三行有额外的数据：
- en: '[PRE18]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'These two slices can then be zipped together to create a list of pairs:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个切片然后可以组合在一起以创建一对对的列表：
- en: '[PRE19]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This gives us a sequence that consists of pairs of three tuples. This is very
    close to something we can work with.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这给我们一个由三个元组的对组成的序列。这非常接近我们可以处理的东西。
- en: 'Flatten the results:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展平结果：
- en: '[PRE20]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We’ve used a list comprehension from the [Building lists – literals, appending,
    and comprehensions](ch008_split_000.xhtml#x1-2310002) recipe to combine the two
    elements in each pair of rows to create a single row. This has more properly normalized
    data describing each leg of the voyage.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经使用了一个列表推导式从 [构建列表 – 字面量、追加和推导式](ch008_split_000.xhtml#x1-2310002) 章节中结合每对行的两个元素以创建一个单行。这有更规范化的数据描述每段航程。
- en: From the resulting list, we can now compute the difference in times to get the
    running time for the boat. We can compute the difference in heights to estimate
    the fuel consumed during each leg of the journey. This flat list with five useful
    items—date, time, height, time, and height—has all the needed data in a single
    row. It also has a column that will generally contain an empty string.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果列表中，我们现在可以计算时间差以得到船的运行时间。我们可以计算高度差以估计每段旅程中消耗的燃料。这个包含五个有用项——日期、时间、高度、时间、高度——的单行列表包含了所需的所有数据。它还有一个通常包含空字符串的列。
- en: 4.3.3 How it works...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3.3 它是如何工作的...
- en: 'The slice operator has several different forms:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 切片操作符有几种不同的形式：
- en: '[:]: The start and stop are implied. The expression S[:] will create a copy
    of sequence S.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[:]: 开始和结束是隐含的。表达式 S[:] 将创建序列 S 的一个副本。'
- en: '[:stop]: This makes a new list from the beginning to just before the stop index.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[:stop]: 这将从开始到停止索引之前创建一个新的列表。'
- en: '[start:]: This makes a new list from the given start to the end of the sequence.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[start:]: 这将从给定的开始到序列的末尾创建一个新的列表。'
- en: '[start:stop]: This picks a sublist, starting from the start index and stopping
    just before the stop index. Python works with half-open intervals. The start is
    included, while the stop index is not included.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[start:stop]: 这将选择一个子列表，从起始索引开始，到停止索引之前结束。Python 使用半开区间。起始索引包含在内，而停止索引不包含。'
- en: '[::step]: The start and stop are implied and include the entire sequence. The
    step—generally not equal to one—means we’ll skip through the list from the start
    using the step. For a given step, s, and a list of size |L|, the index values
    are i ∈{s×n∣n ∈ℕ and 0 ≤ s×n < |L|}.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[::step]: 开始和结束是隐含的，包括整个序列。步骤——通常不等于一——意味着我们将使用步骤从开始跳过列表。对于给定的步骤，s，和大小为 |L|
    的列表，索引值是 i ∈{s×n∣n ∈ℕ and 0 ≤ s×n < |L|}。'
- en: '[start::step]: The start is given, but the stop is implied. The idea is that
    the start is an offset, and the step applies to that offset. For a given start,
    a, step, s, and a list of size |L|, the index values are i ∈{s × n + a∣n ∈ℕ and
    0 ≤ s × n + a < |L|}.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[start::step]: 起始是给定的，但停止是隐含的。想法是起始是一个偏移量，步骤应用于该偏移量。对于给定的起始，a，步骤，s，和大小为 |L|
    的列表，索引值是 i ∈{s × n + a∣n ∈ℕ and 0 ≤ s × n + a < |L|}。'
- en: '[:stop:step]: This is used to prevent processing the last few items in a list.
    Since the step is given, processing begins with element zero.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[:stop:step]: 这用于防止处理列表中的最后几个元素。由于给出了步骤，处理从元素零开始。'
- en: '[start:stop:step]: This will pick elements from a subset of the sequence. Items
    prior to start and from stop to the end will not be used.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[start:stop:step]: 这将从序列的子集中选择元素。在起始索引之前和从停止索引到结束的元素将不会使用。'
- en: The slicing technique works for lists, tuples, strings, and any other kind of
    sequence. Slicing does not cause the collection to be mutated; rather, slicing
    will make a copy of some part of the sequence. The items within the source collection
    are now shared between collections.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 切片技术适用于列表、元组、字符串以及任何其他类型的序列。切片不会导致集合被修改；相反，切片将序列的一部分制作成副本。现在，源集合中的项在集合之间共享。
- en: 4.3.4 There’s more...
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3.4 更多...
- en: In the [Reversing a copy of a list](ch008_split_001.xhtml#x1-2620006) recipe,
    we’ll look at an even more sophisticated use of slice expressions.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在[反转列表副本](ch008_split_001.xhtml#x1-2620006)的菜谱中，我们将探讨切片表达式的一种更复杂的使用方法。
- en: The copy of a sequence is called a shallow copy because there will be two collections
    that each contain references to the same underlying objects. We’ll look at this
    in detail in the [Making shallow and deep copies of objects](ch009.xhtml#x1-3160005)
    recipe.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 序列的副本被称为浅拷贝，因为将会有两个集合，每个集合都包含对相同底层对象的引用。我们将在[制作浅拷贝和深拷贝的对象](ch009.xhtml#x1-3160005)的菜谱中详细探讨这一点。
- en: 'For this specific example, we have another way of restructuring multiple rows
    of data into single rows of data: we can use a generator function. We’ll look
    at functional programming techniques online in Chapter [9](ch013_split_000.xhtml#x1-5020009).'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的例子，我们还有另一种将多行数据重新结构化为单行数据的方法：我们可以使用生成器函数。我们将在第[9](ch013_split_000.xhtml#x1-5020009)章中在线查看函数式编程技术。
- en: 4.3.5 See also
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3.5 参考信息
- en: Refer to the [Building lists – literals, appending, and comprehensions](ch008_split_000.xhtml#x1-2310002)
    recipe for ways to create lists.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[构建列表 - 字面量、追加和推导](ch008_split_000.xhtml#x1-2310002)的菜谱，了解创建列表的方法。
- en: Refer to the [Shrinking lists – deleting, removing, and popping](ch008_split_000.xhtml#x1-2460004)
    recipe for other ways to remove items from a list.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[缩小列表 - 删除、移除和弹出](ch008_split_000.xhtml#x1-2460004)的菜谱，了解从列表中删除项的其他方法。
- en: In the [Reversing a copy of a list](ch008_split_001.xhtml#x1-2620006) recipe,
    we’ll look at reversing a list.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[反转列表副本](ch008_split_001.xhtml#x1-2620006)的菜谱中，我们将探讨如何反转列表。
- en: The [pandas](https://pandas.pydata.org) package offers some additional ways
    to work with CSV files.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pandas](https://pandas.pydata.org) 包提供了一些与 CSV 文件一起工作的额外方法。'
- en: 4.4 Shrinking lists – deleting, removing, and popping
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.4 缩小列表 - 删除、移除和弹出
- en: There will be many times when we’ll want to remove items from a list collection.
    We might delete items from a list, and then process the items that are left over.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多次我们想要从列表集合中删除项。我们可能从列表中删除项，然后处理剩下的项。
- en: Removing unneeded items has a similar effect to using filter() to create a copy
    that has only the needed items. The distinction is that a filtered copy will use
    more memory than deleting items from a list. We’ll show both techniques for removing
    unwanted items from a mutable list.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 移除不需要的项与使用 filter() 创建只包含所需项的副本的效果相似。区别在于，过滤后的副本将比从列表中删除项使用更多的内存。我们将展示两种从可变列表中删除不需要项的技术。
- en: 4.4.1 Getting ready
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4.1 准备工作
- en: We have a spreadsheet that is used to record fuel consumption on a large sailboat.
    See Table [4.1](ch008_split_000.xhtml#x1-241001r1) for the data.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个用于记录大型帆船燃油消耗的电子表格。请参阅表[4.1](ch008_split_000.xhtml#x1-241001r1)中的数据。
- en: For more background on this data, refer to the [Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003)
    recipe earlier in this chapter. The get_fuel_use() function will collect the raw
    data. It’s important to note that the structure of this data—each fact spread
    among three separate rows—is perfectly awful and requires considerable care to
    reconstruct something more useful.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此数据的更多背景信息，请参考本章前面的[切片和切块列表](ch008_split_000.xhtml#x1-2400003)菜谱。get_fuel_use()
    函数将收集原始数据。需要注意的是，此数据的结构——每个事实分布在三个单独的行中——非常糟糕，需要相当多的注意来重建更有用的东西。
- en: Each row of the original CSV file is a list. Each of those lists contains three
    items. It’s essential to remove some rows with titles and uninformative data.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 原始 CSV 文件的每一行都是一个列表。这些列表中的每一个都包含三个项。删除包含标题和无用数据的某些行是至关重要的。
- en: 4.4.2 How to do it...
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4.2 如何操作...
- en: 'We’ll look at several ways to remove items from a list:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨几种从列表中删除项的方法：
- en: The del statement.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: del 语句。
- en: The remove() method.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: remove() 方法。
- en: The pop() method.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pop() 方法。
- en: We can also replace items in a list using slice assignment.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以使用切片赋值来替换列表中的项。
- en: The del statement
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: del 语句
- en: 'We can remove items from a list using the del statement. We can provide an
    object and a slice to remove a group of rows from the list object. Here’s how
    the del statement looks:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用del语句从列表中删除项目。我们可以提供一个对象和一个切片来从列表对象中删除一组行。以下是del语句的示例：
- en: '[PRE21]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The del statement removed the first four rows, leaving behind the rows that
    we really need to process. We can then combine these rows and summarize them using
    the [Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003) recipe.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: del语句删除了前四行，留下了我们真正需要处理的行。然后我们可以将这些行组合起来，使用[Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003)配方进行总结。
- en: The remove() method
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: remove()方法
- en: We can remove items from a list using the remove() method. Given a specific
    value, this removes matching items from a list.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用remove()方法从列表中删除项目。给定一个特定的值，它会从列表中删除匹配的项目。
- en: 'We might have a list that looks like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能有一个看起来像这样的列表：
- en: '[PRE22]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can remove the useless ’’ item from the list:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以删除列表中的无用“”项目：
- en: '[PRE23]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that the remove() method does not return a value. It mutates the list in
    place.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到remove()方法不返回值。它会在原地修改列表。
- en: 'As noted in the [Building lists – literals, appending, and comprehensions](ch008_split_000.xhtml#x1-2310002)
    recipe, the following code is incorrect:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如[构建列表 – 字面量、追加和推导](ch008_split_000.xhtml#x1-2310002)配方中所述，以下代码是不正确的：
- en: '[PRE24]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is emphatically wrong. This will set a to None.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是错误的。这将使a变为None。
- en: The pop() method
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pop()方法
- en: We can remove items from a list using the pop() method. This removes items from
    a list based on their index.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用pop()方法从列表中删除项目。这是基于它们的索引从列表中删除项目。
- en: 'We might have a list that looks like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能有一个看起来像这样的列表：
- en: '[PRE25]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This has a useless ’’ string in it. We can find the index of the item to pop
    and then remove it. The code for this has been broken down into separate steps
    in the following example:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含了一个无用的“”字符串。我们可以找到要弹出项目的索引，然后删除它。以下示例将此代码分解为几个独立的步骤：
- en: '[PRE26]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that the pop() method does two things:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到pop()方法做了两件事：
- en: It mutates the list object to remove an item.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过修改列表对象来删除一个项目。
- en: It also returns the item that was removed.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还返回了被删除的项目。
- en: This combination of mutation and returning a value is rare, making this method
    distinctive.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这种修改和返回值的组合很少见，使得这种方法独特。
- en: Slice assignment
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切片赋值
- en: We can replace items in a list by using a slice expression on the left-hand
    side of the assignment statement. This lets us replace items in a list. When the
    replacement is a different size, it lets us expand or contract a list. This leads
    to a technique for removing items from a list using slice assignment.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在赋值语句的左侧使用切片表达式来替换列表中的项目。这让我们可以替换列表中的项目。当替换的大小不同时，它允许我们扩展或收缩列表。这导致了一种使用切片赋值从列表中删除项目的技术。
- en: 'We’ll start with a row that has an empty value in position 3\. This looks like
    this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从位置3有一个空值的行开始。这看起来像这样：
- en: '[PRE27]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can assign an empty list to the slice that starts at index position 3 and
    ends just before index position 4\. This will replace a one-item slice with a
    zero-item slice, removing the item from the list:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一个空列表赋给从索引位置3开始到索引位置4之前的切片。这将用一个零项切片替换一个单项切片，从而从列表中删除该项目：
- en: '[PRE28]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The del statement and methods like remove() and pop() seem to clearly state
    the intent to eliminate an item from the collection. The slice assignment can
    be less clear because it doesn’t have an obvious method name. It does work well,
    however, for removing a number of items that can be described by a slice expression.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: del语句和remove()、pop()等方法似乎清楚地表明了从集合中删除项目的意图。切片赋值可能不太明确，因为它没有明显的函数名。然而，它确实可以很好地用于删除可以用切片表达式描述的一组项目。
- en: 4.4.3 How it works...
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4.3 它是如何工作的...
- en: Because a list is a mutable object, we can remove items from the list. This
    technique doesn’t work for tuples or strings, because they are immutable.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 因为列表是一个可变对象，所以我们可以从列表中删除项目。这种技术不适用于元组或字符串，因为它们是不可变的。
- en: We can only remove items with an index that’s present in the list. If we attempt
    to remove an item with an index outside the allowed range, we’ll get an IndexError
    exception.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能删除列表中存在的索引的项目。如果我们尝试删除索引超出允许范围的项，我们将得到IndexError异常。
- en: 'The following example tries to delete an item with an index of three from a
    list where the index values are zero, one, and two:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例尝试从一个索引值为零、一和二的列表中删除索引为三的项目：
- en: '[PRE29]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 4.4.4 There’s more...
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4.4 更多内容...
- en: There are a few places in Python where deleting from a list object may become
    complicated. If we use a list object in a for statement, we can’t delete items
    from the list. Doing so will lead to unexpected conflicts between the iteration
    control and the underlying object’s internal state.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的几个地方，从列表对象中删除可能会变得复杂。如果我们在一个for语句中使用列表对象，我们无法从列表中删除项。这样做会导致迭代控制与底层对象的内部状态之间出现意外的冲突。
- en: 'Let’s say we want to remove all even items from a list. Here’s an example that
    does not work properly:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要从列表中删除所有偶数项。以下是一个不正确工作的示例：
- en: '[PRE30]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The source list had several even values. The result is clearly not correct;
    the values of 10 and 36 remained in the list. Why are some even-valued items left
    in the list?
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 源列表有几个偶数值。结果是明显不正确的；10和36的值仍然在列表中。为什么有些偶数值项被留在列表中？
- en: Let’s look at what happens when processing data_items[5]; it has a value of
    8\. When the remove(8) method is evaluated, the value will be removed, and all
    the subsequent values will slide forward one position in the list. The 10 value
    will be moved into position 5, the position formerly occupied by the 8 value.
    The iterator control value will advance to the next position, which will have
    13 in it. The 10 value will never be processed.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看处理data_items[5]时会发生什么；它的值为8。当remove(8)方法被评估时，该值将被移除，列表中的所有后续值都将向前滑动一个位置。10值将移动到5的位置，即8值之前的位置。迭代控制值将前进到下一个位置，该位置将包含13。10值将不会被处理。
- en: 'We have several ways to avoid the skip-when-delete problem:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方法可以避免删除时跳过的问题：
- en: 'Make a copy of the list:'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作列表的副本：
- en: '[PRE31]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Use a while statement and maintain the index value explicitly:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用while语句并显式维护索引值：
- en: '[PRE32]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We’ve designed a while statement to only increment the position variable if
    the value of data_items[position] is odd. If the value is even, then the value
    is removed, which also means the other items are moved forward one position in
    the list; it’s essential the value of the position variable is left unchanged.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们设计了一个while语句，只有当data_items[position]的值为奇数时才增加位置变量。如果值为偶数，则该值将被移除，这也意味着列表中的其他项将向前移动一个位置；保持位置变量的值不变是至关重要的。
- en: We can also traverse the list in reverse order. The expression range(len(row)-1, -1, -1)
    will produce index descending from -1\. This works because negative index values
    work forward from the end of the list. The value row[-1] is the last item.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也可以以相反的顺序遍历列表。表达式range(len(row)-1, -1, -1)将产生从-1开始的递减索引。这是因为负索引值从列表的末尾向前工作。row[-1]是最后一个项。
- en: 4.4.5 See also
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4.5 参见
- en: Refer to the [Building lists – literals, appending, and comprehensions](ch008_split_000.xhtml#x1-2310002)
    recipe for ways to create lists.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[构建列表 - 字面量、追加和推导](ch008_split_000.xhtml#x1-2310002)配方，了解创建列表的方法。
- en: Refer to the [Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003) recipe
    for ways to copy lists and pick sublists from a list.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[切片和切块列表](ch008_split_000.xhtml#x1-2400003)配方，了解复制列表和从列表中选取子列表的方法。
- en: In the [Reversing a copy of a list](ch008_split_001.xhtml#x1-2620006) recipe,
    we’ll look at reversing a list.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[反转列表副本](ch008_split_001.xhtml#x1-2620006)配方中，我们将查看如何反转列表。
- en: 4.5 Writing list-related type hints
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.5 编写与列表相关的类型提示
- en: The typing module provides a few essential type definitions for describing the
    contents of a list object. The primary type definition is list, which we can parameterize
    with the types of items in the list. It often looks like list[int].
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: typing模块提供了一些描述列表对象内容的必要类型定义。主要类型定义是list，我们可以用列表中项的类型来参数化它。它通常看起来像list[int]。
- en: 4.5.1 Getting ready
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5.1 准备工作
- en: 'We’ll look at a list that has two kinds of tuples. Some tuples are simple RGB
    colors. Other tuples are RGB colors that are the result of some computations.
    These are built from float values instead of integers. We might have a heterogenous
    list structure that looks like this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看一个包含两种类型的元组的列表。一些元组是简单的RGB颜色。其他元组是某些计算结果的RGB颜色。这些是从浮点值而不是整数构建的。我们可能有一个类似这样的异构列表结构：
- en: '[PRE33]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Each item in the list is a two-tuple with a color name, and a tuple of RGB values.
    The RGB values are represented as a three-tuple of either integer or float values.
    This is potentially difficult to describe with type hints.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每一项都是一个包含颜色名称和RGB值元组的二元组。RGB值表示为整数或浮点值的三个元组。这可能会难以用类型提示来描述。
- en: We have two related functions that work with this data. The first creates a
    color code from RGB values.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个与此数据相关的函数。第一个从RGB值创建颜色代码。
- en: The essential rule is to treat each component, red, green, or blue, as an 8-bit
    number, a value between 0 and 255\. These three are combined by shifting the red
    value by 16 bits and shifting the green value by 8 bits. The Python << operator
    does the necessary bit shifting. The | operator performs an “or” operation, combining
    the shifted bits to create a new integer value.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的规则是将每个组件（红色、绿色或蓝色）视为一个8位数字，一个介于0到255之间的值。这三个值通过将红色值左移16位和绿色值左移8位来组合。Python的<<运算符执行必要的位移动。|运算符执行“或”操作，将移动的位组合成一个新的整数值。
- en: 'The hints for this function aren’t very complicated:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的类型提示并不复杂：
- en: '[PRE34]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The :06X format specification produces a 6-position hexadecimal value.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: :06X格式规范产生一个6位的十六进制值。
- en: An alternative is to treat each color as a separate pair of hex digits with
    an expression like f"#{int(r):02X}{int(g):02X}{int(b):02X}". This uses three copies
    of the :02X format specification to produce 2-position hexadecimal values for
    each color component.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用表达式f"#{int(r):02X}{int(g):02X}{int(b):02X}"将每个颜色视为一个单独的十六进制数字对。这使用了三个:02X格式规范来为每个颜色组件产生2位的十六进制值。
- en: 'When we use this function to create a color string from an RGB number, it looks
    like this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用这个函数从RGB数字创建颜色字符串时，它看起来像这样：
- en: '[PRE35]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The other function, however, is potentially confusing. This function transforms
    a complex list of colors into another list with the hexadecimal color codes:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，另一个函数可能有些令人困惑。这个函数将一个复杂的颜色列表转换成另一个包含十六进制颜色代码的列表：
- en: '[PRE36]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We need to add type hints to be sure this function properly transforms a list
    of colors from numeric form into string code form.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加类型提示以确保这个函数正确地将颜色列表从数字形式转换为字符串代码形式。
- en: We’ve included a _0 suffix on the function name to distinguish it from the examples
    that follow. This is not a best practice in general, but we find it helps clarify
    the code presented in a book like this.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数名上添加了一个 _0 后缀来区分它和随后的示例。这并不是最佳实践，但我们发现它有助于澄清像这本书中展示的代码：
- en: 4.5.2 How to do it...
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5.2 如何做...
- en: 'We’ll start by adding type hints to describe the individual items of the input
    list, exemplified by the scheme variable, shown previously:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过添加类型提示来描述输入列表的各个项目，例如之前显示的scheme变量：
- en: 'Define the resulting type first. It often helps to focus on the outcomes and
    work backward toward the source data required to produce the expected results.
    In this case, the result is a list of two-tuples with the color name and the hexadecimal
    code for the color. We could describe this as list[tuple[str, str]], but that
    kind of summary hides some important details. We prefer to expose the details
    as follows:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先定义结果类型。通常，关注结果并从源数据回溯到产生预期结果所需的数据是有帮助的。在这种情况下，结果是包含颜色名称和颜色十六进制代码的两个元组的列表。我们可以将其描述为list[tuple[str,
    str]]，但这种总结隐藏了一些重要的细节。我们更喜欢以下方式暴露这些细节：
- en: '[PRE37]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This list can be seen as being homogeneous; each item will match the ColorCode
    type definition.
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个列表可以看作是同质的；每个项目都将匹配ColorCode类型定义。
- en: 'Define the source type. In this case, we have two slightly different kinds
    of color definitions. While they tend to overlap, they have different origins,
    and the processing history is sometimes helpful as part of a type hint:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义源类型。在这种情况下，我们有两种稍微不同的颜色定义类型。虽然它们往往重叠，但它们的起源不同，处理历史有时有助于作为类型提示的一部分：
- en: '[PRE38]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We’ve defined the two integer-based RGB three-tuple as RGB_I, and the float-based
    RGB three-tuple as RGB_F. These two alternative types are combined into the ColorRGB
    tuple definition. This is a two-tuple; the second element may be an instance of
    either the RGB_I type or the RGB_F type. The presence of a Union type means that
    this list is heterogenous.
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们定义了基于整数的RGB三元组为RGB_I，基于浮点数的RGB三元组为RGB_F。这两种替代类型组合成ColorRGB元组定义。这是一个二元组；第二个元素可以是RGB_I类型或RGB_F类型的实例。存在联合类型意味着这个列表是异构的。
- en: We could also use RGB_I | RGB_F instead of Union[RGB_I, RGB_F].
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们也可以使用RGB_I | RGB_F代替Union[RGB_I, RGB_F]。
- en: 'Update the function to include the type hints. The input will be a list like
    the schema object, shown previously. The result will be a list that matches the
    ColorCodeList type description:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新函数以包含类型提示。输入将是一个类似于之前显示的模式对象的列表。结果将是一个与ColorCodeList类型描述相匹配的列表：
- en: '[PRE39]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 4.5.3 How it works...
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5.3 它是如何工作的...
- en: The list[T] type hint requires a single value, T, to describe all of the object
    types that can be part of this list. For homogeneous lists, the type is stated
    directly. For heterogeneous lists, a Union must be used to define the various
    kinds of types that may be present.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: list[T] 类型提示需要一个单一值 T 来描述可以成为此列表一部分的所有对象类型。对于同质列表，类型是直接声明的。对于异构列表，必须使用 Union
    来定义可能存在的各种类型。
- en: 'The approach we’ve taken breaks type hinting down into two layers:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采取的方法将类型提示分解为两层：
- en: 'A ”foundation” layer that describes the individual items in a collection. We’ve
    defined three types of primitive items: the RGB_I and RGB_F types, as well as
    the resulting ColorCode type.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个描述集合中单个项目的“基础”层。我们定义了三种原始项目类型：RGB_I 和 RGB_F 类型，以及由此产生的 ColorCode 类型。
- en: A number of ”composition” layers that combine foundational types into descriptions
    of composite objects. In this case, ColorRGB, ColorRGBList, and ColorCodeList
    are all composite type definitions.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个“组合”层，将基础类型组合成复合对象的描述。在这种情况下，ColorRGB、ColorRGBList 和 ColorCodeList 都是复合类型定义。
- en: Once the types have been named, then the names are used with definition functions,
    classes, and methods.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦命名了类型，然后使用定义函数、类和方法使用这些名称。
- en: 'It’s important to define types in stages to avoid long, complex type hints
    that don’t provide any useful insight into the objects being processed. It’s good
    to avoid type descriptions like this:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在阶段定义类型很重要，以避免长而复杂的类型提示，这些类型提示不会提供任何关于正在处理的对象的有用见解。避免像这样的类型描述是好的：
- en: '[PRE40]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: While this is technically correct, it’s difficult to understand because of its
    complexity. It helps to decompose complex types into useful component descriptions.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这在技术上正确，但由于其复杂性，难以理解。将复杂类型分解成有用的组件描述有助于理解。
- en: 4.5.4 There’s more...
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5.4 更多...
- en: The type hints assume a single type for each item in the list. The syntax list[T]
    states that all items are of type T.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示假设列表中的每个项目都是单一类型。语法 list[T] 表示所有项目都是类型 T。
- en: In the case of a heterogeneous list, with a number of distinct types, we need
    to define a union of types. We can import the Union type from the typing module.
    Or we can use | to provide the alternative types for a list.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在异构列表的情况下，具有多个不同类型，我们需要定义类型的联合。我们可以从 typing 模块导入 Union 类型。或者我们可以使用 | 来为列表提供替代类型。
- en: Using a construct like list[RGB_I | RGB_F] describes a list that contains items
    with a mixture of types.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似 list[RGB_I | RGB_F] 的结构描述了一个包含混合类型项目的列表。
- en: 4.5.5 See also
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5.5 参见
- en: In Chapter [1](ch005_split_000.xhtml#x1-170001), the [Using NamedTuples to simplify
    item access in tuples](ch005_split_001.xhtml#x1-7500010) recipe provides some
    alternative ways to clarify types hints for tuples.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 [1](ch005_split_000.xhtml#x1-170001) 章，[使用 NamedTuples 简化元组中的项目访问](ch005_split_001.xhtml#x1-7500010)的配方提供了一些澄清元组类型提示的替代方法。
- en: The [Writing set-related type hints](ch008_split_001.xhtml#x1-2800009) recipe
    covers this from the view of set types.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[编写与集合相关的类型提示](ch008_split_001.xhtml#x1-2800009)的配方从集合类型的视角涵盖了这一点。'
- en: 4.6 Reversing a copy of a list
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.6 反转列表的副本
- en: Some algorithms produce results in a reversed order. It’s common to collect
    the output in a list and then reverse the list. As an example, we’ll look at the
    way numbers converted into a specific base are often generated from least-significant
    to most-significant digit. We generally want to display the values with the most-significant
    digit first. This leads to a need to reverse the sequence of digits in a list.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 一些算法以相反的顺序产生结果。通常会在列表中收集输出，然后反转列表。作为一个例子，我们将查看将数字转换为特定基数时通常是从最低有效位到最高有效位生成的。我们通常希望以最高有效位首先显示值。这导致需要反转列表中数字的顺序。
- en: 4.6.1 Getting ready
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6.1 准备工作
- en: Let’s say we’re doing a conversion among number bases. We’ll look at how a number
    is represented in a base, and how we can compute that representation from a number.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在进行基数之间的转换。我们将查看一个数字在基数中的表示方式，以及如何从数字计算该表示。
- en: Any value, v, can be defined as a polynomial function of the various digits,
    d[n], in a given base, b. A four-digit number would have ⟨d[3],d[2],d[1],d[0]⟩
    as the sequence of digits.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 任何值 v 都可以定义为给定基数 b 中各种数字 d[n] 的多项式函数。一个四位数将具有 ⟨d[3]，d[2]，d[1]，d[0]⟩ 作为数字序列。
- en: Note that the order we’re using here is reversed from the usual order of items
    in a Python list.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里使用的顺序与 Python 列表中项目的通常顺序相反。
- en: 'The value, v, of this sequence of digits is given by the following polynomial:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这个由数字组成的序列的值 v 由以下多项式给出：
- en: '![v = dn × bn + dn−1 × bn− 1 + dn− 2 × bn−2 + ⋅⋅⋅+ d1 × b+ d0 ](img/file48.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![v = dn × bn + dn−1 × bn− 1 + dn− 2 × bn−2 + ⋅⋅⋅+ d1 × b+ d0 ](img/file48.png)'
- en: 'For example, the hexadecimal number 0xBEEF has the following digits: ⟨B = 11,E
    = 14,E = 14,F = 15⟩, with base b = 16:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，十六进制数 0xBEEF 有以下数字：⟨B = 11,E = 14,E = 14,F = 15⟩，基数 b = 16：
- en: '![48879 = 11 × 163 + 14 × 162 + 14× 16 + 15 ](img/file49.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![48879 = 11 × 163 + 14 × 162 + 14× 16 + 15 ](img/file49.png)'
- en: There are many cases where the base isn’t a consistent power of some number.
    The ISO date format, for example, has a mixed base that involves 7 days per week,
    24 hours per day, 60 minutes per hour, and 60 seconds per minute.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况下基数不是某个数的连续幂。例如，ISO 日期格式有一个混合基数，涉及每周 7 天，每天 24 小时，每小时 60 分钟，每分钟 60 秒。
- en: Instead of b⁴, b³, b², b¹ = b, and b⁰ = 1, we have 7 × 24 × 60 × 60, 24 × 60
    × 60, 60 × 60, and 60 as the various values used to compute the polynomial.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是 b⁴, b³, b², b¹ = b, 和 b⁰ = 1，我们有 7 × 24 × 60 × 60, 24 × 60 × 60, 60 × 60,
    和 60 作为计算多项式的各种值。
- en: 'Given a week number, a day of the week, an hour, a minute, and a second, we
    can compute a timestamp of seconds, t[s], within the given year:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个周数，一周中的某一天，一个小时，一个分钟和一个秒，我们可以在给定的年份内计算秒数时间戳 t[s]：
- en: '![ts = (((w × 7 + d)× 24 + h)× 60 + m )× 60 + s ](img/file50.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![ts = (((w × 7 + d)× 24 + h)× 60 + m )× 60 + s ](img/file50.png)'
- en: 'For example:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE41]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This shows how we convert from the given moment into a timestamp. How do we
    invert this calculation? How do we get the various fields from the overall timestamp?
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了如何将给定的时间点转换为时间戳。我们如何反转这个计算？我们如何从整体时间戳中获取各个字段？
- en: We’ll need to use divmod style division. For some background, refer to the [Choosing
    between true division and floor division](ch005_split_000.xhtml#x1-270002) recipe.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用 divmod 风格的除法。有关背景信息，请参阅[在真除法和取整除法之间选择](ch005_split_000.xhtml#x1-270002)配方。
- en: 'The algorithm for converting a timestamp in seconds, t[s], into individual
    week, day, and time fields looks like this:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 将秒数时间戳 t[s] 转换为单独的周、天和时间字段的算法如下：
- en: '| t[m]; s | = ⌊![ts- 60](img/file51.png)⌋; t[s] mod 60 |  |  |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| t[m]; s | = ⌊![ts- 60](img/file51.png)⌋; t[s] mod 60 |  |  |'
- en: '| t[h]; m | = ⌊![tm- 60](img/file52.png)⌋; t[m] mod 60 |  |  |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| t[h]; m | = ⌊![tm- 60](img/file52.png)⌋; t[m] mod 60 |  |  |'
- en: '| t[d]; h | = ⌊![th24](img/file53.png)⌋; t[h] mod 24 |  |  |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| t[d]; h | = ⌊![th24](img/file53.png)⌋; t[h] mod 24 |  |  |'
- en: '| w; d | = ⌊![td7-](img/file54.png)⌋; t[d] mod 7 |  |  |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| w; d | = ⌊![td7-](img/file54.png)⌋; t[d] mod 7 |  |  |'
- en: 'This has a handy pattern that leads to an implementation. It has the consequence
    of producing the values in reverse order:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个实用的模式，导致实现。它产生值的顺序是相反的：
- en: '[PRE42]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We’ve applied the divmod() function four times to extract seconds, minutes,
    hours, days, and weeks from a timestamp, given in seconds. These are in the wrong
    order. How can we reverse them?
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经四次应用了 divmod() 函数，从以秒为单位的时间戳中提取秒、分钟、小时、天和周。它们的顺序是错误的。我们如何将它们反转？
- en: 4.6.2 How to do it...
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6.2 如何做到这一点...
- en: 'We have three approaches: we can use the reverse() method, we can use a [::-1]
    slice expression, or we can use the reversed() built-in function. Here’s the reverse()
    method:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三种方法：我们可以使用 reverse() 方法，我们可以使用 [::-1] 切片表达式，或者我们可以使用 reversed() 内置函数。以下是
    reverse() 方法：
- en: '[PRE43]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We made a copy of the original list so that we could keep an unmutated copy
    to compare with the mutated copy. This makes it easier to follow the examples.
    We applied the reverse() method to reverse a copy of the list.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了原始列表的副本，这样我们就可以保留一个未修改的副本以与修改后的副本进行比较。这使得跟踪示例变得更容易。我们应用了 reverse() 方法来反转列表的副本。
- en: This will mutate the list. As with other mutating methods, it does not return
    a useful value. It’s incorrect to use a statement like a = b.reverse(); the value
    of a will always be None.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这将修改列表。与其他修改方法一样，它不会返回一个有用的值。使用像 a = b.reverse(); 这样的语句是不正确的，a 的值始终是 None。
- en: 'Here’s a slice expression with a negative step:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个带有负步长的切片表达式：
- en: '[PRE44]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this example, we made a slice [::-1] that uses an implied start and stop,
    and a step of -1\. This picks all the items in the list in reverse order to create
    a new list.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个使用隐含的起始和结束位置以及步长为 -1 的切片 [::-1]。这以相反的顺序选择列表中的所有项以创建一个新的列表。
- en: The original list is emphatically not mutated by this slice operation. This
    creates a copy. Check the value of the fields variable to see that it’s unchanged.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 原始列表在切片操作中明确没有被修改。这创建了一个副本。检查 fields 变量的值以确认它没有改变。
- en: 'Here’s how we can use the reversed() function to create a reversed copy of
    a list of values:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何使用 reversed() 函数来创建一个值的列表的反向副本：
- en: '[PRE45]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: It’s important to use the list() function in this example. The reversed() function
    is a generator, and we need to consume the items from the generator to create
    a new list.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，使用list()函数很重要。reversed()函数是一个生成器，我们需要消耗生成器中的项来创建一个新的列表。
- en: 4.6.3 How it works...
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6.3 工作原理...
- en: As we noted in the [Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003)
    recipe, the slice notation is quite sophisticated. Using a slice with a negative
    step size will create a copy (or a subset) with items processed in right to left
    order, instead of the default left to right order.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[切片和切块列表](ch008_split_000.xhtml#x1-2400003)配方中提到的，切片符号相当复杂。使用具有负步长的切片将按从右到左的顺序创建一个副本（或子集），而不是默认的从左到右的顺序。
- en: 'It’s important to distinguish between these three methods:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 很重要要区分这三种方法：
- en: The reverse() method modifies the list object itself. As with methods like append()
    and remove(), there is no return value from this method. Because it changes the
    list, it doesn’t return a value.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: reverse()方法修改列表对象本身。与append()和remove()等方法一样，此方法没有返回值。因为它改变了列表，所以它不返回值。
- en: The [::-1] slice expression creates a new list. This is a shallow copy of the
    original list, with the order reversed.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[::-1]切片表达式创建了一个新的列表。这是原始列表的浅拷贝，顺序被反转。'
- en: The reversed() function is a generator that yields the values in reverse order.
    When the values are consumed by the list() function, it creates a copy of the
    list.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: reversed()函数是一个生成器，它以相反的顺序产生值。当值被list()函数消耗时，它创建列表的副本。
- en: 4.6.4 See also
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6.4 相关内容
- en: Refer to the [Making shallow and deep copies of objects](ch009.xhtml#x1-3160005)
    recipe for more information on what a shallow copy is and why we might want to
    make a deep copy.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[制作浅拷贝和深拷贝的对象](ch009.xhtml#x1-3160005)配方以获取有关浅拷贝是什么以及为什么我们可能想要制作深拷贝的更多信息。
- en: Refer to the [Building lists – literals, appending, and comprehensions](ch008_split_000.xhtml#x1-2310002)
    recipe for ways to create lists.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[构建列表 - 字面量、追加和推导式](ch008_split_000.xhtml#x1-2310002)配方了解创建列表的方法。
- en: Refer to the [Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003) recipe
    for ways to copy lists and pick sublists from a list.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[切片和切块列表](ch008_split_000.xhtml#x1-2400003)配方了解复制列表和从列表中选取子列表的方法。
- en: Refer to the [Shrinking lists – deleting, removing, and popping](ch008_split_000.xhtml#x1-2460004)
    recipe for other ways to remove items from a list.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[缩小列表 - 删除、移除和弹出](ch008_split_000.xhtml#x1-2460004)配方了解从列表中删除项的其他方法。
- en: 4.7 Building sets – literals, adding, comprehensions, and operators
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.7 构建集合 - 字面量、添加、推导式和运算符
- en: If we’ve decided to create a collection based on only an item being present—a
    set—we have several ways of building this structure. Because of the narrow focus
    of sets, there’s no ordering to the items—no relative positions—and items cannot
    be duplicated. We’ll look at a number of ways we can assemble a set collection
    from a source of individual items.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定仅基于一个项的存在来创建一个集合（即集合），我们有几种构建这种结构的方法。由于集合的窄焦点，项目没有顺序——没有相对位置——并且项目不能重复。我们将探讨从单个项目的来源组装集合集合的多种方法。
- en: The set operators parallel the operators defined by the mathematics of set theory.
    These can be helpful for doing bulk comparisons between sets. We’ll look at these
    in addition to the methods of the set class.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 集合运算符与集合论数学中定义的运算符平行。这些运算符对于在集合之间进行大量比较很有帮助。我们将探讨这些运算符，以及集合类的方法。
- en: 'Sets have an important constraint: they only contain immutable objects. Informally,
    immutable objects have no internal state that can be changed. Numbers are immutable,
    as are strings, and tuples of immutable objects. Formally, immutable objects have
    an internal hash value, and the hash() function will show this value.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 集合有一个重要的约束：它们只包含不可变对象。非正式地说，不可变对象没有内部状态可以改变。数字是不可变的，字符串也是如此，不可变对象的元组也是。正式地说，不可变对象有一个内部哈希值，hash()函数将显示这个值。
- en: 'Here’s how this looks in practice:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在实际中做到这一点：
- en: '[PRE46]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The value of the a variable is an immutable string, which has a hash value.
    The b variable, on the other hand, is a mutable list, and doesn’t have a hash
    value. We can create sets of immutable objects like strings, but the TypeError
    exception will be raised if we try to put mutable objects into a set.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: a变量的值是一个不可变的字符串，它有一个哈希值。另一方面，b变量是一个可变列表，没有哈希值。我们可以创建包含字符串等不可变对象的集合，但如果尝试将可变对象放入集合中，将会引发TypeError异常。
- en: 4.7.1 Getting ready
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7.1 准备工作
- en: 'Let’s say we need to do some analysis of the dependencies among modules in
    a complex application. Here’s one part of the available data:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要对一个复杂应用程序中模块之间的依赖关系进行分析。以下是可用数据的一部分：
- en: '[PRE47]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Each item in this list names a module and a list of modules that it imports.
    There are a number of questions we can ask about this collection of relationships
    among modules. We’d like to compute the short list of dependencies, thereby removing
    duplicates from this list.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表中的每个项目命名了一个模块及其导入的模块列表。我们可以对这个模块之间的关系集合提出许多问题。我们希望计算一个简短的依赖列表，从而从列表中删除重复项。
- en: 4.7.2 How to do it...
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7.2 如何实现...
- en: 'We have many ways to create set objects:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有许多创建集合对象的方法：
- en: 'Literal: We can create literal display of a set using a sequence of values
    surrounded by characters. It looks like this: {value, ... }. Python needs to match
    the { at the start of the literal and } at the end of the literal to see a complete
    logical line, so the literal can span physical lines. For more information, refer
    to the [Writing long lines of code](ch006_split_000.xhtml#x1-910002) recipe in
    Chapter [2](ch006_split_000.xhtml#x1-840002).'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字面量：我们可以使用一系列由字符包围的值来创建集合的文本显示。它看起来像这样：{value, ...}。Python需要匹配字面量开头的{和结尾的}，以看到完整的逻辑行，因此字面量可以跨越物理行。有关更多信息，请参阅第[2](ch006_split_000.xhtml#x1-840002)章中[编写长行代码](ch006_split_000.xhtml#x1-910002)的配方。
- en: Note that we can’t create an empty set with {}; this is an empty dictionary.
    We must use set() to create an empty set.
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们无法使用{}创建一个空集合；这是一个空字典。我们必须使用set()来创建一个空集合。
- en: 'Conversion function: We can convert some other data collection into a set using
    the set() function. We can convert a list of immutable items, or the keys of a
    dict, or a tuple of immutable items.'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换函数：我们可以使用set()函数将其他数据集合转换为集合。我们可以转换不可变项的列表，或字典的键，或不可变项的元组。
- en: 'Add method: The set method add() will add an item to a set. Additionally, sets
    can be created by a union() method or the | operator.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加方法：set方法中的add()会将一个项目添加到集合中。此外，集合可以通过union()方法或|运算符创建。
- en: 'Comprehension: A comprehension is a specialized generator expression that describes
    the items in a set using an expression to define membership. We’ll look at this
    in detail in the [Writing a set comprehension](ch008_split_001.xhtml#x1-2710002)
    section of this recipe.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推导式：推导式是一种特殊的生成器表达式，它使用一个表达式来定义成员资格，从而描述集合中的项目。我们将在本配方[编写集合推导式](ch008_split_001.xhtml#x1-2710002)部分中详细探讨这一点。
- en: The first two ways to create sets are single Python expressions. The last two
    are more complex, and we’ll show recipes for each of them.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 创建集合的前两种方法是单个Python表达式。最后两种更复杂，我们将为每种方法提供配方。
- en: Building a set with the add method
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用add方法构建集合
- en: 'Our source collection of data is a list with sublists. We want to summarize
    the items inside each of the sublists:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据源集合是一个包含子列表的列表。我们希望总结每个子列表中的项目：
- en: 'Create an empty set into which items can be added. Unlike lists, there’s no
    abbreviated syntax for an empty set, so we must use the set() function:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空集合，可以添加项目。与列表不同，没有空集合的缩写语法，因此我们必须使用set()函数：
- en: '[PRE48]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Write a for statement to iterate through each two-tuple in the import_details
    collection. This needs a nested for statement to iterate through each name in
    the list of imports in each pair. Use the add() method of the all_imports set
    to create a complete set with duplicates removed:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个for语句来遍历import_details集合中的每个二元组。这需要一个嵌套的for语句来遍历每对中导入列表中的每个名称。使用all_imports集合的add()方法创建一个包含重复项的完整集合：
- en: '[PRE49]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This result summarizes many lines of details, showing the set of distinct items
    imported. Note that the order here is arbitrary and can vary each time the example
    is executed.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 此结果总结了多行细节，显示了导入的不同项目的集合。请注意，这里的顺序是任意的，并且每次执行示例时都可能不同。
- en: The arbitrary ordering means a doctest example to confirm the correctness of
    this code can’t simply show the expected result. See the [Handling common doctest
    issues](ch019_split_000.xhtml#x1-8100003) recipe in Chapter [15](ch019_split_000.xhtml#x1-79400015)
    for more advice on using doctest.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 任意的顺序意味着用于确认此代码正确性的doctest示例不能简单地显示预期的结果。请参阅第[15](ch019_split_000.xhtml#x1-79400015)章中[处理常见的doctest问题](ch019_split_000.xhtml#x1-8100003)的配方，以获取有关使用doctest的更多建议。
- en: Writing a set comprehension
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写集合推导式
- en: 'The goal of a set comprehension is to create an object that occupies a syntax
    role, similar to a set literal:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 集合推导式的目标是创建一个占据语法角色的对象，类似于集合字面量：
- en: 'Write the wrapping braces that surround the set object to be built:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写包围要构建的集合对象的括号：
- en: '[PRE50]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Write the source of the data. This will include the target variable. We have
    two nested lists, so we’ll need to use two for clauses. Note that there’s no :
    at the end of the for clause because we’re not writing a complete statement:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写数据源。这将包括目标变量。我们有两个嵌套列表，因此我们需要使用两个 for 子句。注意，for 子句的末尾没有冒号，因为我们没有写一个完整的语句：
- en: '[PRE51]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: For now, we’ve written the result of the expression as the special Ellipsis
    object. Once we finish this expression, we will replace it with something more
    useful.
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们将表达式的结果写成了特殊的省略号对象。一旦我们完成这个表达式，我们将用更有用的东西替换它。
- en: 'Prefix the for clause with the expression to evaluate that creates each value
    of the target collection. In this case, we only want the name from the import
    list within each pair of items in the overall import details list-of-lists:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 for 子句前加上创建目标集合每个值的表达式。在这种情况下，我们只想从整体导入详情列表中的每一对项目中的导入列表中获取名称：
- en: '[PRE52]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: A set comprehension cannot have duplicates, so this will always have distinct
    values.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 集合推导不能有重复项，所以这总是有不同值的。
- en: As with the list comprehension, a set comprehension is built around a central
    generator expression. The generator expression at the heart of the comprehension
    has a data expression clause and a for clause.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 就像列表推导一样，集合推导围绕一个中心生成器表达式构建。这个推导的核心生成器表达式有一个数据表达式子句和一个 for 子句。
- en: We can replace the enclosing { and } syntax with the set() function. Using the
    explicit set() function had an advantage when we consider the possibility of changing
    the data structure. We can easily replace set() with frozenset(), list(), or Counter().
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用 set() 函数替换包围的 { 和 } 语法。当我们考虑更改数据结构的可能性时，使用显式的 set() 函数有优势。我们可以轻松地将 set()
    替换为 frozenset()、list() 或 Counter()。
- en: 4.7.3 How it works...
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7.3 它是如何工作的...
- en: A set is a collection of immutable objects. Each immutable Python object has
    a hash value, and these numeric hash codes are used to optimize locating items
    in a set. We can imagine the implementation relies on an array of buckets, and
    the numeric hash value directs us to a bucket to see if the item is present in
    that bucket or not.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是不可变对象的集合。每个不可变的 Python 对象都有一个哈希值，这些数字哈希码用于优化在集合中定位项目。我们可以想象实现依赖于一个桶的数组，数字哈希值将我们引导到桶中，以查看项目是否存在于该桶中。
- en: Hash values are not necessarily unique. The array of hash buckets is finite,
    meaning hash collisions are possible. A collision occurs when two distinct objects
    both have the same hash value. This leads to some overhead to handle any collisions.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希值不一定唯一。哈希桶的数组是有限的，这意味着可能发生哈希冲突。当两个不同的对象都具有相同的哈希值时，就会发生冲突。这导致了一些处理任何冲突的开销。
- en: 'We can create two integers that will have a hash collision:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建两个将产生哈希冲突的整数：
- en: '[PRE53]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In spite of these two objects having the same hash value, hash collision processing
    will keep these two objects separate from each other in a set.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两个对象具有相同的哈希值，但哈希冲突处理将保持这两个对象在集合中相互分离。
- en: 4.7.4 There’s more...
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7.4 更多内容...
- en: 'We have several ways to add items to a set:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方法可以向集合中添加项目：
- en: The example used the add() method. This works with a single item.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例使用了 add() 方法。这对于单个项目是有效的。
- en: We can use the union() method. This method is like an operator—it creates a
    new result set. It does not mutate either of the operand sets.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 union() 方法。这个方法就像一个运算符——它创建一个新的结果集。它不会修改操作数集合中的任何一个。
- en: We can use the update() method to update one set with items from another set.
    This mutates a set and does not return a value.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 update() 方法用另一个集合中的项目更新一个集合。这会修改集合，但不返回任何值。
- en: 'For most of these techniques, we’ll need to create a singleton set from the
    item we’re going to add. Here are some examples:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些技术中的大多数，我们需要从我们要添加的项目创建一个单元素集合。以下是一些示例：
- en: '[PRE54]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the preceding example, we’ve created a singleton set, {item}, from the value
    of the item variable. We then used the union() method to compute a new set, which
    is the union of the collection set and the {item} set.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们已从 item 变量的值创建了一个单元素集合 {item}。然后我们使用了 union() 方法来计算一个新的集合，这是集合集合和
    {item} 集合的并集。
- en: 'Note that union() creates a new object and leaves the original collection untouched.
    Here is yet another alternative that uses the union operator, |:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，union() 创建了一个新对象，并保留了原始集合不变。这里还有一个使用并集运算符 | 的另一种替代方案：
- en: '[PRE55]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can also use the update() method to mutate the set:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 update() 方法来修改集合：
- en: '[PRE56]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Methods like update() and add() mutate the set object. Because they mutate the
    set, they do not return a value. This is similar to the way methods of the list
    collection work. Generally, a method that mutates the collection does not return
    a value. The only exception to this pattern is the pop() method, which both mutates
    the set object and returns the popped value.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 update() 和 add() 这样的方法会修改集合对象。因为它们会修改集合，所以它们不会返回值。这与列表集合的方法类似。通常，修改集合的方法不会返回值。这个模式的唯一例外是
    pop() 方法，它既会修改集合对象又会返回被弹出的值。
- en: 'Python has a number of set operators. These are ordinary operator symbols that
    we can use in complex set expressions:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有许多集合运算符。这些是我们可以用于复杂集合表达式的普通运算符符号：
- en: '| for set union, often typeset as A ∪ B'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '| 用于集合并集，通常表示为 A ∪ B'
- en: '& for set intersection, often typeset as A ∩ B'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '& 用于集合交集，通常表示为 A ∩ B'
- en: ^ for set symmetric difference, often typeset as A △ B
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ^ 用于集合对称差集，通常表示为 A △ B
- en: '- for set subtraction, often typeset as A ∖ B'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 用于集合减法，通常表示为 A ∖ B'
- en: 4.7.5 See also
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7.5 参考内容
- en: In the [Shrinking sets – remove(), pop(), and difference](ch008_split_001.xhtml#x1-2750008)
    recipe, we’ll look at how we can update a set by removing or replacing items.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[缩小集合 – remove(), pop(), 和 difference](ch008_split_001.xhtml#x1-2750008)菜谱中，我们将探讨如何通过删除或替换项目来更新集合。
- en: 4.8 Shrinking sets – remove(), pop(), and difference
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.8 缩小集合 – remove(), pop(), 和 difference
- en: Python gives us several ways to remove items from a set collection. We can use
    the remove() method to remove a specific item. We can use the pop() method to
    remove (and return) an arbitrary item.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: Python 给我们几种从集合集合中删除项目的方法。我们可以使用 remove() 方法来删除一个特定的项目。我们可以使用 pop() 方法来删除（并返回）一个任意项目。
- en: 'Additionally, we can compute a new set using the set intersection, difference,
    and symmetric difference operators: &, -, and ^. These will produce a new set
    that is a subset of a given input set.'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用集合交集、差集和对称差集运算符：&、- 和 ^ 来计算一个新的集合。这些将产生一个新的集合，它是给定输入集合的子集。
- en: 4.8.1 Getting ready
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8.1 准备工作
- en: 'Sometimes, we’ll have log files that contain lines with complex and varied
    formats. Here’s a small snippet from a long, complex log:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们会有包含复杂和多变格式的日志文件。以下是从一个长而复杂的日志中摘取的一小段：
- en: '[PRE57]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We need to find all of the text similar to IP: 111.222.111.222 in this log.
    These are IPv4 addresses with 4 numeric fields.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在这个日志中找到所有类似于IP: 111.222.111.222的文本。这些是具有4个数字字段的IPv4地址。
- en: 'Here’s how we can create a set of matches:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何创建匹配项集合的方法：
- en: '[PRE60]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The problem we have with this log is extraneous matches. The log file also has
    text that looks similar but are dummy or placeholder values we need to ignore.
    In the full log, we’ll also find lines containing text like IP: 1.2.3.4, which
    is a placeholder, not a meaningful address. It turns out that there is a small
    set of irrelevant values.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这个日志的问题是有一些无关的匹配项。日志文件中还有一些看起来相似但却是我们需要忽略的占位符或占位值。在完整的日志中，我们还会找到包含类似IP: 1.2.3.4这样的文本的行，这是一个占位符，不是一个有意义的地址。结果证明，存在一组不相关的值。
- en: This is a place where set intersection and set subtraction can be very helpful.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在集合交集和集合减法可以非常有帮助的地方。
- en: 4.8.2 How to do it...
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8.2 如何做到...
- en: 'Create a set of items we’d like to ignore as a set literal:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个我们想要忽略的项目集合，作为一个集合字面量：
- en: '[PRE61]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Collect all entries from the log. We’ll use the re module for this, as shown
    earlier. We’ll see results like the following:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集日志中的所有条目。我们将使用前面展示的 re 模块来完成此操作。我们将看到以下结果：
- en: '[PRE62]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Remove items from the set of matches using set subtraction. Here are two examples:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用集合减法从匹配项集合中删除项目。以下有两个示例：
- en: '[PRE63]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Both of these are operators that return new sets as their results. Neither of
    these will mutate the underlying set objects.
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这两个都是返回新集合作为结果的运算符。这两个都不会修改底层集合对象。
- en: It turns out the difference() method can work with any iterable collection,
    including lists and tuples. While permitted, mixing sets and lists can be confusing,
    and it can be challenging to write type hints for them.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，difference() 方法可以与任何可迭代的集合一起工作，包括列表和元组。虽然允许混合集合和列表，但这可能会造成混淆，并且为它们编写类型提示可能会很具挑战性。
- en: 'We’ll often use these in statements, like this example:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常在语句中使用这些，例如以下示例：
- en: '[PRE64]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This will assign the resulting set to a new variable, valid_matches, so that
    we can do the required processing on this new set.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把结果集合分配给一个新的变量，valid_matches，这样我们就可以对这个新集合进行所需的处理。
- en: We can also use the remove() and pop() methods to remove specific items. The
    remove() method raises an exception when an item cannot be removed. We can use
    this behavior to both confirm that an item is in the set and remove it.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: 4.8.3 How it works...
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A set object tracks membership of items. An item is either in the set or not.
    We specify the item we want to remove. Removing an item doesn’t depend on an index
    position or a key value.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: The set operators permit sophisticated set computations. We can remove any of
    the items in one set from a target set computing set difference or set subtraction.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 4.8.4 There’s more...
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have several other ways to remove items from a set:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we used the difference() method and the - operator. The difference()
    method behaves like an operator and creates a new set.
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also use the difference_update() method. This will mutate a set in place.
    It does not return a value.
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can remove an individual item with the remove() method.
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also remove an arbitrary item with the pop() method. This doesn’t apply
    to this example very well because we can’t control which item is popped from a
    set.
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s how the difference_update() method looks:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We applied the difference_update() method to remove the undesirable items from
    the valid_matches set. Since the valid_matches set was mutated, no value is returned.
    Also, since the set is a copy, this operation doesn’t modify the original matches
    set.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: 'We could do something like the following example to use the remove() method.
    Note that remove() will raise an exception if an item is not present in the set:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We tested to see if the item was in the valid_matches set before attempting
    to remove it. Using an if statement is one way to avoid raising a KeyError exception.
    An alternative is to use a try: statement to silence the exception that’s raised
    when an item is not present.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the pop() method to remove an arbitrary item. This method is
    unusual in that it both mutates the set and returns the item that was removed.
    However, we can’t control which item is popped, making it inappropriate for this
    example.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: 4.9 Writing set-related type hints
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The typing module provides a few essential type definitions for describing the
    contents of a set object. The primary type definition is set, which we can parameterize
    with the types of items in the set. We’ll use set[int] to describe a set composed
    of integers. This parallels the Writing list-related type hints recipe.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: 4.9.1 Getting ready
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A dice game like Zonk (also called 10,000 or Greed) requires a random collection
    of dice to be grouped into ”hands.” While rules vary, there a several patterns
    for hands, including:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: Three of a kind.
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A “small straight” of five ascending dice (1-2-3-4-5 or 2-3-4-5-6 are the two
    combinations).
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A “large straight” of six ascending dice.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An “ace” hand. This has at least one 1 die that’s not part of a three of a kind
    or straight.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Six of a kind. While rare, it’s not impossible.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll use the following class and function definitions to create the hands
    of dice:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下类和函数定义来创建骰子手牌：
- en: '[PRE67]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The Die class definition enumerates the six faces of a standard die by providing
    the Unicode character with the appropriate value.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: Die类的定义通过提供适当的Unicode字符来枚举标准骰子的六个面。
- en: When we evaluate the zonk() function, it looks like this.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们评估zonk()函数时，它看起来是这样的。
- en: '[PRE68]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This shows us a hand with two sixes, two ones, a two, and a three. When examining
    the hand for patterns, we will often create complex sets of objects.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们展示了一副包含两个六、两个一、一个二和一个三的手牌。在检查手牌以寻找模式时，我们通常会创建复杂的一组对象。
- en: 4.9.2 How to do it...
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.9.2 如何实现...
- en: 'A function to do analysis of the patterns of dice works by creating a set[Die]
    object from the six dice instances. This set reveals a great deal of information:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于分析骰子模式的功能通过从六个骰子实例创建一个set[Die]对象来工作。这个集合揭示了许多信息：
- en: When there is one die in the set of unique values, then all six dice have the
    same value.
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当集合中独特的值只有一个骰子时，那么所有六个骰子都有相同的值。
- en: When there are five distinct dice in the set of unique values, then this could
    be a small straight. This requires an additional check to see if the set of unique
    values is 1-5 or 2-6, which are the two valid small straights.
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当集合中独特的值有五个骰子时，这可能是小顺子。这需要额外的检查以查看独特的值集合是否为1-5或2-6，这两个是有效的小顺子。
- en: When there are six distinct items in the set of unique values, then this must
    be a large straight.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当集合中独特的值有六个不同项时，那么这必须是一个大顺子。
- en: For two unique dice values there will be at least one three of a kind. There
    may be a four or five of a kind, but these are scored as a three of a kind and
    the remaining dice are non-scoring.
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于两个独特的骰子值，至少会有一个三个一的情况。可能会有四个或五个一的情况，但这些被计分为三个一，剩余的骰子不计分。
- en: For three or four unique dice in the set, there may be a three of a kind. More
    detailed analysis of the set is required to see the exact pattern.
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于集合中的三个或四个独特骰子，可能会有三个一的情况。需要更详细地分析集合以查看确切的模式。
- en: We can distinguish many of the patterns by looking at the cardinality of the
    set of distinct dice. The remaining distinctions can be made by looking at the
    pattern of counts. For this, a collections.Counter object will be useful.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看独特骰子集合的基数来区分许多模式。剩余的区别可以通过查看计数模式来实现。为此，collections.Counter对象将很有用。
- en: 'Here’s how to write this set-based analysis:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何编写这种基于集合的分析：
- en: Define the type for each item in the set. In this example, the Die class is
    the item class. We’ll work with set[Die] and Counter[Die] types.
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义集合中每个项目的类型。在这个例子中，Die类是项目类。我们将使用set[Die]和Counter[Die]类型。
- en: 'Create the set object with the unique values from the hand of Die instances.
    Here’s how the evaluation function can begin:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Die实例的手牌中的独特值创建集合对象。下面是评估函数如何开始：
- en: '[PRE69]'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'There are two small straight definitions: 1-5 and 2-6:'
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有两个小顺子的定义：1-5和2-6：
- en: '[PRE70]'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We can build these two sets in the body of the analysis function to show how
    they’re used. Pragmatically, the value of small_straights should be computed only
    once.
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以在分析函数的主体中构建这两个集合，以展示它们是如何被使用的。从实用主义的角度来看，small_straights的值应该只计算一次。
- en: We can’t build a set of these two set instances because set objects are mutable.
    We could build a set of two frozenset objects instead of building a list.
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不能构建这两个集合实例的集合，因为集合对象是可变的。我们可以通过构建两个frozenset对象来代替构建列表。
- en: 'Examine the simple cases. The number of distinct elements in the set identifies
    several kinds of hands directly:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查简单的情况。集合中不同元素的数量直接识别了几种手牌：
- en: '[PRE71]'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'When there are three or four distinct values, the patterns can be summarized
    using the counts. This pattern of frequency counts can be summarized as a set[int]:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当集合中有三个或四个独特值时，可以使用计数来总结模式。这种频率计数的模式可以总结为set[int]：
- en: '[PRE72]'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'For the cases of three or four distinct Die values, these can form a variety
    of patterns. If at least one of the Die has a frequency of three or four, that’s
    a scoring combination. If nothing else matches and there’s a die showing a one,
    that’s a minimal score:'
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于三个或四个不同的Die值的情况，这些可以形成各种模式。如果至少有一个Die的频率为三个或四个，那么这就是一个计分组合。如果没有其他匹配，并且有一个骰子显示一，那么这就是最小得分：
- en: '[PRE73]'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Are there any conditions left over? Does this cover all the possible cardinalities
    of dice and frequencies of dice? The remaining cases includes collections of pairs
    and singletons without any ”one” showing. After the above if statement, we can
    provide a single return statement to collect all other cases into a single, non-scoring
    Zonk:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否还有剩余的条件？这涵盖了所有可能的骰子基数和频率吗？剩余的情况包括没有“一个”出现的成对和单数集合。在上述if语句之后，我们可以提供一个单独的返回语句来收集所有其他情况到一个单一的、不计分的Zonk中：
- en: '[PRE74]'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This shows two ways of using sets to evaluate the pattern of a collection of
    data items. The first set, set[Die], looked at the overall pattern of unique Die
    values. The second set, set[int], looked at the pattern of frequencies of Die
    values.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了两种使用集合评估数据项集合模式的方法。第一个集合，set[Die]，检查了唯一Die值的整体模式。第二个集合，set[int]，检查了Die值频率的模式。
- en: 4.9.3 How it works...
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.9.3 它是如何工作的...
- en: The essential property of a set is membership. When we compute a set from a
    collection of Die instances, we used the set[Die] type hint to describe this structure.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的基本属性是成员资格。当我们从Die实例的集合中计算集合时，我们使用set[Die]类型提示来描述这个结构。
- en: Similarly, when we look at the distribution of frequencies, there are only a
    few distinct patterns. Transforming the counts into a set of values into a collection
    with the set[int] type hint described this additional structure.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当我们查看频率分布时，只有几种不同的模式。将计数转换为具有set[int]类型提示的值的集合，描述了这种额外的结构。
- en: 4.9.4 There’s more...
  id: totrans-538
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.9.4 更多内容...
- en: A set of items that don’t have a single, uniform type is potentially confusing.
    We can use set[T1 | T2] to describe a set where items can be any of the types
    T1 or T2.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 一组没有单一、统一类型的项可能会令人困惑。我们可以使用set[T1 | T2]来描述一个可以包含T1或T2类型的项的集合。
- en: 'Computing the score of the hand of dice depends on which dice were part of
    the winning pattern. This means the evaluation function needs to return a more
    complex result when the outcome is a three of a kind. To determine the points,
    there are three cases we need to consider:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 计算骰子手的分数取决于哪些骰子是获胜模式的一部分。这意味着当结果是三张牌时，评估函数需要返回一个更复杂的结果。为了确定分数，我们需要考虑三种情况：
- en: Which value of the Dice class occurred three or six times. This determines the
    base score. Often, 1s are given 1,000 points, and 2 through 6 are given 200 through
    600 points.
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dice类中哪个值出现了三次或六次。这决定了基础分数。通常，1被赋予1,000分，2到6被赋予200到600分。
- en: It’s possible to roll two triples; this pattern must be distinguished, too.
    This often scores 2,000 points, irrespective of the numbers shown.
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出两个三重组合是可能的；这种模式也需要区分。这通常得分2,000点，无论显示的数字是多少。
- en: For the straights and the “ace” hand, simple fixed scores are assigned. A small
    straight might be 1,000 points. A large straight 2,000\. A lone 1 might score
    only 50 points.
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于顺子和“王牌”手牌，分配了简单的固定分数。小顺子可能是1,000分。大顺子2,000分。单独的1可能只得分50分。
- en: We have two separate conditions to identify the patterns of unique values indicating
    a three-of-a-kind pattern. The function needs some refactoring to properly identify
    the values of the dice occurring three or more times and the values of the dice
    which were ignored. We’ve left this additional design as an exercise for the reader.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个单独的条件来识别表示三张牌模式的唯一值模式。该函数需要一些重构，以正确识别出现三次或更多次的骰子值以及被忽略的骰子值。我们将这个额外的设计留作读者的练习。
- en: 4.9.5 See also
  id: totrans-545
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.9.5 参考以下内容
- en: Refer to the [Writing list-related type hints](ch008_split_001.xhtml#x1-2560005)
    recipe in this chapter for more about type hints for lists.
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考本章中的[编写列表相关类型提示](ch008_split_001.xhtml#x1-2560005)配方以了解更多关于列表类型提示的信息。
- en: Join our community Discord space
  id: totrans-547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的Python Discord工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-549
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
