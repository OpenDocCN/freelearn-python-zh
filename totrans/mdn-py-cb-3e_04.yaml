- en: '4'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Built-In Data Structures Part 1: Lists and Sets'
  prefs: []
  type: TYPE_NORMAL
- en: Python has a rich collection of built-in data structures. These data structures
    are sometimes called ”containers” or ”collections” because they contain a collection
    of individual items. These structures cover a wide variety of common programming
    situations.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at an overview of the various collections that are built in and what
    problems they solve. After the overview, we will look at the list and set collections
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The built-in tuple and string types were part of Chapter [1](ch005_split_000.xhtml#x1-170001),
    [Numbers, Strings, and Tuples](ch005_split_000.xhtml#x1-170001). These structures
    are sequences, making them similar in many ways to the list collection. However,
    strings and tuples seem to have more in common with immutable numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter, Chapter [5](ch009.xhtml#x1-2890005), will look at dictionaries,
    as well as some more advanced topics also related to lists and sets. In particular,
    it will look at how Python handles references to mutable collection objects. This
    has consequences in the way functions need to be defined that accept lists or
    sets as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll look at the following recipes, all related to Python’s
    built-in data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Choosing a data structure](ch008_split_000.xhtml#x1-2250001)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Building lists – literals, appending, and comprehensions](ch008_split_000.xhtml#x1-2310002)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Shrinking lists – deleting, removing, and popping](ch008_split_000.xhtml#x1-2460004)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Writing list-related type hints](ch008_split_001.xhtml#x1-2560005)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Reversing a copy of a list](ch008_split_001.xhtml#x1-2620006)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Building sets – literals, adding, comprehensions, and operators](ch008_split_001.xhtml#x1-2670007)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Shrinking sets – remove(), pop(), and difference](ch008_split_001.xhtml#x1-2750008)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Writing set-related type hints](ch008_split_001.xhtml#x1-2800009)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.1 Choosing a data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python offers a number of built-in data structures to help us work with collections
    of data. It can be confusing to match the data structure features with the problem
    we’re trying to solve.
  prefs: []
  type: TYPE_NORMAL
- en: How do we choose which structure to use?
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we put data into a collection, we’ll need to consider how we’ll gather
    the data, and what we’ll do with the collection once we have it. One big question
    is how to identify a particular item within the collection. Python offers a variety
    of choices.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Is the programming focused on the existence of a value? An example of this
    is validating an input value. When the user enters something that’s in a collection,
    their input is valid; otherwise, the entry is invalid. Simple membership tests
    suggest using a set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A set holds items in no particular order. If order matters, then a list is more
    appropriate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Are we going to identify items by their position in the collection? An example
    includes the lines in an input file—the line number is its position in the collection.
    When we identify an item using an index or position, we must use a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have created a list, month_name_list, with 12 string items in a specific
    order. We can pick an item by providing the index position. We can also use the
    index() method to return the index position of an item in the list. List index
    values in Python always start with zero. While a list has a simple membership
    test, the test can be slow for a very large list, and a set might be a better
    idea if many such tests will be needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the number of items in the collection is fixed—for example, RGB colors have
    three values—this suggests a tuple instead of a list. If the number of items will
    grow and change, then the list collection is a better choice than the tuple collection.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Are we going to identify the items in a collection by a key value that’s distinct
    from the item’s index? An example might include a mapping between strings of characters—words,
    for example—and integers that represent the frequencies of those words. Another
    example might be a mapping between a color name and the RGB tuple for that color.
    We’ll look at mappings and dictionaries in Chapter [5](ch009.xhtml#x1-2890005),
    [Built-In Data Structures Part 2: Dictionaries](ch009.xhtml#x1-2890005). The important
    distinction is mappings do not locate items by a numerical index position the
    way lists do.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider the mutability of items in a set collection (and the keys in a dictionary).
    Each item in a set must be an immutable object. Numbers, strings, and tuples are
    all immutable and can be collected into sets. Since list, dictionary, and set
    objects are mutable, they can’t be used as items in a set. It’s impossible to
    build a set of list objects, for example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rather than create a set of list items, we can transform each item into an immutable
    tuple object. Similarly, dictionary keys must be immutable. We can use a number,
    a string, or a tuple as a dictionary key. We can’t use a list, or a set, or any
    other mutable object as a dictionary key.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 4.1.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each of Python’s built-in collections offers a specific set of unique features.
    The collections also offer a large number of overlapping features. The challenge
    for programmers new to Python is to map the unique features of each collection
    to the problem they are trying to solve.
  prefs: []
  type: TYPE_NORMAL
- en: The collections.abc module provides a kind of road map through the built-in
    container classes. This module defines the Abstract Base Classes (ABCs) underlying
    the concrete classes we use. We’ll use the names from this set of definitions
    to guide us through the features.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the ABCs, we can see that there are places for a total of three general
    kinds of collections with six implementation choices:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set: Its unique feature is that items are either members or not. This means
    duplicates are ignored:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mutable set: The built-in set collection'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Immutable set: The built-in frozenset collection'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sequence: Its unique feature is that items are provided with an index position:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mutable sequence: The built-in list collection'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Immutable sequence: The built-in tuple collection. This is the subject of some
    recipes in Chapter [1](ch005_split_000.xhtml#x1-170001).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mapping: Its unique feature is that each item has a key that refers to a value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mutable mapping: The built-in dict collection. This is the subject of Chapter [5](ch009.xhtml#x1-2890005).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Immutable mapping: Interestingly, there’s no built-in frozen mapping.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python’s libraries offer additional implementations of these core collection
    types. The collections module include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'namedtuple: A tuple that offers names for each item in a tuple. It’s slightly
    clearer to use rgb_color.red than rgb_color[0].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'deque: A double-ended queue. It’s a mutable sequence with optimizations for
    pushing and popping from each end. We can do similar things with a list, but deque
    is more efficient when changes at both ends are needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'defaultdict: A dict that can provide a default value for a missing key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Counter: A dict that is designed to count occurrences of a key. This is sometimes
    called a multiset or a bag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ChainMap: A dict that combines several dictionaries into a single mapping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, there’s an older OrderedDict class. This class retains the keys
    in the order in which they were created. Starting with Python 3.7, the dictionary
    keys for an ordinary dictionary are retained in the order they were created, making
    the OrderedDict class redundant.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s still more in the Python Standard Library. We can also use the heapq
    module, which defines a kind of list that acts as a high-performance priority
    queue. The bisect module includes methods for searching a sorted list very quickly.
    This lets us create a list object, which can have performance that is a little
    closer to the very fast lookups of a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find descriptions of data structures on summary web pages, like this
    one: [https://thealgorist.com](https://thealgorist.com). We’ll take a quick look
    at four additional families of data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays: The Python array module supports densely packed arrays of values. The
    numpy module also offers very sophisticated array processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Trees: Generally, tree structures can be used to create sets, sequential lists,
    or key-value mappings. We can look at a tree as an implementation technique for
    building sets or dictionaries. We often build tree structures using objects and
    class definitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hashes: Python uses hashes to implement dictionaries and sets. This leads to
    good speed but potentially large memory consumption.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Graphs: Python doesn’t have a built-in graph data structure. However, we can
    easily represent a graph structure with a dictionary where each node has a list
    of adjacent nodes. External libraries like NetworkX, Pyoxigraph, and RDFLib support
    sophisticated graph databases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can—with a little cleverness—implement almost any kind of data structure
    in Python. While it’s often the case that the built-in structures have the essential
    we may be able to locate a built-in structure that can be pressed into service.
    We’ll look at mappings and dictionaries in Chapter [5](ch009.xhtml#x1-2890005),
    [Built-In Data Structures Part 2: Dictionaries](ch009.xhtml#x1-2890005).'
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For high-performance array processing, see [https://numpy.org](https://numpy.org).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For advanced graph analysis, see [https://networkx.github.io](https://networkx.github.io).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For graph manipulation and storage, see [https://pyoxigraph.readthedocs.io/en/stable/](https://pyoxigraph.readthedocs.io/en/stable/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For graph manipulation, see [https://rdflib.readthedocs.io/en/stable/](https://rdflib.readthedocs.io/en/stable/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.2 Building lists – literals, appending, and comprehensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we’ve decided to create a collection based on each item’s position in the
    container—a list—we have several ways of building this structure. We’ll look at
    a number of ways we can assemble a list object from the individual items.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, we’ll need a list because it allows duplicate values, unlike
    a set. This is common in statistical work. A different structure, called a multiset,
    can also be useful for a statistically oriented collection that permits duplicates.
    This collection is available in the standard library as collections.Counter.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say we need to do some statistical analyses of some file sizes. Here’s
    a short script that will provide us with the sizes of some files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We’ve used a pathlib.Path object to represent a directory in our filesystem.
    The glob() method expands all names that match a given pattern.
  prefs: []
  type: TYPE_NORMAL
- en: We’d like to accumulate a list object that has the various file sizes. From
    that list, we can compute the total size and average size.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have many ways to create list objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Literal: We can create a literal display of a list using a sequence of values
    surrounded by [] characters. For example, [1, 2, 3]. Python needs to match an
    opening [ and a closing ] to see a complete logical line, so the literal can span
    physical lines. For more information, refer to the [Writing long lines of code](ch006_split_000.xhtml#x1-910002)
    recipe in Chapter [2](ch006_split_000.xhtml#x1-840002).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Conversion function: We can convert some other data collection into a list
    using the list() function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Append method: We have list methods that allow us to build a list one item
    at a time. These methods include append(), extend(), and insert(). We’ll look
    at the append() method in the [Building a list with the append() method](ch008_split_000.xhtml#x1-2340002)
    section of this recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Comprehension: A comprehension is a specialized generator expression that computes
    a list from a source object. We’ll look at this in detail in the [Writing a list
    comprehension](ch008_split_000.xhtml#x1-2350002) section of this recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two ways to create a list are single Python expressions. The last
    two are more complex, and we’ll show recipes for each of them.
  prefs: []
  type: TYPE_NORMAL
- en: Building a list with the append() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create an empty list using literal syntax, [], or the list() function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Iterate through some source of data. Append the items to the list using the
    append() method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we print the list, Python displays it in literal notation. This is handy
    if we ever need to copy and paste the list into another script.
  prefs: []
  type: TYPE_NORMAL
- en: It’s very important to note that the append() method does not return a value.
    The append() method mutates the list object, and does not return anything.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a list comprehension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The goal of a list comprehension is to create an object that occupies the syntax
    role of a literal:'
  prefs: []
  type: TYPE_NORMAL
- en: Write the wrapping [] brackets that surround the list object to be built.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the source of the data. This will include the target variable. Note that
    there’s no : at the end of the for clause because we’re not writing a complete
    statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Prefix the for clause with an expression to evaluate to create each value that
    goes into the sequence from the value of target variable. Again, since this is
    only a single expression, we cannot use complex statements here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s an example of list object construction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve created a list object, we can assign it to a variable and do
    other calculations and summaries on the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list comprehension is built around a central generator expression, called
    a comprehension in the language manual. The comprehension has two parts: the data
    expression clause and a for clause. The data expression clause is evaluated repeatedly,
    driven by the variables assigned in the for clause.'
  prefs: []
  type: TYPE_NORMAL
- en: We can replace the enclosing [ and ] with the list() function. Using the explicit
    list() function had an advantage when we consider the possibility of changing
    the data structure. We can easily replace list() with set() or Counter() to make
    use of the core generator, but creating a distinct collection type.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Python list object has a dynamic size. The size is adjusted when items are
    appended or inserted, or the list is extended with items from another sequence.
    Similarly, the size shrinks when items are popped or deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'In rare cases, we might want to create a list with a given initial size, and
    then set the values of the items separately. We can do this with a list comprehension,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a list with an initial size of 100 items, each of which is
    True. We might need this kind of initialization to implement the [Sieve of Eratosthenes](https://math.libretexts.org/Bookshelves/Combinatorics_and_Discrete_Mathematics/Elementary_Number_Theory_(Raji)/02%3A_Prime_Numbers/2.01%3A_The_Sieve_of_Eratosthenes)
    algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The sieve collection has a sequence of True and False values. The index position
    of each True is a prime number. Multiples of each prime, p, starting with p²,
    are set to False. The prime collection is a sequence of values, p for which the
    expression sieve[p] is True.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common goal for creating a list object is to be able to summarize it. We
    can use a variety of Python functions for this. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve used the built-in sum(), min(), and max() methods to produce some descriptive
    statistics of these document sizes. Which of these index files is the smallest?
    We want to know the position of the minimum in the list of values. We can use
    the index() method for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We found the minimum, and then used the index() method to locate the position
    of that minimal value.
  prefs: []
  type: TYPE_NORMAL
- en: Other ways to extend a list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can extend a list object, as well as insert one into the middle or beginning
    of a list. We have two ways to extend a list: we can use the + operator or we
    can use the extend() method. Here’s an example of creating two lists and putting
    them together with the + operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have created a list of sizes of documents with names like Chapter_03/*.py.
    We then created a second list of sizes of documents with a slightly different
    name pattern, Chapter_04/*.py. We then combined the two lists into a final list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can insert a value prior to any particular position in a list. The insert()
    method accepts the position of an item; the new value will be before the given
    position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We’ve inserted two new values into a list object. As with the append() and extend()
    methods, the insert() method does not return a value. It mutates the list object.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the [Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003) recipe
    for ways to copy lists and pick sublists from a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the [Shrinking lists – deleting, removing, and popping](ch008_split_000.xhtml#x1-2460004)
    recipe for other ways to remove items from a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the [Reversing a copy of a list](ch008_split_001.xhtml#x1-2620006) recipe,
    we’ll look at reversing a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This article provides some insights into how Python collections work internally:
    [https://wiki.python.org/moin/TimeComplexity](https://wiki.python.org/moin/TimeComplexity).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When looking at the tables, it’s important to note the expression O(1) means
    that the cost is essentially constant. The expression O(n) means the cost grows
    as the size of the collection grows.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 4.3 Slicing and dicing a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many times when we’ll want to pick items from a list. One of the most
    common kinds of processing is to treat the first item of a list as a special case.
    This leads to a kind of head-tail processing where we treat the head of a list
    differently from the items in the tail of a list.
  prefs: []
  type: TYPE_NORMAL
- en: We can use these techniques to make a copy of a list too.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have a spreadsheet that was used to record fuel consumption on a large sailboat.
    It has rows that look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| date | engine on | fuel height |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | engine off | fuel height |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Other notes |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 10/25/2013 | 08:24:00 AM | 29 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | 01:15:00 PM | 27 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | calm seas – anchor solomon’s island |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 10/26/2013 | 09:12:00 AM | 27 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | 06:25:00 PM | 22 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | choppy – anchor in jackson’s creek |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4.1: Example of sailboat fuel use'
  prefs: []
  type: TYPE_NORMAL
- en: In this dataset, fuel is measured by height. This is because a sight-gauge is
    used, calibrated in inches of depth. For all practical purposes, the tank is rectangular,
    so the depth shown can be converted into volume since we know 31 inches of depth
    is about 75 gallons.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example of spreadsheet data is not properly normalized. Ideally, all rows
    follow the First Normal Form for data: a row should have identical content, and
    each cell should have only atomic values. In this data, there are three subtypes
    of row:'
  prefs: []
  type: TYPE_NORMAL
- en: The first row of a three-row group has engine on date, time, and a measurement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second row of a group has engine off time and a measurement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third row has some notes that aren’t too useful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This kind of denormalized data includes the following two problems:'
  prefs: []
  type: TYPE_NORMAL
- en: The .csv file has four rows of headings. (The fourth row is a blank line that’s
    not shown here in this nicely formatted book.) This is something the csv module
    can’t deal with directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each day’s travel is spread across three rows. These rows must be combined to
    make it easier to compute an elapsed time and the number of inches of fuel used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can read the data with a function defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We’ve used the csv module to read the log details. The object returned by the
    csv.reader() function is iterable. In order to collect the items into a single
    list, we applied the list() function to the iterable; this creates a list object
    from the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each row of the original CSV file is a list. Here’s what the first and last
    rows look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For this recipe, we’ll use an extension of a list index expression to slice
    items from the list of rows. The slice, like an index expression, follows the
    list object in [] characters. Python offers several variations of the slice expression
    so that we can extract useful subsets of the list of rows.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we need to do is remove the four lines of headings from the
    list of rows. We’ll use two partial slice expressions to divide the list by the
    fourth row:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve sliced the list into two sections using log_rows[:4] and log_rows[4:].
    The first slice expression selects the first four lines; this is assigned to the
    head variable. The second slice expression selects rows from 4 to the end of the
    list. This is assigned to the tail variable. These are the rows of the sheet we
    care about.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We’ll use slices with steps to pick the interesting rows. The [start:stop:step]
    version of a slice will pick rows in groups based on the step value. In our case,
    we’ll take two slices. One slice starts on row zero—the “engine on” lines—and
    the other slice starts on row one—the “engine off” lines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s a slice of every third row, starting with row zero:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve used the pprint() function from the pprint module to make the output much
    easier to read.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There’s additional data in every third row, starting with row one:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These two slices can then be zipped together to create a list of pairs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This gives us a sequence that consists of pairs of three tuples. This is very
    close to something we can work with.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Flatten the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve used a list comprehension from the [Building lists – literals, appending,
    and comprehensions](ch008_split_000.xhtml#x1-2310002) recipe to combine the two
    elements in each pair of rows to create a single row. This has more properly normalized
    data describing each leg of the voyage.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: From the resulting list, we can now compute the difference in times to get the
    running time for the boat. We can compute the difference in heights to estimate
    the fuel consumed during each leg of the journey. This flat list with five useful
    items—date, time, height, time, and height—has all the needed data in a single
    row. It also has a column that will generally contain an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The slice operator has several different forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[:]: The start and stop are implied. The expression S[:] will create a copy
    of sequence S.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[:stop]: This makes a new list from the beginning to just before the stop index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[start:]: This makes a new list from the given start to the end of the sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[start:stop]: This picks a sublist, starting from the start index and stopping
    just before the stop index. Python works with half-open intervals. The start is
    included, while the stop index is not included.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[::step]: The start and stop are implied and include the entire sequence. The
    step—generally not equal to one—means we’ll skip through the list from the start
    using the step. For a given step, s, and a list of size |L|, the index values
    are i ∈{s×n∣n ∈ℕ and 0 ≤ s×n < |L|}.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[start::step]: The start is given, but the stop is implied. The idea is that
    the start is an offset, and the step applies to that offset. For a given start,
    a, step, s, and a list of size |L|, the index values are i ∈{s × n + a∣n ∈ℕ and
    0 ≤ s × n + a < |L|}.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[:stop:step]: This is used to prevent processing the last few items in a list.
    Since the step is given, processing begins with element zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[start:stop:step]: This will pick elements from a subset of the sequence. Items
    prior to start and from stop to the end will not be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The slicing technique works for lists, tuples, strings, and any other kind of
    sequence. Slicing does not cause the collection to be mutated; rather, slicing
    will make a copy of some part of the sequence. The items within the source collection
    are now shared between collections.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Reversing a copy of a list](ch008_split_001.xhtml#x1-2620006) recipe,
    we’ll look at an even more sophisticated use of slice expressions.
  prefs: []
  type: TYPE_NORMAL
- en: The copy of a sequence is called a shallow copy because there will be two collections
    that each contain references to the same underlying objects. We’ll look at this
    in detail in the [Making shallow and deep copies of objects](ch009.xhtml#x1-3160005)
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this specific example, we have another way of restructuring multiple rows
    of data into single rows of data: we can use a generator function. We’ll look
    at functional programming techniques online in Chapter [9](ch013_split_000.xhtml#x1-5020009).'
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the [Building lists – literals, appending, and comprehensions](ch008_split_000.xhtml#x1-2310002)
    recipe for ways to create lists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the [Shrinking lists – deleting, removing, and popping](ch008_split_000.xhtml#x1-2460004)
    recipe for other ways to remove items from a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the [Reversing a copy of a list](ch008_split_001.xhtml#x1-2620006) recipe,
    we’ll look at reversing a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [pandas](https://pandas.pydata.org) package offers some additional ways
    to work with CSV files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.4 Shrinking lists – deleting, removing, and popping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There will be many times when we’ll want to remove items from a list collection.
    We might delete items from a list, and then process the items that are left over.
  prefs: []
  type: TYPE_NORMAL
- en: Removing unneeded items has a similar effect to using filter() to create a copy
    that has only the needed items. The distinction is that a filtered copy will use
    more memory than deleting items from a list. We’ll show both techniques for removing
    unwanted items from a mutable list.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have a spreadsheet that is used to record fuel consumption on a large sailboat.
    See Table [4.1](ch008_split_000.xhtml#x1-241001r1) for the data.
  prefs: []
  type: TYPE_NORMAL
- en: For more background on this data, refer to the [Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003)
    recipe earlier in this chapter. The get_fuel_use() function will collect the raw
    data. It’s important to note that the structure of this data—each fact spread
    among three separate rows—is perfectly awful and requires considerable care to
    reconstruct something more useful.
  prefs: []
  type: TYPE_NORMAL
- en: Each row of the original CSV file is a list. Each of those lists contains three
    items. It’s essential to remove some rows with titles and uninformative data.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll look at several ways to remove items from a list:'
  prefs: []
  type: TYPE_NORMAL
- en: The del statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remove() method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pop() method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also replace items in a list using slice assignment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The del statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can remove items from a list using the del statement. We can provide an
    object and a slice to remove a group of rows from the list object. Here’s how
    the del statement looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The del statement removed the first four rows, leaving behind the rows that
    we really need to process. We can then combine these rows and summarize them using
    the [Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003) recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The remove() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can remove items from a list using the remove() method. Given a specific
    value, this removes matching items from a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might have a list that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can remove the useless ’’ item from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note that the remove() method does not return a value. It mutates the list in
    place.
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted in the [Building lists – literals, appending, and comprehensions](ch008_split_000.xhtml#x1-2310002)
    recipe, the following code is incorrect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is emphatically wrong. This will set a to None.
  prefs: []
  type: TYPE_NORMAL
- en: The pop() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can remove items from a list using the pop() method. This removes items from
    a list based on their index.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might have a list that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This has a useless ’’ string in it. We can find the index of the item to pop
    and then remove it. The code for this has been broken down into separate steps
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the pop() method does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: It mutates the list object to remove an item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also returns the item that was removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This combination of mutation and returning a value is rare, making this method
    distinctive.
  prefs: []
  type: TYPE_NORMAL
- en: Slice assignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can replace items in a list by using a slice expression on the left-hand
    side of the assignment statement. This lets us replace items in a list. When the
    replacement is a different size, it lets us expand or contract a list. This leads
    to a technique for removing items from a list using slice assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start with a row that has an empty value in position 3\. This looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can assign an empty list to the slice that starts at index position 3 and
    ends just before index position 4\. This will replace a one-item slice with a
    zero-item slice, removing the item from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The del statement and methods like remove() and pop() seem to clearly state
    the intent to eliminate an item from the collection. The slice assignment can
    be less clear because it doesn’t have an obvious method name. It does work well,
    however, for removing a number of items that can be described by a slice expression.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because a list is a mutable object, we can remove items from the list. This
    technique doesn’t work for tuples or strings, because they are immutable.
  prefs: []
  type: TYPE_NORMAL
- en: We can only remove items with an index that’s present in the list. If we attempt
    to remove an item with an index outside the allowed range, we’ll get an IndexError
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example tries to delete an item with an index of three from a
    list where the index values are zero, one, and two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 4.4.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few places in Python where deleting from a list object may become
    complicated. If we use a list object in a for statement, we can’t delete items
    from the list. Doing so will lead to unexpected conflicts between the iteration
    control and the underlying object’s internal state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we want to remove all even items from a list. Here’s an example that
    does not work properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The source list had several even values. The result is clearly not correct;
    the values of 10 and 36 remained in the list. Why are some even-valued items left
    in the list?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at what happens when processing data_items[5]; it has a value of
    8\. When the remove(8) method is evaluated, the value will be removed, and all
    the subsequent values will slide forward one position in the list. The 10 value
    will be moved into position 5, the position formerly occupied by the 8 value.
    The iterator control value will advance to the next position, which will have
    13 in it. The 10 value will never be processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have several ways to avoid the skip-when-delete problem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a copy of the list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a while statement and maintain the index value explicitly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve designed a while statement to only increment the position variable if
    the value of data_items[position] is odd. If the value is even, then the value
    is removed, which also means the other items are moved forward one position in
    the list; it’s essential the value of the position variable is left unchanged.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can also traverse the list in reverse order. The expression range(len(row)-1, -1, -1)
    will produce index descending from -1\. This works because negative index values
    work forward from the end of the list. The value row[-1] is the last item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.4.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the [Building lists – literals, appending, and comprehensions](ch008_split_000.xhtml#x1-2310002)
    recipe for ways to create lists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the [Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003) recipe
    for ways to copy lists and pick sublists from a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the [Reversing a copy of a list](ch008_split_001.xhtml#x1-2620006) recipe,
    we’ll look at reversing a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.5 Writing list-related type hints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The typing module provides a few essential type definitions for describing the
    contents of a list object. The primary type definition is list, which we can parameterize
    with the types of items in the list. It often looks like list[int].
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll look at a list that has two kinds of tuples. Some tuples are simple RGB
    colors. Other tuples are RGB colors that are the result of some computations.
    These are built from float values instead of integers. We might have a heterogenous
    list structure that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Each item in the list is a two-tuple with a color name, and a tuple of RGB values.
    The RGB values are represented as a three-tuple of either integer or float values.
    This is potentially difficult to describe with type hints.
  prefs: []
  type: TYPE_NORMAL
- en: We have two related functions that work with this data. The first creates a
    color code from RGB values.
  prefs: []
  type: TYPE_NORMAL
- en: The essential rule is to treat each component, red, green, or blue, as an 8-bit
    number, a value between 0 and 255\. These three are combined by shifting the red
    value by 16 bits and shifting the green value by 8 bits. The Python << operator
    does the necessary bit shifting. The | operator performs an “or” operation, combining
    the shifted bits to create a new integer value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hints for this function aren’t very complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The :06X format specification produces a 6-position hexadecimal value.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative is to treat each color as a separate pair of hex digits with
    an expression like f"#{int(r):02X}{int(g):02X}{int(b):02X}". This uses three copies
    of the :02X format specification to produce 2-position hexadecimal values for
    each color component.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use this function to create a color string from an RGB number, it looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The other function, however, is potentially confusing. This function transforms
    a complex list of colors into another list with the hexadecimal color codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We need to add type hints to be sure this function properly transforms a list
    of colors from numeric form into string code form.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve included a _0 suffix on the function name to distinguish it from the examples
    that follow. This is not a best practice in general, but we find it helps clarify
    the code presented in a book like this.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll start by adding type hints to describe the individual items of the input
    list, exemplified by the scheme variable, shown previously:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the resulting type first. It often helps to focus on the outcomes and
    work backward toward the source data required to produce the expected results.
    In this case, the result is a list of two-tuples with the color name and the hexadecimal
    code for the color. We could describe this as list[tuple[str, str]], but that
    kind of summary hides some important details. We prefer to expose the details
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This list can be seen as being homogeneous; each item will match the ColorCode
    type definition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define the source type. In this case, we have two slightly different kinds
    of color definitions. While they tend to overlap, they have different origins,
    and the processing history is sometimes helpful as part of a type hint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve defined the two integer-based RGB three-tuple as RGB_I, and the float-based
    RGB three-tuple as RGB_F. These two alternative types are combined into the ColorRGB
    tuple definition. This is a two-tuple; the second element may be an instance of
    either the RGB_I type or the RGB_F type. The presence of a Union type means that
    this list is heterogenous.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We could also use RGB_I | RGB_F instead of Union[RGB_I, RGB_F].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the function to include the type hints. The input will be a list like
    the schema object, shown previously. The result will be a list that matches the
    ColorCodeList type description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 4.5.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The list[T] type hint requires a single value, T, to describe all of the object
    types that can be part of this list. For homogeneous lists, the type is stated
    directly. For heterogeneous lists, a Union must be used to define the various
    kinds of types that may be present.
  prefs: []
  type: TYPE_NORMAL
- en: 'The approach we’ve taken breaks type hinting down into two layers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A ”foundation” layer that describes the individual items in a collection. We’ve
    defined three types of primitive items: the RGB_I and RGB_F types, as well as
    the resulting ColorCode type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number of ”composition” layers that combine foundational types into descriptions
    of composite objects. In this case, ColorRGB, ColorRGBList, and ColorCodeList
    are all composite type definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the types have been named, then the names are used with definition functions,
    classes, and methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to define types in stages to avoid long, complex type hints
    that don’t provide any useful insight into the objects being processed. It’s good
    to avoid type descriptions like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: While this is technically correct, it’s difficult to understand because of its
    complexity. It helps to decompose complex types into useful component descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The type hints assume a single type for each item in the list. The syntax list[T]
    states that all items are of type T.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a heterogeneous list, with a number of distinct types, we need
    to define a union of types. We can import the Union type from the typing module.
    Or we can use | to provide the alternative types for a list.
  prefs: []
  type: TYPE_NORMAL
- en: Using a construct like list[RGB_I | RGB_F] describes a list that contains items
    with a mixture of types.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Chapter [1](ch005_split_000.xhtml#x1-170001), the [Using NamedTuples to simplify
    item access in tuples](ch005_split_001.xhtml#x1-7500010) recipe provides some
    alternative ways to clarify types hints for tuples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Writing set-related type hints](ch008_split_001.xhtml#x1-2800009) recipe
    covers this from the view of set types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.6 Reversing a copy of a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some algorithms produce results in a reversed order. It’s common to collect
    the output in a list and then reverse the list. As an example, we’ll look at the
    way numbers converted into a specific base are often generated from least-significant
    to most-significant digit. We generally want to display the values with the most-significant
    digit first. This leads to a need to reverse the sequence of digits in a list.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say we’re doing a conversion among number bases. We’ll look at how a number
    is represented in a base, and how we can compute that representation from a number.
  prefs: []
  type: TYPE_NORMAL
- en: Any value, v, can be defined as a polynomial function of the various digits,
    d[n], in a given base, b. A four-digit number would have ⟨d[3],d[2],d[1],d[0]⟩
    as the sequence of digits.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the order we’re using here is reversed from the usual order of items
    in a Python list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value, v, of this sequence of digits is given by the following polynomial:'
  prefs: []
  type: TYPE_NORMAL
- en: '![v = dn × bn + dn−1 × bn− 1 + dn− 2 × bn−2 + ⋅⋅⋅+ d1 × b+ d0 ](img/file48.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For example, the hexadecimal number 0xBEEF has the following digits: ⟨B = 11,E
    = 14,E = 14,F = 15⟩, with base b = 16:'
  prefs: []
  type: TYPE_NORMAL
- en: '![48879 = 11 × 163 + 14 × 162 + 14× 16 + 15 ](img/file49.png)'
  prefs: []
  type: TYPE_IMG
- en: There are many cases where the base isn’t a consistent power of some number.
    The ISO date format, for example, has a mixed base that involves 7 days per week,
    24 hours per day, 60 minutes per hour, and 60 seconds per minute.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of b⁴, b³, b², b¹ = b, and b⁰ = 1, we have 7 × 24 × 60 × 60, 24 × 60
    × 60, 60 × 60, and 60 as the various values used to compute the polynomial.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a week number, a day of the week, an hour, a minute, and a second, we
    can compute a timestamp of seconds, t[s], within the given year:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ts = (((w × 7 + d)× 24 + h)× 60 + m )× 60 + s ](img/file50.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This shows how we convert from the given moment into a timestamp. How do we
    invert this calculation? How do we get the various fields from the overall timestamp?
  prefs: []
  type: TYPE_NORMAL
- en: We’ll need to use divmod style division. For some background, refer to the [Choosing
    between true division and floor division](ch005_split_000.xhtml#x1-270002) recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm for converting a timestamp in seconds, t[s], into individual
    week, day, and time fields looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| t[m]; s | = ⌊![ts- 60](img/file51.png)⌋; t[s] mod 60 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| t[h]; m | = ⌊![tm- 60](img/file52.png)⌋; t[m] mod 60 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| t[d]; h | = ⌊![th24](img/file53.png)⌋; t[h] mod 24 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| w; d | = ⌊![td7-](img/file54.png)⌋; t[d] mod 7 |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'This has a handy pattern that leads to an implementation. It has the consequence
    of producing the values in reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We’ve applied the divmod() function four times to extract seconds, minutes,
    hours, days, and weeks from a timestamp, given in seconds. These are in the wrong
    order. How can we reverse them?
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have three approaches: we can use the reverse() method, we can use a [::-1]
    slice expression, or we can use the reversed() built-in function. Here’s the reverse()
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We made a copy of the original list so that we could keep an unmutated copy
    to compare with the mutated copy. This makes it easier to follow the examples.
    We applied the reverse() method to reverse a copy of the list.
  prefs: []
  type: TYPE_NORMAL
- en: This will mutate the list. As with other mutating methods, it does not return
    a useful value. It’s incorrect to use a statement like a = b.reverse(); the value
    of a will always be None.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a slice expression with a negative step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we made a slice [::-1] that uses an implied start and stop,
    and a step of -1\. This picks all the items in the list in reverse order to create
    a new list.
  prefs: []
  type: TYPE_NORMAL
- en: The original list is emphatically not mutated by this slice operation. This
    creates a copy. Check the value of the fields variable to see that it’s unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can use the reversed() function to create a reversed copy of
    a list of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: It’s important to use the list() function in this example. The reversed() function
    is a generator, and we need to consume the items from the generator to create
    a new list.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we noted in the [Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003)
    recipe, the slice notation is quite sophisticated. Using a slice with a negative
    step size will create a copy (or a subset) with items processed in right to left
    order, instead of the default left to right order.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to distinguish between these three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The reverse() method modifies the list object itself. As with methods like append()
    and remove(), there is no return value from this method. Because it changes the
    list, it doesn’t return a value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [::-1] slice expression creates a new list. This is a shallow copy of the
    original list, with the order reversed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reversed() function is a generator that yields the values in reverse order.
    When the values are consumed by the list() function, it creates a copy of the
    list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.6.4 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the [Making shallow and deep copies of objects](ch009.xhtml#x1-3160005)
    recipe for more information on what a shallow copy is and why we might want to
    make a deep copy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the [Building lists – literals, appending, and comprehensions](ch008_split_000.xhtml#x1-2310002)
    recipe for ways to create lists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the [Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003) recipe
    for ways to copy lists and pick sublists from a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the [Shrinking lists – deleting, removing, and popping](ch008_split_000.xhtml#x1-2460004)
    recipe for other ways to remove items from a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.7 Building sets – literals, adding, comprehensions, and operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we’ve decided to create a collection based on only an item being present—a
    set—we have several ways of building this structure. Because of the narrow focus
    of sets, there’s no ordering to the items—no relative positions—and items cannot
    be duplicated. We’ll look at a number of ways we can assemble a set collection
    from a source of individual items.
  prefs: []
  type: TYPE_NORMAL
- en: The set operators parallel the operators defined by the mathematics of set theory.
    These can be helpful for doing bulk comparisons between sets. We’ll look at these
    in addition to the methods of the set class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sets have an important constraint: they only contain immutable objects. Informally,
    immutable objects have no internal state that can be changed. Numbers are immutable,
    as are strings, and tuples of immutable objects. Formally, immutable objects have
    an internal hash value, and the hash() function will show this value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how this looks in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The value of the a variable is an immutable string, which has a hash value.
    The b variable, on the other hand, is a mutable list, and doesn’t have a hash
    value. We can create sets of immutable objects like strings, but the TypeError
    exception will be raised if we try to put mutable objects into a set.
  prefs: []
  type: TYPE_NORMAL
- en: 4.7.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say we need to do some analysis of the dependencies among modules in
    a complex application. Here’s one part of the available data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Each item in this list names a module and a list of modules that it imports.
    There are a number of questions we can ask about this collection of relationships
    among modules. We’d like to compute the short list of dependencies, thereby removing
    duplicates from this list.
  prefs: []
  type: TYPE_NORMAL
- en: 4.7.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have many ways to create set objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Literal: We can create literal display of a set using a sequence of values
    surrounded by characters. It looks like this: {value, ... }. Python needs to match
    the { at the start of the literal and } at the end of the literal to see a complete
    logical line, so the literal can span physical lines. For more information, refer
    to the [Writing long lines of code](ch006_split_000.xhtml#x1-910002) recipe in
    Chapter [2](ch006_split_000.xhtml#x1-840002).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we can’t create an empty set with {}; this is an empty dictionary.
    We must use set() to create an empty set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Conversion function: We can convert some other data collection into a set using
    the set() function. We can convert a list of immutable items, or the keys of a
    dict, or a tuple of immutable items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add method: The set method add() will add an item to a set. Additionally, sets
    can be created by a union() method or the | operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Comprehension: A comprehension is a specialized generator expression that describes
    the items in a set using an expression to define membership. We’ll look at this
    in detail in the [Writing a set comprehension](ch008_split_001.xhtml#x1-2710002)
    section of this recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two ways to create sets are single Python expressions. The last two
    are more complex, and we’ll show recipes for each of them.
  prefs: []
  type: TYPE_NORMAL
- en: Building a set with the add method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our source collection of data is a list with sublists. We want to summarize
    the items inside each of the sublists:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an empty set into which items can be added. Unlike lists, there’s no
    abbreviated syntax for an empty set, so we must use the set() function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write a for statement to iterate through each two-tuple in the import_details
    collection. This needs a nested for statement to iterate through each name in
    the list of imports in each pair. Use the add() method of the all_imports set
    to create a complete set with duplicates removed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This result summarizes many lines of details, showing the set of distinct items
    imported. Note that the order here is arbitrary and can vary each time the example
    is executed.
  prefs: []
  type: TYPE_NORMAL
- en: The arbitrary ordering means a doctest example to confirm the correctness of
    this code can’t simply show the expected result. See the [Handling common doctest
    issues](ch019_split_000.xhtml#x1-8100003) recipe in Chapter [15](ch019_split_000.xhtml#x1-79400015)
    for more advice on using doctest.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a set comprehension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The goal of a set comprehension is to create an object that occupies a syntax
    role, similar to a set literal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the wrapping braces that surround the set object to be built:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the source of the data. This will include the target variable. We have
    two nested lists, so we’ll need to use two for clauses. Note that there’s no :
    at the end of the for clause because we’re not writing a complete statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For now, we’ve written the result of the expression as the special Ellipsis
    object. Once we finish this expression, we will replace it with something more
    useful.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Prefix the for clause with the expression to evaluate that creates each value
    of the target collection. In this case, we only want the name from the import
    list within each pair of items in the overall import details list-of-lists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A set comprehension cannot have duplicates, so this will always have distinct
    values.
  prefs: []
  type: TYPE_NORMAL
- en: As with the list comprehension, a set comprehension is built around a central
    generator expression. The generator expression at the heart of the comprehension
    has a data expression clause and a for clause.
  prefs: []
  type: TYPE_NORMAL
- en: We can replace the enclosing { and } syntax with the set() function. Using the
    explicit set() function had an advantage when we consider the possibility of changing
    the data structure. We can easily replace set() with frozenset(), list(), or Counter().
  prefs: []
  type: TYPE_NORMAL
- en: 4.7.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A set is a collection of immutable objects. Each immutable Python object has
    a hash value, and these numeric hash codes are used to optimize locating items
    in a set. We can imagine the implementation relies on an array of buckets, and
    the numeric hash value directs us to a bucket to see if the item is present in
    that bucket or not.
  prefs: []
  type: TYPE_NORMAL
- en: Hash values are not necessarily unique. The array of hash buckets is finite,
    meaning hash collisions are possible. A collision occurs when two distinct objects
    both have the same hash value. This leads to some overhead to handle any collisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create two integers that will have a hash collision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In spite of these two objects having the same hash value, hash collision processing
    will keep these two objects separate from each other in a set.
  prefs: []
  type: TYPE_NORMAL
- en: 4.7.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have several ways to add items to a set:'
  prefs: []
  type: TYPE_NORMAL
- en: The example used the add() method. This works with a single item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the union() method. This method is like an operator—it creates a
    new result set. It does not mutate either of the operand sets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the update() method to update one set with items from another set.
    This mutates a set and does not return a value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For most of these techniques, we’ll need to create a singleton set from the
    item we’re going to add. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we’ve created a singleton set, {item}, from the value
    of the item variable. We then used the union() method to compute a new set, which
    is the union of the collection set and the {item} set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that union() creates a new object and leaves the original collection untouched.
    Here is yet another alternative that uses the union operator, |:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the update() method to mutate the set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Methods like update() and add() mutate the set object. Because they mutate the
    set, they do not return a value. This is similar to the way methods of the list
    collection work. Generally, a method that mutates the collection does not return
    a value. The only exception to this pattern is the pop() method, which both mutates
    the set object and returns the popped value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has a number of set operators. These are ordinary operator symbols that
    we can use in complex set expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| for set union, often typeset as A ∪ B'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '& for set intersection, often typeset as A ∩ B'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^ for set symmetric difference, often typeset as A △ B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '- for set subtraction, often typeset as A ∖ B'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.7.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Shrinking sets – remove(), pop(), and difference](ch008_split_001.xhtml#x1-2750008)
    recipe, we’ll look at how we can update a set by removing or replacing items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.8 Shrinking sets – remove(), pop(), and difference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python gives us several ways to remove items from a set collection. We can use
    the remove() method to remove a specific item. We can use the pop() method to
    remove (and return) an arbitrary item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we can compute a new set using the set intersection, difference,
    and symmetric difference operators: &, -, and ^. These will produce a new set
    that is a subset of a given input set.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.8.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, we’ll have log files that contain lines with complex and varied
    formats. Here’s a small snippet from a long, complex log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We need to find all of the text similar to IP: 111.222.111.222 in this log.
    These are IPv4 addresses with 4 numeric fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can create a set of matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The problem we have with this log is extraneous matches. The log file also has
    text that looks similar but are dummy or placeholder values we need to ignore.
    In the full log, we’ll also find lines containing text like IP: 1.2.3.4, which
    is a placeholder, not a meaningful address. It turns out that there is a small
    set of irrelevant values.
  prefs: []
  type: TYPE_NORMAL
- en: This is a place where set intersection and set subtraction can be very helpful.
  prefs: []
  type: TYPE_NORMAL
- en: 4.8.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a set of items we’d like to ignore as a set literal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Collect all entries from the log. We’ll use the re module for this, as shown
    earlier. We’ll see results like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove items from the set of matches using set subtraction. Here are two examples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Both of these are operators that return new sets as their results. Neither of
    these will mutate the underlying set objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It turns out the difference() method can work with any iterable collection,
    including lists and tuples. While permitted, mixing sets and lists can be confusing,
    and it can be challenging to write type hints for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll often use these in statements, like this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This will assign the resulting set to a new variable, valid_matches, so that
    we can do the required processing on this new set.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the remove() and pop() methods to remove specific items. The
    remove() method raises an exception when an item cannot be removed. We can use
    this behavior to both confirm that an item is in the set and remove it.
  prefs: []
  type: TYPE_NORMAL
- en: 4.8.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A set object tracks membership of items. An item is either in the set or not.
    We specify the item we want to remove. Removing an item doesn’t depend on an index
    position or a key value.
  prefs: []
  type: TYPE_NORMAL
- en: The set operators permit sophisticated set computations. We can remove any of
    the items in one set from a target set computing set difference or set subtraction.
  prefs: []
  type: TYPE_NORMAL
- en: 4.8.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have several other ways to remove items from a set:'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we used the difference() method and the - operator. The difference()
    method behaves like an operator and creates a new set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also use the difference_update() method. This will mutate a set in place.
    It does not return a value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can remove an individual item with the remove() method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also remove an arbitrary item with the pop() method. This doesn’t apply
    to this example very well because we can’t control which item is popped from a
    set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s how the difference_update() method looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We applied the difference_update() method to remove the undesirable items from
    the valid_matches set. Since the valid_matches set was mutated, no value is returned.
    Also, since the set is a copy, this operation doesn’t modify the original matches
    set.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could do something like the following example to use the remove() method.
    Note that remove() will raise an exception if an item is not present in the set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We tested to see if the item was in the valid_matches set before attempting
    to remove it. Using an if statement is one way to avoid raising a KeyError exception.
    An alternative is to use a try: statement to silence the exception that’s raised
    when an item is not present.'
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the pop() method to remove an arbitrary item. This method is
    unusual in that it both mutates the set and returns the item that was removed.
    However, we can’t control which item is popped, making it inappropriate for this
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 4.9 Writing set-related type hints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The typing module provides a few essential type definitions for describing the
    contents of a set object. The primary type definition is set, which we can parameterize
    with the types of items in the set. We’ll use set[int] to describe a set composed
    of integers. This parallels the Writing list-related type hints recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 4.9.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A dice game like Zonk (also called 10,000 or Greed) requires a random collection
    of dice to be grouped into ”hands.” While rules vary, there a several patterns
    for hands, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Three of a kind.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A “small straight” of five ascending dice (1-2-3-4-5 or 2-3-4-5-6 are the two
    combinations).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A “large straight” of six ascending dice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An “ace” hand. This has at least one 1 die that’s not part of a three of a kind
    or straight.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Six of a kind. While rare, it’s not impossible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll use the following class and function definitions to create the hands
    of dice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The Die class definition enumerates the six faces of a standard die by providing
    the Unicode character with the appropriate value.
  prefs: []
  type: TYPE_NORMAL
- en: When we evaluate the zonk() function, it looks like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This shows us a hand with two sixes, two ones, a two, and a three. When examining
    the hand for patterns, we will often create complex sets of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 4.9.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A function to do analysis of the patterns of dice works by creating a set[Die]
    object from the six dice instances. This set reveals a great deal of information:'
  prefs: []
  type: TYPE_NORMAL
- en: When there is one die in the set of unique values, then all six dice have the
    same value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When there are five distinct dice in the set of unique values, then this could
    be a small straight. This requires an additional check to see if the set of unique
    values is 1-5 or 2-6, which are the two valid small straights.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When there are six distinct items in the set of unique values, then this must
    be a large straight.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For two unique dice values there will be at least one three of a kind. There
    may be a four or five of a kind, but these are scored as a three of a kind and
    the remaining dice are non-scoring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For three or four unique dice in the set, there may be a three of a kind. More
    detailed analysis of the set is required to see the exact pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can distinguish many of the patterns by looking at the cardinality of the
    set of distinct dice. The remaining distinctions can be made by looking at the
    pattern of counts. For this, a collections.Counter object will be useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to write this set-based analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the type for each item in the set. In this example, the Die class is
    the item class. We’ll work with set[Die] and Counter[Die] types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the set object with the unique values from the hand of Die instances.
    Here’s how the evaluation function can begin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are two small straight definitions: 1-5 and 2-6:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can build these two sets in the body of the analysis function to show how
    they’re used. Pragmatically, the value of small_straights should be computed only
    once.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can’t build a set of these two set instances because set objects are mutable.
    We could build a set of two frozenset objects instead of building a list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Examine the simple cases. The number of distinct elements in the set identifies
    several kinds of hands directly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When there are three or four distinct values, the patterns can be summarized
    using the counts. This pattern of frequency counts can be summarized as a set[int]:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the cases of three or four distinct Die values, these can form a variety
    of patterns. If at least one of the Die has a frequency of three or four, that’s
    a scoring combination. If nothing else matches and there’s a die showing a one,
    that’s a minimal score:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Are there any conditions left over? Does this cover all the possible cardinalities
    of dice and frequencies of dice? The remaining cases includes collections of pairs
    and singletons without any ”one” showing. After the above if statement, we can
    provide a single return statement to collect all other cases into a single, non-scoring
    Zonk:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This shows two ways of using sets to evaluate the pattern of a collection of
    data items. The first set, set[Die], looked at the overall pattern of unique Die
    values. The second set, set[int], looked at the pattern of frequencies of Die
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 4.9.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The essential property of a set is membership. When we compute a set from a
    collection of Die instances, we used the set[Die] type hint to describe this structure.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when we look at the distribution of frequencies, there are only a
    few distinct patterns. Transforming the counts into a set of values into a collection
    with the set[int] type hint described this additional structure.
  prefs: []
  type: TYPE_NORMAL
- en: 4.9.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A set of items that don’t have a single, uniform type is potentially confusing.
    We can use set[T1 | T2] to describe a set where items can be any of the types
    T1 or T2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Computing the score of the hand of dice depends on which dice were part of
    the winning pattern. This means the evaluation function needs to return a more
    complex result when the outcome is a three of a kind. To determine the points,
    there are three cases we need to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Which value of the Dice class occurred three or six times. This determines the
    base score. Often, 1s are given 1,000 points, and 2 through 6 are given 200 through
    600 points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s possible to roll two triples; this pattern must be distinguished, too.
    This often scores 2,000 points, irrespective of the numbers shown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the straights and the “ace” hand, simple fixed scores are assigned. A small
    straight might be 1,000 points. A large straight 2,000\. A lone 1 might score
    only 50 points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have two separate conditions to identify the patterns of unique values indicating
    a three-of-a-kind pattern. The function needs some refactoring to properly identify
    the values of the dice occurring three or more times and the values of the dice
    which were ignored. We’ve left this additional design as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 4.9.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the [Writing list-related type hints](ch008_split_001.xhtml#x1-2560005)
    recipe in this chapter for more about type hints for lists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community Discord space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
