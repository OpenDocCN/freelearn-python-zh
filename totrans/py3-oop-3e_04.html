<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Expecting the Unexpected</h1>
                </header>
            
            <article>
                
<p>Programs are very fragile. It would be ideal if code always returned a valid result, but sometimes a valid result can't be calculated. For example, it's not possible to divide by zero, or to access the eighth item in a five-item list.</p>
<p>In the old days, the only way around this was to rigorously check the inputs for every function to make sure they made sense. Typically, functions had special return values to indicate an error condition; for example, they could return a negative number to indicate that a positive value couldn't be calculated. Different numbers might mean different errors occurred. Any code that called this function would have to explicitly check for an error condition and act accordingly. A lot of developers didn't bother to do this, and programs simply crashed. However, in the object-oriented world, this is not the case.</p>
<p>In this chapter, we will study <strong>exceptions</strong>, special error objects that only need to be handled when it makes sense to handle them. In particular, we will cover the following:</p>
<ul>
<li>How to cause an exception to occur</li>
<li>How to recover when an exception has occurred</li>
<li>How to handle different exception types in different ways</li>
<li>Cleaning up when an exception has occurred</li>
<li>Creating new types of exception</li>
<li>Using the exception syntax for flow control</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Raising exceptions</h1>
                </header>
            
            <article>
                
<p>In principle, an exception is just an object. There are many different exception classes available, and we can easily define more of our own. The one thing they all have in common is that they inherit from a built-in class called <kbd>BaseException</kbd>. These exception objects become special when they are handled inside the program's flow of control. When an exception occurs, everything that was supposed to happen doesn't happen, unless it was supposed to happen when an exception occurred. Make sense? Don't worry, it will!</p>
<p>The easiest way to cause an exception to occur is to do something silly. Chances are you've done this already and seen the exception output. For example, any time Python encounters a line in your program that it can't understand, it bails with <kbd>SyntaxError</kbd>, which is a type of exception. Here's a common one:</p>
<pre><strong>&gt;&gt;&gt; print "hello world"</strong>
<strong>  File "&lt;stdin&gt;", line 1</strong>
<strong>    print "hello world"</strong>
<strong>                      ^</strong>
<strong>SyntaxError: invalid syntax</strong>  </pre>
<p>This <kbd>print</kbd> statement was a valid command way back in the Python 2 and earlier days, but in Python 3, because <kbd>print</kbd> is a function, we have to enclose the arguments in parentheses. So, if we type the preceding command into a Python 3 interpreter, we get <kbd>SyntaxError</kbd>.</p>
<p>In addition to <kbd>SyntaxError</kbd>, some other common exceptions are shown in the following example:</p>
<pre><strong>&gt;&gt;&gt; x = 5 / 0</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>ZeroDivisionError: int division or modulo by zero</strong>

<strong>&gt;&gt;&gt; lst = [1,2,3]</strong>
<strong>&gt;&gt;&gt; print(lst[3])</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>IndexError: list index out of range</strong>

<strong>&gt;&gt;&gt; lst + 2</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>TypeError: can only concatenate list (not "int") to list</strong>

<strong>&gt;&gt;&gt; lst.add</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>AttributeError: 'list' object has no attribute 'add'</strong>

<strong>&gt;&gt;&gt; d = {'a': 'hello'}</strong>
<strong>&gt;&gt;&gt; d['b']</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>KeyError: 'b'</strong>

<strong>&gt;&gt;&gt; print(this_is_not_a_var)</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>NameError: name 'this_is_not_a_var' is not defined</strong>  </pre>
<p>Sometimes, these exceptions are indicators of something wrong in our program (in which case, we would go to the indicated line number and fix it), but they also occur in legitimate situations. A <kbd>ZeroDivisionError</kbd> error doesn't always mean we received an invalid input. It could also mean we have received a different input. The user may have entered a zero by mistake, or on purpose, or it may represent a legitimate value, such as an empty bank account or the age of a newborn child.</p>
<p>You may have noticed all the preceding built-in exceptions end with the name <kbd>Error</kbd>. In Python, the words <kbd>error</kbd> and <kbd>Exception</kbd> are used almost interchangeably. Errors are sometimes considered more dire than exceptions, but they are dealt with in exactly the same way. Indeed, all the error classes in the preceding example have <kbd>Exception</kbd> (which extends <kbd>BaseException</kbd>) as their superclass.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Raising an exception</h1>
                </header>
            
            <article>
                
<p>We'll get to responding to such exceptions in a minute, but first, let's discover what we should do if we're writing a program that needs to inform the user or a calling function that the inputs are invalid. We can use the exact same mechanism that Python uses. Here's a simple class that adds items to a list only if they are even numbered integers:</p>
<pre>class EvenOnly(list): 
    def append(self, integer): 
        if not isinstance(integer, int): 
<strong>            raise TypeError("Only integers can be added")</strong> 
        if integer % 2: 
<strong>            raise ValueError("Only even numbers can be added")</strong> 
        super().append(integer) </pre>
<p>This class extends the <kbd>list</kbd> built-in, as we discussed in <a href="0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Objects in Python</em>, and overrides the <kbd>append</kbd> method to check two conditions that ensure the item is an even integer. We first check whether the input is an instance of the <kbd>int</kbd> type, and then use the modulus operator to ensure it is divisible by two. If either of the two conditions is not met, the <kbd>raise</kbd> keyword causes an exception to occur. The <kbd>raise</kbd> keyword is followed by the object being raised as an exception. In the preceding example, two objects are constructed from the built-in <kbd>TypeError</kbd> and <kbd>ValueError</kbd> classes. The raised object could just as easily be an instance of a new <kbd>Exception</kbd> class we create ourselves (we'll see how shortly), an exception that was defined elsewhere, or even an <kbd>Exception</kbd> object that has been previously raised and handled.</p>
<p>If we test this class in the Python interpreter, we can see that it is outputting useful error information when exceptions occur, just as before:</p>
<pre><strong>&gt;&gt;&gt; e = EvenOnly()</strong>
<strong>&gt;&gt;&gt; e.append("a string")</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>  File "even_integers.py", line 7, in add</strong>
<strong>    raise TypeError("Only integers can be added")</strong>
<strong>TypeError: Only integers can be added</strong>

<strong>&gt;&gt;&gt; e.append(3)</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>  File "even_integers.py", line 9, in add</strong>
<strong>    raise ValueError("Only even numbers can be added")</strong>
<strong>ValueError: Only even numbers can be added</strong>
<strong>&gt;&gt;&gt; e.append(2)</strong></pre>
<div class="packt_infobox">While this class is effective for demonstrating exceptions in action, it isn't very good at its job. It is still possible to get other values into the list using index notation or slice notation. This can all be avoided by overriding other appropriate methods, some of which are magic double-underscore methods.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The effects of an exception</h1>
                </header>
            
            <article>
                
<p>When an exception is raised, it appears to stop program execution immediately. Any lines that were supposed to run after the exception is raised are not executed, and unless the exception is dealt with, the program will exit with an error message. Take a look at this basic function:</p>
<pre>def no_return(): 
    print("I am about to raise an exception") 
    raise Exception("This is always raised") 
    print("This line will never execute") 
    return "I won't be returned" </pre>
<p>If we execute this function, we see that the first <kbd>print</kbd> call is executed and then the exception is raised. The second <kbd>print</kbd> function call is never executed, nor is the <kbd>return</kbd> statement:</p>
<pre><strong>&gt;&gt;&gt; no_return()</strong>
<strong>I am about to raise an exception</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>  File "exception_quits.py", line 3, in no_return</strong>
<strong>    raise Exception("This is always raised")</strong>
<strong>Exception: This is always raised</strong>  </pre>
<p>Furthermore, if we have a function that calls another function that raises an exception, nothing is executed in the first function after the point where the second function was called. Raising an exception stops all execution right up through the function call stack until it is either handled or forces the interpreter to exit. To demonstrate, let's add a second function that calls the earlier one:</p>
<pre>def call_exceptor(): 
    print("call_exceptor starts here...") 
    no_return() 
    print("an exception was raised...") 
    print("...so these lines don't run") </pre>
<p>When we call this function, we see that the first <kbd>print</kbd> statement executes, as well as the first line in the <kbd>no_return</kbd> function. But once the exception is raised, nothing else executes:</p>
<pre><strong>&gt;&gt;&gt; call_exceptor()</strong>
<strong>call_exceptor starts here...</strong>
<strong>I am about to raise an exception</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>  File "method_calls_excepting.py", line 9, in call_exceptor</strong>
<strong>    no_return()</strong>
<strong>  File "method_calls_excepting.py", line 3, in no_return</strong>
<strong>    raise Exception("This is always raised")</strong>
<strong>Exception: This is always raised</strong>  </pre>
<p>We'll soon see that when the interpreter is not actually taking a shortcut and exiting immediately, we can react to and deal with the exception inside either method. Indeed, exceptions can be handled at any level after they are initially raised.</p>
<p>Look at the exception's output (called a traceback) from bottom to top, and notice how both methods are listed. Inside <kbd>no_return</kbd>, the exception is initially raised. Then, just above that, we see that inside <kbd>call_exceptor</kbd>, that pesky <kbd>no_return</kbd> function was called and the exception <em>bubbled up</em> to the calling method. From there, it went up one more level to the main interpreter, which, not knowing what else to do with it, gave up and printed a traceback.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling exceptions</h1>
                </header>
            
            <article>
                
<p>Now let's look at the tail side of the exception coin. If we encounter an exception situation, how should our code react to or recover from it? We handle exceptions by wrapping any code that might throw one (whether it is exception code itself, or a call to any function or method that may have an exception raised inside it) inside a <kbd>try...except</kbd> clause. The most basic syntax looks like this:</p>
<pre>try: 
    no_return() 
<strong>except:</strong> 
    print("I caught an exception") 
print("executed after the exception") </pre>
<p>If we run this simple script using our existing <kbd>no_return</kbd> function—which, as we know very well, always throws an exception—we get this output:</p>
<pre><strong>I am about to raise an exception 
I caught an exception 
executed after the exception</strong> </pre>
<p>The <kbd>no_return</kbd> function happily informs us that it is about to raise an exception, but we fooled it and caught the exception. Once caught, we were able to clean up after ourselves (in this case, by outputting that we were handling the situation), and continue on our way, with no interference from that offensive function. The remainder of the code in the <kbd>no_return</kbd> function still went unexecuted, but the code that called the function was able to recover and continue.</p>
<div class="packt_infobox">Note the indentation around <kbd>try</kbd> and <kbd>except</kbd>. The <kbd>try</kbd> clause wraps any code that might throw an exception. The <kbd>except</kbd> clause is then back on the same indentation level as the <kbd>try</kbd> line. Any code to handle the exception is indented after the <kbd>except</kbd> clause. Then normal code resumes at the original indentation level.</div>
<p>The problem with the preceding code is that it will catch any type of exception. What if we were writing some code that could raise both <kbd>TypeError</kbd> and <kbd>ZeroDivisionError</kbd>? We might want to catch <kbd>ZeroDivisionError</kbd>, but let <kbd>TypeError</kbd> propagate to the console. Can you guess the syntax?</p>
<p>Here's a rather silly function that does just that:</p>
<pre>def funny_division(divider):<br/>    try:<br/>        return 100 / divider<br/><strong>    except ZeroDivisionError:</strong><br/>        return "Zero is not a good idea!"<br/><br/><br/>print(funny_division(0))<br/>print(funny_division(50.0))<br/>print(funny_division("hello"))</pre>
<p>The function is tested with the <kbd>print</kbd> statements that show it behaving as expected:</p>
<pre><strong>Zero is not a good idea!</strong>
<strong>2.0</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "catch_specific_exception.py", line 9, in &lt;module&gt;</strong>
<strong>    print(funny_division("hello"))</strong>
<strong>  File "catch_specific_exception.py", line 3, in funny_division</strong>
<strong>    return 100 / </strong><strong>divider</strong>
<strong>TypeError: unsupported operand type(s) for /: 'int' and 'str'.</strong>  </pre>
<p>The first line of output shows that if we enter <kbd>0</kbd>, we get properly mocked. If we call with a valid number (note that it's not an integer, but it's still a valid divisor), it operates correctly. Yet if we enter a string (you were wondering how to get a <kbd>TypeError</kbd>, weren't you?), it fails with an exception. If we had used an empty <kbd>except</kbd> clause that didn't specify a <kbd>ZeroDivisionError</kbd>, it would have accused us of dividing by zero when we sent it a string, which is not a proper behavior at all.</p>
<div class="packt_tip">The <em>bare except</em> syntax is generally frowned upon, even if you really do want to catch all instances of an exception. Use the <kbd>except Exception:</kbd> syntax to explicitly catch all exception types. This tell the reader that you meant to catch exception objects and all subclasses of <kbd>Exception</kbd>. The bare except syntax is actually the same as using <kbd>except BaseException:</kbd>, which actually catches system-level exceptions that are very rare to intentionally want to catch, as we'll see in the next section. If you really do want to catch them, explicitly use <kbd>except BaseException:</kbd> so that anyone who reads your code knows that you didn't just forget to specify what kind of exception you wanted.</div>
<p>We can even catch two or more different exceptions and handle them with the same code. Here's an example that raises three different types of exception. It handles <kbd>TypeError</kbd> and <kbd>ZeroDivisionError</kbd> with the same exception handler, but it may also raise a <kbd>ValueError</kbd> error if you supply the number <kbd>13</kbd>:</p>
<pre>def funny_division2(divider):<br/>    try:<br/>        if divider == 13:<br/>            raise ValueError("13 is an unlucky number")<br/>        return 100 / divider<br/><strong>    except (ZeroDivisionError, TypeError):</strong><br/>        return "Enter a number other than zero"<br/><br/><br/>for val in (0, "hello", 50.0, 13):<br/><br/>    print("Testing {}:".format(val), end=" ")<br/>    print(funny_division2(val))</pre>
<p>The <kbd>for</kbd> loop at the bottom loops over several test inputs and prints the results. If you're wondering about that <kbd>end</kbd> argument in the <kbd>print</kbd> statement, it just turns the default trailing newline into a space so that it's joined with the output from the next line. Here's a run of the program:</p>
<pre><strong>Testing 0: Enter a number other than zero</strong>
<strong>Testing hello: Enter a number other than zero</strong>
<strong>Testing 50.0: 2.0</strong>
<strong>Testing 13: Traceback (most recent call last):</strong>
<strong>  File "catch_multiple_exceptions.py", line 11, in &lt;module&gt;</strong>
<strong>    print(funny_division2(val))</strong>
<strong>  File "catch_multiple_exceptions.py", line 4, in funny_division2</strong>
<strong>    raise ValueError("13 is an unlucky number")</strong>
<strong>ValueError: 13 is an unlucky number</strong>  </pre>
<p>The number <kbd>0</kbd> and the string are both caught by the <kbd>except</kbd> clause, and a suitable error message is printed. The exception from the number <kbd>13</kbd> is not caught because it is a <kbd>ValueError</kbd>, which was not included in the types of exceptions being handled. This is all well and good, but what if we want to catch different exceptions and do different things with them? Or maybe we want to do something with an exception and then allow it to continue to bubble up to the parent function, as if it had never been caught?</p>
<p>We don't need any new syntax to deal with these cases. It's possible to stack the <kbd>except</kbd> clauses, and only the first match will be executed. For the second question, the <kbd>raise</kbd> keyword, with no arguments, will re-raise the last exception if we're already inside an exception handler. Observe the following code:</p>
<pre>def funny_division3(divider):<br/>    try:<br/>        if divider == 13:<br/>            raise ValueError("13 is an unlucky number")<br/>        return 100 / divider<br/><strong>    except ZeroDivisionError:</strong><br/>        return "Enter a number other than zero"<br/><strong>    except TypeError:</strong><br/>        return "Enter a numerical value"<br/><strong>    except ValueError:</strong><br/>        print("No, No, not 13!")<br/>        raise</pre>
<p>The last line re-raises the <kbd>ValueError</kbd> error, so after outputting <kbd>No, No, not 13!</kbd>, it will raise the exception again; we'll still get the original stack trace on the console.</p>
<p>If we stack exception clauses like we did in the preceding example, only the first matching clause will be run, even if more than one of them fits. How can more than one clause match? Remember that exceptions are objects, and can therefore be subclassed. As we'll see in the next section, most exceptions extend the <kbd>Exception</kbd> class (which is itself derived from <kbd>BaseException</kbd>). If we catch <kbd>Exception</kbd> before we catch <kbd>TypeError</kbd>, then only the <kbd>Exception</kbd> handler will be executed, because <kbd>TypeError</kbd> is an <kbd>Exception</kbd> by inheritance.</p>
<p>This can come in handy in cases where we want to handle some exceptions specifically, and then handle all remaining exceptions as a more general case. We can simply catch <kbd>Exception</kbd> after catching all the specific exceptions and handle the general case there.</p>
<p>Often, when we catch an exception, we need a reference to the <kbd>Exception</kbd> object itself. This most often happens when we define our own exceptions with custom arguments, but can also be relevant with standard exceptions. Most exception classes accept a set of arguments in their constructor, and we might want to access those attributes in the exception handler. If we define our own <kbd>Exception</kbd> class, we can even call custom methods on it when we catch it. The syntax for capturing an exception as a variable uses the <kbd>as</kbd> keyword:</p>
<pre>try: 
    raise ValueError("This is an argument") 
except ValueError as e: 
    print("The exception arguments were", e.args) </pre>
<p>If we run this simple snippet, it prints out the string argument that we passed into <kbd>ValueError</kbd> upon initialization.</p>
<p>We've seen several variations on the syntax for handling exceptions, but we still don't know how to execute code regardless of whether or not an exception has occurred. We also can't specify code that should be executed <strong>only</strong> if an exception does <strong>not</strong> occur. Two more keywords, <kbd>finally</kbd> and <kbd>else</kbd>, can provide the missing pieces. Neither one takes any extra arguments. The following example randomly picks an exception to throw and raises it. Then some not-so-complicated exception handling code runs that illustrates the newly introduced syntax:</p>
<pre>import random 
some_exceptions = [ValueError, TypeError, IndexError, None] 
 
try: 
    choice = random.choice(some_exceptions) 
    print("raising {}".format(choice)) 
    if choice: 
        raise choice("An error") 
except ValueError: 
    print("Caught a ValueError") 
except TypeError: 
    print("Caught a TypeError") 
except Exception as e: 
    print("Caught some other error: %s" % 
        ( e.__class__.__name__)) 
<strong>else:</strong> 
    print("This code called if there is no exception") 
<strong>finally:</strong> 
    print("This cleanup code is always called") </pre>
<p>If we run this example—which illustrates almost every conceivable exception handling scenario—a few times, we'll get different output each time, depending on which exception <kbd>random</kbd> chooses. Here are some example runs:</p>
<pre><strong>$ python finally_and_else.py</strong>
<strong>raising None</strong>
<strong>This code called if there is no exception</strong>
<strong>This cleanup code is always called</strong>

<strong>$ python finally_and_else.py</strong>
<strong>raising &lt;class 'TypeError'&gt;</strong>
<strong>Caught a TypeError</strong>
<strong>This cleanup code is always called</strong>
    
<strong>$ python finally_and_else.py</strong>
<strong>raising &lt;class 'IndexError'&gt;</strong>
<strong>Caught some other error: IndexError</strong>
<strong>This cleanup code is always called</strong>
 
<strong>$ python finally_and_else.py</strong>
<strong>raising &lt;class 'ValueError'&gt;</strong>
<strong>Caught a ValueError</strong>
<strong>This cleanup code is always called</strong>  </pre>
<p>Note how the <kbd>print</kbd> statement in the <kbd>finally</kbd> clause is executed no matter what happens. This is extremely useful when we need to perform certain tasks after our code has finished running (even if an exception has occurred). Some common examples include the following:</p>
<ul>
<li>Cleaning up an open database connection</li>
<li>Closing an open file</li>
<li>Sending a closing handshake over the network</li>
</ul>
<div class="packt_infobox">The <kbd>finally</kbd> clause is also very important when we execute a <kbd>return</kbd> statement from inside a <kbd>try</kbd> clause. The <kbd>finally</kbd> handler will still be executed before the value is returned without executing any code following the <kbd>try...finally</kbd> clause.</div>
<p>Also, pay attention to the output when no exception is raised: both the <kbd>else</kbd> and the <kbd>finally</kbd> clauses are executed. The <kbd>else</kbd> clause may seem redundant, as the code that should be executed only when no exception is raised could just be placed after the entire <kbd>try...except</kbd> block. The difference is that the <kbd>else</kbd> block will not be executed if an exception is caught and handled. We'll see more on this when we discuss using exceptions as flow control later.</p>
<p>Any of the <kbd>except</kbd>, <kbd>else</kbd>, and <kbd>finally</kbd> clauses can be omitted after a <kbd>try</kbd> block (although <kbd>else</kbd> by itself is invalid). If you include more than one, the <kbd>except</kbd> clauses must come first, then the <kbd>else</kbd> clause, with the <kbd>finally</kbd> clause at the end. The order of the <kbd>except</kbd> clauses normally goes from most specific to most generic.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The exception hierarchy</h1>
                </header>
            
            <article>
                
<p>We've already seen several of the most common built-in exceptions, and you'll probably encounter the rest over the course of your regular Python development. As we noticed earlier, most exceptions are subclasses of the <kbd>Exception</kbd> class. But this is not true of all exceptions. <kbd>Exception</kbd> itself actually inherits from a class called <kbd>BaseException</kbd>. In fact, all exceptions must extend the <kbd>BaseException</kbd> class or one of its subclasses.</p>
<p>There are two key built-in the exception classes, <kbd>SystemExit</kbd> and <kbd>KeyboardInterrupt</kbd>, that derive directly from <kbd>BaseException</kbd> instead of <kbd>Exception</kbd>. The <kbd>SystemExit</kbd> exception is raised whenever the program exits naturally, typically because we called the <kbd>sys.exit</kbd> function somewhere in our code (for example, when the user selected an exit menu item, clicked the <em>Close</em> button on a window, or entered a command to shut down a server). The exception is designed to allow us to clean up code before the program ultimately exits. However, we generally don't need to handle it explicitly because cleanup code can happen inside a <kbd>finally</kbd> clause.</p>
<p>If we do handle it, we would normally re-raise the exception, since catching it would stop the program from exiting. There are, of course, situations where we might want to stop the program exiting; for example, if there are unsaved changes and we want to prompt the user if they really want to exit. Usually, if we handle <kbd>SystemExit</kbd> at all, it's because we want to do something special with it, or are anticipating it directly. We especially don't want it to be accidentally caught in generic clauses that catch all normal exceptions. This is why it derives directly from <kbd>BaseException</kbd>.</p>
<p>The <kbd>KeyboardInterrupt</kbd> exception is common in command-line programs. It is thrown when the user explicitly interrupts program execution with an OS-dependent key combination (normally, <em><span class="KeyPACKT">Ctrl</span></em> + <em><span class="KeyPACKT">C</span></em>). This is a standard way for the user to deliberately interrupt a running program, and like <kbd>SystemExit</kbd>, it should almost always respond by terminating the program. Also, like <kbd>SystemExit</kbd>, it should handle any cleanup tasks inside the <kbd>finally</kbd> blocks.</p>
<p>Here is a class diagram that fully illustrates the hierarchy:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/3740a42f-0a0e-4bd7-869e-c22c3f71204f.png" style="width:23.67em;height:11.92em;"/></div>
<p>When we use the <kbd>except:</kbd> clause without specifying any type of exception, it will catch all subclasses of <kbd>BaseException</kbd>; which is to say, it will catch all exceptions, including the two special ones. Since we almost always want these to get special treatment, it is unwise to use the <kbd>except:</kbd> statement without arguments. If you want to catch all exceptions other than <kbd>SystemExit</kbd> and <kbd>KeyboardInterrupt</kbd>, explicitly catch <kbd>Exception</kbd>. Most Python developers assume that <kbd>except:</kbd> without a type is an error and will flag it in code review. If you really do want to catch everything, just explicitly use <kbd>except BaseException:</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining our own exceptions</h1>
                </header>
            
            <article>
                
<p>Occasionally, when we want to raise an exception, we find that none of the built-in exceptions are suitable. Luckily, it's trivial to define new exceptions of our own. The name of the class is usually designed to communicate what went wrong, and we can provide arbitrary arguments in the initializer to include additional information.</p>
<p>All we have to do is inherit from the <kbd>Exception</kbd> class. We don't even have to add any content to the class! We can, of course, extend <kbd>BaseException</kbd> directly, but I have never encountered a use case where this would make sense.</p>
<p>Here's a simple exception we might use in a banking application:</p>
<pre>class InvalidWithdrawal(Exception): 
    pass 
 
raise InvalidWithdrawal("You don't have $50 in your account") </pre>
<p>The last line illustrates how to raise the newly defined exception. We are able to pass an arbitrary number of arguments into the exception. Often a string message is used, but any object that might be useful in a later exception handler can be stored. The <kbd>Exception.__init__</kbd> method is designed to accept any arguments and store them as a tuple in an attribute named <kbd>args</kbd>. This makes exceptions easier to define without needing to override <kbd>__init__</kbd>.</p>
<p>Of course, if we do want to customize the initializer, we are free to do so. Here's an exception whose initializer accepts the current balance and the amount the user wanted to withdraw. In addition, it adds a method to calculate how overdrawn the request was:</p>
<pre>class InvalidWithdrawal(Exception): 
    def __init__(self, balance, amount): 
        super().__init__(f"account doesn't have ${amount}") 
        self.amount = amount 
        self.balance = balance 
 
    def overage(self): 
        return self.amount - self.balance 
 
<strong>raise InvalidWithdrawal(25, 50)</strong> </pre>
<p>The <kbd>raise</kbd> statement at the end illustrates how to construct this exception. As you can see, we can do anything with an exception that we would do with other objects.</p>
<p>Here's how we would handle an <kbd>InvalidWithdrawal</kbd> exception if one was raised:</p>
<pre>try: 
    raise InvalidWithdrawal(25, 50) 
<strong>except InvalidWithdrawal as e:</strong> 
    print("I'm sorry, but your withdrawal is " 
            "more than your balance by " 
            f"${e.overage()}") </pre>
<p>Here we see a valid use of the <kbd>as</kbd> keyword. By convention, most Python coders name the exception <kbd>e</kbd> or the <kbd>ex</kbd> variable, although, as usual, you are free to call it  <kbd>exception</kbd>, or <kbd>aunt_sally</kbd> if you prefer.</p>
<p>There are many reasons for defining our own exceptions. It is often useful to add information to the exception or log it in some way. But the utility of custom exceptions truly comes to light when creating a framework, library, or API that is intended for access by other programmers. In that case, be careful to ensure your code is raising exceptions that make sense to the client programmer. They should be easy to handle and clearly describe what went on. The client programmer should easily see how to fix the error (if it reflects a bug in their code) or handle the exception (if it's a situation they need to be made aware of).</p>
<p>Exceptions aren't exceptional. Novice programmers tend to think of exceptions as only useful for exceptional circumstances. However, the definition of exceptional circumstances can be vague and subject to interpretation. Consider the following two functions:</p>
<pre>def divide_with_exception(number, divisor): 
    try: 
        print(f"{number} / {divisor} = {number / divisor}") 
    except ZeroDivisionError: 
        print("You can't divide by zero") 
 
def divide_with_if(number, divisor): 
    if divisor == 0: 
        print("You can't divide by zero") 
    else: 
        print(f"{number} / {divisor} = {number / divisor}") </pre>
<p>These two functions behave identically. If <kbd>divisor</kbd> is zero, an error message is printed; otherwise, a message printing the result of division is displayed. We could avoid <kbd>ZeroDivisionError</kbd> ever being thrown by testing for it with an <kbd>if</kbd> statement. Similarly, we can avoid <kbd>IndexError</kbd> by explicitly checking whether or not the parameter is within the confines of the list, and <kbd>KeyError</kbd> by checking whether the key is in a dictionary.</p>
<p>But we shouldn't do this. For one thing, we might write an <kbd>if</kbd> statement that checks whether or not the index is lower than the parameters of the list, but forget to check negative values.</p>
<div class="packt_infobox">Remember, Python lists support negative indexing; <kbd>-1</kbd> refers to the last element in the list.</div>
<p>Eventually, we would discover this and have to find all the places where we were checking code. But if we had simply caught <kbd>IndexError</kbd> and handled it, our code would just work.</p>
<p>Python programmers tend to follow a model of <em>ask forgiveness rather than permission</em>, which is to say, they execute code and then deal with anything that goes wrong. The alternative, to <em>look before you leap</em>, is generally less popular. There are a few reasons for this, but the main one is that it shouldn't be necessary to burn CPU cycles looking for an unusual situation that is not going to arise in the normal path through the code. Therefore, it is wise to use exceptions for exceptional circumstances, even if those circumstances are only a little bit exceptional. Taking this argument further, we can actually see that the exception syntax is also effective for flow control. Like an <kbd>if</kbd> statement, exceptions can be used for decision making, branching, and message passing.</p>
<p>Imagine an inventory application for a company that sells widgets and gadgets. When a customer makes a purchase, the item can either be available, in which case the item is removed from inventory and the number of items left is returned, or it might be out of stock. Now, being out of stock is a perfectly normal thing to happen in an inventory application. It is certainly not an exceptional circumstance. But what do we return if it's out of stock? A string saying out of stock? A negative number? In both cases, the calling method would have to check whether the return value is a positive integer or something else, to determine if it is out of stock. That seems a bit messy, especially if we forget to do it somewhere in our code.</p>
<p>Instead, we can raise <kbd>OutOfStock</kbd> and use the <kbd>try</kbd> statement to direct program flow control. Make sense? In addition, we want to make sure we don't sell the same item to two different customers, or sell an item that isn't in stock yet. One way to facilitate this is to lock each type of item to ensure only one person can update it at a time. The user must lock the item, manipulate the item (purchase, add stock, count items left...), and then unlock the item. Here's an incomplete <kbd>Inventory</kbd> example with docstrings that describes what some of the methods should do:</p>
<pre>class Inventory:<br/>    def lock(self, item_type):<br/>        """Select the type of item that is going to<br/>        be manipulated. This method will lock the<br/>        item so nobody else can manipulate the<br/>        inventory until it's returned. This prevents<br/>        selling the same item to two different<br/>        customers."""<br/>        pass<br/><br/>    def unlock(self, item_type):<br/>        """Release the given type so that other<br/>        customers can access it."""<br/>        pass<br/><br/>    def purchase(self, item_type):<br/>        """If the item is not locked, raise an<br/>        exception. If the item_type does not exist,<br/>        raise an exception. If the item is currently<br/>        out of stock, raise an exception. If the item<br/>        is available, subtract one item and return<br/>        the number of items left."""<br/>        pass</pre>
<p>We could hand this object prototype to a developer and have them implement the methods to do exactly as they say while we work on the code that needs to make a purchase. We'll use Python's robust exception handling to consider different branches, depending on how the purchase was made:</p>
<pre>item_type = "widget"<br/>inv = Inventory()<br/>inv.lock(item_type)<br/>try:<br/>    num_left = inv.purchase(item_type)<br/>except InvalidItemType:<br/>    print("Sorry, we don't sell {}".format(item_type))<br/>except OutOfStock:<br/>    print("Sorry, that item is out of stock.")<br/>else:<br/>    print("Purchase complete. There are {num_left} {item_type}s left")<br/>finally:<br/>    inv.unlock(item_type)</pre>
<p>Pay attention to how all the possible exception handling clauses are used to ensure the correct actions happen at the correct time. Even though <kbd>OutOfStock</kbd> is not a terribly exceptional circumstance, we are able to use an exception to handle it suitably. This same code could be written with an <kbd>if...elif...else</kbd> structure, but it wouldn't be as easy to read or maintain.</p>
<p>We can also use exceptions to pass messages between different methods. For example, if we wanted to inform the customer as to what date the item is expected to be in stock again, we could ensure our <kbd>OutOfStock</kbd> object requires a <kbd>back_in_stock</kbd> parameter when it is constructed. Then, when we handle the exception, we can check that value and provide additional information to the customer. The information attached to the object can be easily passed between two different parts of the program. The exception could even provide a method that instructs the inventory object to reorder or backorder an item.</p>
<p>Using exceptions for flow control can make for some handy program designs. The important thing to take from this discussion is that exceptions are not a bad thing that we should try to avoid. Having an exception occur does not mean that you should have prevented this exceptional circumstance from happening. Rather, it is just a powerful way to communicate information between two sections of code that may not be directly calling each other.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case study</h1>
                </header>
            
            <article>
                
<p>We've been looking at the use and handling of exceptions at a fairly low level of detail—syntax and definitions. This case study will help tie it all in with our previous chapters so we can see how exceptions are used in the larger context of objects, inheritance, and modules.</p>
<p>Today, we'll be designing a simple central authentication and authorization system. The entire system will be placed in one module, and other code will be able to query that module object for authentication and authorization purposes. We should admit, from the start, that we aren't security experts, and that the system we are designing may be full of security holes. Our purpose is to study exceptions, not to secure a system. It will be sufficient, however, for a basic login and permission system that other code can interact with. Later, if that other code needs to be made more secure, we can have a security or cryptography expert review or rewrite our module, preferably without changing the API.</p>
<p>Authentication is the process of ensuring a user is really the person they say they are. We'll follow the lead of common web systems today, which use a username and private password combination. Other methods of authentication include voice recognition, fingerprint or retinal scanners, and identification cards.</p>
<p>Authorization, on the other hand, is all about determining whether a given (authenticated) user is permitted to perform a specific action. We'll create a basic permission list system that stores a list of the specific people allowed to perform each action.</p>
<p>In addition, we'll add some administrative features to allow new users to be added to the system. For brevity, we'll leave out editing of passwords or changing of permissions once they've been added, but these (highly necessary) features can certainly be added in the future.</p>
<p>There's a simple analysis; now let's proceed with design. We're obviously going to need a <kbd>User</kbd> class that stores the username and an encrypted password. This class will also allow a user to log in by checking whether a supplied password is valid. We probably won't need a <kbd>Permission</kbd> class, as those can just be strings mapped to a list of users using a dictionary. We should have a central <kbd>Authenticator</kbd> class that handles user management and logging in or out. The last piece of the puzzle is an <kbd>Authorizor</kbd> class that deals with permissions and checking whether a user can perform an activity. We'll provide a single instance of each of these classes in the <kbd>auth</kbd> module so that other modules can use this central mechanism for all their authentication and authorization needs. Of course, if they want to instantiate private instances of these classes, for non-central authorization activities, they are free to do so.</p>
<p>We'll also be defining several exceptions as we go along. We'll start with a special <kbd>AuthException</kbd> base class that accepts a <kbd>username</kbd> and optional <kbd>user</kbd> object as parameters; most of our self-defined exceptions will inherit from this one.</p>
<p>Let's build the <kbd>User</kbd> class first; it seems simple enough. A new user can be initialized with a username and password. The password will be stored encrypted to reduce the chances of its being stolen. We'll also need a <kbd>check_password</kbd> method to test whether a supplied password is the correct one. Here is the class in full:</p>
<pre>import hashlib<br/><br/><br/>class User:<br/>    def __init__(self, username, password):<br/>        """Create a new user object. The password<br/>        will be encrypted before storing."""<br/>        self.username = username<br/>        self.password = self._encrypt_pw(password)<br/>        self.is_logged_in = False<br/><br/>    def _encrypt_pw(self, password):<br/>        """Encrypt the password with the username and return<br/>        the sha digest."""<br/>        hash_string = self.username + password<br/>        hash_string = hash_string.encode("utf8")<br/>        return hashlib.sha256(hash_string).hexdigest()<br/><br/>    def check_password(self, password):<br/>        """Return True if the password is valid for this<br/>        user, false otherwise."""<br/>        encrypted = self._encrypt_pw(password)<br/>        return encrypted == self.password</pre>
<p>Since the code for encrypting a password is required in both <kbd>__init__</kbd> and <kbd>check_password</kbd>, we pull it out to its own method. This way, it only needs to be changed in one place if someone realizes it is insecure and needs improvement. This class could easily be extended to include mandatory or optional personal details, such as names, contact information, and birth dates.</p>
<p>Before we write code to add users (which will happen in the as-yet undefined <kbd>Authenticator</kbd> class), we should examine some use cases. If all goes well, we can add a user with a username and password; the <kbd>User</kbd> object is created and inserted into a dictionary. But in what ways can all not go well? Well, clearly we don't want to add a user with a username that already exists in the dictionary. If we did so, we'd overwrite an existing user's data and the new user might have access to that user's privileges. So, we'll need a <kbd>UsernameAlreadyExists</kbd> exception. Also, for security's sake, we should probably raise an exception if the password is too short. Both of these exceptions will extend <kbd>AuthException</kbd>, which we mentioned earlier. So, before writing the <kbd>Authenticator</kbd> class, let's define these three exception classes:</p>
<pre>class AuthException(Exception): 
    def __init__(self, username, user=None): 
        super().__init__(username, user) 
        self.username = username 
        self.user = user 
 <br/>class UsernameAlreadyExists(AuthException): 
    pass 
 <br/>class PasswordTooShort(AuthException): 
    pass </pre>
<p>The <kbd>AuthException</kbd> requires a username and has an optional user parameter. This second parameter should be an instance of the <kbd>User</kbd> class associated with that username. The two specific exceptions we're defining simply need to inform the calling class of an exceptional circumstance, so we don't need to add any extra methods to them.</p>
<p>Now let's start on the <kbd>Authenticator</kbd> class. It can simply be a mapping of usernames to user objects, so we'll start with a dictionary in the initialization function. The method for adding a user needs to check the two conditions (password length and previously existing users) before creating a new <kbd>User</kbd> instance and adding it to the dictionary:</p>
<pre>class Authenticator:<br/>    def __init__(self):<br/>        """Construct an authenticator to manage<br/>        users logging in and out."""<br/>        self.users = {}<br/><br/>    def add_user(self, username, password):<br/>        if username in self.users:<br/>            raise UsernameAlreadyExists(username)<br/>        if len(password) &lt; 6:<br/>            raise PasswordTooShort(username)<br/>        self.users[username] = User(username, password)</pre>
<p>We could, of course, extend the password validation to raise exceptions for passwords that are too easy to crack in other ways, if we desired. Now let's prepare the <kbd>login</kbd> method. If we weren't thinking about exceptions just now, we might just want the method to return <kbd>True</kbd> or <kbd>False</kbd>, depending on whether the login was successful or not. But we are thinking about exceptions, and this could be a good place to use them for a not-so-exceptional circumstance. We could raise different exceptions, for example, if the username does not exist or the password does not match. This will allow anyone trying to log a user in to elegantly handle the situation using a <kbd>try</kbd>/<kbd>except</kbd>/<kbd>else</kbd> clause. So, first we add these new exceptions:</p>
<pre>class InvalidUsername(AuthException): 
    pass 
 
class InvalidPassword(AuthException): 
    pass </pre>
<p>Then we can define a simple <kbd>login</kbd> method to our <kbd>Authenticator</kbd> class that raises these exceptions if necessary. If not, it flags the <kbd>user</kbd> as logged in and returns the following:</p>
<pre>    def login(self, username, password): 
        try: 
            user = self.users[username] 
        except KeyError: 
            raise InvalidUsername(username) 
 
        if not user.check_password(password): 
            raise InvalidPassword(username, user) 
 
        user.is_logged_in = True 
        return True </pre>
<p>Notice how <kbd>KeyError</kbd> is handled. This could have been handled using <kbd>if username not in self.users:</kbd> instead, but we chose to handle the exception directly. We end up eating up this first exception and raising a brand new one of our own that better suits the user-facing API.</p>
<p>We can also add a method to check whether a particular username is logged in. Deciding whether to use an exception here is trickier. Should we raise an exception if the username does not exist? Should we raise an exception if the user is not logged in?</p>
<p>To answer these questions, we need to think about how the method would be accessed. Most often, this method will be used to answer the yes/no question, <em>should I allow them access to &lt;something&gt;?</em> The answer will either be, y<em>es, the username is valid and they are logged in</em>, or <em>no, the username is not valid or they are not logged in</em>. Therefore, a Boolean return value is sufficient. There is no need to use exceptions here, just for the sake of using an exception:</p>
<pre>    def is_logged_in(self, username): 
        if username in self.users: 
            return self.users[username].is_logged_in 
        return False </pre>
<p>Finally, we can add a default authenticator instance to our module so that the client code can access it easily using <kbd>auth.authenticator</kbd>:</p>
<pre>authenticator = Authenticator() </pre>
<p>This line goes at the module level, outside any class definition, so the <kbd>authenticator</kbd> variable can be accessed as <kbd>auth.authenticator</kbd>. Now we can start on the <kbd>Authorizor</kbd> class, which maps permissions to users. The <kbd>Authorizor</kbd> class should not permit user access to a permission if they are not logged in, so they'll need a reference to a specific authenticator. We'll also need to set up the permission dictionary upon initialization:</p>
<pre>class Authorizor: 
    def __init__(self, authenticator): 
        self.authenticator = authenticator 
        self.permissions = {} </pre>
<p>Now we can write methods to add new permissions and to set up which users are associated with each permission:</p>
<pre>    def add_permission(self, perm_name): 
        '''Create a new permission that users 
        can be added to''' 
        try: 
            perm_set = self.permissions[perm_name] 
        except KeyError: 
            self.permissions[perm_name] = set() 
        else: 
            raise PermissionError("Permission Exists") 
 
    def permit_user(self, perm_name, username): 
        '''Grant the given permission to the user''' 
        try: 
            perm_set = self.permissions[perm_name] 
        except KeyError: 
            raise PermissionError("Permission does not exist") 
        else: 
            if username not in self.authenticator.users: 
                raise InvalidUsername(username) 
            perm_set.add(username) </pre>
<p>The first method allows us to create a new permission, unless it already exists, in which case an exception is raised. The second allows us to add a username to a permission, unless either the permission or the username doesn't yet exist.</p>
<p>We use <kbd>set</kbd> instead of <kbd>list</kbd> for usernames, so that even if you grant a user permission more than once, the nature of sets means the user is only in the set once. We'll discuss sets further in a later chapter.</p>
<p>A <kbd>PermissionError</kbd> error is raised in both methods. This new error doesn't require a username, so we'll make it extend <kbd>Exception</kbd> directly, instead of our custom <kbd>AuthException</kbd>:</p>
<pre>class PermissionError(Exception): 
    pass </pre>
<p>Finally, we can add a method to check whether a user has a specific <kbd>permission</kbd> or not. In order for them to be granted access, they have to be both logged into the authenticator and in the set of people who have been granted access to that privilege. If either of these conditions is unsatisfied, an exception is raised:</p>
<pre>    def check_permission(self, perm_name, username): 
        if not self.authenticator.is_logged_in(username): 
            raise NotLoggedInError(username) 
        try: 
            perm_set = self.permissions[perm_name] 
        except KeyError: 
            raise PermissionError("Permission does not exist") 
        else: 
            if username not in perm_set: 
                raise NotPermittedError(username) 
            else: 
                return True </pre>
<p>There are two new exceptions in here; they both take usernames, so we'll define them as subclasses of <kbd>AuthException</kbd>:</p>
<pre>class NotLoggedInError(AuthException): 
    pass 
 
class NotPermittedError(AuthException): 
    pass </pre>
<p>Finally, we can add a default <kbd>authorizor</kbd> to go with our default authenticator:</p>
<pre>authorizor = Authorizor(authenticator) </pre>
<p>That completes a basic authentication/authorization system. We can test the system at the Python prompt, checking to see whether a user, <kbd>joe</kbd>, is permitted to do tasks in the paint department:</p>
<pre><strong>&gt;&gt;&gt; import auth</strong>
<strong>&gt;&gt;&gt; auth.authenticator.add_user("joe", "joepassword")</strong>
<strong>&gt;&gt;&gt; auth.authorizor.add_permission("paint")</strong>
<strong>&gt;&gt;&gt; auth.authorizor.check_permission("paint", "joe")</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>  File "auth.py", line 109, in check_permission</strong>
<strong>    raise NotLoggedInError(username)</strong>
<strong>auth.NotLoggedInError: joe</strong>
<strong>&gt;&gt;&gt; auth.authenticator.is_logged_in("joe")</strong>
<strong>False</strong>
<strong>&gt;&gt;&gt; auth.authenticator.login("joe", "joepassword")</strong>
<strong>True</strong>
<strong>&gt;&gt;&gt; auth.authorizor.check_permission("paint", "joe")</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>  File "auth.py", line 116, in check_permission</strong>
 <strong>   raise NotPermittedError(username)</strong>
<strong>auth.NotPermittedError: joe</strong>
<strong>&gt;&gt;&gt; auth.authorizor.check_permission("mix", "joe")</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "auth.py", line 111, in check_permission</strong>
<strong>    perm_set = self.permissions[perm_name]</strong>
<strong>KeyError: 'mix'</strong>

<strong>During handling of the above exception, another exception occurred:</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>  File "auth.py", line 113, in check_permission</strong>
<strong>    raise PermissionError("Permission does not exist")</strong>
<strong>auth.PermissionError: Permission does not exist</strong>
<strong>&gt;&gt;&gt; auth.authorizor.permit_user("mix", "joe")</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "auth.py", line 99, in permit_user</strong>
<strong>    perm_set = self.permissions[perm_name]</strong>
<strong>KeyError: 'mix'</strong>
    
<strong>During handling of the above exception, another exception occurred:</strong>
 
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>  File "auth.py", line 101, in permit_user</strong>
<strong>    raise PermissionError("Permission does not exist")</strong>
<strong>auth.PermissionError: Permission does not exist</strong>
<strong>&gt;&gt;&gt; auth.authorizor.permit_user("paint", "joe")</strong>
<strong>&gt;&gt;&gt; auth.authorizor.check_permission("paint", "joe")</strong>
<strong>True</strong>  </pre>
<p>While verbose, the preceding output shows all of our code and most of our exceptions in action, but to really understand the API we've defined, we should write some exception handling code that actually uses it. Here's a basic menu interface that allows certain users to change or test a program:</p>
<pre>import auth<br/><br/># Set up a test user and permission<br/>auth.authenticator.add_user("joe", "joepassword")<br/>auth.authorizor.add_permission("test program")<br/>auth.authorizor.add_permission("change program")<br/>auth.authorizor.permit_user("test program", "joe")<br/><br/><br/>class Editor:<br/>    def __init__(self):<br/>        self.username = None<br/>        self.menu_map = {<br/>            "login": self.login,<br/>            "test": self.test,<br/>            "change": self.change,<br/>            "quit": self.quit,<br/>        }<br/><br/>    def login(self):<br/>        logged_in = False<br/>        while not logged_in:<br/>            username = input("username: ")<br/>            password = input("password: ")<br/>            try:<br/>                logged_in = auth.authenticator.login(username, password)<br/>            except auth.InvalidUsername:<br/>                print("Sorry, that username does not exist")<br/>            except auth.InvalidPassword:<br/>                print("Sorry, incorrect password")<br/>            else:<br/>                self.username = username<br/><br/>    def is_permitted(self, permission):<br/>        try:<br/>            auth.authorizor.check_permission(permission, self.username)<br/>        except auth.NotLoggedInError as e:<br/>            print("{} is not logged in".format(e.username))<br/>            return False<br/>        except auth.NotPermittedError as e:<br/>            print("{} cannot {}".format(e.username, permission))<br/>            return False<br/>        else:<br/>            return True<br/><br/>    def test(self):<br/>        if self.is_permitted("test program"):<br/>            print("Testing program now...")<br/><br/>    def change(self):<br/>        if self.is_permitted("change program"):<br/>            print("Changing program now...")<br/><br/>    def quit(self):<br/>        raise SystemExit()<br/><br/>    def menu(self):<br/>        try:<br/>            answer = ""<br/>            while True:<br/>                print(<br/>                    """<br/>Please enter a command:<br/>\tlogin\tLogin<br/>\ttest\tTest the program<br/>\tchange\tChange the program<br/>\tquit\tQuit<br/>"""<br/>                )<br/>                answer = input("enter a command: ").lower()<br/>                try:<br/>                    func = self.menu_map[answer]<br/>                except KeyError:<br/>                    print("{} is not a valid option".format(answer))<br/>                else:<br/>                    func()<br/>        finally:<br/>            print("Thank you for testing the auth module")<br/><br/><br/>Editor().menu()</pre>
<p>This rather long example is conceptually very simple. The <kbd>is_permitted</kbd> method is probably the most interesting; this is a mostly internal method that is called by both <kbd>test</kbd> and <kbd>change</kbd> to ensure the user is permitted access before continuing. Of course, those two methods are stubs, but we aren't writing an editor here; we're illustrating the use of exceptions and exception handlers by testing an authentication and authorization framework.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exercises</h1>
                </header>
            
            <article>
                
<p>If you've never dealt with exceptions before, the first thing you need to do is look at any old Python code you've written and notice if there are places you should have been handling exceptions. How would you handle them? Do you need to handle them at all? Sometimes, letting the exception propagate to the console is the best way to communicate to the user, especially if the user is also the script's coder. Sometimes, you can recover from the error and allow the program to continue. Sometimes, you can only reformat the error into something the user can understand and display it to them.</p>
<p>Some common places to look are file I/O (is it possible your code will try to read a file that doesn't exist?), mathematical expressions (is it possible that a value you are dividing by is zero?), list indices (is the list empty?), and dictionaries (does the key exist?). Ask yourself whether you should ignore the problem, handle it by checking values first, or handle it with an exception. Pay special attention to areas where you might have used <kbd>finally</kbd> and <kbd>else</kbd> to ensure the correct code is executed under all conditions.</p>
<p>Now write some new code. Think of a program that requires authentication and authorization, and try writing some code that uses the <kbd>auth</kbd> module we built in the case study. Feel free to modify the module if it's not flexible enough. Try to handle<br/>
all the exceptions in a sensible way. If you're having trouble coming up with something that requires authentication, try adding authorization to the Notepad example from <a href="0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Objects in Python</em>, or add authorization to the <kbd>auth</kbd> module itself—it's not a terribly useful module if just anybody can start adding permissions! Maybe require an administrator username and password before allowing privileges to be added or changed.</p>
<p>Finally, try to think of places in your code where you can raise exceptions. It can be in code you've written or are working on; or you can write a new project as an exercise. You'll probably have the best luck for designing a small framework or API that is meant to be used by other people; exceptions are a terrific communication tool between your code and someone else's. Remember to design and document any self-raised exceptions as part of the API, or they won't know whether or how to handle them!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we went into the gritty details of raising, handling, defining, and manipulating exceptions. Exceptions are a powerful way to communicate unusual circumstances or error conditions without requiring a calling function to explicitly check return values. There are many built-in exceptions and raising them is trivially easy. There are several different syntaxes for handling different exception events.</p>
<p>In the next chapter, everything we've studied so far will come together as we discuss how object-oriented programming principles and structures should best be applied in Python applications.</p>


            </article>

            
        </section>
    </body></html>