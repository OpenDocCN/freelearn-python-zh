- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintaining Cross-Platform Compatibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Word has spread throughout ABQ AgriLabs about your application, and it is being
    requested as a way to visualize and work on experimental data files. As a result,
    it now needs to run on Windows, macOS, and Linux systems equally well. Fortunately
    for you, Python and Tkinter are supported on these three operating systems, and
    you'll be pleasantly surprised to find that your application already runs unaltered
    on all three. However, there are some small issues that you need to address and
    remain aware of in order for your application to be a good citizen on each platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn more about cross-platform compatibility as we
    cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: In *Writing cross-platform Python*, you'll learn how to keep basic Python code
    functional across multiple platforms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Writing cross-platform Tkinter*, you'll learn about cross-platform issues
    that affect Tkinter code specifically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Improving our application's cross-platform compatibility*, we'll update
    our ABQ Data Entry application for better cross-platform support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing cross-platform Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing, Python is supported on nearly a dozen operating system
    platforms, covering everything from common desktop systems like Windows to high-end
    commercial Unixes like AIX and obscure OS projects such as Haiku OS.
  prefs: []
  type: TYPE_NORMAL
- en: Across all these platforms, most Python code works without any significant alteration,
    as Python has been designed to translate high-level functionality into appropriate
    low-level operations on each system. Even so, there are situations where OS differences
    cannot be (or simply have not been) abstracted away, and careful handling is required
    to avoid platform-specific failures.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll look at some of the larger issues that impact cross-platform
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: Filenames and file paths across platforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Filesystems are probably the biggest source of pitfalls for cross-platform development.
    Although most platforms share the concept of files and directories arranged in
    a hierarchy, there are some crucial differences that can trip up developers who
    are unfamiliar with a variety of operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Path separators and drives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When it comes to identifying locations on a filesystem, operating systems generally
    use one of the following two models:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows/DOS: In this model, each partition or storage device is assigned a
    volume label (usually a single letter), and each volume has its own filesystem
    tree. Paths are separated by a backslash (`\`) character. This system is used
    by Windows, DOS, and VMS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unix: In this model, there is one filesystem tree, into which devices and partitions
    are mounted at arbitrary points. Paths are separated by a forward slash (`/`).
    This model is used by macOS, Linux, BSD, iOS, Android, and other Unix-like operating
    systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, a path like `E:\Server\Files\python` is meaningless on Linux or macOS,
    while a path like `/mnt/disk1/files/python` is equally meaningless on Windows.
    This could make it quite difficult to write code that accesses files in a cross-platform
    way, but Python gives us a few tools to deal with the differences.
  prefs: []
  type: TYPE_NORMAL
- en: Path separator translation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you use the Unix-style forward slash path separators on a Windows system,
    Python will automatically translate them into backslashes. This is quite useful
    for cross-platform purposes because using backslashes in strings can be problematic.
    For example, if you try to create the string `C:\Users` in Python, you'll get
    an exception, because `\u` is an escape sequence for specifying Unicode sequences,
    and `sers` (the rest of the string after `\U`) is not a valid Unicode sequence.
  prefs: []
  type: TYPE_NORMAL
- en: To use backslashes in a string, you must either escape them by entering a double-backslash
    (`\\`) or you must use a raw string (by prefixing the string literal with an `r`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there is no Windows-to-Unix path separator translation: Python will
    not translate backslashes into Unix-style forward slashes. Thus, a path like `r''\usr\bin\python''`
    will simply not work on macOS or Linux.'
  prefs: []
  type: TYPE_NORMAL
- en: The os.path module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Even with automatic path-separator interpolation, building or hardcoding paths
    as strings is a messy business. Python's powerful string manipulation methods
    make it tempting to try to work with paths as strings, and many programmers attempt
    to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is often ugly, non-portable code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: While this approach might work most of the time (even on Windows), it's prone
    to breaking on some edge cases (for example, if `some_path` is `/script.sh`).
    For this reason, the Python standard library includes the `os.path` module for
    working with filesystem paths.
  prefs: []
  type: TYPE_NORMAL
- en: The `path` module appears to be a collection of functions and constants that
    help abstract common filenames and directory operations, though it's actually
    a wrapper around the low-level modules `posixpath` for Unix-like systems and `ntpath`
    for Windows. When you import `path`, Python simply detects your operating system
    and loads the appropriate low-level library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows some common `os.path` functions that are useful for
    cross-platform developers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| `join()` | Joins two or more path segments in a platform-appropriate way
    |'
  prefs: []
  type: TYPE_TB
- en: '| `expanduser()` | Expands the `~` or `username` shortcuts to the user''s home
    directory or user name, respectively |'
  prefs: []
  type: TYPE_TB
- en: '| `expandvars()` | Expands any shell variables present in a path string |'
  prefs: []
  type: TYPE_TB
- en: '| `dirname()` | Extracts the parent directory of the path |'
  prefs: []
  type: TYPE_TB
- en: '| `isfile()` | Determines whether the path points to a file |'
  prefs: []
  type: TYPE_TB
- en: '| `isdir()` | Determines whether the path points to a directory |'
  prefs: []
  type: TYPE_TB
- en: '| `exists()` | Determines whether the given path exists |'
  prefs: []
  type: TYPE_TB
- en: Using these functions rather than directly manipulating path strings guarantees
    that your code will work across platforms consistently.
  prefs: []
  type: TYPE_NORMAL
- en: The pathlib module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A more recent addition to the Python standard library is the `pathlib` module.
    The `pathlib` module is a more object-oriented and somewhat higher-level take
    on filesystem paths, which we have been using throughout this book. Unlike `os.path`,
    which is just a collection of functions and constants, `pathlib` offers the `Path`
    object, which represents a filesystem location and provides a variety of methods
    for modifying the path and obtaining information about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We typically use `pathlib` by importing the `Path` class from it. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`Path` defaults to the current working directory, but you can also provide
    it with an absolute or relative path string. Relative paths will be calculated
    against the current working directory.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Path` objects have a variety of useful properties and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the `pathlib` module's documentation at [https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html)
    for more information on this powerful library.
  prefs: []
  type: TYPE_NORMAL
- en: Should you use `os.path` or `pathlib.Path`? Generally speaking, `pathlib` is
    the better choice and results in much cleaner code overall. However, there are
    a few edge cases where you might need `os.path`. For example, `pathlib` has no
    equivalent to `expandvars()`; also, the `os.path` module's function-oriented approach
    may be more useful in functional programming situations.
  prefs: []
  type: TYPE_NORMAL
- en: Case sensitivity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Platforms also differ in terms of filesystem case sensitivity. On Linux, BSD,
    and Unix, for example, the files `log.txt`, `LOG.txt`, and `LoG.TxT` are all different
    files that can coexist in the same directory. On Windows or macOS (depending on
    your settings), all three names would refer to the same file, and three files
    with these names could not exist in the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table breaks down the case sensitivity of major operating systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '| System | Case-sensitive |'
  prefs: []
  type: TYPE_TB
- en: '| Windows | No |'
  prefs: []
  type: TYPE_TB
- en: '| macOS | Not by default (configurable) |'
  prefs: []
  type: TYPE_TB
- en: '| Linux | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| BSD, most other Unix systems | Yes |'
  prefs: []
  type: TYPE_TB
- en: 'Problems with case (in)sensitivity usually depend on which system you''re accustomed
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: Programmers used to a case-insensitive system tend to run into problems with
    inconsistent use of cases when referencing files and paths. For instance, you
    might save a file as `UserSettings.json` but try to retrieve it as `usersettings.JSON`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programmers used to a case-sensitive system can have problems when depending
    on a case to differentiate between file or directory names. For example, you might
    have the files `ImportIngest.txt` and `ImportingEst.txt` in the same directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Avoiding these issues is fairly simple with the following few basic rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Use all-lowercase names for file and path names unless there is a good reason
    not to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you do mix cases, follow consistent rules, so that you don't need to remember
    arbitrary case usage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid CamelCase or similar naming schemes that rely on case to denote word breaks.
    Use underscores, hyphens, or spaces (they're valid in all modern filesystems!).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To put it another way: treat all paths and filenames as if you had a case-sensitive
    system, but don''t rely on the system being case-sensitive.'
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic links
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A symbolic link is a special filesystem-level construct that appears to be a
    file or directory but is actually just a pointer to another file or directory
    on the system. They're often used to provide aliases to files or directories,
    or to make it appear as though the same file exists in multiple places without
    using additional disk space. Although they exist on Windows, they're far more
    commonly used on Linux, macOS, and other Unix-like systems; thus, they can be
    a point of confusion for programmers coming from a Windows environment.
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic links are not to be confused with desktop shortcuts, which also exist
    on all three major platforms. Shortcuts are just metadata files implemented at
    the desktop environment level, whereas symbolic links are implemented at the filesystem
    level.
  prefs: []
  type: TYPE_NORMAL
- en: File and path operations sometimes need to clarify if they're working with the
    symbolic link itself or the file that the link points to.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we had a symbolic link in our current directory, `secret_stuff.txt`,
    that points to the nonexistent file `/tmp/secret_stuff.txt`. Look at how `os.path()`
    responds to such a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The regular `path.exists()` function will follow the link and discover that
    the actual file in question does not exist. `os.path` also includes a `lexists()`
    function that will tell us if the *link* exists, even if the *file* does not.
    This situation could be a problem; for example, your program might be attempting
    to create a directory with the same name as a broken symbolic link. In this case,
    `os.path.exists()` or `Path.exists()` would both return `False`, but the name
    conflict would still exist, and directory creation would fail. Checking `os.path.lexists()`
    or `Path.is_symlink()` as well would be a good idea in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows some of the `os.path` functions that help deal with
    symbolic links:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `islink()` | Returns `True` if a path is a symbolic link |'
  prefs: []
  type: TYPE_TB
- en: '| `lexists()` | Returns `True` if a path exists, even if it''s a broken symbolic
    link |'
  prefs: []
  type: TYPE_TB
- en: '| `realpath()` | Returns the actual path, resolving any symbolic links to real
    files and directories |'
  prefs: []
  type: TYPE_TB
- en: '`pathlib.Path` objects also feature these link-related methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `is_symlink()` | Returns `True` if the path is a symbolic link |'
  prefs: []
  type: TYPE_TB
- en: '| `resolve()` | Returns a path with all symbolic links resolved to real files
    and directories |'
  prefs: []
  type: TYPE_TB
- en: '| `lchmod()` | Changes permissions on a symbolic link, rather than the file
    it is pointed to |'
  prefs: []
  type: TYPE_TB
- en: '| `lstat()` | Returns filesystem information on a symbolic link, rather than
    the file it is pointed to |'
  prefs: []
  type: TYPE_TB
- en: In summary, our code should be mindful of symbolic links in situations where
    they might cause it to behave unexpectedly.
  prefs: []
  type: TYPE_NORMAL
- en: Path variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most platforms, including Windows, macOS, and Linux, support some kind of shell
    variables, which are often automatically set up by the system to point to common
    filesystem locations. The `os.path` module provides the `expandvars()` function
    to expand these variables into their actual values (`pathlib` has no equivalent
    method). While these variables can be useful in locating common path locations,
    the cross-platform developer should understand that they are not consistent across
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some commonly used variables across different systems include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Description | Windows | macOS | Linux |'
  prefs: []
  type: TYPE_TB
- en: '| Current user home directory | `%HOME%`, `%USERPROFILE%` | `$HOME` | `$HOME`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Temporary directory | `%TMP%`, `%TEMP%` | `$TMPDIR` | None |'
  prefs: []
  type: TYPE_TB
- en: '| Path to default shell | N/A | `$SHELL` | `$SHELL` |'
  prefs: []
  type: TYPE_TB
- en: '| Current working directory | None | `$PWD` | `$PWD` |'
  prefs: []
  type: TYPE_TB
- en: '| Configuration directory | `%APPDATA%`, `%LOCALAPPDATA%` | None | `$XDG_CONFIG_HOME`
    (often not set) |'
  prefs: []
  type: TYPE_TB
- en: '| OS directory | `%WINDIR%`, `%SYSTEMROOT%` | N/A | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| Program files directory | `%PROGRAMFILES%`, `%PROGRAMW6432%` | N/A | N/A
    |'
  prefs: []
  type: TYPE_TB
- en: Note that Windows variables can be spelled using the native `%VARIABLENAME%`
    format or the Unix-style `$VARIABLENAME` format; macOS and Linux only accept the
    Unix-style format.
  prefs: []
  type: TYPE_NORMAL
- en: Using these variables is not necessarily a bad idea (they can help abstract
    differences between versions or configurations of an OS), but be aware that they
    are not consistently available, or even meaningful, across platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Inconsistent library and feature support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it's understandable that many third-party Python libraries only support
    a limited number of platforms, you might be surprised to learn that the standard
    library contains a slightly different set of modules depending on the platform.
    Even those that do exist across platforms might behave slightly differently, or
    have inconsistent contents, depending on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, these have to be handled carefully in cross-platform applications.
    Let's look at a few examples of these libraries and features.
  prefs: []
  type: TYPE_NORMAL
- en: Python's platform-limited libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In sections 34 and 35 of Python's standard library documentation ([https://docs.python.org/3/library/index.html](https://docs.python.org/3/library/index.html)),
    you'll find a list of libraries available only on Windows or Unix-like systems,
    respectively. Careful reading of the documentation shows that there are a couple
    more platform-limited libraries listed in other sections as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a list of the more common platform-limited libraries you may encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Library | Description | Availability |'
  prefs: []
  type: TYPE_TB
- en: '| `ossaudiodev` | Open Sound System (OSS) audio server interface | Linux, FreeBSD
    |'
  prefs: []
  type: TYPE_TB
- en: '| `winsound` | Windows audio interface | Windows |'
  prefs: []
  type: TYPE_TB
- en: '| `msilib` | Windows software packaging tools | Windows |'
  prefs: []
  type: TYPE_TB
- en: '| `winreg` | Windows registry tools | Windows |'
  prefs: []
  type: TYPE_TB
- en: '| `syslog` | Unix system log interface | Linux, macOS, BSD |'
  prefs: []
  type: TYPE_TB
- en: '| `pwd`, `spwd` | Unix password database interface | Linux, macOS, BSD |'
  prefs: []
  type: TYPE_TB
- en: '| `resource` | System resource limits | Linux, macOS, BSD |'
  prefs: []
  type: TYPE_TB
- en: '| `curses` | Terminal-based UI library | Linux, macOS, BSD |'
  prefs: []
  type: TYPE_TB
- en: In some cases, there are higher-level, cross-platform libraries that you can
    use to replace these (for example, use `logging` instead of `syslog`), but in
    other cases the functionality is so platform-specific that you may have no choice
    (`winreg`, for example). In this case, you'll need to do a platform check before
    importing these libraries, as you'll get an `ImportError` exception on unsupported
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Checking low-level function compatibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even in universally available libraries, there are sometimes functions or methods
    that are unavailable or exhibit different behaviors depending on the platform.
    The `os` module is perhaps the most notable case.
  prefs: []
  type: TYPE_NORMAL
- en: The `os` module is a relatively thin wrapper around system calls or commands,
    and while it attempts to abstract some roughly analogous calls across platforms,
    many of its functions are too platform-specific to make available universally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `os` module documentation at [https://docs.python.org/3/library/os.html](https://docs.python.org/3/library/os.html)
    contains complete details on platform support, but some examples are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Library | Description | Availability |'
  prefs: []
  type: TYPE_TB
- en: '| `getuid`, `getgid`, `getgroups`, `geteuid` | Get user or group information
    for the current process | Unix-like |'
  prefs: []
  type: TYPE_TB
- en: '| `setuid`, `setgid`, `setgroups`, `seteuid` | Set user or group information
    for the current process | Unix-like |'
  prefs: []
  type: TYPE_TB
- en: '| `getpriority`, `setpriority` | Get or set the priority of the current process
    | Unix-like |'
  prefs: []
  type: TYPE_TB
- en: '| `chown`, `lchown` | Change the owner of a file or its symbolic link | Unix-like
    |'
  prefs: []
  type: TYPE_TB
- en: '| `startfile` | Open a file as if it were double-clicked | Windows |'
  prefs: []
  type: TYPE_TB
- en: Attempting to use an unavailable function will cause an exception, so none of
    these functions should be in a cross-platform application without appropriate
    checks or exception handling. By far, most of the platform-limited functions in
    `os` are limited to Unix-like systems (Linux, macOS, BSD, and so on), and most
    of the analogous functions for Windows will be found in the third-party `pywin32`
    package (which is only available for Windows, of course).
  prefs: []
  type: TYPE_NORMAL
- en: In general, you need to check the documentation of the libraries you use to
    make sure they're available on all the platforms you intend to support. Caution
    is especially warranted when using libraries that interact with operating system
    functions (such as window management, filesystems, user authentication, and so
    on) or with services that are only available on certain platforms (Microsoft SQL
    Server, for example).
  prefs: []
  type: TYPE_NORMAL
- en: The dangers of the subprocess module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `subprocess` module provides tools to launch and manage other programs and
    commands from within your Python application. For programmers already familiar
    with their operating system's command-line interface, it often provides a fast
    and convenient way to accomplish filesystem operations or other administrative
    tasks. It's also highly effective at sabotaging cross-platform compatibility!
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a programmer on Linux or macOS might be tempted to copy files
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This would work on Unix-like operating systems but fail on Windows, as `cp`
    is not a valid Windows shell command. The better option in this case is to use
    the `shutil` library, which contains high-level functions for copying files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid problems here, follow these guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Look for high-level libraries before resorting to `subprocess` to solve a problem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you must use `subprocess`, carefully study the called command on each supported
    platform, making sure the syntax, output, and behavior are identical.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If they're not, make sure to create different cases for each platform (see the
    section *Writing code that changes according to the platform*, below).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Naturally, all this advice applies equally to any third-party modules that allow
    you to execute operating system commands from within Python.
  prefs: []
  type: TYPE_NORMAL
- en: Text file encodings and formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Plaintext files on different platforms use different character encodings and
    end-of-line characters by default. Although most operating systems can handle
    a wide variety of encodings, each system has a default (often determined by language
    or localization settings) that will be used if none is specified. Text files on
    different platforms also use different character codes for end-of-line characters.
  prefs: []
  type: TYPE_NORMAL
- en: Modern versions of Linux and macOS use UTF-8 as a default encoding and the line
    feed character (`\n`) as a line terminator. Windows 10, however, uses `cp1252`
    as its default encoding and the combination of the carriage return and line feed
    (`\r\n`) characters as a line terminator. Most of the time, these differences
    do not represent a problem, especially if you are only reading and writing files
    in Python and working with standard English characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider, however, a scenario where you attempt to append a Unicode character
    to a text file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, or other systems with a non-Unicode default encoding, the preceding
    code will raise an exception, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid this problem, you can manually specify a character encoding when opening
    a file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The line-terminator character can also be specified when opening a file using
    the `newline` argument, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We've already been doing this in ABQ Data Entry to work around a bug in Windows
    with the `csv` module. In a cross-platform situation, it's a good idea to specify
    both the `encoding` and `newline` arguments whenever saving data you don't control
    (such as user-entered data).
  prefs: []
  type: TYPE_NORMAL
- en: Graphical and console modes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On Windows, programs are launched in either GUI mode or console mode, as determined
    by metadata in the executable. The Python distribution for Windows includes a
    utility called Python launcher, which is associated with Python files during installation.
    Python launcher will launch your application in either GUI or console mode depending
    on its file extension, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Files ending in the `.py` extension will be launched in console mode using `python.exe`.
    This will cause a command-line window to open in the background, which must stay
    open while the program runs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files ending in `.pyw` will be launched in GUI mode using `pythonw.exe`. No
    command-line window will be launched, and if run from a command line the program
    will not block the console (that is, the prompt will return immediately, while
    the program is still running); however, `print()` will have no effect and `sys.stderr`
    and `sys.stdout` will not exist. Trying to access them will raise an exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This distinction often causes confusion for developers coming from Linux or
    macOS, where it is common to have graphical applications that output errors and
    debugging information to the terminal. Even for Windows programmers who are new
    to GUI applications, the lack of command-line output for GUI applications can
    be problematic.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid issues, simply remember the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove any `sys.stdout()` or `sys.stderr()` calls from the code if deploying
    to Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rely on logging rather than `print()` or `sys.stderr()` calls to record debugging
    information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a copy of the main executable script with a `.pyw` extension so that
    Windows users can launch it without a command-line window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While macOS does not distinguish between GUI and console applications (apart
    from the obvious presence of a GUI), its desktop launches regular `.py` files
    by launching a Terminal window, just like Windows. While macOS Python includes
    a `pythonw.exe` file that launches without the Terminal, there are two problems
    with it. First, it is not associated with the `.pyw` extension by default; you'd
    need to do that manually if you wanted that behavior. Second, depending on how
    you installed Python 3 (for instance, if you installed it using `homebrew`), your
    installation may not have `pythonw`.
  prefs: []
  type: TYPE_NORMAL
- en: There is a way to set up Python programs on macOS so that they behave like proper
    GUI applications, which we'll cover in *Chapter 16*, *Packaging with setuptools
    and cxFreeze*.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code that changes according to the platform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you've seen so far, there are certain situations where you simply can't avoid
    writing platform-specific code, either because a high-level library is unavailable
    or because the actions that need to be performed are fundamentally different on
    a particular platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, it becomes necessary to detect the platform. There are a few
    ways of doing this in Python, including the `os.system()` function and the `sys.platform`
    attribute, but the standard library `platform` module contains the best set of
    functionality for determining the OS details most useful in making decisions.
    When called, the `platform.system()` function returns a string identifying the
    operating system: `Windows`, `Linux`, `freebsd7`, or `Darwin` (for macOS).'
  prefs: []
  type: TYPE_NORMAL
- en: Some other useful functions in the `platform` module include `release()`, which
    returns the version string of the OS (for example, "10" on Windows 10, "17.3.0"
    on macOS High Sierra, or the running kernel version on Linux); and `architecture()`,
    which tells us if the system is 64 bit or 32 bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'For simple differences in code, using this information in a nested `if` / `else`
    chain usually suffices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This example defines a platform-appropriate list of command tokens based on
    the value returned by `platform.system()`. The correct list is saved as `cmd`,
    which is then passed to `subprocess.check_output()` to run the command and obtain
    its output.
  prefs: []
  type: TYPE_NORMAL
- en: 'This works acceptably for the occasional call, but for more complex situations,
    it makes sense to bundle platform-specific code into backend classes that we can
    then select on the basis of our platform string. For example, we could re-implement
    the above code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this approach, we have created a generic class to handle the common logic
    for getting processes, then subclassed it to override the `cmd` attribute specifically
    for each platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can create a selector function to return an appropriate backend class
    when given an OS name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, code that needs to use this class can utilize this function to retrieve
    a platform-appropriate version. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This script can now be run on Linux, Windows, macOS, or BSD to print a process
    list. Other platforms can be easily added by creating more `GenericProcessGetter`
    subclasses and updating `get_process_getter_class()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For even more complex situations, where multiple classes or functions need
    to be implemented differently between platforms, we can take an approach similar
    to the standard library''s `os.path` module: implement completely separate modules
    for each platform, then import them with a common alias depending on the platform.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Bear in mind that each backend module should ideally contain identical class
    and function names and produce similar output. That way `backend` can be used
    by the code without concern for the platform in question.
  prefs: []
  type: TYPE_NORMAL
- en: Writing cross-platform Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you've seen so far, Tkinter mostly works identically across platforms, and
    even has the capability to do the right thing on each platform with minimal effort.
    However, there are some minor issues to be aware of as you support a Tkinter application
    across multiple operating systems. In this section, we'll explore the more significant
    differences.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter version differences across platforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As of 2021, the official Python 3 distributions for major platforms ship at
    least Tcl/Tk 8.6; this is the latest major release of Tcl/Tk and includes all
    the functionality discussed in this book. However, not every platform includes
    the latest minor version, which may impact bug fixes and minor features. At the
    time of writing, the latest version of Tcl/Tk is 8.6.11.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, some platforms (notably macOS) have lagged behind in shipping
    the latest version of Tcl/Tk. While platform support at the time of writing is
    fairly consistent, it's possible that differences may arise again in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'To discover the exact version of Tcl/Tk installed on your system, you can execute
    the following commands at a Python prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This code uses the `Tcl()` function to create a new Tcl interpreter, then calls
    the `info patchlevel` command. Here''s what this command returns on several platforms
    using the most commonly used Python 3 distribution for each platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Platform | Python version | Tcl/Tk version |'
  prefs: []
  type: TYPE_TB
- en: '| Windows 10 | 3.9 (from python.org) | 8.6.9 |'
  prefs: []
  type: TYPE_TB
- en: '| macOS High Sierra | 3.9 (from python.org) | 8.6.8 |'
  prefs: []
  type: TYPE_TB
- en: '| Ubuntu 20.04 | 3.8 (from the repositories) | 8.6.10 |'
  prefs: []
  type: TYPE_TB
- en: '| Debian 10 | 3.7 (from the repositories) | 8.6.9 |'
  prefs: []
  type: TYPE_TB
- en: As you can see, none of these platforms offer the latest version of Tcl/Tk,
    and even those with newer versions of Python may have older versions of Tcl/Tk.
    Ultimately, if you intend to write cross-platform Tkinter code, make sure you
    are not relying on features from the very latest version of Tcl/Tk.
  prefs: []
  type: TYPE_NORMAL
- en: Application menus across platforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The application menu is probably one of the most visible areas where both capabilities
    and conventions vary between platforms. As mentioned in *Chapter 7*, *Creating
    Menus with Menu and Tkinter Dialogs*, we should be aware of both the limitations
    and the expectations on major operating systems when designing our menus.
  prefs: []
  type: TYPE_NORMAL
- en: Menu widget capabilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Menu` widget, which we learned about in *Chapter 7*, is different from
    most other Tkinter widgets in that it relies on the menu facilities of the underlying
    platform. This allows your application to have a menu that behaves natively; for
    example, on macOS, the menu appears in the global menu area at the top of the
    screen, while on Windows it appears in the application window under the taskbar.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this design, there are some limitations when working with cross-platform
    `Menu` widgets. To demonstrate this, let's build an extremely non-cross-platform
    menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin by creating a simple `Tk` window with a menu, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll create a cascade menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `smile_menu` contains two commands, one with a text label and the other
    with only an image. We've also used the image when adding the cascade to the menu,
    so that it shouldn't have a text label, just an image.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we''re at it, let''s add some colors; in *Chapter 9*, *Improving the
    Look with Styles and Themes*, we customized the color of the application menu,
    mentioning that it only worked in Linux. Let''s see what it does on other platforms;
    add in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: That should make our main menu white text on a black background, and the cascade
    yellow on red.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add a separator and a command directly to the main menu, after
    the `smile_menu`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Last of all, we''ll create a `Checkbutton` widget directly on the main menu,
    and finish with the usual boilerplate to configure `root` and run the `mainloop()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Save this file and execute the code. Depending on your operating system, you'll
    see some different things.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are on Linux (in this case, Ubuntu 20.04), it seems to work mostly as
    expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: The menu experiment on Ubuntu 20.04](img/B17578_10_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: The menu experiment on Ubuntu 20.04'
  prefs: []
  type: TYPE_NORMAL
- en: We have our first cascade labeled with the smiley face GIF, our top-level menu
    command, and our top-level `Checkbutton` (which we've checked, because it is true
    that our menu works!). The colors also seem to be correct, although the background
    of the GIF is the default grey rather than the red we would expect (the GIF itself
    has a transparent background).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re using Windows 10, you should see something more like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: The menu experiment on Windows 10](img/B17578_10_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: The menu experiment on Windows 10'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of our smiling icon in the top menu, we only have the text **(Image)**.
    Even if we specify a label, this text shows up where the image should be. Fortunately,
    the image does appear when we use it in the cascade menu. As for the colors, they
    work as expected in the cascade menu, but the top-level menu ignores them completely.
    The command in the main menu appears and works just fine, but the `Checkbutton`
    widget does not. Its label appears and can be clicked on, but the check mark itself
    does not appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s try this menu on macOS. It should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: The menu experiment on macOS](img/B17578_10_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: The menu experiment on macOS'
  prefs: []
  type: TYPE_NORMAL
- en: On macOS, our menu shows up not in the program window, but in the global menu
    at the top of the screen, as macOS users would expect it to. However, there are
    some obvious problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, while our smiling icon appears, it''s cut off. Since the top bar is
    a fixed height and Tkinter will not resize our icon for us, images larger than
    the top bar height get truncated. There are bigger problems too: neither the top-level
    command nor the `Checkbutton` widget are anywhere to be seen. Only our cascade
    menu shows up. Color-wise, the top-level menu ignored our colors, while the cascades
    only honored the foreground color (resulting in a fairly unreadable yellow-on-gray
    combination). Also note that we have a "Python" cascade menu that we did not create.'
  prefs: []
  type: TYPE_NORMAL
- en: On each platform, we're limited by the capabilities of the menu system, and
    while it appears that anything goes for menus on Linux, the other two operating
    systems require more care when constructing menus.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid any issues with menus, follow these guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid command, `Checkbutton`, and `Radiobutton` items in the main menu; stick
    to cascade menus only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't use images in the top-level main menu.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't use colors to style the menu, at least not on Windows or macOS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you must do any of the preceding points, create separate menus for each platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you take the approach of building separate menus for each platform, of course,
    you can implement whatever features are supported on the platform in question.
    However, just because you *can* use a feature on a platform doesn't necessarily
    mean you *should*. In the next section, we'll look at the guidelines and standards
    that can help you decide how to implement a menu on each platform.
  prefs: []
  type: TYPE_NORMAL
- en: Menu guidelines and standards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each of our major platforms offers standards to direct developers in making
    user interfaces that meet the expectations of that system's users. While these
    standards should be taken into consideration for the whole application, one of
    the most visible areas affected by them is the layout of the application menu
    (or menu bar, to use the standard terminology).
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the standards available for each platform, which we'll refer to
    later in the chapter when we create a cross-platform main menu.
  prefs: []
  type: TYPE_NORMAL
- en: Windows user experience interaction guidelines
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Microsoft's *Windows user experience interaction guidelines*, available at [https://docs.microsoft.com/en-us/windows/win32/uxguide/guidelines](https://docs.microsoft.com/en-us/windows/win32/uxguide/guidelines),
    offer developers a wealth of information for designing applications that fit right
    in to the Windows desktop. Among many guidelines offered for menu bar design is
    a description of the standard menu items and how they should be arranged.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, Microsoft has just released newer guidelines aimed at
    Windows 11 and the Universal Windows Platform, available at [https://docs.microsoft.com/en-us/windows/apps/design/basics/](https://docs.microsoft.com/en-us/windows/apps/design/basics/).
    However, these newer guidelines do not offer specific guidance on menu structure,
    so we have used the older guidelines instead.
  prefs: []
  type: TYPE_NORMAL
- en: Apple's human interface guidelines
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Apple's human interface guidelines are available at [https://developer.apple.com/macos/human-interface-guidelines/](https://developer.apple.com/macos/human-interface-guidelines/)
    and offer a detailed set of rules for creating macOS-friendly interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: While much of the basic advice for menu bar design is similar to that offered
    by Microsoft, the layout recommendations are quite different and much more specific.
    For example, the first cascade on a macOS application should be the App menu,
    a menu named after the application, which contains items like **About** and **Preferences**.
  prefs: []
  type: TYPE_NORMAL
- en: Linux and BSD human interface guidelines
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In sharp contrast to Windows and macOS, Linux, BSD, and other X11 systems have
    no blessed default desktop environments or controlling entities to dictate UI
    standards. There are well over a dozen full desktop environments available for
    these platforms, each with its own goals and ideas about user interaction. While
    there are multiple projects working to create **human interface guidelines** (**HIG**)
    for these platforms, we'll be following the Gnome HIG from the Gnome project.
    This set of guidelines is used by the Gnome, MATE, and XFCE desktops and is available
    at [https://developer.gnome.org/hig/](https://developer.gnome.org/hig/). The Gnome
    desktop is the default desktop environment on many Linux distributions, including
    Red Hat, Ubuntu, and notably Debian, which is our target Linux environment at
    ABQ.
  prefs: []
  type: TYPE_NORMAL
- en: Menus and accelerator keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Accelerator keys are keyboard shortcuts assigned to common application actions,
    particularly menu items. Thus far, we've added no accelerator keys, which is bad
    for keyboard-only users.
  prefs: []
  type: TYPE_NORMAL
- en: In Tkinter, accelerator keys can be assigned to a widget using the `bind()`
    method. We can also use the `bind_all()` method, which can be called on any widget
    and effectively binds an event globally (that is, even if the widget that called
    `bind_all()` is not focused). Our menu items also take an `accelerator` argument,
    which can be used to specify a string that will be shown in the menu as an accelerator
    key hint.
  prefs: []
  type: TYPE_NORMAL
- en: The UI guidelines on each platform define standard accelerator keys for common
    actions, most of which are the same across platforms since they descend from the
    IBM **Common User Access** (**CUA**) standard established in the 1980s. The most
    notable difference is the use of the command (![](img/B17578_10_001.jpg)) key
    on macOS in place of the control (Ctrl) key used by Windows and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: As we rewrite our application menus for cross-platform compatibility, we'll
    also add platform-appropriate accelerator keys.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform fonts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 9*, *Improving the Look with Styles and Themes*, we learned how
    easy it is to customize Tkinter's fonts to change the look and feel of your application.
    Doing so, however, can cause inconsistencies across platforms.
  prefs: []
  type: TYPE_NORMAL
- en: There are around 18 fonts that are shared between macOS and Windows, but not
    all of them look identical on both platforms. As for Linux, most distributions
    ship with none of those 18 fonts due to license issues.
  prefs: []
  type: TYPE_NORMAL
- en: Unless you can guarantee that a particular font is available on all supported
    platforms, it's best to avoid naming specific font families in your styles. Fortunately,
    if you do happen to specify a nonexistent font, Tkinter will just use the default,
    but even that could cause layout or readability issues in certain cases.
  prefs: []
  type: TYPE_NORMAL
- en: To be safe, stick with Tkinter's named fonts, which are automatically set to
    the same defaults on each platform.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform theme support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in *Chapter 9*, *Improving the Look with Styles and Themes*, Ttk provides
    a number of themes that differ from platform to platform. Each platform contains
    an alias called "default", which points to the most sensible theme for that platform.
    Attempting to set a theme that doesn't exist results in an exception, so avoid
    hardcoding a theme setting in your application, and make sure theme choices are
    checked against the output of `Style.theme_names()`.
  prefs: []
  type: TYPE_NORMAL
- en: Window zoomed state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to maximized and minimized windows, many windowing environments
    have the concept of a "zoomed" window, which takes over the screen completely.
    On Windows or macOS, it can be activated for a Tkinter application using the root
    window''s `state()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: On Windows or macOS, this creates a window that takes over the screen; on Linux
    or BSD, however, it raises an exception because X11 does not provide anything
    for setting a zoomed state.
  prefs: []
  type: TYPE_NORMAL
- en: 'On X11, this is accomplished by turning on the root window''s `-zoomed` attribute
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, the preceding code raises an exception on Windows and macOS.
    If you need to be able to set this state in a program, you'll need to use some
    platform-specific code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've walked through a variety of cross-platform issues, let's take
    a look at ABQ Data Entry and see what we can do to improve its behavior across
    different operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Improving our application's cross-platform compatibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our application does pretty well across platforms, but there are some things
    we can do to improve it:'
  prefs: []
  type: TYPE_NORMAL
- en: First, our application stores its preferences in the user's home folder, which
    is not ideal on any platform. Most desktop platforms define specific locations
    where configuration files should be placed, so we will fix our application to
    use those for the `abq_settings.json` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, we're creating our CSV files without specifying any encoding; if a user
    inserted a Unicode character (say, in the `Notes` field), file saving would raise
    an exception and fail on non-Unicode platforms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the current menu structure does not really come close to following
    any of the human interface guidelines we've discussed. We'll implement separate
    menus for each platform to ensure users have a UI that is consistent with their
    platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Storing preferences correctly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each platform defines a proper location for storing user configuration files:'
  prefs: []
  type: TYPE_NORMAL
- en: Linux and other X11 systems store configuration files in a location defined
    in the `$XDG_CONFIG_HOME` environment variable, which defaults to `$HOME/.config`
    if it's not defined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS user configuration files are stored in `$HOME/Library/Application Support/`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows user configuration files are stored in `%USERPROFILE%\AppData\Local`.
    Though if your environment uses **Active Directory** (**AD**) with roaming profiles,
    you might prefer to use `%HOME%\AppData\Roaming` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To realize this in our application, we'll need to update the `SettingsModel`
    class. Remember that our `SettingsModel` class's initializer method currently
    places the configuration file in `Path.home()`, which returns the user's home
    directory on each platform. Let's update this with some platform-specific code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, open `models.py` and import the `platform` module, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To figure out the directories required, we're going to need to get the name
    of the platform, as well as some environment variables. The `os.environ` variable
    is a dictionary containing the environment variables set on the system. Since
    we've already imported `os` into the `models.py` file, we can use `os.environ`
    to retrieve the variables we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `SettingsModel` class, we''ll create a dictionary for looking up the
    correct configuration directories, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In each case, we've matched a platform name with a `pathlib.Path` object pointing
    to the default configuration directory for each platform. Now, inside the `SettingsModel`
    initializer, we just need to look up the correct directory using the value of
    `platform.system()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `__init__()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If the platform is not in our list, we simply default to `Path.home()` to place
    the configuration file in the user's home directory. Otherwise, the file should
    be placed correctly for the platform.
  prefs: []
  type: TYPE_NORMAL
- en: Now when you run the application, you should find that any previous preferences
    are reset to the default (since we're now looking for the configuration file in
    a different location), and that if you save new preferences, the file `abq_settings.json`
    shows up in your platform's configuration directory.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying an encoding for our CSV file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our application is currently saving CSV files using the system's default encoding.
    This could be a problem for Windows users if they try to use Unicode characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `models.py`, we need to locate the three instances of `open()` in our `CSVModel`
    class and specify an encoding, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Make sure to update all the `open()` calls in `models.py`, including those in
    `SettingsModel`. With this change, the Unicode characters should no longer be
    a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Making platform-appropriate menus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating platform-specific menus is going to be a bit more involved than the
    previous fixes. Our basic approach will be to create multiple menu classes and
    use a selector function to return an appropriate class as explained in the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can do this, we'll need to prepare our `MainMenu` class so that it's
    easier to subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing our MainMenu class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, the bulk of the configuration of our `MainMenu` class takes place
    in `__init__()`. For each platform, though, we're going to need to build the menu
    with a different structure, and with some different details for certain commands.
    To make this simpler, we're going to take a compositional approach, in which we'll
    break the menu creation into many discrete methods that we can then compose in
    each subclass as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we''ll do is change its name to explain its role more clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We've also created an empty `styles` dictionary as a class attribute. Since
    menu styles are not supported across all platforms well, this empty dictionary
    can act as a placeholder so that we can apply styles when desired by simply overriding
    this attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we're going to create individual methods for creating each menu item.
    Because these items may be added to different menus depending on the platform,
    each method will take a `menu` argument that will be used to specify which `Menu`
    object it will be added to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with methods for creating our **Select file** and **Quit** command
    entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the methods to add the auto-fill settings options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'For our font options that have their own sub-menus, we''ll create methods that
    create the whole sub-menu, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that we've used the `self.styles` dict in defining our cascade menus; although
    it's empty in this class, we want the styles to apply to all menus if we define
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the themes menu, we''ll do the same, and also set up the trace that displays
    the warning message, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s add the last three methods for our navigation and About commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, to compose these methods into a menu, we'll create a new method called
    `_build_menu()`. This method can be overridden by our subclasses, leaving `__init__()`
    to take care of the common setup tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this will work, let''s create a version of this method that will
    recreate our generic menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're creating our File, Options, Go, and Help cascade menus, and passing
    each one to the appropriate item-adding methods to set up its items. We're storing
    these in a dictionary, `self._menus`, rather than as local variables. At the end
    of the method, we iterate through the dictionary to add each cascade to the main
    menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can reduce the initializer of this class to a bare skeleton of method
    calls, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: After calling the superclass initializer, this method just saves the settings,
    creates the icons and the `_menus` dictionary, then calls `_build_menu()`. If
    any styles are set, those are applied to the main menu by `self.configure()`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding accelerators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we start building subclasses of `GenericMainMenu`, let's make it possible
    to add platform-specific accelerator keys to each menu. These are simply keyboard
    shortcuts that can activate our menu items. We don't need these for every menu
    item, just a few commands that will be commonly used.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a key binding to menu items, there are two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Bind the keyboard event to the callback using the `bind_all()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Label the menu item with the keyboard sequence using the menu entry's accelerator
    argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's important to understand that we need to do both; the `accelerator` argument
    does not automatically set up the key binding, it just determines how the menu
    item will be labeled. Likewise, the `bind_all()` method will not cause menu items
    to be labeled, it will just create the event binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish both, we''ll create two class attribute dictionaries, one for
    the accelerators and one for the key bindings, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The first dictionary simply matches accelerator strings with keys that we can
    use in our menu definition methods. To use this dictionary, we just need to update
    those methods to include the accelerator; for example, update the `_add_file_open()`
    method like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and add the `accelerator` argument to the `add_command()` calls in
    `_add_quit()`, `_add_go_record_list()`, and `_add_go_new_record()` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle the key bindings, we just need to create a method that will make
    the key bindings. Add this `_bind_accelerators()` method to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `_bind_accelerators()` method iterates the `keybinds` dictionary and binds
    each key sequence to a function created by the `_event()` method that will generate
    the given event. Note that we've used `bind_all()` here; unlike the `bind()` method,
    which only responds to events on the widget, the `bind_all()` method will cause
    the callback to be executed when the event is generated on *any* widget. Thus,
    regardless of what widget is selected or in focus, a Control + Q keystroke will
    quit the program, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final piece is to call this new method from our initializer. Add this to
    the end of `GenericMainMenu.__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now the `GenericMainMenu` class is ready for subclassing. Let's go through one
    platform at a time and figure out what needs to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Windows menu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After studying the *Windows user experience interaction guidelines*, you deem
    the following changes are necessary to make our menu Windows-friendly:'
  prefs: []
  type: TYPE_NORMAL
- en: '**File** | **Quit** should be changed to **File** | **Exit**, and there should
    be no accelerator for it. Windows uses Alt + F4 to close programs, and this is
    handled by Windows automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows can handle commands in the menu bar just fine, and the guidelines encourage
    this for frequently used functionality. We'll move our Record List and New Record
    commands directly to the main menu. We'll have to remove the icons, though, since
    it can't handle icons in the main menu.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration option items are supposed to go under a Tools menu, separated
    from the rest of the items in tools (if there are any). We'll need to create a
    Tools menu and move our options there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s implement these changes and create our Windows menu class. Start by
    subclassing the `GenericMainMenu` class like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we''ll do is override the initializer so we can remove the
    keybinding for **File** | **Exit**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll need to override the `_add_quit()` method to relabel it and remove
    the accelerator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to remove the icons for the two navigation commands, so that we don''t
    have the **(Image)** string showing up in our menu. To do that, we''ll next override
    the `_create_icons()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The superclass version of the method creates `self.icons`, so we just need to
    run it and delete the icons we don't want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that those are fixed, we can create the `_build_menu()` method to compose
    our menu, starting with the three cascades like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we''d like to add our navigation command entries for Record List and
    NewRecord directly to the main menu rather than to a cascade menu, we can''t just
    iterate over the `_menus` dictionary to add the cascades. Instead, we''ll have
    to manually add the entries to the top-level menu, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The Windows menu is now complete and ready to use. Let's move on to the next
    platform!
  prefs: []
  type: TYPE_NORMAL
- en: Building the Linux menu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our `GenericMainMenu` class is pretty close to the Gnome HIG, but there is
    one change to be made: our Options menu doesn''t really belong; rather, we need
    to split its items into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: The autofill options, since they change the way data is entered in the form,
    belong in an Edit menu.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The font and theme options, since they only change the appearance of the application
    and not the actual data, belong in a View menu.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since Linux also fully supports menu colors, we'll add our color styles back
    to this version of the menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by subclassing `GenericMainMenu` and defining some styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: These menu styles aren't strictly necessary, but if we're going to make a separate
    menu for Linux, we may as well take advantage of some of its features!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s begin the `_build_menu()` method with the File and Edit menus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we''ve added back `**self.styles` to each `Menu()` call to apply
    the styles. We''ll do the same building the next three cascades, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll iterate over the `_menus` dictionary and add all the cascades:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We don't need to change anything else; our accelerators and the rest of the
    menu line up pretty well with the Gnome HIG.
  prefs: []
  type: TYPE_NORMAL
- en: Building the macOS menu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of the three platform-specific menus, the macOS menu will need the most extensive
    changes. Unlike the Windows and Gnome guidelines, which mostly suggest categories,
    the Apple guidelines are very specific about which menus should be created and
    which items belong in them. Furthermore, macOS also creates and pre-populates
    some of these menus with default commands, so we'll need to use special arguments
    to hook into those menus and add our own items.
  prefs: []
  type: TYPE_NORMAL
- en: 'The changes we need to make to comply with Apple''s HIG are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to create an **App menu**. This is the first menu macOS creates, just
    to the right of the Apple icon on the menu bar. It's created by default, but we'll
    need to hook into it to add some custom items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The About command belongs in the App menu; we'll move it there and remove the
    unused Help menu.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since macOS will provide a Quit command for us, we'll remove ours.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we did with the Linux menu, our options will be split between the Edit and
    View menus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to add a Window menu; this is another autogenerated menu that macOS
    fills with window management and navigation functions. Our navigation items will
    be moved from the Go menu to this menu.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, macOS uses the command key rather than the Control key to activate
    accelerators. We need to update both our key bindings and accelerator dictionaries
    accordingly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As before, we''ll start by creating a subclass of `GenericMainMenu`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we've done is redefine the `keybinds` and `accelerators` dictionaries
    to remove the `Quit` entries and change "`Control`" `to` "`Command`". Note that,
    when the menu displays, Tkinter will automatically replace the strings `Command`
    or `Cmd` with the symbol for the command key (![](img/B17578_10_0011.jpg)), so
    make sure to use one or the other when specifying accelerators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s start working on the `_build_menu()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The first order of business is the App menu. To access this built-in menu, all
    we need to do is pass in a `name` argument set to `apple` when we create the `Menu`
    object. The App menu should contain both our About option and our Quit option,
    but we only need to add the former since macOS automatically adds a Quit action.
    Note that we've also added a separator, which should always be added after the
    About command.
  prefs: []
  type: TYPE_NORMAL
- en: The App menu should *always* be the first menu you add to the main menu on macOS.
    If you add anything else first, your customized app menu items will be added in
    their own menu rather than in the generated App menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on, we need to make one correction to our About command. Apple''s
    HIG specifies that this command should read *About <program name>* rather than
    just *About*. So, we''ll need to override `_add_about()` to correct this, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Your App menu will currently read "Python" rather than "ABQ Data Entry". We'll
    address this when we package our application in *Chapter 16*, *Packaging with
    setuptools and cxFreeze*.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the App menu is created, let''s create our File, Edit, and View menus,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t really need to do anything different there; however, the `Window`
    menu is another automatically generated menu created by macOS, so we will once
    again need to use the `name` argument when creating it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s iterate over the `_menus` dictionary and add all the cascades:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Even though macOS automatically creates the App and Window menus, you still
    need to explicitly add the `Menu` objects to the main menu using `add_cascade()`,
    or your added items will not appear on the automatically created menu.
  prefs: []
  type: TYPE_NORMAL
- en: That completes our macOS menu class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using our selector function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With our classes created, let''s add a simple selector function to return the
    appropriate class for each platform; add this code to `mainmenu.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The keys in this dictionary are the output strings from `platform.system()`,
    which we have pointed to a platform-appropriate menu class. In the event we're
    running on some new, unknown system, we default to the `GenericMainMenu` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back in `application.py`, we''ll change our import statement from `mainmenu`
    to only import this function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note that we've also imported `platform`, which we'll use to determine the running
    operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, instead of calling `v.MainMenu()` (which no longer exists), we use the
    following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when you run the application, your menu appearance will change according
    to the platform. On Windows, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4: The menu system on a Windows computer](img/B17578_10_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: The menu system on a Windows computer'
  prefs: []
  type: TYPE_NORMAL
- en: 'On macOS, you''ll see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5: The menu system on macOS](img/B17578_10_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: The menu system on macOS'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Linux or BSD, you''ll see a menu as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5: The menu system on Ubuntu Linux](img/B17578_10_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: The menu system on Ubuntu Linux'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to write Python software that works well across
    multiple platforms. You learned how to avoid common platform pitfalls in Python
    code such as filesystem differences and library support, and how to write software
    that intelligently adapts to the needs of different operating systems. You also
    learned about published guidelines that help developers write software that meets
    platform users' expectations, and you used these guidelines to create platform-specific
    menus for ABQ Data Entry.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to learn about automated testing. You'll learn
    to write tests that ensure your code works correctly, both for regular Python
    code and specifically for Tkinter code, and to take advantage of the testing framework
    included in the Python standard library.
  prefs: []
  type: TYPE_NORMAL
