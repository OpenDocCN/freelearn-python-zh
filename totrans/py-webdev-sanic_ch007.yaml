- en: 6 Operating outside the Request Handler
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 在请求处理器之外操作
- en: The basic building block of application development within Sanic is the request
    handler, which is sometimes known as a “route handler”. Those terms can be used
    interchangeably and mean the same thing. It is the function that Sanic runs when
    a request has been routed to your application to be handled and responded to.
    This is where business logic and HTTP logic combine to allow the developer to
    dictate how responses should be delivered back to the client. It is the obvious
    place to start when learning how to build with Sanic.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Sanic 中，应用程序开发的基本构建块是请求处理器，有时也称为“路由处理器”。这些术语可以互换使用，意思相同。这是当请求被路由到你的应用程序进行处理和响应时
    Sanic 运行的函数。这是业务逻辑和 HTTP 逻辑结合的地方，允许开发者规定如何将响应发送回客户端。这是学习如何使用 Sanic 构建时的明显起点。
- en: However, request handlers alone do not provide enough power to create a polished
    application experience. In order to build out an application that is polished
    and professional, we must break outside the handler to see what other tools Sanic
    has to offer. It is time to think about the HTTP request/response cycle as not
    being confined to a single function. We will broaden our scope so that responding
    to a request is not the responsibility of just the handler, but of the entire
    application. We have already gotten a taste of this when we caught a glimpse of
    middleware.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅请求处理器本身并不能提供足够的强大功能来创建一个精致的应用程序体验。为了构建一个精致且专业的应用程序，我们必须跳出处理器，看看 Sanic 还能提供哪些其他工具。现在是时候考虑
    HTTP 请求/响应周期不再局限于单个函数了。我们将扩大我们的范围，使得响应请求不再仅仅是处理器的责任，而是整个应用程序的责任。当我们瞥见中间件时，我们已经尝到了这种味道。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Making use of ctx
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 ctx
- en: Altering requests and responses with middleware
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用中间件修改请求和响应
- en: Leveraging signals for intra-worker communication
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用信号进行工作内通信
- en: Mastering HTTP connections
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握 HTTP 连接
- en: Implementing Exception handling
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现异常处理
- en: Background task processing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景任务处理
- en: Of course, not all projects will need features like these, but when used in
    the right place they can be extremely powerful. Have you ever worked on a DIY
    project around your home and not quite had the right tools for the job? It can
    be super frustrating and inefficient when you need a Phillips-head screwdriver,
    but all you have are flat head screwdrivers. Not having the right tool for the
    job can make your task harder, but it also sometimes decreases the quality of
    the work that you can perform.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并非所有项目都需要这些功能，但当它们被用在正确的地方时，它们可以非常强大。您是否曾经在家中的 DIY 项目中工作，但并没有找到合适的工具？当您需要一字螺丝刀，但只有平头螺丝刀时，这可能会非常令人沮丧且效率低下。没有合适的工具会使任务变得更难，有时也会降低您能完成的工作质量。
- en: 'Think of the features that we explore in this Chapter as tools. There is a
    common saying you may have heard that says: “*If you are holding a hammer, then
    every problem looks like a nail*.” Lucky for us, we have a bunch of tools and
    our job now is to learn how to use them. We are about to go explore the Sanic
    tool belt and see what kinds of problems we can solve.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下我们在本章中探索的功能就像工具。你可能听说过这样一句俗语：“*如果你手里拿着锤子，那么每个问题看起来都像钉子*。”幸运的是，我们有一系列工具，我们的工作现在就是学习如何使用它们。我们即将探索
    Sanic 工具包，看看我们能解决哪些问题。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, you should have the same tools available as in the previous
    Chapters at your disposal in order to be able to follow along with the examples
    (IDE, modern Python, and curl).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您应该拥有与之前章节相同的工具，以便能够跟随示例（IDE、现代 Python 和 curl）。
- en: 'You can access source code for this chapter on GitHub: [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/06](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/06).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的源代码：[https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/06](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/06)。
- en: Making use of ctx
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用 ctx
- en: 'Before we begin with the tool belt, there is one more concept that we must
    become familiar with. It is fairly ubiquitous in Sanic, and you will see it in
    a lot of places. I am talking about: `ctx`. What is it?'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始工具包之前，还有一个概念我们必须熟悉。它在 Sanic 中相当普遍，你会在很多地方看到它。我说的就是：`ctx`。那是什么？
- en: It is stands for *context*. These `ctx` objects can be found in a number of
    places, and it is impractical to build without making good use of them. What they
    enable is the passing of state from one location in your application to another.
    They exist for your own usage as a developer, and you should feel free to use
    them however you wish. That is to say that the `ctx` objects are yours to add
    information to without worrying about name collisions or otherwise impacting the
    operation of Sanic.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它代表*上下文*。这些`ctx`对象可以在多个地方找到，不利用它们来构建是不切实际的。它们允许将状态从应用程序的一个位置传递到另一个位置。它们是为了开发者自己的使用而存在的，你应该自由地按照自己的意愿使用它们。也就是说，`ctx`对象是你的，你可以添加信息而不用担心名称冲突或以其他方式影响Sanic的操作。
- en: The most common example that comes to mind is your database connection object.
    You create it once, but you want to have access to it in many places. How does
    this work?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的例子是数据库连接对象。你只创建一次，但你想在许多地方访问它。这是怎么做到的？
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, anywhere you can access the application instance, you can access the db
    instance. For example, you can access it inside a function somewhere:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在任何可以访问应用实例的地方访问数据库实例。例如，你可以在某个函数内部访问它：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is a list of all of the locations that have a `ctx` object:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了所有具有`ctx`对象的位置：
- en: '| **Object** | **Description** | **Example** |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **对象** | **描述** | **示例** |'
- en: '| Sanic | Available during the entire lifetime of your worker instance. It
    is worker specific, meaning that if you run multiple workers, it will *not* keep
    them synchronized. Best used for connection management, or other things that need
    to be made available throughout the lifetime of the application instance. | `app.ctx`
    |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| Sanic | 在你的工作实例整个生命周期内可用。它是针对工作实例特定的，这意味着如果你运行多个工作实例，它们将*不会*保持同步。最适合用于连接管理，或其他需要在应用实例整个生命周期内可用的东西。
    | `app.ctx` |'
- en: '| Blueprint | Available on a Blueprint instance as long as the blueprint exists.
    This might be helpful if you have some specific data that needs to be available
    for the entire worker lifetime, but you want to control its access to anything
    attached to that particular Blueprint. | `bp.ctx` |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 蓝图 | 在蓝图实例存在期间可用。这可能有助于你有一些特定的数据需要在整个工作实例生命周期内可用，但你又想控制它对特定蓝图附加内容的访问。 | `bp.ctx`
    |'
- en: '| Request | Available for the duration of a single HTTP request. Helpful for
    adding details in middleware, and then making it available in the handler or other
    middleware. Common uses include session IDs and user instances. | `request.ctx`
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 请求 | 在单个HTTP请求期间可用。对于在中间件中添加详细信息并在处理程序或其他中间件中使其可用很有帮助。常见用途包括会话ID和用户实例。 |
    `request.ctx` |'
- en: '| ConnInfo | Available for the duration of an entire HTTP connection (potentially
    multiple requests). Be careful with this one particularly if you use a proxy.
    It usually should not be used for sensitive information. | `request.conn_info.ctx`
    |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| ConnInfo | 在整个HTTP连接期间（可能包括多个请求）可用。如果你使用代理，请特别小心。通常不应用于敏感信息。 | `request.conn_info.ctx`
    |'
- en: '| Route | Available on the Route and Signal instances. This is the one exception
    where Sanic actually does store some details on the ctx object. | `request.route.ctx`
    |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 路由 | 在路由和信号实例上可用。这是Sanic实际上在ctx对象上存储一些细节的唯一例外。 | `request.route.ctx` |'
- en: Table 6.1 - Sanic features with a `ctx` object
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1 - 使用`ctx`对象的Sanic特性
- en: We will continue to come back to `ctx` objects often. They are a very important
    concept in Sanic to allow the passing of arbitrary data and objects. Not all of
    them are created equal, and you will likely find yourself using `app.ctx` and
    `request.ctx` much more often than any of the others.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将经常回到`ctx`对象。它们在Sanic中是一个非常重要的概念，允许传递任意的数据和对象。它们并不完全相同，你可能会发现自己比其他任何对象更频繁地使用`app.ctx`和`request.ctx`。
- en: Now that we have this basic building block behind us, we will see what it actually
    looks like to pass these objects around. In the next section regarding middleware,
    we will see how the Request object—and therefor also the `request.ctx`—can be
    accessed in multiple places from your application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个基本构建块，我们将看到这些对象是如何在应用程序中传递的。在下一节关于中间件的部分，我们将看到请求对象——因此也是`request.ctx`——如何在应用程序的多个地方被访问。
- en: Altering requests and responses with middleware
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用中间件修改请求和响应
- en: If you have been following along with the book up until now, the concept of
    middleware should be familiar. This is the first tool in the tool belt that you
    should become familiar with.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直跟随这本书到现在，中间件的概念应该是熟悉的。这是你应该熟悉的第一件工具。
- en: 'Middleware are snippets of code that can be run before and after route handlers.
    Middleware comes in two varieties: request and response.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是可以在路由处理器前后运行的代码片段。中间件有两种类型：请求和响应。
- en: Request middleware
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求中间件
- en: The request middleware executes in the order in which it was declared, before
    the route handler.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请求中间件按照声明的顺序执行，在路由处理器之前。
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When we try and reach this endpoint, we should see the following in the terminal:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试达到这个终点时，我们应该在终端看到以下内容：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'But, this only tells part of the story. Sometimes we may need to add some additional
    logic to only *parts* of our application. Let’s pretend we are working on building
    an e-commerce application. Like other online stores, we will need to build a shopping
    cart that holds products that are going to be purchased. For the sake of our example,
    we will imagine that when the user logs in, we create the cart in our database
    and store a reference to it in a cookie. Something like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这只能讲述故事的一部分。有时我们可能需要添加一些额外的逻辑来仅针对我们应用程序的**部分**。让我们假设我们正在构建一个电子商务应用程序。像其他在线商店一样，我们需要构建一个购物车来存放将要购买的产品。为了我们的示例，我们将想象当用户登录时，我们在数据库中创建购物车，并将其引用存储在cookie中。类似于这样：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Do not get too tied up in the details here. The point is that on every subsequent
    request, there will be a cookie called cart that we can use to fetch data from
    our database.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过于纠结于这里的细节。重点是，在每次后续请求中，都将会有一个名为cart的cookie，我们可以用它从我们的数据库中获取数据。
- en: Now, suppose that we want all endpoints on our `/cart` path to have access to
    the shopping cart. We might have endpoints for adding items, removing items, changing
    quantities, and so on. However, we will always need access to the cart. Rather
    than repeating the logic in every handler, we can do it once on the Blueprint.
    Adding middleware to all the routes on a single Blueprint looks and functions
    similarly to application wide middleware.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们希望我们的`/cart`路径上的所有端点都能访问购物车。我们可能有添加项目、删除项目、更改数量等端点。然而，我们始终需要访问购物车。而不是在每个处理器中重复逻辑，我们可以在蓝图上做一次。将中间件添加到单个蓝图上的所有路由看起来和功能与应用范围中间件相似。
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we would expect, every endpoint that is attached to the `ShoppingCart` Blueprint
    will fetch the cart before it runs the handler. I am sure you can see the value
    in this sort of pattern. Where you can identify a group of routes that need a
    similar functionality, sometimes it is best to pull that out into middleware.
    This is a good time to also point out that this works also with Blueprint Groups.
    We could change the middleware to this and have the same impact:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所期望的，每个附加到`ShoppingCart`蓝图上的端点在运行处理器之前都会获取购物车。我相信你可以看到这种模式的价值。当你能够识别一组需要类似功能的路由时，有时最好将其提取到中间件中。这也是指出这一点的好时机，即这也适用于蓝图组。我们可以将中间件更改为这样，并产生相同的影响：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Just as we would expect, endpoints that are within that Blueprint Group will
    now have the shopping cart accessible to them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所期望的，属于该蓝图组的端点现在可以访问购物车。
- en: 'Knowing that we can execute middleware both application-wide and blueprint-specific
    leads to an interesting question: in what order are they applied? No matter the
    order in which they are declared, all application-wide middleware will *always*
    run before the blueprint-specific middleware. To illustrate this point, we will
    use an example that mixes the two types.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 知道我们可以在应用范围和蓝图特定范围内执行中间件，这引发了一个有趣的问题：它们应用的顺序是什么？无论它们声明的顺序如何，所有应用范围的中间件都将**始终**在蓝图特定中间件之前运行。为了说明这一点，我们将使用一个混合两种类型的示例。
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see in this example, we interspersed declaring application and blueprint
    middleware by alternating between them: first application, then blueprint, etc.
    While the code lists the functions in sequential order (1, 2, 3, 4, 5, 6), our
    output will not be. You should be able to anticipate how our endpoints will respond
    with the application numbers appended before the blueprint numbers. Sure enough,
    that is the case:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个示例所示，我们通过交替声明应用和蓝图中间件来穿插它们：首先是应用，然后是蓝图等。虽然代码按顺序列出函数（1，2，3，4，5，6），但我们的输出不会。你应该能够预测我们的端点将如何响应，应用编号将附加在蓝图编号之前。确实如此：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It is also really helpful to point out that since middleware is just passing
    along the `Request` object, subsequent middleware has access to whatever changes
    earlier middleware performed. In this example, we created the list of numbers
    in one, which was then available to all of the middleware.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点很有帮助的是指出，由于中间件只是传递`Request`对象，后续中间件可以访问早期中间件所做的任何更改。在这个例子中，我们在一个中间件中创建了数字列表，然后它对所有中间件都是可用的。
- en: Response middleware
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应中间件
- en: 'On the other side of the HTTP lifecycle, we have response middleware. The same
    rules for request middleware apply:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTTP生命周期的另一边，我们有响应中间件。请求中间件的规则同样适用：
- en: It is executed based upon the order of declaration, *although, it is reverse
    order!*
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是根据声明的顺序执行的，*尽管它是反向顺序！*
- en: Response middleware can be both application-wide or blueprint-specific
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应中间件可以是应用范围内的或蓝图特定的
- en: All application-wide middleware will run before any blueprint-specific middleware
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有应用范围内的中间件将在任何蓝图特定中间件之前运行
- en: 'In the last section, we counted from 1 through 6 using middleware. We will
    take the exact same code (order is important!), but change from request to response:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们使用中间件从1计数到6。我们将使用完全相同的代码（顺序很重要！），但将请求改为响应：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, when we hit our endpoint, we will see a different order:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们访问我们的端点时，我们将看到不同的顺序：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Uh oh, what happened? Well, since we did not define our `ctx.numbers` container
    until the response middleware, it was not available inside the handlers. Let’s
    make a quick change. We will create that object inside of a request middleware.
    For the sake of our example, we also will return None from the request handler,
    and instead create our response from our last middleware. In this example, the
    last middleware to respond will be the first Blueprint response middleware declared.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，发生了什么事？嗯，因为我们直到响应中间件才定义了我们的`ctx.numbers`容器，所以在处理程序内部不可用。让我们快速修改一下。我们将在请求中间件内部创建该对象。为了我们的示例，我们还将从请求处理程序返回None，而不是从最后一个中间件创建我们的响应。在这个例子中，最后一个响应中间件将是第一个声明的蓝图响应中间件。
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Take a close look at the above. We still have a mixture of application and
    blueprint middleware. We create the numbers container inside of the handler. Also,
    it is important to note that we are using the exact same ordering that we used
    for the request middleware that yielded: 1, 3, 5, 2, 4, 6\. The changes here are
    merely to show us how response middleware reverses its order. Can you guess what
    order our numbers will be in? Let’s check:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看上面的内容。我们仍然有应用和蓝图中间件的混合。我们在处理程序内部创建了数字容器。此外，重要的是要注意，我们正在使用与请求中间件相同的顺序，后者产生了：1,
    3, 5, 2, 4, 6。这里的更改只是为了向我们展示响应中间件是如何反转其顺序的。你能猜出我们的数字将按什么顺序排列吗？让我们检查一下：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First, all of the application-wide response middleware runs (in reverse order
    of declaration). Second, all of the blueprint-specific middleware runs (in reverse
    order of declaration). Keep this distinction in mind when you are creating your
    response middleware if they are interconnected.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，所有应用范围内的响应中间件都会运行（按声明的反向顺序）。其次，所有蓝图特定的中间件都会运行（按声明的反向顺序）。当你创建响应中间件时，如果它们相互关联，请记住这个区别。
- en: Whereas a common use-case for request middleware is to add some data to the
    request object for further processing, this is not so practical for response middleware.
    Our above example is a bit odd and impractical. What then is response middleware
    good for? The most common use case is probably setting headers and cookies.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然请求中间件的常见用例是为请求对象添加一些数据以供进一步处理，但这对于响应中间件来说并不实用。我们上面的例子有点奇怪且不实用。那么响应中间件有什么用呢？最常见的情况可能是设置头和cookie。
- en: 'Here is a simple (and very common) use case:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单（并且非常常见）的用例：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Why would you want to do this? Many web APIs use what is known as a *correlation
    ID* to help identify individual requests. This is helpful for logging purposes,
    for tracking a request as it trickles through various systems in your stack, and
    also for clients that are consuming your API to keep track of what is happening.
    Sanic latches onto this principal and will set the `request.id` automatically
    for you. This value will either be the incoming correlation ID from the incoming
    request headers, or a unique value generated per request. By default, Sanic will
    generate a UUID for this value. You usually will not need to worry about this
    unless you want to use something other than a UUID for correlating web requests.
    If you are interested in how you can override Sanic’s logic for generating these,
    checkout *Chapter 11*, *A complete real-world example*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你为什么要这样做呢？许多Web API使用所谓的*关联ID*来帮助识别单个请求。这对于日志记录目的很有帮助，对于跟踪请求在堆栈中通过各种系统时的流动，以及对于消费你的API的客户来说，跟踪正在发生的事情也很有帮助。Sanic遵循这个原则，并将自动为你设置`request.id`。这个值将是来自传入请求头部的传入关联ID，或者为每个请求生成一个唯一值。默认情况下，Sanic将为这个值生成一个UUID。你通常不需要担心这个问题，除非你想要使用除了UUID之外的东西来关联Web请求。如果你对如何覆盖Sanic生成这些值的逻辑感兴趣，请查看*第11章*，*一个完整的真实世界示例*。
- en: 'Coming back to our above example, we see that we are simply grabbing that value
    and appending it to our response headers. We can now see it in action:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们上面的例子，我们看到我们只是简单地获取那个值并将其附加到我们的响应头中。我们现在可以看到它在行动：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This small snippet is something I would highly encourage you to add to all of
    your applications. It is extremely beneficial when you pair it with request ID
    logging. This is also something we will add into our application in *Chapter 11*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这段小代码是我强烈建议你添加到所有你的应用程序中的。当你与请求ID记录结合使用时，它非常有用。这也是我们将在*第11章*中添加到我们的应用程序中的内容。
- en: Responding early (or late) with middleware
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用中间件提前（或延迟）响应
- en: 'When we explored the response middleware ordering example from the last section,
    did you notice something peculiar happening with our responses? Did you see this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们探索上一节中的响应中间件排序示例时，你是否注意到了我们的响应中发生了一些奇怪的事情？你是否看到了这个：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We had a non-sensical response from the handler, but it was not returned. That
    is because in our middleware we returned an `HTTPResponse` object. Whenever you
    return a value from middleware–whether request or response–Sanic will assume that
    you are trying to end HTTP lifecycle and return immediately. Therefore, you should
    *never* return anything from middleware that is:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从处理器得到了一个无意义的响应，但它并没有被返回。这是因为在我们的中间件中我们返回了一个`HTTPResponse`对象。无论何时你从中间件返回一个值——无论是请求还是响应——Sanic都会假设你正在尝试结束HTTP生命周期并立即返回。因此，你*永远*不应该从中间件返回以下任何内容：
- en: Not an `HTTPResponse` object
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不是`HTTPResponse`对象
- en: Not intended to interrupt the HTTP lifecycle
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不打算中断HTTP生命周期
- en: This rule, however, does not apply to None values. You can still use return
    `None` if you simply want to halt execution of the middleware.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个规则不适用于`None`值。如果你只是想停止中间件的执行，仍然可以使用`return None`。
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s see how this plays out now:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看现在会发生什么：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the second request, it was allowed to proceed because it had the correct
    header. Therefore, we can see that returning `None` is also acceptable from middleware.
    If you are familiar with using continue inside of a Python loop, it has roughly
    the same impact: halt execution, and move onto the next step.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个请求中，由于它有正确的头，因此它被允许继续进行。因此，我们可以看到从中间件返回`None`也是可以接受的。如果你熟悉在Python循环中使用`continue`，它大致有相同的影响：停止执行，并进入下一步。
- en: '**Important note**'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Even though we were looking for the value `please` in the request headers, we
    were able to pass `Please` and for it to still work since headers are always case-insensitive.
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管我们正在寻找请求头部的`please`值，但我们能够传递`Please`并且它仍然可以工作，因为头总是不区分大小写的。
- en: Middleware and streaming responses
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中间件和流式响应
- en: There is one more *gotcha* that you should know about middleware. Remember how
    we simply said that the middleware basically wraps before and after the route
    handler? This is not entirely true.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该知道关于中间件的一个额外的*陷阱*。记得我们简单地说中间件基本上是在路由处理器前后封装吗？这并不完全正确。
- en: Truthfully, the middleware wraps the generation of the response. Since this
    *usually* happens in the return statement of a handler, that is why we take the
    simplistic approach.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 真诚地说，中间件封装了响应的生成。由于这*通常*发生在处理器的返回语句中，这就是我们为什么采取简单方法的原因。
- en: 'This point can be easily seen if we revisit our Chapter 5 example with our
    streaming handler. Here is where we started:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾第 5 章的示例并使用我们的流处理程序，这一点很容易看出。这就是我们开始的地方：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let’s add some print statements and some middleware so we can examine the order
    of execution.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些打印语句和一些中间件，以便我们可以检查执行顺序。
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we will hit the endpoint, and look at our terminal logs:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将访问端点，并查看我们的终端日志：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As we would expect, the request middleware runs first, and then we begin the
    route handler. But, the response middleware runs immediately after we call: `request.respond()`.
    For most use cases of response middleware (like adding headers), this should not
    matter. It will, however, pose a problem if you absolutely must execute some bit
    of code *after* the route handler is complete. If this is the case, then your
    solution is to use signals, which we will explore later in this Chapter.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预期的那样，请求中间件首先运行，然后我们开始路由处理程序。但是，响应中间件在我们调用 `request.respond()` 之后立即运行。对于大多数响应中间件的用例（如添加头信息），这通常不会造成问题。然而，如果你绝对必须在路由处理程序完成后执行一些代码，那么这就会成为一个问题。在这种情况下，你的解决方案是使用信号，我们将在本章后面探讨。
- en: But first, we are going to explore signals, which sometimes are a great replacement
    for middleware. While middleware essentially is a tool that allows us to extend
    business logic outside the confines of the route handler, and to share it among
    different endpoints, we will learn that signals are more like breakpoints that
    allow us to interject code into Sanic.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们将探讨信号，有时它们可以很好地替代中间件。虽然中间件本质上是一个工具，它允许我们在路由处理器的限制之外扩展业务逻辑，并在不同的端点之间共享它，但我们会了解到信号更像是允许我们在
    Sanic 中插入代码的断点。
- en: Leveraging signals for intra-worker communication
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用信号进行工作内通信
- en: In general, Sanic tries to make it possible for developers to extend its capabilities
    to create custom solutions. This is the reason that when interfacing with Sanic,
    there are a number of options to inject custom classes to overtake, change, or
    otherwise extend its functionality. For example, did you know that you could swap
    out its HTTP protocol to essentially turn Sanic into an FTP server (or any other
    TCP-based protocol)? Or, maybe you want to extend the router capabilities?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Sanic 试图让开发者能够扩展其功能以创建自定义解决方案。这也是为什么在与 Sanic 接口时，有多个选项可以注入自定义类来接管、更改或以其他方式扩展其功能。例如，你知道你可以替换其
    HTTP 协议，从而将 Sanic 实质上变成一个 FTP 服务器（或任何其他基于 TCP 的协议）吗？或者，你可能想扩展路由功能？
- en: These sorts of customizations are rather quite advanced. We will not cover them
    in this book since for most use cases it is the equivalent of hanging a picture
    nail on your wall with a sledgehammer.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这类定制相当高级。我们不会在本书中涵盖它们，因为对于大多数用例来说，这就像是用手锤在墙上钉钉子一样。
- en: 'The Sanic team introduced signals as a method to extend the functionality of
    the platform in a more user-friendly format. Very intentionally, setting up a
    signal handler looks and feels like a route handler:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic 团队引入信号作为一种在更用户友好的格式中扩展平台功能的方法。非常有意地，设置信号处理程序看起来和感觉就像是一个路由处理程序：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You may be asking: what exactly is this, and how can I use it? In this example,
    we learn that `http.lifecycle.begin` is an event name. When Sanic opens an HTTP
    connection to a client, it dispatches this signal. Sanic will then look to see
    if there are any handlers waiting for it and run them. Therefore, all we did was
    setup a handler to attach to that event. We will dig a little more into the pre-defined
    events in this Chapter. But first, let’s take a closer examination at the structure
    and operation of signals.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问：这究竟是什么，我该如何使用它？在这个例子中，我们了解到 `http.lifecycle.begin` 是一个事件名称。当 Sanic 向客户端打开
    HTTP 连接时，它会派发这个信号。然后 Sanic 会检查是否有任何处理程序正在等待它，并运行它们。因此，我们所做的就是设置一个处理程序来附加到该事件。在本章中，我们将更深入地探讨预定义的事件。但首先，让我们更仔细地检查信号的结构和操作。
- en: Signal definitions
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信号定义
- en: 'All signals are defined by their event name, which is composed of three segments.
    We just saw a signal event called: `http.lifecycle.begin`. Obviously, the three
    segments are `http`, `lifecycle`, and `begin`. An event will *only* ever have
    three segments.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所有信号都通过其事件名称定义，该名称由三个部分组成。我们刚刚看到了一个名为 `http.lifecycle.begin` 的信号事件。显然，这三个部分是
    `http`、`lifecycle` 和 `begin`。一个事件将 *仅* 有三个部分。
- en: 'This is important to know because even though Sanic ships with a bunch of signals
    out of the box, it also allows us to create our own signals along the way. Therefore,
    we will need to follow the pattern. It is helpful to think of the first segment
    as a namespace, the middle as a reference, and the last as an action. Sort of
    like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为尽管 Sanic 默认提供了一组信号，但它也允许我们在过程中创建自己的信号。因此，我们需要遵循这个模式。将第一部分视为命名空间，中间部分视为引用，最后部分视为动作。有点像这样：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Thinking in these terms helps me conceptualize them. I like to think of them
    like routes. In fact, they actually are! Under the hood, Sanic deals with signal
    handlers the same way as it does with route handlers because they inherit from
    the same base class.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式思考有助于我概念化它们。我喜欢把它们想象成路由。事实上，它们确实是！在底层，Sanic 以与路由处理器相同的方式处理信号处理器，因为它们继承自相同的基类。
- en: 'If a signal is essentially a route, does that mean it can look for dynamic
    path parameters too? Yes! Check this out:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果信号本质上是一个路由，那么这意味着它也可以查找动态路径参数吗？是的！看看这个：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Go hit any route in your application now, and we should see the following in
    our terminal:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在去访问应用中的任何路由，我们应该在我们的终端中看到以下内容：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Before continuing on to see what signals are available, there is one more thing
    we need to be aware of: condition. The `app.signal()` method accepts a keyword
    argument called condition that can help in limiting the events that match on it.
    Only an event that is dispatched with the same condition will be executed.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续查看可用的信号之前，还有一件事我们需要注意：条件。`app.signal()` 方法接受一个名为 condition 的关键字参数，可以帮助限制匹配的事件。只有与相同条件分发的事件才会被执行。
- en: We will look at a concrete example.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看一个具体的例子。
- en: Start by adding some request middleware.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先添加一些请求中间件。
- en: '[PRE25]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Then add a signal to attach to our middleware (this is a built-in as we will
    see later).
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加一个信号来连接到我们的中间件（这将在稍后看到，它是一个内置的）。
- en: '[PRE26]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let’s go take a look at our terminal after we hit an endpoint:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在访问端点后查看我们的终端：
- en: '[PRE27]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Hmmm, we see that the signal was dispatched, and that our middleware ran, but
    our signal handlers did not. Why? The `http.middleware.*` events are special in
    that they will only match when a specific **condition** is met. Therefore, we
    need to amend our signal definition to include the required condition.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 嗯嗯，我们看到信号已被分发，我们的中间件也运行了，但我们的信号处理器没有。为什么？`http.middleware.*` 事件是特殊的，因为它们只有在满足特定**条件**时才会匹配。因此，我们需要修改我们的信号定义以包含所需条件。
- en: 'Change your signal to add the condition like this:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的信号修改为添加条件，如下所示：
- en: '[PRE28]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Hit the endpoint again. We should now see the text as anticipated.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次访问端点。现在我们应该看到预期的文本。
- en: '[PRE29]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Conditions are something that you can also add to your custom signal dispatches
    (keep reading ahead to the *Custom signals* section to learn more). It would look
    like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 条件是你可以添加到自定义信号分发中的内容（继续阅读以了解更多关于*自定义信号*部分的内容）。它看起来像这样：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Most signal use cases will not need this approach. However, if you find the
    need for additional control on signal dispatching, it might just be the right
    tool for the job. Let’s turn our attention back to Sanic’s built-in signals and
    see what other events we can attach signals to.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数信号用例不需要这种方法。然而，如果你发现需要对信号分发进行更多控制，这可能正是你需要的工具。让我们把注意力转回到 Sanic 的内置信号，看看我们还能将信号附加到哪些其他事件上。
- en: Using built-in signals
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用内置信号
- en: There are a number of built-in signals that we can use. Take a look at the tables
    below and dog-ear this page in the book. I highly encourage you to come back to
    this table often and look at your options when trying to solve a problem. While
    the implementations and usages we come up with in this book may be small, it is
    your job to learn the process so you can more effectively solve your own application
    needs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多内置的信号我们可以使用。查看下面的表格，并在书中标记这一页。我强烈建议你在尝试解决问题时经常回到这个表格，看看你的选项。虽然这本书中我们提出的实现和使用可能很小，但你的任务是学习这个过程，这样你就可以更有效地解决你自己的应用需求。
- en: First, are the signals related to routing. They will execute on every request.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这些信号与路由相关。它们将在每个请求上执行。
- en: '| **Event name** | **Arguments** | **Description** |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| **事件名称** | **参数** | **描述** |'
- en: '| `http.routing.before` | `request` | When Sanic is ready to resolve the incoming
    path to a route |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `http.routing.before` | `request` | 当 Sanic 准备解析传入路径到路由时 |'
- en: '| `http.routing.after` | `request, route, kwargs, handler` | Immediately after
    a route has been found |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `http.routing.after` | `request, route, kwargs, handler` | 在找到路由之后立即 |'
- en: Table 6.2 - Available built-in routing signals
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.2 - 可用的内置路由信号
- en: Second, we have the signals that are specifically related to the request/response
    lifecycle.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们有与请求/响应生命周期特别相关的信号。
- en: '| **Event name** | **Arguments** | **Description** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **事件名称** | **参数** | **描述** |'
- en: '| `http.lifecycle.begin` | `conn_info` | When an HTTP connection is established
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `http.lifecycle.begin` | `conn_info` | 当建立 HTTP 连接时 |'
- en: '| `http.lifecycle.read_head` | `head` | After an HTTP head is read, but before
    it is parsed |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `http.lifecycle.read_head` | `head` | 在读取 HTTP 头部信息之后，但在解析之前 |'
- en: '| `http.lifecycle.request` | `request` | Immediately upon the creation of a
    Request object |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `http.lifecycle.request` | `request` | 在创建请求对象之后立即 |'
- en: '| `http.lifecycle.handle` | `request` | Before Sanic begins to handle a request
    |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `http.lifecycle.handle` | `request` | 在 Sanic 开始处理请求之前 |'
- en: '| `http.lifecycle.read_body` | `body` | Every time bytes are read from a request
    body |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `http.lifecycle.read_body` | `body` | 每次从请求体中读取字节时 |'
- en: '| `http.lifecycle.exception` | `request, exception` | When an exception is
    raised in a route handler or middleware |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `http.lifecycle.exception` | `request, exception` | 在路由处理程序或中间件中抛出异常时 |'
- en: '| `http.lifecycle.response` | `request, response` | Just before a response
    is sent |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `http.lifecycle.response` | `request, response` | 在发送响应之前 |'
- en: '| `http.lifecycle.send` | `data` | Everytime date is sent to an HTTP transport
    |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `http.lifecycle.send` | `data` | 每次将数据发送到 HTTP 传输时 |'
- en: '| `http.lifecycle.complete` | `conn_info` | When an HTTP connection is closed
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `http.lifecycle.complete` | `conn_info` | 当 HTTP 连接关闭时 |'
- en: Table 6.3 - Available built-in request/response lifecycle signals
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.3 - 可用的内置请求/响应生命周期信号
- en: Third, we have the events that wrap around each middleware handler. These are
    not likely signals that you will use often. Instead, they primarily exist for
    the benefit of Sanic plugin developers.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们有围绕每个中间件处理程序的事件。这些信号可能不是你经常使用的。相反，它们主要存在以供 Sanic 插件开发者受益。
- en: '| **Event name** | **Arguments** | **Conditions** | **Description** |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| **事件名称** | **参数** | **条件** | **描述** |'
- en: '| `http.middleware.before` | `request, response` | `{"attach_to": "request"}
    or {"attach_to": "response"}` | Before each middleware runs |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `http.middleware.before` | `request, response` | `{"attach_to": "request"}
    或 {"attach_to": "response"}` | 在每个中间件运行之前 |'
- en: '| `http.middleware.after` | `request, response` | `{"attach_to": "request"}
    or {"attach_to": "response"}` | After each middleware runs |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `http.middleware.after` | `request, response` | `{"attach_to": "request"}
    或 {"attach_to": "response"}` | 每个中间件运行之后 |'
- en: Table 6.4 - Available built-in middleware signals
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.4 - 可用的内置中间件信号
- en: Finally, we have the server events. These signals are a one-to-one match with
    the listener events. Although you can call them as a signal, there is a convenient
    decorator for each of them as indicated in the descriptions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有服务器事件。这些信号与监听器事件一一对应。虽然你可以将它们作为信号调用，但描述中已指示，每个都有方便的装饰器。
- en: '| **Event name** | **Arguments** | **Description** |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **事件名称** | **参数** | **描述** |'
- en: '| `server.init.before` | `app, loop` | Before a server starts up (equivalent
    to `app.before_server_start` ) |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `server.init.before` | `app, loop` | 在服务器启动之前（相当于 `app.before_server_start`）
    |'
- en: '| `server.init.after` | `app, loop` | After a server starts up (equivalent
    to `app.after_server_start` ) |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `server.init.after` | `app, loop` | 服务器启动后（相当于 `app.after_server_start`）
    |'
- en: '| `server.shutdown.before` | `app, loop` | Before a server shuts down (equivalent
    to `app.before_server_stop` ) |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `server.shutdown.before` | `app, loop` | 在服务器关闭之前（相当于 `app.before_server_stop`）
    |'
- en: '| `server.shutdown.after` | `app, loop` | After a server shuts down (equivalent
    to `app.after_server_stop` ) |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `server.shutdown.after` | `app, loop` | 在服务器关闭之后（相当于 `app.after_server_stop`）
    |'
- en: Table 6.5 - Available built-in server lifecycle signals
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.5 - 可用的内置服务器生命周期信号
- en: I want to share an anecdote that exemplifies the power of signals. I do a lot
    of support for Sanic users. If you have spent any time looking over the community
    resources (either the Forums or the Discord server), you likely have seen me helping
    developers solve their problems. I really do enjoy this aspect of being involved
    in OSS.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我想分享一个例子，说明信号的力量。我为 Sanic 用户提供了很多支持。如果你花过时间查看社区资源（无论是论坛还是 Discord 服务器），你很可能见过我帮助开发者解决问题。我真的喜欢参与开源软件的这一方面。
- en: On one occasion I was asked by someone who was having trouble with middleware.
    The goal was to use response middleware to log out helpful information about responses
    as they were being delivered from the server. The problem is that when an exception
    is raised in middleware, it will halt the rest of the middleware from running.
    Therefore, this individual was not able to log every response. The requests that
    raised an exception in other response middleware never made it to the logger.
    The solution—as you have probably guessed—was to use signals. In particular, the
    `http.lifecycle.response` event worked perfectly for this use case.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有一次，有人向我求助，他们遇到了中间件的问题。目标是使用响应中间件在服务器发送响应时记录有用的信息。问题是，当中间件中引发异常时，它将停止其他中间件的运行。因此，这个人无法记录每个响应。在其他响应中间件中引发异常的请求从未到达记录器。解决方案——你可能已经猜到了——是使用信号。特别是，`http.lifecycle.response`事件在这个用例中工作得非常完美。
- en: 'To show the point, here is some code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，这里有一些代码：
- en: 'Setup two middleware, one for logging and one for causing an exception. Remember,
    they need to be in reverse order from how you want them to run:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置两个中间件，一个用于日志记录，另一个用于引发异常。记住，它们需要按照你希望它们运行的顺序相反：
- en: '[PRE31]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When we hit any endpoint, `log_response` will *NEVER* be run.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们访问任何端点时，`log_response`将*永远不会*被运行。
- en: 'To solve, change `log_response` from middleware into a signal (which is as
    easy as changing the decorator):'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，将`log_response`从中间件改为信号（只需更改装饰器即可）：
- en: '[PRE32]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, when we access the endpoint and experience the exception, we still get
    our logs as expected:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当我们访问端点并遇到异常时，我们仍然会得到预期的日志：
- en: '[PRE33]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We can also use this exact same signal to solve one of our earlier problems.
    Remember when we were examining response middleware and had somewhat surprising
    results with a streaming handler? If you go back to earlier in this Chapter, we
    noticed that response middleware actually was called when the response object
    was created, not after the handler completed. We could use `http.lifecycle.response`
    to wrap up after our lyrics are done streaming.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用这个完全相同的信号来解决我们早期遇到的一个问题。记得当我们检查响应中间件并使用流处理程序得到一些令人惊讶的结果时吗？如果你回到本章的早期部分，我们会注意到响应中间件实际上是在响应对象创建时被调用的，而不是在处理程序完成后。我们可以在歌词流完之后使用`http.lifecycle.response`来包装。
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This might be another good time for you to put the book down and do some exploration.
    Go back to that earlier example with the streaming handler and play around with
    some of these signals. Take a look at the arguments they receive and think about
    how you might make usage of them. It is also, of course, important to understand
    the order in which they are dispatched.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能又是一个你放下书本进行探索的好时机。回到那个早期的流处理程序示例，并尝试一些这些信号。看看它们接收到的参数，并思考你如何使用它们。当然，了解它们发送的顺序也同样重要。
- en: After you complete that, we will take a look at creating custom signals and
    events.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们将探讨创建自定义信号和事件。
- en: Custom signals
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义信号
- en: So far, we have been looking specifically at the built-in signals. They are
    sort of a narrow implementation of what Sanic signals have to offer. While it
    is helpful to think of them as breakpoints that allow us to insert functionality
    into Sanic itself, in truth there is a more general concept at play.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们特别关注内置信号。它们是Sanic信号提供的狭义实现。虽然将它们视为允许我们在Sanic本身中插入功能的断点是有帮助的，但事实上，还有一个更通用的概念在发挥作用。
- en: 'Signals allow for intra-application communication. Because they can be dispatched
    asynchronously as background tasks, it can become a convenient method for one
    part of your application to inform another that something has happened. This introduces
    another important concept of signals: they can be dispatched as inline or as tasks.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 信号允许应用程序内部通信。因为它们可以作为后台任务异步发送，所以这可以成为应用程序的一部分通知另一部分发生了某事的方便方法。这引入了信号的重要概念之一：它们可以以内联或任务的形式发送。
- en: So far, every single example we have seen with the built-in signals is inline.
    That is to say that Sanic will halt the processing of a request until the signals
    complete. This is how we are able to add functionality into the lifecycle while
    maintaining a consistent flow.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的每个内置信号示例都是内联的。也就是说，Sanic会在信号完成之前停止处理请求。这就是我们能够在生命周期中添加功能的同时保持一致流程的方式。
- en: This might not always be desirable. In fact, often times when you want to implement
    your own solution with custom signals, having them run as a background task gives
    the application the ability to continue responding to the request, while it goes
    and does something else.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能并不总是期望的。事实上，很多时候当你想使用自定义信号实现自己的解决方案时，让它们作为后台任务运行，这给了应用程序在执行其他任务的同时继续响应请求的能力。
- en: 'Let’s take logging for example. Imagine that we are back in our example where
    we are building an ecommerce application. We want to augment our access logs to
    include information about the authenticated use (if any), and the number of items
    they have in their shopping cart. Let’s take our earlier middleware example and
    convert it to signals:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以记录为例。想象一下，我们回到了我们的示例，我们正在构建一个电子商务应用程序。我们想增强我们的访问日志，包括有关已认证用户（如果有）和他们购物车中物品数量的信息。让我们将我们之前的中间件示例转换为信号：
- en: We need to create a signal to pull the user and shopping cart information onto
    our request object. Again, we just need to change the first line.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个信号，将用户和购物车信息拉到我们的请求对象上。同样，我们只需要更改第一行。
- en: '[PRE35]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For the sake of our example, we want to throw together some quick models and
    fake getters like this:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了我们的示例，我们想快速组合一些模型和类似这样的假getter：
- en: '[PRE36]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This will be enough to get our example operational, but we want to be able
    to see it. For now, we will add a route handler that just outputs our `request.ctx`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将足以让我们的示例运行起来，但我们想看到它。现在，我们将添加一个路由处理程序，它只是输出我们的`request.ctx`：
- en: '[PRE37]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We should now see our fake user and cart are available as expected:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在应该看到我们的假用户和购物车如预期那样可用：
- en: '[PRE38]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Since we want to use our own access logs, we should turn off Sanic’s access
    logs. Back in Chapter 2, we decided we were going to run all of our examples like
    this:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们想使用自己的访问日志，我们应该关闭Sanic的访问日志。在第二章中，我们决定将所有示例都这样运行：
- en: '[PRE39]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We are going to change that now. Add `--no-access-logs`:'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在将改变这一点。添加`--no-access-logs`：
- en: '[PRE40]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we are going to add our own request logger. But, to illustrate the point
    we are trying to make, we will manually make our signal take a while to respond:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将添加我们自己的请求记录器。但是，为了说明我们想要表达的观点，我们将手动让我们的信号响应时间变长：
- en: '[PRE41]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When you access the endpoint, you will see the following in your logs. You also
    should experience a delay before the logging appears, and also before your response
    is delivered.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你访问端点时，你将在日志中看到以下内容。你也应该体验到在日志出现之前，以及在你收到响应之前会有延迟。
- en: '[PRE42]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To fix this, we will create a custom signal for our logger, and dispatch the
    event from `fetch_user_and_cart`. Let’s make the following changes:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将为我们的记录器创建一个自定义信号，并从`fetch_user_and_cart`中分发事件。让我们进行以下更改：
- en: '[PRE43]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This time when we go and access the endpoint, there are two things you need
    to pay attention to. First, your response should return almost immediately. The
    delayed response we experienced earlier should be gone. Second, the delay in the
    access log should remain.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次当我们访问端点时，有两件事你需要注意。首先，你的响应应该几乎立即返回。我们之前遇到的延迟响应应该消失了。其次，访问日志中的延迟应该保持。
- en: What we have effectively done here is taken any IO wait time in the logging
    away from the request cycle. To do this we created a custom signal. That signal
    was called `olives.request.incoming`. There is nothing special about this. It
    is entirely arbitrary. The only requirements, as we discussed, is that it has
    three parts.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里有效地做的是将日志记录中的任何I/O等待时间从请求周期中移除。为了做到这一点，我们创建了一个自定义信号。这个信号被称作`olives.request.incoming`。这并没有什么特别之处。它是完全任意的。唯一的要求，正如我们讨论的那样，是它有三个部分。
- en: 'To execute the signal, we just need to call `app.dispatch` with the same name:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行信号，我们只需要用相同名称调用`app.dispatch`：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Because we wanted to have access to the Request object in `access_log`, we used
    the optional argument context to pass the object.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想在`access_log`中访问请求对象，所以我们使用了可选参数`context`来传递对象。
- en: So, why did the `http.lifecycle.handle` signal delay the response, but `olives.request.incoming`
    did not? Because the former was executed *inline* and the latter as a background
    task. Under the hood, Sanic calls dispatch with `inline=True`. Go ahead and add
    that to the custom dispatch to see how that impacts the response. Once again,
    both the logging and the response are now delayed. You should use this when you
    want your application to pause on the dispatch until all signals attached to it
    are done running. If that order is not important, you will achieve more performance
    if you leave it out.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么`http.lifecycle.handle`信号延迟了响应，而`olives.request.incoming`没有？因为前者是**内联**执行的，而后者是作为后台任务执行的。在底层，Sanic使用`inline=True`调用dispatch。现在就添加到自定义调度中，看看它如何影响响应。再次强调，日志和响应现在都延迟了。你应该在想要你的应用程序在调度时暂停，直到所有附加的信号都运行完毕时使用这个。如果这个顺序不重要，如果你省略它，你会获得更好的性能。
- en: 'There are a few more arguments that dispatch takes that might be helpful for
    you. Here is the function signature:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: dispatch还接受一些可能对你有帮助的参数。以下是函数签名：
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The arguments that this function accepts are as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受的参数如下：
- en: '`condition`: Used as seen with the middleware signals to control additional
    matching (we saw this as used by the `http.middleware.*` signals)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`condition`：用作中间件信号，以控制额外的匹配（我们看到了`http.middleware.*`信号的使用）'
- en: '`context`: Arguments that should be passed to the signal'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context`：应传递给信号的参数'
- en: '`fail_not_found`: What if you dispatch an event that does not exist? Should
    it raise an exception or fail silently?'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fail_not_found`：如果你调度了一个不存在的事件，会发生什么？应该抛出异常还是静默失败？'
- en: '`inline`: Run in a task or not as discussed already'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inline`：是否在任务中运行，如之前讨论的那样'
- en: '`reverse`: When there are multiple signals on an event, what order should they
    run in?'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reverse`：当事件上有多个信号时，它们应该按什么顺序运行？'
- en: Waiting on events
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 等待事件
- en: The last helpful thing about dispatching a signal event is that they also can
    be used like asyncio events to block until it is dispatched. The use case for
    this is different than dispatching. When you dispatch a signal, you are causing
    some other operation to occur, usually in a background task. You should wait on
    a signal event when you want to pause an existing task until that event happens.
    This means that it will block the currently existing task, whether that is a background
    task or the actual request that is being handled.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 分派信号事件的最后一个有用之处在于，它们也可以像asyncio事件一样使用，以阻塞直到它们被调度。这种用例与调度不同。当你调度一个信号时，你正在导致其他操作发生，通常是在后台任务中。当你想要暂停现有任务直到该事件发生时，你应该等待信号事件。这意味着它将阻塞当前存在的任务，无论是后台任务还是正在处理的实际请求。
- en: The easiest way to show this is with a super simple loop that runs constantly
    in your application.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是使用一个在应用程序中持续运行的超级简单的循环来展示这一点。
- en: Setup your loop like this. Notice that we are using `app.event` with our event
    name. For simplicity, we are using a built-in signal event, but it could also
    be a custom. In order to work, we would just need an app.signal to be registered
    with the same name.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式设置你的循环。注意我们使用`app.event`和我们的事件名称。为了简单起见，我们使用了一个内置的信号事件，但它也可以是自定义的。为了使其工作，我们只需要一个与相同名称注册的app.signal。
- en: '[PRE46]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, when we hit our endpoint, we should see this in the logs:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当我们访问我们的端点时，我们应该在日志中看到以下内容：
- en: '[PRE47]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This might be a helpful tool especially if your application uses websockets.
    You might, for example, want to keep track of the number of open sockets. Feel
    free to turn back to the websockets example and see if you can integrate some
    events and signals into your implementation.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个有用的工具，特别是如果你的应用程序使用websockets。例如，你可能想跟踪打开套接字的数量。随时可以回到websockets示例，看看你是否可以将一些事件和信号集成到你的实现中。
- en: One more helpful use case is where you have a number of things that need to
    happen in your endpoint before you respond. You want to push off some work to
    a signal, but ultimately it does need to be complete before responding.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的用例是，在你响应之前，你的端点需要发生多个事件。你希望将一些工作推迟到信号，但最终它确实需要在响应前完成。
- en: We could do something like this. Setup the following handlers and signals.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样做。设置以下处理程序和信号。
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now when we look at the terminal, we should see this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们查看终端时，应该看到以下内容：
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Since we know that sending the email will be an expensive operation, we send
    that off to the background while continue processing the request. By using app.event,
    we were able to wait for the `registration.email.done` event to be dispatched
    before responding that the email in fact had been sent.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道发送电子邮件将是一个昂贵的操作，我们将它发送到后台，同时继续处理请求。通过使用app.event，我们能够等待`registration.email.done`事件被分发，然后回复电子邮件实际上已经发送。
- en: One thing that you should make note of, in this example there is not actually
    a signal attached to `registration.email.done`. Out of the box, Sanic will complain
    and raise an exception. If you would like to use this pattern, you have three
    options.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你应该注意的一点是，实际上并没有信号附加到`registration.email.done`上。默认情况下，Sanic会抱怨并抛出异常。如果你想使用这种模式，你有三种选择。
- en: Register a signal.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册一个信号。
- en: '[PRE50]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Since we do not need to actually execute anything, we do not actually need
    a handler:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们实际上不需要执行任何操作，所以我们实际上不需要一个处理器：
- en: '[PRE51]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Tell Sanic to automatically create all events when there is a dispatch, regardless
    of whether there is a registered signal:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉Sanic在发生分发时自动创建所有事件，无论是否有注册的信号：
- en: '[PRE52]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now that we know there are a number of ways to control the execution of business
    logic within an HTTP lifecycle, we will next explore some other things we can
    do to exploit our new found tools.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道有几种方式可以在HTTP生命周期内控制业务逻辑的执行，我们将接下来探索我们可以利用新发现工具做的一些其他事情。
- en: Mastering HTTP connections
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 掌握HTTP连接
- en: Earlier in Chapter 4, we discussed how the HTTP lifecycle represented a conversation
    between a client and a server. The client requests information, and the server
    responds. In particular, we likened it to a video chat with bi-directional communication.
    Let’s dig into this analogy a little deeper to expand our understanding of HTTP
    and Sanic.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四章的早期，我们讨论了HTTP生命周期代表了客户端和服务器之间的对话。客户端请求信息，服务器响应。特别是，我们将它比作双向通信的视频聊天。让我们深入这个类比，以扩展我们对HTTP和Sanic的理解。
- en: 'Rather than thinking about an HTTP request as the video chat, it is better
    to think of it as an individual conversation, or better yet, a single question
    and answer. Something like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是将HTTP请求视为视频聊天，最好是将其视为一个单独的对话，或者更好，一个单一的问题和答案。类似于这样：
- en: '**Client**: Hi, my session ID is 123456, and my shopping cart ID is 987654\.
    Can you tell me what other items I can buy?'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户**: 嗨，我的会话ID是123456，我的购物车ID是987654。你能告诉我我可以购买的其他商品吗？'
- en: '**Server**: Hi Adam, you have pure olive oil, and extra virgin olive oil in
    your cart already. You can add: balsamic vinegar or red wine vinegar.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器**: 嗨亚当，你的购物车中已经有了纯橄榄油和特级初榨橄榄油。你可以添加：香醋或红葡萄酒醋。'
- en: 'Sanic is a “performant” web framework because it is capable of having these
    conversations with multiple clients at the same time. While it is fetching the
    results for one client, it can begin conversations with other clients:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic是一个“高性能”的Web框架，因为它能够同时与多个客户端进行这些对话。当它在为一位客户端获取结果时，它可以开始与其他客户端的对话：
- en: '**Client 1**: What products do you sell?'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户1**: 你们销售哪些产品？'
- en: '**Client 2**: How much does a barrel of olive oil cost?'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户2**: 一桶橄榄油的价格是多少？'
- en: '**Client 3**: What is the meaning of life?'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户3**: 生活的意义是什么？'
- en: By being capable of corresponding within multiple video chat sessions simultaneously,
    the server has become more efficient at responding. But, what happens when one
    client has multiple questions? To start and stop the video chat for each “conversation”
    would be time consuming and costly.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务器能够同时对应多个视频聊天会话，因此它变得更加高效地响应。但是，当一个客户端有多个问题时会发生什么？为每个“对话”开始和结束视频聊天将会既耗时又昂贵。
- en: '*Start video chat*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*开始视频聊天*'
- en: '**Client**: Here are my credentials, can I login?'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户**: 这里是我的凭证，我可以登录吗？'
- en: '**Server**: Hi Adam, nice to see you again, here is a session ID: 123456\.
    Goodbye.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器**: 嗨亚当，很高兴再次见到你，这是你的会话ID：123456。再见。'
- en: '*Stop video chat*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*结束视频聊天*'
- en: '*Start video chat*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*开始视频聊天*'
- en: '**Client**: Hi, my session ID is 123456\. Can I update my profile information?'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户**: 嗨，我的会话ID是123456。我可以更新我的个人资料信息吗？'
- en: '**Server**: Oops, Bad Request. Looks like you did not send me the right data.
    Goodbye.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器**: 哎呀，无效请求。看起来你没有发送正确的数据。再见。'
- en: '*Stop video chat*'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*结束视频聊天*'
- en: Every time that the video chat starts and stops we are wasting time and resources.
    HTTP/1.1 sought to solve this problem by introducing persistent connections. This
    is accomplished with the Keep-Alive header. We do not need to worry specifically
    about how this header works from the client or server. Sanic will take care of
    responding appropriately.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 每次视频聊天开始和停止时，我们都在浪费时间和资源。HTTP/1.1 通过引入持久连接来试图解决这个问题。这是通过 Keep-Alive 头部实现的。我们不需要担心客户端或服务器如何具体处理这个头部。Sanic
    会相应地处理。
- en: What we do need to understand is that it exists, and that it includes a timeout.
    This means that Sanic will not close the connection to the client if another request
    comes within some timeout period.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要理解的是，它确实存在，并且包含一个超时时间。这意味着如果在这个超时期间有另一个请求到来，Sanic 不会关闭与客户端的连接。
- en: '*Start video chat*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*开始视频聊天*'
- en: '**Client**: Here are my credentials, can I login?'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端**: 这是我的凭证，我可以登录吗？'
- en: '**Server**: Hi Adam, nice to see you again, here is a session ID: 123456.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器**: 嗨，亚当，很高兴再次见到你，这是你的会话ID：123456。'
- en: '**Server**: *waiting…*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器**: *等待中…*'
- en: '**Server**: *waiting…*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器**: *等待中…*'
- en: '**Server**: *waiting…*'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器**: *等待中…*'
- en: '**Server**: Goodbye.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器**: 再见。'
- en: '*Stop video chat*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*停止视频聊天*'
- en: We have now created an efficiency within a single video chat to allow for multiple
    conversations.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在单个视频聊天中创建了一个效率，允许进行多个对话。
- en: 'There are two practical concerns we need to think about here: (1) how long
    should the server wait? And, (2) can we make the connection more efficient?'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑的两个实际问题： (1) 服务器应该等待多长时间？以及 (2) 我们能否使连接更高效？
- en: Keep-Alive within Sanic
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sanic 中的 Keep-Alive
- en: 'Sanic will keep HTTP connections alive by default. This makes operations more
    performant as we saw earlier. There may, however, be instances where this is undesirable.
    Perhaps you *never* want to keep the connections open. If you know that your application
    will never handle more than one request per client, then perhaps it is wasteful
    to use precious memory to keep open a connection that will never be reused. To
    turn it off, just set a configuration value on your application instance:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic 默认会保持 HTTP 连接活跃。这使得操作更高效，正如我们之前看到的。然而，可能存在一些情况下这并不理想。也许你*永远*不想保持连接开启。如果你知道你的应用程序永远不会处理每个客户端超过一个请求，那么可能使用宝贵的内存来保持一个永远不会被重用的连接是浪费的。要关闭它，只需在你的应用程序实例上设置一个配置值：
- en: '[PRE53]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you can probably guess, even the most basic web applications will never fall
    into this category. Therefore, even though we have the ability to turn off keep-alive,
    you probably should not.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所能猜到的，即使是最基本的 Web 应用程序也不会落入这个类别。因此，尽管我们有关闭 keep-alive 的能力，但你可能不应该这么做。
- en: 'What you are more likely going to want to change is the timeout. By default,
    Sanic will keep connections open for five seconds. This may not seem long, but
    it should be long enough for most use cases without being wasteful. This is, however,
    Sanic just making a complete guess. You are more likely to know and understand
    the needs of your application, and you should feel free to tune this number to
    your needs. How? Again, with a simple configuration value:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你更有可能想要更改的是超时时间。默认情况下，Sanic 将保持连接开启五秒钟。这可能看起来不是很长，但对于大多数用例来说应该足够长，而且不会造成浪费。然而，这仅仅是
    Sanic 做的一个完全猜测。你更有可能了解并理解你应用程序的需求，你应该可以自由地调整这个数字以满足你的需求。如何？再次，通过一个简单的配置值：
- en: '[PRE54]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To give you some context, here is a snippet from the Sanic User Guide that
    provides some insight how other systems operate:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给你一些背景信息，这里是从 Sanic 用户指南中摘录的一段内容，它提供了一些关于其他系统如何操作的见解：
- en: '*“Apache httpd server default keepalive timeout = 5 seconds*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*“Apache httpd 服务器默认 keepalive 超时 = 5 秒*'
- en: '*Nginx server default keepalive timeout = 75 seconds*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '*Nginx 服务器默认 keepalive 超时 = 75 秒*'
- en: '*Nginx performance tuning guidelines uses keepalive = 15 seconds*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*Nginx 性能调整指南使用 keepalive = 15 秒*'
- en: '*IE (5-9) client hard keepalive limit = 60 seconds*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*IE (5-9) 客户端硬 keepalive 限制 = 60 秒*'
- en: '*Firefox client hard keepalive limit = 115 seconds*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*Firefox 客户端硬 keepalive 限制 = 115 秒*'
- en: '*Opera 11 client hard keepalive limit = 120 seconds*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*Opera 11 客户端硬 keepalive 限制 = 120 秒*'
- en: '*Chrome 13+ client keepalive limit > 300+ seconds”*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*Chrome 13+ 客户端 keepalive 限制 > 300+ 秒"*'
- en: '[https://sanicframework.org/en/guide/deployment/configuration.html#keep-alive-timeout](https://sanicframework.org/en/guide/deployment/configuration.html#keep-alive-timeout)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://sanicframework.org/en/guide/deployment/configuration.html#keep-alive-timeout](https://sanicframework.org/en/guide/deployment/configuration.html#keep-alive-timeout)'
- en: How do you know if you should increase the timeout? If you are building a single-page
    application where your API is meant to power a JS frontend, there is a high likelihood
    that your browser will make a lot of requests. This is generally the nature of
    how these frontend applications work. This would be especially true if you expect
    users to click a button, browse through some content, and click some more. The
    first thing that comes to my mind would be a web portal type application where
    a single user might need to make dozens of calls within a minute, but they might
    be spaced out by some interval of browsing time. In this case, increasing the
    timeout to reflect the expected usage might make sense.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何知道是否应该增加超时时间？如果你正在构建一个单页应用程序，其中你的API旨在为JS前端提供动力，那么浏览器可能会发出很多请求。这通常是这些前端应用程序的工作方式。如果你预期用户会点击按钮、浏览一些内容，然后再次点击，这尤其正确。我首先想到的是一种网络门户类型的应用程序，其中单个用户可能需要在分钟内进行数十次调用，但这些调用可能被一些浏览时间间隔所分隔。在这种情况下，将超时时间增加到反映预期使用可能是有意义的。
- en: This does not mean that you should increase it too far. First, as we see above
    browsers generally have a limit to the maximum they will hold a connection open.
    Second, going too far with connection length can be wasteful and harmful to your
    memory performance. It is a balance that you are after. There is no one good answer,
    so you may need to experiment to see what works.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着你应该过度增加它。首先，如我们上面所看到的，浏览器通常有一个它们将保持连接打开的最大限制。其次，连接长度过长可能会造成浪费，并损害你的内存性能。你追求的是一个平衡。没有一种完美的答案，所以你可能需要通过实验来找出什么有效。
- en: Caching data per connection
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按连接缓存数据
- en: If you are thinking about ways that you might exploit some of these tools for
    your applications needs, you might have noticed a potential efficiency you can
    create. Back at the beginning of this Chapter there is a table that lists all
    of the context (`ctx`) objects that are available to you in Sanic. One of them
    is connection specific.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在考虑如何利用这些工具来满足你的应用程序需求，你可能已经注意到了可以创建的潜在效率。回到本章的开头，有一个表格列出了Sanic中你可以使用的所有上下文（`ctx`）对象。其中之一是针对连接的特定对象。
- en: This means that not only are you able to create stateful requests, but you can
    also add state into a single connection. Our simple example will be a counter.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你不仅能够创建有状态的请求，还可以将状态添加到单个连接中。我们的简单示例将是一个计数器。
- en: 'Start by creating a counter when connection is established. We will use a signal
    for this:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在建立连接时创建一个计数器。我们将为此使用一个信号：
- en: '[PRE55]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, we will increment the counter on every request using middleware:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用中间件在每次请求时增加计数器：
- en: '[PRE56]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then we will output that in our request body so we can see what this looks
    like:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将将其输出到我们的请求体中，以便我们可以看到它看起来像什么：
- en: '[PRE57]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, we will issue multiple requests using curl. To do that, we just give it
    the URL multiple times:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用curl发出多个请求。为此，我们只需多次给出URL：
- en: '[PRE58]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This is of course a trivial example, and we could get that information from
    Sanic easily enough:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然是一个简单的例子，我们可以很容易地从Sanic中获取这些信息：
- en: '[PRE59]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This could be extremely useful if you have some data that might be expensive
    to obtain, but want it available for all requests. Coming back to our earlier
    roleplay model, it would be as if your server fetched some details when the video
    chat started. Now, every time the client asks a question, the server already has
    the details on hand in cache.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有某些可能获取成本高昂的数据，但又希望它对所有请求都可用，这将非常有用。回到我们之前的角色扮演模型，这就像你的服务器在视频聊天开始时获取了一些详细信息。现在，每当客户端提出问题，服务器已经将详细信息放在缓存中。
- en: '**Important note**'
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This does come with a warning. If your application is exposed through a proxy,
    it could be connection pooling. That is to say that the proxy could be taking
    requests from differing clients and bundling them together in one connection.
    Think of this as if your video chat session was not in someone’s private home,
    but were instead in the foyer of a large university dormitory. Anyone could walk
    up to the single video chat session and ask a question. You might not be guaranteed
    to have the same person all the time. Therefore, before you expose any sort of
    sensitive details on this object, you must know that it will be safe. Your best
    practice might just be to keep the sensitive details on `request.ctx`.
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这确实有一个警告。如果你的应用程序通过代理暴露，可能是连接池。也就是说，代理可能会从不同的客户端接收请求并将它们捆绑在一个连接中。想象一下，如果你的视频聊天会话不是在某个人的私人住宅中，而是在一个大大学宿舍的大厅里。任何人都可以走到单个视频聊天会话前提问。你可能无法保证每次都是同一个人。因此，在你将任何敏感细节暴露在这个对象上之前，你必须知道它是安全的。你的最佳实践可能就是将敏感细节保留在`request.ctx`上。
- en: Handling exceptions like a pro
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 像专业人士一样处理异常
- en: 'In an ideal world, our applications would never fail and users would never
    submit bad information. All endpoints would return a `200 OK` response all the
    time. This is, of course, pure fantasy, and no web application could be complete
    if it did not address the possibility of failures. In real life, our code will
    have bugs, there will be edge cases not addressed, and users will send us bad
    data and misuse the application. In short: our application will fail. Therefore,
    we must think about this constantly.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个理想的世界里，我们的应用程序永远不会失败，用户永远不会提交错误信息。所有端点将始终返回`200 OK`响应。这当然是纯粹的幻想，没有任何网络应用程序如果不解决失败的可能性就不能完整。在现实生活中，我们的代码会有错误，会有未处理的边缘情况，用户会发送错误数据并滥用应用程序。简而言之：我们的应用程序会失败。因此，我们必须时刻考虑这一点。
- en: Sanic does, of course, provide some default handling for us. It includes a few
    different styles of exception handlers (HTML, JSON, and text), and can be used
    both in production and development. It is of course unopinionated, and therefore
    likely inadequate for a decently sized application. We will talk more about the
    fallback error handling in the *Fallback handling* section later. As we just learned,
    handling exceptions in an application is critical to the quality (and ultimately
    security) of a web application. We will now learn more about how to do that in
    Sanic.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Sanic 为我们提供了一些默认的处理方式。它包括几种不同的异常处理器样式（HTML、JSON 和文本），并且可以在生产环境和开发环境中使用。它当然是中立的，因此对于相当规模的应用程序来说可能是不够充分的。我们将在后面的*回退错误处理*部分更多地讨论回退错误处理。正如我们刚刚学到的，在应用程序中处理异常对于网络应用程序的质量（以及最终的安全性）至关重要。现在我们将学习如何在
    Sanic 中做到这一点。
- en: Implementing proper Exception handling
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施适当的异常处理
- en: Before we look at how to handle exceptions with Sanic, it is important to consider
    that a failure to properly address this could become a security problem. The obvious
    way would be through an inadvertent disclosure of sensitive information. This
    is known as *leaking*. This occurs when an exception is raised (by mistake of
    on purpose by the user) and your application reports back exposing details about
    how the application is built, or the data stored.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探讨如何使用 Sanic 处理异常之前，重要的是要考虑，如果未能妥善处理这个问题，可能会变成一个安全问题。显而易见的方式可能是不小心泄露敏感信息。这被称为*泄露*。这种情况发生在异常被抛出（可能是用户的错误或故意为之）并且你的应用程序报告回显露出有关应用程序构建方式或存储数据的细节时。
- en: In a real-world worst-case scenario, I once had an old forgotten endpoint that
    no longer worked in one of my web applications. No one used it anymore and I simply
    forgot that it existed or was even still live. The problem was that the endpoint
    did not have proper exception handling and errors were directly reported as they
    occurred. That means even “*Failure to connect to database XYZ using username
    ABC and password EFG*”messages were flowing right to anyone that accessed the
    endpoint. Oops.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个现实世界的最坏情况下，我曾经在一个网络应用程序中有一个被遗忘的旧端点，它已经不再工作。没有人再使用它，我简单地忘记了它的存在，甚至不知道它仍然处于活跃状态。问题是这个端点没有适当的异常处理，错误直接在发生时报告。这意味着即使是“*无法使用用户名
    ABC 和密码 EFG 连接到数据库 XYZ*”这样的消息也会直接流向访问端点的人。哎呀。
- en: 'Therefore, even though we do not discuss security concerns in general until
    Chapter 7, it does extend into the current exploration into exception handling.
    There are two main concerns here: providing exception messages with tracebacks
    or other implementation details, and incorrectly using 400 series responses.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管我们直到第7章才讨论一般的安全问题，但它确实扩展到了当前对异常处理的探索。这里有两个主要问题：提供带有回溯或其他实现细节的异常消息，以及错误地使用400系列响应。
- en: Bad exception messages
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不良异常消息
- en: While developing, it is super helpful to have as much information about your
    request as possible. This is why it would be desirable to have exception messages
    and tracebacks in your responses. When you are building your applications in debug
    mode, you will get all of these details. But make sure you turn it off in production!
    Just like I wish my applications only served `200 OK` response all the time, I
    wish I never stumbled onto a website that accidentally leaked debug information
    to me. It happens out there in the wild, so be careful not to fall into that mistake.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，尽可能多地了解您的请求信息非常有帮助。这就是为什么在您的响应中包含异常消息和回溯是可取的。当您以调试模式构建应用程序时，您将获得所有这些详细信息。但请确保在生产环境中将其关闭！就像我希望我的应用程序始终只提供`200
    OK`响应一样，我希望我永远不会遇到一个意外泄露调试信息的网站。这种情况在野外确实存在，所以请小心不要犯这个错误。
- en: What is perhaps more common is failing to properly consider the content of the
    errors when responding. When writing messages that will reach the end user, keep
    in mind that you do not want to accidentally disclose implementation details.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的是在响应时没有正确考虑错误的内容。在编写将发送给最终用户的消息时，请记住，您不希望无意中泄露实现细节。
- en: Misusing statuses
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误使用状态
- en: 'Closely related to bad exceptions are exceptions that leak information about
    your application. Imagine if your bank website had an endpoint that was: `/accounts/id/123456789`.
    They do their due diligence and properly protect the endpoint so that only you
    can access it. That is not a problem. But, what happens to someone that cannot
    access it? What happens when I try to access your bank account? Obviously I would
    get a 401 Unauthorized because it is not my account. However, as soon as you do
    that, the bank is now acknowledging that 123456789 is a legitimate account number.
    Therefore, I *highly* encourage you to use the below chart and commit it to memory.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 与不良异常密切相关的是泄露关于您应用程序信息的异常。想象一下，如果您的银行网站有一个端点是：`/accounts/id/123456789`。他们做了尽职调查并正确保护了这个端点，以确保只有您才能访问它。这没问题。但是，如果有人无法访问它会发生什么？当我尝试访问您的银行账户时会发生什么？显然我会得到401未授权，因为这不是我的账户。然而，一旦你这样做，银行现在就承认123456789是一个合法的账户号码。因此，我**强烈**建议您使用下面的图表并将其牢记在心。
- en: '| **Status** | **Description** | **Sanic Exception** | **When to use** |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| **状态** | **描述** | **Sanic 异常** | **何时使用** |'
- en: '| 400 | Bad Request | `InvalidUsage` | When any user submits data in an unexpected
    form or they otherwise did something your application does not intend to handle
    |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 400 | 错误请求 | `InvalidUsage` | 当任何用户提交意外形式的数据或他们以其他方式做了您的应用程序不打算处理的事情时'
- en: '| 401 | Unauthorized | `Unauthorized` | When an unknown user has not been authenticated.
    In other words, you do not know who the user is. |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| 401 | 未授权 | `Unauthorized` | 当未知用户尚未认证时。换句话说，您不知道用户是谁。'
- en: '| 403 | Forbidden | `Forbidden` | When a known user does not have permissions
    to do something on a *KNOWN* resource |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 403 | 禁止访问 | `Forbidden` | 当已知用户没有权限在**已知**资源上执行某些操作时'
- en: '| 404 | Not Found | `NotFound` | When any user attempts access on a hidden
    resource |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 404 | 未找到 | `NotFound` | 当任何用户尝试访问隐藏资源时'
- en: '|  |  |  |  |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |'
- en: Table 6.6 - Sanic exceptions for common 400 series HTTP responses
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.6 - Sanic 对常见400系列HTTP响应的异常
- en: Perhaps the biggest failure here is when people inadvertently expose the existence
    of a hidden resource with a 401 or 403\. Your bank should have instead sent me
    a 404 and directed me to a “page not found” response. This is not to say that
    you should always favor a 404\. But it is to your benefit from a security perspective
    to think about who could be accessing the information, and what they should or
    should not know about it. Then, you can decide which error response is appropriate.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的失败可能是人们无意中通过401或403暴露了隐藏资源的存在。您的银行本应发送给我一个404，并引导我到一个“页面未找到”的响应。这并不是说您应该总是优先考虑404。但从安全角度来看，考虑谁可以访问信息，以及他们应该或不应该知道什么，对您是有利的。然后，您可以决定哪种错误响应是合适的。
- en: Responses through raising an exception
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过抛出异常来响应
- en: One of the most convenient things about exception handling in Sanic is that
    it is relatively trivial to get started. Remember, we are just coding a Python
    script here, and you should treat it like you might anything else. What should
    you do when something goes wrong? Raise an exception! Here is an example.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Sanic 中处理异常最方便的事情之一是它相对容易上手。记住，我们只是在编写一个 Python 脚本，你应该像对待其他任何东西一样对待它。当事情出错时，你应该怎么做？抛出异常！这里有一个例子。
- en: Make a simple handler, we will ignore the return value here since we do not
    need it to prove our point. Use your imagination for what could be beyond the
    `...`.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的处理器，我们在这里将忽略返回值，因为我们不需要它来证明我们的观点。发挥你的想象力，看看 `...` 之外可能是什么。
- en: '[PRE60]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Next, we will submit some JSON to the endpoint leaving out the name property.
    Make sure to use `-i` so we can inspect the response headers.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将向端点提交一些 JSON 数据，但不包括名称属性。请确保使用 `-i` 选项，这样我们就可以检查响应头。
- en: '[PRE61]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Take note how we received a 400 response but did not actually return a response
    from the handler. This is because if you raise any exception from `sanic.exceptions`
    they *could* be used to return an appropriate status code. Furthermore, you will
    find that many of the exceptions in that module (like `InvalidUsage`) have a default
    `status_code`. This is why when you raise `InvalidUsage` Sanic will respond with
    a 400\. You could of course override the status code by passing a different on.
    Let’s see how that would work:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们收到了一个 400 响应，但实际上并没有从处理器返回响应。这是因为如果你从 `sanic.exceptions` 中抛出任何异常，它们*可以*用来返回适当的状态码。此外，你会发现该模块中的许多异常（如
    `InvalidUsage`）都有一个默认的 `status_code`。这就是为什么当你抛出 `InvalidUsage` 时，Sanic 会以 400
    响应。当然，你可以通过传递不同的值来覆盖状态码。让我们看看这将如何工作：
- en: 'Setup this endpoint and change `status_code` to something other than 400:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置此端点并更改 `status_code` 为 400 以外的值：
- en: '[PRE62]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, let’s access it:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们访问它：
- en: '[PRE63]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'As you can see, we passed the 418 status code to the exception. Sanic took
    that code and properly converted it to the appropriate HTTP response: `418 I''m
    a teapot`. Yes, that is a real HTTP response. Don’t believe me? Look it up in
    RFC 7168 § 2.3.3\. [https://datatracker.ietf.org/doc/html/rfc7168#section-2.3.3](https://datatracker.ietf.org/doc/html/rfc7168#section-2.3.3)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们向异常传递了 418 状态码。Sanic 接受了这个代码，并将其正确转换为适当的 HTTP 响应：`418 我是一把茶壶`。是的，这是一个真实的
    HTTP 响应。你不信？在 RFC 7168 § 2.3.3 中查找。[https://datatracker.ietf.org/doc/html/rfc7168#section-2.3.3](https://datatracker.ietf.org/doc/html/rfc7168#section-2.3.3)
- en: 'Here is a reference of all of the built-in exceptions and their associated
    response codes:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是所有内置异常及其相关响应码的参考：
- en: '| **Exception** | **Status** |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| **异常** | **状态** |'
- en: '| `HeaderNotFound` | 400 Bad Request |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| `HeaderNotFound` | 400 错误请求 |'
- en: '| `InvalidUsage` | 400 Bad Request |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| `InvalidUsage` | 400 错误请求 |'
- en: '| `Unauthorized` | 401 Unauthorized |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| `Unauthorized` | 401 未授权 |'
- en: '| `Forbidden` | 403 Forbidden |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| `Forbidden` | 403 禁止 |'
- en: '| `FileNotFound` | 404 Not Found |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| `FileNotFound` | 404 文件未找到 |'
- en: '| `NotFound` | 404 Not Found |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| `NotFound` | 404 文件未找到 |'
- en: '| `MethodNotSupported` | 405 Method Not Allowed |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| `MethodNotSupported` | 405 方法不允许 |'
- en: '| `RequestTimeout` | 408 Request Timeout |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| `RequestTimeout` | 408 请求超时 |'
- en: '| `PayloadTooLarge` | 413 Request Entity Too Large |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| `PayloadTooLarge` | 413 请求实体过大 |'
- en: '| `ContentRangeError` | 416 Request Range Not Satisfiable |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| `ContentRangeError` | 416 请求范围不满足 |'
- en: '| `InvalidRangeType` | 416 Request Range Not Satisfiable |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| `InvalidRangeType` | 416 请求范围不满足 |'
- en: '| `HeaderExpectationFailed` | 417 Expectation Failed |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| `HeaderExpectationFailed` | 417 期望失败 |'
- en: '| `ServerError` | 500 Internal Server Error |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| `ServerError` | 500 内部服务器错误 |'
- en: '| `URLBuildError` | 500 Internal Server Error |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| `URLBuildError` | 500 内部服务器错误 |'
- en: '| `ServiceUnavailable` | 503 Service Unavailable |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| `ServiceUnavailable` | 503 服务不可用 |'
- en: Table 6.4 Sanic exceptions with built in HTTP responses
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.4 带内置 HTTP 响应的 Sanic 异常
- en: 'It is therefore a really good practice to make usage of these status codes.
    An obvious example might be when you are looking up something in your database
    that does not exist:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用这些状态码是一个非常好的实践。一个明显的例子可能是当你正在数据库中查找不存在的东西时：
- en: '[PRE64]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Using the Sanic exceptions is perhaps one of the easiest solutions to getting
    appropriate responses back to the users.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Sanic 异常可能是获得适当响应给用户的解决方案之一。
- en: We could of course go one step further. We can make our own custom exceptions
    that subclass from the Sanic exceptions to leverage the same capability.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以更进一步。我们可以创建自己的自定义异常，这些异常从 Sanic 异常中继承，以利用相同的特性。
- en: 'Create an exception that subclasses one of the existing Sanic exceptions:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个继承现有 Sanic 异常之一的异常：
- en: '[PRE65]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Raise it when appropriate:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在适当的时候提升它：
- en: '[PRE66]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'See the error when we have a bad request (less than 5 items):'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们有一个不良请求（少于 5 项）时，可以看到错误：
- en: '[PRE67]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Using and reusing exceptions that inherit from `SanicException` is highly encouraged.
    It not only is a good practice because it provides a consistent and clean mechanism
    for organizing your code, it makes it easy to provide the appropriate HTTP responses.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励使用和重用继承自 `SanicException` 的异常。这不仅是一种良好的实践，因为它提供了一种一致且干净的机制来组织你的代码，而且它使得提供适当的
    HTTP 响应变得容易。
- en: So far throughout this book, when we have hit an exception with our client (like
    in the last example), we have received a nice textual representation of that error.
    In the next section, we will learn about the other types of exception output,
    and how we can control it.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，当我们客户端遇到异常（如最后一个例子所示）时，我们已经收到了一个很好的错误文本表示。在下一节中，我们将了解其他类型的异常输出，以及我们如何控制它。
- en: Fallback handling
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回退处理
- en: 'Let’s face it: formatting exceptions is mundane. There is little doubt that
    using our skills we have learned so far that we could build our own set of exception
    handlers. We know how to use templates, catch exceptions, and return HTTP responses
    with an error status. But creating those take time and a lot of boilerplate code.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 坦白说：格式化异常是平凡的。毫无疑问，使用我们迄今为止学到的技能，我们可以构建我们自己的异常处理器集合。我们知道如何使用模板、捕获异常和返回带有错误状态的
    HTTP 响应。但是创建这些需要时间和大量的样板代码。
- en: 'Which is why it is nice that Sanic offers three (3) different exception handlers:
    HTML, JSON, and plain text. For the most part, the examples in this book have
    used the plain text handlers only because it has been a more suitable form for
    presenting information in a book. Let’s go back to our example where we raised
    a `NotFound` error and see what it might look like with each of the three types
    of handlers.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么 Sanic 提供了三种（3）不同的异常处理器：HTML、JSON 和纯文本。在本书的大部分例子中，我们只使用了纯文本处理器，因为这更适合在书中展示信息。让我们回到我们引发
    `NotFound` 错误的例子，看看它使用三种不同类型的处理器可能是什么样子。
- en: HTML
  id: totrans-364
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: HTML
- en: 'Setup our endpoint to raise the exception:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置我们的端点以引发异常：
- en: '[PRE68]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Tell Sanic to use HTML formatting. We will look more into configurations in
    Chapter 8\. For now, we will just set the value right after our Sanic instance:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉 Sanic 使用 HTML 格式化。我们将在第 8 章深入探讨配置。现在，我们只需在我们的 Sanic 实例之后设置该值：
- en: '[PRE69]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Open up a web browser and go to our endpoint. You should see something like
    this:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个网页浏览器并访问我们的端点。你应该会看到类似这样的内容：
- en: '![Figure 6.1 - Example 404 page showing what the default 404 Not Found HTML
    page looks like in Sanic](img/file7.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 - 示例 404 页面，显示 Sanic 中默认的 404 未找到 HTML 页面看起来是什么样子](img/file7.png)'
- en: Figure 6.1 - Example 404 page showing what the default 404 Not Found HTML page
    looks like in Sanic
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 - 示例 404 页面，显示 Sanic 中默认的 404 未找到 HTML 页面看起来是什么样子
- en: JSON
  id: totrans-372
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JSON
- en: Use the same setup as before, but change the fallback format to `json`.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前的相同设置，但将回退格式更改为 `json`。
- en: '[PRE70]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This time we will access the endpoint with curl:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次我们将使用 curl 访问端点：
- en: '[PRE71]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Instead of nicely formatted HTML that we saw with the previous example, our
    exception has been formatted into JSON. This is more appropriate if your endpoint
    will—for example—be used by a Javascript browser application.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前示例中看到的格式良好的 HTML 不同，我们的异常已被格式化为 JSON。如果你的端点将——例如——被一个 JavaScript 浏览器应用程序使用，这更为合适。
- en: Text
  id: totrans-378
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文本
- en: Again using the same setup, we will change the fallback format to `text`.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用相同的设置，我们将回退格式更改为 `text`。
- en: '[PRE72]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We will again use curl to access the endpoint:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将再次使用 curl 来访问端点：
- en: '[PRE73]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As you can see, there are three convenient formatters for our exceptions that
    may be appropriate in different circumstances.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，有三个方便的格式化器适用于我们的异常，可能在不同情况下都适用。
- en: Auto
  id: totrans-384
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动
- en: 'The previous three examples used `FALLBACK_ERROR_FORMAT` to show that there
    are three types of built-in error formats. There is a fourth option for setting
    FALLBACK_ERROR_FORMAT: `auto`. It would look like this.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个示例使用了 `FALLBACK_ERROR_FORMAT` 来展示有三种内置的错误格式。还有一个设置 FALLBACK_ERROR_FORMAT
    的第四个选项：`auto`。它看起来是这样的。
- en: '[PRE74]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: When the format is set to `auto`, Sanic will look at the the routing handler
    and the incoming request to determine what is likely to be the most appropriate
    handler to use. For example, if a route handler always uses the `text()` response
    object, then Sanic will assume that you want the exceptions to also be formatted
    in `text` format. The same applies to `html()` and `json()` responses.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 当格式设置为`auto`时，Sanic将查看路由处理程序和传入的请求，以确定最合适的处理程序。例如，如果一个路由处理程序始终使用`text()`响应对象，那么Sanic将假设你希望异常也以`text`格式格式化。同样适用于`html()`和`json()`响应。
- en: Sanic will even go one step further than that when in `auto` mode. It will analyze
    the incoming request to look at the headers to make sure that what it *thinks*
    is correct and matches with what the client said that it wants to receive.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 当处于`auto`模式时，Sanic甚至会比这更进一步。它会分析传入的请求，查看头部信息，以确保它认为正确的内容与客户端所说的想要接收的内容相匹配。
- en: Manual override per route
  id: totrans-389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 每个路由的手动覆盖
- en: The last option we have is to set the error format on an individual route inside
    of the route definition. This would allow us to be specific and deviate from the
    fallback option if needed.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后一个选择是在路由定义中的单个路由上设置错误格式。这允许我们具体指定，并在需要时偏离回退选项。
- en: Consider the example where we set the fallback to `html`.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑我们设置回退为`html`的例子。
- en: '[PRE75]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Let’s now change our route definition from the beginning of this section to
    look like the following with a specific defined `error_format`:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将本节开头的路由定义更改为以下具有特定定义的`error_format`：
- en: '[PRE76]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: As you might already be able to guess, we will *not* see a formatted HTML page,
    but instead will see the plain text from earlier.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您可能已经猜到的，我们不会看到一个格式化的HTML页面，而会看到之前提到的纯文本。
- en: '[PRE77]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Catching exceptions
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获异常
- en: Although Sanic conveniently handles a lot of exceptions for us, it goes without
    saying that it cannot anticipate every error that could be raised in an application.
    We therefore need to think about how we want to handle exceptions that come from
    outside of Sanic. Or, rather, how to handle exceptions that are not manually raised
    by our application using one of the Sanic exceptions that conveniently adds a
    response code.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Sanic方便地为我们处理了很多异常，但不用说，它无法预知应用中可能出现的每一个错误。因此，我们需要考虑如何处理来自Sanic之外的异常。或者，更确切地说，如何处理不是通过Sanic的异常手动抛出的异常，使用Sanic方便添加响应代码的异常。
- en: Returning to our ecommerce example, let’s imagine that we are using a third-party
    vendor for handling our credit card transactions. They have conveniently provided
    us with a module that we can use to process credit cards. When something goes
    wrong, their module will raise a `CreditCardError`. Our job now is to make sure
    that our application is ready to handle this error.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的电子商务示例，让我们想象我们正在使用第三方供应商来处理我们的信用卡交易。他们方便地为我们提供了一个我们可以用来处理信用卡的模块。当出现问题的时候，他们的模块将抛出`CreditCardError`。我们现在的工作是确保我们的应用程序准备好处理这个错误。
- en: Before we do that, however, let’s see why this is important.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们这样做之前，让我们看看为什么这很重要。
- en: 'Imagine that this is our endpoint:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想象一下，这是我们终点：
- en: '[PRE78]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, we access the endpoint, and if there is an error we get this response:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们访问端点，如果出现错误，我们会得到以下响应：
- en: '[PRE79]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'That is not a very helpful message. If we look at our logs, however, we might
    see this:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一条很有帮助的信息。然而，如果我们查看我们的日志，我们可能会看到以下内容：
- en: '[PRE80]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: That error looks potentially far more helpful to our users.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误看起来对我们的用户可能更有帮助。
- en: 'One solution could, of course, just be to catch the exception and return the
    response that we want:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一个解决方案可能是捕获异常并返回我们想要的响应：
- en: '[PRE81]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This pattern is not ideal, however. It would require a lot of extra code when
    we need to catch every potential exception in various locations in the application
    to cast them to responses. This also would turn our code into a giant mess of
    try/except blocks and make things harder to read, and ultimately maintain. In
    short, it would go against some of the development principles we established early
    on in this book.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种模式并不理想。当我们需要在应用程序的各个位置捕获每个潜在的异常并将它们转换为响应时，这将需要大量的额外代码。这也会使我们的代码变成一个巨大的try/except块混乱，使阅读和维护变得更困难。简而言之，这会违反我们在本书早期确立的一些开发原则。
- en: 'A better solution would be to add an application-wide exception handler. This
    tells Sanic that anytime this exception bubbles up, it should catch it and respond
    in a certain way. It looks very much like a route handler:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是添加一个应用程序级别的异常处理器。这告诉 Sanic，每当这个异常冒泡时，它应该捕获它并以某种方式响应。它看起来非常像路由处理器：
- en: '[PRE82]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Sanic has now registered this as an exception handler, and will use it anytime
    that the `CreditCardError` is raised. Of course, this handler is super simplistic,
    but you might imagine that it could be used for: extra logging, providing request
    context, sending out an emergency alert notification to your devops team at 3am,
    and so on.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic 现已将此注册为异常处理器，并在 `CreditCardError` 被抛出时使用它。当然，这个处理器非常简单，但你可以想象它可以用作：额外的日志记录、提供请求上下文、凌晨3点向你的
    DevOps 团队发送紧急警报通知等等。
- en: '**TIP**'
  id: totrans-414
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-415
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Error handlers are not limited to your application instance. Just like other
    regular route handlers, they can be registered on your Blueprint instances to
    be able to customize error handling for a specific subset of your application.
  id: totrans-416
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 错误处理器不仅限于你的应用程序实例。就像其他常规路由处理器一样，它们可以注册在你的 Blueprint 实例上，以便为应用程序的特定子集定制错误处理。
- en: Exception handling is an incredibly important part of application development.
    It is an immediate differentiator between amateur applications and professional
    application. We now know how we can use exceptions to provide not only helpful
    messages to our users, but also to provide proper HTTP response codes. We now
    move on to another topic (background processing) that can really help to take
    your applications to the next level.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理是应用程序开发中极其重要的一个部分。它是业余应用程序和专业应用程序之间的一个直接区分因素。我们现在知道如何使用异常不仅为用户提供有用的消息，还可以提供适当的
    HTTP 响应代码。我们现在转向另一个主题（后台处理），这可以帮助将你的应用程序提升到下一个层次。
- en: Background processing
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后台处理
- en: There comes a time in the development of most applications where the developers
    or users start to notice the application is feeling a bit slow. There are some
    operations that seem to take a long time and it is harming the usability of the
    rest of the application. It could be computationally expensive, or it could be
    because of a network operation reaching out to another system.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数应用程序的开发过程中，开发者或用户开始注意到应用程序感觉有点慢。有些操作似乎需要很长时间，这损害了应用程序其他部分的可用性。这可能是因为计算成本高昂，也可能是因为网络操作需要连接到另一个系统。
- en: Let’s imagine that you are in this scenario. You have built a great application
    and an endpoint that allows users to generate a PDF report with the click of a
    button showing all kinds of fancy data and graphs. The problem is that to retrieve
    all the data and then crunch the numbers seems to take twenty (20) seconds. That’s
    an eternity for a HTTP request! After spending time to squeeze as much performance
    out of the report generator as you can, you are finally at the conclusion that
    it runs as fast as it can. What can you do?
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设你处于这种场景。你已经构建了一个优秀的应用程序和一个端点，允许用户通过点击按钮生成 PDF 报告，显示各种复杂的数据和图表。问题是，为了检索所有数据并处理这些数字似乎需要二十（20）秒。对于
    HTTP 请求来说，这是一段很长的时间！在花费时间尽可能提高报告生成器的性能之后，你最终得出结论，它已经尽可能快地运行。你能做什么？
- en: Push it to the background.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 将其推送到后台。
- en: When we say “background processing” what we really mean is a solution that allows
    the current request to complete without having finalized whatever it needs to
    be done. In this example, it would mean completing the request that *starts* the
    report generation before it is actually finished. Whenever and wherever you can,
    I recommend pushing work to the background. Earlier in the *Waiting on events*
    section of this Chapter we saw a use case for sending out registration emails
    in the background. Indeed the usage of signals as described earlier is a form
    of background processing. It is, however, not the only tool Sanic provides.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说“后台处理”时，我们真正指的是一种允许当前请求完成而不需要最终完成所需工作的解决方案。在这个例子中，这意味着在报告生成实际完成之前，完成启动报告生成的请求。无论何时何地，我都建议将工作推送到后台。在本章的“等待事件”部分中，我们看到了在后台发送注册电子邮件的用例。确实，如前所述的信号的使用是一种后台处理形式。然而，这并不是
    Sanic 提供的唯一工具。
- en: Adding tasks to the loop
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向循环中添加任务
- en: As you may already know, one of the cornerstones of the `asyncio` library are
    tasks. They are essentially the unit of processing that is responsible for running
    asynchronous work on the loop. If the concept of a task or the task loop are still
    foreign to you, it might be a good time to do a little research on the Internet
    before continuing on.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经知道，`asyncio` 库的一个基石是任务。它们本质上是在循环上运行异步工作的处理单元。如果任务或任务循环的概念对您来说仍然陌生，那么在继续之前，在互联网上做一些研究可能是个好主意。
- en: 'In the typical scenario, you can generate a task by getting access to the event
    loop, and then calling `create_task` as seen here:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型场景中，您可以通过获取事件循环并调用`create_task`来生成任务，如下所示：
- en: '[PRE83]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This is probably not new to you, but what this does is start running `something`
    in a task outside of the current one.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能对您来说并不陌生，但它的作用是在当前任务之外启动`something`。
- en: 'Sanic adds a simple interface for creating tasks, as shown here:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic提供了一个简单的接口来创建任务，如下所示：
- en: '[PRE84]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This is probably the simplest form of background processing, and is a pattern
    that you should get comfortable using. Why use this over `create_task`? There
    are three reasons:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是最简单的后台处理形式，并且是一个您应该习惯使用的模式。为什么使用这个而不是`create_task`？有三个原因：
- en: It is easier since you do not need to fetch the loop
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这更容易，因为您不需要获取循环。
- en: It can be used in the global scope before the loop has started
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在循环开始之前在全局范围内使用。
- en: It can be called or not called, and also with or without the application instance
    as an argument
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以调用或不调用，也可以带或不带应用程序实例作为参数。
- en: 'To illustrate the flexibility, contrast the previous example with this:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明灵活性，将上一个例子与以下例子进行对比：
- en: '[PRE85]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '**TIP**'
  id: totrans-436
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-437
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the task is not called like the first example, Sanic will introspect the
    function to see if it expects the `app` instance as an argument, and inject it.
  id: totrans-438
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果任务没有像第一个例子那样被调用，Sanic将检查该函数是否期望`app`实例作为参数，并将其注入。
- en: Asyncio tasks are very helpful, but sometimes you need a more robust solution.
    Let’s see what our other options are.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: Asyncio任务非常有帮助，但有时您需要一个更健壮的解决方案。让我们看看我们的其他选项。
- en: Integrating with an outside service
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与外部服务集成
- en: If there is work to be done by your application, but it is outside of the scope
    of your API for whatever reason, you might want to turn to an off-the-shelf solution.
    This comes in the form of another service that is running somewhere else. The
    job of your web API now is to feed work into that service.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序有工作要做，但由于某种原因超出了您的API范围，您可能需要转向现成的解决方案。这通常是以另一种在别处运行的服务的形式出现的。现在，您的Web
    API的工作就是向该服务提供工作。
- en: In the Python world, the classic framework for this kind of work is Celery.
    It is of course not the only option, but since this book is not about deciding
    what to use, we will show Celery as an example because it is widely used and known.
    In short, Celery is a platform with workers that read messages from a queue. Some
    client is responsible for pushing work to the queue, and when a worker receives
    the message, it executes the work.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python世界中，这类工作的经典框架是Celery。当然，这并不是唯一的选择，但鉴于这本书不是关于决定使用什么的，我们将以Celery为例，因为它被广泛使用且为人所知。简而言之，Celery是一个平台，它的工作进程从队列中读取消息。某些客户端负责将工作推送到队列，当工作进程接收到消息时，它将执行该工作。
- en: For Celery to operate, it runs a process on a machine somewhere. It has a set
    of known operations that it can perform (that are also called “tasks”). To initiate
    a task, an outside client needs to connect to it through a broker, and send instructions
    to run the task. A basic implementation might look like this.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 为了Celery能够运行，它在某台机器上运行一个进程。它有一组已知的操作可以执行（也称为“任务”）。要启动一个任务，外部客户端需要通过代理连接到它，并发送运行任务的指令。一个基本的实现可能看起来像这样。
- en: We setup a client to be able to communicate with the process. A common place
    to put this is on the `application.ctx` to make it usable anywhere in the application.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置了一个客户端，使其能够与进程通信。一个常见的放置位置是在`application.ctx`上，以便在应用程序的任何地方使用。
- en: '[PRE86]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: To use it, we simply call the client from the route handler to push some work
    to Celery.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用它，我们只需从路由处理程序中调用客户端，将一些工作推送到Celery。
- en: '[PRE87]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: An important thing to point out here is that we are using a `202 Accepted` status
    to tell whoever made the request that the operation has been accepted for processing.
    No guarantee is being made that it is done, or will be done.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要指出的重要一点是，我们正在使用`202 已接受`状态来告诉 whoever made the request，该操作已被接受处理。没有保证它会完成，或者将会完成。
- en: After examining Celery, you may be thinking that it is overkill for your needs.
    But, `app.add_task` does not seem like enough. Next we look at how you could develop
    your own in-process queue system.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查Celery之后，你可能认为它对你的需求来说有点过度。但是，`app.add_task`似乎还不够。接下来，我们将看看你如何开发自己的进程内队列系统。
- en: Designing an in-process task queue
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计进程内任务队列
- en: 'Sometimes the *obvious* goldilocks solution for your needs is to build something
    entirely confined to Sanic. It will be easier to manage if you have only one service
    to worry about instead of multiples. You may still want to keep the idea of “workers”
    and a “task queue” without the overhead required in implementing a service like
    Celery. So, let’s build something that hopefully you can use as a launching point
    for something even more amazing in your applications. Before we get started, you
    can checkout the final code product in the GitHub repo at: ___.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，对于你的需求来说，显而易见的黄金比例解决方案是构建一个完全局限于Sanic的东西。如果你只需要担心一个服务而不是多个服务，这将更容易管理。你可能仍然希望保留“工作者”和“任务队列”的概念，而不需要像Celery这样的服务实现所需的额外开销。所以，让我们构建一些东西，希望这能成为你在应用程序中构建更令人惊叹的东西的起点。在我们开始之前，你可以在GitHub仓库中查看最终的代码产品：___。
- en: Before we go any further, let’s change the name from “task queue” to “job queue”.
    We do not want to confuse ourselves with asyncio tasks for example. For the rest
    of this section, the word “task” will relate to an asyncio task.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，让我们将名称从“任务队列”更改为“作业队列”。我们不希望因为像asyncio任务这样的例子而混淆自己。在本节剩余部分，单词“任务”将指代asyncio任务。
- en: To begin, we will develop a set of needs for our job queue.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将开发一套针对我们的作业队列的需求。
- en: There should be one or more “workers” that are capable of executing jobs outside
    of the request/response cycle.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该有一个或多个能够执行作业（在请求/响应周期之外）的“工作者”。
- en: They should execute jobs in a first-in-first-out order.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们应该按照先入先出的顺序执行作业。
- en: Completion order of jobs is not important (for example, job A starts before
    job B, but it does not matter which one finishes first).
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作业的完成顺序并不重要（例如，作业A在作业B之前开始，但哪个先完成并不重要）。
- en: We should be able to check on the state of a job.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该能够检查作业的状态。
- en: 'Our strategy to achieve this will be to build out a framework where we have
    a “worker” that that is itself a background task. Its job will be to look for
    jobs inside of a common queue and execute them. The concept is very similar to
    Celery, except we are handling it all within our Sanic application with asyncio
    tasks. We are going to walk through the source to accomplish this, but not all
    of it. Implementation details not relevant to this discussion will be skipped
    here. For full details, please refer to the source code in the GitHub repository:
    ____.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现这一点的策略是构建一个框架，其中我们有一个“工作者”，它本身就是一个后台任务。它的任务是查找通用队列中的作业并执行它们。这个概念与Celery非常相似，但我们将在我们的Sanic应用程序中使用asyncio任务来处理它。我们将通过查看源代码来完成这一点，但不会全部展示。与本次讨论无关的实现细节将在此省略。有关完整详情，请参阅GitHub仓库中的源代码：____。
- en: To begin, let’s setup a very simple application with a single blueprint.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们设置一个非常简单的应用程序，它只有一个蓝图。
- en: '[PRE88]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: That blueprint will be the location where we will attach some listeners and
    our endpoints.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那个蓝图将是我们将附加一些监听器和端点的地方。
- en: '[PRE89]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'As you can see, we have three listeners that we need to run: `setup_job fetch`,
    `setup_task_executor`, and `register_operations`. We also have two views: one
    is a list view and the other a detail view. Let’s take each of these items in
    turn to see what they are.'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们需要运行三个监听器：`setup_job fetch`、`setup_task_executor`和`register_operations`。我们还有两个视图：一个是列表视图，另一个是详情视图。让我们逐一查看这些项目，看看它们是什么。
- en: Since we want to store the state of our tasks, we need some sort of a datastore.
    To keep things really simple, I created a file-based database called `FileBackend`.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们想要存储任务的状态，我们需要某种类型的数据存储。为了使事情尽可能简单，我创建了一个基于文件的数据库，名为`FileBackend`。
- en: '[PRE90]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The functionality of this job management system will be driven from our job
    queue, which will be implemented with `asyncio.Queue`. So, we next need to setup
    our queue and workers.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个作业管理系统将根据我们的作业队列的功能驱动，该队列将使用`asyncio.Queue`实现。因此，我们接下来需要设置我们的队列和工作者。
- en: '[PRE91]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: After creating our queue, we create one or more background tasks. As you can
    see, we are simply using Sanic’s `add_task` method to create a task from the `worker`
    function. We will see that function in just a moment.
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在创建我们的队列之后，我们创建一个或多个后台任务。正如你所见，我们只是使用Sanic的`add_task`方法从`worker`函数创建一个任务。我们将在稍后看到这个函数。
- en: The last listener we need will setup an object that will be used to hold all
    of our potential operations.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要的最后一个监听器将设置一个对象，该对象将用于存储我们所有的潜在操作。
- en: '[PRE92]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'To remind you, and `Operation` will be something that we want to run in the
    background. In this example, we have one operation: `Hello`. Before looking at
    an operation, let’s look at the two views.'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了提醒你，`Operation`将是我们希望在后台运行的东西。在这个例子中，我们有一个操作：`Hello`。在查看操作之前，让我们看看两个视图。
- en: 'The list view will have a POST call that is responsible for pushing a new job
    into the Queue. You can also imagine that this would be an appropriate place to
    make an endpoint that listed all of the existing jobs (paginated of course). First,
    it will need to get some data from the request:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列表视图将有一个POST调用，该调用负责将新的作业推入队列。你也可以想象这将是列出所有现有作业（当然，分页）的端点的一个合适位置。首先，它需要从请求中获取一些数据：
- en: '[PRE93]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Here, we perform some very simple data validation. In a real-world scenario,
    you might want to do some more to make sure that the request JSON conforms to
    what you are expecting.
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们执行一些非常简单的数据验证。在现实世界的场景中，你可能想要做更多的事情来确保请求的JSON符合你的预期。
- en: After validating the data, we can push information about the job to the queue.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在验证数据后，我们可以将有关作业的信息推送到队列。
- en: '[PRE94]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We created a UUID. This unique identifier will be used both in storing the job
    in our database, and retrieving information about it later. Also, it is important
    to point out that we are using the `202 Accepted` response since it is the most
    appropriate form.
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们创建了一个UUID。这个唯一标识符将用于在数据库中存储作业，并在以后检索有关它的信息。此外，重要的是指出，我们使用`202 Accepted`响应，因为它是最合适的形式。
- en: The detail view is very simple. Using the unique identifier, we simply look
    it up in the database and return it.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 详细视图非常简单。使用唯一标识符，我们只需在数据库中查找并返回它。
- en: '[PRE95]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Coming back to our `Hello` operation, we will build it now:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到我们的`Hello`操作，我们现在来构建它：
- en: '[PRE96]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: As you can see, it is a simple object that has a `run` method. That method will
    be called by the worker when running a `Job`.
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，它是一个简单的对象，有一个`run`方法。当运行`Job`时，该方法将由工作者调用。
- en: The worker is really nothing more than an async function. Its job will be to
    run a never ending loop. Inside that loop it will wait until there is a job in
    the queue.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作者实际上只是一个异步函数。它的任务将运行一个永无止境的循环。在这个循环中，它将等待队列中有作业。
- en: '[PRE97]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Once it has the information about how to run a job, it needs to create a job
    instance, and execute it.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦它有了如何运行作业的信息，它需要创建一个作业实例，并执行它。
- en: '[PRE98]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'A couple final things to say about this solution: one of its biggest faults
    is that it has no recovery. If your application crashes or restarts, there is
    no way to continue processing a job that had already begun. In a true task management
    process, this is usually an important feature. Therefore, in the GitHub repository
    in addition to the source used to build this solution, you will find source code
    for a “subprocess” task queue. I will not walk you through the steps to build
    it since it is largely a similar exercise with a lot of the same code. However,
    it differs from this solution in two important ways: it does have the ability
    to recover and restart an unfinished job, and instead of running in asyncio tasks,
    it leverages Sanic’s process management listeners to create a subprocess using
    multiprocessing techniques. Please take some time to look through the source code
    there as you continue to learn and work your way through this book.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个解决方案的几点补充：它最大的缺点是没有恢复机制。如果你的应用程序崩溃或重启，将无法继续处理已经开始的作业。在真正的任务管理过程中，这通常是一个重要的功能。因此，在GitHub仓库中，除了构建此解决方案所使用的源代码外，你还会找到“子进程”任务队列的源代码。我不会带你一步步构建它，因为它在很大程度上是一个类似的练习，有很多相同的代码。然而，它与这个解决方案在两个重要方面有所不同：它确实有恢复和重启未完成作业的能力，并且它不是在异步任务中运行，而是利用Sanic的进程管理监听器通过多进程技术创建子进程。在你继续学习和通过这本书的工作时，请花些时间查看那里的源代码。
- en: Summary
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In my opinion, one of the biggest leaps that you can make as an application
    developer is devising strategies to abstract a solution to a problem, and to reuse
    that solution in multiple places. If you have ever heard of the DRY (Don’t Repeat
    Yourself) principle, this is what I mean. Applications are seldom ever “complete.”
    We develop them, maintain them, and change them. If we have too much repetitive
    code, or code that is too tightly coupled to a single use case, then it becomes
    more difficult to change it or adapt it to different use cases. Learning to generalize
    our solutions mitigates this problem.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，作为应用开发者，你可以迈出的最大一步之一是制定策略来抽象问题的解决方案，并在多个地方重用该解决方案。如果你听说过 DRY（不要重复自己）原则，这就是我的意思。应用程序很少是“完整”的。我们开发它们、维护它们并修改它们。如果我们有太多的重复代码，或者代码与单一用例过于紧密耦合，那么修改它或将其适应不同用例就会变得更加困难。学会概括我们的解决方案可以减轻这个问题。
- en: In Sanic, this means taking logic out of the route handlers. It is best if we
    can minimize the amount of code in the individual handlers, and instead place
    that code in other locations where it can be reused by other endpoints. Did you
    notice how the route handlers in the final example in *Designing an in-process
    task queue* had not more than a dozen lines? While the exact length is not important,
    it is helpful to keep these clean and short and place your logic somewhere else.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Sanic 中，这意味着将逻辑从路由处理程序中提取出来。最好我们能够最小化单个处理程序中的代码量，并将这些代码放置在其他位置，以便其他端点可以重用。你是否注意到了在
    *设计进程内任务队列* 的最终示例中，路由处理程序并没有超过十几行？虽然确切的长度并不重要，但保持这些代码简洁且简短，并将你的逻辑放在其他地方是有帮助的。
- en: Perhaps one of the biggest takeaways from this Chapter should be that there
    is usually not a single way to do something. Often we can use a mixture of these
    methodologies to achieve our goal. It is then the job of the application developer
    to look at the tool belt and decide which tool is best for any given situation.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 也许本章最大的收获之一应该是通常没有一种唯一的方法来完成某事。我们经常可以使用这些方法的混合来达到我们的目标。那么，应用开发者的任务就是查看工具箱，并决定在特定情况下哪种工具最适合。
- en: For this reason, as a Sanic developer you should learn how to devise strategies
    to respond to web requests outside of the route handler. In this chapter, we learned
    about some tools to help you accomplish this using middleware; built-in and custom
    signals; connection management; exception handling; and background processing.
    Again, think of these as your core tools in your toolbelt. Got a screw that needs
    tightening? Pull out your middleware. Need to drill a hole in some wood? Time
    to grab the drill off the shelf. The more familiar you become with basic building
    blocks like these in Sanic, the greater your understanding will be in how to piece
    together a professional grade application.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为一个 Sanic 开发者，你应该学习如何制定策略来在路由处理程序之外响应网络请求。在本章中，我们学习了使用中间件、内置和自定义信号、连接管理、异常处理和后台处理等工具来帮助你完成这项任务。再次强调，将这些视为你的工具箱中的核心工具。需要拧紧螺丝吗？拿出你的中间件。需要在木头上钻孔吗？是时候从架子上拿走钻头了。你对
    Sanic 中这些基本构建块（如中间件）越熟悉，你对如何构建专业级应用程序的理解就会越深入。
- en: It is your job now to play with these and internalize them on your way to becoming
    a better developer.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是你的任务，通过玩转这些工具并在成为更好的开发者道路上内化它们。
- en: We have scratched the surface of security-related issues. In the next Chapter,
    we will take a closer look at how we can protect our Sanic applications.h
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经触及了与安全相关问题的表面。在下一章中，我们将更深入地探讨如何保护我们的 Sanic 应用程序。
