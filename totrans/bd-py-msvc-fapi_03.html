<html><head></head><body>
		<div id="_idContainer020">
			<h1 id="_idParaDest-53" class="chapter-number"><a id="_idTextAnchor052"/>3</h1>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor053"/>Investigating Dependency Injection</h1>
			<p>Since the first chapter, <strong class="bold">Dependency Injection</strong> (<strong class="bold">DI</strong>) has been accountable for building clean and robust FastAPI REST services and was apparent in some of our sample APIs that required <strong class="source-inline">BaseModel</strong>, <strong class="source-inline">Request</strong>, <strong class="source-inline">Response</strong>, and <strong class="source-inline">BackgroundTasks</strong> in their processes. Applying DI proves that instantiating some FastAPI classes is not always the ideal approach, since the framework has a built-in container that can provide the objects of these classes for the API services. This method of object management makes FastAPI easy and efficient to use.</p>
			<p>FastAPI has a container where the DI policy is applied to instantiate module classes and even functions. We only need to specify and declare these module APIs to the services, middleware, authenticator, data sources, and test cases because the rest of the object assembly, management, and instantiation is now the responsibility of the built-in container.</p>
			<p>This chapter will help you to understand how to manage objects needed by the application, such as minimizing some instances and creating loose bindings among them. Knowing the effectiveness of DI on FastAPI is the first step in designing our microservice applications. Our discussions will focus on the following:</p>
			<ul>
				<li>Applying <strong class="bold">Inversion of Control</strong> (<strong class="bold">IoC</strong>) and DI</li>
				<li>Exploring ways of injecting dependencies</li>
				<li>Organizing a project based on dependencies</li>
				<li>Using third-party containers</li>
				<li>Scoping of instances</li>
			</ul>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor054"/>Technical requirements</h1>
			<p>This chapter uses a software prototype called <em class="italic">online recipe system</em>, which manages, evaluates, rates, and reports recipes of different types and origins. Applying a DI pattern is the priority of this project, so expect some changes in the development strategies and approaches, such as adding <strong class="source-inline">model</strong>, <strong class="source-inline">repository</strong>, and <strong class="source-inline">service</strong> folders. This software is for food enthusiasts or chefs who want to share their specialties, newbies looking for recipes to experiment with, and guests who just like to browse through different food menus. This open-ended application does not use any database management system yet, so all the data is temporarily stored in Python containers. Code is all uploaded at <a href="https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch03">https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch03</a>.</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor055"/>Applying IoC/DI</h1>
			<p>FastAPI is a <a id="_idIndexMarker132"/>framework <a id="_idIndexMarker133"/>that supports the IoC principle, which means that it has a container that can instantiate objects for an application. In a typical programming scenario, we instantiate classes to use them in many ways to build a running application. But with IoC, the framework instantiates the components for the application. <em class="italic">Figure 3.1</em> shows the whole picture of the IoC principle and the participation of one of its forms, called the DI.</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/Figure_3.1_B17975.jpg" alt="Figure 3.1 – The IoC principle"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – The IoC principle</p>
			<p>For FastAPI, DI is not only a principle but a mechanism to integrate an object into a component that leads to creating a <em class="italic">loosely coupled</em> but <em class="italic">highly cohesive</em> software structure. Almost all components can be candidates for DI, including <em class="italic">functions</em>. But for now, let us focus on <em class="italic">callable components</em> that provide some JSON objects once they are injected into an API service – injectable and callable components that we call <em class="italic">dependency functions</em>.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>Injecting a dependency function</h2>
			<p>A <strong class="bold">dependency function</strong> is a<a id="_idIndexMarker134"/> typical Python function that has parameters such as a path operation or an API service and a return value of a JSON type too. A sample implementation is <strong class="source-inline">create_login()</strong>, as shown in the following code, which is in the project’s <strong class="source-inline">/api/users.py</strong> module:</p>
			<pre class="source-code">
def <strong class="bold">create_login</strong>(<strong class="bold">id:UUID, username: str, password:str,</strong> 
                 <strong class="bold">type: UserType</strong>):
    account = {"id": <strong class="bold">id</strong>, "username": <strong class="bold">username</strong>, "password":
                 <strong class="bold">password</strong>, "type": <strong class="bold">type</strong>}
    return <strong class="bold">account</strong></pre>
			<p>The function requires the <strong class="source-inline">id</strong>, <strong class="source-inline">username</strong>, and <strong class="source-inline">password</strong> parameters and <strong class="source-inline">type</strong> to continue its process and return a valid JSON <strong class="source-inline">account</strong> object, derived from these parameters. A dependency function sometimes uses some underlying formula, resource, or complex algorithms to derive its function value, but for now, we utilize it as a <em class="italic">placeholder of data</em> or <strong class="source-inline">dict</strong>.</p>
			<p>Common to dependency functions are method parameters that serve as placeholders to a REST API’s incoming request. These are wired into the API’s method parameter list as a domain model to the query parameters or request body through DI. The <strong class="source-inline">Depends()</strong> function from the <strong class="source-inline">fastapi</strong> module pursues the injection before it wires the injectable to a local parameter. The module function can only take one parameter for injection:</p>
			<pre class="source-code">
from fastapi import APIRouter, <strong class="bold">Depends</strong>
<strong class="bold">@router.get("/users/function/add")</strong>
def populate_user_accounts(
              <strong class="bold">user_account=Depends(create_login)</strong>):
    account_dict = jsonable_encoder(user_account)
    login = Login(**account_dict)
    login_details[login.id] = login
    return login</pre>
			<p>The preceding is a code fragment from our <em class="italic">online recipe system</em> that shows how <strong class="source-inline">Depends()</strong> injects <strong class="source-inline">create_login()</strong>into the framework’s container and fetches its instance for <em class="italic">wiring</em> to the <strong class="source-inline">populate_user_accounts()</strong> service. Syntactically, the injection process only needs the name of the function dependency without the parenthesis. Again, the purpose of <strong class="source-inline">create_login()</strong> is to capture the query parameters of the API service. The <strong class="source-inline">jsonable_encoder()</strong> is very useful to many APIs in converting these injectables to JSON-compatible types such as <strong class="source-inline">dict</strong>, which are essential <a id="_idIndexMarker135"/>for <em class="italic">instantiating the needed data models</em> and <em class="italic">generating responses</em>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The term <strong class="bold">dependencies</strong> can be used interchangeably with <strong class="bold">injectables</strong>, <strong class="bold">dependables</strong>, <strong class="bold">resources</strong>, <strong class="bold">providers</strong>, or <strong class="bold">components</strong>.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>Injecting a callable class</h2>
			<p>FastAPI also<a id="_idIndexMarker136"/> allows classes to be injected into any components, since they can also be considered <em class="italic">callable</em> components. A class becomes <em class="italic">callable</em> during instantiation when the call to its constructor, <strong class="source-inline">__init__(self)</strong>, is done. Some of these classes have <em class="italic">no-arg</em> constructors, while others, such as the following <strong class="source-inline">Login</strong> class, require constructor arguments:</p>
			<pre class="source-code">
class <strong class="bold">Login</strong>:
    <strong class="bold">def __init__(self, id: UUID, username: str, </strong>
                 <strong class="bold">password: str, type: UserType</strong>): 
        self.id = id
        self.username = username
        self.password = password
        self.type= type</pre>
			<p>The <strong class="source-inline">Login</strong> class, located in <strong class="source-inline">/model/users.py</strong>, needs <strong class="source-inline">id</strong>, <strong class="source-inline">username</strong>, <strong class="source-inline">password</strong>, and <strong class="source-inline">type</strong> passed to its constructor before the instantiation. A possible instantiation would be <strong class="source-inline">Login(id=' 249a0837-c52e-48cd-bc19-c78e6099f931', username='admin', password='admin2255', type=UserType.admin)</strong>. Overall, we can observe the similarity between a class and a dependency function based on their callable behavior and the ability to capture request data, such as a model attribute.</p>
			<p>Conversely, the <strong class="source-inline">populate_login_without_service()</strong> shown in the following code block shows how <strong class="source-inline">Depends()</strong> injects <strong class="source-inline">Login</strong> to the service. The <strong class="source-inline">Depends()</strong> function tells the built-in container to instantiate <strong class="source-inline">Login</strong> and fetches that instance, ready to be <a id="_idIndexMarker137"/>assigned to the <strong class="source-inline">user_account</strong> local parameter:</p>
			<pre class="source-code">
<strong class="bold">@router.post("/users/datamodel/add")</strong>
def populate_login_without_service(
              <strong class="bold">user_account=Depends(Login)</strong>):
    account_dict = jsonable_encoder(user_account)
    login = Login(**account_dict)
    login_details[login.id] = login
    return login</pre>
			<p class="callout-heading">Important Note</p>
			<p class="callout">All dependencies should be declared at the right-most part of the service’s parameter list. If there are query, path, or form parameters, injectables should come last. Moreover, the use of the <strong class="source-inline">jsonable_encoder()</strong> function can be an option if the <em class="italic">injectables</em> do not contain data that are hard to encode by default. </p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Building nested dependencies</h2>
			<p>There are some <a id="_idIndexMarker138"/>scenarios when injectables are also dependent on other dependencies. When we inject a function dependency to another function, a class dependency to another class injectable, or a function resource to a class, the goal is to build nested dependencies. Nested dependencies are beneficial to REST APIs, with lengthy and complex request data that needs structuring and grouping through sub-domain models. These sub-domains or domain models within a model are later encoded as sub-dependencies into JSON-compatible types by FastAPI:</p>
			<pre class="source-code">
async def<strong class="bold"> create_user_details</strong>(id: UUID, firstname: str,
         lastname: str, middle: str, bday: date, pos: str, 
         <strong class="bold">login=Depends(create_login)</strong>):
    user = {"id": id, "firstname": firstname, 
            "lastname": lastname, "middle": middle, 
            "bday": bday, "pos": pos, "login": login}
    return user</pre>
			<p>The preceding asynchronous <strong class="source-inline">create_user_details()</strong> function shows that even a dependency function needs another dependency to satisfy its purpose. This function is dependent on <strong class="source-inline">create_login()</strong>, which is another dependable component. With this nested dependency setup, wiring the <strong class="source-inline">create_user_details()</strong> into an API service also includes the injection of <strong class="source-inline">create_login()</strong> into the container. In short, there is a<a id="_idIndexMarker139"/> chain of DIs that will be created when nested dependencies are applied:</p>
			<pre class="source-code">
@router.post("/users/add/profile")
async def add_profile_login(
          <strong class="bold">profile=Depends(create_user_details)</strong>): 
    user_profile = jsonable_encoder(profile)
    <strong class="bold">user = User(**user_profile)</strong>
    <strong class="bold">login = user.login</strong>
    <strong class="bold">login = Login(**login)</strong>
    user_profiles[user.id] = user
    login_details[login.id] = login
    return user_profile</pre>
			<p>The preceding <strong class="source-inline">add_profile_login()</strong> service provides a clear picture of its dependency on <strong class="source-inline">create_user_details()</strong>, including its underlying login details. The FastAPI container successfully created the two functions through chained DI to capture the request data during the API’s request transactions. </p>
			<p>Conversely, a class can also be dependable on another class. An example is the <strong class="source-inline">Profile</strong> class, shown<a id="_idIndexMarker140"/> here, which is dependent on <strong class="source-inline">UserDetails</strong> and <strong class="source-inline">Login</strong> classes:</p>
			<pre class="source-code">
class <strong class="bold">Login</strong>:
    <strong class="bold">def __init__(self, id: UUID, username: str, </strong>
                 <strong class="bold">password: str, type: UserType): </strong>
        self.id = id
        self.username = username
        self.password = password
        self.type= type
class <strong class="bold">UserDetails</strong>: 
    <strong class="bold">def __init__(self, id: UUID, firstname: str, </strong>
            <strong class="bold">lastname: str, middle: str, bday: date, </strong>
               <strong class="bold">pos: str ):</strong>
        self.id = id 
        self.firstname = firstname 
        self.lastname = lastname 
        self.middle = middle 
        self.bday = bday 
        self.pos = pos
        
class <strong class="bold">Profile</strong>:
    <strong class="bold">def __init__(self, id: UUID, date_created: date, </strong>
        <strong class="bold">login=Depends(Login), user=Depends(UserDetails)</strong>): 
        self.id = id 
        self.date_created = date_created
        <strong class="bold">self.login = login </strong>
        <strong class="bold">self.user = user</strong></pre>
			<p>There is a nested dependency here because two classes will be injected altogether once <strong class="source-inline">Profile</strong> is wired to a REST API service. </p>
			<p>A clear advantage <a id="_idIndexMarker141"/>of these chained dependencies is depicted in the following <strong class="source-inline">add_profile_login_models()</strong> service:</p>
			<pre class="source-code">
@router.post("/users/add/model/profile")
async def add_profile_login_models(
                   <strong class="bold">profile=Depends(Profile)</strong>): 
     <strong class="bold">user_details = jsonable_encoder(profile.user)</strong>
     <strong class="bold">login_details = jsonable_encoder(profile.login)</strong>
     <strong class="bold">user = UserDetails(**user_details)</strong>
     <strong class="bold">login = Login(**login_details)</strong>
     user_profiles[user.id] = user
     login_details[login.id] = login
     return {"profile_created": profile.date_created}</pre>
			<p>The extraction of <strong class="source-inline">profile.user</strong> and <strong class="source-inline">profile.login</strong> makes it easier for the service to identify what query data to deserialize. It also helps the service determine which group of data needs <strong class="source-inline">Login</strong> instantiation and which is for <strong class="source-inline">UserDetails</strong>. As a result, it will be easier to manage the persistency of these objects in their respective <strong class="source-inline">dict</strong> repositories. </p>
			<p>Creating explicit dependencies between function and class<a id="_idIndexMarker142"/> will be discussed later, but for now, let us examine how to fine-tune whenever we use lots of these nested dependencies in our application.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>Caching the dependencies</h2>
			<p>All dependencies <a id="_idIndexMarker143"/>are <em class="italic">cacheable</em>, and FastAPI caches all these dependencies during a request transaction. If a dependable is common to all services, FastAPI will not allow you to fetch these objects from its container <em class="italic">by default</em>. Rather, it will look for this injectable from its cache to be used multiple times across the API layer. Saving dependencies, especially nested ones, is a good feature of FastAPI because it optimizes the performance of the REST service.</p>
			<p>Conversely, <strong class="source-inline">Depends()</strong> has a <strong class="source-inline">use_cache</strong> parameter that we can set to <strong class="source-inline">False</strong> if we want to bypass this caching mechanism. Configuring this hook will not save the dependencies from the cache during request transactions, allowing <strong class="source-inline">Depends()</strong> to fetch the instances from the container more frequently. Another version of the <strong class="source-inline">add_profile_login_models()</strong> service, shown here, shows how to disable dependency caching:</p>
			<pre class="source-code">
<strong class="bold">@router.post("/users/add/model/profile")</strong>
async def add_profile_login_models(
   profile:<strong class="bold">Profile</strong>=Depends(Profile, <strong class="bold">use_cache=False</strong>)): 
     user_details = jsonable_encoder(profile.user)
     login_details = jsonable_encoder(profile.login)
     … … … … … …
     return {"profile_created": profile.date_created}</pre>
			<p>Another obvious change in the preceding service implementation is the presence of the <strong class="source-inline">Profile</strong> data type in the local parameter declaration. Is this really allowed by FastAPI?</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>Declaring Depends() parameter types</h2>
			<p>Generally, we do not<a id="_idIndexMarker144"/> declare types of the local parameters that will reference the injected dependencies. Due to <em class="italic">type hints</em>, we can optionally associate the references with their appropriate object types. For instance, we can re-implement <strong class="source-inline">populate_user_accounts()</strong> to include the type of <strong class="source-inline">user_account</strong>, such as the following one:</p>
			<pre class="source-code">
<strong class="bold">@router.get("/users/function/add")</strong>
def populate_user_accounts(
           <strong class="bold">user_account:Login=Depends(create_login)</strong>):
    account_dict = jsonable_encoder(user_account)
    login = Login(**account_dict)
    login_details[login.id] = login
    return login</pre>
			<p>This scenario happens very rarely, since <strong class="source-inline">create_login()</strong> is a dependency function, and we usually do not create classes only to provide the blueprint type of its returned values. But when we use class dependables, declaring the appropriate class type to the wired object is feasible, as in the following <strong class="source-inline">add_profile_login_models()</strong> service, which<a id="_idIndexMarker145"/> declares the <strong class="source-inline">profile</strong> parameter as <strong class="source-inline">Profile</strong>:</p>
			<pre class="source-code">
<strong class="bold">@router.post("/users/add/model/profile")</strong>
async def add_profile_login_models(
              <strong class="bold">profile:Profile=Depends(Profile)</strong>): 
     user_details = jsonable_encoder(profile.user)
     login_details = jsonable_encoder(profile.login)
     … … … … … …
     return {"profile_created": profile.date_created}</pre>
			<p>Although the declaration is syntactically valid, the expression looks <em class="italic">repetitive</em> and <em class="italic">redundant</em> because the <strong class="source-inline">Profile</strong> type appears twice in the declaration portion. To avoid this redundancy, we can replace the statement with a shorthand version by omitting the class name inside the <strong class="source-inline">Depends()</strong> function. Thus, a better way of declaring the preceding <strong class="source-inline">profile</strong> should be the following:</p>
			<pre class="source-code">
<strong class="bold">@router.post("/users/add/model/profile")</strong>
async def add_profile_login_models(
              <strong class="bold">profile:Profile=Depends()</strong>): 
     user_details = jsonable_encoder(profile.user)
     ... ... ... ... ... ...
     return {"profile_created": profile.date_created}</pre>
			<p>The changes<a id="_idIndexMarker146"/> reflected on the parameter list will not affect the performance of the request transaction of the <strong class="source-inline">add_profile_login_models()</strong> service.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>Injecting asynchronous dependencies</h2>
			<p>A FastAPI built-in<a id="_idIndexMarker147"/> container does not only manage <em class="italic">synchronous</em> function dependables but also <em class="italic">asynchronous</em> ones. The following <strong class="source-inline">create_user_details()</strong> is an asynchronous dependency, read to be wired to a service:</p>
			<pre class="source-code">
<strong class="bold">async</strong> <strong class="bold">def create_user_details</strong>(id: UUID, firstname: str, 
       lastname: str, middle: str, bday: date, pos: str, 
       <strong class="bold">login=Depends(create_login)</strong>):
    user = {"id": id, "firstname": firstname, 
            "lastname": lastname, "middle": middle, 
            "bday": bday, "pos": pos, "login": login}
    return user</pre>
			<p>The container can manage both synchronous and asynchronous function dependency. It can allow the wiring of <em class="italic">asynchronous dependables</em> on an asynchronous API service or some <em class="italic">asynchronous ones</em> on a synchronous API. In cases where the dependency and the services are both asynchronous, applying the <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> protocol is recommended to avoid discrepancies in the results. <strong class="source-inline">create_user_details()</strong>, which is dependent on a synchronous <strong class="source-inline">create_login()</strong>, is wired on <strong class="source-inline">add_profile_login()</strong>, which is an asynchronous API.</p>
			<p>After learning how DI design pattern works in FastAPI, the next step is to know the different levels<a id="_idIndexMarker148"/> of strategy for applying <strong class="source-inline">Depends()</strong> in our application.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/>Exploring ways of injecting dependencies</h1>
			<p>From the previous<a id="_idIndexMarker149"/> discussions, we know that FastAPI has a built-in container through which some objects are injected and instantiated. Likewise, we have learned that the only FastAPI components that are injectables are those so-called dependables, injectables, or dependencies. Now, let us enumerate different ways to pursue the DI pattern in our application.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>Dependency injection on services</h2>
			<p>The most <a id="_idIndexMarker150"/>common area where DI occurs is in the <em class="italic">parameter list</em> of a service method. Any discussions regarding this strategy have been tackled already in the previous examples, so we only need to present additional points concerning this strategy: </p>
			<ul>
				<li>First, the number of custom injectables a service method should take is also part of the concern. When it comes to complex query parameters or request bodies, API services can take more than one injectable as long as there are no similar instance variable names among these dependables. This <em class="italic">variable name collision</em> among the dependables will lead to having one parameter entry for the conflicted variable during the request transactions, thus sharing the same value for all these conflicting variables.</li>
				<li>Second, the appropriate <em class="italic">HTTP method operation</em> to work with the injectables is also one aspect to consider. Both function and class dependencies can work with the <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">PATCH</strong> operations, except for those dependables with attribute types such as numeric <strong class="source-inline">Enum</strong> and <strong class="source-inline">UUID</strong> that can cause an <em class="italic">HTTP Status 422</em> (<strong class="bold">Unprocessable Entity</strong>) due to conversion problems. We must plan which HTTP method is applicable for some dependable(s) first, before implementing the service method.</li>
				<li>Third, not all dependables are placeholders of request data. Unlike the class dependables, dependency functions are not specifically used for returning objects <a id="_idIndexMarker151"/>or <strong class="source-inline">dict</strong>. Some of them are used in <em class="italic">filtering request data</em>, <em class="italic">scrutinizing authentication details</em>, <em class="italic">managing form data</em>, <em class="italic">verifying header values</em>, <em class="italic">handling cookies</em>, and <em class="italic">throwing some errors</em> when there are violations of some rules. The following <strong class="source-inline">get_all_recipes()</strong> service is dependent on a <strong class="source-inline">get_recipe_service()</strong> injectable that will query all the recipes from the <strong class="source-inline">dict</strong> repository of the application:</li>
			</ul>
			<pre class="source-code">
<strong class="bold">@router.get("/recipes/list/all")</strong>
def get_all_recipes(<strong class="bold">handler=Depends(get_recipe_service)</strong>):
      return handler.get_recipes()</pre>
			<p>The dependency function provides the needed transactions such as saving and retrieving records of recipes. Instead of the usual instantiation or method call, a better strategy is to inject these <em class="italic">dependable services</em> into the API implementation. The <strong class="source-inline">handler</strong> method parameter, which refers to the instance of <strong class="source-inline">get_recipe_service()</strong>, invokes<a id="_idIndexMarker152"/> the <strong class="source-inline">get_recipes()</strong> transactions of a particular service to retrieve all the menus and ingredients stored in the repository.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>Dependency injection on path operators</h2>
			<p>There is <a id="_idIndexMarker153"/>always an option to implement <em class="italic">triggers</em>, <em class="italic">validators</em>, and <em class="italic">exception handlers</em> as injectable functions. Since these dependables work like <em class="italic">filters</em> to the incoming request, their injection happens in the <em class="italic">path operator</em> and not in the service parameter list. The following code is an implementation of the <strong class="source-inline">check_feedback_length()</strong> validator, found in <strong class="source-inline">/dependencies/posts.py</strong>, which checks whether the feedback posted by a user regarding a recipe should be at least 20 characters, including spaces: </p>
			<pre class="source-code">
def check_feedback_length(request: Request): 
    <strong class="bold">feedback = request.query_params["feedback"]</strong>
    if feedback == None:
        <strong class="bold">raise HTTPException(status_code=500, </strong>
           <strong class="bold">detail="feedback does not exist")</strong>
    if len(feedback) &lt; 20:
        <strong class="bold">raise HTTPException(status_code=403, </strong>
           <strong class="bold">detail="length of feedback … not lower … 20")</strong></pre>
			<p>The validator pauses the API execution to retrieve the feedback from a post to be validated <em class="italic">if its length is lower than 20</em>. If the dependency function finds it <strong class="source-inline">True</strong>, it will throw an <em class="italic">HTTP Status 403</em>. Alternatively, it will emit a <em class="italic">Status Code 500</em> if the feedback is missing from the request data; otherwise, it will let the API transaction finish its task.</p>
			<p>Compared to the <strong class="source-inline">create_post()</strong> and <strong class="source-inline">post_service()</strong> dependables, the following script shows that the <strong class="source-inline">check_feedback_length()</strong> validator is not invoked anywhere inside the <strong class="source-inline">insert_post_feedback()</strong> service:</p>
			<pre class="source-code">
async def <strong class="bold">create_post</strong>(id:UUID, feedback: str, 
    rating: RecipeRating, userId: UUID, date_posted: date): 
    post = {"id": id, "feedback": feedback, 
            "rating": rating, "userId" : userId, 
            "date_posted": date_posted}
    return post
<strong class="bold">@router.post</strong>("/posts/insert",
      <strong class="bold">dependencies=[Depends(check_feedback_length)]</strong>)
async def insert_post_feedback(<strong class="bold">post=Depends(create_post)</strong>, 
          <strong class="bold">handler=Depends(post_service)</strong>): 
    post_dict = jsonable_encoder(post)
    post_obj = Post(**post_dict)
    handler.add_post(post_obj)
    return post</pre>
			<p>The validator will always work closely with the incoming request transaction, whereas the other two <a id="_idIndexMarker154"/>injectables, <strong class="source-inline">post</strong> and <strong class="source-inline">handler</strong>, are part of the API’s transactions.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The path router of <strong class="source-inline">APIRouter</strong> can accommodate more than one injectable, which is why its <strong class="source-inline">dependencies</strong> parameter always needs a <strong class="source-inline">List</strong> value (<strong class="source-inline">[]</strong>).</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>Dependency injection on routers</h2>
			<p>However, some<a id="_idIndexMarker155"/> transactions are not localized to work on one specific API. There are dependency functions created to work with a certain group of REST API services within an application, such as the following <strong class="source-inline">count_user_by_type()</strong> and <strong class="source-inline">handler check_credential_error()</strong> events that are designed to manage incoming requests of REST APIs under the <strong class="source-inline">user.router</strong> group. This strategy requires DI at the <strong class="source-inline">APIRouter</strong> level:</p>
			<pre class="source-code">
from fastapi import Request, HTTPException
<strong class="bold">from repository.aggregates import stats_user_type</strong>
import json
def count_user_by_type(<strong class="bold">request: Request</strong>):
    try:
      count = 
          stats_user_type[<strong class="bold">request.query_params.get("type")</strong>]
      count += 1
      stats_user_type[<strong class="bold">request.query_params.get("type")</strong>] =
          count
      print(json.dumps(stats_user_type))
    except:
      stats_user_type[<strong class="bold">request.query_params.get("type")</strong>] = 1
def check_credential_error(<strong class="bold">request: Request</strong>): 
    try:
      <strong class="bold">username = request.query_params.get("username")</strong>
      <strong class="bold">password = request.query_params.get("password")</strong>
      if username == password:
        raise HTTPException(status_code=403, 
         detail="username should not be equal to password")
    except:
      raise HTTPException(status_code=500, 
           detail="encountered internal problems")         </pre>
			<p>Based on the <a id="_idIndexMarker156"/>preceding implementations, the goal of <strong class="source-inline">count_user_by_type()</strong> is to build an updated frequency of users in <strong class="source-inline">stats_user_type</strong> according to <strong class="source-inline">UserType</strong>. Its execution starts right after the REST API receives a new user and login details from the client. While it checks the <strong class="source-inline">UserType</strong> of the new record, the API service pauses briefly and resumes after the function dependency has completed its tasks.  </p>
			<p>Conversely, the task of <strong class="source-inline">check_credential_error()</strong> is to ensure that the <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong> of the new user should not be the same. It throws an <em class="italic">HTTP Status 403</em>  when the credentials are the same, which will halt the whole REST service transaction.  </p>
			<p>Injecting these two dependables through <strong class="source-inline">APIRouter</strong> means that all the REST API services registered in that <strong class="source-inline">APIRouter</strong> will always trigger the executions of these dependencies. The dependencies can only work with API services designed to persist the like of the <strong class="source-inline">user</strong> and <strong class="source-inline">login</strong> details, as <a id="_idIndexMarker157"/>shown here:</p>
			<pre class="source-code">
from fastapi import APIRouter, Depends
router = APIRouter(<strong class="bold">dependencies=[</strong>
                      <strong class="bold">Depends(count_user_by_type)</strong>, 
                      <strong class="bold">Depends(check_credential_error)]</strong>)
<strong class="bold">@router.get("/users/function/add")</strong>
def populate_user_accounts(
          <strong class="bold">user_account:Login=Depends(create_login)</strong>):
    account_dict = jsonable_encoder(user_account)
    login = Login(**account_dict)
    login_details[login.id] = login
    return login</pre>
			<p><strong class="source-inline">check_credential_error()</strong>, which is injected into the <strong class="source-inline">APIRouter</strong> component, filters the <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong> derived from the <strong class="source-inline">create_login()</strong> injectable function. Likewise, it filters the <strong class="source-inline">create_user_details()</strong> injectable of the <strong class="source-inline">add_profile_login()</strong> service, as shown in the following snippet:</p>
			<pre class="source-code">
<strong class="bold">@router.post("/users/add/profile")</strong>
async def add_profile_login(
          <strong class="bold">profile=Depends(create_user_details)</strong>): 
    user_profile = jsonable_encoder(profile)
    user = User(**user_profile)
    login = user.login
    login = Login(**login)
    user_profiles[user.id] = user
    login_details[login.id] = login
    return user_profile
<strong class="bold">@router.post("/users/datamodel/add")</strong>
def populate_login_without_service(
          <strong class="bold">user_account=Depends(Login)</strong>):
    account_dict = jsonable_encoder(user_account)
    login = Login(**account_dict)
    login_details[login.id] = login
    return login</pre>
			<p>The <strong class="source-inline">Login</strong> injectable class also undergoes filtering through <strong class="source-inline">check_credential_error()</strong>. It also contains the <strong class="source-inline">username</strong> and <strong class="source-inline">password </strong>parameters that<a id="_idIndexMarker158"/> the injectable function can filter. Conversely, the injectable <strong class="source-inline">Profile</strong> of the following <strong class="source-inline">add_profile_login_models()</strong> service is not excluded from the error-checking mechanism because it has a <strong class="source-inline">Login</strong> dependency in its constructor. Having the <strong class="source-inline">Login</strong> dependable means <strong class="source-inline">check_cedential_error()</strong> will also filter <strong class="source-inline">Profile</strong>.</p>
			<p>With <strong class="source-inline">check_credential_error()</strong> is the <strong class="source-inline">count_user_by_type()</strong> injectable that counts the number of users that access the API service:</p>
			<pre class="source-code">
<strong class="bold">@router.post("/users/add/model/profile")</strong>
async def add_profile_login_models(
          <strong class="bold">profile:Profile=Depends(Profile)</strong>): 
     user_details = jsonable_encoder(profile.user)
     ... ... ... ... ... ...
     login = Login(**login_details)
     user_profiles[user.id] = user
     login_details[login.id] = login
     return {"profile_created": profile.date_created}</pre>
			<p>A dependency<a id="_idIndexMarker159"/> function wired into <strong class="source-inline">APIRouter</strong> should apply defensive programming and a proper <strong class="source-inline">try-except</strong> to avoid parameter conflicts with the API services. If we were to run <strong class="source-inline">check_credential_error()</strong> with a <strong class="source-inline">list_all_user()</strong> service, for instance, expect some runtime problems because there is no <strong class="source-inline">login</strong> persistence involved during data retrieval.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Like its path operators, the constructor of <strong class="source-inline">APIRouter</strong> can also accept more than one injectable because its <strong class="source-inline">dependencies</strong> parameter will allow a <strong class="source-inline">List</strong> (<strong class="source-inline">[]</strong>) of valid ones.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>Dependency injection on main.py</h2>
			<p>There are<a id="_idIndexMarker160"/> portions of the software that are very hard to automate because of their vast and complex scopes, so considering them will always be a waste of time and effort. These <em class="italic">cross-cutting concerns</em> span from the UI level down to the data tier, which explains why these functionalities are impractical and even inconceivable to manage and implement using typical programming paradigms. These cross-cutting concerns are transactions such as <em class="italic">exception logging</em>, <em class="italic">caching</em>, <em class="italic">instrumentation</em>, and <em class="italic">user authorization</em>, common to any application.</p>
			<p>FastAPI has an easy remedy to address these <em class="italic">features</em>: to create them as injectables to the FastAPI instance of <strong class="source-inline">main.py</strong>: </p>
			<pre class="source-code">
from fastapi import Request
from uuid import uuid1
service_paths_log = dict()
<strong class="bold">def log_transaction(request: Request): </strong>
    service_paths_log[uuid1()] = <strong class="bold">request.url.path</strong></pre>
			<p>The preceding <strong class="source-inline">log_transaction()</strong> is a simple logger of the <strong class="source-inline">URL</strong> paths invoked or accessed by the client. While the application is running, this cross-cut should propagate the repository with different URLs coming from any <strong class="source-inline">APIRouter</strong>. This task can only happen when we<a id="_idIndexMarker161"/> inject this function through the FastAPI instance of <strong class="source-inline">main.py</strong>:</p>
			<pre class="source-code">
from fastapi import FastAPI, Depends
<strong class="bold">from api import recipes, users, posts, login, admin, </strong>
        <strong class="bold">keywords, admin_mcontainer, complaints</strong>
from dependencies.global_transactions import    
        log_transaction
app = FastAPI(<strong class="bold">dependencies=[Depends(log_transaction)]</strong>)
app.include_router(recipes.router, prefix="/ch03")
app.include_router(users.router, prefix="/ch03")
   … … … … … …
app.include_router(admin.router, prefix="/ch03")
app.include_router(keywords.router, prefix="/ch03")
app.include_router(admin_mcontainer.router, prefix="/ch03")
app.include_router(complaints.router, prefix="/ch03")</pre>
			<p>Dependencies <em class="italic">auto-wired</em> to the FastAPI constructor are known as <em class="italic">global dependencies</em> because they are accessible by any REST APIs from the routers. For instance, <strong class="source-inline">log_transaction()</strong>, depicted in the preceding script, will execute every time the APIs from the <strong class="source-inline">recipes</strong>, <strong class="source-inline">users</strong>, <strong class="source-inline">posts</strong>, or <strong class="source-inline">complaints</strong> routers process their respective<a id="_idIndexMarker162"/> request transactions.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Like <strong class="source-inline">APIRouter</strong>, the constructor of <strong class="source-inline">FastAPI</strong> allows more than function dependency.</p>
			<p>Aside from these <a id="_idIndexMarker163"/>strategies, DI can also help us organize our application by having <strong class="source-inline">repository</strong>, <strong class="source-inline">service</strong>, and <strong class="source-inline">model</strong> layers. </p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/>Organizing a project based on dependencies</h1>
			<p>It is feasible to <a id="_idIndexMarker164"/>use a <em class="italic">repository-service</em> pattern in some complex FastAPI applications through DI. The repository-service pattern is responsible for the creation <a id="_idIndexMarker165"/>of the <strong class="bold">repository layer</strong> of the application, which manages the Creation, Reading, Updates, and Deletion (CRUD) of data source. A repository layer<a id="_idIndexMarker166"/> requires <strong class="bold">data models</strong> that depict the table schemas of a collection or database. The repository layer needs <a id="_idIndexMarker167"/>the <strong class="bold">service layer</strong> to establish a connection with other parts of the application. The service layer operates like a business layer, where the data sources and business processes meet to derive all the necessary objects needed by the REST API. The communication between the repository and service layers can only be possible by creating injectables. Now, let us explore how the layers shown in <em class="italic">Figure 3.2</em> are built by DI using injectable components.</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/Figure_3.2_B17975.jpg" alt="Figure 3.2 – The repository-service layers"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – The repository-service layers</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/>The model layer</h2>
			<p>This layer is purely<a id="_idIndexMarker168"/> composed of <em class="italic">resources</em>, <em class="italic">collections</em>, and <em class="italic">Python classes</em> that<a id="_idIndexMarker169"/> can be used by the repository layer to create CRUD transactions. Some model classes are dependable on other models, but some are just independent blueprints designed for data placeholder. Some of the application’s model classes that store recipe-related details are shown here:</p>
			<pre class="source-code">
from uuid import UUID
from model.classifications import Category, Origin
from typing import Optional, List
class <strong class="bold">Ingredient</strong>:
    def __init__(self, id: UUID, name:str, qty : float,
               measure : str):
        self.id = id
        self.name = name
        self.qty = qty
        self.measure = measure
        
class <strong class="bold">Recipe</strong>:
    def __init__(self, id: UUID, name: str, 
           ingredients: List[Ingredient], cat: Category, 
             orig: Origin):
        self.id = id
        self.name = name
        self.ingredients = ingredients
        self.cat = cat
        self.orig = orig</pre>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor069"/>The repository layer</h2>
			<p>This layer is<a id="_idIndexMarker170"/> composed of class dependencies, which<a id="_idIndexMarker171"/> have access to the <em class="italic">data store</em> or improvised <strong class="source-inline">dict</strong> repositories, just like in our <em class="italic">online recipe system</em>. Together with the model layer, these repository classes build the CRUD transactions needed by the REST API. The following is an implementation of <strong class="source-inline">RecipeRepository</strong> that has two transactions, namely <strong class="source-inline">insert_recipe()</strong> and <strong class="source-inline">query_recipes()</strong>:</p>
			<pre class="source-code">
<strong class="bold">from model.recipes import Recipe</strong>
<strong class="bold">from model.recipes import Ingredient</strong>
<strong class="bold">from model.classifications import Category, Origin</strong>
from uuid import uuid1 
<strong class="bold">recipes = dict()</strong>
class RecipeRepository: 
    <strong class="bold">def __init__(self): </strong>
        ingrA1 = <strong class="bold">Ingredient</strong>(measure='cup', qty=1, 
             name='grape tomatoes', id=uuid1())
        ingrA2 = <strong class="bold">Ingredient</strong>(measure='teaspoon', qty=0.5, 
             name='salt', id=uuid1())
        ingrA3 = <strong class="bold">Ingredient</strong>(measure='pepper', qty=0.25, 
             name='pepper', id=uuid1())
        … … … … … …
        recipeA = <strong class="bold">Recipe</strong>(orig=Origin.european ,
         ingredients= [ingrA1, ingrA2, ingrA3, ingrA4, 
              ingrA5, ingrA6, ingrA7, ingrA8, ingrA9], 
         cat= Category.breakfast, 
         name='Crustless quiche bites with asparagus and 
               oven-dried tomatoes', 
         id=uuid1())
        ingrB1 = <strong class="bold">Ingredient</strong>(measure='tablespoon', qty=1, 
           name='oil', id=uuid1())
        ingrB2 = <strong class="bold">Ingredient</strong>(measure='cup', qty=0.5, 
           name='chopped tomatoes', id=uuid1())
        … … … … … …
        recipeB = <strong class="bold">Recipe</strong>(orig=Origin.carribean ,
           ingredients= [ingrB1, ingrB2, ingrB3, ingrB4, 
             ingrB5], 
           cat= Category.breakfast, 
           name='Fried eggs, Caribbean style', id=uuid1())
        ingrC1 = <strong class="bold">Ingredient</strong>(measure='pounds', qty=2.25, 
           name='sweet yellow onions', id=uuid1())
        ingrC2 = <strong class="bold">Ingredient</strong>(measure='cloves', qty=10, 
           name='garlic', id=uuid1())
        … … … … … …
        recipeC = <strong class="bold">Recipe</strong>(orig=Origin.mediterranean ,
          ingredients= [ingrC1, ingrC2, ingrC3, ingrC4, 
             ingrC5, ingrC6, ingrC7, ingrC8], 
          cat= Category.soup, 
          name='Creamy roasted onion soup', id=uuid1())
        
        <strong class="bold">recipes[recipeA.id] = recipeA</strong>
        <strong class="bold">recipes[recipeB.id] = recipeB</strong>
        <strong class="bold">recipes[recipeC.id] = recipeC</strong>
        
    <strong class="bold">def insert_recipe(self, recipe: Recipe):</strong>
        recipes[recipe.id] = recipe
  
    <strong class="bold">def query_recipes(self):</strong>
        return recipes</pre>
			<p>Its constructor is used to populate the recipes with some initial data. The constructor of an <em class="italic">injectable repository</em> class plays a role in datastore setup and configuration, and this is where we <em class="italic">auto-wire</em> dependency if there is any. Conversely, the implementation includes <a id="_idIndexMarker172"/>two <strong class="source-inline">Enum</strong> classes – <strong class="source-inline">Category</strong> and <strong class="source-inline">Origin</strong> – which <a id="_idIndexMarker173"/>provide lookup values to the recipe’s menu category and place of origin respectively.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>The repository factory methods</h2>
			<p>This layer<a id="_idIndexMarker174"/> uses the <em class="italic">factory design pattern</em> to<a id="_idIndexMarker175"/> add a more loose coupling design between the repository and service layer. Although this approach is optional, this is still an option to manage the threshold of interdependency between the two layers, especially when there are frequent changes in the performance, processes, and results of the CRUD transactions. The following are the repository factory methods used by our application:</p>
			<pre class="source-code">
def get_recipe_repo(<strong class="bold">repo=Depends(RecipeRepository)</strong>):
    return repo
def get_post_repo(<strong class="bold">repo=Depends(PostRepository)</strong>): 
    return repo
def get_users_repo(<strong class="bold">repo=Depends(AdminRepository)</strong>): 
    return repo
def get_keywords(<strong class="bold">keywords=Depends(KeywordRepository)</strong>): 
    return keywords
def get_bad_recipes(<strong class="bold">repo=Depends(BadRecipeRepository)</strong>): 
    return repo</pre>
			<p>We can see from the preceding script that <strong class="source-inline">RecipeRepository</strong> is a dependable object of the factory methods, which are also injectable components but of the service layer. For instance, <strong class="source-inline">get_recipe_repo()</strong> will be wired to a service class to pursue the implementation <a id="_idIndexMarker176"/>of native<a id="_idIndexMarker177"/> services that require some transactions from <strong class="source-inline">RecipeRepository</strong>. In a way, we are indirectly wiring the repository class to the service layer.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>The service layer</h2>
			<p>This layer has <a id="_idIndexMarker178"/>all the application’s services with the <a id="_idIndexMarker179"/>domain logic, such as our <strong class="source-inline">RecipeService</strong>, which provides business processes and algorithms to <strong class="source-inline">RecipeRepository</strong>. The <strong class="source-inline">get_recipe_repo()</strong> factory is injected through its constructor to provide CRUD transactions from <strong class="source-inline">RecipeRepository</strong>. The injection strategy used here is the function of class dependency, which is depicted in the following code:</p>
			<pre class="source-code">
from model.recipes import Recipe
<strong class="bold">from repository.factory import get_recipe_repo</strong>
class <strong class="bold">RecipeService</strong>: 
    def __init__(self, <strong class="bold">repo=Depends(get_recipe_repo)</strong>):
        <strong class="bold">self.repo = repo</strong>
        
    <strong class="bold">def get_recipes(self):</strong>
        return self.repo.query_recipes()
    
    <strong class="bold">def add_recipe(self, recipe: Recipe):</strong>
        self.repo.insert_recipe(recipe)</pre>
			<p>The constructor of a typical Python class is always the appropriate place to inject components, which <a id="_idIndexMarker180"/>can either be a function or class <a id="_idIndexMarker181"/>dependable. With the preceding <strong class="source-inline">RecipeService</strong>, its <strong class="source-inline">get_recipes()</strong> and <strong class="source-inline">add_recipe()</strong> are realized because of the transactions derived from <strong class="source-inline">get_recipe_repo()</strong>.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor072"/>The REST API and the service layer</h2>
			<p>The REST API<a id="_idIndexMarker182"/> methods can directly<a id="_idIndexMarker183"/> inject the<a id="_idIndexMarker184"/> service class <a id="_idIndexMarker185"/>or factory method if it needs to access the service layer. In our application, there is a factory method associated with each service class to apply the same strategy used in the <strong class="source-inline">RecipeRepository</strong> injection. That is why, in the following script, the <strong class="source-inline">get_recipe_service()</strong> method is wired to the REST API instead of <strong class="source-inline">RecipeService</strong>:</p>
			<pre class="source-code">
<strong class="bold">class IngredientReq(BaseModel):</strong>
    id: UUID 
    name:str
    qty: int
    measure: str
      
<strong class="bold">class RecipeReq(BaseModel):</strong>
    id: UUID 
    name: str
    <strong class="bold">ingredients: List[IngredientReq]</strong>
    cat: Category
    orig: Origin
     
router = APIRouter()
<strong class="bold">@router.post("/recipes/insert")</strong>
def insert_recipe(<strong class="bold">recipe: RecipeReq</strong>, 
            <strong class="bold">handler=Depends(get_recipe_service)</strong>): 
    json_dict = jsonable_encoder(recipe)
    rec = Recipe(**json_dict)
    handler.add_recipe(rec)
    return JSONResponse(content=json_dict, status_code=200)
<strong class="bold">@router.get("/recipes/list/all")</strong>
def get_all_recipes(<strong class="bold">handler=Depends(get_recipe_service)</strong>):
    return handler.get_recipes()</pre>
			<p>The <strong class="source-inline">insert_recipe()</strong> is a REST<a id="_idIndexMarker186"/> API<a id="_idIndexMarker187"/> that accepts a recipe and its ingredients from a client <a id="_idIndexMarker188"/>for <a id="_idIndexMarker189"/>persistency, while <strong class="source-inline">get_all_recipes()</strong> returns <strong class="source-inline">List[Recipe]</strong> as a response.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor073"/>The actual project structure</h2>
			<p>With the power<a id="_idIndexMarker190"/> of DI, we have created an <em class="italic">online recipe system</em> with an organized set of <em class="italic">models</em>, <em class="italic">repository</em>, and <em class="italic">service</em> layers. The project structure shown in <em class="italic">Figure 3.3</em> is quite different from the previous prototypes because of the additional layers, but it still has <strong class="source-inline">main.py</strong> and all the packages and modules with their respective <strong class="source-inline">APIRouter</strong>.</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/Figure_3.3_B17975.jpg" alt="Figure 3.3 – The Online Recipe System’s project structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – The Online Recipe System’s project structure</p>
			<p>At this point, DI has offered many advantages to FastAPI applications, from the engineering of object instantiation to breaking down monolithic components to set up loosely coupled structures. But there is only one slight problem: FastAPI’s default container. The framework’s container has no easy configuration to set all its managed objects to a <em class="italic">singleton</em> scope. Most applications prefer fetching singleton objects to avoid wasting memory in <a id="_idIndexMarker191"/>the <strong class="bold">Python Virtual Machine</strong> (<strong class="bold">PVM</strong>). Moreover, the built-in container is not open to a more detailed container configuration, such as having a <em class="italic">multiple container</em> setup. The next series of discussions will focus <a id="_idIndexMarker192"/>on the limitation of FastAPI’s default container and solutions to overcome it.  </p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>Using third-party containers</h1>
			<p>DI has a lot to offer to<a id="_idIndexMarker193"/> improve our application, but it still depends on the framework we use to get the full potential of this design pattern. FastAPI’s container is very acceptable to some when the concerns are simply on object management and project organization. However, when it comes to configuring the container to add more advanced features, it is not feasible for short-term projects, and it will be impossible for huge applications due to constraints. So, the practical way is to rely on <em class="italic">third-party modules</em> for the set of utilities needed to support all these advancements. So, let us explore these popular external modules that integrate seamlessly with FastAPI, the <em class="italic">Dependency Injector</em> and <em class="italic">Lagom</em>, which we can use to set up a complete and manageable container.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>Using configurable containers – Dependency Injector</h2>
			<p>When it comes <a id="_idIndexMarker194"/>to <a id="_idIndexMarker195"/>configurable containers, the <em class="italic">Dependency Injector</em> has several module APIs that can be used to build variations of custom containers that can manage, assemble, and inject objects. But before we can use this module, we need to install it first using <strong class="source-inline">pip</strong>:</p>
			<p class="source-code">pip install dependency-injector</p>
			<h3>The containers and providers module</h3>
			<p>Among all <a id="_idIndexMarker196"/>the <a id="_idIndexMarker197"/>API types, <em class="italic">Dependency Injector</em> is popular with its <em class="italic">containers</em> and <em class="italic">providers</em>. One of its container types is <strong class="source-inline">DeclarativeContainer</strong>, which can be subclassed to contain all its providers. Its providers can be <strong class="source-inline">Factory</strong>, <strong class="source-inline">Dict</strong>, <strong class="source-inline">List</strong>, <strong class="source-inline">Callable</strong>, <strong class="source-inline">Singleton</strong>, or other <em class="italic">containers</em>. Both the <strong class="source-inline">Dict</strong> and <strong class="source-inline">List</strong> providers are easy to set up because they only need <strong class="source-inline">list</strong> and <strong class="source-inline">dict</strong> respectively to be instantiated. A <strong class="source-inline">Factory</strong> provider, conversely, instantiates any class, such as a repository, service, or a generic Python class, while <strong class="source-inline">Singleton</strong> only creates one instance per class, which is valid throughout the application’s runtime. The <strong class="source-inline">Callable</strong> provider manages function dependencies, while <strong class="source-inline">Container</strong> instantiates other containers. Another container type is <strong class="source-inline">DynamicContainer</strong>, which is built from a configuration file, databases, or other resources.</p>
			<h3>The container types</h3>
			<p>Aside from these <a id="_idIndexMarker198"/>container APIs, the <em class="italic">Dependency Injector</em> allows us to customize a container based on the volume of the dependable objects, project structure, or other criteria from the project. The most common style or setup is the single declarative container that fits in small-, medium-, or large-scale applications. Our <em class="italic">o</em><em class="italic">nline recipe system </em>prototype owns a single declarative container, which is implemented in the following script:</p>
			<pre class="source-code">
<strong class="bold">from dependency_injector import containers, providers</strong>
from repository.users import login_details
from repository.login import LoginRepository
from repository.admin import AdminRepository
from repository.keywords import KeywordRepository
from service.recipe_utilities import get_recipe_names 
class Container(<strong class="bold">containers.DeclarativeContainer</strong>):
    <strong class="bold">loginservice = providers.Factory(LoginRepository)</strong>
    <strong class="bold">adminservice = providers.Singleton(AdminRepository)</strong>
    <strong class="bold">keywordservice = providers.Factory(KeywordRepository)</strong>
    <strong class="bold">recipe_util = providers.Callable(get_recipe_names) </strong>
    <strong class="bold">login_repo = providers.Dict(login_details)</strong></pre>
			<p>By simply subclassing <strong class="source-inline">DeclarativeContainer</strong>, we can easily create a single container, with its instances injected by the various providers previously mentioned. <strong class="source-inline">LoginRepository</strong> and <strong class="source-inline">KeywordRepository</strong> are both injected as new instances through the Factory <a id="_idIndexMarker199"/>provider. <strong class="source-inline">AdminRepository</strong> is an injected singleton object, <strong class="source-inline">get_recipe_names()</strong> is an injected function dependable, and <strong class="source-inline">login_details</strong> is an injected dictionary containing login credentials.</p>
			<h3>FastAPI and Dependency Injector integration</h3>
			<p>To wire <a id="_idIndexMarker200"/>the dependencies to a component through the Dependency Injector, the <strong class="source-inline">@inject</strong> decorator is applied. <strong class="source-inline">@inject</strong> is imported from the <strong class="source-inline">dependency_injector.wiring</strong> module and is decorated over the <em class="italic">dependent</em> component. </p>
			<p>Afterward, the instance will be fetched from the container using the <strong class="source-inline">Provide</strong> wiring marker. Wiring markers search for the <strong class="source-inline">Provider</strong> object that references the injectable in the container, and if it exists, it will prepare for <em class="italic">auto-wiring</em>. Both <strong class="source-inline">@inject</strong> and <strong class="source-inline">Provide</strong> belong to the same API module:</p>
			<pre class="source-code">
from repository.keywords import KeywordRepository
<strong class="bold">from containers.single_container import Container</strong>
<strong class="bold">from dependency_injector.wiring import inject, Provide</strong>
from uuid import UUID
router = APIRouter()
@router.post("/keyword/insert")
<strong class="bold">@inject</strong>
def insert_recipe_keywords(*keywords: str, 
         <strong class="bold">keywordservice: KeywordRepository = </strong>
           <strong class="bold">Depends(Provide[Container.keywordservice])</strong>): 
    if keywords != None:
        keywords_list = list(keywords)
        keywordservice.insert_keywords(keywords_list)
        return JSONResponse(content={"message": 
          "inserted recipe keywords"}, status_code=201)
    else:
        return JSONResponse(content={"message": 
          "invalid operation"}, status_code=403)</pre>
			<p>The integration<a id="_idIndexMarker201"/> happens when the <strong class="source-inline">Depends()</strong> function directive is invoked to register the wiring marker and the <strong class="source-inline">Provider</strong> instance to FastAPI. Aside from the acknowledgment, the registration adds <em class="italic">type hints</em> and <em class="italic">Pydantic validation rules</em> to the third-party <strong class="source-inline">Provider</strong> to appropriately wire the injectables into FastAPI. The preceding script imports <strong class="source-inline">Container</strong> from its module to wire <strong class="source-inline">KeywordRepository</strong> through <strong class="source-inline">@inject</strong>, the wire marker, and the <strong class="source-inline">keywordservice</strong> <strong class="source-inline">Provider</strong> of <em class="italic">Dependency Injector</em>.</p>
			<p>Now, the last piece of the puzzle is to <em class="italic">assemble</em>, <em class="italic">create</em>, and <em class="italic">deploy</em> the single declarative container through the FastAPI platform. This last integration measure requires instantiating the <em class="italic">container</em> inside the module where the injections happened and then invoking its <strong class="source-inline">wire()</strong> method, which builds the assemblage. Since the preceding <strong class="source-inline">insert_recipe_keywords()</strong> is part of <strong class="source-inline">/api/keywords.py</strong>, we should add the <a id="_idIndexMarker202"/>following lines in the <strong class="source-inline">keywords</strong> module script, particularly at its end portion:</p>
			<pre class="source-code">
import sys
… … … … …
<strong class="bold">container = Container()</strong>
<strong class="bold">container.wire(modules=[sys.modules[__name__]])</strong></pre>
			<h3>The multiple container setup</h3>
			<p>For large<a id="_idIndexMarker203"/> applications, the number of repository transactions and services increases based on the functionality and special features of the application. If the single declarative type becomes unfeasible for a growing application, then we can always replace it with a <em class="italic">multiple-container </em>setup.</p>
			<p>Dependency Injector allows us to create a separate container for each group of services. Our application has created a sample setup found in <strong class="source-inline">/containers/multiple_containers.py</strong>, just in case this prototype becomes full-blown. That sample of multiple declarative containers is shown as follows:</p>
			<pre class="source-code">
from dependency_injector import containers, providers
from repository.login import <strong class="bold">LoginRepository</strong>
from repository.admin import <strong class="bold">AdminRepository</strong>
from repository.keywords import <strong class="bold">KeywordRepository</strong>
class <strong class="bold">KeywordsContainer</strong>(containers.DeclarativeContainer): 
    keywordservice = providers.Factory(<strong class="bold">KeywordRepository</strong>)
    … … … … …
class <strong class="bold">AdminContainer</strong>(containers.DeclarativeContainer): 
    adminservice = providers.Singleton(<strong class="bold">AdminRepository</strong>)
    … … … … …
class <strong class="bold">LoginContainer</strong>(containers.DeclarativeContainer): 
    loginservice = providers.Factory(<strong class="bold">LoginRepository</strong>)
    … … … … …
    
class <strong class="bold">RecipeAppContainer</strong>(containers.DeclarativeContainer): 
    keywordcontainer = 
          providers.Container(<strong class="bold">KeywordsContainer</strong>)
    admincontainer = providers.Container(<strong class="bold">AdminContainer</strong>)
    logincontainer = providers.Container(<strong class="bold">LoginContainer</strong>)
    … … … … …</pre>
			<p>Based on the preceding configuration, the three different instances of <strong class="source-inline">DeclarativeContainer</strong> created are <strong class="source-inline">KeywordsContainer</strong>, <strong class="source-inline">AdminContainer</strong>, and <strong class="source-inline">LoginContainer</strong>. The <strong class="source-inline">KeywordsContainer</strong> instance will assemble all<a id="_idIndexMarker204"/> dependencies related to keywords, <strong class="source-inline">AdminContainer</strong> will hold all instances related to administrative tasks, and <strong class="source-inline">LoginContainer</strong> for login- and user-related services. Then, there is <strong class="source-inline">RecipeAppContainer</strong>, which will consolidate all these containers through DI also.</p>
			<p>The injection of the dependencies to the API is like the single declarative style, except that the container needs to be indicated in the wiring marker. The following is an admin-related API that shows how we wire dependencies to REST services:</p>
			<pre class="source-code">
<strong class="bold">from dependency_injector.wiring import inject, Provide</strong>
from repository.admin import <strong class="bold">AdminRepository</strong>
from containers.multiple_containers import 
         <strong class="bold">RecipeAppContainer</strong>
    
router = APIRouter()
@router.get("/admin/logs/visitors/list")
<strong class="bold">@inject</strong>
def list_logs_visitors(<strong class="bold">adminservice: AdminRepository =</strong>    
   <strong class="bold">Depends(</strong>
     <strong class="bold">Provide[</strong>
      <strong class="bold">RecipeAppContainer.admincontainer.adminservice])</strong>): 
    logs_visitors_json = jsonable_encoder(
           adminservice.query_logs_visitor())
    return logs_visitors_json</pre>
			<p>The presence of <strong class="source-inline">admincontainer</strong> inside <strong class="source-inline">Provide</strong> checks first for the container of the same name before it fetches the <strong class="source-inline">adminservice</strong> provider that references the service<a id="_idIndexMarker205"/> dependable. The rest of the details are just the same with a single declarative, including the FastAPI integration and object assembly.</p>
			<p>What is highlighted here about <em class="italic">Dependency Injector</em> is just basic configurations for simple applications. There are still other features and integrations that this module can provide to optimize our application using DI. Now, if we need thread-safe and non-blocking but with simple, streamlined, and straightforward APIs, setup and configuration, there is the <em class="italic">Lagom</em> module.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/>Using a simple configuration – Lagom</h2>
			<p>The third-party <em class="italic">Lagom</em> module <a id="_idIndexMarker206"/>is widely used because of its simplicity when it comes to wiring dependables. It is also ideal for building asynchronous microservice-driven applications because it is thread-safe at runtime. Moreover, it can easily integrate into many web frameworks, including FastAPI. To apply its APIs, we <a id="_idIndexMarker207"/>need to install it first using <strong class="source-inline">pip</strong>:</p>
			<p class="source-code">pip install lagom</p>
			<h3>The container</h3>
			<p>Containers in <em class="italic">Lagom</em> are created <a id="_idIndexMarker208"/>instantly using the <strong class="source-inline">Container</strong> class from its module. Unlike in <em class="italic">Dependency Injector</em>, Lagom’s containers are created before the injection happens inside the module of the REST APIs:</p>
			<pre class="source-code">
from lagom import Container
from repository.complaints import BadRecipeRepository
<strong class="bold">container = Container()</strong>
<strong class="bold">container[BadRecipeRepository] = BadRecipeRepository()</strong>
router = APIRouter()</pre>
			<p>All dependables are injected into the container through typical instantiation. The container behaves like a <strong class="source-inline">dict</strong> when adding new dependables because it also uses a <em class="italic">key-value pair</em> as an entry. When we inject an object, the container needs its class name as its <em class="italic">key</em> and the instance as its <em class="italic">value</em>. Moreover, the DI framework also allows instantiation with arguments if the constructors require some parameter values.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/>The FastAPI and Lagom integration</h2>
			<p>Before the <a id="_idIndexMarker209"/>wiring happens, integration to the FastAPI platform must come first by instantiating a new API class called <strong class="source-inline">FastApiIntegration</strong>, which is found in the <strong class="source-inline">lagom.integrations.fast_api</strong> module. It takes <strong class="source-inline">container</strong> as a required parameter:</p>
			<pre class="source-code">
from lagom.integrations.fast_api import FastApiIntegration
<strong class="bold">deps = FastApiIntegration(container)</strong></pre>
			<h3>The dependables</h3>
			<p>The instance of <strong class="source-inline">FastAPIIntegration</strong> has a <strong class="source-inline">depends()</strong> method, which we will use to perform the injection. One of the best features of Lagom is its easy and seamless integration mechanism into any framework. Thus, wiring the dependencies will not need FastAPI’s <strong class="source-inline">Depends()</strong> function anymore:</p>
			<pre class="source-code">
@router.post("/complaint/recipe")
def report_recipe(rid: UUID, 
     <strong class="bold">complaintservice=deps.depends(BadRecipeRepository)</strong>): 
        complaintservice.add_bad_recipe(rid)
        return JSONResponse(content={"message": 
           "reported bad recipe"}, status_code=201)</pre>
			<p>The preceding <strong class="source-inline">report_recipe()</strong> utilizes <strong class="source-inline">BadRecipeRepository</strong> as an injectable service. Since it is part of the container, <em class="italic">Lagom</em>’s <strong class="source-inline">depends()</strong> function will search for the object in the container, and then it will be wired to the API service, if that exists, to save the complaints to the <strong class="source-inline">dict</strong> datastore.</p>
			<p>So far, these two third-party modules are the most popular and elaborative when employing DI in our applications. These modules may change through future updates, but one thing is for sure: IoC and DI design patterns will always be the powerful solution in managing memory usage in an application. Let us now discusses issues surrounding memory space, container, and object assembly.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/>Scoping of dependables</h1>
			<p>In FastAPI, the scope of dependables <a id="_idIndexMarker210"/>can be either a new instance or a singleton. FastAPI’s DI does not support the creation of singleton objects by default. In every execution of an API service with dependencies, FastAPI always fetches a new instance of each wired dependable, which can be proven by getting the <em class="italic">object ID</em> using <strong class="source-inline">id()</strong>.</p>
			<p>A <strong class="source-inline">singleton</strong> object is created only once by a container, no matter how many times the framework injects it. Its <em class="italic">object ID</em> remains the same the entire runtime of the application. Services and repository classes are preferred to be singleton to control the increase of memory utilization of the application. And since it is not easy to create a singleton with FastAPI, we can use either <em class="italic">Dependency Injector</em> or <em class="italic">Lagom</em>.</p>
			<p>There is a <strong class="source-inline">Singleton</strong> provider in Dependency Injector that is responsible for the creation of singleton dependencies. This provider was mentioned already during the discussions on its <strong class="source-inline">DeclarativeContainer</strong> setup. With Lagom, there are two ways to create singleton injectables: (a) using its <strong class="source-inline">Singleton</strong> class, and (b) through the constructor of <strong class="source-inline">FastAPIIntegration</strong>. </p>
			<p>The <strong class="source-inline">Singleton</strong> class wraps the instance of the dependency before injecting it into the container. The following sample snippet shows one example:</p>
			<pre class="source-code">
container = Container()
container[BadRecipeRepository] = 
         <strong class="bold">Singleton(BadRecipeRepository())</strong></pre>
			<p>The other way is to declare the dependency in the <strong class="source-inline">request_singletons</strong> parameter of the constructor of <strong class="source-inline">FastAPIIntegration</strong>. The following snippet shows how it is done:</p>
			<pre class="source-code">
container = Container()
container[BadRecipeRepository] = BadRecipeRepository()
deps = FastApiIntegration(container,
      <strong class="bold">request_singletons=[BadRecipeRepository]</strong>)</pre>
			<p>By the way, the <strong class="source-inline">request_singletons</strong> parameter is a <strong class="source-inline">List</strong> type, so it will allow us to declare at <a id="_idIndexMarker211"/>least one dependable when we want to make singletons.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor079"/>Summary</h1>
			<p>One aspect that makes a framework easy and practical to use is its support for the IoC principle. FastAPI has a built-in container that we can utilize to establish dependency among components. The use of a <em class="italic">DI</em> pattern to integrate all these components through wiring is a strong prerequisite in building microservice-driven applications. From simple injection using <strong class="source-inline">Depends()</strong>, we can extend DI to build pluggable components for database integration, authentication, security, and unit testing.</p>
			<p>This chapter also introduced some third-party modules such as <em class="italic">Dependency Injector</em> and <em class="italic">Lagom</em> that can design and customize containers. Because of the limitations of FastAPI on DI, there are external libraries that can help extend its responsibility to assemble, control, and manage object creation in a container. These third-party APIs can also create singleton objects, which can help decrease the heap size in the PVM.  </p>
			<p>Aside from performance tuning and memory management, DI can contribute to the organization of a project, especially huge applications. The addition of model, repository, and service layers is a remarkable effect of creating dependencies. Injection opens the development to other design patterns, such as factory method, service, and data access object patterns. In the next chapter, we will start to build some microservice-related components based on the core design patterns of microservices.</p>
		</div>
		<div>
			<div id="_idContainer021">
			</div>
		</div>
	</body></html>