<html><head></head><body>
		<div><h1 id="_idParaDest-314" class="chapter-number"><a id="_idTextAnchor388"/>8</h1>
			<h1 id="_idParaDest-315"><a id="_idTextAnchor389"/>Advanced Server-Side Development Techniques</h1>
			<p>In <a href="B20997_05.xhtml#_idTextAnchor238"><em class="italic">Chapter 5</em></a>, <em class="italic">Basic Server-Side Development</em>, you learned how to write methods for a model class, how to extend methods from inherited models, and how to work with record sets. This chapter will deal with more advanced topics, such as working with the environment of a record set, calling a method upon a button click, and working with <code>onchange</code> methods. The recipes in this chapter will help you manage more complex business problems. You will learn how to create an understanding by incorporating visual elements and clarifying the process of creating interactive features within Odoo’s application development process.</p>
			<p>In this chapter, we will look at the following recipes:</p>
			<ul>
				<li>Changing the user that performs an action</li>
				<li>Calling a method with a modified context</li>
				<li>Executing raw SQL queries</li>
				<li>Writing a wizard to guide the user</li>
				<li>Defining <code>onchange</code> methods</li>
				<li>Calling <code>onchange</code> methods on the server side</li>
				<li>Defining <code>onchange</code> with the <code>compute</code> method</li>
				<li>Defining a model based on a SQL view</li>
				<li>Adding custom Settings options</li>
				<li>Implementing <code>init</code> hooks</li>
			</ul>
			<h1 id="_idParaDest-316"><a id="_idTextAnchor390"/>Technical requirements</h1>
			<p>For this chapter, you’ll require the Odoo online platform.</p>
			<p>All the code used in this chapter can be downloaded from this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter08">https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter08</a>.</p>
			<h1 id="_idParaDest-317"><a id="_idTextAnchor391"/>Changing the user that performs an action</h1>
			<p>When writing business logic<a id="_idIndexMarker481"/> code, you may have to perform some actions with a different security context. A typical case is performing an action with <code>superuser</code> rights, bypassing security checks. Such a requirement arises when business requirements necessitate operating on records for which users do not have security access rights.</p>
			<p>This recipe will show you how to allow normal users to create the <code>room</code> record by using <code>sudo()</code>. Put simply, we will allow users to create <code>room</code> by themselves, even if they do not have the right to create a assign the <code>room</code> record.</p>
			<h2 id="_idParaDest-318"><a id="_idTextAnchor392"/>Getting ready</h2>
			<p>For easier understanding, we will add a new model to manage the hostel room. We will add a new model called <code>hostel.student</code>. You can refer to the following definition to add this model:</p>
			<pre class="source-code">
class HostelStudent(models.Model):
   _name = "hostel.student"
   _description = "Hostel Student Information"
   name = fields.Char("Student Name")
   gender = fields.Selection([("male", "Male"),
       ("female", "Female"), ("other", "Other")],
       string="Gender", help="Student gender")
   active = fields.Boolean("Active", default=True,
       help="Activate/Deactivate hostel record")
   hostel_id = fields.Many2one("hostel.hostel", "hostel", help="Name of hostel")
   room_id = fields.Many2one("hostel.room", "Room",
       help="Select hostel room")
   status = fields.Selection([("draft", "Draft"),
       ("reservation", "Reservation"), ("pending", "Pending"),
       ("paid", "Done"),("discharge", "Discharge"), ("cancel", "Cancel")],
       string="Status", copy=False, default="draft",
       help="State of the student hostel")
   admission_date = fields.Date("Admission Date",
       help="Date of admission in hostel",
       default=fields.Datetime.today)
   discharge_date = fields.Date("Discharge Date",
       help="Date on which student discharge")
   duration = fields.Integer("Duration", compute="_compute_check_duration", inverse="_inverse_duration",
                              help="Enter duration of living")</pre>			<p>You will <a id="_idIndexMarker482"/>need to add a form view, an action, and a menu item to see this new model from the user interface. You will also need to add security rules for the hostel so that they can issue the hostel student. Please refer to <a href="B20997_03.xhtml#_idTextAnchor083"><em class="italic">Chapter 3</em></a>, <em class="italic">Creating Odoo Add-On Modules</em>, if you don’t know how to add these things.</p>
			<p>Alternatively, you can use the ready-made initial module from our GitHub code examples to save time. This module is available in the <code>Chapter08/00_initial_module</code> folder. The GitHub code examples are available at <a href="https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter08/00_initial_module">https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter08/00_initial_module</a>.</p>
			<h2 id="_idParaDest-319"><a id="_idTextAnchor393"/>How to do it...</h2>
			<p>If you have tested <a id="_idIndexMarker483"/>the module, you will find that only users who have <code>hostel.room</code> access rights can mark a room as a manager. Non-hostel users cannot create a room by themselves; they need to ask a manager user:</p>
			<ol>
				<li>This user has <strong class="bold">Hostel Manager</strong> access rights, which means they can create <strong class="bold">Hostel </strong><strong class="bold">Room</strong> records:</li>
			</ol>
			<div><div><img src="img/B20997_08_1.jpg" alt="Figure 8.1 – This user has Hostel Manager access rights"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – This user has Hostel Manager access rights</p>
			<p class="list-inset">As shown in the following screenshot, <strong class="bold">Hostel Manager</strong> can also create room records:</p>
			<div><div><img src="img/B20997_08_2.jpg" alt="Figure 8.2 – Hostel Manager can create room records"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Hostel Manager can create room records</p>
			<ol>
				<li value="2">This <a id="_idIndexMarker484"/>user has <strong class="bold">Hostel User</strong> access rights:</li>
			</ol>
			<div><div><img src="img/B20997_08_2.jpg" alt="Figure 8.3 – This user has Hostel User access rights"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – This user has Hostel User access rights</p>
			<p class="list-inset">They can only see <strong class="bold">Hostel </strong><strong class="bold">Room</strong> records:</p>
			<div><div><img src="img/B20997_08_4.jpg" alt="Figure 8.4 – Hostel User can see only Hostel Room records"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Hostel User can see only Hostel Room records</p>
			<p class="list-inset">Suppose that we want to add a new feature so that non-hostel users can create a room by themselves, for themselves. We will do this without giving them the access rights for the <code>hostel.room</code> model.</p>
			<p class="list-inset">So, let’s learn <a id="_idIndexMarker485"/>how to let normal hostel users student.</p>
			<ol>
				<li value="3">Add the <code>action_assign_room()</code> method to the <code>hostel.room</code> model:<pre class="source-code">
class HostelStudent(models.Model):
   _name = "hostel.student"
    ...
    def action_assign_room(self):</pre></li>				<li>In the method, ensure that we are acting on a single record:<pre class="source-code">
self.ensure_one()</pre></li>				<li>Raise a warning if a student is not paid (make sure you have imported <code>UserError</code> at the top):<pre class="source-code">
if self.status != "paid":
           raise UserError(_("You can't assign a room if it's not paid."))</pre></li>				<li>Get the empty recordset of <code>hostel.room</code> as a superuser:<pre class="source-code">
room_as_superuser = self.env['hostel.room'].sudo()</pre></li>				<li>Create a new <code>room</code> record with the appropriate values:<pre class="source-code">
room_rec = room_as_superuser.create({
           "name": "Room A-103",
           "room_no": "A-103",
           "floor_no": 1,
           "room_category_id": self.env.ref("my_hostel.single_room_categ").id,
           "hostel_id": self.hostel_id.id,
       })</pre></li>				<li>To trigger<a id="_idIndexMarker486"/> this method from the user interface, add the button to the student form view:<pre class="source-code">
&lt;button name="action_assign_room"
                           string="Assign Room"
                           type="object"
                           class="btn-primary"
                       /&gt;</pre></li>				<li>Restart the server and update <code>my_hostel</code> to apply the given changes. After the update, you will see an <strong class="bold">Assign Room</strong> button on the student form view, as shown here:</li>
			</ol>
			<div><div><img src="img/B20997_08_5.jpg" alt="Figure 8.5 – The Assign Room button on the student form view"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – The Assign Room button on the student form view</p>
			<p>When you click on that, a new room record will be created. This will also work for non-hostel users. You can test this by accessing Odoo as a demo user.</p>
			<h2 id="_idParaDest-320"><a id="_idTextAnchor394"/>How it works...</h2>
			<p>In the first three steps, we added a <a id="_idIndexMarker487"/>new method called <code>action_assign_room()</code>. This method will be called when the user clicks on the <strong class="bold">Assign Room</strong> button on the student form view.</p>
			<p>In <em class="italic">Step 4</em>, we used <code>sudo()</code>. This method returns a new recordset with a modified <code>environment</code> in which the user has <code>superuser</code> rights. When <code>recordset</code> is called with <code>sudo()</code>, the environment will modify the <code>environment</code> attribute to <code>su</code>, which indicates the <code>superuser</code> state of the environment. You can access its status via <code>recordset.env.su</code>. All method calls through this <code>sudo</code> recordset are made with superuser privileges. To get a better idea of this, remove <code>.sudo()</code> from the method and then click on the <code>Access Error</code> and the user will no longer have access to the model. Simply using <code>sudo()</code> will bypass all security rules.</p>
			<p>If you need a specific user, you can pass a recordset containing either that user or the database ID of the user, as follows:</p>
			<pre class="source-code">
public_user = self.env.ref('base.public_user')
hostel_room = self.env['hostel.room'].with_user(public_user)
hostel_room.search([('name', 'ilike', 'Room 101')])</pre>			<p>This code snippet allows you to search for rooms that are visible using the <code>public</code> user.</p>
			<h2 id="_idParaDest-321"><a id="_idTextAnchor395"/>There’s more...</h2>
			<p>Using <code>sudo()</code>, you can bypass the access rights and security record rules. Sometimes, you can access multiple records that are meant to be isolated, such as records from different companies in multi-company environments. The <code>sudo()</code> recordset bypasses all the security rules of Odoo.</p>
			<p>If you are not careful, records that are searched for in this environment may be linked to any company present in the database, which means that you may be leaking information to a user; worse, you may be silently corrupting the database by linking records that belong to different companies.</p>
			<p>When using <code>sudo()</code>, exercise caution<a id="_idIndexMarker488"/> to avoid unintended consequences, such as inadvertently linking records from different companies. Ensure proper data segregation and consider the potential impact on data integrity and security rules before bypassing access rights.</p>
			<p class="callout-heading">Important tip</p>
			<p class="callout">When using <code>sudo()</code>, always double-check to ensure that your calls to <code>search()</code> do not rely on the standard record rules to filter the results.</p>
			<p class="callout">Without using <code>sudo()</code>, <code>search()</code> calls would respect standard record rules, potentially restricting access to records based on user permissions. This could lead to incomplete or inaccurate search results, affecting data visibility and application functionality.</p>
			<h2 id="_idParaDest-322"><a id="_idTextAnchor396"/>See also</h2>
			<p>Check out these references for more information:</p>
			<ul>
				<li>If you want to learn more about environments, refer to the <em class="italic">Obtaining an empty recordset for a model</em> recipe in <a href="B20997_05.xhtml#_idTextAnchor238"><em class="italic">Chapter 5</em></a>, <em class="italic">Basic </em><em class="italic">Server-Side Development</em></li>
				<li>For more information about access control lists and record rules, check out <a href="B20997_10.xhtml#_idTextAnchor549"><em class="italic">Chapter 10</em></a>, <em class="italic">Security Access</em></li>
			</ul>
			<h1 id="_idParaDest-323"><a id="_idTextAnchor397"/>Calling a method with a modified context</h1>
			<p><code>context</code> is part of the<a id="_idIndexMarker489"/> environment of a recordset. It is used to pass extra information, such as the time zone and the language of the user, from the user interface. You <a id="_idIndexMarker490"/>can also use the context to pass the parameters specified in the actions. Several methods in the standard Odoo add-ons use the context to adapt their business logic based on these context values. It is sometimes necessary to modify the context on a <code>recordset</code> value to get the desired results from a method call or the desired value for a computed field.</p>
			<p>This recipe will show you how to change the behavior of a method based on values in the environmental context.</p>
			<h2 id="_idParaDest-324"><a id="_idTextAnchor398"/>Getting ready</h2>
			<p>For this<a id="_idIndexMarker491"/> recipe, we will use the <code>my_hostel</code> module from the previous recipe. On the form view of the <code>hostel.room</code> model, we will add a button to remove room members. If a regular resident of a hostel removes other occupants from their assigned room without permission or authorization, it could create disruptions and issues within the accommodation. Note that we already have the same button in the form view of the room, but here, we will explore context usage in Odoo, gaining insights into how it influences system operations and outcomes.</p>
			<h2 id="_idParaDest-325"><a id="_idTextAnchor399"/>How to do it...</h2>
			<p>To add a button, you need to perform the following steps:</p>
			<ol>
				<li>Add a <code>hostel.room</code>:<pre class="source-code">
&lt;button name="action_remove_room_members"
                           string="Remove Room Members"
                           type="object"
                           class="btn-primary"
                       /&gt;</pre></li>				<li>Add the <code>action_remove_room_members()</code> method to the <code>hostel.room</code> model:<pre class="source-code">
def action_remove_room_members(self):
   ...</pre></li>				<li>Add the following code to the method to change the context of the environment and call the method to remove the room members:<pre class="source-code">
student.with_context(is_hostel_room=True).action_remove_room()</pre></li>				<li>Update <a id="_idIndexMarker492"/>the <code>action_remove_room()</code> method of the <code>hostel.student </code>model so that a different behavior is exhibited:<pre class="source-code">
def action_remove_room(self):
       if self.env.context.get("is_hostel_room"):
           self.room_id = False</pre></li>			</ol>
			<h2 id="_idParaDest-326"><a id="_idTextAnchor400"/>How it works…</h2>
			<p>In Odoo, to modify behavior influenced by context, we did the following:</p>
			<ol>
				<li>Identified the target behavior.</li>
				<li>Defined the contextual parameters.</li>
				<li>Adapted the relevant code sections.</li>
				<li>Tested the changes thoroughly.</li>
				<li>Ensured compatibility across modules.</li>
			</ol>
			<p>In <em class="italic">Step 1</em>, we removed the room members.</p>
			<p>In <em class="italic">Step 2</em>, we added a new button, <strong class="bold">Remove Room Members</strong>. The user will use this button to <strong class="bold">Remove </strong><strong class="bold">the Members</strong>.</p>
			<p>In <em class="italic">Steps 3</em> and <em class="italic">4</em>, we added a method that will be called when the user clicks on the <strong class="bold">Remove Room </strong><strong class="bold">Members</strong> button.</p>
			<p>In <em class="italic">Step 5</em>, we called <code>student.with_context()</code> with some keyword arguments. This returns a new version of the <code>room_id</code> recordset with an updated context. We are adding one key to the context here, <code>is_hostel_room=True</code>, but you can add multiple keys if you want. We used <code>sudo()</code> here.</p>
			<p>In <em class="italic">Step 6</em>, we checked whether the context had a positive value for the <code>is_hostel_room</code> key.</p>
			<p>Now, when<a id="_idIndexMarker493"/> the hostel room removes room members in the student form view, the <code>room</code> recordset is <code>False</code>.</p>
			<p>This is just a simple example of a modified context, but you can use any method, such as <code>create()</code>, <code>write()</code>, <code>unlink()</code>, and so on. You can also use any custom method based on your requirements.</p>
			<h2 id="_idParaDest-327"><a id="_idTextAnchor401"/>There’s more...</h2>
			<p>It is also possible to pass a dictionary to <code>with_context()</code>. In this case, the dictionary is used as the new context, which overwrites the current one. So, <em class="italic">Step 5</em> can also be written as follows:</p>
			<pre class="source-code">
new_context = self.env.context.copy()
new_context.update({'is_hostel_room': True})
student.with_context(new_context)</pre>			<h2 id="_idParaDest-328"><a id="_idTextAnchor402"/>See also</h2>
			<p>Refer to the following recipes to learn more about contexts in Odoo:</p>
			<ul>
				<li>The <em class="italic">Obtaining an empty recordset for a model</em> recipe in <a href="B20997_05.xhtml#_idTextAnchor238"><em class="italic">Chapter 5</em></a>, <em class="italic">Basic Server-Side Development</em>, explains what the environment is</li>
				<li>The <em class="italic">Passing parameters to forms and actions – context</em> recipe in <a href="B20997_09.xhtml#_idTextAnchor446"><em class="italic">Chapter 9</em></a>, <em class="italic">Backend Views</em>, explains how to modify the context in action definitions</li>
				<li>The <em class="italic">Search for records</em> recipe in <a href="B20997_05.xhtml#_idTextAnchor238"><em class="italic">Chapter 5</em></a>, <em class="italic">Basic Server-Side Development</em>, explains active records</li>
			</ul>
			<h1 id="_idParaDest-329"><a id="_idTextAnchor403"/>Executing raw SQL queries</h1>
			<p>Most of the <a id="_idIndexMarker494"/>time, you can perform the operations you want by using Odoo’s ORM – for example, you can use the <code>search()</code> method to fetch records. However, sometimes, you need more; either you cannot express what you want using the domain syntax (for which some operations are tricky, if not downright impossible) or your query requires several calls to <code>search()</code>, which ends up being inefficient.</p>
			<p>This recipe<a id="_idIndexMarker495"/> shows you how to use raw SQL queries to get the name and amount a user keeps in a particular room.</p>
			<h2 id="_idParaDest-330"><a id="_idTextAnchor404"/>Getting ready</h2>
			<p>For this recipe, we will use the <code>my_hostel</code> module from the previous recipe. For simplicity, we will just print the results in a log, but in real scenarios, you will need to use the query result in your business logic. In <a href="B20997_09.xhtml#_idTextAnchor446"><em class="italic">Chapter 9</em></a>, <em class="italic">Backend Views</em>, we will display the result of this query in the user interface.</p>
			<h2 id="_idParaDest-331"><a id="_idTextAnchor405"/>How to do it...</h2>
			<p>To get information about the name and amount a user keeps in a particular room, you need to perform the following steps:</p>
			<ol>
				<li>Add the <code>action_category_with_amount()</code> method to <code>hostel.room</code>:<pre class="source-code">
def action_category_with_amount(self):
    ...</pre></li>				<li>In the method, write the following SQL query:<pre class="source-code">
"""
           SELECT
               hrc.name,
               hrc.amount
           FROM
               hostel_room AS hostel_room
           JOIN
               hostel_room_category as hrc ON hrc.id = hostel_room.room_category_id
           WHERE hostel_room.room_category_id = %(cate_id)s;""",
           {'cate_id': self.room_category_id.id}</pre></li>				<li>Execute the query:<pre class="source-code">
self.env.cr.execute("""
           SELECT
               hrc.name,
               hrc.amount
           FROM
               hostel_room AS hostel_room
           JOIN
               hostel_room_category as hrc ON hrc.id = hostel_room.room_category_id
           WHERE hostel_room.room_category_id = %(cate_id)s;""",
           {'cate_id': self.room_category_id.id})</pre></li>				<li>Fetch the<a id="_idIndexMarker496"/> result and log it (make sure you have imported <code>logger</code>):<pre class="source-code">
result = self.env.cr.fetchall()
       _logger.warning("Hostel Room With Amount: %s", result)</pre></li>				<li>Add a button in the form view of the <code>hostel.room</code> mode to trigger our method:<pre class="source-code">
&lt;button name="action_category_with_amount"
                           string="Log Category With Amount"
                           type="object"
                           class="btn-primary"/&gt;</pre></li>			</ol>
			<p>Don’t forget to import <code>logger</code> in this file. Then, restart and update the <code>my_hostel</code> module.</p>
			<h2 id="_idParaDest-332"><a id="_idTextAnchor406"/>How it works...</h2>
			<p>In <em class="italic">Step 1</em>, we <a id="_idIndexMarker497"/>added the <code>action_category_with_amount()</code> method, which will be called when the user clicks on the <strong class="bold">Log Category With </strong><strong class="bold">Amount.</strong> button.</p>
			<p>In <em class="italic">Step 2</em>, we declared a SQL <strong class="bold">SELECT</strong> query. This will return the category that states the amount in a hostel room. If you run this query in the PostgreSQL CLI, you will get a result based on your room data. Here is the sample date based on my database:</p>
			<pre class="console">
+---------------------------------------+-------+
| name                                  | amount|
|---------------------------------------+-------|
| Single Room                           | 3000  |
+---------------------------------------+-------+</pre>			<p>In <em class="italic">Step 4</em>, we called the <code>execute()</code> method on the database cursor stored in <code>self.env.cr</code>. This sends the query to PostgreSQL and executes it.</p>
			<p>In <em class="italic">Step 5</em>, we used the <code>fetchall()</code> method of the cursor to retrieve a list of rows selected by the query. This method returns a list of rows. In my case, this is <code>[('Single Room', 3000)]</code>. From the form of the query we execute, we know that each row will have exactly two values, the first being <code>name</code> and the other being the amount a user holds in a particular room. Then, we simply log it.</p>
			<p>In <em class="italic">step 6</em>, we added an <code>Add</code> button to handle user actions.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">If you are executing an <code>UPDATE</code> query, you need to manually invalidate the cache since Odoo ORM’s cache is unaware of the changes you made with the <code>UPDATE</code> query. To invalidate the cache, you can use <code>self.invalidate_cache()</code>.</p>
			<h2 id="_idParaDest-333"><a id="_idTextAnchor407"/>There’s more...</h2>
			<p>The object in <code>self.env.cr</code> is a thin <a id="_idIndexMarker498"/>wrapper around a <code>psycopg2</code> cursor. The following methods are the ones that you will want to use most of the time:</p>
			<ul>
				<li><code>execute(query, params)</code>: This executes the SQL query with the parameters marked as <code>%s</code> in the query substituted with the values in <code>params</code>, which is a tuple</li>
			</ul>
			<p class="callout-heading">Warning</p>
			<p class="callout">Never do the substitution yourself; always use formatting options such as <code>%s</code>. If you use a technique such as string concatenation, it can make the code vulnerable to SQL injection.</p>
			<ul>
				<li><code>fetchone()</code>: This returns one row from the database, wrapped in a tuple (even if only one column has been selected by the query)</li>
				<li><code>fetchall()</code>: This returns all the rows from the database as a list of tuples</li>
				<li><code>dictfetchall()</code>: This returns all the rows from the database as a list of dictionaries mapping column names to values</li>
			</ul>
			<p>Be very careful when dealing with raw SQL queries:</p>
			<ul>
				<li>You are bypassing all the security of the application. Ensure that you call <code>search([('id', 'in', tuple(ids)])</code> with any list of IDs you are retrieving to filter out records to which the user has no access.</li>
				<li>Any modifications you are making are bypassing the constraints set by the add-on modules, except the <code>NOT NULL</code>, <code>UNIQUE</code>, and <code>FOREIGN KEY</code> constraints, which are enforced at the database level. This is also the case for any computed field recomputation triggers, so you may end up corrupting the database.</li>
				<li>Avoid the <code>INSERT/UPDATE</code> query – inserting or updating records via queries will not run any business logic written by overriding the <code>create()</code> and <code>write()</code> methods. It will not update stored compute fields and the ORM constraints will be bypassed too.</li>
			</ul>
			<h2 id="_idParaDest-334"><a id="_idTextAnchor408"/>See also</h2>
			<p>For access rights management, refer to <a href="B20997_10.xhtml#_idTextAnchor549"><em class="italic">Chapter 10</em></a>, <em class="italic">Security Access</em>.</p>
			<h1 id="_idParaDest-335"><a id="_idTextAnchor409"/>Writing a wizard to guide the user</h1>
			<p>In the <em class="italic">Using abstract models for reusable model features</em> recipe in <a href="B20997_04.xhtml#_idTextAnchor118"><em class="italic">Chapter 4</em></a>, <em class="italic">Application Models</em>, the <code>models.TransientModel</code> base class was introduced. This class has a lot in common with normal models, except that the records of transient models are <a id="_idIndexMarker499"/>periodically cleaned up in the database, hence the name transient. These are used to create wizards or dialogue boxes, which are filled in the user interface by the users and are generally used to perform actions on the persistent records of the database.</p>
			<h2 id="_idParaDest-336"><a id="_idTextAnchor410"/>Getting ready</h2>
			<p>For this recipe, we will use the <code>my_hostel</code> module from the previous recipes. This recipe will add a new wizard. With this wizard, the user will be assigned the room.</p>
			<h2 id="_idParaDest-337"><a id="_idTextAnchor411"/>How to do it...</h2>
			<p>Follow these  steps to add a new wizard for updating the assign room and hostel records:</p>
			<ol>
				<li>Add a new transient model to the module with the following definition:<pre class="source-code">
class AssignRoomStudentWizard(models.TransientModel):
   _name = 'assign.room.student.wizard'
   room_id = fields.Many2one("hostel.room", "Room", required=True)</pre></li>				<li>Add the <code>callback</code> method that performs the action on the transient model. Add the<a id="_idIndexMarker500"/> following code to the <code>AssignRoomStudentWizard</code> class:<pre class="source-code">
def add_room_in_student(self):
       hostel_room_student = self.env['hostel.student'].browse(
           self.env.context.get('active_id'))
       if hostel_room_student:
           hostel_room_student.update({
               'hostel_id': self.room_id.hostel_id.id,
               'room_id': self.room_id.id,
               'admission_date': datetime.today(),
           })</pre></li>				<li>Create a form view for the model. Add the following view definition to the module views:<pre class="source-code">
&lt;record id='assign_room_student_wizard_form' model='ir.ui.view'&gt;
   &lt;field name='name'&gt;assign room student wizard form view&lt;/field&gt;
   &lt;field name='model'&gt;assign.room.student.wizard&lt;/field&gt;
   &lt;field name='arch' type='xml'&gt;
       &lt;form string="Assign Room"&gt;
           &lt;sheet&gt;
               &lt;group&gt;
                   &lt;field name='room_id'/&gt;
               &lt;/group&gt;
           &lt;/sheet&gt;
           &lt;footer&gt;
               &lt;button string='Update' name='add_room_in_student' class='btn-primary' type='object'/&gt;
               &lt;button string='Cancel' class='btn-default' special='cancel'/&gt;
           &lt;/footer&gt;
       &lt;/form&gt;
   &lt;/field&gt;
&lt;/record&gt;</pre></li>				<li>Create an <a id="_idIndexMarker501"/>action and a menu entry to display the wizard. Add the following declarations to the module menu file:<pre class="source-code">
&lt;record model="ir.actions.act_window" id="action_assign_room_student_wizard"&gt;
   &lt;field name="name"&gt;Assign Room&lt;/field&gt;
   &lt;field name="res_model"&gt;assign.room.student.wizard&lt;/field&gt;
   &lt;field name="view_mode"&gt;form&lt;/field&gt;
   &lt;field name="target"&gt;new&lt;/field&gt;
&lt;/record&gt;</pre></li>				<li>Add access rights for <code>assign.room.student.wizard</code> in the <code>ir.model.access.csv</code> file:<pre class="source-code">
access_assign_room_student_wizard_manager,access.assign.room.student.wizard.manager,model_assign_room_student_wizard,my_hostel.group_hostel_manager,1,1,1,1</pre></li>				<li>Update the <code>my_hostel</code> module to apply the changes.</li>
			</ol>
			<h2 id="_idParaDest-338"><a id="_idTextAnchor412"/>How it works...</h2>
			<p>In <em class="italic">Step 1</em>, we defined a new model. It is no different from other models, apart from the base class, which is <code>TransientModel</code> instead of <code>Model</code>. Both <code>TransientModel</code> and <code>Model</code> share a common base class, called <code>BaseModel</code>, and if you check the source code of Odoo, you will see that 99% of the work is in <code>BaseModel</code> and that both <code>Model</code> and <code>TransientModel</code> are almost empty.</p>
			<p>The only things <a id="_idIndexMarker502"/>that change for the <code>TransientModel</code> records are as follows:</p>
			<ul>
				<li>Records are periodically removed from the database so that the tables for transient models do not grow over time</li>
				<li>You are not allowed to define <code>one2many</code> fields on a <code>TransientModel</code> instance that refers to a normal model as this will add a column on the persistent model that links to transient data</li>
			</ul>
			<p>Use <em class="italic">many2many</em> relations in this case. You can, of course, use <em class="italic">one2many</em> fields if the related model in <em class="italic">one2many</em> is also <code>TransientModel</code>.</p>
			<p>We define one field in the model for storing the room. We can add other scalar fields so that we can record a scheduled return date, for instance.</p>
			<p>In <em class="italic">Step 2</em>, we added the code to the wizard class that will be called when the button defined in <em class="italic">Step 3</em> is clicked on. This code reads the values from the wizard and updates the <code>hostel.student</code> record.</p>
			<p>In <em class="italic">Step 3</em>, we defined a view for our wizard. Refer to the <em class="italic">Document-style forms</em> recipe in <a href="B20997_09.xhtml#_idTextAnchor446"><em class="italic">Chapter 9</em></a>, <em class="italic">Backend Views</em>, for details. The important point here is the button in the footer; the <code>type</code> attribute is set to <code>'object'</code>, which means that when the user clicks on the button, the method with the name specified by the name attribute of the button will be called.</p>
			<p>In <em class="italic">Step 4</em>, we ensured that we had an entry point for our wizard in the menu of the application. We use <code>target='new'</code> in the action so that the form view is displayed as a dialogue box over the current form. Refer to the <em class="italic">Adding a menu item and window action</em> recipe in <a href="B20997_09.xhtml#_idTextAnchor446"><em class="italic">Chapter 9</em></a>, <em class="italic">Backend Views</em>, for details:</p>
			<div><div><img src="img/B20997_08_6.jpg" alt="Figure 8.6 – Wizard for assigning a room to a student"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Wizard for assigning a room to a student</p>
			<p>In <em class="italic">Step 5</em>, we added<a id="_idIndexMarker503"/> access rights for the <code>assign.room.student.wizard</code> model. With this, the manager user will get full rights to the <code>assign.room.student.wizard</code> model.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Before Odoo v14, <code>TransientModel</code> didn’t require any access rules. Anyone can create a record, and they can only access records created by themselves. With Odoo v14, access rights are compulsory for <code>TransientModel</code>.</p>
			<h2 id="_idParaDest-339"><a id="_idTextAnchor413"/>There’s more...</h2>
			<p>Here are some tips to enhance your wizards.</p>
			<h3>Using the context to compute default values</h3>
			<p>The<a id="_idIndexMarker504"/> wizard we are presenting requires the user to fill in the name of the member in the form. There is a feature of the web client that we can<a id="_idIndexMarker505"/> use to save some typing. When an action is executed, <code>context</code> is updated with some values that can be used by wizards:</p>
			<ul>
				<li><code>active_model</code>: This is the name of the model related to the action. This is generally the model being displayed onscreen.</li>
				<li><code>active_id</code>: This indicates that a single record is active and provides the ID of that record.</li>
				<li><code>active_ids</code>: If several records are selected, this will be a list containing the IDs. This happens when several items are selected in a tree view when the action is triggered. In a form view, you get <code>[active_id]</code>.</li>
				<li><code>active_domain</code>: This is an additional domain on which the wizard will operate.</li>
			</ul>
			<p>These values can be used to compute the default values of the model or even directly in the method<a id="_idIndexMarker506"/> called by the button. To improve on the example<a id="_idIndexMarker507"/> in this recipe, if we had a button displayed on the form view of a <code>hostel.room</code> model to launch the wizard, the context of the creation of the wizard would contain <code>{'active_model': 'hostel.room', 'active_id': &lt;hostel_room_id&gt;}</code>. In that case, you could define the <code>room_id</code> field to get a default value computed by the following method:</p>
			<pre class="source-code">
def _default_member(self):
    if self.context.get('active_model') == 'hostel.room':
        return self.context.get('active_id', False)</pre>			<h3>Wizards and code reuse</h3>
			<p>In <em class="italic">Step 2</em>, we <a id="_idIndexMarker508"/>can add <code>self.ensure_one()</code> at the beginning of the method, as follows:</p>
			<pre class="source-code">
def add_room_in_student(self):
       hostel_room_student = self.env['hostel.student'].browse(
           self.env.context.get('active_id'))
       if hostel_room_student:
           hostel_room_student.update({
               'hostel_id': self.room_id.hostel_id.id,
               'room_id': self.room_id.id,
               'admission_date': datetime.today(),
           })</pre>			<p>We recommend using v17 in this recipe. It will allow us to reuse the wizard from other parts of the code by creating records for the wizard and putting them in a single recordset (refer to the <em class="italic">Combining recordsets</em> recipe in <a href="B20997_05.xhtml#_idTextAnchor238"><em class="italic">Chapter 5</em></a>, <em class="italic">Basic Server-Side Development</em>, to see how to do this) before calling <code>add_room_in_student()</code> on the recordset. Here, the code is trivial, and you don’t need to jump through all those hoops to record that some rooms have been assigned by different students. However, in an Odoo<a id="_idIndexMarker509"/> instance, some operations are much more complex, and it is always nice to have a wizard available that does the right thing. When using these wizards, ensure that you check the source code for any possible use of the <code>active_model/active_id/active_ids</code> keys from the context. If this is the case, you need to pass a custom context (refer to the <em class="italic">Calling a method with a modified </em><em class="italic">context</em> recipe).</p>
			<h2 id="_idParaDest-340"><a id="_idTextAnchor414"/>Redirecting the user</h2>
			<p>The <a id="_idIndexMarker510"/>method in <em class="italic">Step 2</em> doesn’t return anything. This will cause the wizard dialogue to be closed after the action is performed. Another possibility is to have the method return a dictionary with the fields of <code>ir.action</code>. In this case, the web client will process the action as if a menu entry had been clicked on by the user. The <code>get_formview_action()</code> method defined in the <code>BaseModel</code> class can be used to achieve this. For instance, if we wanted to display the form view of the hostel room, we could have written the following:</p>
			<pre class="source-code">
def add_room_in_student(self):
       hostel_room_student = self.env['hostel.student'].browse(
           self.env.context.get('active_id'))
       if hostel_room_student:
           hostel_room_student.update({
               'hostel_id': self.room_id.hostel_id.id,
               'room_id': self.room_id.id,
               'admission_date': datetime.today(),
           })
       rooms = self.mapped('room_id')
       action = rooms.get_formview_action()
       if len(rooms.ids) &gt; 1:
           action['domain'] = [('id', 'in', tuple(rooms.ids))]
           action['view_mode'] = 'tree,form'
       return action</pre>			<p>This <a id="_idIndexMarker511"/>builds a list of rooms that have rooms from this wizard (in practice, there will only be one such room when the wizard is called from the user interface) and creates a dynamic action, which displays the room with the specified IDs.</p>
			<p>The <em class="italic">redirecting the user</em> technique can be used to create a wizard that must perform several steps one after the other. Each step in the wizard can use the values of the previous steps by providing a <strong class="bold">Next</strong> button. This will call a method defined on the wizard that updates some fields on the wizard, returns an action that will redisplay the same updated wizard, and gets ready for the next step.</p>
			<h2 id="_idParaDest-341"><a id="_idTextAnchor415"/>See also</h2>
			<p>Please refer to the following recipes for more details:</p>
			<ul>
				<li>Refer to the <em class="italic">Document-style forms</em> recipe in <a href="B20997_09.xhtml#_idTextAnchor446"><em class="italic">Chapter 9</em></a>, <em class="italic">Backend Views</em>, for more details on defining a view for a wizard</li>
				<li>To understand more about views and calling server-side methods, refer to the <em class="italic">Adding a menu item and window action</em> recipe in <a href="B20997_09.xhtml#_idTextAnchor446"><em class="italic">Chapter 9</em></a>, <em class="italic">Backend Views</em></li>
				<li>For more details on creating records for the wizard and putting them in a single recordset, refer to the <em class="italic">Combining recordsets</em> recipe in <a href="B20997_05.xhtml#_idTextAnchor238"><em class="italic">Chapter 5</em></a>, <em class="italic">Basic </em><em class="italic">Server-Side Development</em></li>
			</ul>
			<h1 id="_idParaDest-342"><a id="_idTextAnchor416"/>Defining onchange methods</h1>
			<p>When <a id="_idIndexMarker512"/>writing business logic, it is often the case that some fields are interrelated. We looked at how to specify constraints between fields in the <em class="italic">Adding constraint validations to a model</em> recipe in <a href="B20997_04.xhtml#_idTextAnchor118"><em class="italic">Chapter 4</em></a>, <em class="italic">Application Models</em>. This recipe illustrates a slightly different concept. Here, <code>onchange</code> methods are called when a field is modified in the user interface to update the values of other fields of the record in the web client, usually in a form view.</p>
			<p>We will illustrate this by providing a wizard similar to the one defined in the <em class="italic">Writing a wizard to guide the user</em> recipe, but that can be used to record duration returns. When a date is set in the form view, the duration is updated for the student. While we are demonstrating <code>onchange</code> methods on <code>Model</code>, these features are also available on normal <code>Transient</code> models.</p>
			<h2 id="_idParaDest-343"><a id="_idTextAnchor417"/>Getting ready</h2>
			<p>For this recipe, we<a id="_idIndexMarker513"/> will use the <code>my_hostel</code> module from the <em class="italic">Writing a form to guide the user</em> recipe of this chapter. We will create a hostel student and add an <code>onchange</code> method that will auto-fill the duration when a user selects a discharge date or admission date field.</p>
			<p>You will also want to prepare your work by defining the following model for the form view:</p>
			<pre class="source-code">
class HostelStudent(models.Model):
   _name = "hostel.student"
   _description = "Hostel Student Information"
   admission_date = fields.Date("Admission Date",
       help="Date of admission in hostel",
       default=fields.Datetime.today)
   discharge_date = fields.Date("Discharge Date",
       help="Date on which student discharge")
   duration = fields.Integer("Duration",          inverse="_inverse_duration",help="Enter duration of living")</pre>			<p>Finally, you will need to define a view. These steps will be left as an exercise for you to carry out.</p>
			<h2 id="_idParaDest-344"><a id="_idTextAnchor418"/>How to do it...</h2>
			<p>To automatically populate<a id="_idIndexMarker514"/> the duration to return when the user is changed, you need to add an <code>onchange</code> method in the <code>HostelStudent</code> step, with the following definition:</p>
			<pre class="source-code">
   @api.onchange('admission_date', 'discharge_date')
   def onchange_duration(self):
       if self.discharge_date and self.admission_date:
           self.duration = (self.discharge_date.year - \
                           self.admission_date.year) * 12 + \
                           (self.discharge_date.month - \
                           self.admission_date.month)</pre>			<h2 id="_idParaDest-345"><a id="_idTextAnchor419"/>How it works...</h2>
			<p>An <code>onchange</code> method uses the <code>@api.onchange</code> decorator, which is passed the names of the fields that change and will thus trigger the call to the method. In our case, we say that whenever <code>admission_date</code> or <code>discharge_date</code> is modified in the user interface, the method must be called.</p>
			<p>In the body of the method, we calculated the duration, and we used an attribute assignment to update the <code>duration</code> attribute of the from view.</p>
			<h2 id="_idParaDest-346"><a id="_idTextAnchor420"/>There’s more...</h2>
			<p>As we have seen in this recipe, the basic use of <code>onchange</code> methods is to compute new values for fields when some other fields are changed in the user interface.</p>
			<p>Inside the body of the method, you get access to the fields that are displayed in the current view of the record, but not necessarily all the fields of the model. This is because <code>onchange</code> methods can be called while the record is being created in the user interface before it is stored in the database! Inside an <code>onchange</code> method, <code>self</code> is in a special state, denoted by the fact that <code>self.id</code> is not an integer, but an instance of <code>odoo.models.NewId</code>. Therefore, you must not make any changes to the database in an <code>onchange</code> method since the user may end up canceling the creation of the record, which will not roll back any changes made by the <code>onchange</code> method during the process of editing.</p>
			<h1 id="_idParaDest-347"><a id="_idTextAnchor421"/>Calling onchange methods on the server side</h1>
			<p>The <code>onchange</code> method <a id="_idIndexMarker515"/>has a limitation: it will not be invoked when you are performing operations on the server side. <code>onchange</code> is only invoked automatically when the dependent operations are performed through the Odoo user interface. Yet, in several cases, these <code>onchange</code> methods must be called because they update important fields in the created or updated record. Of course, you can do the required computation yourself, but this is not always possible since the <code>onchange</code> method can be added or modified by a third-party add-on module that’s been installed on the instance that you don’t know about.</p>
			<p>This recipe explains how to call the <code>onchange</code> methods on a record by manually invoking the <code>onchange</code> method before creating a record.</p>
			<h2 id="_idParaDest-348"><a id="_idTextAnchor422"/>Getting ready</h2>
			<p>In the <em class="italic">Changing the user that performs an action</em> recipe, we added a <strong class="bold">Return Room</strong> button so that users can update the room and hostel by themselves. We now want to do the same for returning the room and hostel; we will just use the <strong class="bold">Assign Room</strong> return wizard.</p>
			<h2 id="_idParaDest-349"><a id="_idTextAnchor423"/>How to do it...</h2>
			<p>In this recipe, we will manually update a record of the <code>hostel.room</code> model. To do this, you need to perform the following steps:</p>
			<ol>
				<li>Import <code>Form</code> from the <code>tests</code> utility in the <code>hostel.student.py</code> file:<pre class="source-code">
from odoo.tests.common import Form</pre></li>				<li>Create the <code>return_room</code> method in the <code>hostel.room</code> model:<pre class="source-code">
def return_room(self):
    self.ensure_one()</pre></li>				<li>Get an empty recordset for <code>assign.room.student.wizard</code>:<pre class="source-code">
wizard = self.env['assign.room.student.wizard']</pre></li>				<li>Create a <a id="_idIndexMarker516"/>wizard <code>Form</code> block, like this:<pre class="source-code">
with Form(wizard) as return_form:</pre></li>				<li>Trigger <code>onchange</code> by assigning a room and then return the updated value of <code>room_id</code>:<pre class="source-code">
return_form.room_id = self.env.ref('my_hostel.101_room')
       record = return_form.save()                            record.with_context(active_id=self.id).add_room_in_student()</pre></li>			</ol>
			<h2 id="_idParaDest-350"><a id="_idTextAnchor424"/>How it works...</h2>
			<p>For an explanation of <em class="italic">Steps 1</em> to <em class="italic">3</em>, refer to the <em class="italic">Creating new records</em> recipe in <a href="B20997_05.xhtml#_idTextAnchor238"><em class="italic">Chapter 5</em></a>, <em class="italic">Basic </em><em class="italic">Server-Side Development</em>.</p>
			<p>In <em class="italic">Step 4</em>, we created a virtual form to handle onchange specifications, such as the GUI.</p>
			<p><em class="italic">Step 5</em> contains the full logic to return the room and hostel. In the first line, we assigned <code>room_id</code> in the wizard. Then, we called the <code>save()</code> method of the form, which returned a wizard record. After that, we called the <code>add_room_in_student()</code> method to execute the logic to return the updated room and hostel.</p>
			<p>The <code>onchange</code> method is mostly invoked from the user interface. But in this recipe, we have learned how to use/trigger the business logic of the <code>onchange</code> method on the server side. This way, we can create records without bypassing any business logic.</p>
			<h2 id="_idParaDest-351"><a id="_idTextAnchor425"/>See also</h2>
			<p>If you want to learn more about creating and updating records, refer to the <em class="italic">Creating new records</em> and <em class="italic">Updating the values of recordset records</em> recipes in <a href="B20997_05.xhtml#_idTextAnchor238"><em class="italic">Chapter 5</em></a>, <em class="italic">Basic </em><em class="italic">Server-Side Development</em>.</p>
			<h1 id="_idParaDest-352"><a id="_idTextAnchor426"/>Defining onchange with the compute method</h1>
			<p>In the <a id="_idIndexMarker517"/>last two recipes, we saw how to define and call the <code>onchange</code> method. We also saw its limitation, which is that it can only<a id="_idIndexMarker518"/> be invoked automatically from the user interface. As a solution to this problem, Odoo v13 introduced a new way to define <code>onchange</code> behavior. In this recipe, we will learn how to use the <code>compute</code> method to produce behavior similar to that of the <code>onchange</code> method.</p>
			<h2 id="_idParaDest-353"><a id="_idTextAnchor427"/>Getting ready</h2>
			<p>For this recipe, we will use the <code>my_hostel</code> module from the previous recipe. We will replace the <code>onchange</code> method of <code>hostel.student</code> with the <code>compute</code> method.</p>
			<h2 id="_idParaDest-354"><a id="_idTextAnchor428"/>How to do it...</h2>
			<p>Follow these steps to modify the <code>onchange</code> method with the <code>compute</code> method:</p>
			<ol>
				<li>Replace <code>api.onchange</code> in the <code>onchange_duration()</code> method with <code>depends</code>, like this:<pre class="source-code">
@api.depends('admission_date', 'discharge_date')
 def onchange_duration(self):
        ...</pre></li>				<li>Add the <code>compute</code> parameter in the definition of the field, like this:<pre class="source-code">
duration = fields.Integer("Duration", compute="onchange_duration", inverse="_inverse_duration",
                              help="Enter duration of living")</pre></li>			</ol>
			<p>Upgrade the <code>my_hostel</code> module to apply the code, then test the return duration form to see the change.</p>
			<h2 id="_idParaDest-355"><a id="_idTextAnchor429"/>How it works...</h2>
			<p>Functionally, our computed <code>onchange</code> works like the normal <code>onchange</code> method. The only<a id="_idIndexMarker519"/> difference is<a id="_idIndexMarker520"/> that now, <code>onchange</code> will be trigged upon backend changes too.</p>
			<p>In <em class="italic">Step 1</em>, we replaced <code>@api.onchange</code> with <code>@api.depends</code>. This is required to recompute the method when the field value changes.</p>
			<p>In <em class="italic">Step 2</em>, we registered the <code>compute</code> method with the field. As you may have noticed, we used <code>readonly=False</code> with the <code>compute</code> field definition. By default, <code>compute</code> methods are read-only, but by setting <code>readonly=False</code>, we are making sure that the field is editable and can be stored.</p>
			<h2 id="_idParaDest-356"><a id="_idTextAnchor430"/>See also</h2>
			<p>To learn more about computed fields, refer to the <em class="italic">Adding computed fields to a model</em> recipe in <a href="B20997_04.xhtml#_idTextAnchor118"><em class="italic">Chapter 4</em></a>, <em class="italic">Application Models</em>.</p>
			<h1 id="_idParaDest-357"><a id="_idTextAnchor431"/>Defining a model based on a SQL view</h1>
			<p>When<a id="_idIndexMarker521"/> working on the design of an <em class="italic">add-on</em> module, we model the data in classes that are then mapped to database tables by Odoo’s ORM. We apply some well-known design principles, such as <em class="italic">separation of concerns</em> and <em class="italic">data normalization</em>. However, at later stages of the module design, it can be useful to aggregate data from several models in a single table and to maybe perform some operations on them on the way, especially for reporting or producing dashboards. To make this easier, and to make use of the full power of the underlying <code>PostgreSQL</code> database engine in Odoo, it is possible to define a read-only model backed by a PostgreSQL view, rather than a table.</p>
			<p>In this recipe, we will reuse the room model from the <em class="italic">Writing a wizard to guide the user</em> recipe in this chapter, and we will create a new model to make it easier to gather availability about rooms and authors.</p>
			<h2 id="_idParaDest-358"><a id="_idTextAnchor432"/>Getting ready</h2>
			<p>For this recipe, we<a id="_idIndexMarker522"/> will use the <code>my_hostel</code> module from the previous recipe. We will create a new model called <code>hostel.room.availability</code> to hold the availability data.</p>
			<h2 id="_idParaDest-359"><a id="_idTextAnchor433"/>How to do it...</h2>
			<p>To create a new model backed by a PostgreSQL view, follow these steps:</p>
			<ol>
				<li>Create a new model with the <code>_auto</code> class attribute set to <code>False</code>:<pre class="source-code">
class HostelRoomAvailability(models.Model):
   _name = 'hostel.room.availability'
   _auto = False</pre></li>				<li>Declare the fields you want to see in the model, setting them as <code>readonly</code>:<pre class="source-code">
room_id = fields.Many2one('hostel.room', 'Room', readonly=True)
student_per_room = fields.Integer(string="Student Per Rooom",                   readonly=True)
availability = fields.Integer(string="Availability",readonly=True)
amount = fields.Integer(string="Amount", readonly=True)</pre></li>				<li>Define the <code>init()</code> method to create the view:<pre class="source-code">
def init(self):
       tools.drop_view_if_exists(self.env.cr, self._table)
       query = """
       CREATE OR REPLACE VIEW hostel_room_availability AS (
       SELECT
               min(h_room.id) as id,
               h_room.id as room_id,
               h_room.student_per_room as student_per_room,
               h_room.availability as availability,
               h_room.rent_amount as amount
           FROM
               hostel_room AS h_room
           GROUP BY h_room.id
       );
       """
       self.env.cr.execute(query)</pre></li>				<li>You can <a id="_idIndexMarker523"/>now define views for the new model. A pivot view is especially useful to explore data (refer to <a href="B20997_09.xhtml#_idTextAnchor446"><em class="italic">Chapter 9</em></a>, <em class="italic">Backend Views</em>).</li>
				<li>Don’t forget to define some access rules for the new model (take a look at <a href="B20997_10.xhtml#_idTextAnchor549"><em class="italic">Chapter 10</em></a>, <em class="italic">Security Access</em>).</li>
			</ol>
			<h2 id="_idParaDest-360"><a id="_idTextAnchor434"/>How it works...</h2>
			<p>Normally, Odoo will create a new table for the model you are defining by using the field definitions for the columns. This is because, in the <code>BaseModel</code> class, the <code>_auto</code> attribute defaults to <code>True</code>. In <em class="italic">Step 1</em>, by setting this class attribute to <code>False</code>, we tell Odoo that we will manage this by ourselves.</p>
			<p>In <em class="italic">Step 2</em>, we defined some fields that will be used by Odoo to generate a table. We took care to flag them as <code>readonly=True</code> so that the views do not enable modifications that you will not be able to save since PostgreSQL views are read-only.</p>
			<p>In <em class="italic">Step 3</em>, we defined the <code>init()</code> method. This method normally does nothing; it is called after <code>_auto_init()</code> (which is responsible for table creation when <code>_auto = True</code> but<a id="_idIndexMarker524"/> does nothing otherwise), and we use it to create a new SQL view (or to update the existing view in the case of a module upgrade). The view creation query must create a view with column names that match the field names of the model.</p>
			<p class="callout-heading">Important tip</p>
			<p class="callout">It is a common mistake to forget to rename the columns in the view definition query. This will cause an error message when Odoo cannot find the column.</p>
			<p>Note that we also need to provide an <code>integer column</code> value called <code>ID</code> that contains unique values.</p>
			<h2 id="_idParaDest-361"><a id="_idTextAnchor435"/>There’s more...</h2>
			<p>It is also possible to have some computed and related fields on such models. The only restriction is that the fields cannot be stored (and therefore, you cannot use them to group records or search).</p>
			<p>If you need to group by base user, you need to store the field by adding it to the view definition, rather than using a related field.</p>
			<h2 id="_idParaDest-362"><a id="_idTextAnchor436"/>See also</h2>
			<p>To learn more, take a look at the following recipes:</p>
			<ul>
				<li>To learn more about UI views for user actions, refer to <a href="B20997_09.xhtml#_idTextAnchor446"><em class="italic">Chapter 9</em></a>, <em class="italic">Backend Views</em></li>
				<li>For a better understanding of access control and record rules, take a look at <a href="B20997_10.xhtml#_idTextAnchor549"><em class="italic">Chapter 10</em></a>, <em class="italic">Security Access</em></li>
			</ul>
			<h1 id="_idParaDest-363"><a id="_idTextAnchor437"/>Adding custom Settings options</h1>
			<p>In Odoo, you<a id="_idIndexMarker525"/> can provide optional features through the <strong class="bold">Settings</strong> options. The user can enable or disable this option at any time. We will illustrate how to create <strong class="bold">Settings</strong> options in this recipe.</p>
			<h2 id="_idParaDest-364"><a id="_idTextAnchor438"/>Getting ready</h2>
			<p>In previous recipes, we added buttons so that hostel users can click and return rooms. This is not the case for every hostel; however, we will create a <code>my_hostel</code> module from the previous recipes.</p>
			<h2 id="_idParaDest-365"><a id="_idTextAnchor439"/>How to do it...</h2>
			<p>To create custom <strong class="bold">Settings</strong> options, follow these steps:</p>
			<ol>
				<li>Add a new field by inheriting the <code>res.config.settings</code> model:<pre class="source-code">
class ResConfigSettings(models.TransientModel):
   _inherit = 'res.config.settings'
   group_hostel_user = fields.Boolean(string="Hostel User", implied_group='my_hostel.group_hostel_user')</pre></li>				<li>Add this field to the existing <code>xpath</code> (for more details, refer to <a href="B20997_09.xhtml#_idTextAnchor446"><em class="italic">Chapter 9</em></a>, <em class="italic">Backend Views</em>):<pre class="source-code">
&lt;record id="res_config_settings_view_form" model="ir.ui.view"&gt;
       &lt;field name="name"&gt;res.config.settings.view.form.inherit.hostel&lt;/field&gt;
       &lt;field name="model"&gt;res.config.settings&lt;/field&gt;
       &lt;field name="priority" eval="5"/&gt;
       &lt;field name="inherit_id" ref="base.res_config_settings_view_form"/&gt;
       &lt;field name="arch" type="xml"&gt;
           &lt;xpath expr="//div[hasclass('settings')]" position="inside"&gt;
               &lt;div class="app_settings_block" data-string="Hostel" string="Hostel" data-key="my_hostel" groups="my_hostel.group_hostel_manager"&gt;
                   &lt;h2&gt;Hostel&lt;/h2&gt;
                   &lt;div class="row mt16 o_settings_container"&gt;
                       &lt;div class="col-12 col-lg-6 o_setting_box" id="hostel"&gt;
                           &lt;div class="o_setting_left_pane"&gt;
                               &lt;field name="group_hostel_user"/&gt;
                           &lt;/div&gt;
                           &lt;div class="o_setting_right_pane"&gt;
                               &lt;label for="group_hostel_user"/&gt;
                               &lt;div class="text-muted"&gt;
                                   Allow users to hostel user
                               &lt;/div&gt;
                           &lt;/div&gt;
                       &lt;/div&gt;
                   &lt;/div&gt;
               &lt;/div&gt;
           &lt;/xpath&gt;
       &lt;/field&gt;
   &lt;/record&gt;</pre></li>				<li>Add some actions<a id="_idIndexMarker526"/> and a menu for <strong class="bold">Settings</strong>:<pre class="source-code">
&lt;record id="hostel_config_settings_action" model="ir.actions.act_window"&gt;
       &lt;field name="name"&gt;Settings&lt;/field&gt;
       &lt;field name="type"&gt;ir.actions.act_window&lt;/field&gt;
       &lt;field name="res_model"&gt;res.config.settings&lt;/field&gt;
       &lt;field name="view_id" ref="res_config_settings_view_form"/&gt;
       &lt;field name="view_mode"&gt;form&lt;/field&gt;
       &lt;field name="target"&gt;inline&lt;/field&gt;
       &lt;field name="context"&gt;{'module' : 'my_hostel'}&lt;/field&gt;
   &lt;/record&gt;
   &lt;menuitem name="Settings" id="hostel_setting_menu" parent="hostel_main_menu" action="hostel_config_settings_action" sequence="50"/&gt;</pre></li>				<li>Restart the server and update the <code>my_hostel</code> module to apply the changes, as shown here:</li>
			</ol>
			<div><div><img src="img/B20997_08_7.jpg" alt="Figure 8.7 – The hostel user access right settings option to enable and disable this feature"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – The hostel user access right settings option to enable and disable this feature</p>
			<h2 id="_idParaDest-366"><a id="_idTextAnchor440"/>How it works...</h2>
			<p>In Odoo, all <a id="_idIndexMarker527"/>settings options are added in the <code>res.config.settings</code> model. <code>res.config.settings</code> is a transient model. In <em class="italic">Step 1</em>, we created a new security group. We will use this group to create the <strong class="bold">Hide</strong> and <strong class="bold">Show</strong> buttons.</p>
			<p>In <em class="italic">step 2</em>, we added a new <code>Boolean</code> field in the <code>res.config.settings</code> model by inheriting it. We added an <code>implied_group</code> attribute with a value of <code>my_hostel.group_hostel_user</code>. This group will be assigned to all <code>odoo</code> users when the admin enables or disables options with the <code>Boolean</code> field.</p>
			<p><code>base.res_config_settings_view_form</code>.</p>
			<p>In <em class="italic">Step 3</em>, we added our option to the user interface by inheriting this setting from the view. We used <code>xpath</code> to add our <code>setting</code> option. We will cover this in more detail in <a href="B20997_09.xhtml#_idTextAnchor446"><em class="italic">Chapter 9</em></a>, <em class="italic">Backend Views</em>. In the form definition, you will find that the attribute data-key value of this option will be your module name. This is only needed when you are adding a whole new tab in <code>xpath</code>.</p>
			<p>In <em class="italic">Step 4</em>, we added an action and a menu to access the configuration options from the user interface. You will need to pass the <code>{'module': 'my_hostel'}</code> context from the action to open the <code>my_hostel</code> module by default when the menu is clicked.</p>
			<p>In <em class="italic">Step 5</em>, we added <code>my_hostel.group_hostel_user</code> groups to the buttons. Because of this group, the <strong class="bold">Hostel User</strong> and <strong class="bold">Return</strong> buttons will be hidden or shown, based on the <strong class="bold">Settings</strong> options.</p>
			<p>After this, you <a id="_idIndexMarker528"/>will see a separate <code>Boolean</code> field to enable or disable the <code>implied_group</code> to or from all <code>odoo</code> users. Because we added the groups to buttons, the buttons will be displayed if the user has groups and will be hidden if the user doesn’t have groups. We will look at security groups in detail in <a href="B20997_10.xhtml#_idTextAnchor549"><em class="italic">Chapter 10</em></a>, <em class="italic">Security Access</em>.</p>
			<h2 id="_idParaDest-367"><a id="_idTextAnchor441"/>There’s more...</h2>
			<p>There are a few other ways to manage the <code>install</code> or <code>uninstall</code> them through various options. To do this, you will need to add a <code>Boolean</code> field with the name of the module prefixed with <code>module_</code>. If, for example, we create a new module called <code>my_hostel_extras</code>, you will need to add a <code>Boolean</code> field, as follows:</p>
			<pre class="source-code">
module_my_hostel_extras = fields.Boolean(
    string='Hostel Extra Features')</pre>			<p>When you enable or disable this option, <code>odoo</code> will <code>install</code> or <code>uninstall</code> the <code>my_hostel_extras</code> module.</p>
			<p>Another way to manage settings is to use system parameters. Such data is stored in the <code>ir.config_parameter</code> model. Here’s how you can create system-wide global parameters:</p>
			<pre class="source-code">
digest_emails = fields.Boolean(
        string="Digest Emails",
        config_parameter='digest.default_digest_emails')</pre>			<p>The <code>config_parameter</code> attribute in the fields will ensure the user data is stored in <code>digest.default_digest_emails</code> key.</p>
			<p>Settings<a id="_idIndexMarker529"/> options are used to make your application generic. These options give freedom to users and allow them to enable or disable features on the fly. When you convert a feature into options, you can serve more customers with one module and your customers can enable the feature whenever they like.</p>
			<h1 id="_idParaDest-368"><a id="_idTextAnchor442"/>Implementing init hooks</h1>
			<p>In <a href="B20997_06.xhtml#_idTextAnchor319"><em class="italic">Chapter 6</em></a>, <em class="italic">Managing Module Data</em>, you learned how to add, update, and delete records from XML or CSV files. Sometimes, however, the business case is complex, and it can’t be solved using data files. In such cases, you can use the <code>init</code> hook from the manifest file to perform the operations you want.</p>
			<p>Complex <a id="_idIndexMarker530"/>business cases may require dynamic initialization of data beyond standard XML or CSV files. Examples include integrating with external systems, performing complex calculations, or configuring records based on runtime conditions, facilitated by the <code>init</code> hook in the manifest file.</p>
			<h2 id="_idParaDest-369"><a id="_idTextAnchor443"/>Getting ready</h2>
			<p>We will use the same <code>my_hostel</code> module from the previous recipe. For simplicity, in this recipe, we will just create some room records through <code>post_init_hook</code>.</p>
			<h2 id="_idParaDest-370"><a id="_idTextAnchor444"/>How to do it...</h2>
			<p>To add <code>post_init_hook</code>, follow these steps:</p>
			<ol>
				<li>Register the hook in the <code>__manifest__.py</code> file with the <code>post_init_hook</code> key:<pre class="source-code">
...
'post_init_hook': 'add_room_hook',
...</pre></li>				<li>Add the <code>add_room_hook()</code> method to the <code>__init__.py</code> file:<pre class="source-code">
from odoo import api, SUPERUSER_ID
def add_room_hook(cr, registry):
   env = api.Environment(cr, SUPERUSER_ID, {})
   room_data1 = {'name': 'Room 1', 'room_no': '01'}
   room_data2 = {'name': 'Room 2', 'room_no': '02'}
   env['hostel.room'].create([room_data1, room_data2])</pre></li>			</ol>
			<h2 id="_idParaDest-371"><a id="_idTextAnchor445"/>How it works...</h2>
			<p>In <em class="italic">Step 1</em>, we registered <code>post_init_hook</code> in the manifest file with the <code>add_room_hook</code> value. This means that after the module is installed, Odoo will look for the <code>add_room_hook</code> method in <code>__init__.py</code>. The <code>post_init_hook</code> value receives the environment as an argument, showcasing an instance of the <code>add_room_hook</code> function that executes after module installation.</p>
			<p>In <em class="italic">Step 2</em>, we <a id="_idIndexMarker531"/>declared the <code>add_room_hook()</code> method, which will be called after the module is installed. We created two records from this method. In real-life scenarios, you can write complex business logic here.</p>
			<p>In this example, we looked at <code>post_init_hook</code>, but Odoo supports two more hooks:</p>
			<ul>
				<li><code>pre_init_hook</code>: This hook will be invoked when you start installing a module. It is the opposite of <code>post_init_hook</code>; it will be invoked after installing the current module:<ol><li class="Alphabets">Register the hook in the <code>__manifest__.py</code> file with the <code>pre_init_hook</code> key:</li></ol><pre class="source-code">
...
'pre_init_hook': 'pre_init_hook_hostel',
...</pre></li>			</ul>
			<ol>
				<li class="Alphabets" value="2">Add the <code>pre_init_hook_hostel()</code> method to the <code>__init__.py </code>file:</li>
			</ol>
			<pre class="source-code">
def pre_init_hook_hostel(env):
   env['ir.model.data'].search([
       ('model', 'like', 'hostel.hostel'),
   ]).unlink()</pre>			<ul>
				<li><code>uninstall_hook</code>: This hook will be invoked when you uninstall the module. This is mostly used when your module needs a garbage-collection mechanism:</li>
			</ul>
			<ol>
				<li class="Alphabets" value="3">Register the hook in the <code>__manifest__.py</code> file with the <code>uninstall_hook</code> key:</li>
			</ol>
			<pre class="source-code">
...
'uninstall_hook': 'uninstall_hook_user',
...</pre>			<ol>
				<li class="Alphabets" value="4">Add <code>uninstall_hook_user()</code> method to the <code>__init__.py</code> file:</li>
			</ol>
			<pre class="source-code">
def uninstall_hook_user(env):
   hostel = env['res.users'].search([])
   hostel.write({'active': False})</pre>			<p>Hooks are<a id="_idIndexMarker532"/> functions that run before, after, or in place of existing code. Hooks – functions that are displayed as strings – are contained in the <code>__init__ .py</code> file of an Odoo module.</p>
		</div>
	</body></html>