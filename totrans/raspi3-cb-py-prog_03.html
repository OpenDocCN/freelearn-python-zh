<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using Python for Automation and Productivity</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Using Tkinter to create graphical user interfaces</li>
<li>Creating a graphical Start menu application</li>
<li>Displaying photo information in an application</li>
<li>Organizing your photos automatically</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Until now, we have focused purely on command-line applications; however, there is much more to Raspberry Pi than just the command line. By using <strong>graphical user interfaces</strong> (<strong>GUIs</strong>), it is often easier to obtain input from a user and provide feedback in a simpler way. After all, we continuously process multiple inputs and outputs all the time, so why limit ourselves to the procedural format of the command line when we don't have to?</p>
<p>Fortunately, Python can support this. Much like other programming languages, such as Visual Basic and C/C++/C#, this can be achieved using prebuilt objects that provide standard controls. We will use a module called <strong>Tkinter</strong> which provides a good range of controls (also referred to as <strong>widgets</strong>) and tools for creating graphical applications.</p>
<p>First, we will take an example, <kbd>encryptdecrypt.py</kbd>, and demonstrate how useful modules can be written and reused in a variety of ways. This is an example of good coding practice. We should aim to write code that can be tested thoroughly and then reused in many places.</p>
<p>Next, we will extend our previous examples by creating a small graphical Start menu application to run our favorite applications from.</p>
<p>Then, we will explore using <strong>classes</strong> within our applications to display and then to<br/>
organize photos.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using Tkinter to create graphical user interfaces</h1>
                </header>
            
            <article>
                
<p>We will create a basic GUI to allow the user to enter information, and the program can then be used to encrypt and decrypt it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You must ensure that this file is placed in the same directory.</p>
<div class="packt_infobox">Since we are using Tkinter (one of many available add-ons for Python), we need to ensure that it is installed. It should be installed by default on the standard Raspbian image. We can confirm it is installed by importing it from the Python prompt, as follows:<br/>
<br/>
<kbd>   Python3</kbd><br/>
<kbd>   &gt;&gt;&gt; import tkinter</kbd><br/>
<br/>
If it is not installed, an <kbd>ImportError</kbd> exception will be raised, in which case you can install it using the following command (use <em><span class="KeyPACKT">Ctrl</span></em> + <em><span class="KeyPACKT">Z</span></em> to exit the Python prompt):<br/>
<br/>
<kbd>   sudo apt-get install python3-tk</kbd><br/>
<br/>
If the module did load, you can use the following command to read more about the module (use <em><span class="KeyPACKT">Q</span></em> to quit when you are done reading):<br/>
<br/>
<kbd>   &gt;&gt;&gt;help(tkinter)</kbd><br/>
<br/>
You can also get information about all the classes, functions, and methods within the module using the following command:<br/>
<br/>
<kbd>   &gt;&gt;&gt;help(tkinter.Button)</kbd><br/>
<br/>
The following <kbd>dir</kbd> command will list any valid commands or variables that are in the scope of the <kbd>module:</kbd><br/>
<br/>
<kbd>   &gt;&gt;&gt;dir(tkinter.Button)</kbd></div>
<p>You will see that our own modules will have the information about the functions marked by triple quotes; this will show up if we use the <kbd>help</kbd> command.</p>
<p>The command line will not be able to display the graphical displays created in this chapter, so you will have to start Raspberry Pi desktop (using the command <kbd>startx</kbd>), or if you are using it remotely.</p>
<div class="packt_infobox">Make sure you have <strong>X11 forwarding</strong> enabled and an <strong>X server</strong> running (see <a href="b2230c60-fd75-45fd-82c8-e477459db3e0.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 1</span></a>, <em>Getting Started with a Raspberry Pi 3 Computer</em>).</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We will use the <kbd>tkinter</kbd> module to produce a GUI for the <kbd>encryptdecrypt.py</kbd> script.</p>
<p>To generate the GUI we will create the following <kbd>tkencryptdecrypt.py</kbd> script:</p>
<pre>#!/usr/bin/python3 
#tkencryptdecrypt.py 
import encryptdecrypt as ENC 
import tkinter as TK 
 
def encryptButton(): 
    encryptvalue.set(ENC.encryptText(encryptvalue.get(), 
                                     keyvalue.get())) 
 
def decryptButton(): 
    encryptvalue.set(ENC.encryptText(encryptvalue.get(), 
                                     -keyvalue.get())) 
#Define Tkinter application 
root=TK.Tk() 
root.title("Encrypt/Decrypt GUI") 
#Set control &amp; test value 
encryptvalue = TK.StringVar() 
encryptvalue.set("My Message")  
keyvalue = TK.IntVar() 
keyvalue.set(20) 
prompt="Enter message to encrypt:" 
key="Key:" 
 
label1=TK.Label(root,text=prompt,width=len(prompt),bg='green') 
textEnter=TK.Entry(root,textvariable=encryptvalue, 
                   width=len(prompt)) 
encryptButton=TK.Button(root,text="Encrypt",command=encryptButton) 
decryptButton=TK.Button(root,text="Decrypt",command=decryptButton) 
label2=TK.Label(root,text=key,width=len(key)) 
keyEnter=TK.Entry(root,textvariable=keyvalue,width=8) 
#Set layout 
label1.grid(row=0,columnspan=2,sticky=TK.E+TK.W) 
textEnter.grid(row=1,columnspan=2,sticky=TK.E+TK.W) 
encryptButton.grid(row=2,column=0,sticky=TK.E) 
decryptButton.grid(row=2,column=1,sticky=TK.W) 
label2.grid(row=3,column=0,sticky=TK.E) 
keyEnter.grid(row=3,column=1,sticky=TK.W) 
 
TK.mainloop() 
#End </pre>
<p>Run the script using the following command:</p>
<pre><strong>python3 tkencryptdecrypt</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We start by importing two modules; the first is our own <kbd>encryptdecrypt</kbd> module and the second is the <kbd>tkinter</kbd> module. To make it easier to see which items have come from where, we use <kbd>ENC</kbd>/<kbd>TK</kbd>. If you want to avoid the extra reference, you can use <kbd>from &lt;module_name&gt; import *</kbd> to refer to the module items directly.</p>
<p>The <kbd>encryptButton()</kbd> and <kbd>decryptButton()</kbd> functions will be called when we click on the <span class="packt_screen">Encrypt</span> and <span class="packt_screen">Decrypt</span> buttons; they are explained in the following sections.</p>
<p>The main Tkinter window is created using the <kbd>Tk()</kbd> command, which returns the main window where all the widgets/controls can be placed.</p>
<p>We will define six controls as follows:</p>
<ul>
<li><kbd>Label</kbd>: This displays the prompt <span class="packt_screen">Enter message to encrypt:</span></li>
<li><kbd>Entry</kbd>: This provides a textbox to receive the user's message to be encrypted</li>
<li><kbd>Button</kbd>: This is an <span class="packt_screen">Encrypt</span> button to trigger the message to be encrypted</li>
<li><kbd>Button</kbd>: This is a <span class="packt_screen">Decrypt</span> button to reverse the encryption</li>
<li><kbd>Label</kbd>: This displays the <span class="packt_screen">Key:</span> field to prompt the user for an encryption key value</li>
<li><kbd>Entry</kbd>: This provides a second textbox to receive values for the encryption keys</li>
</ul>
<p>These controls will produce a GUI similar to the one shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/25cc32ac-9411-441c-b8af-b720909623a8.png" style="width:13.75em;height:7.17em;" width="205" height="107"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The GUI to encrypt/decrypt messages</div>
<p>Let's take a look at the first <kbd>label1</kbd> definition:</p>
<pre>label1=TK.Label(root,text=prompt,width=len(prompt),bg='green') </pre>
<p>All controls must be linked to the application window; hence, we have to specify our Tkinter window <kbd>root</kbd>. The text used for the label is set by <kbd>text</kbd>; in this case, we have set it to a string named <kbd>prompt</kbd>, which has been defined previously with the text we require. We also set the <kbd>width</kbd> to match the number of characters of the message (while not essential, it provides a neater result if we add more text to our labels later), and finally, we set the background color using <kbd>bg='green'</kbd>.</p>
<p>Next, we define the text <kbd>Entry</kbd> box for our message:</p>
<pre>textEnter=TK.Entry(root,textvariable=encryptvalue, 
                   width=len(prompt)) </pre>
<p>We will define <kbd>textvariable</kbd>—a useful way to link a variable to the contents of the box which is a special string variable. We could access the <kbd>text</kbd> directly using <kbd>textEnter.get()</kbd>, but we shall use a <kbd>Tkinter StringVar()</kbd> object instead to access it indirectly. If required, this will allow us to separate the data we are processing from the code that handles the GUI layout. The <kbd>enycrptvalue</kbd> variable automatically updates the <kbd>Entry</kbd> widget it is linked to whenever the <kbd>.set()</kbd> command is used (and the <kbd>.get()</kbd> command obtains the latest value from the <kbd>Entry</kbd> widget).</p>
<p>Next, we have our two <kbd>Button</kbd> widgets, <span class="packt_screen">Encrypt</span> and <span class="packt_screen">Decrypt</span>, as follows:</p>
<pre>encryptButton=TK.Button(root,text="Encrypt",command=encryptButton) 
decryptButton=TK.Button(root,text="Decrypt",command=decryptButton) </pre>
<p>In this case, we can set a function to be called when the <kbd>Button</kbd> widget is clicked by setting the <kbd>command</kbd> attribute. We can define the two functions that will be called when each button is clicked. In the following code snippet, we have the <kbd>encryptButton()</kbd> function, which will set the <kbd>encryptvalue StringVar</kbd> that controls the contents of the first <kbd>Entry</kbd> box. This string is set to the result we get by calling <kbd>ENC.encryptText()</kbd> with the message we want to encrypt (the current value of <kbd>encryptvalue</kbd>) and the <kbd>keyvalue</kbd> variable. The <kbd>decrypt()</kbd> function is exactly the same, except we make the <kbd>keyvalue</kbd> variable negative to decrypt the message:</p>
<pre>def encryptButton(): 
    encryptvalue.set(ENC.encryptText(encryptvalue.get(), 
                                     keyvalue.get())) </pre>
<p>We then set the final <kbd>Label</kbd> and <kbd>Entry</kbd> widgets in a similar way. Note that <kbd>textvariable</kbd> can also be an integer (numerical value) if required, but there is no built-in check to ensure that only numbers can be entered. You will encounter a <kbd>ValueError</kbd> exception when the <kbd>.get()</kbd> command is used.</p>
<p>After we have defined all the widgets to be used in the Tkinter window, we have to set the layout. There are three ways to define the layout in Tkinter: <em>place</em>, <em>pack</em>, and <em>grid</em>.</p>
<p>The place layout allows us to specify the positions and sizes using exact pixel positions. The pack layout places the items in the window in the order that they have been added in. The grid layout allows us to place the items in a specific layout. It is recommended that you avoid the place layout wherever possible since any small change to one item can have a knock-on effect on the positions and sizes of all the other items; the other layouts account for this by determining their positions relative to the other items in the window.</p>
<p class="mce-root">We will place the items as laid out in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/53ee12ff-f352-43f6-871f-20ce50fdeecb.png" style="width:20.33em;height:13.25em;" width="572" height="373"/></div>
<div class="packt_figure">
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Grid layout for the Encrypt/Decrypt GUI</span></div>
</div>
<p>The positions of first two items in the GUI are set using the following code:</p>
<pre>label1.grid(row=0,columnspan=2,sticky= TK.E+TK.W) 
textEnter.grid(row=1,columnspan=2,sticky= TK.E+TK.W) </pre>
<p>We can specify that the first <kbd>Label</kbd> and <kbd>Entry</kbd> box will span both columns (<kbd>columnspan=2</kbd>), and we can set the sticky values to ensure they span right to the edges. This is achieved by setting both the <kbd>TK.E</kbd> for the east and <kbd>TK.W</kbd> for the west sides. We'd use <kbd>TK.N</kbd> for the north and <kbd>TK.S</kbd> for the south sides if we needed to do the same vertically. If the <kbd>column</kbd> value is not specified, the grid function defaults to <kbd>column=0</kbd>. The other items are similarly defined.</p>
<p>The last step is to call <kbd>TK.mainloop()</kbd>, which allows Tkinter to run; this allows the buttons to be monitored for clicks and Tkinter to call the functions linked to them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a graphical application – Start menu</h1>
                </header>
            
            <article>
                
<p>The example in this recipe shows how we can define our own variations of Tkinter objects to generate custom controls and dynamically construct a menu with them. We will also take a quick look at using threads to allow other tasks to continue to function while a particular task is being executed.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>To view the GUI display, you will need a monitor displaying the Raspberry Pi desktop, or you need to be connected to another computer running the X server.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>To create a graphical Start menu application, create the following <kbd>graphicmenu.py</kbd> script:</li>
</ol>
<pre style="padding-left: 60px">#!/usr/bin/python3 
# graphicmenu.py 
import tkinter as tk 
from subprocess import call 
import threading 
 
#Define applications ["Display name","command"] 
leafpad = ["Leafpad","leafpad"] 
scratch = ["Scratch","scratch"] 
pistore = ["Pi Store","pistore"] 
app_list = [leafpad,scratch,pistore] 
APP_NAME = 0 
APP_CMD  = 1 
 
class runApplictionThread(threading.Thread): 
    def __init__(self,app_cmd): 
        threading.Thread.__init__(self) 
        self.cmd = app_cmd 
    def run(self): 
        #Run the command, if valid 
        try: 
            call(self.cmd) 
        except: 
            print ("Unable to run: %s" % self.cmd) 
 
class appButtons: 
    def __init__(self,gui,app_index): 
        #Add the buttons to window 
        btn = tk.Button(gui, text=app_list[app_index][APP_NAME], 
                        width=30, command=self.startApp) 
        btn.pack() 
        self.app_cmd=app_list[app_index][APP_CMD] 
    def startApp(self): 
        print ("APP_CMD: %s" % self.app_cmd) 
        runApplictionThread(self.app_cmd).start()        
 
root = tk.Tk() 
root.title("App Menu") 
prompt = '      Select an application      ' 
label1 = tk.Label(root, text=prompt, width=len(prompt), bg='green') 
label1.pack() 
#Create menu buttons from app_list 
for index, app in enumerate(app_list): 
    appButtons(root,index) 
#Run the tk window 
root.mainloop() 
#End</pre>
<ol start="2">
<li>The previous code produces the following application:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/81acc2fb-5452-4f1b-8507-28bbdbaa02ee.png" style="width:19.08em;height:8.67em;" width="265" height="120"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The App Menu GUI</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We create the Tkinter window as we did before; however, instead of defining all the items separately, we create a special class for the application buttons.</p>
<p>The class we create acts as a blueprint or specification of what we want the <kbd>appButtons</kbd> items to include. Each item will consist of a string value for <kbd>app_cmd</kbd>, a function called <kbd>startApp()</kbd>, and an <kbd>__init__()</kbd> function. The <kbd>__init__()</kbd> function is a special function (called a <strong>constructor</strong>) that is called when we create an <kbd>appButtons</kbd> item; it will allow us to create any setup that is required.</p>
<p>In this case, the <kbd>__init__()</kbd> function allows us to create a new <span class="packt_screen">Tkinter</span> button with the text to be set to an item in <kbd>app_list</kbd> and the command to be called in the <kbd>startApp()</kbd> function when the button is clicked. The <kbd>self</kbd> keyword is used so that the command called will be the one that is part of the item; this means that each button will call a locally defined function that has access to the local data of the item.</p>
<p>We set the value of <kbd>self.app_cmd</kbd> to the command from <kbd>app_list</kbd> and make it ready for use via the <kbd>startApp()</kbd> function. We now create the <kbd>startApp()</kbd> function. If we run the application command here directly, the Tkinter window will freeze until the application we have opened is closed again. To avoid this, we can use the Python threading module, which allows us to perform multiple actions at the same time.</p>
<p>The <kbd>runApplicationThread()</kbd> class is created using the <kbd>threading.Thread</kbd> class as a template—this inherits all the features of the <kbd>threading.Thread</kbd> class in a new class. Just like our previous class, we provide an <kbd>__init__()</kbd> function for this as well. We first call the <kbd>__init__()</kbd> function of the inherited class to ensure it is set up correctly, and then we store the <kbd>app_cmd</kbd> value in <kbd>self.cmd</kbd>. After the <kbd>runApplicationThread()</kbd> function has been created and initialized, the <kbd>start()</kbd> function is called. This function is part of <kbd>threading.Thread</kbd>, which our class can use. When the <kbd>start()</kbd> function is called, it will create a separate application thread (that is, simulate running two things at the same time), allowing Tkinter to continue monitoring button clicks while executing the <kbd>run()</kbd> function within the class.</p>
<p>Therefore, we can place the code in the <kbd>run()</kbd> function to run the required application (using <kbd>call(self.cmd)</kbd>).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>One aspect that makes Python particularly powerful is that it supports the programming techniques used in <strong>Object-Orientated Design</strong> (<strong>OOD</strong>). This is commonly used by modern programming languages to help translate the tasks we want our program to perform into meaningful constructs and structures in code. The principle of OOD lies in the fact that we think of most problems as consisting of several objects (a GUI window, a button, and so on) that interact with each other to produce a desired result.</p>
<p>In the previous section, we found that we could use classes to create unique objects that could be reused multiple times. We created an <kbd>appButton</kbd> class, which generated an object with all the features of the class, including its own personal version of <kbd>app_cmd</kbd> that will be used by the <kbd>startApp()</kbd> function. Another object of the <kbd>appButton</kbd> type will have its own unrelated <kbd>[app_cmd]</kbd> data that its <kbd>startApp()</kbd> function will use.</p>
<p>You can see that classes are useful to keep together a collection of related variables and functions in a single object, and the class will hold its own data in one place. Having multiple objects of the same type (class), each with their own functions and data inside them, results in better program structure. The traditional approach would be to keep all the information in one place and send each item back and forth for various functions to process; however, this may become cumbersome in large systems.</p>
<p>The following diagram shows the organization of related functions and data:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/492bc7ec-fea9-40dd-8eea-8e1552388b07.png" style="width:34.25em;height:21.33em;" width="661" height="411"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Data and functions</div>
<p>So far, we have used Python modules to separate parts of our programs into different<br/>
files; this allows us to conceptually separate different parts of the program (an interface, encoder/decoder, or library of classes, such as Tkinter). Modules can provide code to control a particular bit of hardware, define an interface for the internet, or provide a library of common functionality; however, its most important function is to control the interface (the collection of functions, variables, and classes that are available when the item is imported). A well-implemented module should have a clear interface that is centered around how it is used, rather than how it is implemented. This allows you to create multiple modules that can be swapped and changed easily since they share the same interface. In our previous example, imagine how easy it would be to change the <kbd>encryptdecrypt</kbd> module for another one just by supporting <kbd>encryptText(input_text,key)</kbd>. Complex functionality can be split into smaller, manageable blocks that can be reused in multiple applications.</p>
<p>Python makes use of classes and modules all the time. Each time you import a library, such as <kbd>sys</kbd> or Tkinter or convert a value using <kbd>value.str()</kbd> and iterate through a list using <kbd>for...in</kbd>, you can use them without worrying about the details. You don't have to use classes or modules in every bit of code you write, but they are useful tools to keep in your programmer's toolbox for times when they fit what you are doing.</p>
<p>We will understand how classes and modules allow us to produce well-structured code that is easier to test and maintain by using them in the examples of this book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Displaying photo information in an application</h1>
                </header>
            
            <article>
                
<p>In this example, we shall create a utility class to handle photos that can be used by other applications (as modules) to access photo metadata and display preview images easily.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>The following script makes use of <strong>Python Image Library</strong> (<strong>PIL</strong>); a compatible version for Python 3 is <strong>Pillow</strong>.</p>
<p>Pillow has not been included in the Raspbian repository (used by <kbd>apt-get</kbd>); therefore, we will need to install Pillow using a <strong>Python Package Manager</strong> called <strong>PIP</strong>.</p>
<p>To install packages for Python 3, we will use the Python 3 version of PIP (this requires 50 MB of available space).</p>
<p>The following commands can be used to install PIP:</p>
<pre><strong>sudo apt-get update</strong>
<strong>sudo apt-get install python3-pip</strong> </pre>
<p>Before you use PIP, ensure that you have installed <kbd>libjpeg-dev</kbd> to allow Pillow to handle JPEG files. You can do this using the following command:</p>
<pre><strong>sudo apt-get install libjpeg-dev</strong>
  </pre>
<p>Now you can install Pillow using the following PIP command:</p>
<pre><strong>sudo pip-3.2 install pillow</strong>  </pre>
<p>PIP also makes it easy to uninstall packages using <kbd>uninstall</kbd> instead of <kbd>install</kbd>.</p>
<p>Finally, you can confirm that it has installed successfully by running <kbd>python3</kbd>:</p>
<pre><strong>&gt;&gt;&gt;import PIL</strong>
<strong>&gt;&gt;&gt;help(PIL)</strong>  </pre>
<p>You should not get any errors and see lots of information about PIL and its uses (press <em><span class="KeyPACKT">Q</span></em> to finish). Check the version installed as follows:</p>
<pre><strong>&gt;&gt;PIL.PILLOW_VERSION</strong></pre>
<p>You should see <kbd>2.7.0</kbd> (or similar).</p>
<div class="packt_infobox">PIP can also be used with Python 2 by installing pip-2.x using the following command:<br/>
<br/>
<kbd>   sudo apt-get install python-pip</kbd><br/>
<br/>
Any packages installed using <kbd>sudo pip install</kbd> will be installed just for Python 2.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To display photo information in an application, create the following <kbd>photohandler.py</kbd> script:</p>
<pre>##!/usr/bin/python3 
#photohandler.py 
from PIL import Image 
from PIL import ExifTags 
import datetime 
import os 
 
#set module values 
previewsize=240,240 
defaultimagepreview="./preview.ppm" 
filedate_to_use="Exif DateTime" 
#Define expected inputs 
ARG_IMAGEFILE=1 
ARG_LENGTH=2 
     
class Photo: 
    def __init__(self,filename): 
        """Class constructor""" 
        self.filename=filename 
        self.filevalid=False 
        self.exifvalid=False 
        img=self.initImage() 
        if self.filevalid==True: 
            self.initExif(img) 
            self.initDates() 
     
    def initImage(self): 
        """opens the image and confirms if valid, returns Image""" 
        try: 
            img=Image.open(self.filename) 
            self.filevalid=True 
        except IOError: 
            print ("Target image not found/valid %s" % 
                   (self.filename)) 
            img=None 
            self.filevalid=False 
        return img 
         
    def initExif(self,image): 
        """gets any Exif data from the photo""" 
        try: 
            self.exif_info={ 
                ExifTags.TAGS[x]:y 
                for x,y in image._getexif().items() 
                if x in ExifTags.TAGS 
            } 
            self.exifvalid=True 
        except AttributeError: 
            print ("Image has no Exif Tags") 
            self.exifvalid=False 
 
             
    def initDates(self): 
        """determines the date the photo was taken""" 
        #Gather all the times available into YYYY-MM-DD format 
        self.filedates={} 
        if self.exifvalid: 
            #Get the date info from Exif info 
            exif_ids=["DateTime","DateTimeOriginal", 
                      "DateTimeDigitized"] 
            for id in exif_ids: 
                dateraw=self.exif_info[id] 
                self.filedates["Exif "+id]= 
                                dateraw[:10].replace(":","-") 
        modtimeraw = os.path.getmtime(self.filename) 
        self.filedates["File ModTime"]="%s" % 
            datetime.datetime.fromtimestamp(modtimeraw).date() 
        createtimeraw = os.path.getctime(self.filename) 
        self.filedates["File CreateTime"]="%s" % 
            datetime.datetime.fromtimestamp(createtimeraw).date() 
 
    def getDate(self): 
        """returns the date the image was taken""" 
        try: 
            date = self.filedates[filedate_to_use] 
        except KeyError: 
            print ("Exif Date not found") 
            date = self.filedates["File ModTime"] 
        return date 
         
    def previewPhoto(self): 
        """creates a thumbnail image suitable for tk to display""" 
        imageview=self.initImage() 
        imageview=imageview.convert('RGB') 
        imageview.thumbnail(previewsize,Image.ANTIALIAS) 
        imageview.save(defaultimagepreview,format='ppm') 
        return defaultimagepreview         </pre>
<p>The previous code defines our <kbd>Photo</kbd> class; it is of no use to us until we run it in the <em>There's more...</em> section and in the next example.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We define a general class called <kbd>Photo</kbd>; it contains details about itself and provides<br/>
functions to access <strong>Exchangeable Image File Format</strong> (<strong>EXIF</strong>) information and generate<br/>
a preview image.</p>
<p>In the <kbd>__init__()</kbd> function, we set values for our class variables and call <kbd>self.initImage()</kbd>, which will open the image using the <kbd>Image()</kbd> function from the PIL. We then call <kbd>self.initExif()</kbd> and <kbd>self.initDates()</kbd> and set a flag to indicate whether the file was valid or not. If not valid, the <kbd>Image()</kbd> function would raise an <kbd>IOError</kbd> exception.</p>
<p>The <kbd>initExif()</kbd> function uses PIL to read the EXIF data from the <kbd>img</kbd> object, as shown in the following code snippet:</p>
<pre>self.exif_info={ 
                ExifTags.TAGS[id]:y 
                for id,y in image._getexif().items() 
                if id in ExifTags.TAGS 
               } </pre>
<p>The previous code is a series of compound statements that results in <kbd>self.exif_info</kbd> being populated with a dictionary of tag names and their related values.</p>
<p><kbd>ExifTag.TAGS</kbd> is a dictionary that contains a list of possible tag names linked with their IDs, as shown in the following code snippet:</p>
<pre>ExifTag.TAGS={ 
4096: 'RelatedImageFileFormat', 
513: 'JpegIFOffset', 
514: 'JpegIFByteCount', 
40963: 'ExifImageHeight', 
...etc...}</pre>
<p>The <kbd>image._getexif()</kbd> function returns a dictionary that contains all the values set by the camera of the image, each linked to their relevant IDs, as shown in the following code snippet:</p>
<pre>Image._getexif()={ 
256: 3264, 
257: 2448, 
37378: (281, 100), 
36867: '2016:09:28 22:38:08', 
...etc...} </pre>
<p>The <kbd>for</kbd> loop will go through each item in the image's EXIF value dictionary and check for its occurrence in the <kbd>ExifTags.TAGS</kbd> dictionary; the result will get stored in <kbd>self.exif_info</kbd>. The code for this is as follows:</p>
<pre>self.exif_info={ 
'YResolution': (72, 1), 
 'ResolutionUnit': 2, 
 'ExposureMode': 0,  
'Flash': 24, 
...etc...} </pre>
<p>Again, if there are no exceptions, we set a flag to indicate that the EXIF data is valid, or if there is no EXIF data, we raise an <kbd>AttributeError</kbd> exception.</p>
<p>The <kbd>initDates()</kbd> function allows us to gather all the possible file dates and dates from the EXIF data so that we can select one of them as the date we wish to use for the file. For example, it allows us to rename all the images to a filename in the standard date format. We create a <kbd>self.filedates</kbd> dictionary that we populate with three dates extracted from the EXIF information. We then add the filesystem dates (created and modified) just in case no EXIF data is available. The <kbd>os</kbd> module allows us to use <kbd>os.path.getctime()</kbd> and <kbd>os.path.getmtime()</kbd> to obtain an epoch value of the file creation. It can also be the date and time when the file was moved – and the file modification – when it was last written to (for example, it often refers to the date when the picture was taken). The epoch value is the number of seconds since January 1, 1970, but we can use <kbd>datetime.datetime.fromtimestamp()</kbd> to convert it into years, months, days, hours, and seconds. Adding <kbd>date()</kbd> simply limits it to years, months, and days.</p>
<p>Now, if the <kbd>Photo</kbd> class was to be used by another module, and we wished to know the date of the image that was taken, we could look at the <kbd>self.dates</kbd> dictionary and pick out a suitable date. However, this would require the programmer to know how the <kbd>self.dates</kbd> values are arranged, and if we later changed how they are stored, it would break their program. For this reason, it is recommended that we access data in a class through access functions so the implementation is independent of the interfaces (this process is known as <strong>encapsulation</strong>). We provide a function that returns a date when called; the programmer does not need to know that it could be one of the five available dates or even that they are stored as epoch values. Using a function, we can ensure that the interface will remain the same no matter how the data is stored or collected.</p>
<p>Finally, the last function we want the <kbd>Photo</kbd> class to provide is <kbd>previewPhoto()</kbd>. This function provides a method to generate a small thumbnail image and saves it as a <strong>Portable Pixmap Format</strong> (<strong>PPM</strong>) file. As we will discover in a moment, Tkinter allows us to place images on its <kbd>Canvas</kbd> widget, but unfortunately, it does not support JPEGs directly and only supports GIF or PPM. Therefore, we simply save a small copy of the image we want to display in the PPM format – with the added warning that the image pallet must be converted to RGB too – and then get Tkinter to load it onto the <kbd>Canvas</kbd> when required.</p>
<p>To summarize, the <kbd>Photo</kbd> class we have created is as follows:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Operations</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>__init__(self,filename)</kbd></p>
</td>
<td>
<p>This is the object initializer.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>initImage(self)</kbd></p>
</td>
<td>
<p>This returns <kbd>img</kbd>, a PIL-type image object.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>initExif(self,image)</kbd></p>
</td>
<td>
<p>This extracts all the EXIF information, if any is present.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>initDates(self)</kbd></p>
</td>
<td>
<p>This creates a dictionary of all the dates available from the file and photo information.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>getDate(self)</kbd></p>
</td>
<td>
<p>This returns a string of the date when the photo was taken/created.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>previewPhoto(self)</kbd></p>
</td>
<td>
<p>This returns a string of the filename of the previewed thumbnail.</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_figure"/>
<p>The properties and their respective descriptions are as follows:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Properties</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>self.filename</kbd></p>
</td>
<td>
<p>The filename of the photo.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>self.filevalid</kbd></p>
</td>
<td>
<p>This is set to <kbd>True</kbd> if the file is opened successfully.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>self.exifvalid</kbd></p>
</td>
<td>
<p>This is set to <kbd>True</kbd> if the photo contains EXIF information.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>self.exif_info</kbd></p>
</td>
<td>
<p>This contains the EXIF information from the photo.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>self.filedates</kbd></p>
</td>
<td>
<p>This contains a dictionary of the available dates from the file and photo information.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>To test the new class, we will create some test code to confirm that everything is working as we expect; see the following section.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>We previously created the <kbd>Photo</kbd> class. Now we can add some test code to our module to ensure that it functions as we expect. We can use the <kbd>__name__ ="__main__"</kbd> attribute<br/>
as before to detect whether the module has been run directly or not.</p>
<p>We can add the subsequent section of code at the end of the <kbd>photohandler.py</kbd> script to produce the following test application, which looks as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/f11a6a8e-e92f-4692-8a5d-cdf01d247317.png" style="width:35.67em;height:17.83em;" width="526" height="263"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">The Photo View Demo application</div>
<p>Add the following code at the end of <kbd>photohandler.py</kbd>:</p>
<pre>#Module test code 
def dispPreview(aPhoto): 
    """Create a test GUI""" 
    import tkinter as TK 
 
    #Define the app window 
    app = TK.Tk() 
    app.title("Photo View Demo") 
    
    #Define TK objects 
    # create an empty canvas object the same size as the image 
    canvas = TK.Canvas(app, width=previewsize[0], 
                       height=previewsize[1]) 
    canvas.grid(row=0,rowspan=2) 
    # Add list box to display the photo data 
    #(including xyscroll bars) 
    photoInfo=TK.Variable() 
    lbPhotoInfo=TK.Listbox(app,listvariable=photoInfo, 
                           height=18,width=45, 
                           font=("monospace",10)) 
    yscroll=TK.Scrollbar(command=lbPhotoInfo.yview, 
                         orient=TK.VERTICAL) 
    xscroll=TK.Scrollbar(command=lbPhotoInfo.xview, 
                         orient=TK.HORIZONTAL) 
    lbPhotoInfo.configure(xscrollcommand=xscroll.set, 
                          yscrollcommand=yscroll.set) 
    lbPhotoInfo.grid(row=0,column=1,sticky=TK.N+TK.S) 
    yscroll.grid(row=0,column=2,sticky=TK.N+TK.S) 
    xscroll.grid(row=1,column=1,sticky=TK.N+TK.E+TK.W) 
     
    # Generate the preview image 
    preview_filename = aPhoto.previewPhoto() 
    photoImg = TK.PhotoImage(file=preview_filename) 
    # anchor image to NW corner 
    canvas.create_image(0,0, anchor=TK.NW, image=photoImg)  
     
    # Populate infoList with dates and exif data 
    infoList=[] 
    for key,value in aPhoto.filedates.items(): 
        infoList.append(key.ljust(25) + value) 
    if aPhoto.exifvalid: 
        for key,value in aPhoto.exif_info.items(): 
           infoList.append(key.ljust(25) + str(value)) 
    # Set listvariable with the infoList 
    photoInfo.set(tuple(infoList)) 
 
    app.mainloop() 
 
def main(): 
    """called only when run directly, allowing module testing""" 
    import sys 
    #Check the arguments 
    if len(sys.argv) == ARG_LENGTH: 
        print ("Command: %s" %(sys.argv)) 
        #Create an instance of the Photo class 
        viewPhoto = Photo(sys.argv[ARG_IMAGEFILE]) 
        #Test the module by running a GUI 
        if viewPhoto.filevalid==True: 
            dispPreview(viewPhoto) 
    else: 
        print ("Usage: photohandler.py imagefile") 
 
if __name__=='__main__': 
  main() 
#End </pre>
<p>The previous test code will run the <kbd>main()</kbd> function, which takes the filename of a photo to use and creates a new <kbd>Photo</kbd> object called <kbd>viewPhoto</kbd>. If <kbd>viewPhoto</kbd> is opened successfully, we will call <kbd>dispPreview()</kbd> to display the image and its details.</p>
<p>The <kbd>dispPreview()</kbd> function creates four Tkinter widgets to be displayed: a <kbd>Canvas</kbd> to load the thumbnail image, a <kbd>Listbox</kbd> widget to display the photo information, and two scroll bars to control the <kbd>Listbox</kbd>. First, we create a <kbd>Canvas</kbd> widget the size of the thumbnail image (<kbd>previewsize</kbd>).</p>
<p>Next, we create <kbd>photoInfo</kbd>, which will be our <kbd>listvariable</kbd> parameter linked to the <kbd>Listbox</kbd> widget. Since Tkinter doesn't provide a <kbd>ListVar()</kbd> function to create a suitable item, we use the generic type <kbd>TK.Variable()</kbd> and then ensure we convert it to a tuple type before setting the value. The <kbd>Listbox</kbd> widget gets added; we need to make sure that the <kbd>listvariable</kbd> parameter is set to <kbd>photoInfo</kbd> and also set the font to <kbd>monospace</kbd>. This will allow us to line up our data values using spaces, as <kbd>monospace</kbd> is a fixed width font, so each character takes up the same width as any other.</p>
<p>We define the two scroll bars, linking them to the <kbd>Listbox</kbd> widget, by setting the <kbd>Scrollbar</kbd> command parameters for vertical and horizontal scroll bars to <kbd>lbPhotoInfo.yview</kbd> and <kbd>lbPhotoInfo.xview</kbd>. Then, we adjust the parameters of the <kbd>Listbox</kbd> using the following command:</p>
<pre><strong>lbPhotoInfo.configure(xscrollcommand=xscroll.set, </strong>
<strong>                           yscrollcommand=yscroll.set)</strong>
  </pre>
<p>The <kbd>configure</kbd> command allows us to add or change the widget's parameters after it has been created, in this case linking the two scroll bars so the <kbd>Listbox</kbd> widget can also control them if the user scrolls within the list.</p>
<p>As before, we make use of the grid layout to ensure that the <kbd>Listbox</kbd> widget has the two scroll bars placed correctly next to it and the <kbd>Canvas</kbd> widget is to the left of the <kbd>Listbox</kbd> widget.</p>
<p>We now use the <kbd>Photo</kbd> object to create the <kbd>preview.ppm</kbd> thumbnail file (using the <kbd>aPhoto.previewPhoto()</kbd> function) and create a <kbd>TK.PhotoImage</kbd> object that can then be added to the <kbd>Canvas</kbd> widget with the following command:</p>
<pre><strong>canvas.create_image(0,0, anchor=TK.NW, image=photoImg)</strong>
  </pre>
<p>Finally, we use the date information that the <kbd>Photo</kbd> class gathers and the EXIF information (ensuring it is valid first) to populate the <kbd>Listbox</kbd> widget. We do this by converting each item into a list of strings that are spaced out using <kbd>.ljust(25)</kbd>—it adds left justification to the name and pads it out to make the string 25 characters wide. Once we have the list, we convert it to a tuple type and set the <kbd>listvariable</kbd> (<kbd>photoInfo</kbd>) parameter.</p>
<p>As always, we call <kbd>app.mainloop()</kbd> to start monitoring for events to respond to.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Organizing your photos automatically</h1>
                </header>
            
            <article>
                
<p>Now that we have a class that allows us to gather information about photos, we can apply this information to perform useful tasks. In this case, we will use the file information to automatically organize a folder full of photos into a subset of folders based on the dates<br/>
the photos were taken on. The following screenshot shows the output of the script:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/791ad614-7a78-4a55-8e19-2e94924fda3e.png" width="505" height="310"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Script output to organize photos in folder</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You will need a selection of photos placed in a folder on Raspberry Pi. Alternatively, you can insert a USB memory stick or a card reader with photos on it—they will be located in <kbd>/mnt/</kbd>. However, please make sure you test the scripts with a copy of your photos first, just in case there are any problems.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Create the following script in <kbd>filehandler.py</kbd> to automatically organize your photos:</p>
<pre>#!/usr/bin/python3 
#filehandler.py 
import os 
import shutil 
import photohandler as PH 
from operator import itemgetter 
 
FOLDERSONLY=True 
DEBUG=True 
defaultpath="" 
NAME=0 
DATE=1 
 
class FileList: 
  def __init__(self,folder): 
    """Class constructor""" 
    self.folder=folder 
    self.listFileDates() 
 
  def getPhotoNamedates(self): 
    """returns the list of filenames and dates""" 
    return self.photo_namedates 
 
  def listFileDates(self): 
    """Generate list of filenames and dates""" 
    self.photo_namedates = list() 
    if os.path.isdir(self.folder): 
      for filename in os.listdir(self.folder): 
        if filename.lower().endswith(".jpg"): 
          aPhoto = PH.Photo(os.path.join(self.folder,filename)) 
          if aPhoto.filevalid: 
            if (DEBUG):print("NameDate: %s %s"% 
                             (filename,aPhoto.getDate())) 
            self.photo_namedates.append((filename, 
                                         aPhoto.getDate())) 
            self.photo_namedates = sorted(self.photo_namedates, 
                                    key=lambda date: date[DATE]) 
 
  def genFolders(self): 
    """function to generate folders""" 
    for i,namedate in enumerate(self.getPhotoNamedates()): 
      #Remove the - from the date format 
      new_folder=namedate[DATE].replace("-","") 
      newpath = os.path.join(self.folder,new_folder) 
      #If path does not exist create folder 
      if not os.path.exists(newpath): 
        if (DEBUG):print ("New Path: %s" % newpath) 
        os.makedirs(newpath) 
      if (DEBUG):print ("Found file: %s move to %s" % 
                        (namedate[NAME],newpath)) 
      src_file = os.path.join(self.folder,namedate[NAME]) 
      dst_file = os.path.join(newpath,namedate[NAME]) 
      try: 
        if (DEBUG):print ("File moved %s to %s" % 
                          (src_file, dst_file)) 
        if (FOLDERSONLY==False):shutil.move(src_file, dst_file) 
      except IOError: 
        print ("Skipped: File not found") 
 
def main(): 
  """called only when run directly, allowing module testing""" 
  import tkinter as TK 
  from tkinter import filedialog 
  app = TK.Tk() 
  app.withdraw() 
  dirname = TK.filedialog.askdirectory(parent=app, 
      initialdir=defaultpath, 
      title='Select your pictures folder') 
  if dirname != "": 
    ourFileList=FileList(dirname) 
    ourFileList.genFolders() 
 
if __name__=="__main__": 
  main() 
#End </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We shall make a class called <kbd>FileList</kbd>; it will make use of the <kbd>Photo</kbd> class to manage<br/>
the photos within a specific folder. There are two main steps for this: we first need to find all the images within the folder, and then generate a list containing both the filename and the photo date. We will use this information to generate new subfolders and move the photos into these folders.</p>
<p>When we create the <kbd>FileList</kbd> object, we will create the list using <kbd>listFileDates()</kbd>. We will then confirm that the folder provided is valid and use <kbd>os.listdir</kbd> to obtain the full list of files within the directory. We will check that each file is a JPEG file and obtain each photo's date (using the function defined in the <kbd>Photo</kbd> class). Next, we will add the filename and date as a tuple to the <kbd>self.photo_namedates</kbd> list.</p>
<p>Finally, we will use the built-in <kbd>sorted</kbd> function to place all the files in order of their date. While we don't need to do this here, this function would make it easier to remove duplicate dates if we were to use this module elsewhere.</p>
<div class="packt_infobox">The <kbd>sorted</kbd> function requires the list to be sorted, and, in this case, we want to sort it by the <kbd>date values:</kbd><br/>
<br/>
<kbd>   sorted(self.photo_namedates,key=lambda date: date[DATE])</kbd><br/>
<br/>
We will substitute <kbd>date[DATE]</kbd> with <kbd>lambda date:</kbd> as the value to sort by.</div>
<p>Once the <kbd>FileList</kbd> object has been initialized, we can use it by calling <kbd>genFolders()</kbd>. First, we convert the date text into a suitable format for our folders (YYYYMMDD), allowing our folders to be easily sorted in order of their date. Next, it will create the folders within the current directory if they don't already exist. Finally, it will move each of the files into the required subfolder.</p>
<p>We end up with our <kbd>FileList</kbd> class that is ready to be tested:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Operations</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>__init__(self,folder)</kbd></p>
</td>
<td>
<p>This is the object initializer.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>getPhotoNamedates(self)</kbd></p>
</td>
<td>
<p>This returns a list of the filenames of the dates of the photos.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>listFileDates(self)</kbd></p>
</td>
<td>
<p>This creates a list of the filenames and dates of the photos in the folder.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>genFolders(self)</kbd></p>
</td>
<td>
<p>This creates new folders based on a photo's date and moves the files into them.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The properties are listed as follows:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Properties</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>self.folder</kbd></p>
</td>
<td>
<p>The folder we are working with.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>self.photo_namedates</kbd></p>
</td>
<td>
<p>This contains a list of the filenames and dates.</p>
</td>
</tr>
</tbody>
</table>
<p>The <kbd>FileList</kbd> class encapsulates all the functions and the relevant data together, keeping everything in one logical place:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/a4a862df-0e43-4755-9c7b-af620e6ce07d.png" style="width:25.92em;height:12.17em;" width="359" height="168"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Tkinter filediaglog.askdirectory() is used to select the photo directory</div>
<p>To test this, we use the Tkinter <kbd>filedialog.askdirectory()</kbd> widget to allow us to select a target directory of pictures. We use <kbd>app.withdrawn()</kbd> to hide the main Tkinter window since it isn't required this time. We just need to create a new <kbd>FileList</kbd> object and then call <kbd>genFolders()</kbd> to move all our photos to new locations!</p>
<div class="packt_infobox">Two additional flags have been defined in this script that provide extra control for testing. <kbd>DEBUG</kbd> allows us to enable or disable extra debugging messages by setting them to either <kbd>True</kbd> or <kbd>False</kbd>. Furthermore, <kbd>FOLDERSONLY</kbd>, when set to <kbd>True</kbd>, only generates the folders and doesn't move the files (this is helpful for testing whether the new subfolders are correct).</div>
<p>Once you have run the script, you can check if all the folders have been created correctly. Finally, change <kbd>FOLDERSONLY</kbd> to <kbd>True</kbd>, and your program will automatically move and organize your photos according to their dates the next time. It is recommended that you<br/>
only run this on a copy of your photos, just in case you get an error.</p>


            </article>

            
        </section>
    </div>



  </body></html>