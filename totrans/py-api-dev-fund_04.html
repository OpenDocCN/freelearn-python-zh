<html><head></head><body>
		<div>
			<div id="_idContainer063" class="Content">
			</div>
		</div>
		<div id="_idContainer064" class="Content">
			<h1 id="_idParaDest-81"><a id="_idTextAnchor136"/>4. Authentication Services and Security with JWT</h1>
		</div>
		<div id="_idContainer065" class="Content">
			<h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Apply your knowledge of JWT</li>
				<li class="bullets">Create an access token using Flask-JWT-Extended</li>
				<li class="bullets">Develop a membership login system</li>
				<li class="bullets">Implement an access control system (authentication and permissions)</li>
				<li class="bullets">Work with a refresh token</li>
				<li class="bullets">Restrict access using a blacklist</li>
			</ul>
			<p>This chapter covers how to develop a user login/logout function using JWT.</p>
		</div>
		<div id="_idContainer085" class="Content">
			<h2 id="_idParaDest-82"><a id="_idTextAnchor137"/>Introduction</h2>
			<p>In the previous chapter, we completed the database setup and configuration and linked the database to the code using ORM. We then implemented the user registration API on top of that. This chapter is divided into four parts. The first part is about authenticating the user and allowing them to log in to their own private profile page. The second part completes the recipe sharing system, allowing users to publish or unpublish their recipes. The third part shows how to refresh the security token and implement the logout feature. And finally, we will talk about how we can use the <strong class="inline">blacklist</strong> function to force the user to log out. </p>
			<p>User authentication is important in modern systems, especially if they are deployed on the internet. Thousands of users visit the same website, using the same web application. Without user authentication and access control, everything would be shared. Look at your Facebook/Instagram account – there are also user authentication and access controls implemented in the system. Only you can log in to your account and manage your posts and photos. For our Smilecook application, we will need the same feature. </p>
			<p>We will start by discussing JWT.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor138"/>JWT</h2>
			<p><strong class="bold">JWT</strong> is used for user authentication and is passed between the user and the server. The full definition of the acronym is <strong class="bold">JSON Web Token</strong>. The way they work is to encode the user identity and sign it digitally, making it an unforgeable token that identifies the user, and the application can later control access for the user based on their identity. </p>
			<p>A JWT is a string composed of the header, payload, and signature. Those three parts are separated by a <strong class="inline">.</strong>. Here is an example:</p>
			<p class="snippet">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1NjQ5ODI5OTcs Im5iZiI6MTU2NDk4Mjk5NywianRpIjoiMGIzOTVlODQtNjFjMy00NjM3LTkwMzYtZjgyZDgy YTllNzc5IiwiZXhwIjoxNTY0OTgzODk3LCJpZGVudGl0eSI6MywiZnJlc2giOmZhbHNlLCJ 0eXBlIjoiYWNjZXNzIn0.t6F3cnAmbUXY_PwLnnBkKD3Z6aJNvIDQ6khMJWj9xZM</p>
			<p>The header of the <strong class="bold">JWT</strong> contains the encryption type, <strong class="inline">"alg": "HS256"</strong>, and the encryption algorithm, <strong class="inline">"typ": "JWT"</strong>. We can see this clearly if we <strong class="inline">base64</strong> decode the header string:</p>
			<p class="snippet">&gt;&gt;&gt; import base64</p>
			<p class="snippet">&gt;&gt;&gt; header = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9'</p>
			<p class="snippet">&gt;&gt;&gt; base64.b64decode(header)</p>
			<p class="snippet">b'{"typ":"JWT","alg":"HS256"}'</p>
			<p>The content of the <strong class="bold">payload</strong> part is arbitrary. It can be anything the developer likes. We can put in it the user ID, nickname, and so on. When the application server receives this token, it can <strong class="inline">base64</strong> decode it and obtain the information inside. One important thing to note is that this information is not encrypted, therefore it is not recommended to store credit card details or passwords here:</p>
			<p class="snippet">&gt;&gt;&gt; import base64</p>
			<p class="snippet">&gt;&gt;&gt; payload = 'eyJpYXQiOjE1NjQ5ODI5OTcsIm5iZiI6MTU2NDk4Mjk5NywianRpI joiMGIzOTVlODQtNjFjMy00NjM3LTkwMzYtZjgyZDgyYTllNzc5IiwiZXhwIjoxNTY0 OTgzODk3LCJpZGVudGl0eSI6MywiZnJlc2giOmZhbHNlLCJ0eXBlIjoiYWNjZXNzIn0'</p>
			<p class="snippet">&gt;&gt;&gt; base64.b64decode(payload + '==')</p>
			<p class="snippet">b'{"iat":1564982997,"nbf":1564982997,"jti":"0b395e84-61c3-4637-9036-f82d82a9e779","exp":1564983897,"identity":3,"fresh":false,"type":"access"}'</p>
			<p>The <strong class="bold">secret</strong> part here is a signature created by the <strong class="inline">HS256</strong> algorithm. The algorithm is encrypting the encoded header and payload data with a secret key that is known by the application server only. While anyone can modify the JWT content, that would result in a different signature, thus the data integrity is protected. </p>
			<p>We can make use of the free service at <a href="https://jwt.io/">https://jwt.io/</a> to have a better view of the structure and content in the JWT token:</p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/C15309_04_01.jpg" alt="Figure 4.1: The JWT website&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 4.1: The JWT website</h6>
			<p>With a simple structure, <strong class="inline">header.payload.secret</strong>, we have a JWT, which will be used in this project for user authentication. Based on the user's identity, we can then apply access controls or other kinds of logic.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor139"/>Flask-JWT-Extended</h2>
			<p>Flask-JWT-Extended is a user authentication package that provides the <strong class="inline">create_access_token</strong> function for making new access JWTs. It also provides the <strong class="inline">jwt_required</strong> decorator for protecting the API endpoints (for checking whether users have logged in). Also, <strong class="inline">the get_jwt_identity()</strong> function is provided to get the identity of a JWT in a protected endpoint. This allows us to know who the authenticated users are. This is an extremely useful package for user authentication.</p>
			<p>Before we dive into the coming exercise, let's first discuss two very important key configurations that we will be using. They are as follows:</p>
			<ul>
				<li><strong class="bold">SECRET_KEY</strong>: This is the key for encrypting the message and generating the signature. We recommend that you use a complex string.</li>
				<li><strong class="bold">JWT_ERROR_MESSAGE_KEY</strong>: This is the key for the error message whenever there is an error. The default value is <strong class="inline">msg</strong>, but we are setting that to the <strong class="inline">message</strong> here.</li>
			</ul>
			<p>We will work on the user login function together in the next exercise. You will learn how user login works and how we can tell who the authenticated user is.</p>
			<h4>Note</h4>
			<p class="callout">For more information on Flask-JWT-Extended, you can refer to this link: <a href="https://flask-jwt-extended.readthedocs.io/en/latest/options.html">https://flask-jwt-extended.readthedocs.io/en/latest/options.html</a>.</p>
			<h3 id="_idParaDest-85"><a id="_idTextAnchor140"/>Exercise 24: Implementing a User Login Function</h3>
			<p>In this exercise, we will build the user login function. We will use the Flask-JWT-Extended package. Through this exercise, you will learn how we can generate JWTs in Flask. Users will enter their credentials in <strong class="inline">http://localhost:5000/token</strong> and they will get a token. They can then use that token to access <strong class="inline">http://localhost:5000/users/{username}</strong> and check their personal information registered in the system. If they don't have the token, they will only see their own ID and username. This is the access control function of our Smilecook application:</p>
			<ol>
				<li>I<a id="_idTextAnchor141"/>nstall the <strong class="inline">Flask-JWT-Extended</strong> package by adding the following lines in <strong class="inline">requirements.txt</strong>:<p class="snippet">Flask-JWT-Extended==3.20.0</p></li>
				<li>R<a id="_idTextAnchor142"/><a id="_idTextAnchor143"/>un the following command to install all of the necessary packages:<p class="snippet">pip install -r requirements.txt</p><p>You should see the following installation result on the screen:</p><p class="snippet">Installing collected packages: PyJWT, Flask-JWT-Extended</p><p class="snippet">  Running setup.py install for Flask-JWT-Extended ... done</p><p class="snippet">Successfully installed Flask-JWT-Extended-3.20.0 PyJWT-1.7.1</p></li>
				<li>C<a id="_idTextAnchor144"/><a id="_idTextAnchor145"/>onfigure <strong class="inline">Flask-JWT-Extended</strong> by adding the follo<a id="_idTextAnchor146"/>wing settings to the <strong class="inline">Config</strong> class in the <strong class="inline">config.py</strong> file:<p class="snippet">SECRET_KEY = 'super-secret-key'</p><p class="snippet">JWT_ERROR_MESSAGE_KEY = 'message'</p></li>
				<li>P<a id="_idTextAnchor147"/>ut the following code in <strong class="inline">extension.py</strong>:<p class="snippet">from flask_jwt_extended import JWTManager</p><p class="snippet">jwt = JWTManager()</p><p>Here, we are trying to create an instance of <strong class="inline">Flask-JWT-Extended</strong>. We first import the <strong class="inline">JWTManager </strong>class from <strong class="inline">flask_jwt_extended</strong>, then we instantiate a <strong class="inline">Flask-JWT-Extended</strong> instance by calling <strong class="inline">JWTManager()</strong>, and assign it to the <strong class="inline">jwt</strong> variable.</p></li>
				<li>T<a id="_idTextAnchor148"/>ype the following code in <strong class="inline">app.py</strong>:<p class="snippet">from extensions import db, jwt</p><p class="snippet">def register_extensions(app):</p><p class="snippet">    db.init_app(app)</p><p class="snippet">    migrate = Migrate(app, db)</p><p class="snippet">    jwt.init_app(app)</p><p>We first imported <strong class="inline">jwt</strong> from <strong class="inline">extensions</strong>, and then we initialized <strong class="inline">jwt</strong> with <strong class="inline">jwt.init_app(app)</strong> in <strong class="inline">register_extensions(app)</strong>.</p></li>
				<li>N<a id="_idTextAnchor149"/>ow we will create the resource for the login. We will first create the <strong class="inline">token.py</strong> file in the <strong class="inline">resources</strong> folder and type in the following code. We first import all the necessary modules, functions, and classes:<p class="snippet">from http import HTTPStatus</p><p class="snippet">from flask import request</p><p class="snippet">from flask_restful import Resource</p><p class="snippet">from flask_jwt_extended import create_access_token</p><p class="snippet">from utils import check_password</p><p class="snippet">from models.user import User</p></li>
				<li>Then, define a class called <strong class="inline">TokenResource</strong>. This class inherits from <strong class="inline">flask_restful.Resource</strong>:<p class="snippet">class TokenResource(Resource):</p></li>
				<li>Inside the class, we create a <strong class="inline">post</strong> method. When a user logs in, this method will be invoked and it will take the <strong class="inline">email</strong> and <strong class="inline">password</strong> from the client JSON request. It will use the <strong class="inline">get_by_email</strong> method to verify the correctness of the user's credentials:<p class="snippet">    def post(self):</p><p class="snippet">        json_data = request.get_json()</p><p class="snippet">        email = json_data.get('email')</p><p class="snippet">        password = json_data.get('password')</p><p class="snippet">        user = User.get_by_email(email=email)</p><p class="snippet">        if not user or not check_password(password, user.password):</p><p class="snippet">            return {'message': 'email or password is incorrect'}, HTTPStatus.UNAUTHORIZED</p><p class="snippet">        access_token = create_access_token(identity=user.id)</p><p class="snippet">        return {'access_token': access_token}, HTTPStatus.OK</p><p>If they are invalid, the method will stop there and return <strong class="bold">401 UNAUTHORIZED</strong>, with an email message saying <strong class="inline">email or password is incorrect</strong>. Otherwise, it will create an access token with the user id as the identity to the user.</p><h4>Note</h4><p class="callout">The way the <strong class="inline">check_password</strong> function works is by hashing the password the client passes in and comparing that hash value with the one stored in the database, using the <strong class="inline">pbkdf2_sha256.verify(password, hashed)</strong> function. There is no plaintext password comparison here.</p></li>
				<li>W<a id="_idTextAnchor150"/>e will then create a new resource, which is for getting user details. If the user is not authenticated, they can only see their ID and username. Otherwise, they will see their personal email as well. We can add the following code to <strong class="inline">resources/user.py</strong>.<p>We first import the necessary modules, functions, and classes:</p><p class="snippet">from flask_jwt_extended import jwt_optional, get_jwt_identity</p></li>
				<li>Then, we define a <strong class="inline">UserResource</strong> class that inherits from <strong class="inline">flask_restful.Resource</strong>:<p class="snippet">class UserResource(Resource):</p></li>
				<li>In this class, we define a <strong class="inline">get</strong> method and wrap it with a <strong class="inline">jwt_optional</strong> decorator. This implies that the endpoint is accessible regardless of the procession of the token:<p class="snippet">    @jwt_optional</p><p class="snippet">    def get(self, username):</p></li>
				<li>We then perform a similar routine to the previous step and check whether the <strong class="inline">username</strong> can be found in the database:<p class="snippet">        </p><p class="snippet">        user = User.get_by_username(username=username)</p><p class="snippet">        </p><p class="snippet">        if user is None:</p><p class="snippet">            return {'message': 'user not found'}, HTTPStatus.NOT_FOUND</p></li>
				<li>If it is found in the database, we will further check whether it matches the identity of the user ID in the JWT:<p class="snippet">        current_user = get_jwt_identity()</p></li>
				<li>Depending on the result in the previous step, we apply access control and output different information:<p class="snippet">        if current_user == user.id:</p><p class="snippet">            data = {</p><p class="snippet">                'id': user.id,</p><p class="snippet">                'username': user.username,</p><p class="snippet">                'email': user.email,</p><p class="snippet">            }</p><p class="snippet">        else:</p><p class="snippet">            data = {</p><p class="snippet">                'id': user.id,</p><p class="snippet">                'username': user.username,</p><p class="snippet">            }</p><p class="snippet">        return data, HTTPStatus.OK</p></li>
				<li>F<a id="_idTextAnchor151"/>inally, we will import the resources we created in the previous steps and add them to the <strong class="inline">api</strong> in <strong class="inline">app.py</strong>:<p class="snippet">from resources.user import UserListResource, UserResource</p><p class="snippet">from resources.token import TokenResource</p><p class="snippet">def register_resources(app):</p><p class="snippet">    api = Api(app)</p><p class="snippet">  api.add_resource(UserListResource, '/users')</p><p class="snippet">    api.add_resource(UserResource, '/users/&lt;string:username&gt;')</p><p class="snippet">    api.add_resource(TokenResource, '/token')</p></li>
				<li>Right-click on it to run the application. <strong class="bold">Flask</strong> will then be started up and run on localhost (<strong class="bold">127.0.0.1</strong>) at port <strong class="bold">5000</strong>:<div id="_idContainer067" class="IMG---Figure"><img src="image/C15309_04_02.jpg" alt="Figure 4.2: Run the application to start and run Flask on localhost&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 4.2: Run the application to start and run Flask on localhost</h6>
			<p>So, we have completed the user login function. This will allow users to visit the access-controlled APIs after login. Let's test it in our next exercise!</p>
			<h3 id="_idParaDest-86">Ex<a id="_idTextAnchor152"/>ercise 25: Testing the User Login Function</h3>
			<p>In this exercise, we will test the login function and verify the user information stored in the database. We will also test that the user information obtained from the <strong class="inline">http://localhost:5000/users/{username}</strong> API is different before and after user login:</p>
			<ol>
				<li value="1">Th<a id="_idTextAnchor153"/>e first thing to do is to create a user. Click on the <strong class="bold">Collections</strong> tab and choose <strong class="bold">POST</strong> <strong class="bold">UserList</strong>.</li>
				<li>Select the <strong class="bold">Body</strong> tab, select the <strong class="bold">raw</strong> radio button, and choose <strong class="bold">JSON (application/json)</strong> from the drop-down list. Put in the following user details (JSON format) in the <strong class="bold">Body</strong> field:<p class="snippet">{</p><p class="snippet">    "username": "james",</p><p class="snippet">    "email": "james@gmail.com",</p><p class="snippet">    "password": "WkQad19"</p><p class="snippet">}</p></li>
				<li>Click <strong class="bold">Send</strong> to register. The result is shown in the following screenshot:<div id="_idContainer068" class="IMG---Figure"><img src="image/C15309_04_03.jpg" alt="Figure 4.3: Creating a user&#13;&#10;"/></div><h6>Figure 4.3: Creating a user</h6><p>You will then see the response. The HTTP status is <strong class="bold">201 CREATED</strong>, meaning that the user registration has been successful. And we can see the user details in the response body. <strong class="inline">"id": 3</strong> here means that the user is the third successfully registered user.</p></li>
				<li>We<a id="_idTextAnchor154"/><a id="_idTextAnchor155"/> will then try to check the user information without logging in. Let's see what information we can get. Click on the <strong class="bold">Collections</strong> tab, create a new request with the name <strong class="inline">User</strong>, and save it under the <strong class="inline">User</strong> folder.</li>
				<li>Edit the request and put <strong class="inline">http://localhost:5000/users/james</strong> in the URL field. <strong class="bold">Save</strong> the request so that it can be reused later.</li>
				<li>Click <strong class="bold">Send</strong> to get the user details. The result is shown in the following screenshot:<div id="_idContainer069" class="IMG---Figure"><img src="image/C15309_04_04.jpg" alt="Figure 4.4: Checking the user information without logging in&#13;&#10;"/></div><h6>Figure 4.4: Checking the user information without logging in</h6><p>You will then see the response. The HTTP Status is <strong class="bold">200 OK</strong>, meaning the request has been successful. We can see the ID and username in the response body. However, we can't see the email address here because it is private information and is only visible to the authenticated user. </p></li>
				<li>Now,<a id="_idTextAnchor156"/> log in through the API. Click on the <strong class="bold">Collections</strong> tab. Create a new folder called <strong class="bold">Token</strong> and create a new request called <strong class="bold">Token</strong> inside it.</li>
				<li>Edit the request, change the method to <strong class="bold">POST</strong>, and put <strong class="inline">http://localhost:5000/token</strong> in the URL field.</li>
				<li>Click the <strong class="bold">Body</strong> tab, check the <strong class="bold">raw</strong> radio button, and select <strong class="bold">JSON (application/json)</strong> in the drop-down menu. Type in the following JSON content in the <strong class="bold">Body</strong> field and click <strong class="bold">Save</strong>:<p class="snippet">{</p><p class="snippet">    "email": "james@gmail.com",</p><p class="snippet">    "password": "WkQad19"</p><p class="snippet">}</p></li>
				<li>Click <strong class="bold">Send</strong> to log in. The result is shown in the following screenshot:<div id="_idContainer070" class="IMG---Figure"><img src="image/C15309_04_05.jpg" alt="Figure 4.5: Checking the user information after creating tokens&#13;&#10;"/></div><h6>Figure 4.5: Checking the user information after creating tokens</h6><p>You will then see the response. The HTTP status code <strong class="bold">200</strong> means the login has been successful. We can see the access token in the response body. We will rely on this token to show that the user has logged in.</p></li>
				<li>Now c<a id="_idTextAnchor157"/>heck the user information again after we have logged in. Click the <strong class="bold">Collections</strong> tab and select the <strong class="bold">GET User</strong> request. </li>
				<li>Select the <strong class="bold">Headers</strong> tab, select <strong class="bold">Authorization</strong> in the <strong class="bold">KEY</strong> field, type <strong class="inline">Bearer {token}</strong> in the <strong class="bold">VALUE</strong> field, where the token is what we obtained in step 10.</li>
				<li>Click <strong class="bold">Send</strong> to get the user details. The result is shown in the following screenshot:<div id="_idContainer071" class="IMG---Figure"><img src="image/C15309_04_06.jpg" alt="Figure 4.6: Checking the user information after logging in&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 4.6: Checking the user information after logging in</h6>
			<p>You will then see the response, the HTTP status code <strong class="bold">200</strong> means the request is successful. And in the response body, we can see information including <strong class="bold">id</strong>, <strong class="bold">username</strong>, and <strong class="bold">email</strong>.</p>
			<p>In this exercise, we can see how access control really works. We can see the difference in the HTTP response before and after the user is authenticated. This is very important for our Smilecook application because we want to protect our users' privacy. There is information that only certain authenticated users can see.</p>
			<h3 id="_idParaDest-87"><a id="_idTextAnchor158"/>Exercise 26: Creating the me Endpoint</h3>
			<p>In this exercise, we will create a special endpoint, <strong class="inline">/users/me</strong>. That will allow us to get the authenticated user information back by using <strong class="inline">access_token</strong>. We will first create a new <strong class="inline">resource</strong> class under the <strong class="inline">user</strong> model. There will be a <strong class="inline">get</strong> method in it, and we will finally associate this with the new API endpoint:</p>
			<ol>
				<li value="1"> Add the <strong class="inline">get_by_id</strong> method in <strong class="inline">models/user.py</strong>. For convenience's sake, we will use this method to get the user object by ID:<p class="snippet">@classmethod </p><p class="snippet">def get_by_id(cls, id):         </p><p class="snippet">        return cls.query.filter_by(id=id).first() </p></li>
				<li>In <strong class="inline">resources/user.py</strong>, import <strong class="inline">jwt_required</strong> and create a <strong class="inline">MeResource</strong> class:<p class="snippet">from flask_jwt_extended import jwt_optional, get_jwt_identity, jwt_required</p><p class="snippet">class MeResource(Resource):</p><p class="snippet">    @jwt_required</p><p class="snippet">    def get(self):</p><p class="snippet">        user = User.get_by_id(id=get_jwt_identity())</p><p class="snippet">        data = {</p><p class="snippet">                'id': user.id,</p><p class="snippet">                'username': user.username,</p><p class="snippet">                'email': user.email,</p><p class="snippet">        }</p><p class="snippet">        return data, HTTPStatus.OK</p><p>The <strong class="inline">get</strong> method here will get the user information by the ID in the JWT. </p></li>
				<li>In <strong class="inline">app.py</strong>, import the <strong class="inline">MeResource</strong> class. Add the <strong class="inline">/me</strong> endpoint:<p class="snippet">from resources.user import UserListResource, UserResource, MeResource</p><p class="snippet">api.add_resource(MeResource, '/me')</p></li>
				<li>Right-click on it to run the application. <strong class="bold">Flask</strong> will then be started up and run on localhost (<strong class="bold">127.0.0.1</strong>) at port <strong class="bold">5000</strong>:<div id="_idContainer072" class="IMG---Figure"><img src="image/C15309_03_07.jpg" alt="Figure 4.7: Run the application to start and run the Flask on localhost&#13;&#10;"/></div><h6>Figure 4.7: Run the application to start and run the Flask on localhost</h6></li>
				<li>Now check the user information again after we have logged in using the users/me endpoint. Click on the <strong class="bold">Collections</strong> tab and create a new request called <strong class="bold">Me</strong> in the <strong class="bold">User</strong> folder.</li>
				<li>Put <strong class="inline">http://localhost:5000/me</strong> in the URL field. </li>
				<li>Select the <strong class="bold">Headers</strong> tab, select <strong class="bold">Authorization</strong> in the <strong class="bold">KEY</strong> field and type in <strong class="inline">Bearer {token}</strong> in the <strong class="bold">VALUE</strong> field, where the token is what we obtained in the previous exercise.</li>
				<li>Click <strong class="bold">Send</strong> to get the user details. The result is shown in the following screenshot: <div id="_idContainer073" class="IMG---Figure"><img src="image/C15309_04_08.jpg" alt="Figure 4.8: Checking the user information after we have logged in&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 4.8: Checking the user information after we have logged in</h6>
			<p>This new API endpoint allows us to get the authenticated user information just by using the access token. This means that whenever the user is in the authenticated state, we can get their information. Now that we have pretty much figured out the users, let's work on the recipes.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor159"/>Designing the Methods in the Recipe Model</h2>
			<p>Now, we have finished the user registration and login feature, we will work on the recipe management features of our Smilecook application. That will need a few methods in the <strong class="inline">Recipe</strong> class to do the work. In our design, we will have the following five methods:</p>
			<ul>
				<li><strong class="inline">data</strong>: This is used to return the data in a dictionary format.</li>
				<li><strong class="inline">get_all_published</strong>: This method gets all the published recipes.</li>
				<li><strong class="inline">get_by_id</strong>: This method gets the recipes by ID.</li>
				<li><strong class="inline">save</strong>: This method persists data to the database.</li>
				<li><strong class="inline">delete</strong>: This method deletes data from the database.</li>
			</ul>
			<p>These fi<a id="_idTextAnchor160"/>ve methods cover pretty much all the necessary recipe management functions. In the next exercise, we will work on implementing these methods in our Smilecook application.</p>
			<h3 id="_idParaDest-89"><a id="_idTextAnchor161"/>Exercise 27: Implementing Access-Controlled Recipe Management Functions</h3>
			<p>The aim of this exercise is to implement different recipe management functions on our platform so that users can manage their own recipes in our Smilecook application. We will also have to modify <strong class="inline">RecipeListResource</strong> and <strong class="inline">RecipeResource</strong> to restrict access to certain methods there:</p>
			<ol>
				<li value="1">In <strong class="inline">model<a id="_idTextAnchor162"/>s/recipe.py</strong>, add the <strong class="inline">data</strong>, <strong class="inline">get_all_published</strong>, <strong class="inline">get_by_id</strong>, <strong class="inline">save</strong>, and <strong class="inline">delete</strong> methods to the <strong class="inline">Recipe</strong> class:<p class="snippet">    def data(self):</p><p class="snippet">        return {</p><p class="snippet">            'id': self.id,</p><p class="snippet">            'name': self.name,</p><p class="snippet">            'description': self.description,</p><p class="snippet">            'num_of_servings': self.num_of_servings,</p><p class="snippet">            'cook_time': self.cook_time,</p><p class="snippet">            'directions': self.directions,</p><p class="snippet">            'user_id': self.user_id</p><p class="snippet">        }</p><p class="snippet">    @classmethod</p><p class="snippet">    def get_all_published(cls):</p><p class="snippet">        return cls.query.filter_by(is_publish=True).all()</p><p class="snippet">    @classmethod</p><p class="snippet">    def get_by_id(cls, recipe_id):</p><p class="snippet">        return cls.query.filter_by(id=recipe_id).first()</p><p class="snippet">    def save(self):</p><p class="snippet">        db.session.add(self)</p><p class="snippet">        db.session.commit()</p><p class="snippet">    def delete(self):</p><p class="snippet">        db.session.delete(self)</p><p class="snippet">        db.session.commit()</p></li>
				<li>Delete the following code in <strong class="inline">models/recipe.py</strong>:<p class="snippet">recipe_list = []</p><p class="snippet">  </p><p class="snippet">def get_last_id():</p><p class="snippet">    if recipe_list:</p><p class="snippet">        last_recipe = recipe_list[-1]</p><p class="snippet">    else:</p><p class="snippet">        return 1</p><p class="snippet">    return last_recipe.id + 1</p></li>
				<li>In <strong class="inline">resources/recipe.py</strong>, import <strong class="inline">get_jwt_identity</strong>, <strong class="inline">jwt_required</strong>, and <strong class="inline">jwt_optional</strong>:<p class="snippet">from flask_jwt_extended import get_jwt_identity, jwt_required, jwt_optional</p></li>
				<li>Remove import <strong class="inline">recipe_list</strong><p class="snippet">from models.recipe import Recipe</p></li>
				<li>We will <a id="_idTextAnchor163"/><a id="_idTextAnchor164"/>then modify the <strong class="inline">get</strong> method in the <strong class="inline">RecipeListResource</strong> class. We will get all the published recipes by triggering <strong class="inline">Recipe.get_all_published()</strong>.Then, in the <strong class="inline">for</strong> loop, it iterates through the recipe list, converts each recipe into a dictionary object, and returns the dictionary list:<p class="snippet">class RecipeListResource(Resource):</p><p class="snippet">    def get(self):</p><p class="snippet">        recipes = Recipe.get_all_published()</p><p class="snippet">        data = []</p><p class="snippet">        for recipe in recipes:</p><p class="snippet">            data.append(recipe.data())</p><p class="snippet">         return {'data': data}, HTTPStatus.OK</p></li>
				<li>We then continue to modify the <strong class="inline">post</strong> method in the <strong class="inline">RecipeListResource</strong> class. The <strong class="inline">@jwt_required</strong> decorator here says that the method can only be invoked after the user has logged in. Inside the method, it gets all the recipe details from the client requests and saves them in the database. Finally, it will return the data with an HTTP status code of <strong class="bold">201 CREATED</strong>:<p class="snippet">    @jwt_required</p><p class="snippet">    def post(self):</p><p class="snippet">        json_data = request.get_json()</p><p class="snippet">        current_user = get_jwt_identity()</p><p class="snippet">        recipe = Recipe(name= json_data['name'],</p><p class="snippet">                        description= json_data['description'],</p><p class="snippet">                        num_of_servings= json_data['num_of_servings'],</p><p class="snippet">                        cook_time= json_data['cook_time'],</p><p class="snippet">                        directions= json_data['directions'],</p><p class="snippet">                        user_id=current_user)</p><p class="snippet">        recipe.save()</p><p class="snippet">        return recipe.data(), HTTPStatus.CREATED</p></li>
				<li>We will <a id="_idTextAnchor165"/><a id="_idTextAnchor166"/>modify the <strong class="inline">get</strong> method in <strong class="inline">RecipeResource</strong> to get a specific recipe. The <strong class="inline">@jwt_optional</strong> decorator specifies that the JWT is optional. Inside the method, we use <strong class="inline">Recipe.get_by_id(recipe_id=recipe_id)</strong> to get the recipe. If the specific recipe is not found, we will return <strong class="bold">404 NOT_FOUND</strong>. If it is found, we will then change the user who owns the recipe and the status. There is access control here, so it will return <strong class="bold">403 FORBIDDEN</strong> or <strong class="bold">200 OK</strong> depending on the situation:<p class="snippet">class RecipeResource(Resource):</p><p class="snippet">    @jwt_optional</p><p class="snippet">    def get(self, recipe_id):</p><p class="snippet">        recipe = Recipe.get_by_id(recipe_id=recipe_id)</p><p class="snippet">        if recipe is None:</p><p class="snippet">            return {'message': 'Recipe not found'}, HTTPStatus.NOT_FOUND</p><p class="snippet">        current_user = get_jwt_identity()</p><p class="snippet">        if recipe.is_publish == False and recipe.user_id != current_user:</p><p class="snippet">            return {'message': 'Access is not allowed'}, HTTPStatus.FORBIDDEN</p><p class="snippet">        return recipe.data(), HTTPStatus.OK</p></li>
				<li>We will modify the <strong class="inline">put</strong> method in <strong class="inline">RecipeResource</strong> to get a specific recipe. This <strong class="inline">put</strong> method is to update the recipe details. It will first check whether the recipe exists and whether the user has update privileges. If everything is okay, it will go ahead to update the recipe details and save it to the database:<p class="snippet">    @jwt_required</p><p class="snippet">    def put(self, recipe_id):</p><p class="snippet">        json_data = request.get_json()</p><p class="snippet">        recipe = Recipe.get_by_id(recipe_id=recipe_id)</p><p class="snippet">        if recipe is None:</p><p class="snippet">            return {'message': 'Recipe not found'}, HTTPStatus.NOT_FOUND</p><p class="snippet">        current_user = get_jwt_identity()</p><p class="snippet">        if current_user != recipe.user_id:</p><p class="snippet">            return {'message': 'Access is not allowed'}, HTTPStatus.FORBIDDEN</p><p class="snippet">        recipe.name = json_data['name']</p><p class="snippet">        recipe.description = json_data['description']</p><p class="snippet">        recipe.num_of_servings = json_data['num_of_servings']</p><p class="snippet">        recipe.cook_time = json_data['cook_time']</p><p class="snippet">        recipe.directions = json_data['directions']</p><p class="snippet">        recipe.save()</p><p class="snippet">        return recipe.data(), HTTPStatus.OK</p></li>
				<li>We will modify the <strong class="inline">delete</strong> method in <strong class="inline">RecipeResource</strong> to get a specific recipe. This is for deleting a recipe. The <strong class="inline">@jwt_required</strong> decorator implies that the JWT is required. When the user has logged in, they can access this path and delete the specified recipe if it exists:<p class="snippet">    @jwt_required</p><p class="snippet">    def delete(self, recipe_id):</p><p class="snippet">        recipe = Recipe.get_by_id(recipe_id=recipe_id)</p><p class="snippet">        if recipe is None:</p><p class="snippet">            return {'message': 'Recipe not found'}, HTTPStatus.NOT_FOUND</p><p class="snippet">        current_user = get_jwt_identity()</p><p class="snippet">        if current_user != recipe.user_id:</p><p class="snippet">            return {'message': 'Access is not allowed'}, HTTPStatus.FORBIDDEN</p><p class="snippet">        recipe.delete()</p><p class="snippet">        return {}, HTTPStatus.NO_CONTENT</p></li>
			</ol>
			<p>So, in t<a id="_idTextAnchor167"/>his exercise, we have implemented the recipe management functions and added access control to the resources. Now, only authorized users are allowed to manage their recipes. Let's test whether this is really the case in our next exercise.</p>
			<h3 id="_idParaDest-90">Exercis<a id="_idTextAnchor168"/>e 28: Testing the Recipe Management Functions</h3>
			<p>The aim of this exercise is to test all the recipe management functions using Postman. We registered an account in our previous exercise and logged in. We will use the same authenticated user to test adding, updating, and deleting recipes:</p>
			<ol>
				<li value="1">Create a<a id="_idTextAnchor169"/> recipe through our API. Click on the <strong class="bold">Collections</strong> tab and select the <strong class="bold">POST RecipeList</strong> request that we created previously.</li>
				<li>Go to the <strong class="bold">Headers</strong> tab, select <strong class="bold">Authorization</strong> in the <strong class="bold">KEY</strong> field and <strong class="inline">Bearer {token}</strong> in the <strong class="bold">VALUE</strong> field, where the token is the JWT token we got in our previous exercise. The result is shown in the following screenshot:<div id="_idContainer074" class="IMG---Figure"><img src="image/C15309_04_09.jpg" alt="Figure 4.9: Creating a recipe through the API&#13;&#10;"/></div><h6>Figure 4.9: Creating a recipe through the API</h6></li>
				<li>Go to the <strong class="bold">Body</strong> tab and type in the following recipe details:<p class="snippet">{</p><p class="snippet">    "name": "Cheese Pizza",</p><p class="snippet">    "description": "This is a lovely cheese pizza",</p><p class="snippet">    "num_of_servings": 2,</p><p class="snippet">    "cook_time": 30,</p><p class="snippet">    "directions": "This is how you make it"</p><p class="snippet">}</p></li>
				<li>Click <strong class="bold">Send</strong> to create a new recipe. The result is shown in the following screenshot:<div id="_idContainer075" class="IMG---Figure"><img src="image/C15309_04_10.jpg" alt="Figure 4.10: New recipe created&#13;&#10;"/></div><h6>Figure 4.10: New recipe created</h6><p>You will then see the response. The HTTP status code <strong class="bold">201</strong> here means the recipe is created successfully. And we can see the details in the HTTP response body. We can see from the response that the <strong class="inline">user_id</strong> is <strong class="bold">3</strong>, which is the user ID of the currently authenticated user. </p></li>
				<li>Get the re<a id="_idTextAnchor170"/>cipe with <strong class="inline">id = 3</strong> in the state that the user has logged in. Click on the <strong class="bold">Collections</strong> tab and select the <strong class="bold">GET</strong> recipe request that we created previously.</li>
				<li>Go to the <strong class="bold">Headers</strong> tab, select <strong class="bold">Authorization</strong> in the <strong class="bold">KEY</strong> field and <strong class="inline">Bearer {token}</strong> in the <strong class="bold">VALUE</strong> field, where the token is the JWT token we got in the previous exercise.</li>
				<li>Click <strong class="bold">Send</strong> to check the recipe. The result is shown in the following screenshot:<div id="_idContainer076" class="IMG---Figure"><img src="image/C15309_04_11.jpg" alt="Figure 4.11: Recipe with ID 3 after the user is logged in&#13;&#10;"/></div><h6>Figure 4.<a id="_idTextAnchor171"/>11: Recipe with ID 3 after the user is logged in</h6><p>You will then see the response. We can see the recipe details in the body. That is because the user is authenticated.</p></li>
				<li>Get the re<a id="_idTextAnchor172"/><a id="_idTextAnchor173"/>cipe with <strong class="inline">id = 3</strong> in the state that the user has <em class="italics">not</em> logged in. The expected result is that we won't be able to see the unpublished recipe. Click on the <strong class="bold">Collections</strong> tab and select the <strong class="bold">GET Recipe</strong> request that we created previously.</li>
				<li>Go to the <strong class="bold">Headers</strong> tab and uncheck <strong class="bold">Authorization</strong>, meaning that we are not going to put in the JWT token. Click <strong class="bold">Send</strong> to check the recipe. The result is shown in the following screenshot:<div id="_idContainer077" class="IMG---Figure"><img src="image/C15309_04_12.jpg" alt="Figure 4.12: Recipe with ID 3 and the user not logged in&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 4.12: Recipe with ID 3 and the user not logged in</h6>
			<p>You will then see the response; the HTTP status code is <strong class="bold">403 FORBIDDEN</strong>. This is because the recipe is unpublished and we have implemented access control on our API so that only authenticated users can see their own recipes in the draft. We see the message <strong class="bold">Access is not allowed</strong> because we have not logged in yet. The unpublished recipe is not available to the public.</p>
			<p>So, we have tested the access control recipe management functions. We can see how these can be used in real-world scenarios. Next, we will discuss refresh tokens, which are for keeping our users in the logged-in state.</p>
			<h2 id="_idParaDest-91">Refresh Toke<a id="_idTextAnchor174"/>ns</h2>
			<p>For the sake of security, we often set an expiration time for our tokens (<strong class="inline">flask-jwt-extended</strong> defaults that to 15 minutes). Because a token will expire, we need a function to refresh it without users putting in their credentials again.</p>
			<p>Flask-JWT-Extended provides refresh-token-related functions. A refresh token is a long-lived token that can be used to generate new access tokens. Please don't mix up refresh tokens and access tokens. A refresh token can only be used to obtain a new access token; it cannot be used as an access token to access restricted endpoints. For example, endpoints that have the <strong class="inline">jwt_required()</strong> or <strong class="inline">jwt_optional()</strong> decorators need an access token.</p>
			<p>Here's a brief explanation of the refresh-token-related functions in Flask-JWT-Extended:</p>
			<ul>
				<li><strong class="inline">create_access_token</strong>: This function creates a new access token.</li>
				<li><strong class="inline">create_refresh_token</strong>: This function creates a refresh token.</li>
				<li><strong class="inline">jwt_refresh_token_required</strong>: This is a decorator specifying that the refresh token is required.</li>
				<li><strong class="inline">get_jwt_identity</strong>: This function gets the user that holds the current access token.</li>
			</ul>
			<p>You will learn more about these functions in the next exercise. We will also add a <strong class="inline">fresh</strong> attribute to our token. This <strong class="inline">fresh</strong> attribute will only be set to <strong class="inline">True</strong> when users get the token by putting in their credentials. When they simply refresh the token, they will get a token with <strong class="inline">fresh = false</strong>. The reason for a refresh token is that we would like to avoid users having to put their credentials in again and again. However, for some critical functions, for example, changing passwords, we will still require them to have a fresh token.</p>
			<h3 id="_idParaDest-92">Exercise 29:<a id="_idTextAnchor175"/> Adding a Refresh Token Function</h3>
			<p>In this exercise, we will be adding a refresh token feature to our Smilecook application so that when the user's access token expires, they can use the refresh token to obtain a new access token:</p>
			<ol>
				<li value="1">In <strong class="inline">resources<a id="_idTextAnchor176"/><a id="_idTextAnchor177"/>/token.py</strong>, import the necessary functions from <strong class="inline">flask_jwt_extended</strong>:<p class="snippet">from flask_jwt_extended import (</p><p class="snippet">    create_access_token,</p><p class="snippet">    create_refresh_token,</p><p class="snippet">    jwt_refresh_token_required,</p><p class="snippet">    get_jwt_identity</p><p class="snippet">)</p></li>
				<li>Modify the <strong class="inline">p<a id="_idTextAnchor178"/>ost</strong> method under <strong class="inline">TokenResource</strong> to generate a <strong class="inline">token</strong> and a <strong class="inline">refresh_token</strong> for the user:<p class="snippet">    def post(self):</p><p class="snippet">        data = request.get_json()</p><p class="snippet">        email = data.get('email')</p><p class="snippet">        password = data.get('password')</p><p class="snippet">        user = User.get_by_email(email=email)</p><p class="snippet">        if not user or not check_password(password, user.password):</p><p class="snippet">            return {'message': 'username or password is incorrect'}, HTTPStatus.UNAUTHORIZED</p><p class="snippet">        access_token = create_access_token(identity=user.id, fresh=True)</p><p class="snippet">        refresh_token = create_refresh_token(identity=user.id)</p><p class="snippet">        return {'access_token': access_token, 'refresh_token': refresh_token}, HTTPStatus.OK</p><p>We pass in the <strong class="inline">fresh=True</strong> parameter to the <strong class="inline">create_access_token</strong> function. We then invoke the <strong class="inline">create_refresh_token</strong> function to generate a <strong class="inline">refresh</strong> token.</p></li>
				<li>Add the <strong class="inline">Refr<a id="_idTextAnchor179"/>eshResource</strong> class to <strong class="inline">token.py</strong>. Please add the following code:<p class="snippet">class RefreshResource(Resource):</p><p class="snippet">    @jwt_refresh_token_required</p><p class="snippet">    def post(self):</p><p class="snippet">        current_user = get_jwt_identity()</p><p class="snippet">        access_token = create_access_token(identity=current_user, fresh=False)</p><p class="snippet">        return {access_token: access_token}, HTTPStatus.OK</p><p>The <strong class="inline">@jwt_refresh_token_required</strong> decorator specifies that this endpoint will require a <strong class="inline">refresh</strong> token. In this method, we are generating a token for the user with <strong class="inline">fresh=false</strong>.</p></li>
				<li>Finally, add<a id="_idTextAnchor180"/><a id="_idTextAnchor181"/> the route for <strong class="inline">RefreshResource</strong>:<p class="snippet">from resources.token import TokenResource, RefreshResource</p><p class="snippet">def register_resources(app):</p><p class="snippet">    api.add_resource(RefreshResource, '/refresh')</p></li>
				<li>Save <strong class="inline">app.py</strong> <a id="_idTextAnchor182"/>and right-click on it to run the application. <strong class="bold">Flask</strong> will then be started up and run on localhost (<strong class="inline">127.0.0.1</strong>) at port <strong class="inline">5000</strong>:<div id="_idContainer078" class="IMG---Figure"><img src="image/C15309_04_13.jpg" alt="Figure 4.13: Run the application to start and run Flask on localhost&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 4.13: Run the application to start and run Flask on localhost</h6>
			<p>Congratulations! We have just added the refresh token function. Let's move on to the testing part.</p>
			<h3 id="_idParaDest-93">Exercise 30: <a id="_idTextAnchor183"/>Obtaining a New Access Token Using a Refresh Token</h3>
			<p>In this exercise, we will be using Postman to log in to the user account and get the access token and refresh token. Later on, we will obtain a new access token by using the refresh token. This is to simulate a real-life scenario in which we want to keep the user logged in:</p>
			<ol>
				<li value="1">We will test logging first. Click on the <strong class="bold">Collections</strong> tab. Select the <strong class="bold">POST Token</strong> request that we created previously.</li>
				<li>Check the <strong class="bold">raw</strong> radio button and select <strong class="bold">JSON (application/json)</strong> from the drop-down menu.</li>
				<li>Add the following JSON content in the <strong class="bold">Body</strong> field:<p class="snippet">{</p><p class="snippet">    "email": "james@gmail.com",</p><p class="snippet">    "password": "WkQad19"</p><p class="snippet">}</p></li>
				<li>Click <strong class="bold">Send</strong> to login to the account. The result is shown in the following screenshot:<div id="_idContainer079" class="IMG---Figure"><img src="image/C15309_04_14.jpg" alt="Figure 4.14: Testing the login&#13;&#10;"/></div><h6>Figure 4.14: Testing the login</h6><p>We can see that the HTTP status code is <strong class="bold">200 OK</strong>, meaning the login has been successful. We can also see the access token and refresh token in the body.</p></li>
				<li>Next, we will<a id="_idTextAnchor184"/> get the <strong class="inline">access</strong> token by using the <strong class="inline">refresh</strong> token. Click on the <strong class="bold">Collections</strong> tab. Create a new request, name it <strong class="bold">Refresh</strong>, and save it in the <strong class="bold">Token</strong> folder.</li>
				<li>Select this new request and choose <strong class="bold">POST</strong> as the method. Put <strong class="inline">http://localhost:5000/refresh</strong> in the <strong class="bold">URL</strong> field. </li>
				<li>Go to the <strong class="bold">Headers</strong> tab and select <strong class="bold">Authorization</strong> in the <strong class="bold">KEY</strong> field and <strong class="inline">Bearer {token}</strong> in the <strong class="bold">VALUE</strong> field, where the token is the <strong class="bold">JWT</strong> we got in step 4.</li>
				<li>Click <strong class="bold">Send</strong> to refresh the token. The result is shown in the following screenshot:<div id="_idContainer080" class="IMG---Figure"><img src="image/C15309_04_15.jpg" alt="Figure 4.15: Accessing the token using the refresh token&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 4.15: Accessing the token using the refresh token</h6>
			<p>We can see HTTP status <strong class="bold">200 OK</strong>, which means the request has been successful. And we can see the new access token in the response body. If the access token expires in the future, we can use a refresh token to obtain a new access token.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor185"/>The User Logout Mechanism</h2>
			<p>The Flask-JWT-E<a id="_idTextAnchor186"/>xtended package supports the logout function. The way it works is to put the token into a blacklist when the user is logged out. A <strong class="bold">blacklist</strong> is basically a blocklist; it is an access control mechanism. Things (for example, emails, tokens, IDs, and so on) on the list will be denied access. With the blacklist in place, the application can use <strong class="inline">token_in_blacklist_loader</strong> to verify whether the user has logged out or not:</p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/C15309_04_16.jpg" alt="Figure 4.16: The user logout mechanism using a blacklist&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 4.16: The user logout mechanism using a blacklist</h6>
			<p>In the next exercise, we want you to try implementing this logout function. It will test your understanding of the login and logout flow.</p>
			<h3 id="_idParaDest-95"><a id="_idTextAnchor187"/>Exercise 31: Implementing the Logout Function</h3>
			<p>In this exercise, we will implement the logout function. We will first declare a <strong class="inline">black_list</strong> to store all the <strong class="bold">logged-out</strong> access tokens. Later, when the user wants to visit the access-controlled API endpoints, we will first check whether the access token is still valid using the blacklist:</p>
			<ol>
				<li value="1">Import <strong class="inline">get_raw_j<a id="_idTextAnchor188"/>wt</strong>. In <strong class="inline">resources/token.py</strong>, we will import <strong class="inline">jwt_required</strong> and <strong class="inline">get_raw_jwt</strong> from <strong class="inline">flask_jwt_extended</strong>:<p class="snippet">from flask_jwt_extended import (</p><p class="snippet">    create_access_token,</p><p class="snippet">    create_refresh_token,</p><p class="snippet">    jwt_refresh_token_required,</p><p class="snippet">    get_jwt_identity,</p><p class="snippet">    jwt_required,</p><p class="snippet">    get_raw_jwt</p><p class="snippet">)</p></li>
				<li>In <strong class="inline">resources/tok<a id="_idTextAnchor189"/>en.py</strong>, assign <strong class="inline">set()</strong> to <strong class="inline">black_list</strong>:<p class="snippet">black_list = set()</p></li>
				<li>Create the <strong class="inline">Revok<a id="_idTextAnchor190"/>eResource</strong> class and define the <strong class="inline">post</strong> method. We will apply the <strong class="inline">@jwt_required</strong> decorator here to control the access to this endpoint. In this method, we get the token using <strong class="inline">get_raw_jwt()['jti']</strong> and put it in the blacklist:<p class="snippet">class RevokeResource(Resource):</p><p class="snippet">    @jwt_required</p><p class="snippet">    def post(self):</p><p class="snippet">        jti = get_raw_jwt()['jti']</p><p class="snippet">        black_list.add(jti)</p><p class="snippet">         return {'message': 'Successfully logged out'}, HTTPStatus.OK</p></li>
				<li>We will then add<a id="_idTextAnchor191"/> the following code in <strong class="inline">config.py</strong>. As you can tell, we are enabling the blacklist feature and also telling the application to check both the <strong class="inline">access</strong> and <strong class="inline">refresh</strong> token:<p class="snippet">class Config:</p><p class="snippet">    JWT_BLACKLIST_ENABLED = True</p><p class="snippet">    JWT_BLACKLIST_TOKEN_CHECKS = ['access', 'refresh']</p></li>
				<li>We will then import <strong class="inline">RevokeResource</strong> and <strong class="inline">black_list</strong> in <strong class="inline">app.py</strong>:<p class="snippet">from resources.token import TokenResource, RefreshResource, RevokeResource, black_list</p></li>
				<li>Then, inside <strong class="inline">register_extensions(app)</strong>, we will add the following lines of code. This is to check whether the token is on the blacklist:<p class="snippet">def register_extensions(app):</p><p class="snippet">    db.app = app</p><p class="snippet">    db.init_app(app)</p><p class="snippet">    migrate = Migrate(app, db)</p><p class="snippet">    jwt.init_app(app)</p><p class="snippet">    @jwt.token_in_blacklist_loader</p><p class="snippet">    def check_if_token_in_blacklist(decrypted_token):</p><p class="snippet">        jti = decrypted_token['jti']</p><p class="snippet">        return jti in black_list</p></li>
				<li>Finally, add the<a id="_idTextAnchor192"/> route in <strong class="inline">register_resources</strong>:<p class="snippet">def register_resources(app):</p><p class="snippet">    api.add_resource(TokenResource, '/token')</p><p class="snippet">    api.add_resource(RefreshResource, '/refresh')</p><p class="snippet">    api.add_resource(RevokeResource, '/revoke')</p></li>
				<li>Save <strong class="inline">app.py</strong> and right-click on it to run the application. <strong class="bold">Flask</strong> will then be started up and run on localhost (<strong class="bold">127.0.0.1</strong>) at port <strong class="bold">5000</strong>:<div id="_idContainer082" class="IMG---Figure"><img src="image/C15309_04_17.jpg" alt="Figure 4.17: Run the application to start Flask&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 4.17: Run the application to start Flask</h6>
			<p>Once the server is started, that means we are ready to test our refresh token API.</p>
			<h3 id="_idParaDest-96">Exercise 32: Test<a id="_idTextAnchor193"/>ing the Logout Function</h3>
			<p>In this exercise, we are going to test the logout function that we have just implemented in the previous exercise. Once we have logged out, we will try accessing an access-controlled endpoint and make sure we no longer have access to it:</p>
			<ol>
				<li value="1">We will log out from our application. Click on the <strong class="bold">Collections</strong> tab and create a new request, name it <strong class="bold">Revoke</strong>, and save it in the <strong class="bold">Token</strong> folder.</li>
				<li>Select this new request and choose <strong class="bold">POST</strong> as the method. Put <strong class="inline">http://localhost:5000/revoke</strong> in the URL field.</li>
				<li>Go to the <strong class="bold">Headers</strong> tab. Select <strong class="bold">Authorization</strong> in the <strong class="bold">KEY</strong> field and <strong class="inline">Bearer {token}</strong> in the <strong class="bold">VALUE</strong> field, where the token is the JWT we got in the previous exercise.</li>
				<li>Click <strong class="bold">Send</strong> to log out. The result is shown in the following screenshot:<div id="_idContainer083" class="IMG---Figure"><img src="image/C15309_04_18.jpg" alt="Figure 4.18: Logging out from the application&#13;&#10;"/></div><h6>Figure 4.18: Logging out from the application</h6><p>You will then see the response, HTTP status <strong class="bold">200 OK</strong>, meaning that the user has logged out successfully. Besides this, we can also see the message saying that the user has <strong class="bold">successfully logged out</strong>.</p></li>
				<li>Log out again and <a id="_idTextAnchor194"/>see what happens. Click <strong class="bold">Send</strong> again, and you will then see the following response:<div id="_idContainer084" class="IMG---Figure"><img src="image/C15309_04_19.jpg" alt="Figure 4.19: Logging out again&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 4.19: Logging out again</h6>
			<p>We can see HTTP status <strong class="bold">401 UNAUTHORIZED</strong>, meaning the user doesn't have access to this endpoint because the original access token has already been placed on the blacklist. In the response body, we can see the message <strong class="bold">Token has been revoked</strong>, meaning the user has successfully logged out.</p>
			<h3 id="_idParaDest-97"><a id="_idTextAnchor195"/>Activity 7: Implementing Access Control on the publish/unpublish Recipe Function</h3>
			<p>In this activity, we will implement access control on the <strong class="inline">publish</strong>/<strong class="inline">unpublish</strong> recipe API endpoint so that only authenticated users can <strong class="inline">publish</strong>/<strong class="inline">unpublish</strong> their own recipe. Follow these steps to complete the activity:</p>
			<ol>
				<li value="1">Modify the <strong class="inline">put</strong> method in <strong class="inline">RecipePublishResource</strong> to restrict access to authenticated users.</li>
				<li>Modify the <strong class="inline">delete</strong> method in <strong class="inline">RecipePublishResource</strong>.</li>
				<li>Log in to the user account and get the access token.</li>
				<li>Publish the recipe with <strong class="inline">id = 3</strong> in the state that the user has logged in.</li>
				<li>Unpublish a recipe <strong class="inline">id = 3</strong> in the state that the user has logged in<h4>Note</h4><p class="callout">The solution for this activity can be found on page 307.</p></li>
			</ol>
			<p>If you got everything right, congratulations! That means you have added access control to the publish and unpublish recipe function. Now, recipes are protected in the Smilecook application. Only the authors of the recipes can manage their own recipes now.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor196"/>Summary</h2>
			<p>In this chapter, we learned how to use Flask-JWT-Extended for access control. This is an important and fundamental feature that almost all online platforms will require. At the end of the chapter, we touched on the topic of maintaining the liveliness of a token. This is advanced but applicable knowledge that you will use in developing real-life RESTful APIs. In the next chapter, we will start to talk about data verification.</p>
		</div>
	</body></html>