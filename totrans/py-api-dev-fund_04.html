<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-81"><a id="_idTextAnchor136"/>4. Authentication Services and Security with JWT</h1>
		</div>
		<div><h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Apply your knowledge of JWT</li>
				<li class="bullets">Create an access token using Flask-JWT-Extended</li>
				<li class="bullets">Develop a membership login system</li>
				<li class="bullets">Implement an access control system (authentication and permissions)</li>
				<li class="bullets">Work with a refresh token</li>
				<li class="bullets">Restrict access using a blacklist</li>
			</ul>
			<p>This chapter covers how to develop a user login/logout function using JWT.</p>
		</div>
		<div><h2 id="_idParaDest-82"><a id="_idTextAnchor137"/>Introduction</h2>
			<p>In the previous chapter, we completed the database setup and configuration and linked the database to the code using ORM. We then implemented the user registration API on top of that. This chapter is divided into four parts. The first part is about authenticating the user and allowing them to log in to their own private profile page. The second part completes the recipe sharing system, allowing users to publish or unpublish their recipes. The third part shows how to refresh the security token and implement the logout feature. And finally, we will talk about how we can use the <code>blacklist</code> function to force the user to log out. </p>
			<p>User authentication is important in modern systems, especially if they are deployed on the internet. Thousands of users visit the same website, using the same web application. Without user authentication and access control, everything would be shared. Look at your Facebook/Instagram account – there are also user authentication and access controls implemented in the system. Only you can log in to your account and manage your posts and photos. For our Smilecook application, we will need the same feature. </p>
			<p>We will start by discussing JWT.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor138"/>JWT</h2>
			<p><strong class="bold">JWT</strong> is used for user authentication and is passed between the user and the server. The full definition of the acronym is <strong class="bold">JSON Web Token</strong>. The way they work is to encode the user identity and sign it digitally, making it an unforgeable token that identifies the user, and the application can later control access for the user based on their identity. </p>
			<p>A JWT is a string composed of the header, payload, and signature. Those three parts are separated by a <code>.</code>. Here is an example:</p>
			<pre>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1NjQ5ODI5OTcs Im5iZiI6MTU2NDk4Mjk5NywianRpIjoiMGIzOTVlODQtNjFjMy00NjM3LTkwMzYtZjgyZDgy YTllNzc5IiwiZXhwIjoxNTY0OTgzODk3LCJpZGVudGl0eSI6MywiZnJlc2giOmZhbHNlLCJ 0eXBlIjoiYWNjZXNzIn0.t6F3cnAmbUXY_PwLnnBkKD3Z6aJNvIDQ6khMJWj9xZM</pre>
			<p>The header of the <code>"alg": "HS256"</code>, and the encryption algorithm, <code>"typ": "JWT"</code>. We can see this clearly if we <code>base64</code> decode the header string:</p>
			<pre>&gt;&gt;&gt; import base64
&gt;&gt;&gt; header = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9'
&gt;&gt;&gt; base64.b64decode(header)
b'{"typ":"JWT","alg":"HS256"}'</pre>
			<p>The content of the <code>base64</code> decode it and obtain the information inside. One important thing to note is that this information is not encrypted, therefore it is not recommended to store credit card details or passwords here:</p>
			<pre>&gt;&gt;&gt; import base64
&gt;&gt;&gt; payload = 'eyJpYXQiOjE1NjQ5ODI5OTcsIm5iZiI6MTU2NDk4Mjk5NywianRpI joiMGIzOTVlODQtNjFjMy00NjM3LTkwMzYtZjgyZDgyYTllNzc5IiwiZXhwIjoxNTY0 OTgzODk3LCJpZGVudGl0eSI6MywiZnJlc2giOmZhbHNlLCJ0eXBlIjoiYWNjZXNzIn0'
&gt;&gt;&gt; base64.b64decode(payload + '==')
b'{"iat":1564982997,"nbf":1564982997,"jti":"0b395e84-61c3-4637-9036-f82d82a9e779","exp":1564983897,"identity":3,"fresh":false,"type":"access"}'</pre>
			<p>The <code>HS256</code> algorithm. The algorithm is encrypting the encoded header and payload data with a secret key that is known by the application server only. While anyone can modify the JWT content, that would result in a different signature, thus the data integrity is protected. </p>
			<p>We can make use of the free service at <a href="https://jwt.io/">https://jwt.io/</a> to have a better view of the structure and content in the JWT token:</p>
			<div><div><img src="img/C15309_04_01.jpg" alt="Figure 4.1: The JWT website&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 4.1: The JWT website</h6>
			<p>With a simple structure, <code>header.payload.secret</code>, we have a JWT, which will be used in this project for user authentication. Based on the user's identity, we can then apply access controls or other kinds of logic.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor139"/>Flask-JWT-Extended</h2>
			<p>Flask-JWT-Extended is a user authentication package that provides the <code>create_access_token</code> function for making new access JWTs. It also provides the <code>jwt_required</code> decorator for protecting the API endpoints (for checking whether users have logged in). Also, <code>the get_jwt_identity()</code> function is provided to get the identity of a JWT in a protected endpoint. This allows us to know who the authenticated users are. This is an extremely useful package for user authentication.</p>
			<p>Before we dive into the coming exercise, let's first discuss two very important key configurations that we will be using. They are as follows:</p>
			<ul>
				<li><strong class="bold">SECRET_KEY</strong>: This is the key for encrypting the message and generating the signature. We recommend that you use a complex string.</li>
				<li><code>msg</code>, but we are setting that to the <code>message</code> here.</li>
			</ul>
			<p>We will work on the user login function together in the next exercise. You will learn how user login works and how we can tell who the authenticated user is.</p>
			<h4>Note</h4>
			<p class="callout">For more information on Flask-JWT-Extended, you can refer to this link: <a href="https://flask-jwt-extended.readthedocs.io/en/latest/options.html">https://flask-jwt-extended.readthedocs.io/en/latest/options.html</a>.</p>
			<h3 id="_idParaDest-85"><a id="_idTextAnchor140"/>Exercise 24: Implementing a User Login Function</h3>
			<p>In this exercise, we will build the user login function. We will use the Flask-JWT-Extended package. Through this exercise, you will learn how we can generate JWTs in Flask. Users will enter their credentials in <code>http://localhost:5000/token</code> and they will get a token. They can then use that token to access <code>http://localhost:5000/users/{username}</code> and check their personal information registered in the system. If they don't have the token, they will only see their own ID and username. This is the access control function of our Smilecook application:</p>
			<ol>
				<li>I<a id="_idTextAnchor141"/>nstall the <code>Flask-JWT-Extended</code> package by adding the following lines in <code>requirements.txt</code>:<pre>Flask-JWT-Extended==3.20.0</pre></li>
				<li>R<a id="_idTextAnchor142"/><a id="_idTextAnchor143"/>un the following command to install all of the necessary packages:<pre>pip install -r requirements.txt</pre><p>You should see the following installation result on the screen:</p><pre>Installing collected packages: PyJWT, Flask-JWT-Extended
  Running setup.py install for Flask-JWT-Extended ... done
Successfully installed Flask-JWT-Extended-3.20.0 PyJWT-1.7.1</pre></li>
				<li>C<a id="_idTextAnchor144"/><a id="_idTextAnchor145"/>onfigure <code>Flask-JWT-Extended</code> by adding the follo<a id="_idTextAnchor146"/>wing settings to the <code>Config</code> class in the <code>config.py</code> file:<pre>SECRET_KEY = 'super-secret-key'
JWT_ERROR_MESSAGE_KEY = 'message'</pre></li>
				<li>P<a id="_idTextAnchor147"/>ut the following code in <code>extension.py</code>:<pre>from flask_jwt_extended import JWTManager
jwt = JWTManager()</pre><p>Here, we are trying to create an instance of <code>Flask-JWT-Extended</code>. We first import the <code>JWTManager </code>class from <code>flask_jwt_extended</code>, then we instantiate a <code>Flask-JWT-Extended</code> instance by calling <code>JWTManager()</code>, and assign it to the <code>jwt</code> variable.</p></li>
				<li>T<a id="_idTextAnchor148"/>ype the following code in <code>app.py</code>:<pre>from extensions import db, jwt
def register_extensions(app):
    db.init_app(app)
    migrate = Migrate(app, db)
    jwt.init_app(app)</pre><p>We first imported <code>jwt</code> from <code>extensions</code>, and then we initialized <code>jwt</code> with <code>jwt.init_app(app)</code> in <code>register_extensions(app)</code>.</p></li>
				<li>N<a id="_idTextAnchor149"/>ow we will create the resource for the login. We will first create the <code>token.py</code> file in the <code>resources</code> folder and type in the following code. We first import all the necessary modules, functions, and classes:<pre>from http import HTTPStatus
from flask import request
from flask_restful import Resource
from flask_jwt_extended import create_access_token
from utils import check_password
from models.user import User</pre></li>
				<li>Then, define a class called <code>TokenResource</code>. This class inherits from <code>flask_restful.Resource</code>:<pre>class TokenResource(Resource):</pre></li>
				<li>Inside the class, we create a <code>post</code> method. When a user logs in, this method will be invoked and it will take the <code>email</code> and <code>password</code> from the client JSON request. It will use the <code>get_by_email</code> method to verify the correctness of the user's credentials:<pre>    def post(self):
        json_data = request.get_json()
        email = json_data.get('email')
        password = json_data.get('password')
        user = User.get_by_email(email=email)
        if not user or not check_password(password, user.password):
            return {'message': 'email or password is incorrect'}, HTTPStatus.UNAUTHORIZED
        access_token = create_access_token(identity=user.id)
        return {'access_token': access_token}, HTTPStatus.OK</pre><p>If they are invalid, the method will stop there and return <code>email or password is incorrect</code>. Otherwise, it will create an access token with the user id as the identity to the user.</p><h4>Note</h4><p class="callout">The way the <code>check_password</code> function works is by hashing the password the client passes in and comparing that hash value with the one stored in the database, using the <code>pbkdf2_sha256.verify(password, hashed)</code> function. There is no plaintext password comparison here.</p></li>
				<li>W<a id="_idTextAnchor150"/>e will then create a new resource, which is for getting user details. If the user is not authenticated, they can only see their ID and username. Otherwise, they will see their personal email as well. We can add the following code to <code>resources/user.py</code>.<p>We first import the necessary modules, functions, and classes:</p><pre>from flask_jwt_extended import jwt_optional, get_jwt_identity</pre></li>
				<li>Then, we define a <code>UserResource</code> class that inherits from <code>flask_restful.Resource</code>:<pre>class UserResource(Resource):</pre></li>
				<li>In this class, we define a <code>get</code> method and wrap it with a <code>jwt_optional</code> decorator. This implies that the endpoint is accessible regardless of the procession of the token:<pre>    @jwt_optional
    def get(self, username):</pre></li>
				<li>We then perform a similar routine to the previous step and check whether the <code>username</code> can be found in the database:<pre>        
        user = User.get_by_username(username=username)
        
        if user is None:
            return {'message': 'user not found'}, HTTPStatus.NOT_FOUND</pre></li>
				<li>If it is found in the database, we will further check whether it matches the identity of the user ID in the JWT:<pre>        current_user = get_jwt_identity()</pre></li>
				<li>Depending on the result in the previous step, we apply access control and output different information:<pre>        if current_user == user.id:
            data = {
                'id': user.id,
                'username': user.username,
                'email': user.email,
            }
        else:
            data = {
                'id': user.id,
                'username': user.username,
            }
        return data, HTTPStatus.OK</pre></li>
				<li>F<a id="_idTextAnchor151"/>inally, we will import the resources we created in the previous steps and add them to the <code>api</code> in <code>app.py</code>:<pre>from resources.user import UserListResource, UserResource
from resources.token import TokenResource
def register_resources(app):
    api = Api(app)
  api.add_resource(UserListResource, '/users')
    api.add_resource(UserResource, '/users/&lt;string:username&gt;')
    api.add_resource(TokenResource, '/token')</pre></li>
				<li>Right-click on it to run the application. <strong class="bold">Flask</strong> will then be started up and run on localhost (<strong class="bold">127.0.0.1</strong>) at port <strong class="bold">5000</strong>:<div><img src="img/C15309_04_02.jpg" alt="Figure 4.2: Run the application to start and run Flask on localhost&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 4.2: Run the application to start and run Flask on localhost</h6>
			<p>So, we have completed the user login function. This will allow users to visit the access-controlled APIs after login. Let's test it in our next exercise!</p>
			<h3 id="_idParaDest-86">Ex<a id="_idTextAnchor152"/>ercise 25: Testing the User Login Function</h3>
			<p>In this exercise, we will test the login function and verify the user information stored in the database. We will also test that the user information obtained from the <code>http://localhost:5000/users/{username}</code> API is different before and after user login:</p>
			<ol>
				<li value="1">Th<a id="_idTextAnchor153"/>e first thing to do is to create a user. Click on the <strong class="bold">Collections</strong> tab and choose <strong class="bold">POST</strong> <strong class="bold">UserList</strong>.</li>
				<li>Select the <strong class="bold">Body</strong> tab, select the <strong class="bold">raw</strong> radio button, and choose <strong class="bold">JSON (application/json)</strong> from the drop-down list. Put in the following user details (JSON format) in the <strong class="bold">Body</strong> field:<pre>{
    "username": "james",
    "email": "james@gmail.com",
    "password": "WkQad19"
}</pre></li>
				<li>Click <code>"id": 3</code> here means that the user is the third successfully registered user.</p></li>
				<li>We<a id="_idTextAnchor154"/><a id="_idTextAnchor155"/> will then try to check the user information without logging in. Let's see what information we can get. Click on the <code>User</code>, and save it under the <code>User</code> folder.</li>
				<li>Edit the request and put <code>http://localhost:5000/users/james</code> in the URL field. <strong class="bold">Save</strong> the request so that it can be reused later.</li>
				<li>Click <strong class="bold">Send</strong> to get the user details. The result is shown in the following screenshot:<div><img src="img/C15309_04_04.jpg" alt="Figure 4.4: Checking the user information without logging in&#13;&#10;"/></div><h6>Figure 4.4: Checking the user information without logging in</h6><p>You will then see the response. The HTTP Status is <strong class="bold">200 OK</strong>, meaning the request has been successful. We can see the ID and username in the response body. However, we can't see the email address here because it is private information and is only visible to the authenticated user. </p></li>
				<li>Now,<a id="_idTextAnchor156"/> log in through the API. Click on the <strong class="bold">Collections</strong> tab. Create a new folder called <strong class="bold">Token</strong> and create a new request called <strong class="bold">Token</strong> inside it.</li>
				<li>Edit the request, change the method to <code>http://localhost:5000/token</code> in the URL field.</li>
				<li>Click the <strong class="bold">Body</strong> tab, check the <strong class="bold">raw</strong> radio button, and select <strong class="bold">JSON (application/json)</strong> in the drop-down menu. Type in the following JSON content in the <strong class="bold">Body</strong> field and click <strong class="bold">Save</strong>:<pre>{
    "email": "james@gmail.com",
    "password": "WkQad19"
}</pre></li>
				<li>Click <strong class="bold">Send</strong> to log in. The result is shown in the following screenshot:<div><img src="img/C15309_04_05.jpg" alt="Figure 4.5: Checking the user information after creating tokens&#13;&#10;"/></div><h6>Figure 4.5: Checking the user information after creating tokens</h6><p>You will then see the response. The HTTP status code <strong class="bold">200</strong> means the login has been successful. We can see the access token in the response body. We will rely on this token to show that the user has logged in.</p></li>
				<li>Now c<a id="_idTextAnchor157"/>heck the user information again after we have logged in. Click the <strong class="bold">Collections</strong> tab and select the <strong class="bold">GET User</strong> request. </li>
				<li>Select the <code>Bearer {token}</code> in the <strong class="bold">VALUE</strong> field, where the token is what we obtained in step 10.</li>
				<li>Click <strong class="bold">Send</strong> to get the user details. The result is shown in the following screenshot:<div><img src="img/C15309_04_06.jpg" alt="Figure 4.6: Checking the user information after logging in&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 4.6: Checking the user information after logging in</h6>
			<p>You will then see the response, the HTTP status code <strong class="bold">200</strong> means the request is successful. And in the response body, we can see information including <strong class="bold">id</strong>, <strong class="bold">username</strong>, and <strong class="bold">email</strong>.</p>
			<p>In this exercise, we can see how access control really works. We can see the difference in the HTTP response before and after the user is authenticated. This is very important for our Smilecook application because we want to protect our users' privacy. There is information that only certain authenticated users can see.</p>
			<h3 id="_idParaDest-87"><a id="_idTextAnchor158"/>Exercise 26: Creating the me Endpoint</h3>
			<p>In this exercise, we will create a special endpoint, <code>/users/me</code>. That will allow us to get the authenticated user information back by using <code>access_token</code>. We will first create a new <code>resource</code> class under the <code>user</code> model. There will be a <code>get</code> method in it, and we will finally associate this with the new API endpoint:</p>
			<ol>
				<li value="1"> Add the <code>get_by_id</code> method in <code>models/user.py</code>. For convenience's sake, we will use this method to get the user object by ID:<pre>@classmethod 
def get_by_id(cls, id):         
        return cls.query.filter_by(id=id).first() </pre></li>
				<li>In <code>resources/user.py</code>, import <code>jwt_required</code> and create a <code>MeResource</code> class:<pre>from flask_jwt_extended import jwt_optional, get_jwt_identity, jwt_required
class MeResource(Resource):
    @jwt_required
    def get(self):
        user = User.get_by_id(id=get_jwt_identity())
        data = {
                'id': user.id,
                'username': user.username,
                'email': user.email,
        }
        return data, HTTPStatus.OK</pre><p>The <code>get</code> method here will get the user information by the ID in the JWT. </p></li>
				<li>In <code>app.py</code>, import the <code>MeResource</code> class. Add the <code>/me</code> endpoint:<pre>from resources.user import UserListResource, UserResource, MeResource
api.add_resource(MeResource, '/me')</pre></li>
				<li>Right-click on it to run the application. <strong class="bold">Flask</strong> will then be started up and run on localhost (<strong class="bold">127.0.0.1</strong>) at port <strong class="bold">5000</strong>:<div><img src="img/C15309_03_07.jpg" alt="Figure 4.7: Run the application to start and run the Flask on localhost&#13;&#10;"/></div><h6>Figure 4.7: Run the application to start and run the Flask on localhost</h6></li>
				<li>Now check the user information again after we have logged in using the users/me endpoint. Click on the <strong class="bold">Collections</strong> tab and create a new request called <strong class="bold">Me</strong> in the <strong class="bold">User</strong> folder.</li>
				<li>Put <code>http://localhost:5000/me</code> in the URL field. </li>
				<li>Select the <code>Bearer {token}</code> in the <strong class="bold">VALUE</strong> field, where the token is what we obtained in the previous exercise.</li>
				<li>Click <strong class="bold">Send</strong> to get the user details. The result is shown in the following screenshot: <div><img src="img/C15309_04_08.jpg" alt="Figure 4.8: Checking the user information after we have logged in&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 4.8: Checking the user information after we have logged in</h6>
			<p>This new API endpoint allows us to get the authenticated user information just by using the access token. This means that whenever the user is in the authenticated state, we can get their information. Now that we have pretty much figured out the users, let's work on the recipes.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor159"/>Designing the Methods in the Recipe Model</h2>
			<p>Now, we have finished the user registration and login feature, we will work on the recipe management features of our Smilecook application. That will need a few methods in the <code>Recipe</code> class to do the work. In our design, we will have the following five methods:</p>
			<ul>
				<li><code>data</code>: This is used to return the data in a dictionary format.</li>
				<li><code>get_all_published</code>: This method gets all the published recipes.</li>
				<li><code>get_by_id</code>: This method gets the recipes by ID.</li>
				<li><code>save</code>: This method persists data to the database.</li>
				<li><code>delete</code>: This method deletes data from the database.</li>
			</ul>
			<p>These fi<a id="_idTextAnchor160"/>ve methods cover pretty much all the necessary recipe management functions. In the next exercise, we will work on implementing these methods in our Smilecook application.</p>
			<h3 id="_idParaDest-89"><a id="_idTextAnchor161"/>Exercise 27: Implementing Access-Controlled Recipe Management Functions</h3>
			<p>The aim of this exercise is to implement different recipe management functions on our platform so that users can manage their own recipes in our Smilecook application. We will also have to modify <code>RecipeListResource</code> and <code>RecipeResource</code> to restrict access to certain methods there:</p>
			<ol>
				<li value="1">In <code>model<a id="_idTextAnchor162"/>s/recipe.py</code>, add the <code>data</code>, <code>get_all_published</code>, <code>get_by_id</code>, <code>save</code>, and <code>delete</code> methods to the <code>Recipe</code> class:<pre>    def data(self):
        return {
            'id': self.id,
            'name': self.name,
            'description': self.description,
            'num_of_servings': self.num_of_servings,
            'cook_time': self.cook_time,
            'directions': self.directions,
            'user_id': self.user_id
        }
    @classmethod
    def get_all_published(cls):
        return cls.query.filter_by(is_publish=True).all()
    @classmethod
    def get_by_id(cls, recipe_id):
        return cls.query.filter_by(id=recipe_id).first()
    def save(self):
        db.session.add(self)
        db.session.commit()
    def delete(self):
        db.session.delete(self)
        db.session.commit()</pre></li>
				<li>Delete the following code in <code>models/recipe.py</code>:<pre>recipe_list = []
  
def get_last_id():
    if recipe_list:
        last_recipe = recipe_list[-1]
    else:
        return 1
    return last_recipe.id + 1</pre></li>
				<li>In <code>resources/recipe.py</code>, import <code>get_jwt_identity</code>, <code>jwt_required</code>, and <code>jwt_optional</code>:<pre>from flask_jwt_extended import get_jwt_identity, jwt_required, jwt_optional</pre></li>
				<li>Remove import <code>recipe_list</code><pre>from models.recipe import Recipe</pre></li>
				<li>We will <a id="_idTextAnchor163"/><a id="_idTextAnchor164"/>then modify the <code>get</code> method in the <code>RecipeListResource</code> class. We will get all the published recipes by triggering <code>Recipe.get_all_published()</code>.Then, in the <code>for</code> loop, it iterates through the recipe list, converts each recipe into a dictionary object, and returns the dictionary list:<pre>class RecipeListResource(Resource):
    def get(self):
        recipes = Recipe.get_all_published()
        data = []
        for recipe in recipes:
            data.append(recipe.data())
         return {'data': data}, HTTPStatus.OK</pre></li>
				<li>We then continue to modify the <code>post</code> method in the <code>RecipeListResource</code> class. The <code>@jwt_required</code> decorator here says that the method can only be invoked after the user has logged in. Inside the method, it gets all the recipe details from the client requests and saves them in the database. Finally, it will return the data with an HTTP status code of <strong class="bold">201 CREATED</strong>:<pre>    @jwt_required
    def post(self):
        json_data = request.get_json()
        current_user = get_jwt_identity()
        recipe = Recipe(name= json_data['name'],
                        description= json_data['description'],
                        num_of_servings= json_data['num_of_servings'],
                        cook_time= json_data['cook_time'],
                        directions= json_data['directions'],
                        user_id=current_user)
        recipe.save()
        return recipe.data(), HTTPStatus.CREATED</pre></li>
				<li>We will <a id="_idTextAnchor165"/><a id="_idTextAnchor166"/>modify the <code>get</code> method in <code>RecipeResource</code> to get a specific recipe. The <code>@jwt_optional</code> decorator specifies that the JWT is optional. Inside the method, we use <code>Recipe.get_by_id(recipe_id=recipe_id)</code> to get the recipe. If the specific recipe is not found, we will return <strong class="bold">404 NOT_FOUND</strong>. If it is found, we will then change the user who owns the recipe and the status. There is access control here, so it will return <strong class="bold">403 FORBIDDEN</strong> or <strong class="bold">200 OK</strong> depending on the situation:<pre>class RecipeResource(Resource):
    @jwt_optional
    def get(self, recipe_id):
        recipe = Recipe.get_by_id(recipe_id=recipe_id)
        if recipe is None:
            return {'message': 'Recipe not found'}, HTTPStatus.NOT_FOUND
        current_user = get_jwt_identity()
        if recipe.is_publish == False and recipe.user_id != current_user:
            return {'message': 'Access is not allowed'}, HTTPStatus.FORBIDDEN
        return recipe.data(), HTTPStatus.OK</pre></li>
				<li>We will modify the <code>put</code> method in <code>RecipeResource</code> to get a specific recipe. This <code>put</code> method is to update the recipe details. It will first check whether the recipe exists and whether the user has update privileges. If everything is okay, it will go ahead to update the recipe details and save it to the database:<pre>    @jwt_required
    def put(self, recipe_id):
        json_data = request.get_json()
        recipe = Recipe.get_by_id(recipe_id=recipe_id)
        if recipe is None:
            return {'message': 'Recipe not found'}, HTTPStatus.NOT_FOUND
        current_user = get_jwt_identity()
        if current_user != recipe.user_id:
            return {'message': 'Access is not allowed'}, HTTPStatus.FORBIDDEN
        recipe.name = json_data['name']
        recipe.description = json_data['description']
        recipe.num_of_servings = json_data['num_of_servings']
        recipe.cook_time = json_data['cook_time']
        recipe.directions = json_data['directions']
        recipe.save()
        return recipe.data(), HTTPStatus.OK</pre></li>
				<li>We will modify the <code>delete</code> method in <code>RecipeResource</code> to get a specific recipe. This is for deleting a recipe. The <code>@jwt_required</code> decorator implies that the JWT is required. When the user has logged in, they can access this path and delete the specified recipe if it exists:<pre>    @jwt_required
    def delete(self, recipe_id):
        recipe = Recipe.get_by_id(recipe_id=recipe_id)
        if recipe is None:
            return {'message': 'Recipe not found'}, HTTPStatus.NOT_FOUND
        current_user = get_jwt_identity()
        if current_user != recipe.user_id:
            return {'message': 'Access is not allowed'}, HTTPStatus.FORBIDDEN
        recipe.delete()
        return {}, HTTPStatus.NO_CONTENT</pre></li>
			</ol>
			<p>So, in t<a id="_idTextAnchor167"/>his exercise, we have implemented the recipe management functions and added access control to the resources. Now, only authorized users are allowed to manage their recipes. Let's test whether this is really the case in our next exercise.</p>
			<h3 id="_idParaDest-90">Exercis<a id="_idTextAnchor168"/>e 28: Testing the Recipe Management Functions</h3>
			<p>The aim of this exercise is to test all the recipe management functions using Postman. We registered an account in our previous exercise and logged in. We will use the same authenticated user to test adding, updating, and deleting recipes:</p>
			<ol>
				<li value="1">Create a<a id="_idTextAnchor169"/> recipe through our API. Click on the <strong class="bold">Collections</strong> tab and select the <strong class="bold">POST RecipeList</strong> request that we created previously.</li>
				<li>Go to the <code>Bearer {token}</code> in the <strong class="bold">VALUE</strong> field, where the token is the JWT token we got in our previous exercise. The result is shown in the following screenshot:<div><img src="img/C15309_04_09.jpg" alt="Figure 4.9: Creating a recipe through the API&#13;&#10;"/></div><h6>Figure 4.9: Creating a recipe through the API</h6></li>
				<li>Go to the <strong class="bold">Body</strong> tab and type in the following recipe details:<pre>{
    "name": "Cheese Pizza",
    "description": "This is a lovely cheese pizza",
    "num_of_servings": 2,
    "cook_time": 30,
    "directions": "This is how you make it"
}</pre></li>
				<li>Click <code>user_id</code> is <strong class="bold">3</strong>, which is the user ID of the currently authenticated user. </p></li>
				<li>Get the re<a id="_idTextAnchor170"/>cipe with <code>id = 3</code> in the state that the user has logged in. Click on the <strong class="bold">Collections</strong> tab and select the <strong class="bold">GET</strong> recipe request that we created previously.</li>
				<li>Go to the <code>Bearer {token}</code> in the <strong class="bold">VALUE</strong> field, where the token is the JWT token we got in the previous exercise.</li>
				<li>Click <strong class="bold">Send</strong> to check the recipe. The result is shown in the following screenshot:<div><img src="img/C15309_04_11.jpg" alt="Figure 4.11: Recipe with ID 3 after the user is logged in&#13;&#10;"/></div><h6>Figure 4.<a id="_idTextAnchor171"/>11: Recipe with ID 3 after the user is logged in</h6><p>You will then see the response. We can see the recipe details in the body. That is because the user is authenticated.</p></li>
				<li>Get the re<a id="_idTextAnchor172"/><a id="_idTextAnchor173"/>cipe with <code>id = 3</code> in the state that the user has <em class="italics">not</em> logged in. The expected result is that we won't be able to see the unpublished recipe. Click on the <strong class="bold">Collections</strong> tab and select the <strong class="bold">GET Recipe</strong> request that we created previously.</li>
				<li>Go to the <strong class="bold">Headers</strong> tab and uncheck <strong class="bold">Authorization</strong>, meaning that we are not going to put in the JWT token. Click <strong class="bold">Send</strong> to check the recipe. The result is shown in the following screenshot:<div><img src="img/C15309_04_12.jpg" alt="Figure 4.12: Recipe with ID 3 and the user not logged in&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 4.12: Recipe with ID 3 and the user not logged in</h6>
			<p>You will then see the response; the HTTP status code is <strong class="bold">403 FORBIDDEN</strong>. This is because the recipe is unpublished and we have implemented access control on our API so that only authenticated users can see their own recipes in the draft. We see the message <strong class="bold">Access is not allowed</strong> because we have not logged in yet. The unpublished recipe is not available to the public.</p>
			<p>So, we have tested the access control recipe management functions. We can see how these can be used in real-world scenarios. Next, we will discuss refresh tokens, which are for keeping our users in the logged-in state.</p>
			<h2 id="_idParaDest-91">Refresh Toke<a id="_idTextAnchor174"/>ns</h2>
			<p>For the sake of security, we often set an expiration time for our tokens (<code>flask-jwt-extended</code> defaults that to 15 minutes). Because a token will expire, we need a function to refresh it without users putting in their credentials again.</p>
			<p>Flask-JWT-Extended provides refresh-token-related functions. A refresh token is a long-lived token that can be used to generate new access tokens. Please don't mix up refresh tokens and access tokens. A refresh token can only be used to obtain a new access token; it cannot be used as an access token to access restricted endpoints. For example, endpoints that have the <code>jwt_required()</code> or <code>jwt_optional()</code> decorators need an access token.</p>
			<p>Here's a brief explanation of the refresh-token-related functions in Flask-JWT-Extended:</p>
			<ul>
				<li><code>create_access_token</code>: This function creates a new access token.</li>
				<li><code>create_refresh_token</code>: This function creates a refresh token.</li>
				<li><code>jwt_refresh_token_required</code>: This is a decorator specifying that the refresh token is required.</li>
				<li><code>get_jwt_identity</code>: This function gets the user that holds the current access token.</li>
			</ul>
			<p>You will learn more about these functions in the next exercise. We will also add a <code>fresh</code> attribute to our token. This <code>fresh</code> attribute will only be set to <code>True</code> when users get the token by putting in their credentials. When they simply refresh the token, they will get a token with <code>fresh = false</code>. The reason for a refresh token is that we would like to avoid users having to put their credentials in again and again. However, for some critical functions, for example, changing passwords, we will still require them to have a fresh token.</p>
			<h3 id="_idParaDest-92">Exercise 29:<a id="_idTextAnchor175"/> Adding a Refresh Token Function</h3>
			<p>In this exercise, we will be adding a refresh token feature to our Smilecook application so that when the user's access token expires, they can use the refresh token to obtain a new access token:</p>
			<ol>
				<li value="1">In <code>resources<a id="_idTextAnchor176"/><a id="_idTextAnchor177"/>/token.py</code>, import the necessary functions from <code>flask_jwt_extended</code>:<pre>from flask_jwt_extended import (
    create_access_token,
    create_refresh_token,
    jwt_refresh_token_required,
    get_jwt_identity
)</pre></li>
				<li>Modify the <code>p<a id="_idTextAnchor178"/>ost</code> method under <code>TokenResource</code> to generate a <code>token</code> and a <code>refresh_token</code> for the user:<pre>    def post(self):
        data = request.get_json()
        email = data.get('email')
        password = data.get('password')
        user = User.get_by_email(email=email)
        if not user or not check_password(password, user.password):
            return {'message': 'username or password is incorrect'}, HTTPStatus.UNAUTHORIZED
        access_token = create_access_token(identity=user.id, fresh=True)
        refresh_token = create_refresh_token(identity=user.id)
        return {'access_token': access_token, 'refresh_token': refresh_token}, HTTPStatus.OK</pre><p>We pass in the <code>fresh=True</code> parameter to the <code>create_access_token</code> function. We then invoke the <code>create_refresh_token</code> function to generate a <code>refresh</code> token.</p></li>
				<li>Add the <code>Refr<a id="_idTextAnchor179"/>eshResource</code> class to <code>token.py</code>. Please add the following code:<pre>class RefreshResource(Resource):
    @jwt_refresh_token_required
    def post(self):
        current_user = get_jwt_identity()
        access_token = create_access_token(identity=current_user, fresh=False)
        return {access_token: access_token}, HTTPStatus.OK</pre><p>The <code>@jwt_refresh_token_required</code> decorator specifies that this endpoint will require a <code>refresh</code> token. In this method, we are generating a token for the user with <code>fresh=false</code>.</p></li>
				<li>Finally, add<a id="_idTextAnchor180"/><a id="_idTextAnchor181"/> the route for <code>RefreshResource</code>:<pre>from resources.token import TokenResource, RefreshResource
def register_resources(app):
    api.add_resource(RefreshResource, '/refresh')</pre></li>
				<li>Save <code>app.py</code> <a id="_idTextAnchor182"/>and right-click on it to run the application. <code>127.0.0.1</code>) at port <code>5000</code>:<div><img src="img/C15309_04_13.jpg" alt="Figure 4.13: Run the application to start and run Flask on localhost&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 4.13: Run the application to start and run Flask on localhost</h6>
			<p>Congratulations! We have just added the refresh token function. Let's move on to the testing part.</p>
			<h3 id="_idParaDest-93">Exercise 30: <a id="_idTextAnchor183"/>Obtaining a New Access Token Using a Refresh Token</h3>
			<p>In this exercise, we will be using Postman to log in to the user account and get the access token and refresh token. Later on, we will obtain a new access token by using the refresh token. This is to simulate a real-life scenario in which we want to keep the user logged in:</p>
			<ol>
				<li value="1">We will test logging first. Click on the <strong class="bold">Collections</strong> tab. Select the <strong class="bold">POST Token</strong> request that we created previously.</li>
				<li>Check the <strong class="bold">raw</strong> radio button and select <strong class="bold">JSON (application/json)</strong> from the drop-down menu.</li>
				<li>Add the following JSON content in the <strong class="bold">Body</strong> field:<pre>{
    "email": "james@gmail.com",
    "password": "WkQad19"
}</pre></li>
				<li>Click <strong class="bold">Send</strong> to login to the account. The result is shown in the following screenshot:<div><img src="img/C15309_04_14.jpg" alt="Figure 4.14: Testing the login&#13;&#10;"/></div><h6>Figure 4.14: Testing the login</h6><p>We can see that the HTTP status code is <strong class="bold">200 OK</strong>, meaning the login has been successful. We can also see the access token and refresh token in the body.</p></li>
				<li>Next, we will<a id="_idTextAnchor184"/> get the <code>access</code> token by using the <code>refresh</code> token. Click on the <strong class="bold">Collections</strong> tab. Create a new request, name it <strong class="bold">Refresh</strong>, and save it in the <strong class="bold">Token</strong> folder.</li>
				<li>Select this new request and choose <code>http://localhost:5000/refresh</code> in the <strong class="bold">URL</strong> field. </li>
				<li>Go to the <code>Bearer {token}</code> in the <strong class="bold">VALUE</strong> field, where the token is the <strong class="bold">JWT</strong> we got in step 4.</li>
				<li>Click <strong class="bold">Send</strong> to refresh the token. The result is shown in the following screenshot:<div><img src="img/C15309_04_15.jpg" alt="Figure 4.15: Accessing the token using the refresh token&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 4.15: Accessing the token using the refresh token</h6>
			<p>We can see HTTP status <strong class="bold">200 OK</strong>, which means the request has been successful. And we can see the new access token in the response body. If the access token expires in the future, we can use a refresh token to obtain a new access token.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor185"/>The User Logout Mechanism</h2>
			<p>The Flask-JWT-E<a id="_idTextAnchor186"/>xtended package supports the logout function. The way it works is to put the token into a blacklist when the user is logged out. A <code>token_in_blacklist_loader</code> to verify whether the user has logged out or not:</p>
			<div><div><img src="img/C15309_04_16.jpg" alt="Figure 4.16: The user logout mechanism using a blacklist&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 4.16: The user logout mechanism using a blacklist</h6>
			<p>In the next exercise, we want you to try implementing this logout function. It will test your understanding of the login and logout flow.</p>
			<h3 id="_idParaDest-95"><a id="_idTextAnchor187"/>Exercise 31: Implementing the Logout Function</h3>
			<p>In this exercise, we will implement the logout function. We will first declare a <code>black_list</code> to store all the <strong class="bold">logged-out</strong> access tokens. Later, when the user wants to visit the access-controlled API endpoints, we will first check whether the access token is still valid using the blacklist:</p>
			<ol>
				<li value="1">Import <code>get_raw_j<a id="_idTextAnchor188"/>wt</code>. In <code>resources/token.py</code>, we will import <code>jwt_required</code> and <code>get_raw_jwt</code> from <code>flask_jwt_extended</code>:<pre>from flask_jwt_extended import (
    create_access_token,
    create_refresh_token,
    jwt_refresh_token_required,
    get_jwt_identity,
    jwt_required,
    get_raw_jwt
)</pre></li>
				<li>In <code>resources/tok<a id="_idTextAnchor189"/>en.py</code>, assign <code>set()</code> to <code>black_list</code>:<pre>black_list = set()</pre></li>
				<li>Create the <code>Revok<a id="_idTextAnchor190"/>eResource</code> class and define the <code>post</code> method. We will apply the <code>@jwt_required</code> decorator here to control the access to this endpoint. In this method, we get the token using <code>get_raw_jwt()['jti']</code> and put it in the blacklist:<pre>class RevokeResource(Resource):
    @jwt_required
    def post(self):
        jti = get_raw_jwt()['jti']
        black_list.add(jti)
         return {'message': 'Successfully logged out'}, HTTPStatus.OK</pre></li>
				<li>We will then add<a id="_idTextAnchor191"/> the following code in <code>config.py</code>. As you can tell, we are enabling the blacklist feature and also telling the application to check both the <code>access</code> and <code>refresh</code> token:<pre>class Config:
    JWT_BLACKLIST_ENABLED = True
    JWT_BLACKLIST_TOKEN_CHECKS = ['access', 'refresh']</pre></li>
				<li>We will then import <code>RevokeResource</code> and <code>black_list</code> in <code>app.py</code>:<pre>from resources.token import TokenResource, RefreshResource, RevokeResource, black_list</pre></li>
				<li>Then, inside <code>register_extensions(app)</code>, we will add the following lines of code. This is to check whether the token is on the blacklist:<pre>def register_extensions(app):
    db.app = app
    db.init_app(app)
    migrate = Migrate(app, db)
    jwt.init_app(app)
    @jwt.token_in_blacklist_loader
    def check_if_token_in_blacklist(decrypted_token):
        jti = decrypted_token['jti']
        return jti in black_list</pre></li>
				<li>Finally, add the<a id="_idTextAnchor192"/> route in <code>register_resources</code>:<pre>def register_resources(app):
    api.add_resource(TokenResource, '/token')
    api.add_resource(RefreshResource, '/refresh')
    api.add_resource(RevokeResource, '/revoke')</pre></li>
				<li>Save <code>app.py</code> and right-click on it to run the application. <strong class="bold">Flask</strong> will then be started up and run on localhost (<strong class="bold">127.0.0.1</strong>) at port <strong class="bold">5000</strong>:<div><img src="img/C15309_04_17.jpg" alt="Figure 4.17: Run the application to start Flask&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 4.17: Run the application to start Flask</h6>
			<p>Once the server is started, that means we are ready to test our refresh token API.</p>
			<h3 id="_idParaDest-96">Exercise 32: Test<a id="_idTextAnchor193"/>ing the Logout Function</h3>
			<p>In this exercise, we are going to test the logout function that we have just implemented in the previous exercise. Once we have logged out, we will try accessing an access-controlled endpoint and make sure we no longer have access to it:</p>
			<ol>
				<li value="1">We will log out from our application. Click on the <strong class="bold">Collections</strong> tab and create a new request, name it <strong class="bold">Revoke</strong>, and save it in the <strong class="bold">Token</strong> folder.</li>
				<li>Select this new request and choose <code>http://localhost:5000/revoke</code> in the URL field.</li>
				<li>Go to the <code>Bearer {token}</code> in the <strong class="bold">VALUE</strong> field, where the token is the JWT we got in the previous exercise.</li>
				<li>Click <strong class="bold">Send</strong> to log out. The result is shown in the following screenshot:<div><img src="img/C15309_04_18.jpg" alt="Figure 4.18: Logging out from the application&#13;&#10;"/></div><h6>Figure 4.18: Logging out from the application</h6><p>You will then see the response, HTTP status <strong class="bold">200 OK</strong>, meaning that the user has logged out successfully. Besides this, we can also see the message saying that the user has <strong class="bold">successfully logged out</strong>.</p></li>
				<li>Log out again and <a id="_idTextAnchor194"/>see what happens. Click <strong class="bold">Send</strong> again, and you will then see the following response:<div><img src="img/C15309_04_19.jpg" alt="Figure 4.19: Logging out again&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 4.19: Logging out again</h6>
			<p>We can see HTTP status <strong class="bold">401 UNAUTHORIZED</strong>, meaning the user doesn't have access to this endpoint because the original access token has already been placed on the blacklist. In the response body, we can see the message <strong class="bold">Token has been revoked</strong>, meaning the user has successfully logged out.</p>
			<h3 id="_idParaDest-97"><a id="_idTextAnchor195"/>Activity 7: Implementing Access Control on the publish/unpublish Recipe Function</h3>
			<p>In this activity, we will implement access control on the <code>publish</code>/<code>unpublish</code> recipe API endpoint so that only authenticated users can <code>publish</code>/<code>unpublish</code> their own recipe. Follow these steps to complete the activity:</p>
			<ol>
				<li value="1">Modify the <code>put</code> method in <code>RecipePublishResource</code> to restrict access to authenticated users.</li>
				<li>Modify the <code>delete</code> method in <code>RecipePublishResource</code>.</li>
				<li>Log in to the user account and get the access token.</li>
				<li>Publish the recipe with <code>id = 3</code> in the state that the user has logged in.</li>
				<li>Unpublish a recipe <code>id = 3</code> in the state that the user has logged in<h4>Note</h4><p class="callout">The solution for this activity can be found on page 307.</p></li>
			</ol>
			<p>If you got everything right, congratulations! That means you have added access control to the publish and unpublish recipe function. Now, recipes are protected in the Smilecook application. Only the authors of the recipes can manage their own recipes now.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor196"/>Summary</h2>
			<p>In this chapter, we learned how to use Flask-JWT-Extended for access control. This is an important and fundamental feature that almost all online platforms will require. At the end of the chapter, we touched on the topic of maintaining the liveliness of a token. This is advanced but applicable knowledge that you will use in developing real-life RESTful APIs. In the next chapter, we will start to talk about data verification.</p>
		</div>
	</body></html>