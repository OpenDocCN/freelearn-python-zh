- en: Chapter 1. Sockets, IPv4, and Simple Client/Server Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Printing your machine's name and IPv4 address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving a remote machine's IP address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting an IPv4 address to different formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding a service name, given the port and protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting integers to and from host to network byte order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting and getting the default socket timeout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling socket errors gracefully
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying a socket's send/receive buffer size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing a socket to the blocking/non-blocking mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusing socket addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing the current time from the Internet time server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a SNTP client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a simple echo client/server application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter introduces Python''s core networking library through some simple
    recipes. Python''s `socket` module has both class-based and instances-based utilities.
    The difference between a class-based and instance-based method is that the former
    doesn''t need an instance of a socket object. This is a very intuitive approach.
    For example, in order to print your machine''s IP address, you don''t need a socket
    object. Instead, you can just call the socket''s class-based methods. On the other
    hand, if you need to send some data to a server application, it is more intuitive
    that you create a socket object to perform that explicit operation. The recipes
    presented in this chapter can be categorized into three groups as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first few recipes, the class-based utilities have been used in order
    to extract some useful information about host, network, and any target service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, some more recipes have been presented using the instance-based utilities.
    Some common socket tasks, including manipulating the socket timeout, buffer size,
    blocking mode, and so on, have been demonstrated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, both class-based and instance-based utilities have been used to construct
    some clients, which perform some practical tasks, for example, synchronizing the
    machine time with an Internet server or writing a generic client/server script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use these demonstrated approaches to write your own client/server application.
  prefs: []
  type: TYPE_NORMAL
- en: Printing your machine's name and IPv4 address
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you need to quickly discover some information about your machine,
    for example, the host name, IP address, number of network interfaces, and so on.
    This is very easy to achieve using Python scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to install Python on your machine before you start coding. Python
    comes preinstalled in most of the Linux distributions. For Microsoft Windows operating
    system, you can download binaries from the Python website: [http://www.python.org/download/](http://www.python.org/download/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may consult the documentation of your OS to check and review your Python
    setup. After installing Python on your machine, you can try opening the Python
    interpreter from the command line by typing `python`. This will show the interpreter
    prompt, `>>>`, which should be similar to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As this recipe is very short, you can try this in the Python interpreter interactively.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import the Python `socket` library with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we call the `gethostname()` method from the `socket` library and store
    the result in a variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The entire activity can be wrapped in a free-standing function, `print_machine_info()`,
    which uses the built-in socket class methods.
  prefs: []
  type: TYPE_NORMAL
- en: We call our function from the usual Python `__main__` block. During runtime,
    Python assigns values to some internal variables such as `__name__`. In this case,
    `__name__` refers to the name of the calling process. When running this script
    from the command line, as shown in the following command, the name will be `__main__`,
    but it will be different if the module is imported from another script. This means
    that when the module is called from the command line, it will automatically run
    our `print_machine_info` function; however, when imported separately, the user
    will need to explicitly call the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 1.1 shows how to get our machine info, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to run this recipe, you can use the provided source file from the
    command line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'On my machine, the following output is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This output will be different on your machine depending on the system's host
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The import socket statement imports one of Python''s core networking libraries.
    Then, we use the two utility functions, `gethostname()` and `gethostbyname(host_name)`.
    You can type `help(socket.gethostname)` to see the online help information from
    within the command line. Alternately, you can type the following address in your
    web browser at [http://docs.python.org/3/library/socket.html](http://docs.python.org/3/library/socket.html).
    You can refer to the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first function takes no parameter and returns the current or localhost name.
    The second function takes a single `hostname` parameter and returns its IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving a remote machine's IP address
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you need to translate a machine's hostname into its corresponding
    IP address, for example, a quick domain name lookup. This recipe introduces a
    simple function to do that.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need to know the IP address of a remote machine, you can use a built-in
    library function, `gethostbyname()`. In this case, you need to pass the remote
    hostname as its parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we need to call the `gethostbyname()` class function. Let's have
    a look inside this short code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 1.2 shows how to get a remote machine''s IP address as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding code it gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe wraps the `gethostbyname()` method inside a user-defined function
    called `get_remote_machine_info()`. In this recipe, we introduced the notion of
    exception handling. As you can see, we wrapped the main function call inside a
    `try-except` block. This means that if some error occurs during the execution
    of this function, this error will be dealt with by this `try-except` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s change the `remote_host` value and replace [www.python.org](http://www.python.org)
    with something non-existent, for example, `www.pytgo.org`. Now run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `try-except` block catches the error and shows the user an error message
    that there is no IP address associated with the hostname, `www.pytgo.org`.
  prefs: []
  type: TYPE_NORMAL
- en: Converting an IPv4 address to different formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you would like to deal with low-level network functions, sometimes, the
    usual string notation of IP addresses are not very useful. They need to be converted
    to the packed 32-bit binary formats.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Python socket library has utilities to deal with the various IP address
    formats. Here, we will use two of them: `inet_aton()` and `inet_ntoa()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us create the `convert_ip4_address()` function, where `inet_aton()` and
    `inet_ntoa()` will be used for the IP address conversion. We will use two sample
    IP addresses, `127.0.0.1` and `192.168.0.1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 1.3 shows `ip4_address_conversion` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you run this recipe, you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, the two IP addresses have been converted from a string to a
    32-bit packed format using a `for-in` statement. Additionally, the Python `hexlify`
    function is called from the `binascii` module. This helps to represent the binary
    data in a hexadecimal format.
  prefs: []
  type: TYPE_NORMAL
- en: Finding a service name, given the port and protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you would like to discover network services, it may be helpful to determine
    what network services run on which ports using either the TCP or UDP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you know the port number of a network service, you can find the service name
    using the `getservbyport()` socket class function from the socket library. You
    can optionally give the protocol name when calling this function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us define a `find_service_name()` function, where the `getservbyport()`
    socket class function will be called with a few ports, for example, `80, 25`.
    We can use Python's `for-in` loop construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 1.4 shows `finding_service_name` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this script, you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, `for-in` statement is used to iterate over a sequence of variables.
    So for each iteration we use one IP address to convert them in their packed and
    unpacked format.
  prefs: []
  type: TYPE_NORMAL
- en: Converting integers to and from host to network byte order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you ever need to write a low-level network application, it may be necessary
    to handle the low-level data transmission over the wire between two machines.
    This operation requires some sort of conversion of data from the native host operating
    system to the network format and vice versa. This is because each one has its
    own specific representation of data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python's socket library has utilities for converting from a network byte order
    to host byte order and vice versa. You may want to become familiar with them,
    for example, `ntohl()`/`htonl()`.
  prefs: []
  type: TYPE_NORMAL
- en: Let us define the `convert_integer()` function, where the `ntohl()`/`htonl()`
    socket class functions are used to convert IP address formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 1.5 shows `integer_conversion` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this recipe, you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we take an integer and show how to convert it between network and host
    byte orders. The `ntohl()` socket class function converts from the network byte
    order to host byte order in a long format. Here, `n` represents network and `h`
    represents host; `l` represents long and `s` represents short, that is 16-bit.
  prefs: []
  type: TYPE_NORMAL
- en: Setting and getting the default socket timeout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you need to manipulate the default values of certain properties of
    a socket library, for example, the socket timeout.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can make an instance of a socket object and call a `gettimeout()` method
    to get the default timeout value and the `settimeout()` method to set a specific
    timeout value. This is very useful in developing custom server applications.
  prefs: []
  type: TYPE_NORMAL
- en: We first create a socket object inside a `test_socket_timeout()` function. Then,
    we can use the getter/setter instance methods to manipulate timeout values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 1.6 shows `socket_timeout` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the preceding script, you can see how this modifies the default
    socket timeout as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this code snippet, we have first created a socket object by passing the socket
    family and socket type as the first and second arguments of the socket constructor.
    Then, you can get the socket timeout value by calling `gettimeout()` and alter
    the value by calling the `settimeout()` method. The timeout value passed to the
    `settimeout()` method can be in seconds (non-negative float) or `None`. This method
    is used for manipulating the blocking-socket operations. Setting a timeout of
    `None` disables timeouts on socket operations.
  prefs: []
  type: TYPE_NORMAL
- en: Handling socket errors gracefully
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any networking application, it is very common that one end is trying to connect,
    but the other party is not responding due to networking media failure or any other
    reason. The Python socket library has an elegant method of handing these errors
    via the `socket.error` exceptions. In this recipe, a few examples are presented.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us create a few try-except code blocks and put one potential error type
    in each block. In order to get a user input, the `argparse` module can be used.
    This module is more powerful than simply parsing command-line arguments using
    `sys.argv`. In the try-except blocks, put typical socket operations, for example,
    create a socket object, connect to a server, send data, and wait for a reply.
  prefs: []
  type: TYPE_NORMAL
- en: The following recipe illustrates the concepts in a few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 1.7 shows `socket_errors` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Python, passing command-line arguments to a script and parsing them in the
    script can be done using the `argparse` module. This is available in Python 2.7\.
    For earlier versions of Python, this module is available separately in **Python
    Package Index** (**PyPI**). You can install this via `easy_install` or `pip`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, three arguments are set up: a hostname, port number, and filename.
    The usage of this script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try with a non-existent host, this script will print an address error
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is no service on a specific port and if you try to connect to that
    port, then this will throw a connection timeout error as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the following error since the host, [www.python.org](http://www.python.org),
    is not listening on port 8080:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you send an arbitrary request to a correct request to a correct
    port, the error may not be caught in the application level. For example, running
    the following script returns no error, but the HTML output tells us what''s wrong
    with this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, four try-except blocks have been used. All blocks
    use `socket.error` except the second block, which uses `socket.gaierror`. This
    is used for address-related errors. There are two other types of exceptions: `socket.herror`
    is used for legacy C API, and if you use the `settimeout()` method in a socket,
    `socket.timeout` will be raised when a timeout occurs on that socket.'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying socket's send/receive buffer sizes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default socket buffer size may not be suitable in many circumstances. In
    such circumstances, you can change the default socket buffer size to a more suitable
    value.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us manipulate the default socket buffer size using a socket object's `setsockopt()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, define two constants: `SEND_BUF_SIZE`/`RECV_BUF_SIZE` and then wrap
    a socket instance''s call to the `setsockopt()` method in a function. It is also
    a good idea to check the value of the buffer size before modifying it. Note that
    we need to set up the send and receive buffer size separately.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 1.8 shows how to modify socket send/receive buffer sizes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding script, it will show the changes in the socket''s
    buffer size. The following output may be different on your machine depending on
    your operating system''s local settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can call the `getsockopt()` and `setsockopt()` methods on a socket object
    to retrieve and modify the socket object''s properties respectively. The `setsockopt()`
    method takes three arguments: `level`, `optname`, and `value`. Here, `optname`
    takes the option name and `value` is the corresponding value of that option. For
    the first argument, the needed symbolic constants can be found in the socket module
    (`SO_*etc.`).'
  prefs: []
  type: TYPE_NORMAL
- en: Changing a socket to the blocking/non-blocking mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, TCP sockets are placed in a blocking mode. This means the control
    is not returned to your program until some specific operation is complete. For
    example, if you call the `connect()` API, the connection blocks your program until
    the operation is complete. On many occasions, you don't want to keep your program
    waiting forever, either for a response from the server or for any error to stop
    the operation. For example, when you write a web browser client that connects
    to a web server, you should consider a stop functionality that can cancel the
    connection process in the middle of this operation. This can be achieved by placing
    the socket in the non-blocking mode.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us see what options are available under Python. In Python, a socket can
    be placed in the blocking or non-blocking mode. In the non-blocking mode, if any
    call to API, for example, `send()` or `recv()`, encounters any problem, an error
    will be raised. However, in the blocking mode, this will not stop the operation.
    We can create a normal TCP socket and experiment with both the blocking and non-blocking
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: In order to manipulate the socket's blocking nature, we need to create a socket
    object first.
  prefs: []
  type: TYPE_NORMAL
- en: We can then call `setblocking(1)` to set up blocking or `setblocking(0)` to
    unset blocking. Finally, we bind the socket to a specific port and listen for
    incoming connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 1.9 shows how the socket changes to blocking or non-blocking mode as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this recipe, it will launch a trivial server that has the blocking
    mode enabled as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we enable blocking on a socket by setting the value `1` in the
    `setblocking()` method. Similarly, you can unset the value `0` in this method
    to make it non-blocking.
  prefs: []
  type: TYPE_NORMAL
- en: This feature will be reused in some later recipes, where its real purpose will
    be elaborated.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing socket addresses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You want to run a socket server always on a specific port even after it is closed
    intentionally or unexpectedly. This is useful in some cases where your client
    program always connects to that specific server port. So, you don't need to change
    the server port.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you run a Python socket server on a specific port and try to rerun it after
    closing it once, you won''t be able to use the same port. It will usually throw
    an error like the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The remedy to this problem is to enable the socket reuse option, `SO_REUSEADDR`.
  prefs: []
  type: TYPE_NORMAL
- en: After creating a socket object, we can query the state of address reuse, say
    an old state. Then, we call the `setsockopt()` method to alter the value of its
    address reuse state. Then, we follow the usual steps of binding to an address
    and listening for incoming client connections. In this example, we catch the `KeyboardInterrupt`
    exception so that if you issue *Ctrl* + *C*, then the Python script gets terminated
    without showing any exception message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 1.10 shows how to reuse socket addresses as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this recipe will be similar to the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may run this script from one console window and try to connect to this server
    from another console window by typing `telnet localhost 8282`. After you close
    the server program, you can rerun it again on the same port. However, if you comment
    out the line that sets the `SO_REUSEADDR`, the server will not run for the second
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Printing the current time from the Internet time server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many programs rely on the accurate machine time, such as the `make` command
    in UNIX. Your machine time may be different and need synchronizing with another
    time server in your network.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to synchronize your machine time with one of the Internet time servers,
    you can write a Python client for that. For this, `ntplib` will be used. Here,
    the client/server conversation will be done using **Network Time Protocol** (**NTP**).
    If `ntplib` is not installed on your machine, you can get it from `PyPI` with
    the following command using `pip` or `easy_install`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We create an instance of `NTPClient` and then we call the `request()` method
    on it by passing the NTP server address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 1.11shows how to print the current time from the Internet time server
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In my machine, this recipe shows the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, an NTP client has been created and an NTP request has been sent to one
    of the Internet NTP servers, `pool.ntp.org`. The `ctime()` function is used for
    printing the response.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a SNTP client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike the previous recipe, sometimes, you don't need to get the precise time
    from the NTP server. You can use a simpler version of NTP called simple network
    time protocol.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us create a plain SNTP client without using any third-party library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us first define two constants: `NTP_SERVER` and `TIME1970\. NTP_SERVER`
    is the server address to which our client will connect, and `TIME1970` is the
    reference time on January 1, 1970 (also called *Epoch*). You may find the value
    of the Epoch time or convert to the Epoch time at [http://www.epochconverter.com/](http://www.epochconverter.com/).
    The actual client creates a UDP socket (`SOCK_DGRAM`) to connect to the server
    following the UDP protocol. The client then needs to send the SNTP protocol data
    (`''\x1b'' + 47 * ''\0''`) in a packet. Our UDP client sends and receives data
    using the `sendto()` and `recvfrom()` methods.'
  prefs: []
  type: TYPE_NORMAL
- en: When the server returns the time information in a packed array, the client needs
    a specialized `struct` module to unpack the data. The only interesting data is
    located in the 11th element of the array. Finally, we need to subtract the reference
    value, `TIME1970`, from the unpacked value to get the actual current time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 1.11 shows how to write an SNTP client as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe prints the current time from the Internet time server received
    with the SNTP protocol as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This SNTP client creates a socket connection and sends the protocol data. After
    receiving the response from the NTP server (in this case, `0.uk.pool.ntp.org`),
    it unpacks the data with `struct`. Finally, it subtracts the reference time, which
    is January 1, 1970, and prints the time using the `ctime()` built-in method in
    the Python time module.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a simple echo client/server application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After testing with basic socket APIs in Python, let us create a socket server
    and client now. Here, you will have the chance to utilize your basic knowledge
    gained in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, a server will echo whatever it receives from the client. We
    will use the Python `argparse` module to specify the TCP port from a command line.
    Both the server and client script will take this argument.
  prefs: []
  type: TYPE_NORMAL
- en: First, we create the server. We start by creating a TCP socket object. Then,
    we set the reuse address so that we can run the server as many times as we need.
    We bind the socket to the given port on our local machine. In the listening stage,
    we make sure we listen to multiple clients in a queue using the backlog argument
    to the `listen()` method. Finally, we wait for the client to be connected and
    send some data to the server. When the data is received, the server echoes back
    the data to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 1.13a shows how to write a simple echo client/server application as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: On the client-side code, we create a client socket using the port argument and
    connect to the server. Then, the client sends the message, `Test message. This
    will be echoed` to the server, and the client immediately receives the message
    back in a few segments. Here, two try-except blocks are constructed to catch any
    exception during this interactive session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 1-13b shows the echo client as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to see the client/server interactions, launch the following server
    script in one console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the client from another terminal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon connecting to the localhost, the client server will also print the following
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
