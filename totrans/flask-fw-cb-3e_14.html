<html><head></head><body>
<div id="_idContainer106">
<h1 class="chapter-number" id="_idParaDest-394"><a id="_idTextAnchor758"/><a id="_idTextAnchor759"/><span class="koboSpan" id="kobo.1.1">14</span></h1>
<h1 id="_idParaDest-395"><a id="_idTextAnchor760"/><span class="koboSpan" id="kobo.2.1">Additional Tips and Tricks</span></h1>
<p><span class="koboSpan" id="kobo.3.1">This book has covered almost all the areas that need to be known for the creation of a web application using Flask. </span><span class="koboSpan" id="kobo.3.2">Much has been covered, and a lot more needs to be explored. </span><span class="koboSpan" id="kobo.3.3">In this final chapter, we will go through some additional recipes that can be used to add value to a Flask-based web application if and </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">when needed.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We will learn how to implement full-text search using Elasticsearch. </span><span class="koboSpan" id="kobo.5.2">Full-text search becomes important for a web application that offers a lot of content and options, such as an e-commerce site. </span><span class="koboSpan" id="kobo.5.3">Next, we will catch up on signals that help decouple applications by sending notifications (signals) when an action is performed somewhere in the application. </span><span class="koboSpan" id="kobo.5.4">This signal is caught by a subscriber/receiver that can perform an action accordingly. </span><span class="koboSpan" id="kobo.5.5">This is followed by implementing caching for our </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">Flask application.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">We will also see how email support is added to our application and how emails can be sent directly from the application by performing different actions. </span><span class="koboSpan" id="kobo.7.2">We will then see how we can make our application asynchronous. </span><span class="koboSpan" id="kobo.7.3">By default, WSGI applications are synchronous and blocking – that is, by default, they do not serve multiple simultaneous requests together. </span><span class="koboSpan" id="kobo.7.4">We will see how to deal with this via a small example. </span><span class="koboSpan" id="kobo.7.5">We will also integrate Celery with our application and see how a task queue can be used to our </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">application’s benefit.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">following recipes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Implementing full-text search </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">with Elasticsearch</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Working </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">with signals</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Using caching with </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">your application</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Implementing </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">email support</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">asynchronous operations</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Working </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">with Celery</span></span></li>
</ul>
<h1 id="_idParaDest-396"><a id="_idTextAnchor761"/><span class="koboSpan" id="kobo.23.1">Implementing full-text search with Elasticsearch</span></h1>
<p><a id="_idTextAnchor762"/><span class="koboSpan" id="kobo.24.1">Full-text search is an essential</span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.25.1"> part of almost all use cases</span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.26.1"> that are catered to via web applications. </span><span class="koboSpan" id="kobo.26.2">It becomes much more crucial if you intend to build an e-commerce platform or something similar where search plays a central role. </span><span class="koboSpan" id="kobo.26.3">Full-text search means an ability to search some text inside a large amount of textual data where the search results can contain full or partial matches as </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">per configuration.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.28.1">Elasticsearch</span></strong><span class="koboSpan" id="kobo.29.1"> is a search server based on Lucene, which</span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.30.1"> is an open source information-retrieval library. </span><span class="koboSpan" id="kobo.30.2">Elasticsearch provides a distributed full-text search engine with a RESTful web interface and schema-free JSON documents. </span><span class="koboSpan" id="kobo.30.3">In this recipe, we will implement full-text search using Elasticsearch for our </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">Flask applicatio</span><a id="_idTextAnchor763"/><span class="koboSpan" id="kobo.32.1">n.</span></span></p>
<h2 id="_idParaDest-397"><a id="_idTextAnchor764"/><span class="koboSpan" id="kobo.33.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.34.1">We will use a Python library called </span><strong class="source-inline"><span class="koboSpan" id="kobo.35.1">elasticsearch</span></strong><span class="koboSpan" id="kobo.36.1">, which makes dealing with Elasticsearch a </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">lot easier:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.38.1">
$ pip install elasticsearch</span></pre>
<p><span class="koboSpan" id="kobo.39.1">We also need to install the Elasticsearch</span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.40.1"> server itself. </span><span class="koboSpan" id="kobo.40.2">This can be downloaded from </span><a href="https://www.elastic.co/downloads/elasticsearch"><span class="koboSpan" id="kobo.41.1">https://www.elastic.co/downloads/elasticsearch</span></a><span class="koboSpan" id="kobo.42.1">. </span><span class="koboSpan" id="kobo.42.2">Unpack the package at any location of your choice on your machine and run the </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.44.1">
$ bin/elasticsearch</span></pre>
<p><span class="koboSpan" id="kobo.45.1">This will start the Elasticsearch server on </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">http://localhost:9200/</span></strong><span class="koboSpan" id="kobo.47.1"> by default. </span><span class="koboSpan" id="kobo.47.2">There are a couple of details that you need to make note of before </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">moving ahead:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.49.1">When you run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">elasticsearch</span></strong><span class="koboSpan" id="kobo.51.1"> server using the preceding command, you will see some details as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">following screenshot:</span></span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer105">
<span class="koboSpan" id="kobo.53.1"><img alt="Figure 14.1 – Elasticsearch security details" src="image/B19111_14_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.54.1">Figure 14.1 – Elasticsearch security details</span></p>
<p><span class="koboSpan" id="kobo.55.1">Make note of the password</span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.56.1"> for the elastic user</span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.57.1"> here. </span><span class="koboSpan" id="kobo.57.2">You can also choose to reset the password using the command specified in the preceding screenshot.</span></p>
<ul>
<li><span class="koboSpan" id="kobo.58.1">When you run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">elasticsearch</span></strong><span class="koboSpan" id="kobo.60.1"> server, it generates an HTTP CA certificate, which needs to be used while establishing a connection via our Flask application. </span><span class="koboSpan" id="kobo.60.2">You can find this certificate file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">config/certs</span></strong><span class="koboSpan" id="kobo.62.1"> folder of your </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">elasticsearch</span></strong><span class="koboSpan" id="kobo.64.1"> server folder. </span><span class="koboSpan" id="kobo.64.2">In most cases, it should be </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">&lt;path to your </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">elasticsearch folder&gt;/config/certs/http_ca.</span><a id="_idTextAnchor765"/><span class="koboSpan" id="kobo.67.1">crt</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">.</span></span></li>
</ul>
<h2 id="_idParaDest-398"><a id="_idTextAnchor766"/><span class="koboSpan" id="kobo.69.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.70.1">Follow these steps to perform the integration between Elasticsearch and our </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">Flask application:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.72.1">Start by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">elasticsearch</span></strong><span class="koboSpan" id="kobo.74.1"> object to the application’s configuration – that </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">is, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">my_app/__init__.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.78.1">
from elasticsearch import Elasticsearch</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.79.1">
es = Elasticsearch(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.80.1">
    'https://192.168.1.6:9200/',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.81.1">
    ca_certs='Users/apple/workspace/elasticsearch-</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.82.1">
      8.6.2/config/certs/http_ca.crt',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.83.1">
    verify_certs=False,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.84.1">
    basic_auth=("elastic", '8oJ7C3U8ipo0PE+-n1Ff')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.85.1">
)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.86.1">
es.indices.create(index='catalog', ignore=400)</span></pre></li>
</ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.87.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.88.1">You will notice that several configuration settings are used in the preceding code. </span><span class="koboSpan" id="kobo.88.2">I have used them directly while instantiating an </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">es</span></strong><span class="koboSpan" id="kobo.90.1"> object to make it easier for you to understand. </span><span class="koboSpan" id="kobo.90.2">In actual applications, these should come from configuration settings or </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">configuration files.</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">Here, we have</span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.93.1"> created an </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">es</span></strong><span class="koboSpan" id="kobo.95.1"> object</span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.96.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">Elasticsearch</span></strong><span class="koboSpan" id="kobo.98.1"> class, which accepts the server URL, HTTP CA certificate, and basic authentication using the username and password. </span><span class="koboSpan" id="kobo.98.2">The HTTP CA certificate and password were sourced in the steps outlined in the </span><em class="italic"><span class="koboSpan" id="kobo.99.1">Getting ready</span></em><span class="koboSpan" id="kobo.100.1"> section of this recipe. </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">verify_certs=False</span></strong><span class="koboSpan" id="kobo.102.1"> is required because my application is running on HTTP, while Elasticsearch runs on HTTPS. </span><span class="koboSpan" id="kobo.102.2">If your app also runs on HTTPS, then this flag would not be needed. </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">ignore=400</span></strong><span class="koboSpan" id="kobo.104.1"> will ignore any errors related to </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">resource_already_exists_exception</span></strong><span class="koboSpan" id="kobo.106.1"> that are raised, as this index has been created already.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.107.1">Next, we need to add a document to our Elasticsearch index. </span><span class="koboSpan" id="kobo.107.2">This can be done in views or models; however, in my opinion, the best way will be to add it in the model layer because it is more closely related to data rather than how it is displayed. </span><span class="koboSpan" id="kobo.107.3">We will do this in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">my_app/catalog/models.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.109.1"> file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.110.1">
from my_app import es</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.111.1">
class Product(db.Model):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.112.1">
    def add_index_to_es(self):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.113.1">
        es.index(index='catalog', document={</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.114.1">
            'name': self.name,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.115.1">
            'category': self.category.name</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.116.1">
        }, id=self.id)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.117.1">
        es.indices.refresh(index='catalog')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.118.1">
class Category(db.Model):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.119.1">
    def add_index_to_es(self):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.120.1">
        es.index('catalog', document={</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.121.1">
            'name': self.name,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.122.1">
        }, id=self.id)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.123.1">
        es.indices.refresh(index='catalog')</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.124.1">Here, in each </span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.125.1">of the models, we added </span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.126.1">a new method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">add_index_to_es()</span></strong><span class="koboSpan" id="kobo.128.1">, which will add the document that corresponds to the current </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">Product</span></strong><span class="koboSpan" id="kobo.130.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">Category</span></strong><span class="koboSpan" id="kobo.132.1"> object to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">catalog</span></strong><span class="koboSpan" id="kobo.134.1"> index. </span><span class="koboSpan" id="kobo.134.2">You might want to index different types of data in separate indexes to make the search more accurate. </span><span class="koboSpan" id="kobo.134.3">Finally, we refreshed our index so that the newly created index is available for searching.</span></p>
<p><span class="koboSpan" id="kobo.135.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">add_index_to_es()</span></strong><span class="koboSpan" id="kobo.137.1"> method can be called when we create, update, or delete a product or category.</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.138.1">Next, for demonstration, just</span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.139.1"> add the statement</span><a id="_idIndexMarker677"/><span class="koboSpan" id="kobo.140.1"> to index a document (product) to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">elasticsearch</span></strong><span class="koboSpan" id="kobo.142.1"> index  while creating the product </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">my_app/catalog/views.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.146.1">
from my_app import es</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.147.1">
@catalog.route('/product-create', methods=['GET',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.148.1">
  'POST'])</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.149.1">
def create_product():</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.150.1">
#... </span><span class="koboSpan" id="kobo.150.2">normal product creation logic … #</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.151.1">
        db.session.commit()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.152.1">
        product.add_index_to_es()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.153.1">
#... </span><span class="koboSpan" id="kobo.153.2">normal post product creation logic … #</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.154.1">
@catalog.route('/product-search-es')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.155.1">
@catalog.route('/product-search-es/&lt;int:page&gt;')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.156.1">
def product_search_es(page=1):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.157.1">
    q = request.args.get('q')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.158.1">
    products = es.search(index="catalog", query={</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.159.1">
        "query_string": {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.160.1">
            "query": '*' + q + '*'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.161.1">
        }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.162.1">
    })</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.163.1">
    return products['hits']</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.164.1">In the preceding code, we have also added a </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">product_search_es()</span></strong><span class="koboSpan" id="kobo.166.1"> method to allow for searching on the Elasticsearch index we just created. </span><span class="koboSpan" id="kobo.166.2">Do the same in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">create_category()</span></strong><span class="koboSpan" id="kobo.168.1"> method as well.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.169.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.170.1">The search query we sent to Elasticsearch in the preceding code is pretty basic and open-ended. </span><span class="koboSpan" id="kobo.170.2">I would urge you to read about Elasticsearch</span><a id="_idIndexMarker678"/><span class="koboSpan" id="kobo.171.1"> query building and apply it to your program. </span><span class="koboSpan" id="kobo.171.2">Refer to the </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">following: </span></span><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html"><span class="No-Break"><span class="koboSpan" id="kobo.173.1">https://www.elastic.co/guide/en/elasticsearch/reference/current/quer</span><span id="_idTextAnchor767"/><span class="koboSpan" id="kobo.174.1">y-dsl.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.175.1">.</span></span></p>
<h2 id="_idParaDest-399"><a id="_idTextAnchor768"/><span class="koboSpan" id="kobo.176.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.177.1">Now, let’s say we created</span><a id="_idIndexMarker679"/><span class="koboSpan" id="kobo.178.1"> a few categories</span><a id="_idIndexMarker680"/><span class="koboSpan" id="kobo.179.1"> and products in each of the categories. </span><span class="koboSpan" id="kobo.179.2">If we open </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">http://127.0.0.1:5000/product-search-es?q=phone</span></strong><span class="koboSpan" id="kobo.181.1">, we will get a response similar to </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.183.1">
{
  "hits": [
    {
      "_id": "5",
      "_index": "catalog",
      "_score": 1.0,
      "_source": {
        "category": "Phones",
        "name": "iPhone 14"
      }
    },
    {
      "_id": "6",
      "_index": "catalog",
      "_score": 1.0,
      "_source": {
        "category": "Phones",
        "name": "Motorola razr"
      }
    }
  ],
  "max_score": 1.0,
  "total": {
    "relation": "eq",
    "value": 2
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.184.1">I encourage you to try and enhance</span><a id="_idIndexMarker681"/><span class="koboSpan" id="kobo.185.1"> the formatting</span><a id="_idIndexMarker682"/><span class="koboSpan" id="kobo.186.1"> and display</span><a id="_idTextAnchor769"/><span class="koboSpan" id="kobo.187.1"> of </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">the output.</span></span></p>
<h2 id="_idParaDest-400"><a id="_idTextAnchor770"/><span class="koboSpan" id="kobo.189.1">See also</span></h2>
<ul>
<li><span class="koboSpan" id="kobo.190.1">You can learn more about</span><a id="_idIndexMarker683"/><span class="koboSpan" id="kobo.191.1"> connecting to the elasticsearch server </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">at </span></span><a href="https://www.elastic.co/guide/en/elasticsearch/client/python-api/current/connecting.html"><span class="No-Break"><span class="koboSpan" id="kobo.193.1">https://www.elastic.co/guide/en/elasticsearch/client/python-api/current/connecting.html</span></span></a></li>
<li><span class="koboSpan" id="kobo.194.1">More about the Python Elasticsearch client</span><a id="_idIndexMarker684"/><span class="koboSpan" id="kobo.195.1"> can be read </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">at </span></span><a href="https://elasticsearch-py.readthedocs.io/en/v8.6.2/index.html"><span class="No-Break"><span class="koboSpan" id="kobo.197.1">https://elasticsearch-py.readthedocs.io/en/</span><span id="_idTextAnchor771"/><span class="koboSpan" id="kobo.198.1">v8.6.2/index.html</span></span></a></li>
</ul>
<h1 id="_idParaDest-401"><a id="_idTextAnchor772"/><span class="koboSpan" id="kobo.199.1">Working with signals</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.200.1">Signals</span></strong><span class="koboSpan" id="kobo.201.1"> can be thought of as events</span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.202.1"> that happen in our application. </span><span class="koboSpan" id="kobo.202.2">These events</span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.203.1"> can be subscribed by certain receivers who then invoke a function whenever the event occurs. </span><span class="koboSpan" id="kobo.203.2">The occurrence of events is broadcasted by senders who can specify the arguments that can be used by the function, which will be triggered by </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">the receiver.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.205.1">Important</span></p>
<p class="callout"><span class="koboSpan" id="kobo.206.1">You should refrain from modifying any application data in the signals because signals aren’t executed in a specified order and can easily lead </span><a id="_idTextAnchor773"/><span class="koboSpan" id="kobo.207.1">to </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">data corruption.</span></span></p>
<h2 id="_idParaDest-402"><a id="_idTextAnchor774"/><span class="koboSpan" id="kobo.209.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.210.1">We will use a Python library called </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">blinker</span></strong><span class="koboSpan" id="kobo.212.1">, which provides the signals feature. </span><span class="koboSpan" id="kobo.212.2">Flask has built-in support for </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">blinker</span></strong><span class="koboSpan" id="kobo.214.1"> and uses signaling itself to a good extent. </span><span class="koboSpan" id="kobo.214.2">There are certain core signals provided </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">by Flask.</span></span></p>
<p><span class="koboSpan" id="kobo.216.1">In this recipe, we will use the application from the </span><em class="italic"><span class="koboSpan" id="kobo.217.1">Implementing full-text search with Elasticsearch</span></em><span class="koboSpan" id="kobo.218.1"> recipe and add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">product</span></strong><span class="koboSpan" id="kobo.220.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">category</span></strong><span class="koboSpan" id="kobo.222.1"> documents to make indexe</span><a id="_idTextAnchor775"/><span class="koboSpan" id="kobo.223.1">s work </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">via signals.</span></span></p>
<h2 id="_idParaDest-403"><a id="_idTextAnchor776"/><span class="koboSpan" id="kobo.225.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.226.1">Follow these steps to implement and understand how </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">signaling works:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.228.1">First, create signals for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">product</span></strong><span class="koboSpan" id="kobo.230.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">category</span></strong><span class="koboSpan" id="kobo.232.1"> creation. </span><span class="koboSpan" id="kobo.232.2">This can be done in </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">my_app/catalog/models.py</span></strong><span class="koboSpan" id="kobo.234.1">. </span><span class="koboSpan" id="kobo.234.2">However, you can use any file you want since signals are created on a </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">global scope:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.236.1">
from blinker import Namespace</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.237.1">
catalog_signals = Namespace()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.238.1">
product_created = catalog_signals.signal('product-</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.239.1">
  created')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.240.1">
category_created = catalog_signals.signal('category-</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.241.1">
  created')</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.242.1">We have used </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">Namespace</span></strong><span class="koboSpan" id="kobo.244.1"> to create signals, which will create them in a custom namespace</span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.245.1"> rather than in the global namespace, thereby helping with the clean management of signals. </span><span class="koboSpan" id="kobo.245.2">We created two signals, </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">product-created</span></strong><span class="koboSpan" id="kobo.247.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">category-created</span></strong><span class="koboSpan" id="kobo.249.1">, where the intent of both is clear by their names.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.250.1">Then, we will create subscribers to these signals and attach functions to them. </span><span class="koboSpan" id="kobo.250.2">For this, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">add_index_to_es()</span></strong><span class="koboSpan" id="kobo.252.1"> methods have to be removed (if you are building over the code from the previous recipe), and new functions on the global scope have to be created </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">my_app/catalog/models.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.256.1">
def add_product_index_to_es(sender, product):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.257.1">
    es.index(index='catalog', document={</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.258.1">
        'name': product.name,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.259.1">
        'category': product.category.name</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.260.1">
    }, id=product.id)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.261.1">
    es.indices.refresh(index='catalog')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.262.1">
product_created.connect(add_product_index_to_es, app)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.263.1">
def add_category_index_to_es(sender, category):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.264.1">
    es.index(index='catalog', document={</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.265.1">
        'name': category.name,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.266.1">
    }, id=category.id)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.267.1">
    es.indices.refresh('catalog')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.268.1">
category_created.connect(add_category_index_to_es,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.269.1">
  app)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.270.1">In the preceding code snippet, we created subscribers</span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.271.1"> for the signals we created in </span><em class="italic"><span class="koboSpan" id="kobo.272.1">step 1</span></em><span class="koboSpan" id="kobo.273.1"> using </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">.connect()</span></strong><span class="koboSpan" id="kobo.275.1">. </span><span class="koboSpan" id="kobo.275.2">This method accepts the function that should be called when the event occurs; it also accepts the sender as an optional argument. </span><span class="koboSpan" id="kobo.275.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">app</span></strong><span class="koboSpan" id="kobo.277.1"> object is provided as the sender because we don’t want our function to be called every time the event is triggered anywhere in any application. </span><span class="koboSpan" id="kobo.277.2">This specifically holds true in the case of extensions, which can be used by multiple applications. </span><span class="koboSpan" id="kobo.277.3">The function that gets called by the receiver (in this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">add_product_index_to_es</span></strong><span class="koboSpan" id="kobo.279.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">add_category_index_to_es</span></strong><span class="koboSpan" id="kobo.281.1">) gets the sender as the first argument, which defaults to </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">None</span></strong><span class="koboSpan" id="kobo.283.1"> if the sender is not provided. </span><span class="koboSpan" id="kobo.283.2">We provided the product/category as the second argument for which the record needs to be added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">elasticsearch</span></strong><span class="koboSpan" id="kobo.285.1"> index.</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.286.1">Now, emit the signal that can be caught by the receiver. </span><span class="koboSpan" id="kobo.286.2">This needs to be done in </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">my_app/catalog/views.py</span></strong><span class="koboSpan" id="kobo.288.1">. </span><span class="koboSpan" id="kobo.288.2">For this, just remove the calls to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">add_index_to_es()</span></strong><span class="koboSpan" id="kobo.290.1"> methods and replace them with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">send()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.293.1"> methods:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.294.1">
From my_app.catalog.models import product_created,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.295.1">
  category_created</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.296.1">
@catalog.route('/product-create', methods=['GET',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.297.1">
  'POST'])</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.298.1">
def create_product():</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.299.1">
    #... </span><span class="koboSpan" id="kobo.299.2">normal product creation logic … #</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.300.1">
        db.session.commit()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.301.1">
        product_created.send(app, product=product)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.302.1">
    #... </span><span class="koboSpan" id="kobo.302.2">normal post product creation logic … #</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.303.1">Do the same in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">create_categ</span><a id="_idTextAnchor777"/><span class="koboSpan" id="kobo.305.1">ory()</span></strong><span class="koboSpan" id="kobo.306.1"> method as well.</span></p>
<h2 id="_idParaDest-404"><a id="_idTextAnchor778"/><span class="koboSpan" id="kobo.307.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.308.1">Whenever a product is created, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">product_created</span></strong><span class="koboSpan" id="kobo.310.1"> signal is emitted, with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">app</span></strong><span class="koboSpan" id="kobo.312.1"> object as the sender and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">product</span></strong><span class="koboSpan" id="kobo.314.1"> as the keyword argument. </span><span class="koboSpan" id="kobo.314.2">This is then caught in </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">models.py</span></strong><span class="koboSpan" id="kobo.316.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">add_product_index_to_es()</span></strong><span class="koboSpan" id="kobo.318.1"> function is called, which adds the document to the </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">catalog index.</span></span></p>
<p><span class="koboSpan" id="kobo.320.1">The functionality of this recipe is exactly</span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.321.1"> the same as the last recipe, </span><em class="italic"><span class="koboSpan" id="kobo.322.1">Implementing full-text sear</span><a id="_idTextAnchor779"/><span class="koboSpan" id="kobo.323.1">ch </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.324.1">with Elasticsearch</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">.</span></span></p>
<h2 id="_idParaDest-405"><a id="_idTextAnchor780"/><span class="koboSpan" id="kobo.326.1">See also</span></h2>
<ul>
<li><span class="koboSpan" id="kobo.327.1">Read the </span><em class="italic"><span class="koboSpan" id="kobo.328.1">Implementing full-text search with Elasticsearch</span></em><span class="koboSpan" id="kobo.329.1"> recipe for a background on </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">this recipe</span></span></li>
<li><span class="koboSpan" id="kobo.331.1">You can read about</span><a id="_idIndexMarker690"/><span class="koboSpan" id="kobo.332.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">blinker</span></strong><span class="koboSpan" id="kobo.334.1"> library </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">at </span></span><a href="https://pypi.python.org/pypi/blinker"><span class="No-Break"><span class="koboSpan" id="kobo.336.1">https://pypi.python.org/pypi/blinker</span></span></a></li>
<li><span class="koboSpan" id="kobo.337.1">You can view the list</span><a id="_idIndexMarker691"/><span class="koboSpan" id="kobo.338.1"> of core signals that are supported by Flask </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">at </span></span><a href="https://flask.palletsprojects.com/en/2.2.x/api/#core-signals-list"><span class="No-Break"><span class="koboSpan" id="kobo.340.1">https://flask.palletsprojects.com/en/2.2.x/api/#core-signals-list</span></span></a></li>
<li><span class="koboSpan" id="kobo.341.1">You can view the signals</span><a id="_idIndexMarker692"/><span class="koboSpan" id="kobo.342.1"> that are provided by Flask-SQLAlchemy for tracking modifications to models </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">at </span></span><a href="https://flask-sqlalchemy.palletsprojects.com/en/3.0.x/api/#module-flask_sqlalchemy.track_modifications"><span class="No-Break"><span class="koboSpan" id="kobo.344.1">https://flask-sqlalchemy.palletsprojects.com/en/3.0.x/api/#module-flask_sqlal</span><span id="_idTextAnchor781"/><span class="koboSpan" id="kobo.345.1">chemy.track_modifications</span></span></a></li>
</ul>
<h1 id="_idParaDest-406"><span class="koboSpan" id="kobo.346.1">Using cach</span><a id="_idTextAnchor782"/><span class="koboSpan" id="kobo.347.1">ing with your application</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.348.1">Caching</span></strong><span class="koboSpan" id="kobo.349.1"> becomes an important</span><a id="_idIndexMarker693"/><span class="koboSpan" id="kobo.350.1"> and integral part</span><a id="_idIndexMarker694"/><span class="koboSpan" id="kobo.351.1"> of any web application when scaling</span><a id="_idIndexMarker695"/><span class="koboSpan" id="kobo.352.1"> or increasing the response time of your application becomes a question. </span><span class="koboSpan" id="kobo.352.2">Caching is the first thing that is implemented in these cases. </span><span class="koboSpan" id="kobo.352.3">Flask, by itself, does not provide any caching</span><a id="_idIndexMarker696"/><span class="koboSpan" id="kobo.353.1"> support by default, but </span><strong class="bold"><span class="koboSpan" id="kobo.354.1">Werkzeug</span></strong><span class="koboSpan" id="kobo.355.1"> does. </span><span class="koboSpan" id="kobo.355.2">Werkzeug has some basic support to cache with multiple backends, such as Memcached and Redis. </span><span class="koboSpan" id="kobo.355.3">This caching</span><a id="_idIndexMarker697"/><span class="koboSpan" id="kobo.356.1"> support of Werkzeug is implemented by a package called </span><strong class="bold"><span class="koboSpan" id="kobo.357.1">Flask-Caching</span></strong><span class="koboSpan" id="kobo.358.1">, whi</span><a id="_idTextAnchor783"/><span class="koboSpan" id="kobo.359.1">ch</span><a id="_idIndexMarker698"/><span class="koboSpan" id="kobo.360.1"> we will use</span><a id="_idIndexMarker699"/><span class="koboSpan" id="kobo.361.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">this recipe.</span></span></p>
<h2 id="_idParaDest-407"><a id="_idTextAnchor784"/><span class="koboSpan" id="kobo.363.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.364.1">We will install a Flask extension called </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">flask-caching</span></strong><span class="koboSpan" id="kobo.366.1">, which simplifies the process of caching </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">a lot:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.368.1">
$ pip install flask-caching</span></pre>
<p><span class="koboSpan" id="kobo.369.1">We will use our catalog application for this purpose and imp</span><a id="_idTextAnchor785"/><span class="koboSpan" id="kobo.370.1">lement caching for </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">some methods.</span></span></p>
<h2 id="_idParaDest-408"><a id="_idTextAnchor786"/><span class="koboSpan" id="kobo.372.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.373.1">Implementing basic caching is pretty easy. </span><span class="koboSpan" id="kobo.373.2">Go through the following steps to </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">do so:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.375.1">First, initialize </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">Cache</span></strong><span class="koboSpan" id="kobo.377.1"> to work with our application. </span><span class="koboSpan" id="kobo.377.2">This is done in the application’s configuration – that </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">is, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">my_app/__init__.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.381.1">
from flask_caching import Cache</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.382.1">
cache = Cache(app, config={'CACHE_TYPE': 'simple'})</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.383.1">Here, we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">simple</span></strong><span class="koboSpan" id="kobo.385.1"> as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">Cache</span></strong><span class="koboSpan" id="kobo.387.1"> type, where the cache is stored in the memory. </span><span class="koboSpan" id="kobo.387.2">This is not advised for production environments. </span><span class="koboSpan" id="kobo.387.3">For production, we should use something such as Redis, Memcached, filesystem cache, and so on. </span><span class="koboSpan" id="kobo.387.4">Flask-Caching supports all of them with a couple more backends.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.388.1">Next, add caching to the methods that need to be cached. </span><span class="koboSpan" id="kobo.388.2">Just add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">@cache.cached(timeout=&lt;time in seconds&gt;)</span></strong><span class="koboSpan" id="kobo.390.1"> decorator to the view methods. </span><span class="koboSpan" id="kobo.390.2">A simple target can be the list of categories (we will do this </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">my_app/catalog/views.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.394.1">
@catalog.route('/categories')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.395.1">
@cache.cached(timeout=120)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.396.1">
def categories():</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.397.1">
    categories = Category.query.all()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.398.1">
    return render_template('categories.html',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.399.1">
      categories=categories)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.400.1">This way of caching stores the value</span><a id="_idIndexMarker700"/><span class="koboSpan" id="kobo.401.1"> of the output of this method in the cache in the form of a key-value pair, </span><a id="_idTextAnchor787"/><span class="koboSpan" id="kobo.402.1">with the key</span><a id="_idIndexMarker701"/><span class="koboSpan" id="kobo.403.1"> as the </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">request path.</span></span></p>
<h2 id="_idParaDest-409"><a id="_idTextAnchor788"/><span class="koboSpan" id="kobo.405.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.406.1">After adding the preceding code, to check whether the cache works as expected, fetch the list of categories by pointing the browser to </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">http://127.0.0.1:5000/categories</span></strong><span class="koboSpan" id="kobo.408.1">. </span><span class="koboSpan" id="kobo.408.2">This will save a key-value pair for this URL in the cache. </span><span class="koboSpan" id="kobo.408.3">Now, create a new category quickly and navigate to the same category list page. </span><span class="koboSpan" id="kobo.408.4">You will notice that the newly added category is not listed. </span><span class="koboSpan" id="kobo.408.5">Wait for a couple of minutes and then reload the page. </span><span class="koboSpan" id="kobo.408.6">The newly added category will be shown now. </span><span class="koboSpan" id="kobo.408.7">This is because the first time the category list was cached, it expired after 2 minutes (</span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">120 seconds).</span></span></p>
<p><span class="koboSpan" id="kobo.410.1">This might seem to be a fault with the application but, in the case of large applications, this becomes a boon where the hits to the database are reduced, and the overall application experience improves. </span><span class="koboSpan" id="kobo.410.2">Caching is usually implemented for those handlers whose res</span><a id="_idTextAnchor789"/><span class="koboSpan" id="kobo.411.1">ults don’t get </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">updated frequently.</span></span></p>
<h2 id="_idParaDest-410"><a id="_idTextAnchor790"/><span class="koboSpan" id="kobo.413.1">There’s more…</span></h2>
<p><span class="koboSpan" id="kobo.414.1">Many of us might think that such caching will fail in the case of a single category or product page, where each record has a separate</span><a id="_idIndexMarker702"/><span class="koboSpan" id="kobo.415.1"> page. </span><span class="koboSpan" id="kobo.415.2">The solution to this is </span><strong class="bold"><span class="koboSpan" id="kobo.416.1">memoization</span></strong><span class="koboSpan" id="kobo.417.1">. </span><span class="koboSpan" id="kobo.417.2">It is similar to caching, with the difference being that it stores the result of a method in the cache, along with the information on the parameters that were passed. </span><span class="koboSpan" id="kobo.417.3">So, when a method is created with the same parameters multiple times, the result is loaded from the cache rather than making a database</span><a id="_idIndexMarker703"/><span class="koboSpan" id="kobo.418.1"> hit. </span><span class="koboSpan" id="kobo.418.2">Implementing memoization is </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">quite simple:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.420.1">
@catalog.route('/product/&lt;id&gt;')
@cache.memoize(120)
def product(id):
    product = Product.query.get_or_404(id)
    return render_template('product.html', product=product)</span></pre>
<p><span class="koboSpan" id="kobo.421.1">Now, if we open a URL (say, </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">http://127.0.0.1:5000/product/1</span></strong><span class="koboSpan" id="kobo.423.1">) in our browser for the first time, it will be loaded after making calls to the database. </span><span class="koboSpan" id="kobo.423.2">However, if we make the same call again, the page will be loaded from the cache. </span><span class="koboSpan" id="kobo.423.3">On the other hand, if we open another product (say, </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">http://127.0.0.1:5000/product/2</span></strong><span class="koboSpan" id="kobo.425.1">), then it will be loaded after fetching the product details from the databa</span><a id="_idTextAnchor791"/><span class="koboSpan" id="kobo.426.1">se when accessed for the </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">first time.</span></span></p>
<h2 id="_idParaDest-411"><a id="_idTextAnchor792"/><span class="koboSpan" id="kobo.428.1">See also</span></h2>
<ul>
<li><span class="koboSpan" id="kobo.429.1">Flask-Caching</span><a id="_idIndexMarker704"/> <span class="No-Break"><span class="koboSpan" id="kobo.430.1">at </span></span><a href="https://flask-caching.readthedocs.io/en/latest/"><span class="No-Break"><span class="koboSpan" id="kobo.431.1">https://flask-caching.readthedocs.io/en/latest/</span></span></a></li>
<li><span class="koboSpan" id="kobo.432.1">Memoization</span><a id="_idIndexMarker705"/> <span class="No-Break"><span class="koboSpan" id="kobo.433.1">at </span></span><a href="http://en.wikipedia.org/wiki/Memoization"><span class="No-Break"><span class="koboSpan" id="kobo.434.1">ht</span><span id="_idTextAnchor793"/><span class="koboSpan" id="kobo.435.1">tp://en.wikipedia.org/wiki/Memoization</span></span></a></li>
</ul>
<h1 id="_idParaDest-412"><a id="_idTextAnchor794"/><span class="koboSpan" id="kobo.436.1">Implementing email support</span></h1>
<p><span class="koboSpan" id="kobo.437.1">The ability to send emails </span><a id="_idIndexMarker706"/><span class="koboSpan" id="kobo.438.1">is usually one of the most basic functions of any web application. </span><span class="koboSpan" id="kobo.438.2">It is usually easy to implement with any application. </span><span class="koboSpan" id="kobo.438.3">With Python-based applications, it is quite simple to implement with the help of </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">smtplib</span></strong><span class="koboSpan" id="kobo.440.1">. </span><span class="koboSpan" id="kobo.440.2">In the case of Flask, this is further simpli</span><a id="_idTextAnchor795"/><span class="koboSpan" id="kobo.441.1">fied by an extension </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">Flask-Mail</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">.</span></span></p>
<h2 id="_idParaDest-413"><a id="_idTextAnchor796"/><span class="koboSpan" id="kobo.445.1">Getting ready</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">Flask-Mail</span></strong><span class="koboSpan" id="kobo.447.1"> can be easily installed </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">via </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">pip</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.451.1">
$ pip install Flask-Mail</span></pre>
<p><span class="koboSpan" id="kobo.452.1">Let’s look at a simple case where an email will be sent to a catalog manager in the applic</span><a id="_idTextAnchor797"/><span class="koboSpan" id="kobo.453.1">ation whenever a new category </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">is added.</span></span></p>
<h2 id="_idParaDest-414"><a id="_idTextAnchor798"/><span class="koboSpan" id="kobo.455.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.456.1">First, instantiate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">Mail</span></strong><span class="koboSpan" id="kobo.458.1"> object in our</span><a id="_idIndexMarker707"/><span class="koboSpan" id="kobo.459.1"> application’s configuration – that </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">is, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">my_app/__init__.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.463.1">
from flask_mail import Mail
app.config['MAIL_SERVER'] = 'smtp.gmail.com'
app.config['MAIL_PORT'] = 587
app.config['MAIL_USE_TLS'] = True
app.config['MAIL_USERNAME'] = 'gmail_username'
app.config['MAIL_PASSWORD'] = 'gmail_password'
app.config['MAIL_DEFAULT_SENDER'] = ('Sender name', 'sender
  email')
mail = Mail(app)</span></pre>
<p><span class="koboSpan" id="kobo.464.1">We also need to do some configuration to set up the email server and sender account. </span><span class="koboSpan" id="kobo.464.2">The preceding code is a sample configuration for Gmail accounts (without two-factor authentication enabled). </span><span class="koboSpan" id="kobo.464.3">Any SMTP server can be set up like this. </span><span class="koboSpan" id="kobo.464.4">There are several other options</span><a id="_idIndexMarker708"/><span class="koboSpan" id="kobo.465.1"> provided; they can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">Flask-Mail</span></strong><span class="koboSpan" id="kobo.467.1"> documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">at </span></span><a href="https://pythonhosted.org/Flask-Mail"><span class="No-Break"><span class="koboSpan" id="kobo.469.1">https://pythonhosted.org/Flask-Mail</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.470.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.471.1">To send an email on category creation, we need to make the following changes </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">my_app/catalog/views.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.475.1">
from my_app import mail
from flask_mail import Message
@catalog.route('/category-create', methods=['POST',])
def create_category():
    # ... </span><span class="koboSpan" id="kobo.475.2">Create a category ... </span><span class="koboSpan" id="kobo.475.3">#
    message = Message(
        "New category added",
        recipients=['shalabh7777@gmail.com']
    )
    message.body = 'New category "%s" has been created'
      % category.name
    message.html = render_template(
        "category-create-email-html.html",
        category=category
    )
    mail.send(message)
    # ... </span><span class="koboSpan" id="kobo.475.4">Rest of the process ... </span><span class="koboSpan" id="kobo.475.5">#</span></pre>
<p><span class="koboSpan" id="kobo.476.1">Here, a new email will be sent to the list of recipients from the default sender configuration that we did. </span><span class="koboSpan" id="kobo.476.2">You will notice that the category creation takes one or two seconds to execute. </span><a id="_idTextAnchor799"/><span class="koboSpan" id="kobo.477.1">That is the time</span><a id="_idIndexMarker709"/><span class="koboSpan" id="kobo.478.1"> taken to send </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">the email.</span></span></p>
<h2 id="_idParaDest-415"><a id="_idTextAnchor800"/><span class="koboSpan" id="kobo.480.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.481.1">Create a new category by simply making a post request to </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">http://127.0.0.1:5000/category-create</span></strong><span class="koboSpan" id="kobo.483.1">. </span><span class="koboSpan" id="kobo.483.2">You can do it using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">requests</span></strong><span class="koboSpan" id="kobo.485.1"> library from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">Python</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.487.1"> prompt:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.488.1">
&gt;&gt;&gt; requests.post('http://127.0.0.1:5000/category-create', data={'name': 'Headphone'})</span></pre>
<p><span class="koboSpan" id="kobo.489.1">You should receive an em</span><a id="_idTextAnchor801"/><span class="koboSpan" id="kobo.490.1">ail on the recipient email </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">ID(s) provided.</span></span></p>
<h2 id="_idParaDest-416"><a id="_idTextAnchor802"/><span class="koboSpan" id="kobo.492.1">There’s more…</span></h2>
<p><span class="koboSpan" id="kobo.493.1">Now, let’s assume that we need to send</span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.494.1"> a large email with a lot of HTML content. </span><span class="koboSpan" id="kobo.494.2">Writing all of this in our Python file will make the overall code ugly and unmanageable. </span><span class="koboSpan" id="kobo.494.3">A simple solution to this is to create templates and render their content while sending emails. </span><span class="koboSpan" id="kobo.494.4">Here, I created two templates: one for the HTML content and one simply for </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">text content.</span></span></p>
<p><span class="koboSpan" id="kobo.496.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">category-create-email-text.html</span></strong><span class="koboSpan" id="kobo.498.1"> template will look </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.500.1">
A new category has been added to the catalog.
</span><span class="koboSpan" id="kobo.500.2">The name of the category is {{ category.name }}.
</span><span class="koboSpan" id="kobo.500.3">Click on the URL below to access the same:
{{ url_for('catalog.category', id=category.id, _external =
  True) }}
This is an automated email. </span><span class="koboSpan" id="kobo.500.4">Do not reply to it.</span></pre>
<p><span class="koboSpan" id="kobo.501.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">category-create-email-html.html</span></strong><span class="koboSpan" id="kobo.503.1"> template will look </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.505.1">
&lt;p&gt;A new category has been added to the catalog.&lt;/p&gt;
&lt;p&gt;The name of the category is &lt;a href="{{
  url_for('catalog.category', id=category.id, _external =
  True) }}"&gt;
      &lt;h2&gt;{{ category.name }}&lt;/h2&gt;
    &lt;/a&gt;.
</span><span class="koboSpan" id="kobo.505.2">&lt;/p&gt;
&lt;p&gt;This is an automated email. </span><span class="koboSpan" id="kobo.505.3">Do not reply to it.&lt;/p&gt;</span></pre>
<p><span class="koboSpan" id="kobo.506.1">After this, we need to modify the email message </span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.507.1">creation procedure that we </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">created earlier:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.509.1">
    message.body = render_template(
        "category-create-email-text.html",
        category=category
    )
    message.html = render_template(
        "category-create-email</span><a id="_idTextAnchor803"/><span class="koboSpan" id="kobo.510.1">-html.html",
        category=category
    )</span></pre>
<h2 id="_idParaDest-417"><a id="_idTextAnchor804"/><span class="koboSpan" id="kobo.511.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.512.1">The next recipe, </span><em class="italic"><span class="koboSpan" id="kobo.513.1">Understanding asynchronous operations</span></em><span class="koboSpan" id="kobo.514.1">, will show us how we can delegate the time-consuming email-sending process to an asynchronous thr</span><a id="_idTextAnchor805"/><span class="koboSpan" id="kobo.515.1">ead and speed up our </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">application experience.</span></span></p>
<h1 id="_idParaDest-418"><a id="_idTextAnchor806"/><span class="koboSpan" id="kobo.517.1">Understanding asynchronous operations</span></h1>
<p><span class="koboSpan" id="kobo.518.1">Some of the operations</span><a id="_idIndexMarker712"/><span class="koboSpan" id="kobo.519.1"> in a web application can be time-consuming and make the overall application feel slow for the user, even though it’s not actually slow. </span><span class="koboSpan" id="kobo.519.2">This hampers the user experience significantly. </span><span class="koboSpan" id="kobo.519.3">To deal with this, the simplest way to implement the asynchronous execution of operations is with the help of threads. </span><span class="koboSpan" id="kobo.519.4">In this recipe, we will implement this using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">threading</span></strong><span class="koboSpan" id="kobo.521.1"> libraries of Python. </span><span class="koboSpan" id="kobo.521.2">In Python 3, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">thread</span></strong><span class="koboSpan" id="kobo.523.1"> package has been deprecated. </span><span class="koboSpan" id="kobo.523.2">Although it is still available as </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">_threa</span><a id="_idTextAnchor807"/><span class="koboSpan" id="kobo.525.1">d</span></strong><span class="koboSpan" id="kobo.526.1">, it is highly recommended to </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">use </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">threading</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">.</span></span></p>
<h2 id="_idParaDest-419"><a id="_idTextAnchor808"/><span class="koboSpan" id="kobo.530.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.531.1">We will use the application from the </span><em class="italic"><span class="koboSpan" id="kobo.532.1">Implementing email support for Flask applications</span></em><span class="koboSpan" id="kobo.533.1"> recipe. </span><span class="koboSpan" id="kobo.533.2">Many of us will have noticed that, while the email is being sent, the application waits for the whole process to finish, which is unnecessary. </span><span class="koboSpan" id="kobo.533.3">Email sending can be easily done in the background, and our application can </span><a id="_idTextAnchor809"/><span class="koboSpan" id="kobo.534.1">become available to the </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">user instantaneously.</span></span></p>
<h2 id="_idParaDest-420"><a id="_idTextAnchor810"/><span class="koboSpan" id="kobo.536.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.537.1">Doing an asynchronous</span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.538.1"> execution with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">threading</span></strong><span class="koboSpan" id="kobo.540.1"> package is very simple. </span><span class="koboSpan" id="kobo.540.2">Just add the following code </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">my_app/catalog/views.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.544.1">
from threading import Thread
def send_mail(message):
    with app.app_context():
        mail.send(message)
# Replace the line below in create_category()
# mail.send(message)
# by
t = Thread(target=send_mail, args=(message,))
t.start()</span></pre>
<p><span class="koboSpan" id="kobo.545.1">As you can see, the sending of an email happens in a new thread, which sends the message as a parameter to the newly created method. </span><span class="koboSpan" id="kobo.545.2">We need to create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">send_mail()</span></strong><span class="koboSpan" id="kobo.547.1"> method because our email templates contain </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">url_for</span></strong><span class="koboSpan" id="kobo.549.1">, which can only be executed inside an application context; this won’t be available in the newly created thread by default. </span><span class="koboSpan" id="kobo.549.2">It provides the flexibility of starting the thread whenever it’s needed instead of crea</span><a id="_idTextAnchor811"/><span class="koboSpan" id="kobo.550.1">ting and starting the thread at the </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">same time.</span></span></p>
<h2 id="_idParaDest-421"><a id="_idTextAnchor812"/><span class="koboSpan" id="kobo.552.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.553.1">It is pretty simple to observe how this works. </span><span class="koboSpan" id="kobo.553.2">Compare the performance of sending an email in this recipe with that of the application in the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.554.1">Implementing email support for Flask applications</span></em><span class="koboSpan" id="kobo.555.1">. </span><span class="koboSpan" id="kobo.555.2">You will notice that the application is more responsive. </span><span class="koboSpan" id="kobo.555.3">Another way can be to monitor the debug logs, where the newly created cat</span><a id="_idTextAnchor813"/><span class="koboSpan" id="kobo.556.1">egory page will load</span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.557.1"> before the email </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">is sent.</span></span></p>
<h2 id="_idParaDest-422"><a id="_idTextAnchor814"/><span class="koboSpan" id="kobo.559.1">See also</span></h2>
<ul>
<li><span class="koboSpan" id="kobo.560.1">Since I have mentioned multithreading and asynchronous operations, many of you must be thinking about Python’s built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">asyncio</span></strong><span class="koboSpan" id="kobo.562.1"> library and its potential here. </span><span class="koboSpan" id="kobo.562.2">Although it is possible to write Flask methods using </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">async..await</span></strong><span class="koboSpan" id="kobo.564.1"> and they would work in a non-blocking fashion, there are no obvious performance gains as WSGI</span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.565.1"> would still need</span><a id="_idIndexMarker716"/><span class="koboSpan" id="kobo.566.1"> to run in a single worker to handle a request. </span><span class="koboSpan" id="kobo.566.2">See </span><a href="https://flask.palletsprojects.com/en/2.2.x/async-await/"><span class="koboSpan" id="kobo.567.1">https://flask.palletsprojects.com/en/2.2.x/async-await/</span></a><span class="koboSpan" id="kobo.568.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">more details.</span></span></li>
<li><span class="koboSpan" id="kobo.570.1">You can look at </span><strong class="bold"><span class="koboSpan" id="kobo.571.1">Quart</span></strong><span class="koboSpan" id="kobo.572.1"> (</span><a href="https://pgjones.gitlab.io/quart/"><span class="koboSpan" id="kobo.573.1">https://pgjones.gitlab.io/quart/</span></a><span class="koboSpan" id="kobo.574.1">), which is an </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">asyncio</span></strong><span class="koboSpan" id="kobo.576.1"> implementation</span><a id="_idIndexMarker717"/><span class="koboSpan" id="kobo.577.1"> of Flask or </span><strong class="bold"><span class="koboSpan" id="kobo.578.1">Fast API</span></strong><span class="koboSpan" id="kobo.579.1"> (</span><a href="https://fastapi.tiangolo.com/"><span class="koboSpan" id="kobo.580.1">https://fastapi.tiangolo.com/</span></a><span class="koboSpan" id="kobo.581.1">), which is a different</span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.582.1"> framework built</span><a id="_idTextAnchor815"/><span class="koboSpan" id="kobo.583.1"> using </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">asyncio</span></strong><span class="koboSpan" id="kobo.585.1"> with a very similar syntax </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">to Flask.</span></span></li>
</ul>
<h1 id="_idParaDest-423"><a id="_idTextAnchor816"/><span class="koboSpan" id="kobo.587.1">Working with Celery</span></h1>
<p><span class="koboSpan" id="kobo.588.1">Celery</span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.589.1"> is a task queue for Python. </span><span class="koboSpan" id="kobo.589.2">There used to be an extension</span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.590.1"> to integrate Flask and Celery but, with Celery 3.0, it became obsolete. </span><span class="koboSpan" id="kobo.590.2">Now, Celery can be directly used with Flask by just using a bit of configuration. </span><span class="koboSpan" id="kobo.590.3">In the </span><em class="italic"><span class="koboSpan" id="kobo.591.1">Understanding asynchronous operations</span></em><span class="koboSpan" id="kobo.592.1"> recipe, we implemented asynchronous processing to send an email. </span><span class="koboSpan" id="kobo.592.2">In </span><a id="_idTextAnchor817"/><span class="koboSpan" id="kobo.593.1">this recipe, we will implement the same </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">using Celery.</span></span></p>
<h2 id="_idParaDest-424"><a id="_idTextAnchor818"/><span class="koboSpan" id="kobo.595.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.596.1">Celery can be installed simply </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">from PyPI:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.598.1">
$ pip install celery</span></pre>
<p><span class="koboSpan" id="kobo.599.1">To make Celery work with Flask, we will need to modify our Flask app config file a bit. </span><span class="koboSpan" id="kobo.599.2">In order to do its job, Celery needs a broker to receive and deliver tasks. </span><span class="koboSpan" id="kobo.599.3">Here, we will use Redis as the broker (thanks to </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">its simplicity).</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.601.1">Information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.602.1">Make sure that you run the Redis server for the connection to happen. </span><span class="koboSpan" id="kobo.602.2">To install and run a Redis server, refer </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">to </span></span><a href="https://redis.io/docs/getting-started/"><span class="No-Break"><span class="koboSpan" id="kobo.604.1">https://redis.io/docs/getting-started/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.605.1">.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.606.1">You would also need to install the Redis client in your </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">virtual environment:</span></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">$ pip </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">install Redis</span></strong></span></p>
<p><span class="koboSpan" id="kobo.610.1">We will use the application</span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.611.1"> from the pr</span><a id="_idTextAnchor819"/><span class="koboSpan" id="kobo.612.1">evious recipe and implement Celery in the </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">same manner.</span></span></p>
<h2 id="_idParaDest-425"><a id="_idTextAnchor820"/><span class="koboSpan" id="kobo.614.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.615.1">Follow these steps to understand Celery’s integration with the </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">Flask application:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.617.1">First, we need to do a bit of configuration in the application’s configuration – that </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">is, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">my_app/__init__.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.621.1">
from celery import Celery</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.622.1">
app.config['SERVER_NAME'] = '127.0.0.1:5000'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.623.1">
app.config.update(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.624.1">
    CELERY_BROKER_URL='redis://127.0.0.1:6379',</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.625.1">
    CELERY_RESULT_BACKEND='redis://127.0.0.1:6379'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.626.1">
)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.627.1">
def make_celery(app):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.628.1">
    celery = Celery(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.629.1">
        app.import_name,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.630.1">
          broker=app.config['CELERY_BROKER_URL']</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.631.1">
    )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.632.1">
    celery.conf.update(app.config)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.633.1">
    TaskBase = celery.Task</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.634.1">
    class ContextTask(TaskBase):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.635.1">
        abstract = True</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.636.1">
        def __call__(self, *args, **kwargs):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.637.1">
            with app.app_context():</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.638.1">
                return TaskBase.__call__(self, *args,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.639.1">
                  **kwargs)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.640.1">
    celery.Task = ContextTask</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.641.1">
    return celery</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.642.1">
celery = make_celery(app)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.643.1">The preceding snippet comes directly from the Flask website and can be used as is in your application</span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.644.1"> in most cases. </span><span class="koboSpan" id="kobo.644.2">Here, we are essentially configuring a task in Celery to have the application context.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.645.1">To run the Celery process, execute the </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">following command:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.647.1">
$ celery --app=my_app.celery worker -l INFO</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.648.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">-app</span></strong><span class="koboSpan" id="kobo.650.1"> points to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">celery</span></strong><span class="koboSpan" id="kobo.652.1"> object that is created in the configuration file, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">-l</span></strong><span class="koboSpan" id="kobo.654.1"> is the log level that we want to observe.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.655.1">Important</span></p>
<p class="callout"><span class="koboSpan" id="kobo.656.1">Make sure that Redis is also running on the broker URL, as specified in </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">the configuration.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.658.1">Now, use this </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">celery</span></strong><span class="koboSpan" id="kobo.660.1"> object in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">my_app/catalog/views.py</span></strong><span class="koboSpan" id="kobo.662.1"> file to send </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">emails</span></span><span class="No-Break"><a id="_idIndexMarker723"/></span><span class="No-Break"><span class="koboSpan" id="kobo.664.1"> asynchronously:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.665.1">
from my_app import db, app, es, cache, mail, celery</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.666.1">
@celery.task()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.667.1">
def send_mail(category_id, category_name):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.668.1">
    with app.app_context():</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.669.1">
        category = Category(category_name)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.670.1">
        category.id = category_id</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.671.1">
        message = Message(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.672.1">
            "New category added",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.673.1">
            recipients=['some-receiver@domain.com']</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.674.1">
        )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.675.1">
        message.body = render_template(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.676.1">
            "category-create-email-text.html",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.677.1">
            category=category</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.678.1">
        )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.679.1">
        message.html = render_template(</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.680.1">
            "category-create-email-html.html",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.681.1">
            category=category</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.682.1">
        )</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.683.1">
        mail.send(message)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.684.1">
# Add this line wherever the email needs to be sent</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.685.1">
  send_mail.apply_async(args=[category.id,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.686.1">
  category.name])</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.687.1">We add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">@celery.task</span></strong><span class="koboSpan" id="kobo.689.1"> decorator to any method that we wish to use as a Celery task. </span><span class="koboSpan" id="kobo.689.2">The</span><a id="_idTextAnchor821"/><span class="koboSpan" id="kobo.690.1"> Celery process will detect these methods automatically.</span></p>
<h2 id="_idParaDest-426"><a id="_idTextAnchor822"/><span class="koboSpan" id="kobo.691.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.692.1">Now, when we create a category</span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.693.1"> and an email is sent, we can see a task being run on the Celery process logs, which will look </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.695.1">
[2023-03-22 15:24:21,838: INFO/MainProcess] Task my_app.catalog.views.send_mail[1e869100-5bee-4d99-a4cc-6a3dca92e120] received
[2023-03-22 15:24:25,927: INFO/ForkPoolWorker-8] Task my_app.catalog.views.send_mail[1e869100-5bee-4d99</span><a id="_idTextAnchor823"/><span class="koboSpan" id="kobo.696.1">-a4cc-6a3dca92e120] succeeded in 4.086294061969966s: None</span></pre>
<h2 id="_idParaDest-427"><a id="_idTextAnchor824"/><span class="koboSpan" id="kobo.697.1">See also</span></h2>
<ul>
<li><span class="koboSpan" id="kobo.698.1">Read the </span><em class="italic"><span class="koboSpan" id="kobo.699.1">Understanding asynchronous operations</span></em><span class="koboSpan" id="kobo.700.1"> recipe to see how threads can be used for various purposes – in our case, to </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">send emails</span></span></li>
<li><span class="koboSpan" id="kobo.702.1">You can read</span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.703.1"> more about Celery </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">at </span></span><a href="http://docs.celeryproject.org/en/latest/index.html"><span class="No-Break"><span class="koboSpan" id="kobo.705.1">http://docs.celeryproject.org/en/latest/index.html</span></span></a></li>
</ul>
</div>
</body></html>