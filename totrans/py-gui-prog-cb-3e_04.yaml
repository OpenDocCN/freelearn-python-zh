- en: Data and Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will save our GUI data into `tkinter` variables. We will
    also start using **object-oriented programming** (**OOP**), writing our own classes
    in Python. This will lead us to creating reusable OOP components. By the end of
    this chapter, you will know how to save data from the GUI into local `tkinter`
    variables. You will also learn how to display tooltips over widgets, which give
    the user additional information. Knowing how to do this makes our GUI more functional
    and easier to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an overview of the Python modules for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/781646b9-8cac-45c5-b464-61edcf82442b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, we will use data and OOP classes using Python 3.7 and above.
    We will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use `StringVar()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to get data from a widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using module-level global variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How coding in classes can improve the GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing callback functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating reusable GUI components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use StringVar()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are built-in programming types in `tkinter` that differ slightly from
    the Python types we are used to programming with. `StringVar()` is one such `tkinter`
    type. This recipe will show you how to use the `StringVar()` type.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to save data from the `tkinter` GUI into
    variables so we can use that data. We can set and get their values, which is very
    similar to how you would use the Java `getter`/`setter` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the types of code in `tkinter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `strVar = StringVar()` | Holds a string; the default value is an empty string
    (`""`) |'
  prefs: []
  type: TYPE_TB
- en: '| `intVar = IntVar()` | Holds an integer; the default value is `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `dbVar = DoubleVar()` | Holds a `float`; the default value is `0.0` |'
  prefs: []
  type: TYPE_TB
- en: '| `blVar = BooleanVar()` | Holds a Boolean, it returns `0` for `False` and
    1 for `True` |'
  prefs: []
  type: TYPE_TB
- en: Different languages call numbers with decimal points `float` or `double`. `tkinter`
    calls them `DoubleVar`, which is known in Python as the `float` data type. Depending
    on the level of precision, `float` and `double` data can be different. Here, we
    are translating `DoubleVar` of `tkinter` into a Python `float` type.
  prefs: []
  type: TYPE_NORMAL
- en: This becomes clearer when we add a `DoubleVar` with a Python `float` and look
    at the resulting type, which is a Python `float` and no longer a `DoubleVar`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a `DoubleVar` of `tkinter` variable and add a `float` number
    literal to it using the `+` operator. After that, we will look at the resulting
    Python type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to see the different `tkinter` data types:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Python module and name it `GUI_PyDoubleVar_to_Float_Get.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the `GUI_PyDoubleVar_to_Float_Get.py` module, import `tkinter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an instance of the `tkinter` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `DoubleVar` and give it a value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the final `GUI_PyDoubleVar_to_Float_Get.py`
    code and the output after running the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6c066496-f89c-4344-bb7d-7313ab6ff01e.png)'
  prefs: []
  type: TYPE_IMG
- en: We can do the same with `tkinter` with regards to strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a new Python module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Python module and name it `GUI_StringVar.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the `GUI_StringVar.py` module, import `tkinter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an instance of the `tkinter` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Assign a `StringVar` of `tkinter` to the `strData` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the `strData` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the value of the `strData` variable and save it in `varData`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Print out the current value of `strData`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the final `GUI_StringVar.py` code and the output
    after running the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/784fc4b2-11ca-4ab0-b5eb-facc47a2211e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will print the default values of, `IntVar`, `DoubleVar`, and `BooleanVar`
    types of `tkinter`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `GUI_StringVar.py` and save the module as `GUI_PyVar_defaults.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code toward the bottom of this module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the final `GUI_PyVar_defaults.py` code and the
    output after running the `GUI_PyVar_defaults.py` code file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fecfbcdb-e903-4b25-b6af-10329205878b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The steps to print the default `tkinter` variable value are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Python module and name it `GUI_PyVar_Get.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following code into the module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code, optionally setting a breakpoint in your IDE in the final `print()`
    statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b99d3c95-461a-4c20-87c0-f127a8011dba.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Eclipse PyDev console, toward the bottom of the screenshot for `GUI_StringVar.py`
    in *step 8*, we can see the output printed to the console, which is Hello StringVar.
    This shows us that we have to call the `get()` method to get the data.
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen in the screenshot of `GUI_PyVar_defaults.py` in *step 3*, the
    default values do not get printed, as we would have expected when we are not calling
    `get()`.
  prefs: []
  type: TYPE_NORMAL
- en: The online literature mentions default values, but we won't see those values
    until we call the `get` method on them. Otherwise, we just get a variable name
    that automatically increments (for example, `PY_VAR3`, as can be seen in the preceding
    screenshot of `GUI_PyVar_defaults.py`).
  prefs: []
  type: TYPE_NORMAL
- en: Assigning the `tkinter` type to a Python variable does not change the outcome.
    We still do not get the default value until we call `get()` on this variable.
  prefs: []
  type: TYPE_NORMAL
- en: The value is `PY_VAR0`, not the expected `0`, until we call the `get` method.
    Now we can see the default value. We did not call `set`, so we see the default
    value automatically assigned to each `tkinter` type once we call the `get` method
    on each type.
  prefs: []
  type: TYPE_NORMAL
- en: Note how the default value of `0` gets printed to the console for the `IntVar`
    instance that we saved in the `intData` variable. We can also see the values in
    the Eclipse PyDev debugger window at the top of the screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: First, we import the `tkinter` module and alias it to the name `tk`. Next, we
    use this alias to create an instance of the `Tk` class by appending parentheses
    to `Tk`, which calls the constructor of the class. This is the same mechanism
    as calling a function; only here, we create an instance of a class.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, we use this instance assigned to the `win` variable to start the main
    event loop later in the code, but here, we are not displaying a GUI; rather, we
    are demonstrating how to use the `StringVar` type of `tkinter`.
  prefs: []
  type: TYPE_NORMAL
- en: We still have to create an instance of `Tk()`. If we comment out this line,
    we will get an error from `tkinter`, so this call is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create an instance of the `StringVar` type `tkinter` and assign it
    to our Python `strData` variable. After that, we use our variable to call the `set()` method
    on `StringVar` and after setting it to a value, we get the value, save it in a
    new variable named `varData`, and then print out its value. We've successfully
    learned how to use `StringVar()`. Now let's move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to get data from a widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the user enters data, we want to do something with it in our code. This
    recipe shows how to capture data in a variable. In the previous recipe, we created
    several `tkinter` class variables. They were standalone. Now, we are connecting
    them to our GUI, using the data we get from the GUI, and storing them in Python
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will continue using the Python GUI we were building in [Chapter 3](ad17a5cd-0b92-4796-96b8-35151c3bbf44.xhtml),
    *Look and Feel Customization*. We'll reuse and enhance the code from `GUI_progressbar.py`
    from that chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will assign a value from our GUI to a Python variable:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `GUI_progressbar.py` from [Chapter 3](ad17a5cd-0b92-4796-96b8-35151c3bbf44.xhtml), *Look
    and Feel Customization*, and save the module as `GUI_data_from_widget.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code toward the bottom of our module. Just above the main
    event loop, add `strData`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add code to place the cursor into the name entry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the GUI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code gives us the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3c8942f3-1f96-47ad-b9d0-f62602f76888.png)'
  prefs: []
  type: TYPE_IMG
- en: We placed our code above the GUI main event loop, so the printing happens before
    the GUI becomes visible. We would have to place the code into a callback function
    if we wanted to print out the current value after displaying the GUI and changing
    the value of the `Spinbox` control.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will retrieve the current value of the `Spinbox` control:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create our `Spinbox` widget using the following code, hard-coding the available
    values into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also move the hard-coding of the data out of the creation of the `Spinbox`
    class instance and set it later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It does not matter how we create our widget and insert data into it because
    we can access this data by using the `get()` method on the instance of the widget.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to get the values out of our GUI written using `tkinter`, we use the `get()`
    method of `tkinter` on an instance of the widget we wish to get the value from.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we used the `Spinbox` control, but the principle is
    the same for all widgets that have a `get()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have got the data, we are in a pure Python world, and `tkinter` did
    serve us well in building our GUI. Now that we know how to get the data out of
    our GUI, we can use this data.
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully learned how to get data from a widget. Now let's move on
    to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Using module-level global variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encapsulation is a major strength in any programming language, enabling us to
    program using OOP. Python is both OOP-friendly as well as procedural. We can create
    `global` variables that are localized to the module they reside in. They are `global`
    only to this module, which is one form of encapsulation. Why do we want this?
    Because as we add more and more functionality to our GUI, we want to avoid naming
    conflicts that could result in bugs in our code.
  prefs: []
  type: TYPE_NORMAL
- en: We do not want naming clashes creating bugs in our code! Namespaces are one
    way to avoid these bugs, and in Python, we can do this by using Python modules
    (which are unofficial namespaces).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can declare module-level **globals **in any module just above and outside
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: We then have to use the `global` Python keyword to refer to them. If we forget
    to use `global` in functions, we will accidentally create new local variables.
    This would be a bug and something we really do not want to do.
  prefs: []
  type: TYPE_NORMAL
- en: Python is a dynamic, strongly typed language. We will notice bugs such as this
    (forgetting to scope variables with the `global` keyword) only at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following code to the GUI we used in the previous recipe, *How to get
    data from a widget*, creating a module-level global variable. We use the all-uppercase
    convention for constants:'
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information in **PEP 8 -- Style Guide for Python Code** at [https://www.python.org/dev/peps/pep-0008/#constants](https://www.python.org/dev/peps/pep-0008/#constants).
  prefs: []
  type: TYPE_NORMAL
- en: Open `GUI_data_from_widget.py` and save the module as `GUI_const_42_print.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the constant variable at the top and the `print` statement at the bottom
    of the module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code results in a printout of the `global`. Note 42 being printed
    to the Eclipse console (`GUI_const_42_print.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/18585c62-9166-43f4-8f70-eb68ae38d6bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the `usingGlobal` function toward the bottom of the module:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `GUI_const_42_print.py` and save the module as `GUI_const_42_print_func.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the function and then call it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the final `GUI_const_42_print_func.py` code
    and the output after running the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ec32da05-1b4b-4505-ac9f-a06e36e7bfc5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding code snippet, we use the module-level `global`. It is easy
    to make a mistake by *shadowing* the `global`, as demonstrated in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `GUI_const_42_print_func.py` and save the module as `GUI_const_42_777.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the declaration of the constant within the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the final `GUI_const_42_777.py` code and the
    output after running the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8319b1c4-856b-4f2f-bd19-476603bd1212.png)'
  prefs: []
  type: TYPE_IMG
- en: Note how 42 becomes 777, even though we are using the same variable name.
  prefs: []
  type: TYPE_NORMAL
- en: There is no compiler in Python that warns us if we override `global` variables
    in a local function. This can lead to difficulties in debugging at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to print out the value of the global variable, without using the `global` keyword,
    we get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `GUI_const_42_777.py` and save the module as `GUI_const_42_777_global_print_error.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Comment out `global` and try to print:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7fa827ff-bdd9-4ac9-8734-36731565d8d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we qualify our local variable with the `global` keyword, we can print
    out the value of the `global` variable and overwrite this value locally:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `GUI_const_42_777_global.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ebd144a8-b0dc-489d-a062-9a603ae6fe7b.png)'
  prefs: []
  type: TYPE_IMG
- en: We might believe that the value of the global variable is local to our function.
  prefs: []
  type: TYPE_NORMAL
- en: Open `GUI_const_42_777_global.py` and save as `GUI_const_42_777_global_shadowing.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `print('GLOBAL_CONST:', GLOBAL_CONS``T)` below the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and observe the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7cfb263b-4094-4eb2-9e8d-b97936b723f6.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We define a `global` variable at the top of our module, and we print out its
    value later, toward the bottom of our module.
  prefs: []
  type: TYPE_NORMAL
- en: That works. We then define a function and print out the value of the `global`
    within the function by using the `global` keyword. If we forget to use the `global`
    keyword, we are creating a new, local variable. When we change the value of the
    global inside the function, this actually changes the global variable. As we can
    see, even outside of our function the global value has changed.
  prefs: []
  type: TYPE_NORMAL
- en: '`global` variables can be very useful when programming small applications.
    They can help us make data available across methods and functions within the same
    Python module and, sometimes, the overhead of OOP is not justified.'
  prefs: []
  type: TYPE_NORMAL
- en: As our programs grow in complexity, the benefit we gain from using globals can
    quickly diminish.
  prefs: []
  type: TYPE_NORMAL
- en: It is best to avoid globals and accidentally shadowing variables by using the
    same name in different scopes. We can use OOP instead of using global variables.
  prefs: []
  type: TYPE_NORMAL
- en: We have played around with `global` variables within procedural code and have
    learned how it can lead to hard-to-debug bugs. In the next recipe, we will move
    on to OOP, which can eliminate such bugs.
  prefs: []
  type: TYPE_NORMAL
- en: How coding in classes can improve the GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been coding in a procedural style. This is a quick scripting
    method we can do in Python. When our code gets larger and larger, we need to advance
    to coding in OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Why?
  prefs: []
  type: TYPE_NORMAL
- en: Because, among many other benefits, OOP allows us to move code around by using
    methods. Once we use classes, we no longer have to physically place the code above
    the code that calls it. This gives us great flexibility in organizing our code.
    We can write the related code next to the other code and no longer have to worry
    that the code will not run because the code does not sit above the code that calls
    it. We can take that to some rather fancy extremes by coding up modules that refer
    to methods that are not being created within that module. They rely on the runtime
    state having created those methods during the time the code runs.
  prefs: []
  type: TYPE_NORMAL
- en: If the methods we call have not been created by that time, we get a runtime
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will turn our entire procedural code into OOP very simply. We just turn it
    into a class, indent all the existing code, and prepend `self` to all variables.
  prefs: []
  type: TYPE_NORMAL
- en: It is very easy.
  prefs: []
  type: TYPE_NORMAL
- en: While at first it might feel a little bit annoying having to prepend everything
    with the `self` keyword, making our code more verbose (<q>hey, we are wasting
    so much paper…</q>), in the end it is worth it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that in the Eclipse IDE, the PyDev editor hints at coding problems by highlighting
    them in red on the right-hand side portion of the code editor.
  prefs: []
  type: TYPE_NORMAL
- en: Open `GUI_const_42_777_global.py` and save the module as `GUI_OOP_classes.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Highlight the entire code below the imports and indent it by four spaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `class OOP():` above the indented code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look at all of the red errors in the code editor on the right-hand side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f853c7d0-376d-419c-9be3-7cda5f228967.png)'
  prefs: []
  type: TYPE_IMG
- en: We have to prepend all the variables with the `self` keyword and also bind the
    functions to the class by using `self`, which officially and technically turns
    the functions into methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s prefix everything with `self` to fix all of the red so we can run our
    code again:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `GUI_OOP_classes.py` and save the module as `GUI_OOP_2_classes.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `self` keyword wherever it is needed, for example, `click_me(self)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and observe it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a6a8afb0-489a-487a-bdc8-80a7335a3ad6.png)'
  prefs: []
  type: TYPE_IMG
- en: Once we do this for all of the errors highlighted in red, we can run our Python
    code again. The `click_me` function is now bound to the class and has officially
    become a method. We are no longer getting any errors that prevent the code from
    running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add our `ToolTip` class from [Chapter 3](ad17a5cd-0b92-4796-96b8-35151c3bbf44.xhtml), *Look
    and Feel Customization*, into this Python module:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `GUI_OOP_2_classes.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `ToolTip` class from `GUI_tooltip.py` to the top of the following module''s
    `import` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are translating our procedural code into object-oriented code. First, we
    indented the entire code and defined the code to be part of a class, which we
    named `OOP`. In order to make this work, we have to use the `self` keyword for
    both variables and methods. Here is a brief comparison of our previous code with
    the new OOP code using a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We moved the callback methods to the top of the module, inside the new `OOP`
    class. We moved all the widget-creation code into one rather long method, `create_widgets`,
    which we call in the initializer of the class. Technically, deep underneath the
    hood of the low-level code Python does have a constructor, yet Python frees us
    from any worries about this. It is taken care of for us. Instead, in addition
    to a real constructor, Python provides us with an initializer, `__init__(self)`.
    We are strongly encouraged to use this initializer. We can use it to pass in arguments
    to our class, initializing variables we wish to use inside our class instance.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, we added the `ToolTip` class to the top of our module just below
    the `import` statements.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, several classes can exist within the same Python module and the module
    name does not have to be the same as the class name.
  prefs: []
  type: TYPE_NORMAL
- en: Here, in this recipe, we can see that more than one class can live in the same
    Python module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cool stuff, indeed! Here are two screenshots of the two classes residing in
    the same module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56dfa16e-0c33-4574-8b94-2c90a679e929.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Both the `ToolTip` class and the `OOP` class reside within the same Python
    module, `GUI_OOP_2_classes.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6555f80c-5f89-46ed-a9a4-7241103518ef.png)'
  prefs: []
  type: TYPE_IMG
- en: In this recipe, we advanced our procedural code into OOP code. Python enables
    us to write code in both a practical and a procedural style, like the C programming
    language style. At the same time, we have the option to code in an OOP style,
    like the Java, C#, and C++ style.
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully learned how coding in classes can improve the GUI. Now let's
    move on to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Writing callback functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At first, callback functions can seem to be a little bit intimidating. You call
    the function, passing it some arguments, and then the function tells you that
    it is really very busy and it will call you back!
  prefs: []
  type: TYPE_NORMAL
- en: 'You wonder: will this function ever call me back? And how long do I have to
    wait? In Python, even callback functions are easy and, yes, they usually do call
    you back. They just have to complete their assigned task first (<q>hey, it was
    you who coded them in the first place…</q>).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn a little bit more about what happens when we code callbacks into
    our GUI. Our GUI is event-driven. After it has been created and displayed onscreen,
    it typically sits there waiting for an event to happen. It is basically waiting
    for an event to be sent to it. We can send an event to our GUI by clicking one
    of its buttons. This creates an event and, in a sense, we called our GUI by sending
    it a message.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what is supposed to happen after we send a message to our GUI? What happens
    after clicking the button depends on whether we created an event handler and associated
    it with this button. If we did not create an event handler, clicking the button
    will have no effect. The event handler is a callback function (or method, if we
    use classes). The callback method is also sitting there passively, like our GUI,
    waiting to be invoked. Once our GUI's button is clicked, it will invoke the callback.
  prefs: []
  type: TYPE_NORMAL
- en: The callback often does some processing and, when done, it returns the result
    to our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: In a sense, we can see that our callback function is calling our GUI back.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python interpreter runs through all the code in a module once, finding any
    syntax errors and pointing them out. You cannot run your Python code if you do
    not have the syntax right. This includes indentation (if not resulting in a syntax
    error, incorrect indentation usually results in a bug).
  prefs: []
  type: TYPE_NORMAL
- en: On the next parsing round, the interpreter interprets our code and runs it.
  prefs: []
  type: TYPE_NORMAL
- en: At runtime, many GUI events can be generated, and it is usually callback functions
    that add functionality to GUI widgets.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the callback for the `Spinbox` widget:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `GUI_OOP_2_classes.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Observe the `_spin(self)` method in the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2e02ce01-c01f-4504-8ada-018d97f271aa.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We create a callback method in the `OOP` class that gets called when we select
    a value from the `Spinbox` widget because we bind the method to the widget via
    the `command` argument (`command=self._spin`). We use a leading underscore to
    hint at the fact that this method is meant to be respected like a private Java
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Python intentionally avoids language restrictions, such as private, public,
    friend, and so on. In Python, we use naming conventions instead. Leading and trailing
    double underscores surrounding a keyword are expected to be restricted to the
    Python language, and we are expected not to use them in our own Python code.
  prefs: []
  type: TYPE_NORMAL
- en: However, we can use a leading underscore prefix with a variable name or function
    to provide a hint that this name is meant to be respected as a private helper.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the same time, we can postfix a single underscore if we wish to use what
    otherwise would be built-in Python names. For example, if we wished to abbreviate
    the length of a list, we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Often, the underscore is hard to read and easy to overlook, so this might not
    be the best idea in practice.
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully learned how to write callback functions. Now let's move on
    to the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Creating reusable GUI components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create reusable GUI components using Python. In this recipe, we will
    keep it simple by moving our `ToolTip` class into its own module. Then, we will
    import and use it to display tooltips over several widgets of our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are building our code from [Chapter 3](ad17a5cd-0b92-4796-96b8-35151c3bbf44.xhtml),
    *Look and Feel Customization*: `GUI_tooltip.py`. We will start by breaking out
    our `ToolTip` class into a separate Python module.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a new Python module and place the `ToolTip` class code into
    it and then import this module into our primary module:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `GUI_OOP_2_classes.py` and save the module as `GUI_OOP_class_imported_tooltip.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Break out the `ToolTip` code from `GUI_tooltip.py` into a new Python module
    and name the module `ToolTip.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `ToolTip` class into `GUI_OOP_class_imported_tooltip.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to `GUI_OOP_class_imported_tooltip.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code and hover the mouse over the different widgets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/57a0d7d6-f7c0-4cf5-9732-470ec6d138bd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This also works on the second tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b764cef7-fe59-4565-978b-f470e2d52261.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we created a new Python module and placed the `ToolTip` class into this
    new module. Then, we imported this `ToolTip` class into a different Python module.
    After that, we created several tooltips using the class.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshots, we can see several `ToolTip` messages being displayed.
    The one for the main window might appear a little bit annoying, so it is better
    not to display a `ToolTip` for the main window because we really wish to highlight
    the functionality of the individual widgets. The main window form has a title
    that explains its purpose; no need for a `ToolTip`.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring our common `ToolTip` class code out into its own module helps us
    reuse this code from other modules. Instead of copy/paste/modify, we use the **DRY** **principle** and
    our common code is located in only one place, so when we modify the code, all
    modules that import it will automatically get the latest version of our module.
  prefs: []
  type: TYPE_NORMAL
- en: '**DRY** is short for **Don''t Repeat Yourself**, and we will look at it again
    in a later chapter. We can do similar things by turning our Tab 3 image into a
    reusable component. To keep this recipe''s code simple, we removed Tab 3, but
    you can experiment with the code from the previous chapter.'
  prefs: []
  type: TYPE_NORMAL
