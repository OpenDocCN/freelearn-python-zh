- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network Monitoring with Python – Part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 7*, *Network Monitoring with Python – Part 1*, we used SNMP to query
    information from network devices. We did this using an SNMP manager to query the
    SNMP agent residing on the network device. The SNMP information is structured
    in a hierarchy format with a specific object ID as a way to represent the value
    of the object. Most of the time, the value we care about is a number, such as
    CPU load, memory usage, or interface traffic. We can graph this data against time
    to give us a sense of how the value has changed over time.
  prefs: []
  type: TYPE_NORMAL
- en: We can typically classify the SNMP approach as a `pull` method as we constantly
    ask the device for a particular answer. This method adds a burden to the device
    because it needs to spend a CPU cycle on the control plane to find answers from
    the subsystem, package the answer in an SNMP packet, and transport the answer
    back to the poller. If you have ever been to a family reunion where you have that
    one family member who keeps asking you the same questions repeatedly, that would
    be analogous to the SNMP manager polling the managed node.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, if we have multiple SNMP pollers querying the same device every 30
    seconds (you would be surprised how often this happens), the management overhead
    will become substantial. In the same family reunion example we have given, instead
    of one family member, imagine many people interrupting you every 30 seconds to
    ask you a question. I don’t know about you, but I know I would be very annoyed
    even if it was a simple question (or worse, if all of them were asking the same
    question).
  prefs: []
  type: TYPE_NORMAL
- en: Another way we can provide more efficient network monitoring is to reverse the
    relationship between the management station from a *pull* to a *push* model. In
    other words, the information can be pushed from the device toward the management
    station in an agreed-upon format. This concept is what flow-based monitoring is
    based on. In a flow-based model, the network device streams the traffic information,
    called flow, to the management station. The format can be the Cisco proprietary
    NetFlow (version 5 or 9), the industry-standard IPFIX, or the open source sFlow
    format. In this chapter, we will spend some time looking into NetFlow, IPFIX,
    and sFlow with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Not all monitoring comes in the form of time series data. You can represent
    information such as network topology and Syslog in a time series format if you
    want to, but this is not ideal. We can use Python to check network topology information
    and see whether the topology has changed over time. We can use tools, such as
    Graphviz, with a Python wrapper to illustrate the topology. As already seen in
    *Chapter 6*, *Network Security with Python*, Syslog contains security information.
    Later in this book, we will look at using the Elastic Stack (Elasticsearch, Logstash,
    Kibana, and Beat) as an efficient way to collect and index network security and
    log information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Graphviz, which is an open source graph visualization software that can help
    us quickly and efficiently graph our network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flow-based monitoring, such as NetFlow, IPFIX, and sFlow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ntop to visualize the flow of information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by looking at how to use Graphviz to monitor network topology changes.
  prefs: []
  type: TYPE_NORMAL
- en: Graphviz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Graphviz is an open source graph visualization software. Imagine we have to
    describe our network topology to a colleague without the benefit of a picture.
    We might say our network consists of three layers: core, distribution, and access.'
  prefs: []
  type: TYPE_NORMAL
- en: The core layer comprises two routers for redundancy, and both of the routers
    are full-meshed toward the four distribution routers; the distribution routers
    are also full-meshed toward the access routers. The internal routing protocol
    is OSPF, and externally, we use BGP for peering with our service provider. While
    this description lacks some details, it is probably enough for your colleague
    to paint a pretty good high-level picture of your network.
  prefs: []
  type: TYPE_NORMAL
- en: Graphviz works similarly to the process by describing the graph in a text format
    that Graphviz can understand in a text file. We can then feed the file to the
    Graphviz program to construct the graph. Here, the graph is described in a text
    format called DOT ([https://en.wikipedia.org/wiki/DOT_(graph_description_language)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)))
    and Graphviz renders the graph based on the description. Of course, because the
    computer lacks human imagination, the language has to be very precise and detailed.
  prefs: []
  type: TYPE_NORMAL
- en: For Graphviz-specific DOT grammar definitions, take a look at [http://www.graphviz.org/doc/info/lang.html](http://www.graphviz.org/doc/info/lang.html).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will use the **Link Layer Discovery Protocol** (**LLDP**)
    to query the device neighbors and create a network topology graph via Graphviz.
    Upon completing this extensive example, we will see how we can take something
    new, such as Graphviz, and combine it with things we have already learned (network
    LLDP) to solve interesting problems (automatically graph the current network topology).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by looking over the lab we will be using.
  prefs: []
  type: TYPE_NORMAL
- en: Lab setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the same lab topology as the last chapter. To recap, we have a three-tier
    topology, with r6 being the external facing edge device and r5 the top-of-rack
    router connecting to the server.
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B18403_08_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Lab topology'
  prefs: []
  type: TYPE_NORMAL
- en: 'The devices are vIOS devices to save on lab resources and simplify configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Nodes virtualized by NX-OS and IOS-XR are much more memory-intensive than IOS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you wish to use NX-OS, consider using NX-API or other API calls that will
    return structured data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The devices have the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Device** | **Management IP** | **Loopback IP** |'
  prefs: []
  type: TYPE_TB
- en: '| r1 | `192.168.2.218` | `192.168.0.1` |'
  prefs: []
  type: TYPE_TB
- en: '| r2 | `192.168.2.219` | `192.168.0.2` |'
  prefs: []
  type: TYPE_TB
- en: '| r3 | `192.168.2.220` | `192.168.0.3` |'
  prefs: []
  type: TYPE_TB
- en: '| r5 | `192.168.2.221` | `192.168.0.4` |'
  prefs: []
  type: TYPE_TB
- en: '| r6 | `192.168.2.222` | `192.168.0.5` |'
  prefs: []
  type: TYPE_TB
- en: 'The Ubuntu host’s information is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Device Name** | **External Link Eth0** | **Internal IP Eth1** |'
  prefs: []
  type: TYPE_TB
- en: '| Client | `192.168.2.211` | `10.0.0.9` |'
  prefs: []
  type: TYPE_TB
- en: '| Server | `192.168.2.212` | `10.0.0.5` |'
  prefs: []
  type: TYPE_TB
- en: For our example, we will use LLDP ([https://en.wikipedia.org/wiki/Link_Layer_Discovery_Protocol](https://en.wikipedia.org/wiki/Link_Layer_Discovery_Protocol)).
    It is a vendor-neutral link-layer neighbor discovery protocol. Let us proceed
    to install the necessary software packages.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Graphviz can be obtained via `apt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After the installation is complete, note that verification is performed by
    using the `dot` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the Python wrapper for Graphviz, so let’s install it now while
    we are at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take a look at how we can use the software.
  prefs: []
  type: TYPE_NORMAL
- en: Graphviz examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like most popular open source projects, the documentation of Graphviz ([https://www.graphviz.org/documentation/](https://www.graphviz.org/documentation/))
    is extensive. The challenge for someone new to the software is often the starting
    point, going from zero to one. For our purpose, we will focus on the dot graph,
    which draws directed graphs as hierarchies (not to be confused with the DOT language,
    which is a graph description language).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with some of the basic concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Nodes represent our network entities, such as routers, switches, and servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The edges represent the links between the network entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The graph, nodes, and edges each have attributes ([https://www.graphviz.org/doc/info/attrs.html](https://www.graphviz.org/doc/info/attrs.html))
    that can be tweaked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After describing the network, we can output the network graph ([https://www.graphviz.org/doc/info/output.html](https://www.graphviz.org/doc/info/output.html))
    in either PNG, JPEG, or PDF format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our first example, `chapter8_gv_1.gv`, is an undirected dot graph consisting
    of four nodes (`core`, `distribution`, `access1`, and `access2`). The edges, represented
    by the dash (`-`) sign, join the core node to the distribution node, as well as
    the distribution node to both of the access nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The graph can be output in the `dot -T<format> source -o <output file>` command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The resultant graph can be viewed from the following output folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18403_08_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Graphviz undirected dot graph example'
  prefs: []
  type: TYPE_NORMAL
- en: Just like *Chapter 7*, *Network Monitoring with Python – Part 1*, it might be
    easier to work in the Linux desktop window while working with these graphs so
    you can see the graphs right away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we can use a directional graph by specifying the graph as a digraph
    and using the arrow (`->`) sign to represent the edges. There are several attributes
    we can modify in the case of nodes and edges, such as the node shape, edge labels,
    etc. The same graph can be modified as follows in `chapter8_gv_2.gv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will output the file in PDF this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the directional arrows in the new graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18403_08_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Network graph with directional arrows and line descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s take a look at the Python wrapper around Graphviz.
  prefs: []
  type: TYPE_NORMAL
- en: Python with Graphviz examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can reproduce the same topology graph as before using the Python Graphviz
    package and construct the same three-layer network topology:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The code produces what you would normally write in the DOT language but in
    a more Pythonic way. You can view the source of the graph before the graph generation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The graph can be rendered by the `render()` method. By default, the output
    format is PDF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The Python package wrapper closely mimics all the API options of Graphviz. You
    can find documentation about the options on the Graphviz Read the Docs website
    ([http://graphviz.readthedocs.io/en/latest/index.html](http://graphviz.readthedocs.io/en/latest/index.html)).
    You can also refer to the source code on GitHub for more information ([https://github.com/xflr6/graphviz](https://github.com/xflr6/graphviz)).
    We are now ready to use the tool to map out our network.
  prefs: []
  type: TYPE_NORMAL
- en: LLDP neighbor graphing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will use the example of mapping out LLDP neighbors to illustrate
    a problem-solving pattern that has helped me over the years:'
  prefs: []
  type: TYPE_NORMAL
- en: Modularize each task into smaller pieces, if possible. In our example, we can
    combine a few steps, but if we break them into smaller pieces, we will be able
    to reuse and improve them more easily.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use an automation tool to interact with the network devices, but keep the more
    complex logic aside at the management station. For example, the router has provided
    an LLDP neighbor output that is a bit messy. In this case, we will stick with
    the working command and the output and use a Python script at the management station
    to parse out the output we need.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When given choices for the same task, pick the one that can be reused. In our
    example, we can use low-level Pexpect, Paramiko, or Ansible playbooks to query
    the routers. In my opinion, Ansible is a more reusable option, so that is what
    I have picked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To get started, since LLDP is not enabled on the routers by default, we will
    need to configure them on the devices first. By now, we know we have a number
    of options to choose from; in this case, I chose the Ansible playbook with the
    `ios_config` module for the task. The `hosts` file consists of five routers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Each host contains the corresponding names in the `host_vars` folder. We are
    showing `r1` as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cisco_config_lldp.yml` playbook consists of one play with the `ios_lldp`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `ios_lldp` Ansible module is new in version 2.5 and later. Use the `ios_config`
    module if you are using an older version of Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the playbook to turn on `lldp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the default `lldp` advertise timer is 30 seconds, we should wait a bit
    for `lldp` advertisements to be exchanged between the devices. We can verify that
    LLDP is indeed active on the routers and the neighbors it has discovered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In older versions of CML, e.g. VIRL, or other lab software, you might see LLDP
    neighbors on the `G0/0` MGMT interfaces. What we really care about are the `G0/1`
    and `G0/2` interfaces that are directly connected to other peers. This information
    will come in handy as we prepare to parse the output and construct our topology
    graph.
  prefs: []
  type: TYPE_NORMAL
- en: Information retrieval
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can now use another Ansible playbook, namely `cisco_discover_lldp.yml`, to
    execute the LLDP command on the device and copy the output of each device to a
    `tmp` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the `tmp` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The playbook will have three tasks. The first task will execute the `show lldp`
    neighbor command on each of the devices, the second task will display the output,
    and the third task will copy the output to a text file in the output directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After execution, the `./tmp` directory now contains all the routers’ output
    (showing LLDP neighbors) in its own file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`r1_lldp_output.txt`, as with the rest of the output files, contains the `output.stdout_lines`
    variable from the Ansible playbook for each device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have worked on retrieving information from network devices. Now we
    are ready to tie everything together with a Python script.
  prefs: []
  type: TYPE_NORMAL
- en: Python parser script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can now use a Python script to parse the LLDP neighbor output from each device
    and construct a network topology graph from the results. The purpose is to automatically
    check the device to see whether any LLDP neighbors have disappeared due to link
    failure or other issues. Let’s look at the `cisco_graph_lldp.py` file and see
    how that is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the necessary imports of the packages: an empty list that we
    will populate with tuples of node relationships. We also know that `Gi0/0` on
    the devices is connected to the management network; therefore, we are only searching
    for `Gi0/[1234]` as our regular expression pattern in the `show LLDP neighbors`
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the `glob.glob()` method to traverse the `./tmp` directory of all
    the files, parse out the device name, and find the neighbors that the device is
    connected to. There are some embedded print statements in the script that we can
    comment out for the final version; if the statements are uncommented, we can see
    the parsed result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The fully populated edge list contains tuples that consist of the device and
    its neighbors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now construct the network topology graph using the Graphviz package.
    The most important part is the unpacking of the tuples that represent the edge
    relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to print out the resulting source dot file, it would be an accurate
    representation of our network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, it is confusing to see the same link twice; for example, the `r2`
    to `r5-tor` link appeared twice in the previous diagram for each of the directions
    of the link. As network engineers, we understand that sometimes a fault in the
    physical link will result in a unidirectional link, which we don’t want to see.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to graph the diagram as is, the placement of the nodes would be
    a bit funky. The placement of the nodes is auto-rendered. The following diagram
    illustrates the rendering in a default layout as well as the `neato` layout, namely,
    a digraph (`My_Network`, `engine=''neato''`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18403_08_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Topology graph 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `neato` layout represents an attempt to draw undirected graphs with even
    less hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18403_08_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Topology graph 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, the default layout presented by the tool is just fine, especially
    if your goal is to detect faults instead of making them visually appealing. However,
    in this case, let’s see how we can insert raw DOT language knobs into the source
    file. From research, we know that we can use the `rank` command to specify the
    level where some nodes can stay on the same level. However, there is no option
    presented in the Graphviz Python API. Luckily, the dot source file is just a string,
    which we can insert as raw dot comments using the `replace()` method with the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The end result is a new source that we can render the final topology graph
    from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The graph is now good to go with the correct hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18403_08_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: Topology graph 3'
  prefs: []
  type: TYPE_NORMAL
- en: We have used the Python script to automatically retrieve network information
    from the devices and automatically graph the topology. It is quite a bit of work,
    but the reward is the consistency and the assurance that the graph always represents
    the latest state of the actual network. Let’s follow up with some verification
    that our script can detect the latest state change of the network with the necessary
    graph.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the playbook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are now ready to incorporate a test to check whether the playbook can accurately
    depict the topology change when a link change happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test this by shutting down the `Gi0/1` and `Go0/2` interfaces on `r6-edge`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When the LLDP neighbor passes the hold timer, they will disappear from the
    LLDP table on `r6-edge`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the playbook and the Python script, the graph will automatically
    show `r6-edge` only connects to `r3` and we can start to troubleshoot why that
    is the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18403_08_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: Topology graph 4'
  prefs: []
  type: TYPE_NORMAL
- en: This is a relatively long example demonstrating multiple tools working together
    to solve a problem. We used the tools we have learned – Ansible and Python – to
    modularize and break tasks into reusable pieces.
  prefs: []
  type: TYPE_NORMAL
- en: We then used a new tool, namely, Graphviz, to help monitor the network for non-time
    series data, such as network topology relationships.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will change direction a bit and look into monitoring
    our network with network flows collected by our network equipment.
  prefs: []
  type: TYPE_NORMAL
- en: Flow-based monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the chapter introduction, besides polling technology, such as
    SNMP, we can also use a push strategy, which allows the device to push network
    information toward the management station. NetFlow and its closely associated
    cousins, IPFIX and sFlow, are examples of such information pushed from the direction
    of the network device toward the management station. We can argue that the `push`
    method is more sustainable since the network device is inherently in charge of
    allocating the necessary resources to push the information. If the device CPU
    is busy, for example, it can skip the flow export process in favor of a more critical
    task such as routing packets.
  prefs: []
  type: TYPE_NORMAL
- en: A flow, as defined by IETF ([https://www.ietf.org/proceedings/39/slides/int/ip1394-background/tsld004.htm](https://www.ietf.org/proceedings/39/slides/int/ip1394-background/tsld004.htm)),
    is a sequence of packets moving from an application sending something to the application
    receiving it. If we refer back to the OSI model, a flow is what constitutes a
    single unit of communication between two applications. Each flow comprises some
    packets; some flows have more packets (such as a video stream), while some have
    just a few (such as an HTTP request). If you think about flows for a minute, you’ll
    notice that routers and switches might care about packets and frames, but the
    application and user usually care more about the network flows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flow-based monitoring usually refers to NetFlow, IPFIX, and sFlow:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NetFlow**: NetFlow v5 is a technology where the network device caches flow
    entries and aggregates packets by matching the set of tuples (source interface,
    source IP/port, destination IP/port, and so on). Once a flow is completed, the
    network device exports the flow characteristics, including total bytes and packet
    counts, to the management station.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IPFIX**: IPFIX is the proposed standard for structured streaming and is similar
    to NetFlow v9, also known as Flexible NetFlow. Essentially, it is a definable
    flow export, which allows the user to export nearly anything that the network
    device knows about. The flexibility often comes at the expense of simplicity compared
    to NetFlow v5\. The configuration of IPFIX is more complex than the traditional
    NetFlow v5\. Additional complexity makes it less ideal for introductory learning.
    However, once you are familiar with NetFlow v5, you can parse IPFIX as long as
    you match the template definition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sFlow**: sFlow has no notion of a flow or packet aggregation by itself. It
    performs two types of sampling of packets. It randomly samples one out of “n”
    packets/applications and has a time-based sampling counter. It sends the information
    to the management station, and the station derives the network flow information
    by referring to the type of packet sample received along with the counters. As
    it doesn’t perform any aggregation on the network device, you can argue that sFlow
    is more scalable than NetFlow and IPFIX.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best way to learn about each one of these is probably to dive right into
    examples. Let’s get into some of the flow-based examples in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: NetFlow parsing with Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use Python to parse the NetFlow datagram transported on the wire. This
    allows us to look at the NetFlow packet in detail and troubleshoot any NetFlow
    issues that are not working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s generate traffic between the client and server across the lab
    network. We can use the built-in HTTP server module from Python to quickly launch
    a simple HTTP server on the VIRL host acting as the server. Open a new Terminal
    window to the server host and start the HTTP server; let’s keep the window open:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: For Python 2, the module is named `SimpleHTTPServer`, for example, `python2
    -m SimpleHTTPServer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a separate Terminal window, `ssh` to the client. We can create a short `while`
    loop in a Python script to continuously send `HTTP GET` to the web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The client should get a very plain HTML page every 5 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look back to the server Terminal window, we should also see the requests
    continuously coming in from the client every 5 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The traffic from the client to the server traverses through the network devices,
    and we can export NetFlow from any of the devices in between. Since `r6-edge`
    is the first hop for the client host, we will have this router export NetFlow
    to the management host at port `9995`.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we use only one device for demonstration; therefore, we manually
    configure it with the necessary commands. In the next section, when we enable
    NetFlow on all the devices, we will use an Ansible playbook to configure all the
    routers at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following configurations are necessary for exporting NetFlow on Cisco IOS
    devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s look at the Python parser script that helps us separate the different
    network flow fields we received from network devices.
  prefs: []
  type: TYPE_NORMAL
- en: Python Socket and Struct
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The script, `netFlow_v5_parser.py`, was modified from Brian Rak’s blog post
    at [http://blog.devicenull.org/2013/09/04/python-netflow-v5-parser.html](http://blog.devicenull.org/2013/09/04/python-netflow-v5-parser.html).
    The modification was mainly for Python 3 compatibility and parsing additional
    NetFlow version 5 fields. The reason we chose NetFlow v5 instead of NetFlow v9
    is that v9 is more complex and uses templates to map out the fields, making it
    more difficult to learn in an introductory session. However, since NetFlow version
    9 is an extended format of the original NetFlow version 5, all the concepts we
    introduced in this section apply to it.
  prefs: []
  type: TYPE_NORMAL
- en: Because NetFlow packets are represented in bytes over the wire, we will use
    the Python struct module included in the standard library to convert bytes into
    native Python data types.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the two modules at [https://docs.python.org/3.10/library/socket.html](https://docs.python.org/3.10/library/socket.html)
    and [https://docs.python.org/3.10/library/struct.html](https://docs.python.org/3.10/library/struct.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the script, we will start by using the `socket` module to bind and listen
    for the UDP datagrams. With `socket.AF_INET`, we intend on listening to the IPv4
    address sockets; with `socket.SOCK_DGRAM`, we specify that we’ll see the UDP datagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We will start a loop and retrieve information off the wire 1,500 bytes at a
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line is where we begin to deconstruct or unpack the packet. The
    first argument of `!HH` specifies the network’s big-endian byte order with the
    exclamation point (big-endian) as well as the format of the C type (`H = 2` byte
    unsigned short integer):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The first 4 bytes include the version and the number of flows exported in this
    packet. If you do not remember the NetFlow version 5 header off the top of your
    head (that was a joke, by the way; I only read the header when I want to fall
    asleep quickly), here is a glance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18403_08_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: NetFlow v5 header (source: http://www.cisco.com/c/en/us/td/docs/net_mgmt/netﬂow_collection_engine/3-6/user/guide/format.html#wp1006108)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the header can be parsed accordingly, depending on the byte location
    and data type. Python allows us to unpack several header items in a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `while` loop that follows will fill the `nfdata` dictionary with the flow
    record that unpacks the source address and port, destination address and port,
    packet count, and byte count and print the information out on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the script allows you to visualize the header as well as the
    flow content at a glance. In the following output, we can see both BGP control
    packets (TCP port `179`) as well as HTTP traffic (TCP port `8000`) on `r6-edge`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in NetFlow version 5, the record size is fixed at 48 bytes; therefore,
    the loop and script are relatively straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the case of NetFlow version 9 or IPFIX, after the header, there
    is a template FlowSet ([http://www.cisco.com/en/US/technologies/tk648/tk362/technologies_white_paper09186a00800a3db9.html](http://www.cisco.com/en/US/technologies/tk648/tk362/technologies_white_paper09186a00800a3db9.html))
    that specifies the field count, field type, and field length. This allows the
    collector to parse the data without knowing the data format in advance. We will
    need to build additional logic in the Python script for NetFlow version 9.
  prefs: []
  type: TYPE_NORMAL
- en: By parsing the NetFlow data in a script, we gained a solid understanding of
    the fields, but this is very tedious and hard to scale. As you may have guessed,
    other tools save us the problem of parsing NetFlow records one by one. Let’s look
    at one such tool, called **ntop**, in the coming section.
  prefs: []
  type: TYPE_NORMAL
- en: ntop traffic monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like the PySNMP script in *Chapter 7*, *Network Monitoring with Python – Part
    1**,* and the NetFlow parser script in this chapter, we can use Python scripts
    to handle low-level tasks on the wire. However, there are tools such as Cacti,
    which is an all-in-one open source package that includes data collection (pollers),
    data storage (RRDs), and a web frontend for visualization. These tools can save
    you a lot of work by packing the frequently used features and software in one
    package.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of NetFlow, there are several open source and commercial NetFlow
    collectors we can choose from. If we do a quick search for the top N open source
    NetFlow analyzers, we will see several comparison studies for different tools.
  prefs: []
  type: TYPE_NORMAL
- en: Each one has its strengths and weaknesses; which one to use is a matter of preference,
    platform, and appetite for customization. I would recommend choosing a tool that
    would support both v5 and v9, and potentially sFlow. A secondary consideration
    would be whether the tool is written in a language that we can understand; I would
    imagine having Python extensibility would be a nice thing.
  prefs: []
  type: TYPE_NORMAL
- en: Two of the open source NetFlow tools I like and have used before are NfSen (with
    NFDUMP as the backend collector) and `ntop` (or `ntopng`). Between the two of
    them, `ntop` is the better-known traffic analyzer; it runs on both Windows and
    Linux platforms and integrates well with Python. Therefore, let’s use `ntop` as
    an example in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to Cacti, ntop is an all-in-one tool. I recommend installing ntop on
    a separate host than the management station in production or a container on the
    management station.
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation of our Ubuntu host is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The installation process will prompt for the necessary interface for listening
    and setting the administrator password. By default, the `ntop` web interface listens
    on port `3000`, while the probe listens on UDP port `5556`. On the network device,
    we need to specify the location of the NetFlow exporter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: By default, IOSv creates a VRF called `Mgmt-intf` and places `Gi0/0` under VRF.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need to specify the direction of traffic exports, such as `ingress`
    or `egress`, under the interface configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: For your reference, I have included the Ansible playbook, `cisco_config_netflow.yml`,
    to configure the lab device for the NetFlow export.
  prefs: []
  type: TYPE_NORMAL
- en: '`r5-tor` and `r6-edge` have two more interfaces than `r1`, `r2`, and `r3`;
    therefore, there is an additional playbook to enable the additional interfaces
    for them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the playbook and make sure the changes were applied properly on the
    devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'It is always a good idea to verify the device configuration after the playbook
    is run, so let’s spot-check on `r2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Once everything is set up, you can check the **ntop** web interface for local
    IP traffic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18403_08_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: ntop local IP traffic'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most often used features of ntop is using it to look at the Top
    Talkers graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table  Description automatically generated](img/B18403_08_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.10: ntop top talkers'
  prefs: []
  type: TYPE_NORMAL
- en: The ntop reporting engine is written in C; it is fast and efficient, but the
    need to have adequate knowledge of C to do something as simple as changing the
    web frontend does not fit the modern agile development mindset.
  prefs: []
  type: TYPE_NORMAL
- en: After a few false starts with Perl in the mid-2000s, the good folks at ntop
    finally settled on embedding Python as an extensible scripting engine. Let’s take
    a look.
  prefs: []
  type: TYPE_NORMAL
- en: Python extension for ntop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use Python to extend ntop through the ntop web server. The ntop web
    server can execute Python scripts. At a high level, the scripts will involve the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Methods to access the state of ntop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python CGI module to process forms and URL parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making templates that generate dynamic HTML pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each Python script can read from `stdin` and print out `stdout/stderr`. The
    `stdout` script is the returned HTTP page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Several resources come in handy with Python integration. Under the web interface,
    you can click on **About | Show Configuration** to see the Python interpreter
    version as well as the directory for your Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing table  Description automatically generated](img/B18403_08_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: Python version'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also check the various directories where the Python script should reside:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table  Description automatically generated](img/B18403_08_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.12: Plugin directories'
  prefs: []
  type: TYPE_NORMAL
- en: 'Under **About | Online Documentation | Python ntop Engine**, there are links
    for the Python API as well as the tutorial:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18403_08_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.13: Python ntop documentation'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, the `ntop` web server directly executes the Python script placed
    under the designated directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We will place our first script, namely, `chapter8_ntop_1.py`, in the directory.
    The Python `CGI` module processes forms and parses URL parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '`ntop` implements three Python modules; each one of them has a specific purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ntop**: This module interacts with the `ntop` engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Host**: This module drills down into a specific host’s information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interfaces**: This module represents the information about the localhost
    interfaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our script, we will use the `ntop` module to retrieve the `ntop` engine
    information as well as using the `sendString()` method to send the HTML body text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We will execute the Python script using `http://<ip>:3000/python/<script name>`.
    Here is the result of our `chapter8_ntop_1.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18403_08_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.14: ntop script result'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can look at another example that interacts with the interface module, `chapter8_ntop_2.py`.
    We will use the API to iterate through the interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting page will display the `ntop` interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18403_08_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.15: ntop interface information'
  prefs: []
  type: TYPE_NORMAL
- en: Besides the community version, ntop also offers a few commercial products that
    you can choose from. With the active open source community, commercial backing,
    and Python extensibility, ntop is a good choice for your NetFlow monitoring needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s take a look at NetFlow’s cousin: sFlow.'
  prefs: []
  type: TYPE_NORMAL
- en: sFlow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: sFlow, which stands for sampled flow, was originally developed by InMon ([http://www.inmon.com](http://www.inmon.com))
    and later standardized by way of RFC. The current version is v5\. Many in the
    industry believe the primary advantage of sFlow is its scalability.
  prefs: []
  type: TYPE_NORMAL
- en: sFlow uses random [one in `n` ] packet flow samples along with the polling interval
    of counter samples to estimate the traffic; this is less CPU-intensive than NetFlow
    for network devices. sFlow’s statistical sampling is integrated with the hardware
    and provides real-time, raw exports.
  prefs: []
  type: TYPE_NORMAL
- en: For scalability and competitive reasons, sFlow is generally preferred over NetFlow
    for newer vendors, such as Arista Networks, Vyatta, and A10 Networks. While Cisco
    supports sFlow on its Nexus line of products, sFlow is generally “not” supported
    on Cisco platforms.
  prefs: []
  type: TYPE_NORMAL
- en: SFlowtool and sFlow-RT with Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unfortunately, at this point, sFlow is something our CML lab devices do not
    support (not even with the NX-OSv virtual switches). You can use a Cisco Nexus
    3000 switch or other vendor switches, such as Arista, that support sFlow. Another
    good option for the lab is to use an Arista vEOS virtual instance. I have access
    to a Cisco Nexus 3048 switch running 7.0 (3), which I will use for this section
    as the sFlow exporter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration of Cisco Nexus 3000 for sFlow is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The easiest way to ingest sFlow is to use `sflowtool`. For installation instructions,
    refer to the documentation at [http://blog.sflow.com/2011/12/sflowtool.html](http://blog.sflow.com/2011/12/sflowtool.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: I am using an older version of `sFlowtool` in the lab. The newer versions work
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the installation, you can launch `sflowtool` and look at the datagram
    Nexus 3048 is sending on the standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a number of good usage examples on the sflowtool GitHub repository
    ([https://github.com/sflow/sflowtool)](https://github.com/sflow/sflowtool)); one
    of them is to use a script to receive the `sflowtool` input and parse the output.
    We can use a Python script for this purpose. In the `chapter8_sflowtool_1.py`
    example, we will use `sys.stdin.readline` to receive the input and use a regular
    expression search to print out only the lines containing the word agent when we
    see the sFlow packets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The script can be piped to `sflowtool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: There are a number of other useful output examples, such as `tcpdump`, output
    as NetFlow version 5 records, and a compact line-by-line output. This makes `sflowtool`
    flexible for different monitoring environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'ntop supports sFlow, which means you can directly export your sFlow to the
    ntop collector. If your collector is only NetFlow-aware, you can use the `-c`
    option for the `sflowtool` output in the NetFlow version 5 format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can also use InMon’s sFlow-RT ([http://www.sflow-rt.com/index.php](http://www.sflow-rt.com/index.php))
    as your sFlow analytics engine. What sets sFlow-RT apart from an operator perspective
    is its vast RESTful API, which can be customized to support your use cases. You
    can also easily retrieve the metrics from the API. You can take a look at its
    extensive API reference at: [http://www.sflow-rt.com/reference.php](http://www.sflow-rt.com/reference.php).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that sFlow-RT requires Java to run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, downloading and running sFlow-RT is straightforward ([https://sflow-rt.com/download.php](https://sflow-rt.com/download.php)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can point the web browser to HTTP port `8008` and verify the installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B18403_08_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.16: sFlow-RT version'
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as sFlow-RT receives any sFlow packets, the agents and other metrics
    will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18403_08_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.17: sFlow-RT agent IP'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two examples of using Python requests to retrieve information from
    sFlow-RT’s REST API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Consult the reference documentation for additional REST endpoints available
    for your needs.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at sFlow-based monitoring examples both as a standalone
    tool as well as part of the integration with `ntop`. sFlow is one of the newer
    flow formats that intends to address scalability issues faced with traditional
    `netflow` formats, and it’s worth us spending some time to see whether it is the
    right tool for the network monitoring tasks at hand. We are close to the end of
    this chapter, so let’s look at what we have covered.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at additional ways in which we can utilize Python
    to enhance our network monitoring efforts. We began using Python’s Graphviz package
    to create network topology graphs with real-time LLDP information reported by
    the network devices. This allows us to effortlessly show the current network topology,
    as well as to easily notice any link failures.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we used Python to parse NetFlow version 5 packets to enhance our understanding
    and troubleshooting of NetFlow. We also looked at how to use ntop and Python to
    extend ntop for NetFlow monitoring. sFlow is an alternative packet sampling technology.
    We used `sflowtool` and sFlow-RT to interpret sFlow results.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 9*, *Building Network Web Services with Python*, we will explore
    how to use the Python web framework Flask to build network web services.
  prefs: []
  type: TYPE_NORMAL
- en: Join our book community
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join our community for this book – where you can share feedback, ask questions
    to the author, and learn about new releases – follow the QR code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2903617220506617062.png)'
  prefs: []
  type: TYPE_IMG
