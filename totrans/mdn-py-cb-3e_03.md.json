["```py\n(cookbook3) % python -m pip install mypy\n```", "```py\n     r, g, b = (hx_int >> 16) & 0xFF, (hx_int >> 8) & 0xFF, hx_int & 0xFF\n    ```", "```py\n    def hex2rgb_1(hx_int): \n\n        if isinstance(hx_int, str): \n\n            if hx_int[0] == \"#\": \n\n                hx_int = int(hx_int [1:], 16) \n\n            else: \n\n                hx_int = int(hx_int, 16) \n\n        r, g, b = (hx_int >> 16) & 0xff, (hx_int >> 8) & 0xff, hx_int & 0xff \n\n        return r, g, b\n    ```", "```py\ndef hex2rgb(hx_int: int | str) -> tuple[int, int, int]: \n\n    if isinstance(hx_int, str): \n\n        if hx_int[0] == \"#\": \n\n            hx_int = int(hx_int[1:], 16) \n\n        else: \n\n            hx_int = int(hx_int, 16) \n\n    r, g, b = (hx_int >> 16) & 0xff, (hx_int >> 8) & 0xff, hx_int & 0xff \n\n    return r, g, b\n```", "```py\n(cookbook3) % mypy src/ch03/recipe_01_reveal.py \n\nsrc/ch03/recipe_01_reveal.py:15: note: Revealed type is \"builtins.int\" \n\nSuccess: no issues found in 1 source file\n```", "```py\ndef rgb_to_hsl_t(rgb: tuple[int, int, int]) -> tuple[float, float, float]: \n\n    ...\n```", "```py\ndef hsl_comp_t(hsl: tuple[float, float, float]) -> tuple[float, float, float]: \n\n    ...\n```", "```py\ndef hsl_to_rgb_t(hsl: tuple[float, float, float]) -> tuple[int, int, int]: \n\n    ...\n```", "```py\nfrom typing import TypeAlias \n\nRGB_a: TypeAlias = tuple[int, int, int] \n\nHSL_a: TypeAlias = tuple[float, float, float]\n```", "```py\n def rgb_to_hsl(color: RGB_a) -> HSL_a: \n\n    ...\n```", "```py\n def hsl_complement(color: HSL_a) -> HSL_a: \n\n    ...\n```", "```py\n def hsl_to_rgb(color: HSL_a) -> RGB_a: \n\n    ...\n```", "```py\nfrom typing import NamedTuple \n\nclass RGB(NamedTuple): \n\n    red: int \n\n    green: int \n\n    blue: int\n```", "```py\n    import random \n\n    def die() -> int: \n\n        return random.randint(1, 6) \n\n    def craps() -> tuple[int, int]: \n\n        return (die(), die())\n    ```", "```py\n    def zonk() -> tuple[int, ...]: \n\n      return tuple(die() for x in range(6))\n    ```", "```py\n    def craps_v2() -> tuple[int, ...]: \n\n        return tuple(die() for x in range(2))\n    ```", "```py\n    def dice_v2(n: int) -> tuple[int, ...]: \n\n        return tuple(die() for x in range(n))\n    ```", "```py\n    def dice_v3(n: int = 2) -> tuple[int, ...]: \n\n        return tuple(die() for x in range(n))\n    ```", "```py\n    def dice_d1(n): \n\n        return tuple(die() for x in range(n))\n    ```", "```py\n    def dice_d2(n=2): \n\n        return tuple(die() for x in range(n))\n    ```", "```py\n    def dice(n: int=2) -> tuple[int, ...]: \n\n        return tuple(die() for x in range(n))\n    ```", "```py\ndef craps_v3(): \n\n    return dice(2) \n\ndef zonk_v3(): \n\n    return dice(6)\n```", "```py\n import warnings\n```", "```py\n     if distance is None: \n\n            distance = rate * time \n\n        elif rate is None: \n\n            rate = distance / time \n\n        elif time is None: \n\n            time = distance / rate\n    ```", "```py\n        else: \n\n            warnings.warning(\"Nothing to solve for\")\n    ```", "```py\n        return dict(distance=distance, rate=rate, time=time)\n    ```", "```py\n    def rtd( \n\n        distance: float | None = None, \n\n        rate: float | None = None, \n\n        time: float | None = None, \n\n    ) -> dict[str, float | None]: \n\n        if distance is None and rate is not None and time is not None: \n\n            distance = rate * time \n\n        elif rate is None and distance is not None and time is not None: \n\n            rate = distance / time \n\n        elif time is None and distance is not None and rate is not None: \n\n            time = distance / rate \n\n        else: \n\n            warnings.warn(\"Nothing to solve for\") \n\n        return dict(distance=distance, rate=rate, time=time)\n    ```", "```py\n>>> rtd(distance=31.2, rate=6) \n\n{’distance’: 31.2, ’rate’: 6, ’time’: 5.2}\n```", "```py\n>>> result = rtd(distance=31.2, rate=6) \n\n>>> (’At {rate}kt, it takes ’ \n\n... ’{time}hrs to cover {distance}nm’).format_map(result) \n\n’At 6kt, it takes 5.2hrs to cover 31.2nm’\n```", "```py\ndef rtd2(**keywords: float) -> dict[str, float | None]: \n\n    rate = keywords.get(’rate’) \n\n    time = keywords.get(’time’) \n\n    distance = keywords.get(’distance’) \n\n    # etc.\n```", "```py\n>>> rtd2(distnace=31.2, rate=6) \n\n{’distance’: None, ’rate’: 6, ’time’: None}\n```", "```py\ndef rtd3(**keywords: float) -> dict[str, float | None]: \n\n    rate = keywords.pop(\"rate\", None) \n\n    time = keywords.pop(\"time\", None) \n\n    distance = keywords.pop(\"distance\", None) \n\n    if keywords: \n\n        raise TypeError( \n\n           f\"Invalid keyword parameter: {’’.join(keywords.keys())}\")\n```", "```py\ndef T_wc(T: float, V: float) -> float: \n\n    return 13.12 + 0.6215*T - 11.37*V**0.16 + 0.3965*T*V**0.16\n```", "```py\nimport csv \n\nfrom typing import TextIO \n\ndef wind_chill( \n\n    start_T: int, stop_T: int, step_T: int, \n\n    start_V: int, stop_V: int, step_V: int, \n\n    target: TextIO \n\n) -> None: \n\n    \"\"\"Wind Chill Table.\"\"\" \n\n    writer= csv.writer(target) \n\n    heading = [’’]+[str(t) for t in range(start_T, stop_T, step_T)] \n\n    writer.writerow(heading) \n\n    for V in range(start_V, stop_V, step_V): \n\n        row = [float(V)] + [ \n\n            T_wc(T, V) \n\n            for T in range(start_T, stop_T, step_T) \n\n        ] \n\n        writer.writerow(row)\n```", "```py\n>>> from pathlib import Path \n\n>>> p = Path(’data/wc1.csv’) \n\n>>> with p.open(’w’,newline=’’) as target: \n\n...     wind_chill(0, -45, -5, 0, 20, 2, target)\n```", "```py\ndef wind_chill_k( \n\n    *, \n\n    start_T: int, stop_T: int, step_T: int, \n\n    start_V: int, stop_V: int, step_V: int, \n\n    target: Path \n\n) -> None:\n```", "```py\n     >>> wind_chill_k(0, -45, -5, 0, 20, 2, target) \n\n    Traceback (most recent call last): \n\n    ... \n\n    TypeError: wind_chill_k() takes 0 positional arguments but 7 were given\n    ```", "```py\n     >>> p = Path(’data/wc2.csv’) \n\n    >>> with p.open(’w’, newline=’’) as output_file: \n\n    ...     wind_chill_k(start_T=0, stop_T=-45, step_T=-5, \n\n    ...     start_V=0, stop_V=20, step_V=2, \n\n    ...     target=output_file)\n    ```", "```py\nimport sys \n\nfrom typing import TextIO \n\ndef wind_chill_k2( \n\n    *, \n\n    start_T: int, stop_T: int, step_T: int, \n\n    start_V: int, stop_V: int, step_V: int, \n\n    target: TextIO = sys.stdout \n\n) -> None: \n\n    ...\n```", "```py\n    >>> wind_chill_k2( \n\n    ...     start_T=0, stop_T=-45, step_T=-5, \n\n    ...     start_V=0, stop_V=20, step_V=2)\n    ```", "```py\n    >>> import pathlib \n\n    >>> path = pathlib.Path(\"data/wc3.csv\") \n\n    >>> with path.open(’w’, newline=’’) as output_file: \n\n    ...     wind_chill_k2(target=output_file, \n\n    ...     start_T=0, stop_T=-45, step_T=-5, \n\n    ...     start_V=0, stop_V=20, step_V=2)\n    ```", "```py\n>>> help(math.sin) \n\nHelp on built-in function sin in module math: \n\nsin(x, /) \n\n    Return the sine of x (measured in radians).\n```", "```py\n>>> import math \n\n>>> math.sin(x=0.5) \n\nTraceback (most recent call last): \n\n... \n\nTypeError: math.sin() takes no keyword arguments\n```", "```py\n    def F_1(c: float) -> float: \n\n        return 32 + 9 * c / 5\n    ```", "```py\n    def F_2(c: float, /) -> float: \n\n        return 32 + 9 * c / 5\n    ```", "```py\ndef C(f: float, /, truncate: bool=False) -> float: \n\n    c = 5 * (f - 32) / 9 \n\n    if truncate: \n\n        return round(c, 0) \n\n    return c\n```", "```py\n>>> C(72) \n\n22.22222222222222 \n\n>>> C(72, truncate=True) \n\n22.0 \n\n>>> C(72, True) \n\n22.0\n```", "```py\nfrom math import radians, sin, cos, sqrt, asin \n\nMI = 3959 \n\nNM = 3440 \n\nKM = 6372 \n\ndef haversine( \n\n    lat_1: float, lon_1: float, \n\n    lat_2: float, lon_2: float, R: float \n\n) -> float: \n\n    \"\"\"Distance between points. \n\n    R is Earth’s radius. \n\n    R=MI computes in miles. Default is nautical miles. \n\n    >>> round(haversine(36.12, -86.67, 33.94, -118.40, R=6372.8), 5) \n\n    2887.25995 \n\n    \"\"\" \n\n    _lat = radians(lat_2) - radians(lat_1) \n\n    _lon = radians(lon_2) - radians(lon_1) \n\n    lat_1 = radians(lat_1) \n\n    lat_2 = radians(lat_2) \n\n    a = sqrt( \n\n        sin(_lat / 2) ** 2 + \n\n        cos(lat_1) * cos(lat_2) * sin(_lon / 2) ** 2 \n\n    ) \n\n    return R * 2 * asin(a) \n```", "```py\n    def haversine_k( \n\n        lat_1: float, lon_1: float, \n\n        lat_2: float, lon_2: float, *, R: float \n\n    ) -> float: \n\n        ... # etc.\n    ```", "```py\n    def nm_haversine_1(*args): \n\n        return haversine_k(*args, R=NM)\n    ```", "```py\n    def haversine_k( \n\n        lat_1: float, lon_1: float, \n\n        lat_2: float, lon_2: float, *, R: float \n\n    ) -> float: \n\n        ... # etc.\n    ```", "```py\n    from functools import partial \n\n    nm_haversine_3 = partial(haversine, R=NM)\n    ```", "```py\n>>> round(nm_haversine_3(36.12, -86.67, 33.94, -118.40), 2) \n\n1558.53\n```", "```py\n    def p_haversine( \n\n        R: float, \n\n        lat_1: float, lon_1: float, lat_2: float, lon_2: float \n\n    ) -> float: \n\n        # etc.\n    ```", "```py\n    from functools import partial \n\n    nm_haversine_4 = partial(p_haversine, NM) \n    ```", "```py\n>>> round(nm_haversine_4(36.12, -86.67, 33.94, -118.40), 2) \n\n1558.53\n```", "```py\nnm_haversine_L = lambda *args: haversine_k(*args, R=NM)\n```", "```py\n    def T_wc_1(T, V): \n\n        \"\"\"Computes the wind chill temperature.\"\"\"\n    ```", "```py\n    def T_wc_2(T, V): \n\n        \"\"\"Computes the wind chill temperature. \n\n        The wind-chill, :math:‘T_{wc}‘, \n\n        is based on air temperature, T, and wind speed, V. \n\n        \"\"\"\n    ```", "```py\n    def T_wc_3(T: float, V: float): \n\n        \"\"\"Computes the wind chill temperature \n\n        The wind-chill, :math:‘T_{wc}‘, \n\n        is based on air temperature, T, and wind speed, V. \n\n        :param T: Temperature in C \n\n        :param V: Wind Speed in kph \n\n        \"\"\"\n    ```", "```py\n    def T_wc_4(T: float, V: float) -> float: \n\n        \"\"\"Computes the wind chill temperature \n\n        The wind-chill, :math:‘T_{wc}‘, \n\n        is based on air temperature, T, and wind speed, V. \n\n        :param T: Temperature in C \n\n        :param V: Wind Speed in kph \n\n        :returns: Wind-Chill temperature in C \n\n        \"\"\"\n    ```", "```py\n    def T_wc_5(T: float, V: float) -> float: \n\n        \"\"\"Computes the wind chill temperature \n\n        The wind-chill, :math:‘T_{wc}‘, \n\n        is based on air temperature, T, and wind speed, V. \n\n        :param T: Temperature in C \n\n        :param V: Wind Speed in kph \n\n        :returns: Wind-Chill temperature in C \n\n        :raises ValueError: for wind speeds under 4.8 kph or T above 10C \n\n        \"\"\"\n    ```", "```py\n    def T_wc(T: float, V: float) -> float: \n\n        \"\"\"Computes the wind chill temperature \n\n        The wind-chill, :math:‘T_{wc}‘, \n\n        is based on air temperature, T, and wind speed, V. \n\n        :param T: Temperature in C \n\n        :param V: Wind Speed in kph \n\n        :returns: Wind-Chill temperature in C \n\n        :raises ValueError: for wind speeds under 4.8 kph or T above 10C \n\n        >>> round(T_wc(-10, 25), 1) \n\n        -18.8\n    ```", "```py\n     See https://en.wikipedia.org/wiki/Wind_chill \n\n        .. math:: \n\n            T_{wc}(T_a, V) = 13.2 + 0.6215 T_a - 11.37 V ^ {0.16} + 0.3965 T_a V ^ {0.16}\n    ```", "```py\ndef wind_chill_table() -> None: \n\n    \"\"\"Uses :func:‘T_wc‘ to produce a wind-chill \n\n    table for temperatures from -30C to 10C and \n\n    wind speeds from 5kph to 50kph. \n\n    \"\"\" \n\n    ... # etc.\n```", "```py\ndef fact_r(n: int) -> int: \n\n    if n == 0: \n\n        return 1 \n\n    return n * fact_r(n - 1)\n```", "```py\n    def prod_i(int_iter: Iterable[int]) -> int: \n\n        p = 1 \n\n        for x in int_iter: \n\n            p *= x \n\n        return p\n    ```", "```py\n>>> prod_i(range(1, 6)) \n\n120 \n\n>>> fact(5) \n\n120\n```", "```py\ndef loop_fact(n: int) -> int: \n\n    p = n \n\n    while n != 1: \n\n        n = n-1 \n\n        p *= n \n\n    return p\n```", "```py\ndef fibo(n: int) -> int: \n\n    if n <= 1: \n\n        return 1 \n\n    else: \n\n        return fibo(n-1) + fibo(n-2)\n```", "```py\nfrom functools import cache \n\n@cache \n\ndef fibo_r(n: int) -> int: \n\n    if n < 2: \n\n        return 1 \n\n    else: \n\n        return fibo_r(n - 1) + fibo_r(n - 2)\n```", "```py\nfrom collections.abc import Iterator \n\ndef fibo_iter() -> Iterator[int]: \n\n    a = 1 \n\n    b = 1 \n\n    yield a \n\n    while True: \n\n        yield b \n\n        a, b = b, a + b\n```", "```py\ndef fibo_i(n: int) -> int: \n\n    for i, f_i in enumerate(fibo_iter()): \n\n        if i == n: \n\n            break \n\n    return f_i\n```", "```py\nsource_path = Path(\"data/waypoints.csv\") \n\nwith source_path.open() as source_file: \n\n    reader = csv.DictReader(source_file) \n\n    start = next(reader) \n\n    for point in reader: \n\n        d = nm_haversine( \n\n            float(start[’lat’]), \n\n            float(start[’lon’]), \n\n            float(point[’lat’]), \n\n            float(point[’lon’]) \n\n        ) \n\n        print(start, point, d) \n\n        start = point\n```", "```py\n    from math import radians, sin, cos, sqrt, asin \n\n    from functools import partial \n\n    MI = 3959 \n\n    NM = 3440 \n\n    KM = 6373 \n\n    def haversine( \n\n        lat_1: float, lon_1: float, \n\n        lat_2: float, lon_2: float, *, R: float) -> float: \n\n        ...  # etc.\n    ```", "```py\n     nm_haversine = partial(haversine, R=NM)\n    ```", "```py\n    def distances_draft(): \n\n        source_path = Path(\"data/waypoints.csv\") \n\n        with source_path.open() as source_file: \n\n            reader = csv.DictReader(source_file) \n\n            start = next(reader) \n\n            for point in reader: \n\n                d = nm_haversine( \n\n                    float(start[’lat’]), \n\n                    float(start[’lon’]), \n\n                    float(point[’lat’]), \n\n                    float(point[’lon’]) \n\n                ) \n\n                print(start, point, d) \n\n                start = point\n    ```", "```py\n    def distances( \n\n        source_path: Path = Path(\"data/waypoints.csv\") \n\n    ) -> None: \n\n        ...  # etc.\n    ```", "```py\n    if __name__ == \"__main__\": \n\n        distances()\n    ```", "```py\nfrom pathlib import Path \n\nfrom ch03.recipe_11 import distances \n\nif __name__ == \"__main__\": \n\n    for trip in ’trip_1.csv’, ’trip_2.csv’: \n\n        distances(Path(’data’) / trip)\n```"]