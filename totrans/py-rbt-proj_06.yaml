- en: Bluetooth-Controlled Robotic Car
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have come a long way; now it's time to go ahead and make something even better.
    The world is going all gaga over the inception of autonomous cars and within this
    decade this will become the new normal. There is so much going on in these vehicles.
    Multiple sensors, GPS, and telemetry are all calculated in real time to make sure
    that the car is on the right course and is being driven by the system safely on
    the road, so making a robotic vehicle proves to be an ideal way to learn robotics
    and future technologies. In this book, we will always try to make technologies
    that are not only as good as the present technologies but in some ways even better.
    So, let's go ahead and get to making this autonomous vehicle one step at a time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Basics of the vehicle
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the vehicle ready
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the vehicle by Bluetooth
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics of the vehicle
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You must be thinking: what can we possibly learn about the vehicle that we
    don''t already know? This may be true, but there are a few that we must make sure
    we understand before taking on this chapter. So, let''s get started.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'First is the chassis, which we will be using: it''s is a four-wheel drive chassis
    and all the four wheels are independently controlled by a dedicated motor. Hence,
    we can change the speed of every single wheels as per our needs. We have chosen
    a four-wheel drive drivetrain as it is harder for it to get stuck on carpets and
    uneven surfaces. You can also opt for a two-wheel drive drivetrain if you want
    to do so, as it won''t make a huge difference.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Now, once you assemble the chassis you might see that it does not have a steering
    mechanism. Does this mean that the car will only go straight? Well, obviously
    not. There are many ways by which we can steer the direction of a car while making
    small vehicles. The best one is called differential turning.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'In conventional cars, there is one engine and that engine powers up the wheels;
    hence in principal all the wheels turn at the same speed. Now this works fine
    when we are going straight but whenever the car wants to turn there comes a new
    problem. Refer to the following diagram:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d25825f-2504-45ec-802c-521a0d2ade0d.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
- en: 'You will see that the wheels, which are on the inner curve, have a smaller
    diameter and the one on the outer edge has a larger diameter. You may remember
    a fact from elementary school: the larger the diameter the more the circumference,
    and vice a versa. Hence, the wheel towards the inner edge will be covering a shorter
    distance compared to the wheels on the outer edge at the same time, or in simple
    words, the inner wheels will be spinning slower and the outer wheels will be spinning
    faster.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: This problem leads to the discovery of differentials in cars, which is a round
    lump at the center of the axle of the car. What this does is that it varies the
    rate at which the wheels are spinning based on the turning radius. Genius, isn't
    it? Now, you must be thinking: this is all right, but why are you telling me all
    this? Well, because we will do the exact opposite to turn the robot. If we change
    the speed of the motors on the inner and outer edge of the turning circle, then
    the car will try to turn towards inside and similarly if we do it for the other
    end then it will try to turn in the other direction. While making wheeled robot
    this strategy is not new at all. Steering mechanisms are complicated and implementing
    them on small robot is simply a challenge. Hence this is a far simpler and easy
    way to turn your vehicle around.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Not only is this way simple but it is a very efficient and simple strategy that
    requires minimal components. It is also better as the turning radius of the vehicle
    is also reduced. In fact, if we spin the opposite sides of the wheels in the opposite
    direction at the same speed then the vehicle will turn completely on its own axis,
    making the turning radius entirely zero. this type of configuration is called
    skid-steer drive. For a robot that is wheeled and works indoors, this is a killer
    feature.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: To know more about it read more here: [https://groups.csail.mit.edu/drl/courses/cs54-2001s/skidsteer.html](https://groups.csail.mit.edu/drl/courses/cs54-2001s/skidsteer.html)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Getting the vehicle ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now is the time to go ahead and make the robotic vehicle a reality. So let's
    unbox the vehicle chassis and screw every part together. The assembly manual generally
    comes along with the kit, so it won't take long for you to complete it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Once you have completed building the kit, go ahead and segregate the wires for
    each of the motors. This is going to be a very important part of making the vehicle
    ready. So, once you have all the wires coming out of the vehicle, take a cell
    and power up each of the wheels. Notice the polarity of connection in which the
    wheels spin in the forward direction. All you have to do is to take a permanent
    marker or perhaps a nail paint and mark the wire which goes to the positive terminal
    when the motor is spinning in the forward direction. As all of these motors are
    entirely dependent on polarity for the direction, this step is key to ensure that
    whenever we power them up they always spin in the same direction. Trust me, this
    will save you a lot of headaches.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, once this is all done, connect the wires to the motor driver as shown
    in the following diagram (the wire marked by red is the wire that you marked earlier):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2025d7fc-c143-4eac-89f1-a0350ad36306.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: 'Perfect! Now everything seems sorted, except for the connection of the motor
    driver with the power source and Raspberry Pi. So let''s see how we are going
    to do it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e028196-14dc-4537-a944-af59b1443670.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: 'All right then! Time for the real deal! So the first thing we want to make
    sure is that all the connections are working exactly the way we planned them to.
    For this, we will start off with a dummy code which will simply switch all the
    motors on and in forward direction. So here is the code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The program can't be more simple than this; all we are doing here is giving
    the motor driver the command to spin the motor in one single direction. There
    might be a chance that a set of motors will be rotating in the reverse direction,
    in which case you should change the polarity of connections on the motor driver.
    This should solve the problem. Some people might think that we can make a change
    to the code as well to do this, but as per my experience it starts getting complicated
    from there and would cause you trouble if you chose the other path.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: All right then, everything is set and all is working well. Go ahead, try some
    other output permutations and combinations and see what happens to the car. Don't
    worry, whatever you do, you won't be able to damage the car unless it runs off
    the roof!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the vehicle by Bluetooth
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Had some fun trying those combinations? Now is the time that we take this journey
    a step ahead and see what else is possible. We have all played with remote-controlled
    cars and I'm sure everyone will have had fun with those zippy little toys. We
    are going to do something similar but in a much more sophisticated way.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'We all are aware of Bluetooth: this is one of the best ways to communicate
    with devices in close proximity. Bluetooth communication is a medium data rate,
    low power communication method. This is almost omnipresent in mobile devices,
    hence it is an ideal way to start. What we will be doing in this chapter is controlling
    the car via your mobile phone using Bluetooth. Now let''s see how we can do it.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we want to do is pair up the smartphone to the robotic vehicle,
    and to do so we need to open the terminal on Raspberry Pi and perform the following
    steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Type in the command `~ $ bluetoothctl`; this is a Bluetooth agent which allows
    two Bluetooth devices to communicate. Without the Bluetooth agent, the two devices
    will not be able to communicate with each other in the first place.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `[Bluetooth] # power on` command simply powers up the Bluetooth on board
    the Raspberry.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `[Bluetooth] # agent on` command starts up the agent which can then initiate
    the connection for us.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `[Bluetooth] # discoverable on` command makes Raspberry Pi''s Bluetooth
    discoverable. The Bluetooth might be on, but we must make it discoverable to make
    sure that the other device can find it and connect to it.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `[Bluetooth] # pairable on` command makes the device pairable. If the Bluetooth
    is on, this doesn''t mean your device will be able to connect, hence we need to
    make it pairable and this command does exactly that.'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `[Bluetooth] # scan on` command starts scanning for nearby Bluetooth devices.
    The output of this command will be a couple of MAC addresses along with the Bluetooth
    name. The MAC address is a physical address of the device; this is a unique address,
    hence it will never ever be the same for two devices.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `[Bluetooth] # pair 94:65:2D:94:9B:D3` command helps you to pair up with
    the device you want. You simply need to type the mentioned command with the MAC
    address.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Just to be clear, this what your screen should look like:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77974b41-0787-497d-8bbe-a2ef84b5e0a8.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: 'Once you have done this process, you should be able to connect Raspberry Pi
    to your mobile devices. Now that you are connected, it''s time to go ahead and
    write the code through which we will be able to control the Bluetooth car just
    using our mobile devices. So here is the code. Go ahead, have a look, then we
    will get to the explanation:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now let''s see what this code is actually doing:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will be using some generic functions of Bluetooth during this program, hence
    we are calling the library `bluetooth` so that we are able to call those methods:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, whenever we connect two Bluetooth devices, we have various methods of
    communication; the easiest among them is radio frequency communication, herein
    referred to as `RFCOMM`. Now, in this line, we are using the `BluetoothSocket`
    method of the `bluetooth` library to define what communication protocol we are
    using in our program, which by now you know is `RFCOMM`. We are further storing
    this data in a variable called `server_socket` so that we don''t have to repeat
    this step over and over again. Rather, whenever we need this data it will already
    be stored in the variable called `server_socket`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, Bluetooth has multiple ports; this is a very useful concept as through
    one single Bluetooth connection we can have various streams of data being transferred
    to various devices and programs. This avoids the clash of data and also makes
    sure that the data is securely communicated to exactly the right receiver. The
    program which we are using right now is extremely simple and we do not need multiple
    ports for data communication. Hence, we can use any of the `1` to `60` ports available
    to us for the communication. In this part of the program, you can write any port
    and your program will run just fine:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, whenever we are connecting two devices we need to make sure that they stay
    connected throughout the communication. Hence, here we are writing this command: `server_socket.bind`. What
    this will do is that it will make sure that your Bluetooth connection is maintained
    during the entire communication.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the first parameter inside the argument is empty. Here, we
    generally write the MAC address which it has to be bound with. However, as we
    have set this as empty it will automatically bind to the MAC address we are already
    paired with. The second argument we have is the port on which it has to be connected.
    As we know, the value of the `port` variable is set to be `1`. Hence, it will
    automatically connect to port number `1`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is a very interesting line. As we know, we might not be the only person
    trying to connect to the Bluetooth device of Raspberry, hence what should Raspberry
    do when it receives another connection request?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'In this line, we are defining just that: we are calling a method called `listen(1)`.
    In this function, we have defined the value of argument as `1`. What it means
    is that it will be connected to one device only. Any other device that tries to
    connect will not get through. If we change this argument to `2` then it will be
    connected to two devices, however it would stay in the queue and hence it is called
    **queue connection**:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that most of the things for the connection have been done, we also need
    to know if we are connected to the right address. What the method `server_socket.accept()`
    does is that it returns the socket number and the address it is serving to. Hence,
    we are storing it within two variables called `client_socket` and `address`. However,
    as we know, the socket will remain only as `1`, hence we will not be using it
    any further:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this line we are simply telling the user that the connection has been made
    successfully with the sue of the function `str(address)` we are printing the value
    of the address to which it is connected to. This way we can be double sure that
    the connection has been made to the right device.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this line, we are receiving the data from the client; also, we are defining
    how long that data will be. Hence, in the method `client_socket.recv(1024)` we
    have passed on a parameter in the argument as `1024` which basically denotes that
    the maximum length of the data packet will be `1024` bytes. Once the data is received,
    it is then passed on to the variable `data` for further use.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, the rest of the program is pretty simple. We simply need to compare
    the value received by the mobile device and make the car do whatever we want to
    do. Here, we have made the car go in all four directions, that is, forward, backward,
    right, and left. You may also add specific conditions as per your needs:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this line, we are closing the connection of the client socket so that the
    client can be disconnected and the data transfer can be terminated:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding line, we are closing the connection of the server socket so
    that the server connection can be disconnected.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter taught us to automate and control a car using Bluetooth interfacing
    via data grabbing and sharing. Next up, we will develop what we have learned so
    far to interface IR sensors for obstacle avoidance and patch planning.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 本章教导我们如何使用蓝牙接口通过数据抓取和共享来自动化和控制一辆汽车。接下来，我们将把迄今为止所学的内容应用于接口红外传感器以实现障碍物避让和路径规划。
