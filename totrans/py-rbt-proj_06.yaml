- en: Bluetooth-Controlled Robotic Car
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝牙遥控机器人车
- en: We have come a long way; now it's time to go ahead and make something even better.
    The world is going all gaga over the inception of autonomous cars and within this
    decade this will become the new normal. There is so much going on in these vehicles.
    Multiple sensors, GPS, and telemetry are all calculated in real time to make sure
    that the car is on the right course and is being driven by the system safely on
    the road, so making a robotic vehicle proves to be an ideal way to learn robotics
    and future technologies. In this book, we will always try to make technologies
    that are not only as good as the present technologies but in some ways even better.
    So, let's go ahead and get to making this autonomous vehicle one step at a time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经走了很长的路；现在是时候继续前进，制造出更好的东西了。全世界都在疯狂地追捧自动驾驶汽车的出现，在接下来的十年里，这将成为新常态。在这些车辆中发生了很多事情。多个传感器、GPS和遥测数据都在实时计算，以确保汽车在正确的航向上行驶，并且由系统安全地驾驶在道路上，因此制造机器人车辆证明是学习机器人技术和未来技术的理想方式。在这本书中，我们将始终努力制造出不仅与现有技术一样好，而且在某些方面甚至更好的技术。那么，让我们一步一步地开始制造这辆自动驾驶汽车吧。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Basics of the vehicle
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 车辆的基本知识
- en: Getting the vehicle ready
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备车辆
- en: Controlling the vehicle by Bluetooth
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过蓝牙控制车辆
- en: Basics of the vehicle
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 车辆的基本知识
- en: 'You must be thinking: what can we possibly learn about the vehicle that we
    don''t already know? This may be true, but there are a few that we must make sure
    we understand before taking on this chapter. So, let''s get started.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能正在想：我们还能从车辆中学到什么我们不知道的东西呢？这可能是对的，但在我们开始这一章之前，我们必须确保理解以下几点。那么，让我们开始吧。
- en: 'First is the chassis, which we will be using: it''s is a four-wheel drive chassis
    and all the four wheels are independently controlled by a dedicated motor. Hence,
    we can change the speed of every single wheels as per our needs. We have chosen
    a four-wheel drive drivetrain as it is harder for it to get stuck on carpets and
    uneven surfaces. You can also opt for a two-wheel drive drivetrain if you want
    to do so, as it won''t make a huge difference.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是底盘，我们将使用它：它是一个四轮驱动底盘，所有的四个轮子都由一个专门的电机独立控制。因此，我们可以根据我们的需求改变每个轮子的速度。我们选择四轮驱动传动系统，因为它在地毯和凹凸不平的表面上更容易卡住。如果你想这样做，你也可以选择两轮驱动传动系统，这不会造成太大的差异。
- en: Now, once you assemble the chassis you might see that it does not have a steering
    mechanism. Does this mean that the car will only go straight? Well, obviously
    not. There are many ways by which we can steer the direction of a car while making
    small vehicles. The best one is called differential turning.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦你组装了底盘，你可能会发现它没有转向机构。这意味着汽车只能直行吗？当然不是。有许多方法可以在制造小型车辆的同时控制汽车的方向。最好的方法是叫做差速转向。
- en: 'In conventional cars, there is one engine and that engine powers up the wheels;
    hence in principal all the wheels turn at the same speed. Now this works fine
    when we are going straight but whenever the car wants to turn there comes a new
    problem. Refer to the following diagram:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统汽车中，有一个发动机，这个发动机为车轮提供动力；因此，原则上所有车轮都以相同的速度转动。当我们直行时，这没问题，但每当汽车想要转弯时，就会出现一个新的问题。参考以下图表：
- en: '![](img/7d25825f-2504-45ec-802c-521a0d2ade0d.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7d25825f-2504-45ec-802c-521a0d2ade0d.png)'
- en: 'You will see that the wheels, which are on the inner curve, have a smaller
    diameter and the one on the outer edge has a larger diameter. You may remember
    a fact from elementary school: the larger the diameter the more the circumference,
    and vice a versa. Hence, the wheel towards the inner edge will be covering a shorter
    distance compared to the wheels on the outer edge at the same time, or in simple
    words, the inner wheels will be spinning slower and the outer wheels will be spinning
    faster.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到，位于内曲线上的轮子直径较小，而位于外缘的轮子直径较大。你可能记得小学的一个事实：直径越大，周长越大，反之亦然。因此，靠近内缘的轮子与外缘的轮子相比，将覆盖更短的距离，或者简单地说，内轮将旋转得更慢，而外轮将旋转得更快。
- en: This problem leads to the discovery of differentials in cars, which is a round
    lump at the center of the axle of the car. What this does is that it varies the
    rate at which the wheels are spinning based on the turning radius. Genius, isn't
    it? Now, you must be thinking: this is all right, but why are you telling me all
    this? Well, because we will do the exact opposite to turn the robot. If we change
    the speed of the motors on the inner and outer edge of the turning circle, then
    the car will try to turn towards inside and similarly if we do it for the other
    end then it will try to turn in the other direction. While making wheeled robot
    this strategy is not new at all. Steering mechanisms are complicated and implementing
    them on small robot is simply a challenge. Hence this is a far simpler and easy
    way to turn your vehicle around.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题导致了汽车中微分器的发现，它位于汽车车轴中心的圆形凸起。它的作用是根据转弯半径改变车轮的转速。天才，不是吗？现在，你可能正在想：这很好，但你为什么要告诉我这些呢？嗯，因为我们将做完全相反的事情来控制机器人。如果我们改变转向圆周内外的电机速度，那么汽车将试图向内转弯，同样地，如果我们对另一端做同样的操作，它将试图向相反方向转弯。在制作轮式机器人时，这种策略根本不是什么新东西。转向机制很复杂，在小型机器人上实现它们简直是一个挑战。因此，这是一种简单且容易的方法来使你的车辆转向。
- en: Not only is this way simple but it is a very efficient and simple strategy that
    requires minimal components. It is also better as the turning radius of the vehicle
    is also reduced. In fact, if we spin the opposite sides of the wheels in the opposite
    direction at the same speed then the vehicle will turn completely on its own axis,
    making the turning radius entirely zero. this type of configuration is called
    skid-steer drive. For a robot that is wheeled and works indoors, this is a killer
    feature.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不仅简单，而且非常高效，需要的组件最少。而且，由于车辆的转弯半径也减小了，所以它更好。实际上，如果我们以相同的速度旋转车轮的相对两侧以相反的方向，车辆将完全在其自身轴上转向，使转弯半径完全为零。这种配置被称为滑移转向驱动。对于在室内工作的轮式机器人，这是一个杀手级特性。
- en: To know more about it read more here: [https://groups.csail.mit.edu/drl/courses/cs54-2001s/skidsteer.html](https://groups.csail.mit.edu/drl/courses/cs54-2001s/skidsteer.html)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多信息，请在此处阅读：[https://groups.csail.mit.edu/drl/courses/cs54-2001s/skidsteer.html](https://groups.csail.mit.edu/drl/courses/cs54-2001s/skidsteer.html)
- en: Getting the vehicle ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备车辆
- en: Now is the time to go ahead and make the robotic vehicle a reality. So let's
    unbox the vehicle chassis and screw every part together. The assembly manual generally
    comes along with the kit, so it won't take long for you to complete it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将这个机器人车辆变为现实了。所以让我们打开车辆底盘，将每个部件组装在一起。组装手册通常与套件一起提供，所以你很快就能完成它。
- en: Once you have completed building the kit, go ahead and segregate the wires for
    each of the motors. This is going to be a very important part of making the vehicle
    ready. So, once you have all the wires coming out of the vehicle, take a cell
    and power up each of the wheels. Notice the polarity of connection in which the
    wheels spin in the forward direction. All you have to do is to take a permanent
    marker or perhaps a nail paint and mark the wire which goes to the positive terminal
    when the motor is spinning in the forward direction. As all of these motors are
    entirely dependent on polarity for the direction, this step is key to ensure that
    whenever we power them up they always spin in the same direction. Trust me, this
    will save you a lot of headaches.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了套件的组装，就继续为每个电机分离电线。这将制作车辆准备过程中的一个非常重要的部分。所以，一旦所有的电线都从车辆中出来，拿一个电池并为每个轮子供电。注意连接的正极性，其中车轮以正向旋转。你所要做的就是拿一支永久性记号笔或者可能是指甲油，标记当电机正向旋转时连接到正极的电线。由于所有这些电机完全依赖于极性来确定方向，这一步是确保我们每次供电时它们总是以相同方向旋转的关键。相信我，这将节省你很多麻烦。
- en: 'Now, once this is all done, connect the wires to the motor driver as shown
    in the following diagram (the wire marked by red is the wire that you marked earlier):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦所有这些都完成了，按照以下图示将电线连接到电机驱动器（红色标记的电线是你之前标记的电线）：
- en: '![](img/2025d7fc-c143-4eac-89f1-a0350ad36306.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2025d7fc-c143-4eac-89f1-a0350ad36306.png)'
- en: 'Perfect! Now everything seems sorted, except for the connection of the motor
    driver with the power source and Raspberry Pi. So let''s see how we are going
    to do it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在似乎一切都井然有序，除了电机驱动器与电源和Raspberry Pi的连接。那么让我们看看我们将如何做到这一点：
- en: '![](img/8e028196-14dc-4537-a944-af59b1443670.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8e028196-14dc-4537-a944-af59b1443670.png)'
- en: 'All right then! Time for the real deal! So the first thing we want to make
    sure is that all the connections are working exactly the way we planned them to.
    For this, we will start off with a dummy code which will simply switch all the
    motors on and in forward direction. So here is the code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，那么现在是时候处理真正的任务了！我们首先想要确保所有连接都按照我们计划的方式正常工作。为此，我们将从一个虚拟代码开始，这个代码将简单地切换所有电机以正向运行。所以，以下是代码：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The program can't be more simple than this; all we are doing here is giving
    the motor driver the command to spin the motor in one single direction. There
    might be a chance that a set of motors will be rotating in the reverse direction,
    in which case you should change the polarity of connections on the motor driver.
    This should solve the problem. Some people might think that we can make a change
    to the code as well to do this, but as per my experience it starts getting complicated
    from there and would cause you trouble if you chose the other path.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 程序不可能比这更简单了；我们在这里所做的只是给电机驱动器发送一个命令，让电机单向旋转。可能会有这样的情况，一组电机将反向旋转，在这种情况下，您应该在电机驱动器上改变连接的极性。这应该会解决问题。有些人可能会认为我们可以修改代码来实现这一点，但根据我的经验，从那里开始事情会变得复杂，如果您选择了另一条路径，这可能会给您带来麻烦。
- en: All right then, everything is set and all is working well. Go ahead, try some
    other output permutations and combinations and see what happens to the car. Don't
    worry, whatever you do, you won't be able to damage the car unless it runs off
    the roof!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，一切都已经设置好了，并且一切运行正常。继续尝试其他输出排列和组合，看看汽车会发生什么。不用担心，无论您做什么，除非汽车从屋顶上掉下来，否则您不会损坏汽车！
- en: Controlling the vehicle by Bluetooth
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过蓝牙控制车辆
- en: Had some fun trying those combinations? Now is the time that we take this journey
    a step ahead and see what else is possible. We have all played with remote-controlled
    cars and I'm sure everyone will have had fun with those zippy little toys. We
    are going to do something similar but in a much more sophisticated way.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试那些组合很有趣吗？现在是我们将这次旅程再向前迈进一步，看看还有什么是可能的。我们都玩过遥控车，我相信每个人都会喜欢那些快速的小玩具。我们将做类似的事情，但方式要复杂得多。
- en: 'We all are aware of Bluetooth: this is one of the best ways to communicate
    with devices in close proximity. Bluetooth communication is a medium data rate,
    low power communication method. This is almost omnipresent in mobile devices,
    hence it is an ideal way to start. What we will be doing in this chapter is controlling
    the car via your mobile phone using Bluetooth. Now let''s see how we can do it.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道蓝牙：这是与近距离设备通信的最佳方式之一。蓝牙通信是一种中速、低功耗的通信方法。它在移动设备中几乎无处不在，因此它是一个理想的起点。在本章中，我们将通过蓝牙使用您的手机来控制汽车。现在让我们看看我们如何做到这一点。
- en: 'The first thing we want to do is pair up the smartphone to the robotic vehicle,
    and to do so we need to open the terminal on Raspberry Pi and perform the following
    steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想要做的是将智能手机与机器人车辆配对，为此我们需要打开树莓派的终端并执行以下步骤：
- en: Type in the command `~ $ bluetoothctl`; this is a Bluetooth agent which allows
    two Bluetooth devices to communicate. Without the Bluetooth agent, the two devices
    will not be able to communicate with each other in the first place.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入命令 `~ $ bluetoothctl`；这是一个蓝牙代理，它允许两个蓝牙设备进行通信。如果没有蓝牙代理，这两个设备将无法相互通信。
- en: 'The `[Bluetooth] # power on` command simply powers up the Bluetooth on board
    the Raspberry.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[蓝牙] # power on` 命令简单地启动了树莓派上的蓝牙。'
- en: 'The `[Bluetooth] # agent on` command starts up the agent which can then initiate
    the connection for us.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[蓝牙] # agent on` 命令启动代理，然后它可以为我们发起连接。'
- en: 'The `[Bluetooth] # discoverable on` command makes Raspberry Pi''s Bluetooth
    discoverable. The Bluetooth might be on, but we must make it discoverable to make
    sure that the other device can find it and connect to it.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[蓝牙] # discoverable on` 命令使树莓派的蓝牙可被发现。蓝牙可能已经开启，但我们必须将其设置为可被发现，以确保其他设备能够找到它并与之连接。'
- en: 'The `[Bluetooth] # pairable on` command makes the device pairable. If the Bluetooth
    is on, this doesn''t mean your device will be able to connect, hence we need to
    make it pairable and this command does exactly that.'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[蓝牙] # pairable on` 命令使设备可配对。如果蓝牙已开启，这并不意味着您的设备能够连接，因此我们需要将其设置为可配对，而这个命令正是这样做的。'
- en: 'The `[Bluetooth] # scan on` command starts scanning for nearby Bluetooth devices.
    The output of this command will be a couple of MAC addresses along with the Bluetooth
    name. The MAC address is a physical address of the device; this is a unique address,
    hence it will never ever be the same for two devices.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[蓝牙] # scan on` 这个命令开始扫描附近的蓝牙设备。这个命令的输出将是一对MAC地址和蓝牙名称。MAC地址是设备的物理地址；这是一个唯一的地址，因此它永远不会为两个设备相同。'
- en: 'The `[Bluetooth] # pair 94:65:2D:94:9B:D3` command helps you to pair up with
    the device you want. You simply need to type the mentioned command with the MAC
    address.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[蓝牙] # pair 94:65:2D:94:9B:D3` 这个命令帮助你与想要连接的设备配对。你只需要输入提到的命令和MAC地址即可。'
- en: 'Just to be clear, this what your screen should look like:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚，这是你的屏幕应该看起来像的样子：
- en: '![](img/77974b41-0787-497d-8bbe-a2ef84b5e0a8.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/77974b41-0787-497d-8bbe-a2ef84b5e0a8.png)'
- en: 'Once you have done this process, you should be able to connect Raspberry Pi
    to your mobile devices. Now that you are connected, it''s time to go ahead and
    write the code through which we will be able to control the Bluetooth car just
    using our mobile devices. So here is the code. Go ahead, have a look, then we
    will get to the explanation:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这个过程，你应该能够将树莓派连接到你的移动设备上。现在你已经连接上了，是时候继续编写代码了，通过这段代码我们可以仅使用我们的移动设备来控制蓝牙汽车。所以，这就是代码。继续看，然后我们将进行解释：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now let''s see what this code is actually doing:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看这段代码实际上在做什么：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will be using some generic functions of Bluetooth during this program, hence
    we are calling the library `bluetooth` so that we are able to call those methods:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们将使用一些蓝牙的通用功能，因此我们调用库`bluetooth`，这样我们就能调用那些方法：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, whenever we connect two Bluetooth devices, we have various methods of
    communication; the easiest among them is radio frequency communication, herein
    referred to as `RFCOMM`. Now, in this line, we are using the `BluetoothSocket`
    method of the `bluetooth` library to define what communication protocol we are
    using in our program, which by now you know is `RFCOMM`. We are further storing
    this data in a variable called `server_socket` so that we don''t have to repeat
    this step over and over again. Rather, whenever we need this data it will already
    be stored in the variable called `server_socket`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次我们连接两个蓝牙设备时，我们都有多种通信方式；其中最简单的是射频通信，在这里被称为`RFCOMM`。现在，在这一行中，我们使用`bluetooth`库的`BluetoothSocket`方法来定义我们在程序中使用的通信协议，到现在你应该知道是`RFCOMM`。我们进一步将这个数据存储在一个名为`server_socket`的变量中，这样我们就不需要反复重复这个步骤。相反，每次我们需要这些数据时，它已经存储在名为`server_socket`的变量中：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, Bluetooth has multiple ports; this is a very useful concept as through
    one single Bluetooth connection we can have various streams of data being transferred
    to various devices and programs. This avoids the clash of data and also makes
    sure that the data is securely communicated to exactly the right receiver. The
    program which we are using right now is extremely simple and we do not need multiple
    ports for data communication. Hence, we can use any of the `1` to `60` ports available
    to us for the communication. In this part of the program, you can write any port
    and your program will run just fine:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，蓝牙有多个端口；这是一个非常有用的概念，因为通过一个单一的蓝牙连接，我们可以将各种数据流传输到不同的设备和程序。这避免了数据冲突，并确保数据被安全地传达给确切的接收者。我们现在使用的程序非常简单，我们不需要多个端口进行数据通信。因此，我们可以使用从`1`到`60`的任何端口进行通信。在这个程序的部分，你可以写入任何端口，你的程序将正常运行：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, whenever we are connecting two devices we need to make sure that they stay
    connected throughout the communication. Hence, here we are writing this command: `server_socket.bind`. What
    this will do is that it will make sure that your Bluetooth connection is maintained
    during the entire communication.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次我们连接两个设备时，我们需要确保它们在整个通信过程中保持连接。因此，我们在这里编写这个命令：`server_socket.bind`。这个命令将会确保你的蓝牙连接在整个通信过程中保持。
- en: 'As you can see, the first parameter inside the argument is empty. Here, we
    generally write the MAC address which it has to be bound with. However, as we
    have set this as empty it will automatically bind to the MAC address we are already
    paired with. The second argument we have is the port on which it has to be connected.
    As we know, the value of the `port` variable is set to be `1`. Hence, it will
    automatically connect to port number `1`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，参数内的第一个参数是空的。在这里，我们通常写入需要绑定的MAC地址。然而，由于我们将其设置为空，它将自动绑定到我们已配对的MAC地址。我们拥有的第二个参数是它需要连接的端口。正如我们所知，`port`变量的值被设置为`1`。因此，它将自动连接到端口号`1`：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is a very interesting line. As we know, we might not be the only person
    trying to connect to the Bluetooth device of Raspberry, hence what should Raspberry
    do when it receives another connection request?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一行非常有趣的代码。正如我们所知，我们可能不是唯一一个试图连接到树莓派蓝牙设备的人，那么当树莓派收到另一个连接请求时，它应该怎么做呢？
- en: 'In this line, we are defining just that: we are calling a method called `listen(1)`.
    In this function, we have defined the value of argument as `1`. What it means
    is that it will be connected to one device only. Any other device that tries to
    connect will not get through. If we change this argument to `2` then it will be
    connected to two devices, however it would stay in the queue and hence it is called
    **queue connection**:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行，我们只是定义了这一点：我们调用一个名为`listen(1)`的方法。在这个函数中，我们将参数的值定义为`1`。这意味着它将只连接到一个设备。任何其他试图连接的设备都不会通过。如果我们把这个参数改为`2`，那么它将连接到两个设备，但是它将保持在队列中，因此它被称为**队列连接**：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that most of the things for the connection have been done, we also need
    to know if we are connected to the right address. What the method `server_socket.accept()`
    does is that it returns the socket number and the address it is serving to. Hence,
    we are storing it within two variables called `client_socket` and `address`. However,
    as we know, the socket will remain only as `1`, hence we will not be using it
    any further:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在大多数连接的事情都已经完成，我们还需要知道我们是否连接到了正确的地址。`server_socket.accept()`方法所做的是返回套接字编号和它所服务的地址。因此，我们将它存储在两个名为`client_socket`和`address`的变量中。然而，正如我们所知，套接字将仅保持为`1`，因此我们不会进一步使用它：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this line we are simply telling the user that the connection has been made
    successfully with the sue of the function `str(address)` we are printing the value
    of the address to which it is connected to. This way we can be double sure that
    the connection has been made to the right device.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行，我们只是告诉用户连接已经成功建立，我们使用`str(address)`函数打印出连接到的地址的值。这样我们就可以确保连接已经建立到了正确的设备。
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this line, we are receiving the data from the client; also, we are defining
    how long that data will be. Hence, in the method `client_socket.recv(1024)` we
    have passed on a parameter in the argument as `1024` which basically denotes that
    the maximum length of the data packet will be `1024` bytes. Once the data is received,
    it is then passed on to the variable `data` for further use.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行，我们正在从客户端接收数据；同时，我们也在定义这些数据将保持多长时间。因此，在`client_socket.recv(1024)`方法中，我们将参数作为`1024`传递，这基本上表示数据包的最大长度将是`1024`字节。一旦数据被接收，它就会被传递到变量`data`以供进一步使用。
- en: 'After this, the rest of the program is pretty simple. We simply need to compare
    the value received by the mobile device and make the car do whatever we want to
    do. Here, we have made the car go in all four directions, that is, forward, backward,
    right, and left. You may also add specific conditions as per your needs:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，程序的其余部分相当简单。我们只需要比较从移动设备接收到的值，让汽车执行我们想要的任何操作。在这里，我们让汽车向四个方向移动，即向前、向后、向右和向左。您也可以根据您的需求添加特定的条件：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this line, we are closing the connection of the client socket so that the
    client can be disconnected and the data transfer can be terminated:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行，我们正在关闭客户端套接字的连接，以便客户端可以被断开，数据传输可以被终止：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding line, we are closing the connection of the server socket so
    that the server connection can be disconnected.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行，我们正在关闭服务器套接字的连接，以便服务器连接可以被断开。
- en: Summary
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter taught us to automate and control a car using Bluetooth interfacing
    via data grabbing and sharing. Next up, we will develop what we have learned so
    far to interface IR sensors for obstacle avoidance and patch planning.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 本章教导我们如何使用蓝牙接口通过数据抓取和共享来自动化和控制一辆汽车。接下来，我们将把迄今为止所学的内容应用于接口红外传感器以实现障碍物避让和路径规划。
