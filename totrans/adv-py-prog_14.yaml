- en: '*Chapter 12*: Deadlocks'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：死锁'
- en: '**Deadlocks**, one of the most common concurrency problems, will be the first
    problem that we will analyze in this book. In this chapter, we will discuss the
    theoretical causes of deadlocks in concurrent programming. We will cover a classical
    synchronization problem in concurrency, called the **dining philosophers problem**,
    as a real-life example of a deadlock. We will also illustrate an actual implementation
    of a deadlock in Python and discuss several methods to address this problem. This
    chapter will also cover the concept of livelocks, which are relevant to deadlocks
    and are also a common problem in concurrent programming.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**死锁**，最常见的一种并发问题，将是我们在本书中首先分析的问题。在本章中，我们将讨论并发编程中死锁的理论原因。我们将以一个经典的同步问题，称为**就餐哲学家问题**，作为一个死锁的现实生活例子。我们还将展示一个实际的Python死锁实现，并讨论解决此问题的几种方法。本章还将涵盖与死锁相关且在并发编程中也是常见问题的活锁概念。'
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The concept of deadlocks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 死锁的概念
- en: Approaches to deadlock situations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理死锁情况的方法
- en: The concept of livelocks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活锁的概念
- en: By the end of this chapter, we will have gained a deep understanding of the
    problem, its place in concurrent programming, and the practical approaches to
    solving it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将对问题、它在并发编程中的位置以及解决它的实际方法有一个深入的理解。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be accessed through this link: [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter12).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以通过以下链接访问：[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter12).
- en: The concept of deadlocks
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 死锁的概念
- en: In concurrent programming, a deadlock refers to a specific situation in which
    no progress can be made, and the program becomes locked in its current state.
    In most cases, this phenomenon is caused by a lack of, or mishandled, coordination
    between different lock objects (for thread synchronization purposes). In this
    section, we will discuss a thought experiment, commonly known as the dining philosophers
    problem, to illustrate the concept of a deadlock and its causes; from there, you
    will learn how to simulate the problem in a Python concurrent program.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发编程中，死锁指的是一种无法取得进展的特定情况，程序锁定在其当前状态。在大多数情况下，这种现象是由不同锁对象之间缺乏或处理不当的协调（用于线程同步目的）引起的。在本节中，我们将讨论一个常见的思想实验，通常称为就餐哲学家问题，以说明死锁的概念及其原因；从那里，你将学习如何在Python并发程序中模拟这个问题。
- en: The dining philosophers problem
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 就餐哲学家问题
- en: The dining philosophers problem was first introduced by Edgar Dijkstra, a leading
    pioneer in concurrent programming, in 1965\. This problem was first demonstrated
    using different technical terms (resource contention in computer systems) and
    was later rephrased by Tony Hoare, a British computer scientist and the inventor
    of the quicksort sorting algorithm. The problem statement is as follows.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 就餐哲学家问题最初由并发编程的先驱埃德加·迪杰斯特拉（Edgar Dijkstra）在1965年提出。这个问题最初使用不同的技术术语（计算机系统中的资源竞争）进行演示，后来由英国计算机科学家、快速排序算法的发明者托尼·霍尔（Tony
    Hoare）重新表述。问题陈述如下。
- en: 'Five philosophers sit around a table, and each has a bowl of food in front
    of them. Placed between these five bowls of food are five forks, so each philosopher
    has one fork to their left and one fork to their right. This setup is shown in
    the following diagram:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 五位哲学家围坐在一张桌子旁，每位哲学家面前都有一碗食物。五把叉子放在这五碗食物之间，所以每位哲学家左边和右边各有一把叉子。这种设置在以下图中显示：
- en: '![Figure 12.1 – An illustration of the dining philosophers problem ](img/Figure_12.1_B17499.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 就餐哲学家问题的说明](img/Figure_12.1_B17499.jpg)'
- en: Figure 12.1 – An illustration of the dining philosophers problem
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 就餐哲学家问题的说明
- en: Each silent philosopher is to alternate between thinking and eating. Each is
    required to have both of the forks around them to be able to pick up the food
    from their bowl, and no fork can be shared between two or more different philosophers.
    When a philosopher finishes eating a specific amount of food, they are to place
    both of the forks back in their respective, original locations. At this point,
    the philosophers around that philosopher will be able to use those forks.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每位沉默的哲学家应该交替进行思考和进食。每个哲学家都需要周围有两把叉子才能从他们的碗里取食物，而且叉子不能在两个或更多不同的哲学家之间共享。当哲学家吃掉一定数量的食物后，他们应该将两把叉子放回各自原来的位置。此时，那位哲学家周围的哲学家将能够使用那些叉子。
- en: Since the philosophers are silent and cannot communicate with each other, they
    have no way to let each other know they need the forks to eat. In other words,
    the only way for a philosopher to eat is to have both of the forks already available
    to them. For this problem, a set of instructions must be designed for the philosophers
    to efficiently switch between eating and thinking so that each philosopher is
    provided with enough food.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于哲学家们是沉默的，无法相互沟通，他们没有方法让对方知道他们需要叉子来吃。换句话说，哲学家唯一能吃的方法是两把叉子都已经可用。对于这个问题，必须为哲学家设计一套指令，以便他们能够高效地在吃和思考之间切换，从而确保每位哲学家都能获得足够的食物。
- en: 'Now, a potential approach to this problem would be the following set of instructions:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在解决这个问题的潜在方法可能是一系列指令如下：
- en: A philosopher must think until the fork on their left becomes available. When
    that happens, the philosopher is to pick it up.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哲学家必须思考，直到他们左手边的叉子变得可用。当这种情况发生时，哲学家应该拿起它。
- en: A philosopher must think until the fork on their right becomes available. When
    that happens, the philosopher is to pick it up.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哲学家必须思考，直到他们右手边的叉子变得可用。当这种情况发生时，哲学家应该拿起它。
- en: 'If a philosopher is holding two forks, they will eat a specific amount of food
    from the bowl in front of them, and then the following will apply:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果哲学家手持两把叉子，他们将从前面的碗里吃掉一定数量的食物，然后以下规则适用：
- en: Afterward, the philosopher has to put the right fork down in its original place.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，哲学家必须将右手叉子放回原来的位置。
- en: Afterward, the philosopher has to put the left fork down in its original place.
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，哲学家必须将左手叉子放回原来的位置。
- en: The process repeats from the first step.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个过程从第一步重复进行。
- en: It is clear to see how this set of instructions can lead to a situation where
    no progress can be made; namely, if, in the beginning, all of the philosophers
    start to execute their instructions at the same time. Since all of the forks are
    on the table at the beginning and are therefore available to be picked up by nearby
    philosophers, each philosopher will be able to execute the first instruction (picking
    up the fork on their left).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这套指令可能导致无法取得进展的情况；也就是说，如果一开始所有哲学家同时开始执行他们的指令。由于一开始所有的叉子都在桌子上，因此附近的哲学家都可以拿起叉子，每个哲学家都将能够执行第一个指令（拿起他们左手边的叉子）。
- en: Now, after this step, each philosopher will be holding a fork with their left
    hand, and no forks will be left on the table. Since no philosopher has both forks
    in their hands, they cannot eat their food. Furthermore, the set of instructions
    that they were given specifies that only after a philosopher has eaten a specific
    amount of food can they put their forks down on the table. This means that so
    long as a philosopher has not eaten, they will not release the fork that they
    are holding.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，经过这一步，每位哲学家都将用左手拿着一把叉子，桌子上将不再剩下任何叉子。由于没有哲学家同时拥有两把叉子，他们无法吃他们的食物。此外，他们所得到的指令规定，只有当哲学家吃掉一定数量的食物后，他们才能将叉子放在桌子上。这意味着只要哲学家没有吃，他们就不会放下他们所持有的叉子。
- en: So, as each philosopher is holding only one fork with their left hand, this
    means they cannot eat or put down the fork they are holding. The only time a philosopher
    gets to eat their food is when their neighboring philosopher puts their fork down,
    which is only possible if they can eat their food; this creates a never-ending
    circle of conditions that can never be satisfied. This situation is, in essence,
    the nature of a deadlock, in which all of the elements of a system are stuck in
    place, and no progress can be made.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于每个哲学家只用左手拿着一个叉子，这意味着他们不能吃或放下他们手中的叉子。哲学家唯一能吃到食物的时间是当他们的邻居放下叉子时，而这只有在他们能吃到食物的情况下才可能；这创造了一个永远无法满足的条件的循环。这种情况本质上就是死锁的本质，其中系统的所有元素都停滞不前，无法取得任何进展。
- en: It is not difficult to imagine real-world situations that involve shared resources
    and are modeled by this dining philosophers problem. For example, the original
    problems that inspired Dijkstra to construct this formulation involved working
    with external devices such as tape drives.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 想象现实世界中涉及共享资源并由用餐哲学家问题模型化的情况并不困难。例如，激发迪杰斯特拉构建这个公式的原始问题涉及与外部设备（如磁带驱动器）一起工作。
- en: 'Another example is in terms of banks: to execute transactions between two bank
    accounts, you must ensure that both accounts are locked from other transactions
    for the correct amount of money to be transferred. Here, the analogy does not
    exactly hold – a philosopher corresponds to a transaction that locks accounts
    (the forks) – but the same technical difficulties could arise. Other examples
    include making online reservations and allowing a database to be modified by multiple
    clients at the same time.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是关于银行的：要执行两个银行账户之间的交易，你必须确保两个账户都被锁定，以便正确数量的资金能够被转移。在这里，这种类比并不完全成立——哲学家对应于锁定账户的交易（即叉子）——但可能会出现相同的技术难题。其他例子包括在线预订和允许多个客户端同时修改数据库。
- en: With that said, we will be exclusively focusing on the formal dining philosophers
    problem as it provides a clean, abstract setting that could easily be analyzed
    and taken apart. With that in mind, let's consider the formal concept of a deadlock
    and the relevant theories around it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们将专门关注正式的用餐哲学家问题，因为它提供了一个干净、抽象的环境，可以轻松进行分析和分解。考虑到这一点，让我们考虑死锁的正式概念及其相关的理论。
- en: A deadlock in a concurrent system
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发系统中的死锁
- en: Given a concurrent program with multiple threads or processes, the execution
    flow enters a deadlock if a process (or thread) is waiting on a resource that
    is being held and utilized by another process, which is, in turn, waiting for
    another resource that is held by a different process. In other words, processes
    cannot proceed with their execution instructions while waiting for resources that
    can only be released after the execution is completed; therefore, these processes
    are unable to change their execution states.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个具有多个线程或进程的并发程序，如果进程（或线程）正在等待一个被另一个进程持有和使用的资源，而这个进程反过来又正在等待另一个由不同进程持有的资源，那么执行流程就会进入死锁状态。换句话说，进程在等待只能在其执行完成后才能释放的资源时，无法继续执行其执行指令；因此，这些进程无法改变它们的执行状态。
- en: 'A deadlock is also defined by the conditions that a concurrent program needs
    to have at the same time for a deadlock to occur. These conditions were first
    proposed by the computer scientist Edward G. Coffman, Jr., and are therefore known
    as the **Coffman conditions**. These conditions are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁也被定义为并发程序在发生死锁时需要同时具备的条件。这些条件最初是由计算机科学家爱德华·G·科夫曼（Jr.）提出的，因此被称为**科夫曼条件**。这些条件如下：
- en: At least one resource has to be in a non-shareable state. This means that that
    resource is being held by an individual process (or thread) and cannot be accessed
    by others; the resource can only be accessed and held by a single process (or
    thread) at any given time. This condition is also known as **mutual exclusion**.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少有一个资源必须处于不可共享的状态。这意味着该资源被某个进程（或线程）持有，其他人无法访问；该资源只能由单个进程（或线程）在任何给定时间访问和持有。这种条件也称为**互斥**。
- en: One process (or thread) exists that is simultaneously accessing a resource and
    waiting for another held by other processes (or threads). In other words, this
    process (or thread) needs access to two resources to execute its instructions,
    one of which it is already holding, the other of which it is waiting for from
    other processes (or threads). This condition is called **hold and wait**.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一个进程（或线程），它同时访问一个资源并等待其他进程（或线程）持有的另一个资源。换句话说，这个进程（或线程）需要访问两个资源来执行其指令，其中一个它已经持有，另一个它正在等待其他进程（或线程）提供。这种条件称为**持有并等待**。
- en: Resources can only be released by a process (or a thread) holding them if there
    are specific instructions for the process (or thread) to do so. This is to say
    that unless the process (or thread) voluntarily and actively releases the resource,
    that resource remains in a non-shareable state. This is the **no preemption condition**.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当有特定的指令要求进程（或线程）释放它们所持有的资源时，进程（或线程）才能释放资源。也就是说，除非进程（或线程）自愿并主动释放资源，否则该资源将保持不可共享的状态。这就是**不可抢占条件**。
- en: The final condition is called **circular wait**. As its name suggests, this
    condition specifies that a set of processes (or threads) exist so that the first
    process (or thread) in the set is waiting for a resource to be released by the
    second process (or thread), which, in turn, needs to be waiting for the third
    process (or thread); finally, the last process (or thread) in the set is waiting
    for the first one.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的条件称为**循环等待**。正如其名所示，这个条件指定了一组进程（或线程）存在，其中集合中的第一个进程（或线程）正在等待第二个进程（或线程）释放一个资源，而第二个进程（或线程）反过来又需要等待第三个进程（或线程）；最后，集合中的最后一个进程（或线程）正在等待第一个进程（或线程）。
- en: 'Let''s quickly take a look at a basic example of a deadlock. Consider a concurrent
    program in which there are two different processes (process **A** and process
    **B**) and two different resources (resource **R1** and resource **R2**), as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下死锁的基本示例。考虑一个并发程序，其中有两个不同的进程（进程**A**和进程**B**）和两种不同的资源（资源**R1**和资源**R2**），如下所示：
- en: '![Figure 12.2 – Sample deadlock diagram ](img/Figure_12.2_B17499.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – 示例死锁图](img/Figure_12.2_B17499.jpg)'
- en: Figure 12.2 – Sample deadlock diagram
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 示例死锁图
- en: Neither of the resources can be shared across separate processes, and each process
    needs to access both resources to execute its instructions. Take process **A**,
    for example. It is already holding resource **R1**, but it also needs **R2** to
    proceed with its execution. However, **R2** cannot be acquired by process **A**,
    as it is being held by process **B**. So, process **A** cannot proceed. The same
    goes for process **B**, which is holding **R2** and needs **R1** to proceed. **R1**
    is, in turn, held by process **A**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何资源可以在不同的进程之间共享，每个进程都需要访问这两个资源来执行其指令。以进程**A**为例。它已经持有资源**R1**，但它还需要**R2**来继续执行。然而，**R2**不能被进程**A**获取，因为它被进程**B**持有。所以，进程**A**不能继续执行。对进程**B**也是如此，它持有**R2**并需要**R1**来继续执行。而**R1**反过来又被进程**A**持有。
- en: Python simulation
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python模拟
- en: In this section, we will implement the preceding situation in an actual Python
    program. Specifically, we will have two locks (we will call them **lock A** and
    **lock B**) and two separate threads interacting with the locks (**thread A**
    and **thread B**). In our program, we will set up a situation in which thread
    A has acquired lock A and is waiting to acquire lock B, which has already been
    acquired by thread B, which is, in turn, waiting for lock A to be released.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现前面的情况在一个实际的Python程序中。具体来说，我们将有两个锁（我们将它们称为**锁A**和**锁B**）和两个单独的线程与锁交互（**线程A**和**线程B**）。在我们的程序中，我们将设置一个线程A已经获取锁A并正在等待获取已经被线程B获取的锁B的情况，而线程B反过来又正在等待锁A被释放。
- en: 'If you have already downloaded the code for this book from the relevant GitHub
    page, then go ahead and navigate to the `Chapter12` folder. Let''s consider the
    `Chapter12/example1.py` file, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经从相关的GitHub页面下载了这本书的代码，那么请转到`Chapter12`文件夹。让我们考虑`Chapter12/example1.py`文件，如下所示：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this script, the `thread_a()` and `thread_b()` functions specify thread
    A and thread B, respectively. In our main program, we also have two `threading.Lock`
    objects: lock A and lock B. The general structure of the thread instructions is
    as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，`thread_a()`和`thread_b()`函数分别指定线程A和线程B。在我们的主程序中，我们还有两个`threading.Lock`对象：锁A和锁B。线程指令的一般结构如下：
- en: Start the thread.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动线程。
- en: Try to acquire the lock with the same name as the thread (thread A will try
    to acquire lock A, while thread B will try to acquire lock B).
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用与线程相同名称的锁（线程A将尝试获取锁A，而线程B将尝试获取锁B）。
- en: Perform some calculations.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一些计算。
- en: Try to acquire the other lock (thread A will try to acquire lock B, while thread
    B will try to acquire lock A).
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试获取另一个锁（线程A将尝试获取锁B，而线程B将尝试获取锁A）。
- en: Perform some other calculations.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一些其他计算。
- en: Release both locks.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放两个锁。
- en: End the thread.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结束线程。
- en: Note
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we are using the `time.sleep()` function to simulate the action of
    some calculations being processed.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们正在使用`time.sleep()`函数来模拟一些计算正在处理的行为。
- en: First of all, we are starting both threads A and B almost simultaneously, within
    the main program. With the structure of the thread instruction set in mind, we
    can see that at this point, both threads will be initiated; thread A will try
    to acquire lock A and will succeed in doing so since lock A is still available
    at this point. The same goes for thread B and lock B. The two threads will then
    go on to perform some calculations on their own.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在主程序中几乎同时启动了线程A和线程B。考虑到线程指令集的结构，我们可以看到，在这个点上，两个线程都将被启动；线程A将尝试获取锁A，并且由于此时锁A仍然可用，所以会成功获取。对于线程B和锁B也是如此。然后，这两个线程将继续进行一些自己的计算。
- en: 'Let''s consider the current state of our program: lock A has been acquired
    by thread A, and lock B has been acquired by thread B. After their respective
    calculation processes are complete, thread A will then try to acquire lock B,
    and thread B will try to acquire lock A. We can easily see that this is the beginning
    of our deadlock situation: since lock B is already being held by thread B and
    cannot be acquired by thread A, thread B, for the same reason, cannot acquire
    lock A.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑我们程序当前的状态：锁A已被线程A获取，锁B已被线程B获取。在他们各自的计算过程完成后，线程A将尝试获取锁B，而线程B将尝试获取锁A。我们可以很容易地看出，这是我们死锁情况的开端：由于锁B已经被线程B持有，无法被线程A获取，因此，出于同样的原因，线程B也无法获取锁A。
- en: Both of the threads will now wait infinitely to acquire their respective second
    lock. However, the only way a lock can be released is for a thread to continue
    its execution instructions and release all of the locks it has at the end. So,
    our program will be stuck in its execution at this point, and no further progress
    will be made.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个线程现在将无限期地等待以获取它们各自的第二个锁。然而，释放锁的唯一方式是线程继续执行其执行指令并在结束时释放所有持有的锁。因此，我们的程序将在这一点上陷入执行，并且不会取得任何进一步的进展。
- en: 'The following diagram further illustrates the process of how the deadlock unfolds,
    in sequence:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图进一步说明了死锁展开的过程，按顺序展示：
- en: '![Figure 12.3 – Deadlock sequence diagram ](img/Figure_12.3_B17499.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – 死锁序列图](img/Figure_12.3_B17499.jpg)'
- en: Figure 12.3 – Deadlock sequence diagram
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 死锁序列图
- en: 'Now, let''s look at the deadlock that we have created in action. By running
    the script, you should obtain the following output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们创建的死锁在实际操作中的表现。通过运行脚本，你应该获得以下输出：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we discussed previously, since each thread is trying to acquire a lock that
    is currently held by the other thread, the only way for a lock to be released
    is for a thread to continue its execution. This is a deadlock, and your program
    will hang infinitely, never reaching the final `print` statement in the last line
    of the program.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，由于每个线程都在尝试获取另一个线程当前持有的锁，因此释放锁的唯一方式是线程继续执行。这是一个死锁，你的程序将无限期地挂起，永远不会到达程序最后一行最后的`print`语句。
- en: This behavior is undesirable in every way. In the next section, we will be discussing
    potential approaches to prevent deadlocks from occurring.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为在各方面都是不可取的。在下一节中，我们将讨论防止死锁发生的潜在方法。
- en: Approaches to deadlock situations
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 死锁情况的处理方法
- en: Intuitively, each of the following approaches looks to eliminate one of the
    four Coffman conditions from our program to prevent deadlocks. Our first solution
    is to implement ranking among the competing resources.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地看，以下每种方法似乎都试图从我们的程序中消除四个Coffman条件之一以防止死锁。我们的第一个解决方案是在竞争资源中实现排名。
- en: Implementing ranking among resources
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现资源之间的排名
- en: From both the dining philosophers problem and our Python example, we can see
    that the last condition of the four Coffman conditions, circular wait, is at the
    heart of the deadlock problem. It specifies that the different processes (or threads)
    in our concurrent program wait for resources held by other processes (or threads)
    circularly. By taking a closer look, we can see that the root cause for this condition
    is the order (or lack thereof) in which the processes (or threads) access the
    resources.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从 dining philosophers 问题以及我们的 Python 示例中，我们可以看到四个 Coffman 条件中的最后一个条件，即循环等待，是死锁问题的核心。它指定了我们的并发程序中的不同进程（或线程）循环等待其他进程（或线程）持有的资源。通过仔细观察，我们可以看到这一条件的根本原因是进程（或线程）访问资源时的顺序（或缺乏顺序）。
- en: In the dining philosophers problem, each philosopher is instructed to pick up
    the fork on their left first, while in our Python example, the threads always
    try to acquire the locks with the same name before performing any calculations.
    As you have seen, when the philosophers want to start eating at the same time,
    they will pick up their respective left forks and will be stuck in an infinite
    waiting loop. Similarly, when the two threads start their execution at the same
    time, they will acquire their locks and, again, wait for the other locks infinitely.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 dining philosophers 问题中，每个哲学家被指示首先拿起他们左边的叉子，而在我们的 Python 示例中，线程总是尝试在执行任何计算之前获取具有相同名称的锁。正如你所看到的，当哲学家们同时开始进餐时，他们会拿起各自的左叉子，并陷入无限等待循环。同样，当两个线程同时开始执行时，它们会获取它们的锁，再次无限等待其他锁。
- en: The conclusion that we can infer from this is that if, instead of accessing
    the resources arbitrarily, the processes (or threads) were to access them in a
    predetermined, static order, the circular nature of the way that they acquire
    and wait for the resources will be eliminated. So, for our two-lock Python example,
    instead of having thread A try to acquire lock A and thread B try to acquire lock
    B in their respective execution instructions, we will want both threads to try
    and acquire the locks in the same order. For example, both threads will now try
    to acquire lock A first, perform some calculations, try to acquire lock B, perform
    further calculations, and, finally, release both threads.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个结论中，我们可以推断出，如果进程（或线程）不是任意访问资源，而是按照预定的、静态的顺序访问资源，那么它们获取和等待资源的方式的循环性质将被消除。因此，对于我们的两个锁
    Python 示例，我们希望两个线程都尝试以相同的顺序获取锁。例如，现在两个线程都将首先尝试获取锁 A，执行一些计算，然后尝试获取锁 B，执行进一步的计算，最后释放两个线程。
- en: 'This change is implemented in the `Chapter12/example2.py` file, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种更改在 `Chapter12/example2.py` 文件中实现，如下所示：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This version of the script is now able to finish its execution and should produce
    the following output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个脚本的版本能够完成其执行，并应该产生以下输出：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This approach efficiently eliminates the deadlock problem in our two-lock example,
    but how well does it hold up for the dining philosophers problem? To answer this
    question, let''s try to simulate the problem and the solution in Python by ourselves.
    The `Chapter12/example3.py` file contains the implementation of the dining philosophers
    problem in Python, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有效地消除了我们两个锁示例中的死锁问题，但对于 dining philosophers 问题，它又能保持多好的效果呢？为了回答这个问题，让我们尝试自己用
    Python 模拟这个问题及其解决方案。`Chapter12/example3.py` 文件包含了 Python 中 dining philosophers
    问题的实现，如下所示：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we have the `philosopher()` function as the underlying logic for our separate
    threads. It takes in two `Threading.Lock` objects and simulates the previously
    discussed eating procedure, with two context managers. In our main program, we
    create a list of five lock objects, named `forks`, and a list of five threads,
    named `phils`, with the specification that the first thread will take in the first
    and second locks, the second thread will take in the second and third locks, and
    so on; and the fifth thread will take in the fifth and first locks (in order).
    Finally, we start all five threads simultaneously.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个 `philosopher()` 函数作为我们单独线程的底层逻辑。它接受两个 `Threading.Lock` 对象，并使用两个上下文管理器模拟之前讨论的进餐过程。在我们的主程序中，我们创建了一个包含五个锁对象的列表，命名为
    `forks`，以及一个包含五个线程的列表，命名为 `phils`，具体规定第一个线程将获取第一个和第二个锁，第二个线程将获取第二个和第三个锁，依此类推；第五个线程将获取第五个和第一个锁（按顺序）。最后，我们同时启动所有五个线程。
- en: 'If we run the script, we will see that deadlock occurs almost immediately.
    The following is my output, up until the program hangs infinitely:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行脚本，我们会看到死锁几乎立即发生。以下是我的输出，直到程序无限期挂起：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The question that naturally follows is: how can we implement an order in which
    the locks are acquired in the `philosopher()` function? We will be using the built-in
    `id()` function in Python here, which returns the unique, constant identity of
    the parameter, as the keys to sort the lock objects. We will also implement a
    custom context manager to factor out this sorting logic in a separate class. Navigate
    to `Chapter12/example4.py` for this specific implementation, which looks as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 自然随之而来的问题是：我们如何在`philosopher()`函数中实现一个获取锁的顺序？在这里，我们将使用Python的内置`id()`函数，它返回参数的唯一、恒定的标识符，作为排序锁对象的键。我们还将实现一个自定义上下文管理器，将排序逻辑提取到单独的类中。导航到`Chapter12/example4.py`以查看这个特定的实现，如下所示：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the main program remaining the same, this script will produce an output
    showing that this solution of ranking can effectively address the dining philosophers
    problem.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在保持主程序不变的情况下，这个脚本将生成一个输出，表明这种排序解决方案可以有效地解决哲学家就餐问题。
- en: However, there is a problem with this approach when it is applied to some particular
    cases. Keeping the high-level idea of concurrency in mind, we know that one of
    our main goals when applying concurrency to our programs is to improve the speed.
    Let's go back to our two-lock example and examine the execution time of our program
    with resource ranking implemented. Take a look at the `Chapter12/example5.py`
    file; it is simply the two-lock program with ranked (or ordered) locking implemented,
    combined with a timer that has been added to keep track of how much time it takes
    for the two threads to finish executing.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当这种方法应用于某些特定情况时，存在一个问题。在保持并发的高级思想的同时，我们知道，当我们将并发应用于我们的程序时，我们的主要目标之一是提高速度。让我们回到我们的双锁示例，并检查在实现资源排序后我们的程序执行时间。看看`Chapter12/example5.py`文件；它只是实现了排序（或有序）锁定的双锁程序，并添加了一个计时器来跟踪两个线程完成执行所需的时间。
- en: 'After running the script, your output should look similar to the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，你的输出应该类似于以下内容：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, you can see that the combined execution of both threads took around 14
    seconds. However, if we take a closer look at the specific instructions in the
    two threads, we will see that aside from interacting with the locks, thread A
    would take around 4 seconds to do its calculations (simulated by two `time.sleep(2)`
    commands), while thread B would take around 10 seconds (two `time.sleep(5)` commands).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到两个线程的合并执行大约花费了14秒。然而，如果我们仔细查看两个线程中的具体指令，我们会发现除了与锁交互外，线程A大约需要4秒来完成其计算（由两个`time.sleep(2)`命令模拟），而线程B大约需要10秒（两个`time.sleep(5)`命令）。
- en: 'Does this mean that our program is taking as long as it would if we were to
    execute the two threads sequentially? We will test this theory with our `Chapter12/example6.py`
    file, in which we specify that each thread should execute its instructions one
    at a time with the same `thread_a()` and `thread_b()` functions:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着我们的程序执行时间与顺序执行两个线程的时间一样长？我们将通过`Chapter12/example6.py`文件来测试这个理论，其中我们指定每个线程应该依次使用相同的`thread_a()`和`thread_b()`函数执行其指令：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you run this script, you will see that this sequential version of our two-lock
    program will take the same amount of time as its concurrent counterpart:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个脚本，你会看到这个顺序版本的我们的双锁程序将花费与它的并发对应者相同的时间：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This interesting phenomenon is a direct result of the heavy requirements that
    we have placed on the locks in the program. In other words, since each thread
    has to acquire both locks to complete its execution, each lock cannot be acquired
    by more than one thread at any given time. The locks must be acquired in a specific
    order, and the execution of individual threads cannot happen simultaneously. If
    we were to go back and examine the output produced by the `Chapter12/example5.py`
    file, it would be apparent that thread B could not start its calculations after
    thread A released both locks at the end of its execution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种有趣的现象是直接源于我们在程序中对锁的严格要求。换句话说，由于每个线程都必须获取两个锁以完成其执行，因此在任何给定时间，一个锁不能被超过一个线程获取。锁必须按照特定顺序获取，并且单个线程的执行不能同时发生。如果我们回顾`Chapter12/example5.py`文件产生的输出，就会明显看出线程B在线程A在其执行结束时释放两个锁后无法开始其计算。
- en: It is quite intuitive, then, to conclude that if you placed enough locks on
    the resources of your concurrent program, it would become entirely sequential
    in its execution, and, combined with the overhead of concurrent programming functionalities,
    it would have an even worse speed than the purely sequential version of the program.
    However, we did not see this sequentiality that's created by locks in the dining
    philosophers problem (simulated in Python). This is because, in the two-thread
    problem, two locks were enough to sequentialize the program execution, while five
    were not enough to do the same for the dining philosophers problem.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非常直观的，因此，可以得出结论，如果你在并发程序的资源上放置足够的锁，它的执行将完全变为顺序的，并且，结合并发编程功能的开销，它的速度甚至比纯顺序版本的程序更差。然而，我们在哲学家就餐问题（用Python模拟）中并没有看到由锁创建的这种顺序性。这是因为，在两个线程的问题中，两个锁足以顺序化程序执行，而五个锁则不足以对哲学家就餐问题做同样的事情。
- en: We will explore another instance of this phenomenon in [*Chapter 13*](B17499_13_Final_SS_ePub.xhtml#_idTextAnchor228),
    *Starvation*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第13章*](B17499_13_Final_SS_ePub.xhtml#_idTextAnchor228)中探讨这种现象的另一个实例，*饥饿*。
- en: Ignoring locks and sharing resources
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 忽略锁和共享资源
- en: '**Locks** are undoubtedly an important tool in synchronization tasks, and in
    concurrent programming in general. However, if using locks leads to an undesirable
    situation, such as a deadlock, then it is natural for us to explore the option
    of simply not using locks in our concurrent programs. By ignoring locks, our program''s
    resources effectively become shareable among different processes/threads in a
    concurrent program, thus eliminating the first of the four Coffman conditions:
    **mutual exclusion**.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**锁**无疑是同步任务和一般并发编程中的重要工具。然而，如果使用锁导致不希望的情况，例如死锁，那么我们探索在并发程序中完全不使用锁的选项是很自然的。通过忽略锁，我们的程序资源在并发程序的不同进程/线程之间变得可共享，从而消除了四个Coffman条件中的第一个：**互斥**。'
- en: 'This approach to the problem of a deadlock is straightforward to implement;
    let''s try this with the two preceding examples. In the two-lock example, we simply
    remove the code that specifies any interaction with the lock objects both inside
    the thread functions and in the main program. In other words, we are not utilizing
    a locking mechanism anymore. The `Chapter12/example7.py` file contains the implementation
    of this approach, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决死锁问题的方法易于实现；让我们用前两个例子来尝试一下。在两个锁的例子中，我们只是简单地移除了线程函数和主程序中指定与锁对象任何交互的代码。换句话说，我们不再使用锁定机制了。`Chapter12/example7.py`
    文件包含了这种方法的实现，如下所示：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you run the script, your output should look similar to the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行脚本，你的输出应该类似于以下内容：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It is clear that since we are not using locks to restrict access to any calculation
    processes, the executions of the two threads have become entirely independent
    of one another, so the threads were run completely in parallel. For this reason,
    we also obtained a better speed: since the threads ran in parallel, the total
    time that the whole program took was the same as the time that the longer of the
    two threads took (in other words, thread `B`, with `10` seconds).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，由于我们没有使用锁来限制对任何计算过程的访问，两个线程的执行已经完全独立于彼此，因此线程完全并行运行。因此，我们也获得了更好的速度：由于线程并行运行，整个程序所需的总时间与较长的线程所需的时间相同（也就是说，线程
    `B`，需要 `10` 秒）。
- en: What about the dining philosophers problem? It seems that we can also conclude
    that without locks (the forks), the problem can be solved easily. Since the resources
    (food) are unique to each philosopher (in other words, no philosopher should eat
    another philosopher's food), it should be the case that each philosopher can proceed
    with their execution without worrying about the others. By ignoring the locks,
    each can be executed in parallel, similar to what we saw in our two-lock example.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 那么关于哲学家就餐问题呢？看起来我们也可以得出结论，如果没有锁（即叉子），这个问题可以很容易地解决。由于资源（食物）对每位哲学家是唯一的（换句话说，没有哲学家应该吃另一个哲学家的食物），因此每个哲学家应该可以继续执行而不用担心其他人。通过忽略锁，每个哲学家都可以并行执行，类似于我们在两个锁的例子中看到的那样。
- en: Doing this, however, means that we are completely misunderstanding the problem.
    We know that locks are utilized so that processes and threads can access the shared
    resources in a program in a systematic, coordinated way, to avoid mishandling
    the data. Therefore, removing any locking mechanisms in a concurrent program means
    that the likelihood of the shared resources, which are now free from access limitations,
    being manipulated in an uncoordinated way (and therefore, becoming corrupted)
    increases significantly.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事，然而，意味着我们完全误解了问题。我们知道锁被用来确保进程和线程可以以系统化、协调的方式访问程序中的共享资源，以避免数据处理不当。因此，在并发程序中移除任何锁定机制意味着现在不受访问限制的共享资源被无序操作（因此，可能被破坏）的可能性显著增加。
- en: So, by ignoring locks, it is relatively likely that we will need to completely
    redesign and restructure our concurrent program. If the shared resources still
    need to be accessed and manipulated in an organized way, other synchronization
    methods will need to be implemented. The logic of our processes and threads might
    need to be altered to interact with this new synchronization method appropriately,
    the execution time might be negatively affected by this change in the structure
    of the program, and other potential synchronization problems might also arise.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过忽略锁，我们很可能需要完全重新设计和重构我们的并发程序。如果共享资源仍然需要以有组织的方式被访问和操作，就需要实施其他同步方法。我们进程和线程的逻辑可能需要改变以适当地与这种新的同步方法交互，程序结构的这种变化可能会对执行时间产生负面影响，并且也可能出现其他潜在的同步问题。
- en: An additional note about locks
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于锁的附加说明
- en: 'While the approach of dismissing locking mechanisms in our program to eliminate
    deadlocks might raise some questions and concerns, it does effectively reveal
    a new point for us about lock objects in Python: it is possible for an element
    of a concurrent program to completely bypass the locks when accessing a given
    resource. In other words, lock objects only prevent different processes/threads
    from accessing and manipulating a shared resource if those processes or threads
    acquire the lock objects.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在我们的程序中取消锁定机制以消除死锁的方法可能会引起一些疑问和担忧，但它确实有效地揭示了我们关于Python中锁对象的一个新观点：并发程序的一个元素在访问特定资源时可以完全绕过锁。换句话说，只有当进程或线程获取锁对象时，锁对象才阻止不同的进程/线程访问和操作共享资源。
- en: Locks, then, do not lock anything. They are simply flags that help indicate
    whether a resource should be accessed at a given time; if a poorly instructed,
    or even malicious, process/thread attempts to access that resource without checking
    that the lock object exists, it will most likely be able to do that without difficulty.
    In other words, locks are not connected to the resources that they are supposed
    to lock, and they most certainly do not block processes/threads from accessing
    those resources.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，锁并不锁定任何东西。它们只是帮助指示在特定时间是否应该访问资源的标志；如果一个指导不当，甚至恶意的过程/线程试图在不检查锁对象存在的情况下访问该资源，它很可能能够轻松地做到这一点。换句话说，锁与它们应该锁定的资源没有关联，它们绝对不会阻止进程/线程访问这些资源。
- en: So, simply using locks is inefficient for designing and implementing a secure,
    dynamic, concurrent data structure. To achieve that, we would need to either add
    more concrete links between the locks and their corresponding resources or utilize
    a different synchronization tool altogether (for example, atomic message queues).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，仅仅使用锁来设计和实现一个安全、动态的并发数据结构是低效的。为了实现这一点，我们可能需要增加锁和它们对应的资源之间的更多具体链接，或者完全使用不同的同步工具（例如，原子消息队列）。
- en: Concluding note on deadlock solutions
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于死锁解决方案的总结性说明
- en: In this chapter, you have seen two of the most common approaches to the deadlock
    problem. Each addresses one of the four Coffman conditions, and while both (somewhat)
    successfully prevent deadlocks from occurring in our examples, each raises different,
    additional problems and concerns. So, it is important to truly understand the
    nature of your concurrent programs to know which of the two is applicable, if
    either of them is.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经看到了解决死锁问题的两种最常见的方法。每种方法都针对四个Coffman条件中的一个，虽然两者（在一定程度上）成功地防止了死锁在我们的例子中发生，但每种方法都提出了不同的问题和担忧。因此，真正理解你的并发程序的本质，知道哪一种适用，如果两者都适用的话，是很重要的。
- en: It is also possible that some programs, through deadlocks, are revealed to us
    as unsuitable to be made concurrent; some programs are better left sequential
    and will be made worse with forced concurrency. As we have discussed, while concurrency
    provides significant improvements in many areas of our applications, some are
    inherently inappropriate for concurrent programming. In deadlock situations, developers
    should be ready to consider different approaches to designing a concurrent program
    and should not be reluctant to implement another method when one concurrent approach
    does not work.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能有些程序，通过死锁，被我们揭示为不适合并发执行；有些程序最好是顺序执行，强制并发会使它们变得更糟。正如我们讨论的那样，虽然并发在我们的应用程序的许多领域提供了显著的改进，但有些本质上不适合并发编程。在死锁情况下，开发者应该准备好考虑不同的方法来设计并发程序，并且不应该因为一个并发方法不起作用而不愿意实施另一种方法。
- en: The concept of livelocks
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活锁的概念
- en: The concept of a livelock is connected to a deadlock; some even consider it
    an alternate version of a deadlock. In a livelock situation, the processes (or
    threads) in the concurrent program can switch their states; in fact, they switch
    states constantly. Yet, they simply switch back and forth infinitely, and no progress
    is made. We will now consider an actual scenario of a livelock.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 活锁的概念与死锁相关联；有些人甚至认为它是死锁的另一种版本。在活锁情况下，并发程序中的进程（或线程）可以切换它们的状态；实际上，它们不断切换状态。然而，它们只是无限地来回切换，没有任何进展。我们现在将考虑一个实际的活锁场景。
- en: 'Suppose that a pair of spouses are eating dinner together at a table. They
    only have one fork to share, so only one of them can eat at any given point. Additionally,
    the spouses are polite to each other, so even if one spouse is hungry and wants
    to eat their food, they will leave the fork on the table if their partner is also
    hungry. This specification is at the heart of creating a livelock for this problem:
    when both spouses are hungry, each will wait for the other to eat first, creating
    an infinite loop in which each spouse switches between wanting to eat and waiting
    for the other spouse to eat.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一对配偶正在餐桌旁一起用餐。他们只有一把叉子可以共享，所以任何时候只有其中一个人可以吃饭。此外，配偶之间都很礼貌，即使其中一方饿了想吃食物，如果另一方也饿了，他们也会把叉子留在桌子上。这个规范是创建这个问题的活锁的核心：当双方都饿了，他们会互相等待对方先吃，从而形成一个无限循环，在这个循环中，每一方都在想吃和等待对方吃饭之间切换。
- en: 'Let''s simulate this problem in Python. Navigate to `Chapter12/example8.py`
    and take a look at the `Spouse` class:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Python中模拟这个问题。导航到`Chapter12/example8.py`并查看`Spouse`类：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This class inherits from the `threading.Thread` class and implements the logic
    that we discussed previously. It takes in a name for the `Spouse` instance and
    another `Spouse` object as its partner; when initialized, a `Spouse` object is
    also always hungry (the `hungry` attribute is always set to `True`). The `run()`
    function in the class specifies the logic when the thread is started: so long
    as the `Spouse` object''s `hungry` attribute is set to `True`, the object will
    attempt to use the fork, which is a lock object, to eat. However, it always checks
    whether its partner also has its `hungry` attribute set to `True`, in which case
    it will not proceed to acquire the lock, and will instead wait for its partner
    to do it.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类继承自`threading.Thread`类，并实现了我们之前讨论的逻辑。它接受一个`Spouse`实例的名称和另一个`Spouse`对象作为其伴侣；当初始化时，`Spouse`对象总是饿的（`hungry`属性总是设置为`True`）。类中的`run()`函数指定了线程启动时的逻辑：只要`Spouse`对象的`hungry`属性设置为`True`，该对象就会尝试使用叉子，这是一个锁对象。然而，它总是检查其伴侣是否也将其`hungry`属性设置为`True`，如果是，它将不会继续获取锁，而是等待其伴侣去获取。
- en: 'In our main program, we create the fork as a lock object first; then, we create
    two `Spouse` thread objects, which are each other''s `partner` attributes. Finally,
    we start both threads and run the program until both threads finish executing:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主程序中，我们首先创建叉子作为锁对象；然后，我们创建两个`Spouse`线程对象，它们是彼此的`partner`属性。最后，我们启动两个线程并运行程序，直到两个线程执行完毕：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you run the script, you will see that, as we discussed, each thread will
    go into an infinite loop, switching between wanting to eat and waiting for its
    partner to eat; the program will run forever until Python is interrupted. The
    following code shows the first few lines of output that I obtained:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行脚本，你会看到，正如我们讨论的那样，每个线程都会进入一个无限循环，在想吃和等待其伴侣吃饭之间切换；程序将永远运行，直到Python被中断。以下代码显示了我在获得的前几行输出：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: And with that, we can conclude our discussion on deadlocks and livelocks.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们可以得出关于死锁和活锁的讨论结论。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the causes of deadlocks in concurrent applications
    and implemented approaches to prevent them from occurring. Our examples have shown
    that concurrency cannot always be achieved straightforwardly and that some situations
    may require special handling. These discussions have prepared us for deadlocks
    in the real world and pointed us toward potential solutions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了并发应用程序中死锁的原因，并介绍了防止其发生的实施方法。我们的示例表明，并发性并不总是可以简单地实现，某些情况可能需要特殊处理。这些讨论为我们应对现实世界中的死锁做好了准备，并指出了可能的解决方案。
- en: 'In the next chapter, we will discuss another common problem in concurrent programming:
    starvation.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论并发编程中的另一个常见问题：饥饿。
- en: Questions
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What can lead to a deadlock situation, and why is it undesirable?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么可能导致死锁情况，为什么它是不希望的？
- en: How is the dining philosophers problem related to the problem of a deadlock?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进餐哲学家问题与死锁问题有何关联？
- en: What are the four Coffman conditions?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 四个Coffman条件是什么？
- en: How can resource ranking solve the problem of a deadlock? What other problems
    can occur when this is implemented?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源排序如何解决死锁问题？在实施此操作时可能会出现哪些其他问题？
- en: How can ignoring locks solve the problem of a deadlock? What other problems
    can occur when this is implemented?
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 忽略锁如何解决死锁问题？在实施此操作时可能会出现哪些其他问题？
- en: How is a livelock related to a deadlock?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 活锁与死锁有何关联？
- en: Further reading
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Parallel Programming with Python*, by Jan. Palach, Packt Publishing Ltd, 2014'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Python 并行编程》*，作者：Jan. Palach，Packt Publishing Ltd，2014'
- en: '*Python Parallel Programming Cookbook*, by Giancarlo Zaccone, Packt Publishing
    Ltd, 2015'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Python 并行编程食谱》*，作者：Giancarlo Zaccone，Packt Publishing Ltd，2015'
- en: '*Python Thread Deadlock Avoidance* (`dabeaz.blogspot.com/2009/11/python-thread-deadlock-avoidance_20`)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Python 线程死锁避免》* (`dabeaz.blogspot.com/2009/11/python-thread-deadlock-avoidance_20`)'
