<html><head></head><body>
		<div id="_idContainer023">
			<h1 id="_idParaDest-34" class="chapter-number"><a id="_idTextAnchor036"/>2</h1>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor037"/>Authentication and Authorization using JWTs</h1>
			<p>In this chapter, we’ll dive deeper into Django and its architecture. We’ll be working with <strong class="bold">models</strong>, <strong class="bold">serializers</strong>, and <strong class="bold">viewsets</strong> to create an API that can receive HTTP requests as well as return a response. This will be done by building an authentication and authorization system using <strong class="bold">JSON Web Tokens</strong> (<strong class="bold">JWTs</strong>) to allow users to create an account, log in, and <span class="No-Break">log out.</span></p>
			<p>By the end of this chapter, you’ll be able to create Django models, write Django serializers and validation, write viewsets to handle your API requests, expose your viewsets via the Django REST routers, create an authentication and authorization system based on JWTs, and understand what a JWT is and how it helps with authentication <span class="No-Break">and permissions.</span></p>
			<p>We will be covering the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><span class="No-Break">Understanding JWTs</span></li>
				<li>Organizing <span class="No-Break">a project</span></li>
				<li>Creating a <span class="No-Break">user model</span></li>
				<li>Writing the user <span class="No-Break">registration feature</span></li>
				<li>Adding the <span class="No-Break">login feature</span></li>
				<li><span class="No-Break">Refresh logic</span></li>
			</ul>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor038"/>Technical requirements</h1>
			<p>For this chapter, you’ll need to have Insomnia installed on your machine to make requests to the API we’ll <span class="No-Break">be building.</span></p>
			<p>You can also find the code of this chapter <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap2"><span class="No-Break">https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap2</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor039"/>Understanding JWTs</h1>
			<p>Before writing the authentication feature, let’s explain what a JWT is. As mentioned earlier, <strong class="bold">JWT</strong> stands for<a id="_idIndexMarker068"/> <strong class="bold">JSON Web Token</strong>. It’s one of the most used means of authentication in web applications but also helps with authorization and <span class="No-Break">information exchanges.</span></p>
			<p>According to RFC 7519, a JWT is a JSON object defined as a safe way of transmitting information between two parties. Information transmitted by JWT is digitally signed so it can be verified <span class="No-Break">and trusted.</span></p>
			<p>A JWT contains three parts—a header (<strong class="source-inline">x</strong>), a payload (<strong class="source-inline">y</strong>), and a signature (<strong class="source-inline">z</strong>)—that are separated by <span class="No-Break">a dot:</span></p>
			<pre class="source-code">
xxxxx.yyyyy.zzzzz</pre>
			<ul>
				<li><span class="No-Break"><strong class="bold">Header</strong></span></li>
			</ul>
			<p>The header<a id="_idIndexMarker069"/> of the JWT consists of two parts: the type of token and the signing algorithm being used. The signing algorithm is used to ensure that the message is authentic and <span class="No-Break">not altered.</span></p>
			<p>Here’s an example of <span class="No-Break">a header:</span></p>
			<pre class="source-code">
{
    "alg": "RSA",
    "typ": "JWT"
}</pre>
			<p> Signing algorithms<a id="_idIndexMarker070"/> are algorithms used to sign tokens issued for your application <span class="No-Break">or API.</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Payload</strong></span></li>
			</ul>
			<p>The payload<a id="_idIndexMarker071"/> is the second part that contains the claims. According to the official JWT documentation (<a href="https://jwt.io/introduction">https://jwt.io/introduction</a>), claims<a id="_idIndexMarker072"/> are statements about an entity (typically, the user) and <span class="No-Break">additional data.</span></p>
			<p>Here’s an example of <span class="No-Break">a payload:</span></p>
			<pre class="source-code">
{
  "id": "d1397699-f37b-4de0-8e00-948fa8e9bf2c",
  "name": "John Doe",
  "admin": true
}</pre>
			<p>In the preceding example, we have three claims: the ID of the user, the name of the user, and also a Boolean for the type <span class="No-Break">of user.</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Signature</strong></span></li>
			</ul>
			<p>The signature<a id="_idIndexMarker073"/> of a JWT is the encoded header, the encoded payload plus a secret, and an algorithm specified in the header, all of them combined <span class="No-Break">and signed.</span></p>
			<p>For example, it’s possible to create a signature the following way using the <span class="No-Break">RSA algorithm:</span></p>
			<pre class="source-code">
RSA(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)</pre>
			<p>The role of the signature is to track whether information has <span class="No-Break">been changed.</span></p>
			<p>But how are JWTs actually used <span class="No-Break">in authentication?</span></p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor040"/>Understanding how JWTs are used in authentication</h2>
			<p>Each time a user <a id="_idIndexMarker074"/>successfully logs in, a JWT is created and returned. The JWT will be represented as credentials used to access protected resources. The fact that it’s possible to store data in a JWT makes it vulnerable. That’s why you should specify an expiration time when creating <span class="No-Break">a JWT.</span></p>
			<p>In this book, we’ll be using JWTs in two ways. To make it simple, we’ll have two types <span class="No-Break">of tokens:</span></p>
			<ul>
				<li><strong class="bold">An access token</strong>: Used<a id="_idIndexMarker075"/> to access resources and <span class="No-Break">handle authorization</span></li>
				<li><strong class="bold">A refresh token</strong>: Used to<a id="_idIndexMarker076"/> retrieve a new <span class="No-Break">access token</span></li>
			</ul>
			<p>But why use two tokens? As we stated earlier, a JWT is generated when users log in. Moreover, JWTs used to access resources should have a short lifespan. This means that after the JWT has expired, the user has to log in again and again – and no user wants the login page to appear every <span class="No-Break">5 minutes.</span></p>
			<p>That’s where a refresh token is useful. It’ll contain the essential information needed to verify the user and generate a new <span class="No-Break">access token.</span></p>
			<p>Now that we understand the purpose of JWTs, let’s learn more about models in Django while creating the <span class="No-Break">user model.</span></p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor041"/>Organizing a project</h1>
			<p>When working with <a id="_idIndexMarker077"/>Django, you’ll have to create many apps to handle different parts of a project. For example, you can have a different application for authentication, and another for payments or articles. To have a clean and well-organized project, we can create a Django application that will contain all the apps we will create for <span class="No-Break">this book.</span></p>
			<p>At the root of the project, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
django-admin startapp core</pre>
			<p>A new application will be created. Remove all the files in this app except for the <strong class="source-inline">apps.py</strong> file and the <strong class="source-inline">__init__.py</strong> file. Inside <strong class="source-inline">apps.py</strong>, add the <span class="No-Break">following line:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/apps.py</p>
			<pre class="source-code">
from django.apps import AppConfig
class CoreConfig(AppConfig):
   default_auto_field = 'django.db.models.BigAutoField'
   name = 'core'
   label = 'core'</pre>
			<p>Register the apps in the <strong class="source-inline">setting.py</strong> file of <span class="No-Break">the project:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CoreRoot/settings.py</p>
			<pre class="source-code">
# Application definition
INSTALLED_APPS = [
   'django.contrib.admin',
   'django.contrib.auth',
   'django.contrib.contenttypes',
   'django.contrib.sessions',
   'django.contrib.messages',
   'django.contrib.staticfiles',
   'core'
]</pre>
			<p><strong class="source-inline">INSTALLED_APPS</strong> is a <a id="_idIndexMarker078"/>Django settings configuration, which is a list of Django apps within <span class="No-Break">a project.</span></p>
			<p>We can now create the user application with confidence and write our <span class="No-Break">first model.</span></p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor042"/>Creating a user model</h1>
			<p>Unless you are <a id="_idIndexMarker079"/>creating a simple web application, there is little chance of avoiding the necessity to interact with a database, particularly having an account feature that requires users to register or log in to use your <span class="No-Break">web application.</span></p>
			<p>Before talking about the account feature, let’s learn more about Django models and what problems <span class="No-Break">they resolve.</span></p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor043"/>What are Django models?</h2>
			<p>If you need to connect<a id="_idIndexMarker080"/> your application to a database, particularly <strong class="bold">SQL</strong>, the<a id="_idIndexMarker081"/> first assumption that comes to mind is that you’ll have to work directly with the database via SQL queries – and if that’s true, it can be fun, but it’s not the same for everyone; some developers may find SQL complex. You are no longer focusing on writing the application logic in your own language. Some tasks can become repetitive, such as writing SQL scripts to create tables, getting entries from the database, or inserting or <span class="No-Break">updating data.</span></p>
			<p>As you’ll see, the more the code base evolves, the more difficult it becomes to maintain both simple and complex SQL queries in your code base. This is more of an issue if you are working with multiple databases, which will require you to learn many SQL languages. For example, there are a lot of SQL databases and each one implements SQL in its <span class="No-Break">own way.</span></p>
			<p>Fortunately, in Django, this messy issue is solved by using a Django model to access the database. This doesn’t mean that you don’t have to write SQL queries: it’s just that you don’t have to use SQL at all unless you <span class="No-Break">want to.</span></p>
			<p>Django models provide <strong class="bold">object-relational mapping</strong> (<strong class="bold">ORM</strong>) to the underlying database. ORM is a tool that <a id="_idIndexMarker082"/>simplifies database programming by providing a simple mapping between the object and the database. Then, you don’t necessarily need to know the database structure or write complex SQL queries to manipulate or retrieve data from <span class="No-Break">the database.</span></p>
			<p>For example, creating a<a id="_idIndexMarker083"/> table in SQL will require writing a long <a id="_idIndexMarker084"/>SQL query. Doing this in Python will just require writing a class inheriting from the <strong class="source-inline">django.db</strong> package (<span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/Figure_2.1_B18221.jpg" alt="Figure 2.1 – Comparison between the Django ORM and SQL queries"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Comparison between the Django ORM and SQL queries</p>
			<p>In the preceding figure, you<a id="_idIndexMarker085"/> can see the SQL statement, which requires <a id="_idIndexMarker086"/>some knowledge of the syntax, as well as the fields and the options. The second code from the Django ORM does exactly the same thing but in a more Pythonic and less <span class="No-Break">verbose manner.</span></p>
			<p>Writing models with Django comes with <span class="No-Break">several advantages:</span></p>
			<ul>
				<li><strong class="bold">Simplicity</strong>: Writing queries in <a id="_idIndexMarker087"/>Python may not be as clear as writing in SQL, but it’s less error-prone and more efficient, as you don’t have to control which type of database you are working with before trying to understand <span class="No-Break">the code.</span></li>
				<li><strong class="bold">Consistency</strong>: SQL is inconsistent across different databases. Working with Django models creates an abstraction and helps you focus on the most <span class="No-Break">important tasks.</span></li>
				<li><strong class="bold">Tracking</strong>: It’s even easier to track database design changes working with Django models. It’s done by reading migration files written in Python. We’ll discuss this more in<a id="_idIndexMarker088"/> the <span class="No-Break">next chapter.</span></li>
			</ul>
			<p>Notice that you also have access to model managers. Django Manager<a id="_idIndexMarker089"/> is a class that behaves as an interface through which Django models interact with databases. Every Django model, by default, inherits the <strong class="source-inline">models.Manager</strong> class that comes with the necessary methods to<a id="_idIndexMarker090"/> make <strong class="bold">Create, Read, Update and Delete</strong> (<strong class="bold">CRUD</strong>) operations on the table in <span class="No-Break">the database.</span></p>
			<p>Now that we have a better understanding of Django models, let’s create the first model in this project, the <strong class="source-inline">User</strong> model. Working with our first model, we’ll also learn how to use the basic methods of the Django ORM to perform <span class="No-Break">CRUD operations.</span></p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor044"/>Writing the User model</h2>
			<p>In the previous<a id="_idIndexMarker091"/> section, we saw how a model is represented as a class and how this can basically be created as a table in <span class="No-Break">the database.</span></p>
			<p>Talking about the <strong class="source-inline">User</strong> model, Django comes with a pre-built-in <strong class="source-inline">User</strong> model class that you can use for basic authentication or a session. It actually provides an authentication feature you can use to quickly add authentication and authorization to <span class="No-Break">your projects.</span></p>
			<p>While it’s great for most use cases, it has its limitations. For example, in this book, we are building a social media web application. The user in this application will have some bio or even an avatar. Why not also have a<a id="_idIndexMarker092"/> phone number for <strong class="bold">two-factor </strong><span class="No-Break"><strong class="bold">authentication</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">2FA</strong></span><span class="No-Break">)?</span></p>
			<p>Actually, the <strong class="source-inline">User</strong> model of Django doesn’t come with these fields. This means we’ll need to extend it and have our own user model. This also means that we will have to add custom methods to the manager for creating a user and a superuser. This will speed up the coding process. In Django, a superuser<a id="_idIndexMarker093"/> is a user with <span class="No-Break">administrator permission.</span></p>
			<p>Before creating the model, we actually need an application, and to register it. A Django application is a submodule of a Django project. It’s a Python package structured to work in a Django project and share Django conventions such as <a id="_idIndexMarker094"/>containing files or submodules such as <strong class="source-inline">models</strong>, <strong class="source-inline">tests</strong>, <strong class="source-inline">urls</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">views</strong></span><span class="No-Break">.</span></p>
			<h3>Creating the user application</h3>
			<p>To start a <a id="_idIndexMarker095"/>new application in this project, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
cd core &amp;&amp; django-admin startapp user</pre>
			<p>This will create a new package (directory) containing new files. Here’s the structure of <span class="No-Break">the directory:</span></p>
			<pre class="source-code">
├── admin.py
├── apps.py
├── __init__.py
├── migrations
│   └── __init__.py
├── models.py
├── tests.py
└── views.py</pre>
			<p>We can now confidently start writing the <strong class="source-inline">User</strong> model. Here is the structure of the <strong class="source-inline">User</strong> table we want to have in <span class="No-Break">the database:</span></p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/Figure_2.2_B18221.jpg" alt="Figure 2.2 – User table structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – User table structure</p>
			<p>And here’s the <a id="_idIndexMarker096"/>code concerning the <strong class="source-inline">User</strong> <span class="No-Break">table structure:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/models.py</p>
			<pre class="source-code">
import uuid
from django.contrib.auth.models import AbstractBaseUser,
    BaseUserManager, PermissionsMixin
from django.core.exceptions import ObjectDoesNotExist
from django.db import models
from django.http import Http404
class User(AbstractBaseUser, PermissionsMixin):
   public_id = models.UUIDField(db_index=True, unique=True,
       default=uuid.uuid4, editable=False)
   username = models.CharField(db_index=True,
       max_length=255, unique=True)
   first_name = models.CharField(max_length=255)
   last_name = models.CharField(max_length=255)
   email = models.EmailField(db_index=True, unique=True)
   is_active = models.BooleanField(default=True)
   is_superuser = models.BooleanField(default=False)
   created = models.DateTimeField(auto_now=True)
   updated = models.DateTimeField(auto_now_add=True)
   USERNAME_FIELD = 'email'
   REQUIRED_FIELDS = ['username']
   objects = UserManager()
   def __str__(self):
       return f"{self.email}"
   @property
   def name(self):
       return f"{self.first_name} {self.last_name}"</pre>
			<p>The <strong class="source-inline">models</strong> module from Django provides some field utilities that can be used to write fields and add some rules. For example, <strong class="source-inline">CharField</strong> represents the type of field to create in the <strong class="source-inline">User</strong> table, similar to <strong class="source-inline">BooleanField</strong>. <strong class="source-inline">EmailField</strong> is also <strong class="source-inline">CharField</strong> but rewritten to validate the email that is passed as a value to <span class="No-Break">this field.</span></p>
			<p>We also set the <strong class="source-inline">EMAIL_FIELD</strong> as the email, and <strong class="source-inline">USERNAME_FIELD</strong> as the username. This will help us have two fields for login. The username can be the actual username of a user or just the email address used <span class="No-Break">for registration.</span></p>
			<p>We also have methods <a id="_idIndexMarker097"/>such as <strong class="source-inline">name</strong>, which is basically a model property. Then, it can be accessed anywhere on a <strong class="source-inline">User</strong> object, such as <strong class="source-inline">user.name</strong>. We are also rewriting the <strong class="source-inline">__str__</strong> method to return a string that can help us quickly identify a <span class="No-Break"><strong class="source-inline">User</strong></span><span class="No-Break"> object.</span></p>
			<h3>Creating the user and superuser</h3>
			<p>Next, let’s write <strong class="source-inline">UserManager</strong> so we can<a id="_idIndexMarker098"/> have methods to <a id="_idIndexMarker099"/>create a user and <span class="No-Break">a superuser:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/models.py</p>
			<pre class="source-code">
class UserManager(BaseUserManager):
   def get_object_by_public_id(self, public_id):
       try:
           instance = self.get(public_id=public_id)
           return instance
       except (ObjectDoesNotExist, ValueError, TypeError):
           return Http404
   def create_user(self, username, email, password=None,
        **kwargs):
       """Create and return a `User` with an email, phone
           number, username and password."""
       if username is None:
           raise TypeError('Users must have a username.')
       if email is None:
           raise TypeError('Users must have an email.')
       if password is None:
           raise TypeError('User must have an email.')
       user = self.model(username=username,
           email=self.normalize_email(email), **kwargs)
       user.set_password(password)
       user.save(using=self._db)
       return user
   def create_superuser(self, username, email, password,
       **kwargs):
       """
       Create and return a `User` with superuser (admin)
           permissions.
       """
       if password is None:
           raise TypeError('Superusers must have a
           password.')
       if email is None:
           raise TypeError('Superusers must have an
               email.')
       if username is None:
           raise TypeError('Superusers must have an
           username.')
       user = self.create_user(username, email, password,
           **kwargs)
       user.is_superuser = True
       user.is_staff = True
       user.save(using=self._db)
       return user</pre>
			<p>For the <strong class="source-inline">create_user</strong> method, we are basically making sure that fields such as <strong class="source-inline">password</strong>, <strong class="source-inline">email</strong>, <strong class="source-inline">username</strong>, <strong class="source-inline">first_name</strong>, and <strong class="source-inline">last_name</strong> are not <strong class="source-inline">None</strong>. If everything is good, we can confidently call the model, set a password, and save the user in <span class="No-Break">the table.</span></p>
			<p>This is done using the <span class="No-Break"><strong class="source-inline">save()</strong></span><span class="No-Break"> method.</span></p>
			<p><strong class="source-inline">create_superuser</strong> also behaves in accordance with the <strong class="source-inline">create_user</strong> method – and it’s quite normal because, after all, a superuser is just a user with admin privileges, and also fields such as <strong class="source-inline">is_superuser</strong> and <strong class="source-inline">is_staff</strong> set to <strong class="source-inline">True</strong>. Once it’s done, we save the new <strong class="source-inline">User</strong> object in the database and return <span class="No-Break">the user.</span></p>
			<p>See the <strong class="source-inline">save</strong> method as a<a id="_idIndexMarker100"/> way to commit changes made to the <strong class="source-inline">User</strong> object to<a id="_idIndexMarker101"/> <span class="No-Break">the database.</span></p>
			<p>The model is written and now we need to run migrations to create the table in <span class="No-Break">the database.</span></p>
			<h3>Running migrations and testing the model</h3>
			<p>Before <a id="_idIndexMarker102"/>running the migrations, we need to register the user application in <strong class="source-inline">INSTALLED_APPS</strong> <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">CoreRoot/settings.py</strong></span><span class="No-Break">.</span></p>
			<p>First, let’s rewrite the <strong class="source-inline">apps.py</strong> file of the user. It contains the app configs that Django will use to locate the application. Let’s also add a label for <span class="No-Break">the application:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/apps.py</p>
			<pre class="source-code">
from django.apps import AppConfig
class UserConfig(AppConfig):
   default_auto_field = 'django.db.models.BigAutoField'
   name = 'core.user'
   label = 'core_user'
Let's register the application now:
   'core',
   'core.user'
]</pre>
			<p>Let’s register the application now in the <span class="No-Break"><strong class="source-inline">INSTALLED_APPS</strong></span><span class="No-Break"> setting:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CoreRoot/settings.py</p>
			<pre class="source-code">
...
   'core',
   'core.user'
]</pre>
			<p>We also need to <a id="_idIndexMarker103"/>tell Django to use this <strong class="source-inline">User</strong> model for the authentication user model. In the <strong class="source-inline">settings.py</strong> file, add the <span class="No-Break">following line:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CoreRoot/settings.py</p>
			<pre class="source-code">
AUTH_USER_MODEL = 'core_user.User'</pre>
			<p>Great – we can now create the first migration for the <span class="No-Break">user app:</span></p>
			<pre class="console">
python manage.py makemigrations</pre>
			<p>You’ll have a <span class="No-Break">similar output:</span></p>
			<pre class="console">
Migrations for 'core_user':
  core/user/migrations/0001_initial.py
    - Create model User</pre>
			<p>Let’s migrate this modification to <span class="No-Break">the database:</span></p>
			<pre class="console">
python manage.py migrate</pre>
			<p>The table is created in the database. Let’s use the Django shell to play with the newly created model a <span class="No-Break">little bit:</span></p>
			<pre class="console">
python manage.py shell</pre>
			<p>Let’s <a id="_idIndexMarker104"/>import the model and add a dict containing the data needed to<a id="_idIndexMarker105"/> create <span class="No-Break">a user:</span></p>
			<pre class="console">
Python 3.10.1 (main, Dec 21 2021, 17:46:38) [GCC 9.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
&gt;&gt;&gt; from core.user.models import User
&gt;&gt;&gt; data_user = {
... "email": "testuser@yopmail.com",
... "username": "john-doe",
... "password": "12345",
... "first_name": "John",
... "last_name": "Doe"
... }
&gt;&gt;&gt; user =  User.objects.create_user(**data_user)
The user is created in the database. Let's access some properties of the user object.
&gt;&gt;&gt; user.name
'John Doe'
&gt;&gt;&gt; user.email
'testuser@yopmail.com'
&gt;&gt;&gt; user.password
'pbkdf2_sha256$320000$NxM7JZ0cQ0OtDzCVusgvV7$fM1WZp7QhHC3QEajnb Bjo5rBPKO+Q8ONhDFkCV/gwcI='</pre>
			<p>Great – we’ve just <a id="_idIndexMarker106"/>written the model and created the first user. However, a web <a id="_idIndexMarker107"/>browser won’t directly read the user data from our database – and worse, we are working with a Python native object, and a browser or a client reaching our server to make requests mostly supports JSON or XML. One idea would be to use the <strong class="source-inline">json</strong> library, but we are dealing with a complex data structure; complex data structures can be easily handled <span class="No-Break">with serializers.</span></p>
			<p>Let’s write serializers in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor045"/>Writing UserSerializer</h2>
			<p>A serializer allows us to convert complex Django complex data structures such as <strong class="source-inline">QuerySet</strong> or model instances into Python native objects that can be easily converted to JSON or XML format. However, a serializer also serializes JSON or XML to native Python. <strong class="bold">Django Rest Framework</strong> (<strong class="bold">DRF</strong>) provides<a id="_idIndexMarker108"/> a <strong class="source-inline">serializers</strong> package you<a id="_idIndexMarker109"/> can use to write serializers and also validations when API calls are made to an endpoint using this serializer. Let’s install the DRF package and make some <span class="No-Break">configurations first:</span></p>
			<pre class="console">
pip install djangorestframework django-filter</pre>
			<p>Don’t forget to add the following to the <span class="No-Break"><strong class="source-inline">requirements.txt</strong></span><span class="No-Break"> file:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">requirements.txt</p>
			<pre class="source-code">
Django==4.0.1
psycopg2-binary==2.9.3
djangorestframework==3.13.1
django-filter==21.1</pre>
			<p>We are also adding <strong class="source-inline">django-filter</strong> for data filtering support. Let’s add <strong class="source-inline">rest_framework</strong> to the <span class="No-Break"><strong class="source-inline">INSTALLED_APPS</strong></span><span class="No-Break"> setting:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CoreRoot/settings.py</p>
			<pre class="source-code">
INSTALLED_APPS = [
    ...
    'rest_framework',
]</pre>
			<p>In the <strong class="source-inline">core/user</strong> directory, create <a id="_idIndexMarker110"/>a file called <strong class="source-inline">serializers.py</strong>. This file will contain the <span class="No-Break"><strong class="source-inline">UserSerializer</strong></span><span class="No-Break"> class:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/serializers.py</p>
			<pre class="source-code">
from rest_framework import serializers
from core.user.models import User
class UserSerializer(serializers.ModelSerializer):
   id = serializers.UUIDField(source='public_id',
       read_only=True, format='hex')
   created = serializers.DateTimeField(read_only=True)
   updated = serializers.DateTimeField(read_only=True)
   class Meta:
       model = User
       fields = ['id', 'username', 'first_name',
           'last_name', 'bio', 'avatar', 'email',
           'is_active', 'created', 'updated']
       read_only_field = ['is_active']</pre>
			<p>The <strong class="source-inline">UserSerializer</strong> class inherits from the <strong class="source-inline">serializers.ModelSerialzer</strong> class. It’s a class inheriting from the <strong class="source-inline">serializers.Serializer</strong> class but has deep integrations for supporting a model. It’ll automatically match the field of the model to have the correct validations for <span class="No-Break">each one.</span></p>
			<p>For example, we’ve stated that the email is unique. Then, every time someone registers and enters an email address that already exists in the database, they will receive an error message <span class="No-Break">concerning this.</span></p>
			<p>The <strong class="source-inline">fields</strong> attribute contains all the fields that can be read or written. Then, we also have the <strong class="source-inline">read_only</strong> fields. These fields are only readable. This means that they can’t be modified and it’s definitely better like that. Why give the external user the possibility to modify<a id="_idIndexMarker111"/> the <strong class="source-inline">created</strong>, <strong class="source-inline">updated</strong>, or <span class="No-Break"><strong class="source-inline">id</strong></span><span class="No-Break"> fields?</span></p>
			<p>Now that <strong class="source-inline">UserSerializer</strong> is available, we can now <span class="No-Break">write </span><span class="No-Break"><strong class="source-inline">viewset</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor046"/>Writing UserViewset</h2>
			<p>As we know, Django<a id="_idIndexMarker112"/> at its core is based on the <strong class="bold">Model-View-Template</strong> (<strong class="bold">MVT</strong>) architecture. The model<a id="_idIndexMarker113"/> communicates with the views (or controllers) and the template displays responses or redirects requests to <span class="No-Break">the views.</span></p>
			<p>However, when Django is coupled with DRF, the model can be directly connected to the view. However, as good practice, use a serializer between a model and a viewset. This really helps with validation and also some <span class="No-Break">important checks.</span></p>
			<p>So, what is a viewset then? DRF provides a class named <strong class="source-inline">APIView</strong> from which a lot of classes from DRF inherit to perform CRUD operations. Therefore, a viewset is simply a class-based view that can handle all the basic HTTP requests—<strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">DELETE</strong>, and <strong class="source-inline">PATCH</strong>—without hardcoding any CRUD <span class="No-Break">logic here.</span></p>
			<p>For the <strong class="source-inline">viewset</strong> user, we are only allowing the <strong class="source-inline">PATCH</strong> and <strong class="source-inline">GET</strong> methods. Here’s what the endpoints will <span class="No-Break">look like:</span></p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Method</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">URL</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Result</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">GET</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">api/user/</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Lists all <span class="No-Break">the users</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">GET</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">api/user/user_pk/</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Retrieves a <span class="No-Break">specific user</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">PATCH</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">api/user/user_pk/</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Modifies <span class="No-Break">a user</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.1 – Endpoints</p>
			<p>Let’s write the <a id="_idIndexMarker114"/>viewset. Inside the <strong class="source-inline">user</strong> directory, rename the <strong class="source-inline">view</strong> file <strong class="source-inline">viewsets.py</strong> and add the <span class="No-Break">following content:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/viewsets.py</p>
			<pre class="source-code">
from rest_framework.permissions import AllowAny
from rest_framework import viewsets
from core.user.serializers import UserSerializer
from core.user.models import User
class UserViewSet(viewsets.ModelViewSet):
   http_method_names = ('patch', 'get')
   permission_classes = (AllowAny,)
   serializer_class = UserSerializer
   def get_queryset(self):
       if self.request.user.is_superuser:
           return User.objects.all()
       return User.objects.exclude(is_superuser=True)
   def get_object(self):
    obj =
    User.objects.get_object_by_public_id(self.kwargs['pk'])
       self.check_object_permissions(self.request, obj)
       return obj</pre>
			<p>The only methods <a id="_idIndexMarker115"/>allowed here are <strong class="source-inline">GET</strong> and <strong class="source-inline">PUT</strong>. We also set <strong class="source-inline">serializer_class</strong> and <strong class="source-inline">permission_classes</strong> to <strong class="source-inline">AllowAny</strong>, which means that anybody can access these viewsets. We also rewrite <span class="No-Break">two methods:</span></p>
			<ul>
				<li><strong class="source-inline">get_queryset</strong>: This method is used by the viewset to get a list of all the users. This method will be called when <strong class="source-inline">/user/</strong> is hit with a <span class="No-Break"><strong class="source-inline">GET</strong></span><span class="No-Break"> request.</span></li>
				<li><strong class="source-inline">get_object</strong>: This method is used by the viewset to get one user. This method is called when a <strong class="source-inline">GET</strong> or <strong class="source-inline">PUT</strong> request is made on the <strong class="source-inline">/user/id/</strong> endpoint, with <strong class="source-inline">id</strong> representing the ID of <span class="No-Break">the user.</span></li>
			</ul>
			<p>There we <a id="_idIndexMarker116"/>have the <strong class="source-inline">User</strong> viewset – but there is no endpoint yet to make it work. Well, let’s add a <span class="No-Break">router now.</span></p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor047"/>Adding a router</h2>
			<p>Routers allow<a id="_idIndexMarker117"/> you to quickly declare all of the common routes for a given controller; the next code snippet shows a viewset to which we will be adding <span class="No-Break">a router.</span></p>
			<p>At the root of the <a id="_idIndexMarker118"/>apps project (<strong class="source-inline">core</strong>), create a file <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">routers.py</strong></span><span class="No-Break">.</span></p>
			<p>And let’s add <span class="No-Break">the code:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/routers.py</p>
			<pre class="source-code">
from rest_framework import routers
from core.user.viewsets import UserViewSet
router = routers.SimpleRouter()
# ##################################################################### #
# ################### USER                       ###################### #
# ##################################################################### #
router.register(r'user', UserViewSet, basename='user')
urlpatterns = [
   *router.urls,
]</pre>
			<p>To register a route for a viewset, the <strong class="source-inline">register()</strong> method needs <span class="No-Break">two arguments:</span></p>
			<ul>
				<li><strong class="bold">The prefix</strong>: Representing the name of the <span class="No-Break">endpoint, basically</span></li>
				<li><strong class="bold">The viewset</strong>: Only representing a valid <span class="No-Break">viewset class</span></li>
			</ul>
			<p>The <strong class="source-inline">basename</strong> argument is optional but it’s a good practice to use one, as it helps for readability and also helps Django for URL <span class="No-Break">registry purposes.</span></p>
			<p>The router is now added; we can make some requests to the API <span class="No-Break">using Insomnia.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Insomnia<a id="_idIndexMarker119"/> is a REST client tool used to make requests to RESTful API. With Insomnia, you can manage and create your requests elegantly. It offers support for cookie management, environment variables, code generation, <span class="No-Break">and authentication.</span></p>
			<p>Before doing <a id="_idIndexMarker120"/>that, make sure to have the <span class="No-Break">server running:</span></p>
			<pre class="console">
python manage.py runserver</pre>
			<p>Let’s make a request to <strong class="source-inline">http://127.0.0.1:8000/api/user/</strong>, a <strong class="source-inline">GET</strong> request. Look at the following screenshot and make sure to have the same URL – or you can replace <strong class="source-inline">127.0.0.1</strong> with <strong class="source-inline">localhost --</strong>, next to the <span class="No-Break"><strong class="bold">Send</strong></span><span class="No-Break"> button.</span></p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/Figure_2.3_B18221.jpg" alt="Figure 2.3 – Listing all users"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Listing all users</p>
			<p>As you can see, we <a id="_idIndexMarker121"/>have a list of users created. Let’s also make a <strong class="source-inline">GET</strong> request to retrieve the first user using this <span class="No-Break">URL: </span><span class="No-Break"><strong class="source-inline">/api/user/&lt;id&gt;/</strong></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/Figure_2.4_B18221.jpg" alt="Figure 2.4 – Retrieving a user"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Retrieving a user</p>
			<p>We have now a<a id="_idIndexMarker122"/> <strong class="source-inline">User</strong> object. This endpoint also allows <strong class="source-inline">PATCH</strong> requests. Let’s set the <strong class="source-inline">last_name</strong> value for this user to <strong class="source-inline">Hey</strong>. Change the type of request to <strong class="source-inline">PATCH</strong> and add a <span class="No-Break">JSON body.</span></p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/Figure_2.5_B18221.jpg" alt="Figure 2.5 – Modifying a user without permissions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Modifying a user without permissions</p>
			<p>Although it’s <a id="_idIndexMarker123"/>working, it’s actually a very bad scenario. We can’t have users modify other user names or data. A solution is to change the permission on the <strong class="source-inline">permission_classes</strong> attribute in the <span class="No-Break"><strong class="source-inline">UserViewSet</strong></span><span class="No-Break"> class:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/viewsets.py</p>
			<pre class="source-code">
from rest_framework.permissions import IsAuthenticated
...
class UserViewSet(viewsets.ModelViewSet):
   http_method_names = ('patch', 'get')
   permission_classes = (IsAuthenticated,)
   serializer_class = UserSerializer
...</pre>
			<p>Let’s try <a id="_idIndexMarker124"/>the <strong class="source-inline">PATCH</strong> <span class="No-Break">request again.</span></p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/Figure_2.6_B18221.jpg" alt="Figure 2.6 – Modifying a user without permissions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Modifying a user without permissions</p>
			<p>We normally have a <strong class="source-inline">401</strong> status, an indication of an authentication issue. Basically, it means that an authentication header should be provided. They are more permissions to add <a id="_idIndexMarker125"/>concerning interactions with users, but let’s discuss this in <span class="No-Break">later chapters.</span></p>
			<p>Great. Now that we are done with the user application, we can confidently move on to adding a login and registration feature to <span class="No-Break">the project.</span></p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor048"/>Writing the user registration feature</h1>
			<p>Before accessing <a id="_idIndexMarker126"/>protected data, the user needs to be authenticated. This comes with the assumption that there is a registration system to create an account <span class="No-Break">and credentials.</span></p>
			<p>To make things simpler, if the registration of a user is successful, we will provide credentials, here JWTs, so the user won’t have to log in again to start a session – a win for <span class="No-Break">user experience.</span></p>
			<p>First, let’s install a package that will handle JWT authentication for us. The <strong class="source-inline">djangorestframework-simplejwt</strong> package is a JWT authentication plugin <span class="No-Break">for DRF:</span></p>
			<pre class="console">
pip install djangorestframework-simplejwt</pre>
			<p>The package covers the <a id="_idIndexMarker127"/>most common use case of JWT, and in this case here, it facilitates the creation and management of access tokens, as well as refreshing tokens. Before working with this package, there are some configurations needed in the <strong class="source-inline">settings.py</strong> file. We need to register the app in <strong class="source-inline">INSTALLED_APPS</strong> and specify <strong class="source-inline">DEFAULT_AUTHENTICATION_CLASSES</strong> in the <span class="No-Break"><strong class="source-inline">REST_FRAMEWORK</strong></span><span class="No-Break"> dict:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CoreRoot/settings.py</p>
			<pre class="source-code">
   …
   # external packages apps
   'rest_framework',
   'rest_framework_simplejwt',
   'core',
   'core.user'
]
...
REST_FRAMEWORK = {
   'DEFAULT_AUTHENTICATION_CLASSES': (
       'rest_framework_simplejwt.authentication
           .JWTAuthentication',
   ),
   'DEFAULT_FILTER_BACKENDS':
     ['django_filters.rest_framework.DjangoFilterBackend'],
}</pre>
			<p>First, we need to write a registration serializer, but before that, let’s create a new application called <strong class="source-inline">auth</strong> in the <span class="No-Break"><strong class="source-inline">core</strong></span><span class="No-Break"> app:</span></p>
			<pre class="console">
cd core &amp;&amp; django-admin startapp auth</pre>
			<p>It’ll contain all the logic concerning logging in, registration, logging out, and a <span class="No-Break">lot more.</span></p>
			<p>As we did earlier<a id="_idIndexMarker128"/> for the user application, let’s rewrite the <strong class="source-inline">apps.py</strong> file and register the application in the <span class="No-Break"><strong class="source-inline">INSTALLED_APPS</strong></span><span class="No-Break"> settings:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/apps.py</p>
			<pre class="source-code">
from django.apps import AppConfig
class AuthConfig(AppConfig):
   default_auto_field = 'django.db.models.BigAutoField'
   name = 'core.auth'
   label = 'core_auth'
And adding the new application to <strong class="source-inline">INSTALLED_APPS</strong>:
...
'core',
   'core.user',
   'core.auth'
]
...</pre>
			<p>Remove the <strong class="source-inline">admin.py</strong> and <strong class="source-inline">models.py</strong> files from the <strong class="source-inline">auth</strong> directory, as we won’t be working <a id="_idIndexMarker129"/>with them. For registration and login, we’ll have many serializers and viewsets, so let’s organize the code accordingly. Create a Python package called <strong class="source-inline">serializers</strong> and another one called <strong class="source-inline">viewsets</strong>. Make sure that these new directories have an <strong class="source-inline">__init__.py</strong> file. Here’s how your <strong class="source-inline">auth</strong> app tree <span class="No-Break">should look:</span></p>
			<pre class="source-code">
├── apps.py
├── __init__.py
├── migrations
│   ├── __init__.py
├── serializers
│   └── __init__.py
├── tests.py
├── viewsets
│   └── __init__.py
└── views.py</pre>
			<p>Inside the <strong class="source-inline">serializers</strong> directory, create a file called <strong class="source-inline">register.py</strong>. It’ll contain the code for <strong class="source-inline">RegisterSerializer</strong>, which is the name of the registration <span class="No-Break">serializer class:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/serializers/register.py</p>
			<pre class="source-code">
from rest_framework import serializers
from core.user.serializers import UserSerializer
from core.user.models import User
class RegisterSerializer(UserSerializer):
   """
   Registration serializer for requests and user creation
   """
   # Making sure the password is at least 8 characters
       long, and no longer than 128 and can't be read
   # by the user
   password = serializers.CharField(max_length=128,
       min_length=8, write_only=True, required=True)
   class Meta:
       model = User
       # List of all the fields that can be included in a
           request or a response
       fields = ['id', 'bio', 'avatar', 'email',
           'username', 'first_name', 'last_name',
           'password']
   def create(self, validated_data):
       # Use the `create_user` method we wrote earlier for
           the UserManager to create a new user.
       return User.objects.create_user(**validated_data)</pre>
			<p>As you can <a id="_idIndexMarker130"/>see, <strong class="source-inline">RegisterSerializer</strong> is a subclass of <strong class="source-inline">UserSerializer</strong>. This is really helpful, as we don’t need to rewrite <span class="No-Break">fields again.</span></p>
			<p>Here, we don’t need to revalidate fields such as <strong class="source-inline">email</strong> or <strong class="source-inline">password</strong>. As we declared these fields with some conditions, Django will automatically handle <span class="No-Break">their validation.</span></p>
			<p>Next, we can add the <a id="_idIndexMarker131"/>viewset and register it in the <span class="No-Break"><strong class="source-inline">register.py</strong></span><span class="No-Break"> file:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/viewsets/register.py</p>
			<pre class="source-code">
from rest_framework.response import Response
from rest_framework.viewsets import ViewSet
from rest_framework.permissions import AllowAny
from rest_framework import status
from rest_framework_simplejwt.tokens import RefreshToken
from core.auth.serializers import RegisterSerializer
class RegisterViewSet(ViewSet):
   serializer_class = RegisterSerializer
   permission_classes = (AllowAny,)
   http_method_names = ['post']
   def create(self, request, *args, **kwargs):
       serializer =
           self.serializer_class(data=request.data)
       serializer.is_valid(raise_exception=True)
       user = serializer.save()
       refresh = RefreshToken.for_user(user)
       res = {
           "refresh": str(refresh),
           "access": str(refresh.access_token),
       }
       return Response({
           "user": serializer.data,
           "refresh": res["refresh"],
           "token": res["access"]
       }, status=status.HTTP_201_CREATED)</pre>
			<p>Nothing really new here – we are using attributes from the <strong class="source-inline">ViewSet</strong> class. We are also rewriting the <strong class="source-inline">create</strong> method to add access and refresh tokens in the body of the response. The <strong class="source-inline">djangorestframework-simplejwt</strong> package provides utilities we can use to directly generate tokens. That’s what <span class="No-Break"><strong class="source-inline">RefreshToken.for_user(user)</strong></span><span class="No-Break"> does.</span></p>
			<p>And the final <a id="_idIndexMarker132"/>step – let’s register the viewset in the <span class="No-Break"><strong class="source-inline">routers.py</strong></span><span class="No-Break"> file:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/routers.py</p>
			<pre class="source-code">
 ...
# ##################################################################### #
# ################### AUTH                       ###################### #
# ##################################################################### #
router.register(r'auth/register', RegisterViewSet,
    basename='auth-register')
...</pre>
			<p>Great! Let’s test the new endpoint with Insomnia. In the collection of requests for this project, create a new <strong class="source-inline">POST</strong> request. The URL will be as <span class="No-Break">follows: </span><span class="No-Break"><strong class="source-inline">localhost:8000/api/auth/register/</strong></span><span class="No-Break">.</span></p>
			<p>As a body for the <a id="_idIndexMarker133"/>request, you can pass <span class="No-Break">the following:</span></p>
			<pre class="console">
{
    "username": "mouse21",
    "first_name": "Mickey",
    "last_name": "Mouse",
    "password": "12345678",
    "email": "mouse@yopmail.com"
}</pre>
			<p>With that, send the request. You should have a response similar to that shown in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.6</em> with a <strong class="source-inline">201 </strong><span class="No-Break"><strong class="source-inline">HTTP</strong></span><span class="No-Break"> status:</span></p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/Figure_2.7_B18221.jpg" alt="Figure 2.7 – Registering a user"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Registering a user</p>
			<p>Let’s see what <a id="_idIndexMarker134"/>happens if we try to create a user with the same email and username. Hit the <strong class="bold">Send</strong> button to send the same request again. You should receive a <span class="No-Break"><strong class="source-inline">400</strong></span><span class="No-Break"> error.</span></p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/Figure_2.8_B18221.jpg" alt="Figure 2.8 – Registering a user with the same email and username"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Registering a user with the same email and username</p>
			<p>Great. We are <a id="_idIndexMarker135"/>now sure that the endpoint behaves as we wish. The next step will be to add the login endpoint following the same process: writing the serializer and the viewset, and then registering <span class="No-Break">the route.</span></p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor049"/>Adding the login feature</h1>
			<p>The login feature will <a id="_idIndexMarker136"/>require the email or the username with the password. Using the <strong class="source-inline">djangorestframework-simplejwt</strong> package, which provides a serializer called <strong class="source-inline">TokenObtainPairSerializer</strong>, we’ll write a serializer to check for user authentication but also return a response containing access and refresh tokens. For this, we will rewrite the validate method from the <strong class="source-inline">TokenObtainPairSerializer</strong> class. Inside the <strong class="source-inline">core/auth/serializers</strong> directory, create a new file called <strong class="source-inline">login.py</strong> (this file will contain <strong class="source-inline">LoginSerializer</strong>, a subclass <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">TokenObtainPairSerializer</strong></span><span class="No-Break">):</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/serializers/login.py</p>
			<pre class="source-code">
from rest_framework_simplejwt.serializers import
  TokenObtainPairSerializer
from rest_framework_simplejwt.settings import api_settings
from django.contrib.auth.models import update_last_login
from core.user.serializers import UserSerializer
class LoginSerializer(TokenObtainPairSerializer):
   def validate(self, attrs):
       data = super().validate(attrs)
       refresh = self.get_token(self.user)
       data['user'] = UserSerializer(self.user).data
       data['refresh'] = str(refresh)
       data['access'] = str(refresh.access_token)
       if api_settings.UPDATE_LAST_LOGIN:
           update_last_login(None, self.user)
       return data</pre>
			<p>We are <a id="_idIndexMarker137"/>surcharging the <strong class="source-inline">validate</strong> method from the <strong class="source-inline">TokenObtainPairSerializer</strong> class to adapt it to our needs. That’s why <strong class="source-inline">super</strong> is helpful here. It’s a built-in method in Python that returns a temporary object that can be used to access the class methods of the <span class="No-Break">base class.</span></p>
			<p>Then, we use <strong class="source-inline">user</strong> to retrieve access and refresh tokens. Once the serializer is written, don’t forget to import it to the <span class="No-Break"><strong class="source-inline">__init__.py</strong></span><span class="No-Break"> file:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/serializers/__init__.py</p>
			<pre class="source-code">
from .register import RegisterSerializer
from .login import LoginSerializer</pre>
			<p>The next <a id="_idIndexMarker138"/>step is to add the viewset. We’ll call this viewset <strong class="source-inline">LoginViewset</strong>. As we are not directly interacting with a model here, we’ll just be using the <span class="No-Break"><strong class="source-inline">viewsets.ViewSet</strong></span><span class="No-Break"> class:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/viewsets/login.py</p>
			<pre class="source-code">
from rest_framework.response import Response
from rest_framework.viewsets import ViewSet
from rest_framework.permissions import AllowAny
from rest_framework import status
from rest_framework_simplejwt.exceptions import TokenError,
    InvalidToken
from core.auth.serializers import LoginSerializer
class LoginViewSet(ViewSet):
   serializer_class = LoginSerializer
   permission_classes = (AllowAny,)
   http_method_names = ['post']
   def create(self, request, *args, **kwargs):
       serializer =
           self.serializer_class(data=request.data)
       try:
           serializer.is_valid(raise_exception=True)
       except TokenError as e:
           raise InvalidToken(e.args[0])
       return Response(serializer.validated_data,
           status=status.HTTP_200_OK)</pre>
			<p>Add the viewset to the <strong class="source-inline">__init__.py</strong> file of the <span class="No-Break"><strong class="source-inline">viewsets</strong></span><span class="No-Break"> directory:</span></p>
			<pre class="source-code">
from .register import RegisterViewSet
from .login import LoginViewSet</pre>
			<p>We can now<a id="_idIndexMarker139"/> import it and register it in the <span class="No-Break"><strong class="source-inline">routers.py</strong></span><span class="No-Break"> file:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/routers.py</p>
			<pre class="source-code">
...
from core.auth.viewsets import RegisterViewSet,
    LoginViewSet
router = routers.SimpleRouter()
# ##################################################################### #
# ################### AUTH                       ###################### #
# ##################################################################### #
router.register(r'auth/register', RegisterViewSet,
    basename='auth-register')
router.register(r'auth/login', LoginViewSet,
    basename='auth-login')
...</pre>
			<p>The endpoint for login will be available at <strong class="source-inline">/auth/login/</strong>. Let’s try a request <span class="No-Break">with Insomnia.</span></p>
			<p>Here’s the <a id="_idIndexMarker140"/>body of the request <span class="No-Break">I’ll use:</span></p>
			<pre class="console">
{
    "password": "12345678",
    "email": "mouse@yopmail.com"
}</pre>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/Figure_2.9_B18221.jpg" alt="Figure 2.9 – Login with user credentials"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – Login with user credentials</p>
			<p>The login <a id="_idIndexMarker141"/>feature is ready and working like a charm – but we have a little bit of an issue. The access token expires in 5 minutes. Basically, to get a new access token, the user will have to log in again. Let’s see how we can use the refresh token to request a new access token without logging <span class="No-Break">in again.</span></p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor050"/>Refresh logic</h1>
			<p><strong class="source-inline">djangorestframework-simplejwt</strong> provides a <a id="_idIndexMarker142"/>refresh logic feature. As you’ve noticed, we’ve been generating refresh tokens and returning them as responses every time registration or login is completed. We’ll just inherit the class from <strong class="source-inline">TokenRefreshView</strong> and transform it into <span class="No-Break">a viewset.</span></p>
			<p>In <strong class="source-inline">auth/viewsets</strong>, add a new file <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">refresh.py</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/viewsets/refresh.py</p>
			<pre class="source-code">
from rest_framework.response import Response
from rest_framework_simplejwt.views import TokenRefreshView
from rest_framework.permissions import AllowAny
from rest_framework import status
from rest_framework import viewsets
from rest_framework_simplejwt.exceptions import TokenError,
    InvalidToken
class RefreshViewSet(viewsets.ViewSet, TokenRefreshView):
   permission_classes = (AllowAny,)
   http_method_names = ['post']
   def create(self, request, *args, **kwargs):
       serializer = self.get_serializer(data=request.data)
       try:
           serializer.is_valid(raise_exception=True)
       except TokenError as e:
           raise InvalidToken(e.args[0])
       return Response(serializer.validated_data,
           status=status.HTTP_200_OK)
Now add the class in the __init__.py file.
from .register import RegisterViewSet
from .login import LoginViewSet
from .refresh import RefreshViewSet</pre>
			<p>Now <a id="_idIndexMarker143"/>add the class in the <span class="No-Break"><strong class="source-inline">__init__.py</strong></span><span class="No-Break"> file.</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/viewsets/__init__.py</p>
			<pre class="source-code">
from .register import RegisterViewSet
from .login import LoginViewSet
from .refresh import RefreshViewSet</pre>
			<p>And now register it in the <span class="No-Break"><strong class="source-inline">routers.py</strong></span><span class="No-Break"> file:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/routers.py</p>
			<pre class="source-code">
from core.auth.viewsets import RegisterViewSet,
    LoginViewSet, RefreshViewSet
...
router.register(r'auth/refresh', RefreshViewSet,
    basename='auth-refresh')
...</pre>
			<p>Great – let’s test the new endpoint at <strong class="source-inline">/auth/refresh/</strong> to get a new token. It’ll be a <strong class="source-inline">POST</strong> request with the refresh token in the body of the request, and you will receive a new access token in <span class="No-Break">the response:</span></p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/Figure_2.10_B18221.jpg" alt="Figure 2.10 – Requesting for a new access token"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – Requesting for a new access token</p>
			<p>Great – we’ve<a id="_idIndexMarker144"/> just learned how to implement refresh token logic in <span class="No-Break">the application.</span></p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor051"/>Summary</h1>
			<p>In this chapter, we learned how to write an authentication system based on JWT for a Django application using DRF and <strong class="source-inline">djangorestframework-simplejwt</strong>. We also learned how to extend classes and rewrite <span class="No-Break">the functions.</span></p>
			<p>In the next chapter, we’ll add the <strong class="source-inline">posts</strong> feature. Our users will be able to create a post that can be viewed and<a id="_idTextAnchor052"/> liked by <span class="No-Break">other users.</span></p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor053"/>Questions</h1>
			<ol>
				<li>What is <span class="No-Break">a JWT?</span></li>
				<li>What is Django <span class="No-Break">Rest Framework?</span></li>
				<li>What is <span class="No-Break">a model?</span></li>
				<li>What is <span class="No-Break">a serializer?</span></li>
				<li>What is <span class="No-Break">a viewset?</span></li>
				<li>What is <span class="No-Break">a router?</span></li>
				<li>What is the usage of a <span class="No-Break">refresh token?</span></li>
			</ol>
		</div>
	</body></html>