<html><head></head><body>
		<div><h1 id="_idParaDest-34" class="chapter-number"><a id="_idTextAnchor036"/>2</h1>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor037"/>Authentication and Authorization using JWTs</h1>
			<p>In this chapter, we’ll dive deeper into Django and its architecture. We’ll be working with <strong class="bold">models</strong>, <strong class="bold">serializers</strong>, and <strong class="bold">viewsets</strong> to create an API that can receive HTTP requests as well as return a response. This will be done by building an authentication and authorization system using <strong class="bold">JSON Web Tokens</strong> (<strong class="bold">JWTs</strong>) to allow users to create an account, log in, and log out.</p>
			<p>By the end of this chapter, you’ll be able to create Django models, write Django serializers and validation, write viewsets to handle your API requests, expose your viewsets via the Django REST routers, create an authentication and authorization system based on JWTs, and understand what a JWT is and how it helps with authentication and permissions.</p>
			<p>We will be covering the following topics in this chapter:</p>
			<ul>
				<li>Understanding JWTs</li>
				<li>Organizing a project</li>
				<li>Creating a user model</li>
				<li>Writing the user registration feature</li>
				<li>Adding the login feature</li>
				<li>Refresh logic</li>
			</ul>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor038"/>Technical requirements</h1>
			<p>For this chapter, you’ll need to have Insomnia installed on your machine to make requests to the API we’ll be building.</p>
			<p>You can also find the code of this chapter at <a href="https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap2">https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap2</a>.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor039"/>Understanding JWTs</h1>
			<p>Before writing the authentication feature, let’s explain what a JWT is. As mentioned earlier, <strong class="bold">JWT</strong> stands for<a id="_idIndexMarker068"/> <strong class="bold">JSON Web Token</strong>. It’s one of the most used means of authentication in web applications but also helps with authorization and information exchanges.</p>
			<p>According to RFC 7519, a JWT is a JSON object defined as a safe way of transmitting information between two parties. Information transmitted by JWT is digitally signed so it can be verified and trusted.</p>
			<p>A JWT contains three parts—a header (<code>x</code>), a payload (<code>y</code>), and a signature (<code>z</code>)—that are separated by a dot:</p>
			<pre class="source-code">
xxxxx.yyyyy.zzzzz</pre>
			<ul>
				<li><strong class="bold">Header</strong></li>
			</ul>
			<p>The header<a id="_idIndexMarker069"/> of the JWT consists of two parts: the type of token and the signing algorithm being used. The signing algorithm is used to ensure that the message is authentic and not altered.</p>
			<p>Here’s an example of a header:</p>
			<pre class="source-code">
{
    "alg": "RSA",
    "typ": "JWT"
}</pre>
			<p> Signing algorithms<a id="_idIndexMarker070"/> are algorithms used to sign tokens issued for your application or API.</p>
			<ul>
				<li><strong class="bold">Payload</strong></li>
			</ul>
			<p>The payload<a id="_idIndexMarker071"/> is the second part that contains the claims. According to the official JWT documentation (<a href="https://jwt.io/introduction">https://jwt.io/introduction</a>), claims<a id="_idIndexMarker072"/> are statements about an entity (typically, the user) and additional data.</p>
			<p>Here’s an example of a payload:</p>
			<pre class="source-code">
{
  "id": "d1397699-f37b-4de0-8e00-948fa8e9bf2c",
  "name": "John Doe",
  "admin": true
}</pre>
			<p>In the preceding example, we have three claims: the ID of the user, the name of the user, and also a Boolean for the type of user.</p>
			<ul>
				<li><strong class="bold">Signature</strong></li>
			</ul>
			<p>The signature<a id="_idIndexMarker073"/> of a JWT is the encoded header, the encoded payload plus a secret, and an algorithm specified in the header, all of them combined and signed.</p>
			<p>For example, it’s possible to create a signature the following way using the RSA algorithm:</p>
			<pre class="source-code">
RSA(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)</pre>
			<p>The role of the signature is to track whether information has been changed.</p>
			<p>But how are JWTs actually used in authentication?</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor040"/>Understanding how JWTs are used in authentication</h2>
			<p>Each time a user <a id="_idIndexMarker074"/>successfully logs in, a JWT is created and returned. The JWT will be represented as credentials used to access protected resources. The fact that it’s possible to store data in a JWT makes it vulnerable. That’s why you should specify an expiration time when creating a JWT.</p>
			<p>In this book, we’ll be using JWTs in two ways. To make it simple, we’ll have two types of tokens:</p>
			<ul>
				<li><strong class="bold">An access token</strong>: Used<a id="_idIndexMarker075"/> to access resources and handle authorization</li>
				<li><strong class="bold">A refresh token</strong>: Used to<a id="_idIndexMarker076"/> retrieve a new access token</li>
			</ul>
			<p>But why use two tokens? As we stated earlier, a JWT is generated when users log in. Moreover, JWTs used to access resources should have a short lifespan. This means that after the JWT has expired, the user has to log in again and again – and no user wants the login page to appear every 5 minutes.</p>
			<p>That’s where a refresh token is useful. It’ll contain the essential information needed to verify the user and generate a new access token.</p>
			<p>Now that we understand the purpose of JWTs, let’s learn more about models in Django while creating the user model.</p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor041"/>Organizing a project</h1>
			<p>When working with <a id="_idIndexMarker077"/>Django, you’ll have to create many apps to handle different parts of a project. For example, you can have a different application for authentication, and another for payments or articles. To have a clean and well-organized project, we can create a Django application that will contain all the apps we will create for this book.</p>
			<p>At the root of the project, run the following command:</p>
			<pre class="console">
django-admin startapp core</pre>
			<p>A new application will be created. Remove all the files in this app except for the <code>apps.py</code> file and the <code>__init__.py</code> file. Inside <code>apps.py</code>, add the following line:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/apps.py</p>
			<pre class="source-code">
from django.apps import AppConfig
class CoreConfig(AppConfig):
   default_auto_field = 'django.db.models.BigAutoField'
   name = 'core'
   label = 'core'</pre>
			<p>Register the apps in the <code>setting.py</code> file of the project:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CoreRoot/settings.py</p>
			<pre class="source-code">
# Application definition
INSTALLED_APPS = [
   'django.contrib.admin',
   'django.contrib.auth',
   'django.contrib.contenttypes',
   'django.contrib.sessions',
   'django.contrib.messages',
   'django.contrib.staticfiles',
   'core'
]</pre>
			<p><code>INSTALLED_APPS</code> is a <a id="_idIndexMarker078"/>Django settings configuration, which is a list of Django apps within a project.</p>
			<p>We can now create the user application with confidence and write our first model.</p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor042"/>Creating a user model</h1>
			<p>Unless you are <a id="_idIndexMarker079"/>creating a simple web application, there is little chance of avoiding the necessity to interact with a database, particularly having an account feature that requires users to register or log in to use your web application.</p>
			<p>Before talking about the account feature, let’s learn more about Django models and what problems they resolve.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor043"/>What are Django models?</h2>
			<p>If you need to connect<a id="_idIndexMarker080"/> your application to a database, particularly <strong class="bold">SQL</strong>, the<a id="_idIndexMarker081"/> first assumption that comes to mind is that you’ll have to work directly with the database via SQL queries – and if that’s true, it can be fun, but it’s not the same for everyone; some developers may find SQL complex. You are no longer focusing on writing the application logic in your own language. Some tasks can become repetitive, such as writing SQL scripts to create tables, getting entries from the database, or inserting or updating data.</p>
			<p>As you’ll see, the more the code base evolves, the more difficult it becomes to maintain both simple and complex SQL queries in your code base. This is more of an issue if you are working with multiple databases, which will require you to learn many SQL languages. For example, there are a lot of SQL databases and each one implements SQL in its own way.</p>
			<p>Fortunately, in Django, this messy issue is solved by using a Django model to access the database. This doesn’t mean that you don’t have to write SQL queries: it’s just that you don’t have to use SQL at all unless you want to.</p>
			<p>Django models provide <strong class="bold">object-relational mapping</strong> (<strong class="bold">ORM</strong>) to the underlying database. ORM is a tool that <a id="_idIndexMarker082"/>simplifies database programming by providing a simple mapping between the object and the database. Then, you don’t necessarily need to know the database structure or write complex SQL queries to manipulate or retrieve data from the database.</p>
			<p>For example, creating a<a id="_idIndexMarker083"/> table in SQL will require writing a long <a id="_idIndexMarker084"/>SQL query. Doing this in Python will just require writing a class inheriting from the <code>django.db</code> package (<em class="italic">Figure 2</em><em class="italic">.1</em>):</p>
			<div><div><img src="img/Figure_2.1_B18221.jpg" alt="Figure 2.1 – Comparison between the Django ORM and SQL queries"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Comparison between the Django ORM and SQL queries</p>
			<p>In the preceding figure, you<a id="_idIndexMarker085"/> can see the SQL statement, which requires <a id="_idIndexMarker086"/>some knowledge of the syntax, as well as the fields and the options. The second code from the Django ORM does exactly the same thing but in a more Pythonic and less verbose manner.</p>
			<p>Writing models with Django comes with several advantages:</p>
			<ul>
				<li><strong class="bold">Simplicity</strong>: Writing queries in <a id="_idIndexMarker087"/>Python may not be as clear as writing in SQL, but it’s less error-prone and more efficient, as you don’t have to control which type of database you are working with before trying to understand the code.</li>
				<li><strong class="bold">Consistency</strong>: SQL is inconsistent across different databases. Working with Django models creates an abstraction and helps you focus on the most important tasks.</li>
				<li><strong class="bold">Tracking</strong>: It’s even easier to track database design changes working with Django models. It’s done by reading migration files written in Python. We’ll discuss this more in<a id="_idIndexMarker088"/> the next chapter.</li>
			</ul>
			<p>Notice that you also have access to model managers. Django Manager<a id="_idIndexMarker089"/> is a class that behaves as an interface through which Django models interact with databases. Every Django model, by default, inherits the <code>models.Manager</code> class that comes with the necessary methods to<a id="_idIndexMarker090"/> make <strong class="bold">Create, Read, Update and Delete</strong> (<strong class="bold">CRUD</strong>) operations on the table in the database.</p>
			<p>Now that we have a better understanding of Django models, let’s create the first model in this project, the <code>User</code> model. Working with our first model, we’ll also learn how to use the basic methods of the Django ORM to perform CRUD operations.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor044"/>Writing the User model</h2>
			<p>In the previous<a id="_idIndexMarker091"/> section, we saw how a model is represented as a class and how this can basically be created as a table in the database.</p>
			<p>Talking about the <code>User</code> model, Django comes with a pre-built-in <code>User</code> model class that you can use for basic authentication or a session. It actually provides an authentication feature you can use to quickly add authentication and authorization to your projects.</p>
			<p>While it’s great for most use cases, it has its limitations. For example, in this book, we are building a social media web application. The user in this application will have some bio or even an avatar. Why not also have a<a id="_idIndexMarker092"/> phone number for <strong class="bold">two-factor </strong><strong class="bold">authentication</strong> (<strong class="bold">2FA</strong>)?</p>
			<p>Actually, the <code>User</code> model of Django doesn’t come with these fields. This means we’ll need to extend it and have our own user model. This also means that we will have to add custom methods to the manager for creating a user and a superuser. This will speed up the coding process. In Django, a superuser<a id="_idIndexMarker093"/> is a user with administrator permission.</p>
			<p>Before creating the model, we actually need an application, and to register it. A Django application is a submodule of a Django project. It’s a Python package structured to work in a Django project and share Django conventions such as <a id="_idIndexMarker094"/>containing files or submodules such as <code>models</code>, <code>tests</code>, <code>urls</code>, and <code>views</code>.</p>
			<h3>Creating the user application</h3>
			<p>To start a <a id="_idIndexMarker095"/>new application in this project, run the following command:</p>
			<pre class="console">
cd core &amp;&amp; django-admin startapp user</pre>
			<p>This will create a new package (directory) containing new files. Here’s the structure of the directory:</p>
			<pre class="source-code">
├── admin.py
├── apps.py
├── __init__.py
├── migrations
│   └── __init__.py
├── models.py
├── tests.py
└── views.py</pre>
			<p>We can now confidently start writing the <code>User</code> model. Here is the structure of the <code>User</code> table we want to have in the database:</p>
			<div><div><img src="img/Figure_2.2_B18221.jpg" alt="Figure 2.2 – User table structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – User table structure</p>
			<p>And here’s the <a id="_idIndexMarker096"/>code concerning the <code>User</code> table structure:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/models.py</p>
			<pre class="source-code">
import uuid
from django.contrib.auth.models import AbstractBaseUser,
    BaseUserManager, PermissionsMixin
from django.core.exceptions import ObjectDoesNotExist
from django.db import models
from django.http import Http404
class User(AbstractBaseUser, PermissionsMixin):
   public_id = models.UUIDField(db_index=True, unique=True,
       default=uuid.uuid4, editable=False)
   username = models.CharField(db_index=True,
       max_length=255, unique=True)
   first_name = models.CharField(max_length=255)
   last_name = models.CharField(max_length=255)
   email = models.EmailField(db_index=True, unique=True)
   is_active = models.BooleanField(default=True)
   is_superuser = models.BooleanField(default=False)
   created = models.DateTimeField(auto_now=True)
   updated = models.DateTimeField(auto_now_add=True)
   USERNAME_FIELD = 'email'
   REQUIRED_FIELDS = ['username']
   objects = UserManager()
   def __str__(self):
       return f"{self.email}"
   @property
   def name(self):
       return f"{self.first_name} {self.last_name}"</pre>
			<p>The <code>models</code> module from Django provides some field utilities that can be used to write fields and add some rules. For example, <code>CharField</code> represents the type of field to create in the <code>User</code> table, similar to <code>BooleanField</code>. <code>EmailField</code> is also <code>CharField</code> but rewritten to validate the email that is passed as a value to this field.</p>
			<p>We also set the <code>EMAIL_FIELD</code> as the email, and <code>USERNAME_FIELD</code> as the username. This will help us have two fields for login. The username can be the actual username of a user or just the email address used for registration.</p>
			<p>We also have methods <a id="_idIndexMarker097"/>such as <code>name</code>, which is basically a model property. Then, it can be accessed anywhere on a <code>User</code> object, such as <code>user.name</code>. We are also rewriting the <code>__str__</code> method to return a string that can help us quickly identify a <code>User</code> object.</p>
			<h3>Creating the user and superuser</h3>
			<p>Next, let’s write <code>UserManager</code> so we can<a id="_idIndexMarker098"/> have methods to <a id="_idIndexMarker099"/>create a user and a superuser:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/models.py</p>
			<pre class="source-code">
class UserManager(BaseUserManager):
   def get_object_by_public_id(self, public_id):
       try:
           instance = self.get(public_id=public_id)
           return instance
       except (ObjectDoesNotExist, ValueError, TypeError):
           return Http404
   def create_user(self, username, email, password=None,
        **kwargs):
       """Create and return a `User` with an email, phone
           number, username and password."""
       if username is None:
           raise TypeError('Users must have a username.')
       if email is None:
           raise TypeError('Users must have an email.')
       if password is None:
           raise TypeError('User must have an email.')
       user = self.model(username=username,
           email=self.normalize_email(email), **kwargs)
       user.set_password(password)
       user.save(using=self._db)
       return user
   def create_superuser(self, username, email, password,
       **kwargs):
       """
       Create and return a `User` with superuser (admin)
           permissions.
       """
       if password is None:
           raise TypeError('Superusers must have a
           password.')
       if email is None:
           raise TypeError('Superusers must have an
               email.')
       if username is None:
           raise TypeError('Superusers must have an
           username.')
       user = self.create_user(username, email, password,
           **kwargs)
       user.is_superuser = True
       user.is_staff = True
       user.save(using=self._db)
       return user</pre>
			<p>For the <code>create_user</code> method, we are basically making sure that fields such as <code>password</code>, <code>email</code>, <code>username</code>, <code>first_name</code>, and <code>last_name</code> are not <code>None</code>. If everything is good, we can confidently call the model, set a password, and save the user in the table.</p>
			<p>This is done using the <code>save()</code> method.</p>
			<p><code>create_superuser</code> also behaves in accordance with the <code>create_user</code> method – and it’s quite normal because, after all, a superuser is just a user with admin privileges, and also fields such as <code>is_superuser</code> and <code>is_staff</code> set to <code>True</code>. Once it’s done, we save the new <code>User</code> object in the database and return the user.</p>
			<p>See the <code>save</code> method as a<a id="_idIndexMarker100"/> way to commit changes made to the <code>User</code> object to<a id="_idIndexMarker101"/> the database.</p>
			<p>The model is written and now we need to run migrations to create the table in the database.</p>
			<h3>Running migrations and testing the model</h3>
			<p>Before <a id="_idIndexMarker102"/>running the migrations, we need to register the user application in <code>INSTALLED_APPS</code> in <code>CoreRoot/settings.py</code>.</p>
			<p>First, let’s rewrite the <code>apps.py</code> file of the user. It contains the app configs that Django will use to locate the application. Let’s also add a label for the application:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/apps.py</p>
			<pre class="source-code">
from django.apps import AppConfig
class UserConfig(AppConfig):
   default_auto_field = 'django.db.models.BigAutoField'
   name = 'core.user'
   label = 'core_user'
Let's register the application now:
   'core',
   'core.user'
]</pre>
			<p>Let’s register the application now in the <code>INSTALLED_APPS</code> setting:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CoreRoot/settings.py</p>
			<pre class="source-code">
...
   'core',
   'core.user'
]</pre>
			<p>We also need to <a id="_idIndexMarker103"/>tell Django to use this <code>User</code> model for the authentication user model. In the <code>settings.py</code> file, add the following line:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CoreRoot/settings.py</p>
			<pre class="source-code">
AUTH_USER_MODEL = 'core_user.User'</pre>
			<p>Great – we can now create the first migration for the user app:</p>
			<pre class="console">
python manage.py makemigrations</pre>
			<p>You’ll have a similar output:</p>
			<pre class="console">
Migrations for 'core_user':
  core/user/migrations/0001_initial.py
    - Create model User</pre>
			<p>Let’s migrate this modification to the database:</p>
			<pre class="console">
python manage.py migrate</pre>
			<p>The table is created in the database. Let’s use the Django shell to play with the newly created model a little bit:</p>
			<pre class="console">
python manage.py shell</pre>
			<p>Let’s <a id="_idIndexMarker104"/>import the model and add a dict containing the data needed to<a id="_idIndexMarker105"/> create a user:</p>
			<pre class="console">
Python 3.10.1 (main, Dec 21 2021, 17:46:38) [GCC 9.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
(InteractiveConsole)
&gt;&gt;&gt; from core.user.models import User
&gt;&gt;&gt; data_user = {
... "email": "testuser@yopmail.com",
... "username": "john-doe",
... "password": "12345",
... "first_name": "John",
... "last_name": "Doe"
... }
&gt;&gt;&gt; user =  User.objects.create_user(**data_user)
The user is created in the database. Let's access some properties of the user object.
&gt;&gt;&gt; user.name
'John Doe'
&gt;&gt;&gt; user.email
'testuser@yopmail.com'
&gt;&gt;&gt; user.password
'pbkdf2_sha256$320000$NxM7JZ0cQ0OtDzCVusgvV7$fM1WZp7QhHC3QEajnb Bjo5rBPKO+Q8ONhDFkCV/gwcI='</pre>
			<p>Great – we’ve just <a id="_idIndexMarker106"/>written the model and created the first user. However, a web <a id="_idIndexMarker107"/>browser won’t directly read the user data from our database – and worse, we are working with a Python native object, and a browser or a client reaching our server to make requests mostly supports JSON or XML. One idea would be to use the <code>json</code> library, but we are dealing with a complex data structure; complex data structures can be easily handled with serializers.</p>
			<p>Let’s write serializers in the next section.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor045"/>Writing UserSerializer</h2>
			<p>A serializer allows us to convert complex Django complex data structures such as <code>QuerySet</code> or model instances into Python native objects that can be easily converted to JSON or XML format. However, a serializer also serializes JSON or XML to native Python. <code>serializers</code> package you<a id="_idIndexMarker109"/> can use to write serializers and also validations when API calls are made to an endpoint using this serializer. Let’s install the DRF package and make some configurations first:</p>
			<pre class="console">
pip install djangorestframework django-filter</pre>
			<p>Don’t forget to add the following to the <code>requirements.txt</code> file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">requirements.txt</p>
			<pre class="source-code">
Django==4.0.1
psycopg2-binary==2.9.3
djangorestframework==3.13.1
django-filter==21.1</pre>
			<p>We are also adding <code>django-filter</code> for data filtering support. Let’s add <code>rest_framework</code> to the <code>INSTALLED_APPS</code> setting:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CoreRoot/settings.py</p>
			<pre class="source-code">
INSTALLED_APPS = [
    ...
    'rest_framework',
]</pre>
			<p>In the <code>core/user</code> directory, create <a id="_idIndexMarker110"/>a file called <code>serializers.py</code>. This file will contain the <code>UserSerializer</code> class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/serializers.py</p>
			<pre class="source-code">
from rest_framework import serializers
from core.user.models import User
class UserSerializer(serializers.ModelSerializer):
   id = serializers.UUIDField(source='public_id',
       read_only=True, format='hex')
   created = serializers.DateTimeField(read_only=True)
   updated = serializers.DateTimeField(read_only=True)
   class Meta:
       model = User
       fields = ['id', 'username', 'first_name',
           'last_name', 'bio', 'avatar', 'email',
           'is_active', 'created', 'updated']
       read_only_field = ['is_active']</pre>
			<p>The <code>UserSerializer</code> class inherits from the <code>serializers.ModelSerialzer</code> class. It’s a class inheriting from the <code>serializers.Serializer</code> class but has deep integrations for supporting a model. It’ll automatically match the field of the model to have the correct validations for each one.</p>
			<p>For example, we’ve stated that the email is unique. Then, every time someone registers and enters an email address that already exists in the database, they will receive an error message concerning this.</p>
			<p>The <code>fields</code> attribute contains all the fields that can be read or written. Then, we also have the <code>read_only</code> fields. These fields are only readable. This means that they can’t be modified and it’s definitely better like that. Why give the external user the possibility to modify<a id="_idIndexMarker111"/> the <code>created</code>, <code>updated</code>, or <code>id</code> fields?</p>
			<p>Now that <code>UserSerializer</code> is available, we can now write <code>viewset</code>.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor046"/>Writing UserViewset</h2>
			<p>As we know, Django<a id="_idIndexMarker112"/> at its core is based on the <strong class="bold">Model-View-Template</strong> (<strong class="bold">MVT</strong>) architecture. The model<a id="_idIndexMarker113"/> communicates with the views (or controllers) and the template displays responses or redirects requests to the views.</p>
			<p>However, when Django is coupled with DRF, the model can be directly connected to the view. However, as good practice, use a serializer between a model and a viewset. This really helps with validation and also some important checks.</p>
			<p>So, what is a viewset then? DRF provides a class named <code>APIView</code> from which a lot of classes from DRF inherit to perform CRUD operations. Therefore, a viewset is simply a class-based view that can handle all the basic HTTP requests—<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, and <code>PATCH</code>—without hardcoding any CRUD logic here.</p>
			<p>For the <code>viewset</code> user, we are only allowing the <code>PATCH</code> and <code>GET</code> methods. Here’s what the endpoints will look like:</p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Method</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">URL</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Result</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>GET</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>/</code><code>api/user/</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Lists all the users</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>GET</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>/</code><code>api/user/user_pk/</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Retrieves a specific user</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>PATCH</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>/</code><code>api/user/user_pk/</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Modifies a user</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.1 – Endpoints</p>
			<p>Let’s write the <a id="_idIndexMarker114"/>viewset. Inside the <code>user</code> directory, rename the <code>view</code> file <code>viewsets.py</code> and add the following content:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/viewsets.py</p>
			<pre class="source-code">
from rest_framework.permissions import AllowAny
from rest_framework import viewsets
from core.user.serializers import UserSerializer
from core.user.models import User
class UserViewSet(viewsets.ModelViewSet):
   http_method_names = ('patch', 'get')
   permission_classes = (AllowAny,)
   serializer_class = UserSerializer
   def get_queryset(self):
       if self.request.user.is_superuser:
           return User.objects.all()
       return User.objects.exclude(is_superuser=True)
   def get_object(self):
    obj =
    User.objects.get_object_by_public_id(self.kwargs['pk'])
       self.check_object_permissions(self.request, obj)
       return obj</pre>
			<p>The only methods <a id="_idIndexMarker115"/>allowed here are <code>GET</code> and <code>PUT</code>. We also set <code>serializer_class</code> and <code>permission_classes</code> to <code>AllowAny</code>, which means that anybody can access these viewsets. We also rewrite two methods:</p>
			<ul>
				<li><code>get_queryset</code>: This method is used by the viewset to get a list of all the users. This method will be called when <code>/user/</code> is hit with a <code>GET</code> request.</li>
				<li><code>get_object</code>: This method is used by the viewset to get one user. This method is called when a <code>GET</code> or <code>PUT</code> request is made on the <code>/user/id/</code> endpoint, with <code>id</code> representing the ID of the user.</li>
			</ul>
			<p>There we <a id="_idIndexMarker116"/>have the <code>User</code> viewset – but there is no endpoint yet to make it work. Well, let’s add a router now.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor047"/>Adding a router</h2>
			<p>Routers allow<a id="_idIndexMarker117"/> you to quickly declare all of the common routes for a given controller; the next code snippet shows a viewset to which we will be adding a router.</p>
			<p>At the root of the <a id="_idIndexMarker118"/>apps project (<code>core</code>), create a file named <code>routers.py</code>.</p>
			<p>And let’s add the code:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/routers.py</p>
			<pre class="source-code">
from rest_framework import routers
from core.user.viewsets import UserViewSet
router = routers.SimpleRouter()
# ##################################################################### #
# ################### USER                       ###################### #
# ##################################################################### #
router.register(r'user', UserViewSet, basename='user')
urlpatterns = [
   *router.urls,
]</pre>
			<p>To register a route for a viewset, the <code>register()</code> method needs two arguments:</p>
			<ul>
				<li><strong class="bold">The prefix</strong>: Representing the name of the endpoint, basically</li>
				<li><strong class="bold">The viewset</strong>: Only representing a valid viewset class</li>
			</ul>
			<p>The <code>basename</code> argument is optional but it’s a good practice to use one, as it helps for readability and also helps Django for URL registry purposes.</p>
			<p>The router is now added; we can make some requests to the API using Insomnia.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Insomnia<a id="_idIndexMarker119"/> is a REST client tool used to make requests to RESTful API. With Insomnia, you can manage and create your requests elegantly. It offers support for cookie management, environment variables, code generation, and authentication.</p>
			<p>Before doing <a id="_idIndexMarker120"/>that, make sure to have the server running:</p>
			<pre class="console">
python manage.py runserver</pre>
			<p>Let’s make a request to <code>http://127.0.0.1:8000/api/user/</code>, a <code>GET</code> request. Look at the following screenshot and make sure to have the same URL – or you can replace <code>127.0.0.1</code> with <code>localhost --</code>, next to the <strong class="bold">Send</strong> button.</p>
			<div><div><img src="img/Figure_2.3_B18221.jpg" alt="Figure 2.3 – Listing all users"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Listing all users</p>
			<p>As you can see, we <a id="_idIndexMarker121"/>have a list of users created. Let’s also make a <code>GET</code> request to retrieve the first user using this URL: <code>/api/user/&lt;id&gt;/</code>.</p>
			<div><div><img src="img/Figure_2.4_B18221.jpg" alt="Figure 2.4 – Retrieving a user"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Retrieving a user</p>
			<p>We have now a<a id="_idIndexMarker122"/> <code>User</code> object. This endpoint also allows <code>PATCH</code> requests. Let’s set the <code>last_name</code> value for this user to <code>Hey</code>. Change the type of request to <code>PATCH</code> and add a JSON body.</p>
			<div><div><img src="img/Figure_2.5_B18221.jpg" alt="Figure 2.5 – Modifying a user without permissions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Modifying a user without permissions</p>
			<p>Although it’s <a id="_idIndexMarker123"/>working, it’s actually a very bad scenario. We can’t have users modify other user names or data. A solution is to change the permission on the <code>permission_classes</code> attribute in the <code>UserViewSet</code> class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/user/viewsets.py</p>
			<pre class="source-code">
from rest_framework.permissions import IsAuthenticated
...
class UserViewSet(viewsets.ModelViewSet):
   http_method_names = ('patch', 'get')
   permission_classes = (IsAuthenticated,)
   serializer_class = UserSerializer
...</pre>
			<p>Let’s try <a id="_idIndexMarker124"/>the <code>PATCH</code> request again.</p>
			<div><div><img src="img/Figure_2.6_B18221.jpg" alt="Figure 2.6 – Modifying a user without permissions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Modifying a user without permissions</p>
			<p>We normally have a <code>401</code> status, an indication of an authentication issue. Basically, it means that an authentication header should be provided. They are more permissions to add <a id="_idIndexMarker125"/>concerning interactions with users, but let’s discuss this in later chapters.</p>
			<p>Great. Now that we are done with the user application, we can confidently move on to adding a login and registration feature to the project.</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor048"/>Writing the user registration feature</h1>
			<p>Before accessing <a id="_idIndexMarker126"/>protected data, the user needs to be authenticated. This comes with the assumption that there is a registration system to create an account and credentials.</p>
			<p>To make things simpler, if the registration of a user is successful, we will provide credentials, here JWTs, so the user won’t have to log in again to start a session – a win for user experience.</p>
			<p>First, let’s install a package that will handle JWT authentication for us. The <code>djangorestframework-simplejwt</code> package is a JWT authentication plugin for DRF:</p>
			<pre class="console">
pip install djangorestframework-simplejwt</pre>
			<p>The package covers the <a id="_idIndexMarker127"/>most common use case of JWT, and in this case here, it facilitates the creation and management of access tokens, as well as refreshing tokens. Before working with this package, there are some configurations needed in the <code>settings.py</code> file. We need to register the app in <code>INSTALLED_APPS</code> and specify <code>DEFAULT_AUTHENTICATION_CLASSES</code> in the <code>REST_FRAMEWORK</code> dict:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CoreRoot/settings.py</p>
			<pre class="source-code">
   …
   # external packages apps
   'rest_framework',
   'rest_framework_simplejwt',
   'core',
   'core.user'
]
...
REST_FRAMEWORK = {
   'DEFAULT_AUTHENTICATION_CLASSES': (
       'rest_framework_simplejwt.authentication
           .JWTAuthentication',
   ),
   'DEFAULT_FILTER_BACKENDS':
     ['django_filters.rest_framework.DjangoFilterBackend'],
}</pre>
			<p>First, we need to write a registration serializer, but before that, let’s create a new application called <code>auth</code> in the <code>core</code> app:</p>
			<pre class="console">
cd core &amp;&amp; django-admin startapp auth</pre>
			<p>It’ll contain all the logic concerning logging in, registration, logging out, and a lot more.</p>
			<p>As we did earlier<a id="_idIndexMarker128"/> for the user application, let’s rewrite the <code>apps.py</code> file and register the application in the <code>INSTALLED_APPS</code> settings:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/apps.py</p>
			<pre class="source-code">
from django.apps import AppConfig
class AuthConfig(AppConfig):
   default_auto_field = 'django.db.models.BigAutoField'
   name = 'core.auth'
   label = 'core_auth'
And adding the new application to <code>INSTALLED_APPS</code>:
...
'core',
   'core.user',
   'core.auth'
]
...</pre>
			<p>Remove the <code>admin.py</code> and <code>models.py</code> files from the <code>auth</code> directory, as we won’t be working <a id="_idIndexMarker129"/>with them. For registration and login, we’ll have many serializers and viewsets, so let’s organize the code accordingly. Create a Python package called <code>serializers</code> and another one called <code>viewsets</code>. Make sure that these new directories have an <code>__init__.py</code> file. Here’s how your <code>auth</code> app tree should look:</p>
			<pre class="source-code">
├── apps.py
├── __init__.py
├── migrations
│   ├── __init__.py
├── serializers
│   └── __init__.py
├── tests.py
├── viewsets
│   └── __init__.py
└── views.py</pre>
			<p>Inside the <code>serializers</code> directory, create a file called <code>register.py</code>. It’ll contain the code for <code>RegisterSerializer</code>, which is the name of the registration serializer class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/serializers/register.py</p>
			<pre class="source-code">
from rest_framework import serializers
from core.user.serializers import UserSerializer
from core.user.models import User
class RegisterSerializer(UserSerializer):
   """
   Registration serializer for requests and user creation
   """
   # Making sure the password is at least 8 characters
       long, and no longer than 128 and can't be read
   # by the user
   password = serializers.CharField(max_length=128,
       min_length=8, write_only=True, required=True)
   class Meta:
       model = User
       # List of all the fields that can be included in a
           request or a response
       fields = ['id', 'bio', 'avatar', 'email',
           'username', 'first_name', 'last_name',
           'password']
   def create(self, validated_data):
       # Use the `create_user` method we wrote earlier for
           the UserManager to create a new user.
       return User.objects.create_user(**validated_data)</pre>
			<p>As you can <a id="_idIndexMarker130"/>see, <code>RegisterSerializer</code> is a subclass of <code>UserSerializer</code>. This is really helpful, as we don’t need to rewrite fields again.</p>
			<p>Here, we don’t need to revalidate fields such as <code>email</code> or <code>password</code>. As we declared these fields with some conditions, Django will automatically handle their validation.</p>
			<p>Next, we can add the <a id="_idIndexMarker131"/>viewset and register it in the <code>register.py</code> file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/viewsets/register.py</p>
			<pre class="source-code">
from rest_framework.response import Response
from rest_framework.viewsets import ViewSet
from rest_framework.permissions import AllowAny
from rest_framework import status
from rest_framework_simplejwt.tokens import RefreshToken
from core.auth.serializers import RegisterSerializer
class RegisterViewSet(ViewSet):
   serializer_class = RegisterSerializer
   permission_classes = (AllowAny,)
   http_method_names = ['post']
   def create(self, request, *args, **kwargs):
       serializer =
           self.serializer_class(data=request.data)
       serializer.is_valid(raise_exception=True)
       user = serializer.save()
       refresh = RefreshToken.for_user(user)
       res = {
           "refresh": str(refresh),
           "access": str(refresh.access_token),
       }
       return Response({
           "user": serializer.data,
           "refresh": res["refresh"],
           "token": res["access"]
       }, status=status.HTTP_201_CREATED)</pre>
			<p>Nothing really new here – we are using attributes from the <code>ViewSet</code> class. We are also rewriting the <code>create</code> method to add access and refresh tokens in the body of the response. The <code>djangorestframework-simplejwt</code> package provides utilities we can use to directly generate tokens. That’s what <code>RefreshToken.for_user(user)</code> does.</p>
			<p>And the final <a id="_idIndexMarker132"/>step – let’s register the viewset in the <code>routers.py</code> file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/routers.py</p>
			<pre class="source-code">
 ...
# ##################################################################### #
# ################### AUTH                       ###################### #
# ##################################################################### #
router.register(r'auth/register', RegisterViewSet,
    basename='auth-register')
...</pre>
			<p>Great! Let’s test the new endpoint with Insomnia. In the collection of requests for this project, create a new <code>POST</code> request. The URL will be as follows: <code>localhost:8000/api/auth/register/</code>.</p>
			<p>As a body for the <a id="_idIndexMarker133"/>request, you can pass the following:</p>
			<pre class="console">
{
    "username": "mouse21",
    "first_name": "Mickey",
    "last_name": "Mouse",
    "password": "12345678",
    "email": "mouse@yopmail.com"
}</pre>
			<p>With that, send the request. You should have a response similar to that shown in <em class="italic">Figure 2</em><em class="italic">.6</em> with a <code>201 </code><code>HTTP</code> status:</p>
			<div><div><img src="img/Figure_2.7_B18221.jpg" alt="Figure 2.7 – Registering a user"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Registering a user</p>
			<p>Let’s see what <a id="_idIndexMarker134"/>happens if we try to create a user with the same email and username. Hit the <code>400</code> error.</p>
			<div><div><img src="img/Figure_2.8_B18221.jpg" alt="Figure 2.8 – Registering a user with the same email and username"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Registering a user with the same email and username</p>
			<p>Great. We are <a id="_idIndexMarker135"/>now sure that the endpoint behaves as we wish. The next step will be to add the login endpoint following the same process: writing the serializer and the viewset, and then registering the route.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor049"/>Adding the login feature</h1>
			<p>The login feature will <a id="_idIndexMarker136"/>require the email or the username with the password. Using the <code>djangorestframework-simplejwt</code> package, which provides a serializer called <code>TokenObtainPairSerializer</code>, we’ll write a serializer to check for user authentication but also return a response containing access and refresh tokens. For this, we will rewrite the validate method from the <code>TokenObtainPairSerializer</code> class. Inside the <code>core/auth/serializers</code> directory, create a new file called <code>login.py</code> (this file will contain <code>LoginSerializer</code>, a subclass of <code>TokenObtainPairSerializer</code>):</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/serializers/login.py</p>
			<pre class="source-code">
from rest_framework_simplejwt.serializers import
  TokenObtainPairSerializer
from rest_framework_simplejwt.settings import api_settings
from django.contrib.auth.models import update_last_login
from core.user.serializers import UserSerializer
class LoginSerializer(TokenObtainPairSerializer):
   def validate(self, attrs):
       data = super().validate(attrs)
       refresh = self.get_token(self.user)
       data['user'] = UserSerializer(self.user).data
       data['refresh'] = str(refresh)
       data['access'] = str(refresh.access_token)
       if api_settings.UPDATE_LAST_LOGIN:
           update_last_login(None, self.user)
       return data</pre>
			<p>We are <a id="_idIndexMarker137"/>surcharging the <code>validate</code> method from the <code>TokenObtainPairSerializer</code> class to adapt it to our needs. That’s why <code>super</code> is helpful here. It’s a built-in method in Python that returns a temporary object that can be used to access the class methods of the base class.</p>
			<p>Then, we use <code>user</code> to retrieve access and refresh tokens. Once the serializer is written, don’t forget to import it to the <code>__init__.py</code> file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/serializers/__init__.py</p>
			<pre class="source-code">
from .register import RegisterSerializer
from .login import LoginSerializer</pre>
			<p>The next <a id="_idIndexMarker138"/>step is to add the viewset. We’ll call this viewset <code>LoginViewset</code>. As we are not directly interacting with a model here, we’ll just be using the <code>viewsets.ViewSet</code> class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/viewsets/login.py</p>
			<pre class="source-code">
from rest_framework.response import Response
from rest_framework.viewsets import ViewSet
from rest_framework.permissions import AllowAny
from rest_framework import status
from rest_framework_simplejwt.exceptions import TokenError,
    InvalidToken
from core.auth.serializers import LoginSerializer
class LoginViewSet(ViewSet):
   serializer_class = LoginSerializer
   permission_classes = (AllowAny,)
   http_method_names = ['post']
   def create(self, request, *args, **kwargs):
       serializer =
           self.serializer_class(data=request.data)
       try:
           serializer.is_valid(raise_exception=True)
       except TokenError as e:
           raise InvalidToken(e.args[0])
       return Response(serializer.validated_data,
           status=status.HTTP_200_OK)</pre>
			<p>Add the viewset to the <code>__init__.py</code> file of the <code>viewsets</code> directory:</p>
			<pre class="source-code">
from .register import RegisterViewSet
from .login import LoginViewSet</pre>
			<p>We can now<a id="_idIndexMarker139"/> import it and register it in the <code>routers.py</code> file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/routers.py</p>
			<pre class="source-code">
...
from core.auth.viewsets import RegisterViewSet,
    LoginViewSet
router = routers.SimpleRouter()
# ##################################################################### #
# ################### AUTH                       ###################### #
# ##################################################################### #
router.register(r'auth/register', RegisterViewSet,
    basename='auth-register')
router.register(r'auth/login', LoginViewSet,
    basename='auth-login')
...</pre>
			<p>The endpoint for login will be available at <code>/auth/login/</code>. Let’s try a request with Insomnia.</p>
			<p>Here’s the <a id="_idIndexMarker140"/>body of the request I’ll use:</p>
			<pre class="console">
{
    "password": "12345678",
    "email": "mouse@yopmail.com"
}</pre>
			<div><div><img src="img/Figure_2.9_B18221.jpg" alt="Figure 2.9 – Login with user credentials"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – Login with user credentials</p>
			<p>The login <a id="_idIndexMarker141"/>feature is ready and working like a charm – but we have a little bit of an issue. The access token expires in 5 minutes. Basically, to get a new access token, the user will have to log in again. Let’s see how we can use the refresh token to request a new access token without logging in again.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor050"/>Refresh logic</h1>
			<p><code>djangorestframework-simplejwt</code> provides a <a id="_idIndexMarker142"/>refresh logic feature. As you’ve noticed, we’ve been generating refresh tokens and returning them as responses every time registration or login is completed. We’ll just inherit the class from <code>TokenRefreshView</code> and transform it into a viewset.</p>
			<p>In <code>auth/viewsets</code>, add a new file called <code>refresh.py</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/viewsets/refresh.py</p>
			<pre class="source-code">
from rest_framework.response import Response
from rest_framework_simplejwt.views import TokenRefreshView
from rest_framework.permissions import AllowAny
from rest_framework import status
from rest_framework import viewsets
from rest_framework_simplejwt.exceptions import TokenError,
    InvalidToken
class RefreshViewSet(viewsets.ViewSet, TokenRefreshView):
   permission_classes = (AllowAny,)
   http_method_names = ['post']
   def create(self, request, *args, **kwargs):
       serializer = self.get_serializer(data=request.data)
       try:
           serializer.is_valid(raise_exception=True)
       except TokenError as e:
           raise InvalidToken(e.args[0])
       return Response(serializer.validated_data,
           status=status.HTTP_200_OK)
Now add the class in the __init__.py file.
from .register import RegisterViewSet
from .login import LoginViewSet
from .refresh import RefreshViewSet</pre>
			<p>Now <a id="_idIndexMarker143"/>add the class in the <code>__init__.py</code> file.</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/viewsets/__init__.py</p>
			<pre class="source-code">
from .register import RegisterViewSet
from .login import LoginViewSet
from .refresh import RefreshViewSet</pre>
			<p>And now register it in the <code>routers.py</code> file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/routers.py</p>
			<pre class="source-code">
from core.auth.viewsets import RegisterViewSet,
    LoginViewSet, RefreshViewSet
...
router.register(r'auth/refresh', RefreshViewSet,
    basename='auth-refresh')
...</pre>
			<p>Great – let’s test the new endpoint at <code>/auth/refresh/</code> to get a new token. It’ll be a <code>POST</code> request with the refresh token in the body of the request, and you will receive a new access token in the response:</p>
			<div><div><img src="img/Figure_2.10_B18221.jpg" alt="Figure 2.10 – Requesting for a new access token"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – Requesting for a new access token</p>
			<p>Great – we’ve<a id="_idIndexMarker144"/> just learned how to implement refresh token logic in the application.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor051"/>Summary</h1>
			<p>In this chapter, we learned how to write an authentication system based on JWT for a Django application using DRF and <code>djangorestframework-simplejwt</code>. We also learned how to extend classes and rewrite the functions.</p>
			<p>In the next chapter, we’ll add the <code>posts</code> feature. Our users will be able to create a post that can be viewed and<a id="_idTextAnchor052"/> liked by other users.</p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor053"/>Questions</h1>
			<ol>
				<li>What is a JWT?</li>
				<li>What is Django Rest Framework?</li>
				<li>What is a model?</li>
				<li>What is a serializer?</li>
				<li>What is a viewset?</li>
				<li>What is a router?</li>
				<li>What is the usage of a refresh token?</li>
			</ol>
		</div>
	</body></html>