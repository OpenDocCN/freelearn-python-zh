<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer012">
<h1 class="chapter-number" id="_idParaDest-259"><a id="_idTextAnchor262"/>8</h1>
<h1 id="_idParaDest-260"><a id="_idTextAnchor263"/>Advanced Features and Best Practices</h1>
<p>Welcome to <a href="B21025_08.xhtml#_idTextAnchor262"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, where we explore advanced techniques and best practices to optimize the functionality, performance, and scalability of <span class="No-Break">FastAPI applications.</span></p>
<p>In this chapter, by building a trip agency platform, you’ll delve into essential topics such as dependency injection, custom middleware, internationalization, performance optimization, rate limiting, and background task execution. By mastering these advanced features, you’ll be equipped to build robust, efficient, and high-performing APIs <span class="No-Break">with FastAPI.</span></p>
<p>By the end of this chapter, you’ll have a comprehensive understanding of the advanced FastAPI features and best practices, empowering you to build efficient, scalable, and secure APIs that meet the demands of modern web applications. Let’s dive in and explore these advanced techniques to elevate your FastAPI <span class="No-Break">development skills.</span></p>
<p>In this chapter, we’re going to cover the <span class="No-Break">following recipes:</span></p>
<ul>
<li>Implementing <span class="No-Break">dependency injection</span></li>
<li>Creating <span class="No-Break">custom middleware</span></li>
<li>Internationalization <span class="No-Break">and localization</span></li>
<li>Optimizing <span class="No-Break">application performance</span></li>
<li>Implementing <span class="No-Break">rate limiting</span></li>
<li>Implementing <span class="No-Break">background tasks</span></li>
</ul>
<h1 id="_idParaDest-261"><a id="_idTextAnchor264"/>Technical requirements</h1>
<p>To be able to follow the recipes in this chapter, you must have a good grasp of the <span class="No-Break">following essentials:</span></p>
<ul>
<li><strong class="bold">Python</strong>: You should have a good understanding of Python version 3.7 or higher. You should know how annotation works and about basic <span class="No-Break">class inheritance.</span></li>
<li><strong class="source-inline">fastapi</strong><strong class="bold"> and </strong><strong class="source-inline">asyncio</strong><strong class="bold"> libraries</strong>: If you are not following the book chapter by chapter, make sure you know how to build a simple FastAPI endpoint and understand <span class="No-Break"><strong class="source-inline">async</strong></span><span class="No-Break">/</span><span class="No-Break"><strong class="source-inline">await</strong></span><span class="No-Break"> syntax.</span></li>
</ul>
<p>The code used in the chapter is hosted on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter08"><span class="No-Break">https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter08</span></a><span class="No-Break">.</span></p>
<p>To manage dependencies more efficiently and keep your project isolated, consider creating a virtual environment within the <strong class="source-inline">project</strong> root folder. You can easily install all the dependencies simultaneously by using the <strong class="source-inline">requirements.txt</strong> file provided on the GitHub repository in the <span class="No-Break"><strong class="source-inline">project</strong></span><span class="No-Break"> folder:</span></p>
<pre class="console">
$  pip install –r requirements.txt</pre> <p>You can then start with the first recipe and efficiently implement dependency injection in your <span class="No-Break">FastAPI application.</span></p>
<h1 id="_idParaDest-262"><a id="_idTextAnchor265"/>Implementing dependency injection</h1>
<p><strong class="bold">Dependency injection</strong> is a powerful design pattern used in software development to manage dependencies between components. In the context of FastAPI, dependency injection allows you to efficiently<a id="_idIndexMarker529"/> manage and inject dependencies, such as database connections, authentication services, and configuration settings, into your application’s endpoints and middleware. Although we have already used dependency injection in previous recipes, such as <em class="italic">Setting up SQL databas</em><em class="italic">es</em> in <a href="B21025_02.xhtml#_idTextAnchor052"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Working with Data</em>, or <em class="italic">Setting up user registration</em> in <a href="B21025_04.xhtml#_idTextAnchor122"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Authentication and Authorization</em>, this recipe will show you how to implement dependency injections in FastAPI and how to tackle trickier use cases with nested <span class="No-Break">dependency injections.</span></p>
<h2 id="_idParaDest-263"><a id="_idTextAnchor266"/>Getting ready</h2>
<p>To follow along with the recipe, you only need to have Python installed with the <strong class="source-inline">fastapi</strong> and <strong class="source-inline">uvicorn</strong> packages installed in your environment, as well as <strong class="source-inline">pytest</strong>. If you haven’t installed the packages with the <strong class="source-inline">requirements.txt</strong> file provided in the GitHub repository, you can install them with <strong class="source-inline">pip</strong> from the <span class="No-Break">command line:</span></p>
<pre class="console">
$ pip install fastapi uvicorn pytest</pre> <p>Also, it would be beneficial to<a id="_idIndexMarker530"/> know already how to create a simple server in FastAPI. You can refer to the <em class="italic">Creating a </em><em class="italic">new</em><em class="italic"> FastAPI </em><em class="italic">project</em> recipe in <a href="B21025_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">First Steps with FastAPI</em>, for <span class="No-Break">more details.</span></p>
<h2 id="_idParaDest-264"><a id="_idTextAnchor267"/>How to do it…</h2>
<p>Let's start by creating the project root folder called <strong class="source-inline">trip_platform</strong> containing the <strong class="source-inline">app</strong> folder. Then let's continue the recipe through the <span class="No-Break">following steps.</span></p>
<ol>
<li>In the <strong class="source-inline">app</strong> folder, create the <strong class="source-inline">main.py</strong> module that will contain the <span class="No-Break">server as:</span><pre class="source-code">
from fastapi import FastAPI
app = FastAPI()</pre><p class="list-inset">We will write the dependencies in a separate module called <strong class="source-inline">dependencies.py</strong> inside the <span class="No-Break"><strong class="source-inline">app</strong></span><span class="No-Break"> folder.</span></p></li> <li>Let’s imagine we need to create an endpoint to retrieve all the trips between a start date and an end date. We need to handle two parameters, the start date and end date, and check that the start date is earlier than the end date. Both parameters can be optional; if the start date is not provided, it defaults to the <span class="No-Break">current day.</span><p class="list-inset">In a dedicated module, <strong class="source-inline">dependencies.py</strong> in the <strong class="source-inline">app</strong> folder, let’s define the condition function, which checks that the start date is earlier than the <span class="No-Break">end date:</span></p><pre class="source-code">
from fastapi import HTTPException
def check_start_end_condition(start: date, end: date):
    if end and end &lt; start:
        raise HTTPException(
            status_code=400,
            detail=(
                "End date must be "
                "greater than start date"
            ),
        )</pre></li> <li>We use the <strong class="source-inline">check_start_end_condition</strong> function to define the <strong class="source-inline">dependable</strong> function – namely, the function that will be<a id="_idIndexMarker531"/> used as a dependency – <span class="No-Break">as follows:</span><pre class="source-code">
from datetime import date, timedelta
from fastapi import Query
def time_range(
    start: date | None = Query(
        default=date.today(),
        description=(
            "If not provided the current date is used"
        ),
        example=date.today().isoformat(),
    ),
    end: date | None = Query(
        None,
        example=date.today() + timedelta(days=7),
    ),
) -&gt; Tuple[date, date | None]:
    check_start_end_condition(start, end)
    return start, end</pre><p class="list-inset">The <strong class="source-inline">Query</strong> object is used to<a id="_idIndexMarker532"/> manage metadata of the query parameters, such as the default value, description, and example used when generating <span class="No-Break">the documentation.</span></p></li> <li>We can use the dependable <strong class="source-inline">time_range</strong> function to create the endpoint in the <strong class="source-inline">main.py</strong> module. To specify that it is a dependency, we use the <strong class="source-inline">Depends</strong> object <span class="No-Break">like this:</span><pre class="source-code">
from fastapi import Depends
@app.get("/v1/trips")
def get_tours(
    time_range = Depends(time_range),
):
    start, end = time_range
    message = f"Request trips from {start}"
    if end:
        return f"{message} to {end}"
    return message</pre><p class="list-inset">You can alternatively use the <strong class="source-inline">Annotated</strong> class from the <strong class="source-inline">typing</strong> package to define the dependency <span class="No-Break">as follows:</span></p><pre class="source-code"><strong class="bold">from typing import Annotated</strong>
from fastapi import Depends
@app.get("/v1/trips")
def get_tours(
<strong class="bold">    time_range: Annotated[time_range, Depends()]</strong>
):</pre></li> </ol>
<p class="callout-heading">Important note</p>
<p class="callout">The use of <strong class="source-inline">Annotated</strong> in FastAPI is currently evolving to avoid duplicates and improve readability; take a look at the<a id="_idIndexMarker533"/> dedicated documentation <span class="No-Break">section:</span><span class="No-Break"><span class="P---URL"> </span></span><a href="https://fastapi.tiangolo.com/tutorial/dependencies/#share-annotated-dependencies"><span class="No-Break">https://fastapi.tiangolo.com/tutorial/dependencies/#share-annotated-dependencies</span></a><span class="No-Break">.</span></p>
<p class="callout">For the rest of the chapter, we will use the latest <span class="No-Break"><strong class="source-inline">Annotated</strong></span><span class="No-Break"> convention.</span></p>
<p>Now, if you spin up the server by running <strong class="source-inline">uvicorn app.main:app</strong> on the terminal, you will find the endpoint in the interactive documentation at <strong class="source-inline">http://localhost:8000/docs</strong>. You will see that you just created the endpoint with the parameters correctly documented. The database logic is replaced by a string construction returning a significant message in <span class="No-Break">the example.</span></p>
<p>You have just implemented a dependency injection strategy to define query parameters for the endpoint. You can use the same strategy to write path or body parameters to write modular and <span class="No-Break">readable code.</span></p>
<p>One of the advantages of using dependency injection is to logically separate pieces of code that can be replaced by something else, like in testing. Let’s have a look at how to <span class="No-Break">do it.</span></p>
<h3>Overriding dependency injections in tests</h3>
<p>Let’s create a test for the <strong class="source-inline">GET /v1/trips</strong> endpoint. If you don’t have <strong class="source-inline">pytest</strong> in the environment, install it with <strong class="source-inline">pip install pytest</strong>. Then, under the project root folder, create the <strong class="source-inline">pytest.ini</strong> file containing <strong class="source-inline">pythonpath</strong> for <strong class="source-inline">pytest</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
[pytest]
pythonpath=.</pre> <p>The test will be in the<a id="_idIndexMarker534"/> test module, <strong class="source-inline">test_main.py</strong>, under the <strong class="source-inline">tests</strong> folder. Let’s write a unit test by overriding the <span class="No-Break">client’s dependency:</span></p>
<pre class="source-code">
from datetime import date
from fastapi.testclient import TestClient
from app.dependencies import time_range
from app.main import app
def test_get_v1_trips_endpoint():
    client = TestClient(app)
<strong class="bold">    app.dependency_overrides[time_range] = lambda: (</strong>
<strong class="bold">        date.fromisoformat("2024-02-01"),</strong>
<strong class="bold">        None,</strong>
<strong class="bold">    </strong><strong class="bold">)</strong>
    response = client.get("/v1/trips")
    assert (
        response.json()
        == "Request trips from 2024-02-01"
    )</pre> <p>By overriding the <strong class="source-inline">time_range</strong> dependency, we won’t need to pass the parameters when calling the endpoint, and the<a id="_idIndexMarker535"/> response will depend on the lambda <span class="No-Break">function defined.</span></p>
<p>Then, you can run the test from the <span class="No-Break">command line:</span></p>
<pre class="console">
$ pytest tests</pre> <p>This technique is very useful when writing tests that should not interfere with a production database. Also, an eventual heavy computation logic can be mocked if it is not in the <span class="No-Break">test’s interest.</span></p>
<p>The use of dependency injection can significantly improve test quality by <span class="No-Break">enabling modularity.</span></p>
<h2 id="_idParaDest-265"><a id="_idTextAnchor268"/>How it works…</h2>
<p>The <strong class="source-inline">Depends</strong> object and dependency injection leverage Python’s powerful function annotations and type <span class="No-Break">hinting features.</span></p>
<p>When you define a dependency<a id="_idIndexMarker536"/> function and annotate it with <strong class="source-inline">Depends</strong>, FastAPI interprets it as a dependency that needs to be resolved before executing the endpoint function. When a request is made to an endpoint that depends on one or more dependencies, FastAPI introspects the endpoint function signature, identifies the dependencies, and resolves them by invoking the corresponding dependency functions in the <span class="No-Break">correct order.</span></p>
<p>FastAPI uses Python’s type hinting mechanism to determine the type of each dependency parameter and automatically injects the resolved dependency into the endpoint function. This process ensures that the required data or services are available to the endpoint function at runtime, enabling seamless integration of external services, database connections, authentication mechanisms, and other dependencies into <span class="No-Break">FastAPI applications.</span></p>
<p>Overall, the <strong class="source-inline">Depends</strong> class and dependency injection in FastAPI provide a clean and efficient way to manage dependencies and promote modular, maintainable code architecture. One of the advantages is that they can be overwritten in testing to be easily mocked <span class="No-Break">or replaced.</span></p>
<h2 id="_idParaDest-266"><a id="_idTextAnchor269"/>There’s more…</h2>
<p>We can push things further by <span class="No-Break">leveraging sub-dependencies.</span></p>
<p>Let’s create an endpoint that returns the trips for one of the three categories (cruises, city breaks, and resort stays) and, simultaneously, checks the coupon validity for <span class="No-Break">the category.</span></p>
<p>In the <strong class="source-inline">dependencies.py</strong> module, let’s create the <strong class="source-inline">dependable</strong> function for <span class="No-Break">the category.</span></p>
<p>Imagine we can group our trips into three categories – cruises, city breaks, and resort stays. We need to add a parameter<a id="_idIndexMarker537"/> to retrieve trips only for a specific category. We will need a <strong class="source-inline">dependable</strong> function, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
def select_category(
    category: Annotated[
        str,
        Path(
            description=(
                "Kind of travel "
                "you are interested in"
            ),
            enum=[
                "Cruises",
                "City Breaks",
                "Resort Stay",
            ],
        ),
    ],
) -&gt; str:
    return category</pre> <p>Now, let’s imagine we need to validate a coupon for <span class="No-Break">a discount.</span></p>
<p>The <strong class="source-inline">dependable</strong> function<a id="_idIndexMarker538"/> will be used as a dependency for another <strong class="source-inline">dependable</strong> function that will check the coupon. Let’s define it, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
def check_coupon_validity(
    category: Annotated[select_category, Depends()],
    code: str | None = Query(
        None, description="Coupon code"
    ),
) -&gt; bool:
    coupon_dict = {
        "cruises": "CRUISE10",
        "city-breaks": "CITYBREAK15",
        "resort-stays": "RESORT20",
    }
    if (
        code is not None
        and coupon_dict.get(category, ...) == code
    ):
        return True
    return False</pre> <p>In the <strong class="source-inline">main.py</strong> module, let’s define a new endpoint, <strong class="source-inline">GET /v2/trips/{category}</strong>, that returns the trips for the <span class="No-Break">specified category:</span></p>
<pre class="source-code">
@app.get("/v2/trips/{category}")
def get_trips_by_category(
    category: Annotated[select_category, Depends()],
    discount_applicable: Annotated[
        bool, Depends(check_coupon_validity)
    ],
):
    category = category.replace("-", " ").title()
    message = f"You requested {category} trips."
    if discount_applicable:
        message += (
            "\n. The coupon code is valid! "
            "You will get a discount!"
        )
    return message</pre> <p>If you run the server with the <strong class="source-inline">uvicorn app.main:app</strong> command and open the interactive documentation at <strong class="source-inline">http://localhost:8000/docs</strong>, you will see the new endpoint. The accepted<a id="_idIndexMarker539"/> parameters, <strong class="source-inline">category</strong> and <strong class="source-inline">code</strong>, both come from the dependencies, and the <strong class="source-inline">category</strong> parameter is not repeated within <span class="No-Break">the code.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">You can use both <strong class="source-inline">def</strong> and <strong class="source-inline">async def</strong> keywords to declare dependencies, whether they are synchronous or asynchronous functions respectively. FastAPI will handle <span class="No-Break">them automatically.</span></p>
<p>You have just created an endpoint that uses nested dependencies. By using nested dependencies and sub-dependencies, you will be able to write clear and modular code that is easier to read <span class="No-Break">and maintain.</span></p>
<p class="callout-heading">Exercise</p>
<p class="callout">In FastAPI, dependencies can be also created as a class. Check out the documentation at<span class="P---URL"> </span><a href="https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/#classes-as-dependencies">https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/#classes-as-dependencies</a>, and create a new endpoint that uses all the parameters we defined in the recipe (<strong class="source-inline">time_range</strong>, <strong class="source-inline">category</strong>, and <strong class="source-inline">code</strong>). </p>
<p class="callout">Group all the parameters into a class, and define and use it as a dependency for <span class="No-Break">the endpoint.</span></p>
<h2 id="_idParaDest-267"><a id="_idTextAnchor270"/>See also</h2>
<p>We have used <strong class="source-inline">Query</strong> and <strong class="source-inline">Path</strong> descriptor<a id="_idIndexMarker540"/> objects to set metadata and documentation-related data for <strong class="source-inline">query</strong> and <strong class="source-inline">path</strong> parameters, respectively. You can discover more about their potential at these <span class="No-Break">documentation links:</span></p>
<ul>
<li><em class="italic">Query Parameters and String </em><span class="No-Break"><em class="italic">Validations</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/tutorial/query-params-str-validations/"><span class="No-Break">https://fastapi.tiangolo.com/tutorial/query-params-str-validations/</span></a></li>
<li><em class="italic">Path Parameters and Numeric </em><span class="No-Break"><em class="italic">Validations</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/"><span class="No-Break">https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/</span></a></li>
</ul>
<p>For dependency injections in FastAPI, you can find extensive documentation covering all the possible usages, explaining the potential of this <span class="No-Break">powerful feature:</span></p>
<ul>
<li><span class="No-Break"><em class="italic">Dependencies</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/tutorial/dependencies/"><span class="No-Break">https://fastapi.tiangolo.com/tutorial/dependencies/</span></a></li>
<li><em class="italic">Advanced </em><span class="No-Break"><em class="italic">Dependencies</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/advanced/advanced-dependencies/"><span class="No-Break">https://fastapi.tiangolo.com/advanced/advanced-dependencies/</span></a></li>
<li><em class="italic">Testing Dependencies with </em><span class="No-Break"><em class="italic">Overrides</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/advanced/testing-dependencies/"><span class="No-Break">https://fastapi.tiangolo.com/advanced/testing-dependencies/</span></a></li>
</ul>
<h1 id="_idParaDest-268"><a id="_idTextAnchor271"/>Creating custom middleware</h1>
<p><strong class="bold">Middleware</strong> is an API component that allows <a id="_idIndexMarker541"/>you to intercept and modify incoming requests and outgoing responses, making it a powerful tool for implementing cross-cutting concerns such as authentication, logging, and <span class="No-Break">error handling.</span></p>
<p>In this recipe, we’ll explore how to develop custom middleware to process requests and responses in FastAPI applications and retrieve information on <span class="No-Break">the client.</span></p>
<h2 id="_idParaDest-269"><a id="_idTextAnchor272"/>Getting ready…</h2>
<p>All you need is to have a running FastAPI application. The recipe will use our trip platform defined in the previous recipe, <em class="italic">Implementing dependency injection</em>. However, middleware works for a generic <span class="No-Break">running application.</span></p>
<h2 id="_idParaDest-270"><a id="_idTextAnchor273"/>How to do it…</h2>
<p>We will show you how to<a id="_idIndexMarker542"/> create a custom middleware object class that we will use in our application through the <span class="No-Break">following steps.</span></p>
<ol>
<li>Let’s create a dedicated module in the app folder <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">middleware.py</strong></span><span class="No-Break">.</span><p class="list-inset">We want the middleware to intercept the request and print the host client and the method on the output terminal. In a real application scenario, this information can be stored in a database for analytics or used for security <span class="No-Break">inspection purposes.</span></p><p class="list-inset">Let’s use the same <strong class="source-inline">uvicorn</strong> logger used by FastAPI <span class="No-Break">by default:</span></p><pre class="source-code">
import logging
logger = logging.getLogger("uvicorn.error")</pre></li> <li>Then, let’s create our <strong class="source-inline">ClientInfoMiddleware</strong> class, <span class="No-Break">as follows:</span><pre class="source-code">
from fastapi import Request
from starlette.middleware.base import BaseHTTPMiddleware
class ClientInfoMiddleware(BaseHTTPMiddleware):
    async def dispatch(
        self, request: Request, call_next
    ):
        host_client = request.client.host
        requested_path = request.url.path
        method = request.method
        logger.info(
            f"host client {host_client} "
            f"requested {method} {requested_path} "
            "endpoint"
        )
        return await call_next(request)</pre></li> <li>Then, we need to add our middleware to the FastAPI server in <strong class="source-inline">main.py</strong>. After defining the app server, we <a id="_idIndexMarker543"/>can add the middleware with the <span class="No-Break"><strong class="source-inline">add_middleware</strong></span><span class="No-Break"> method:</span><pre class="source-code">
# main.py import modules
from app.middleware import ClientInfoMiddleware
app = FastAPI()
<strong class="bold">app.add_middleware(ClientInfoMiddleware)</strong>
# rest of the code</pre></li> </ol>
<p>Now, spin up the server with the <strong class="source-inline">uvicorn app.main:app</strong> command, and try to connect to a subpath of <strong class="source-inline">http://localhost:8000/v1/trips</strong>. You don’t even need to call an existing endpoint. You will see the log messages in the application <span class="No-Break">output terminal:</span></p>
<pre class="console">
<strong class="bold">INFO:host client 127.0.0.1 requested GET /v1/trips endpoint</strong></pre> <p>You have just implemented a basic custom middleware to retrieve information about the client. You can increase the<a id="_idIndexMarker544"/> complexity by adding more operations, such as redirecting requests based on the IP and integrating IP blocking <span class="No-Break">or filtering.</span></p>
<h2 id="_idParaDest-271"><a id="_idTextAnchor274"/>How it works…</h2>
<p>FastAPI uses the <strong class="source-inline">BasicHTTPMiddleware</strong> class from the <strong class="source-inline">Starlette</strong> library. The strategy shown in the recipe creates a class derived from <strong class="source-inline">BasicHTTPMiddleware</strong>, with a specific <strong class="source-inline">dispatch</strong> method that implements the <span class="No-Break">interception operation.</span></p>
<p>To create a middleware in FastAPI, you can add a decorator from the FastAPI class methods to a simple function. However, it is recommended to create a class, as it allows for better modularity and organization of the code. By creating a class, you can eventually create your collection module <span class="No-Break">of middleware.</span></p>
<h2 id="_idParaDest-272"><a id="_idTextAnchor275"/>See also</h2>
<p>You can have a look at how to create a custom middleware on the official documentation page at the <span class="No-Break">following link:</span></p>
<ul>
<li><em class="italic">FastAPI Middleware </em><span class="No-Break"><em class="italic">documentation</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/tutorial/middleware/"><span class="No-Break">https://fastapi.tiangolo.com/tutorial/middleware/</span></a></li>
</ul>
<p>An interesting discussion on how to <a id="_idIndexMarker545"/>create middleware classes in FastAPI can be found on the <strong class="bold">Stack </strong><span class="No-Break"><strong class="bold">Overflow</strong></span><span class="No-Break"> website:</span></p>
<ul>
<li><em class="italic">Create FastAPI Custom Middleware Class </em><span class="No-Break"><em class="italic">Discussion</em></span><span class="No-Break">: </span><a href="https://stackoverflow.com/questions/71525132/how-to-write-a-custom-fastapi-middleware-class"><span class="No-Break">https://stackoverflow.com/questions/71525132/how-to-write-a-custom-fastapi-middleware-class</span></a></li>
</ul>
<h1 id="_idParaDest-273"><a id="_idTextAnchor276"/>Internationalization and localization</h1>
<p><strong class="bold">Internationalization</strong> (<strong class="bold">i18n</strong>) and <strong class="bold">localization</strong> (<strong class="bold">l10n</strong>) are fundamental concepts in software development that <a id="_idIndexMarker546"/>enable applications to be adapted for <a id="_idIndexMarker547"/>different languages, regions, <span class="No-Break">and cultures.</span></p>
<p><strong class="bold">i18n</strong> refers to the process of designing and developing software or products that can be adapted to different languages and cultures. This process mainly involves providing content in a specific language. Conversely, <strong class="bold">l10n</strong> involves adapting a product or content for a specific locale or market, such as currency or a unit <span class="No-Break">of measure.</span></p>
<p>The <strong class="bold">Accept-Language request HTTP header</strong> is the<a id="_idIndexMarker548"/> most commonly used method to inform a server about a user’s location. This is widely used by modern browsers. This recipe will guide you on how to utilize the <strong class="source-inline">Accept-Language</strong> header to implement i18n and l10n in our trip platform. This will enable our platform to provide targeted content to <span class="No-Break">the client.</span></p>
<h2 id="_idParaDest-274"><a id="_idTextAnchor277"/>Getting ready</h2>
<p>It would be beneficial to have some knowledge of the <strong class="source-inline">Accept-Language</strong> header; take a look at this interesting article from Mozilla’s <span class="No-Break">documentation:</span><span class="No-Break"><span class="P---URL"> </span></span><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language</span></a><span class="No-Break">.</span></p>
<p>You need to have a running FastAPI application to follow the recipe. You can follow along with the trip platform application used throughout <span class="No-Break">the chapter.</span></p>
<p>We will make use of dependency injection, so it will be beneficial to complete the <em class="italic">Implementing dependency injection</em> recipe from <span class="No-Break">this chapter.</span></p>
<p>Also, we will use the <strong class="source-inline">babel</strong> package to resolve language code references, so if haven’t installed the packages with the <strong class="source-inline">requirements.txt</strong> file, make sure to have <strong class="source-inline">babel</strong> in your environment by running <span class="No-Break">the following:</span></p>
<pre class="console">
$ pip install babel</pre> <p>Once the installation is completed, you have all you need to start <span class="No-Break">the recipe.</span></p>
<h2 id="_idParaDest-275"><a id="_idTextAnchor278"/>How to do it…</h2>
<p>To begin with, we must determine which regions and languages we wish to cater to. For this example, we will focus on two – <strong class="bold">American English</strong> (<strong class="bold">en_US</strong>) and <strong class="bold">French from France</strong> (<strong class="bold">fr_FR</strong>). All content pertaining to language will be in one of these <span class="No-Break">two languages.</span></p>
<p>It is necessary to manage the <strong class="source-inline">Accept-Language</strong> header on the host client side, which is a list of languages <a id="_idIndexMarker549"/>with a preference <span class="No-Break">weight parameter.</span></p>
<p>Examples of the header are <a id="_idIndexMarker550"/><span class="No-Break">as follows:</span></p>
<pre class="source-code">
Accept-Language: en
Accept-Language: en, fr
Accept-Language: en-US
Accept-Language: en-US;q=0.8, fr;q=0.5
Accept-Language: en, *
Accept-Language: en-US, en-GB
Accept-Language: zh-Hans-CN</pre> <p>We need a function that takes as an argument the header and the list of available languages in our app, returning the most appropriate one Let's implement it by applying the <span class="No-Break">following steps.</span></p>
<ol>
<li>Create a dedicated module, <strong class="source-inline">internationalization.py</strong>, under the <span class="No-Break"><strong class="source-inline">app</strong></span><span class="No-Break"> folder.</span><p class="list-inset">First, we store the supported languages in a variable, <span class="No-Break">as follows:</span></p><pre class="source-code">
SUPPORTED_LOCALES = [
    "en_US",
    "fr_FR",
]</pre></li> <li>Then, we start defining the <strong class="source-inline">resolve_accept_lanugage</strong> function, <span class="No-Break">as follows:</span><pre class="source-code">
from babel import Locale, negotiate_locale
def resolve_accept_language(
    accept_language: str = Header("en-US"),
) -&gt; Locale:</pre></li> <li>Within the function, we<a id="_idIndexMarker551"/> parse the string into <span class="No-Break">a list:</span><pre class="source-code">
    client_locales = []
    for language_q in accept_language.split(","):
        if ";q=" in language_q:
            language, q = language_q.split(";q=")
        else:
            language, q = (language_q, float("inf"))
        try:
            Locale.parse(language, sep="-")
            client_locales.append(
                (language, float(q))
            )
        except ValueError:
            continue</pre></li> <li>We then sort the string<a id="_idIndexMarker552"/> according to the preference <span class="No-Break"><strong class="source-inline">q</strong></span><span class="No-Break"> parameter:</span><pre class="source-code">
    client_locales.sort(
        key=lambda x: x[1], reverse=True
    )
    locales = [locale for locale, _ in client_locales]</pre></li> <li>Then, we use <strong class="source-inline">negotiate_locale</strong> from the <strong class="source-inline">babel</strong> package to get the most <span class="No-Break">suited language:</span><pre class="source-code">
    locale = negotiate_locale(
        [str(locale) for locale in locales],
        SUPPORTED_LOCALES,
    )</pre></li> <li>If there is no match, we<a id="_idIndexMarker553"/> return <strong class="source-inline">en_US</strong> <span class="No-Break">as default:</span><pre class="source-code">
    if locale is None:
        locale = "en_US"
    return locale</pre><p class="list-inset">The <strong class="source-inline">resolve_accept_language</strong> function will be used as a dependency for the endpoints that return <a id="_idIndexMarker554"/>content based on <span class="No-Break">the language.</span></p></li> <li>In the same <strong class="source-inline">internationalization.py</strong> module, let’s create a <strong class="source-inline">GET /homepage</strong> endpoint that returns a welcome string, depending on the language. We will do it in a separate <strong class="source-inline">APIRouter</strong>, so the router will be <span class="No-Break">as follows:</span><pre class="source-code">
from fastapi import APIRouter
router = APIRouter(
    tags=["Localizad Content Endpoints"]
)</pre><p class="list-inset">The <strong class="source-inline">tags</strong> parameter specifies that the router’s endpoint will be grouped separately in the interactive <a id="_idIndexMarker555"/>documentation under a specified <span class="No-Break">tag name.</span></p><p class="list-inset">The <strong class="source-inline">GET /home</strong> endpoint <a id="_idIndexMarker556"/>will be <span class="No-Break">as follows:</span></p><pre class="source-code">home_page_content = {
    "en_US": "Welcome to Trip Platform",
    "fr_FR": "Bienvenue sur Trip Platform",
}
@router.get("/homepage")
async def home(
    request: Request,
    language: Annotated[
        resolve_accept_language, Depends()
    ],
):
    return {"message": home_page_content[language]}</pre><p class="list-inset">In the example, the content has been hardcoded as a <strong class="source-inline">dict</strong> object with language code as a <span class="No-Break">dictionary key.</span></p><p class="list-inset">In a real-world scenario, the content should be stored in a database for <span class="No-Break">each language.</span></p><p class="list-inset">Similarly, you define a localization strategy to retrieve <span class="No-Break">the currency.</span></p></li> <li>Let’s create a <strong class="source-inline">GET /show/currency</strong> endpoint as an example that uses a dependency to retrieve the currency from the <strong class="source-inline">Accept-Language</strong> header. The <strong class="source-inline">dependency</strong> function can<a id="_idIndexMarker557"/> be defined <span class="No-Break">as follows:</span><pre class="source-code">
async def get_currency(
    language: Annotated[
        resolve_accept_language, Depends()
    ],
):
    currencies = {
        "en_US": "USD",
        "fr_FR": "EUR",
    }
    return currencies[language]</pre><p class="list-inset">The endpoint will then be <span class="No-Break">as </span><span class="No-Break"><a id="_idIndexMarker558"/></span><span class="No-Break">follows:</span></p><pre class="source-code">from babel.numbers import get_currency_name
@router.get("/show/currency")
async def show_currency(
    currency: Annotated[get_currency, Depends()],
    language: Annotated[
        resolve_accept_language,
        Depends(use_cache=True)
    ],
):
    currency_name = get_currency_name(
        currency, locale=language
    )
    return {
        "currency": currency,
        "currency_name": currency_name,
    }</pre></li> <li>To use both endpoints, we <a id="_idIndexMarker559"/>will need to add the router to<a id="_idIndexMarker560"/> the FastAPI object <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">main.py</strong></span><span class="No-Break">:</span><pre class="source-code">
from app import internationalization
# rest of the code
app.include_router(internationalization.router)</pre></li> </ol>
<p>This is all you need to implement internationalization and localization. To test it, spin up the server from the command line <span class="No-Break">by running:</span></p>
<pre class="console">
<strong class="bold">$ uvicorn app.main:app</strong></pre> <p>On the interactive documentation at <strong class="source-inline">http:localhost:8000/docs</strong>, you will find the <strong class="source-inline">GET</strong> <strong class="source-inline">/homepage</strong> and <strong class="source-inline">GET</strong> <strong class="source-inline">/show/currency</strong> endpoints. Both accept the <strong class="source-inline">Accept-Language</strong> header to provide the language choice; if you don’t, it will get the default language from the browser. To test the implementation, try experimenting with different values for <span class="No-Break">the header.</span></p>
<p>You have successfully implemented internationalization and localization from scratch for your API. Using the recipe provided, you have integrated i18n and l10n into your applications, making them easily <span class="No-Break">understandable worldwide.</span></p>
<h2 id="_idParaDest-276"><a id="_idTextAnchor279"/>See also</h2>
<p>You can find out more about the potential of <strong class="source-inline">Babel</strong> package on the official documentation <span class="No-Break">page: </span><a href="https://babel.pocoo.org/en/latest/"><span class="No-Break">https://babel.pocoo.org/en/latest/</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-277"><a id="_idTextAnchor280"/>Optimizing application performance</h1>
<p>Optimizing FastAPI applications is crucial for ensuring high performance and scalability, especially under <span class="No-Break">heavy loads.</span></p>
<p>In this recipe, we’ll see a technique<a id="_idIndexMarker561"/> to profile our FastAPI application and explore actionable strategies to optimize performances. By the end of the recipe, you will be able to detect code bottlenecks and optimize <span class="No-Break">your application.</span></p>
<h2 id="_idParaDest-278"><a id="_idTextAnchor281"/>Getting ready</h2>
<p>Before starting the recipe, make sure to have a FastAPI application running with some endpoints already set up. You can follow along with our trip <span class="No-Break">platform application.</span></p>
<p>We will be using the <strong class="source-inline">pyinstrument</strong> package to set up a profiler for the application. If you haven’t installed the packages with <strong class="source-inline">requirements.txt</strong>, you can install <strong class="source-inline">pyinstrument</strong> in your environment by running <span class="No-Break">the following:</span></p>
<pre class="console">
$ pip install pyinstrument</pre> <p>Also, it can be useful to have a look at the <em class="italic">Creating </em><em class="italic">custom middleware</em> recipe from earlier in <span class="No-Break">the chapter.</span></p>
<h2 id="_idParaDest-279"><a id="_idTextAnchor282"/>How to do it…</h2>
<p>Let's implement the profiler in <span class="No-Break">simple steps.</span></p>
<ol>
<li>Under the app folder, create a <strong class="source-inline">profiler.py</strong> module <span class="No-Break">as follows:</span><pre class="source-code">
from pyinstrument import Profiler
profiler = Profiler(
    interval=0.001, async_mode="enabled"
)</pre><p class="list-inset">The <strong class="source-inline">async_mode="enabled"</strong> parameter specifies that the profiler logs the time each time it encounters an <strong class="source-inline">await</strong> statement in the function being awaited, rather than observing other coroutines or the event loop. The <strong class="source-inline">interval</strong> specifies the time between <span class="No-Break">two samples.</span></p></li> <li>Before using the profiler, we <a id="_idIndexMarker562"/>should plan what we want to profile. Let’s plan to profile only the code executed in the endpoints. To do this, we can create simple middleware in a separate module that starts and stops the profiler before and after each call, respectively. We can create the middleware in the same <strong class="source-inline">profiler.py</strong> module, <span class="No-Break">as follows:</span><pre class="source-code">
from starlette.middleware.base import (
    BaseHTTPMiddleware
)
class ProfileEndpointsMiddleWare(
    BaseHTTPMiddleware
):
    async def dispatch(
        self, request: Request, call_next
    ):
        if not profiler.is_running:
            profiler.start()
        response = await call_next(request)
        if profiler.is_running:
            profiler.stop()
            profiler.write_html(
                os.getcwd() + "/profiler.xhtml"
            )
            profiler.start()
        return response</pre><p class="list-inset">The profiler is initiated every time an endpoint is requested, and it is terminated after the request is complete. However, since the server operates asynchronously, there is a possibility that the profiler may already be running, due to another endpoint request. This can result in errors during the start and stop of the profiler. To prevent<a id="_idIndexMarker563"/> this, we verify before each request whether the profiler is not already running. After the request, we check whether the profiler is running before <span class="No-Break">terminating it.</span></p></li> <li>You can attach the profiler to the FastAPI server by adding the middleware in the <strong class="source-inline">main.py</strong> module, as we did in the <em class="italic">Creating custom </em><span class="No-Break"><em class="italic">middleware</em></span><span class="No-Break"> recipe:</span><pre class="source-code">
app.add_middleware(ProfileEndpointsMiddleWare)</pre></li> </ol>
<p>To test the profiler, spin up the server by running <strong class="source-inline">uvicorn app.main:app</strong>. Once you start making some calls, you can do it from the interactive documentation at http://localhost:8000/docs. Then, a <strong class="source-inline">profiler.xhtml</strong> file will be created. You can open the file with a simple browser and check the status of <span class="No-Break">the code.</span></p>
<p>You have just integrated a profiler into your <span class="No-Break">FastAPI application.</span></p>
<h2 id="_idParaDest-280"><a id="_idTextAnchor283"/>There’s more...</h2>
<p>Integrating a profiler is the first step that allows you to spot code bottlenecks and optimize the performance of <span class="No-Break">your application.</span></p>
<p>Let’s explore some techniques to optimize the performance of your <span class="No-Break">FastAPI performances:</span></p>
<ul>
<li><strong class="bold">Asynchronous programming</strong>: Utilize asynchronous programming to handle concurrent requests efficiently. FastAPI is built on top of the <strong class="source-inline">Starlette</strong> library and supports asynchronous <a id="_idIndexMarker564"/>request handlers, using the <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> keywords. By leveraging asynchronous programming, you can maximize CPU and <strong class="bold">input/output</strong> (<strong class="bold">I/O</strong>) utilization, reducing<a id="_idIndexMarker565"/> response times and <span class="No-Break">improving scalability.</span></li>
<li><strong class="bold">Scaling Uvicorn workers</strong>: Increasing the number of Uvicorn workers distributes incoming requests across <a id="_idIndexMarker566"/>multiple processes. However, it might not be always the best solution. For purely I/O operations, asynchronous programming massively reduces CPU usage, and additional workers remain idle. Before adding additional workers, check the CPU usage of the <span class="No-Break">main process.</span></li>
<li><strong class="bold">Caching</strong>: Implement caching<a id="_idIndexMarker567"/> mechanisms to store and reuse frequently accessed data, reducing database queries and computation overhead. Use dedicated libraries l to integrate caching into your <span class="No-Break">FastAPI applications.</span></li>
</ul>
<p>Other techniques are related to external libraries or tools, and whatever strategy you use, make sure to properly validate it with proper <span class="No-Break">profiling configuration.</span></p>
<p>Also, for high-traffic testing, take a look at the <em class="italic">Performance testing for high traffic applications</em> recipe in <a href="B21025_05.xhtml#_idTextAnchor157"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Testing and Debugging </em><span class="No-Break"><em class="italic">FastAPI Applications</em></span><span class="No-Break">.</span></p>
<p class="callout-heading">Exercise</p>
<p class="callout">We learned how to configure middleware to profile applications; however, it is more common to create tests to profile specific use cases. We learned how to configure middleware to profile applications; however, it is more common to create test scripts to profile specific use cases. Try to create one by yourself that attaches the profiler to the server, runs the server, makes API calls that reproduce the use case, and finally, writes the profiler output. The solution is provided on the GitHub repository in the <strong class="source-inline">profiling_application.py</strong> file. You can find it <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/FastAPI-Cookbook/blob/main/Chapter08/trip_platform/profiling_application.py"><span class="No-Break">https://github.com/PacktPublishing/FastAPI-Cookbook/blob/main/Chapter08/trip_platform/profiling_application.py</span></a><span class="No-Break">.</span></p>
<h2 id="_idParaDest-281"><a id="_idTextAnchor284"/>See also</h2>
<p>You can discover more<a id="_idIndexMarker568"/> about the potential of <strong class="bold">pyinstrument</strong> profiler on the <span class="No-Break">official documentation:</span></p>
<ul>
<li><em class="italic">pyinstrument</em> <span class="No-Break"><em class="italic">documentation</em></span><span class="No-Break">: </span><a href="https://pyinstrument.readthedocs.io/en/latest/"><span class="No-Break">https://pyinstrument.readthedocs.io/en/latest/</span></a></li>
</ul>
<p>Also, you can find a different approach to profile FastAPI endpoints on <span class="No-Break">the page:</span></p>
<ul>
<li><em class="italic">pyinstrument – profiling FastAPI </em><span class="No-Break"><em class="italic">requests</em></span><span class="No-Break">: </span><a href="https://pyinstrument.readthedocs.io/en/latest/guide.xhtml#profile-a-web-request-in-fastapi"><span class="No-Break">https://pyinstrument.readthedocs.io/en/latest/guide.xhtml#profile-a-web-request-in-fastapi</span></a></li>
</ul>
<h1 id="_idParaDest-282"><a id="_idTextAnchor285"/>Implementing rate limiting</h1>
<p><strong class="bold">Rate limiting</strong> is an essential technique used to control and manage the flow of traffic to web applications, ensuring <a id="_idIndexMarker569"/>optimal performance, resource utilization, and protection against abuse or overload. In this recipe, we’ll explore how to implement rate limiting in FastAPI applications to safeguard against potential abuse, mitigate security risks, and optimize application responsiveness. By the end of this recipe, you’ll have a solid understanding of how to leverage rate limiting to enhance the security, reliability, and scalability of your FastAPI applications, ensuring optimal performance under varying traffic conditions and <span class="No-Break">usage patterns.</span></p>
<h2 id="_idParaDest-283"><a id="_idTextAnchor286"/>Getting ready</h2>
<p>To follow the recipe, you need a running FastAPI application with some endpoints to use for rate limiting. To implement rate limiting, we will use the <strong class="source-inline">slowapi</strong> package; if you haven’t installed the packages with the <strong class="source-inline">requirements.txt</strong> file provided in the GitHub repository, you can install <strong class="source-inline">slowapi</strong> in your environment with <strong class="source-inline">pip</strong> by running <span class="No-Break">the following:</span></p>
<pre class="console">
$ pip install slowapi</pre> <p>Once the installation is completed, you are ready to start <span class="No-Break">the recipe.</span></p>
<h2 id="_idParaDest-284"><a id="_idTextAnchor287"/>How to do it…</h2>
<p>We will start by applying a<a id="_idIndexMarker570"/> rate limiter to a single endpoint in <span class="No-Break">simple steps.</span></p>
<ol>
<li>Let’s create the <strong class="source-inline">rate_limiter.py</strong> module under the <strong class="source-inline">app</strong> folder that contains our limiter object class defined <span class="No-Break">as follows:</span><pre class="source-code">
from slowapi import Limiter
from slowapi.util import get_remote_address
limiter = Limiter(
    key_func=get_remote_address,
)</pre><p class="list-inset">The limiter is designed to restrict the number of requests from a client based on their IP address. It is possible to create a function that can detect a user’s credentials and limit their calls according to their specific user profile. However, for the purpose of this example, we will use the client’s IP address to implement <span class="No-Break">the limiter.</span></p></li> <li>Now, we need to configure the FastAPI server to implement the limiter. In <strong class="source-inline">main.py</strong>, we have to add the <span class="No-Break">following configuration:</span><pre class="source-code">
from slowapi import _rate_limit_exceeded_handler
from slowapi.errors import RateLimitExceeded
# rest of the code
app.state.limiter = limiter
app.add_exception_handler(
    RateLimitExceeded, _rate_limit_exceeded_handler
)
# rest of the code</pre></li> <li>Now, we will apply a rate<a id="_idIndexMarker571"/> limit of two requests per minute to the <strong class="source-inline">GET /homepage</strong> endpoint defined in the <span class="No-Break"><strong class="source-inline">internalization.py</strong></span><span class="No-Break"> module:</span><pre class="source-code">
<strong class="bold">from fastapi import Request</strong>
<strong class="bold">from app.rate_limiter import limiter</strong>
@router.get("/homepage")
<strong class="bold">@limiter.limit("2/minute")</strong>
async def home(
<strong class="bold">    request: Request,</strong>
    language: Annotated[
        resolve_accept_language, Depends()
    ],
):
    return {"message": home_page_content[language]}</pre><p class="list-inset">The rate limit is applied as a decorator. Also, the request parameter needs to be added to make the <span class="No-Break">limiter work.</span></p></li> </ol>
<p>Now, spin up the server from the command line by running <span class="No-Break">the following:</span></p>
<pre class="console">
<strong class="bold">$ uvicorn app.main:app</strong></pre> <p>Then, try to make three consecutive calls to <strong class="source-inline">http://localhost:8000/homepage</strong>; you will get the home page content, and by the third call, you will get a <strong class="source-inline">429</strong> response with the<a id="_idIndexMarker572"/> <span class="No-Break">following content:</span></p>
<pre class="console">
{
    "error": "Rate limit exceeded: 2 per 1 minute"
}</pre> <p>You’ve just added a limit rate to the <strong class="source-inline">GET /homepage</strong> endpoint. With the same strategy, you can add a specific rate limiter to <span class="No-Break">each endpoint.</span></p>
<h2 id="_idParaDest-285"><a id="_idTextAnchor288"/>There's more...</h2>
<p>You can do more by adding a global rate limit to the entire application, <span class="No-Break">as follows.</span></p>
<p>In <strong class="source-inline">main.py</strong>, you need to add a dedicated middleware, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
# rest of the code in main.py
from slowapi.middleware import SlowAPIMiddleware
# rest of the code
app.add_exception_handler(
    RateLimitExceeded, _rate_limit_exceeded_handler
)
app.add_middleware(SlowAPIMiddleware)</pre> <p>Then, you simply need to specify the default limit in the <strong class="source-inline">Limiter</strong> object instantiation in the <span class="No-Break"><strong class="source-inline">rate_limiter.py</strong></span><span class="No-Break"> module:</span></p>
<pre class="source-code">
limiter = Limiter(
    key_func=get_remote_address,
<strong class="bold">    </strong><strong class="bold">default_limits=["5/minute"],</strong>
)</pre> <p>And that’s it. Now, if you rerun the server and call any of the endpoints more than five times consecutively, you will get a <span class="No-Break"><strong class="source-inline">429</strong></span><span class="No-Break"> response.</span></p>
<p>You have successfully set up a<a id="_idIndexMarker573"/> global rate limiter for your <span class="No-Break">FastAPI application.</span></p>
<h2 id="_idParaDest-286"><a id="_idTextAnchor289"/>See also</h2>
<p>You can find more on <strong class="bold">Slowapi</strong> features such as<a id="_idIndexMarker574"/> shared limits, limiting policies, and more in the official documentation at <span class="No-Break">this link:</span></p>
<ul>
<li><em class="italic">SlowApi </em><span class="No-Break"><em class="italic">documentation</em></span><span class="No-Break">: </span><a href="https://slowapi.readthedocs.io/en/latest/"><span class="No-Break">https://slowapi.readthedocs.io/en/latest/</span></a></li>
</ul>
<p>You can check out more on the syntax of rate limit notation in the <strong class="bold">Limits</strong> project documentation at <span class="No-Break">this link:</span></p>
<ul>
<li><em class="italic">Rate limit string </em><span class="No-Break"><em class="italic">notation</em></span><span class="No-Break">: </span><a href="https://limits.readthedocs.io/en/stable/quickstart.xhtml#rate-limit-string-notation"><span class="No-Break">https://limits.readthedocs.io/en/stable/quickstart.xhtml#rate-limit-string-notation</span></a></li>
</ul>
<h1 id="_idParaDest-287"><a id="_idTextAnchor290"/>Implementing background tasks</h1>
<p>Background tasks are a useful feature that <a id="_idIndexMarker575"/>enables you to delegate resource-intensive operations to separate processes. With background tasks, your application can remain responsive and handle multiple requests simultaneously. They are particularly important for handling long-running processes without blocking the main request-response cycle. This improves the overall efficiency and scalability of your application. In this recipe, we will explore how you can execute background tasks in <span class="No-Break">FastAPI applications.</span></p>
<h2 id="_idParaDest-288"><a id="_idTextAnchor291"/>Getting ready</h2>
<p>To follow this recipe, all you need is a FastAPI application running with at least one endpoint to apply the background task. However, we will implement the background task into our trip platform into the <strong class="source-inline">GET /v2/trips/{category}</strong> endpoint, defined in the <em class="italic">Implementing dependency </em><span class="No-Break"><em class="italic">injection</em></span><span class="No-Break"> recipe.</span></p>
<h2 id="_idParaDest-289"><a id="_idTextAnchor292"/>How to do it…</h2>
<p>Let’s imagine we want to store the message of the <strong class="source-inline">GET /v2/trips/{category}</strong> endpoint in an external <a id="_idIndexMarker576"/>database for analytics purposes. Let's do it in two <span class="No-Break">simple steps.</span></p>
<ol>
<li>First, we define a function that mocks the storing operation in a dedicated module, <strong class="source-inline">background_tasks.py</strong>, in the <strong class="source-inline">app</strong> folder. The function will look like <span class="No-Break">the following:</span><pre class="source-code">
import asyncio
import logging
logger = logging.getLogger("uvicorn.error")
async def store_query_to_external_db(message: str):
    logger.info(f"Storing message '{message}'.")
    await asyncio.sleep(2)
    logger.info(f"Message '{message}' stored!")</pre><p class="list-inset">The storing operation is mocked by an <strong class="source-inline">asyncio.sleep</strong> non-blocking operation. We have also added some log messages to keep track of <span class="No-Break">the execution.</span></p></li> <li>Now, we need to execute the <strong class="source-inline">store_query_to_external_db</strong> function as a background task of our <a id="_idIndexMarker577"/>endpoint. In <strong class="source-inline">main.py</strong>, let’s modify the <strong class="source-inline">GET /v2/trips/cruises</strong>, <span class="No-Break">as follows:</span><pre class="source-code">
<strong class="bold">from fastapi import BackgroundTasks</strong>
@app.get("/v2/trips/{category}")
def get_trips_by_category(
<strong class="bold">    background_tasks: BackgroundTasks,</strong>
    category: Annotated[select_category, Depends()],
    discount_applicable: Annotated[
        bool, Depends(check_coupon_validity)
    ],
):
    category = category.replace("-", " ").title()
    message = f"You requested {category} trips."
    if discount_applicable:
        message += (
            "\n. The coupon code is valid! "
            "You will get a discount!"
        )
<strong class="bold">    background_tasks.add_task(</strong>
<strong class="bold">        store_query_to_external_db, message</strong>
<strong class="bold">    )</strong>
    logger.info(
        "Query sent to background task, "
        "end of request."
    )
    return message</pre></li> </ol>
<p>Now, if you spin up the server with <strong class="source-inline">uvicorn app.main:app</strong> and try to call the <strong class="source-inline">GET /v2/trips/cruises</strong> endpoint, you will see the logs from the <strong class="source-inline">store_query_to_external_db</strong> function <a id="_idIndexMarker578"/>on the <span class="No-Break">terminal output:</span></p>
<pre class="console">
<strong class="bold">INFO:  Query sent to background task, end of request.</strong>
<strong class="bold">INFO:  127.0.0.1:58544 - "GET /v2/trips/cruises</strong>
<strong class="bold">INFO:  Storing message 'You requested Cruises trips.'</strong>
<strong class="bold">INFO:  Message 'You requested Cruises trips.' Stored!</strong></pre> <p>That is all you need to implement background tasks in FastAPI! However, if you have to perform extensive background computations, you might want to use dedicated tools to handle queued task execution. This would allow you to run the tasks in a separate process and avoid any performance issues that may arise from running them in the <span class="No-Break">same process.</span></p>
<h2 id="_idParaDest-290"><a id="_idTextAnchor293"/>How it works…</h2>
<p>When a request is made to the endpoint, the background task is enqueued to the <strong class="source-inline">BackgroundTasks</strong> object. All the tasks are passed to the event loop so that they can be executed concurrently, allowing for non-blocking <span class="No-Break">I/O operations.</span></p>
<p>If you have a task that requires a lot of processing power and doesn’t necessarily need to be completed by the same process, you might want to consider using larger tools such <span class="No-Break">as Celery.</span></p>
<h2 id="_idParaDest-291"><a id="_idTextAnchor294"/>See also</h2>
<p>You can find more on creating background tasks in FastAPI on the official documentation page at <span class="No-Break">this</span><span class="No-Break"><a id="_idIndexMarker579"/></span><span class="No-Break"> link:</span></p>
<ul>
<li><em class="italic">Background </em><span class="No-Break"><em class="italic">Tasks</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/tutorial/background-tasks/"><span class="No-Break">https://fastapi.tiangolo.com/tutorial/background-tasks/</span></a></li>
</ul>
</div>
</div></body></html>