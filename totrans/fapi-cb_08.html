<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-259"><a id="_idTextAnchor262"/>8</h1>
<h1 id="_idParaDest-260"><a id="_idTextAnchor263"/>Advanced Features and Best Practices</h1>
<p>Welcome to <a href="B21025_08.xhtml#_idTextAnchor262"><em class="italic">Chapter 8</em></a>, where we explore advanced techniques and best practices to optimize the functionality, performance, and scalability of FastAPI applications.</p>
<p>In this chapter, by building a trip agency platform, you’ll delve into essential topics such as dependency injection, custom middleware, internationalization, performance optimization, rate limiting, and background task execution. By mastering these advanced features, you’ll be equipped to build robust, efficient, and high-performing APIs with FastAPI.</p>
<p>By the end of this chapter, you’ll have a comprehensive understanding of the advanced FastAPI features and best practices, empowering you to build efficient, scalable, and secure APIs that meet the demands of modern web applications. Let’s dive in and explore these advanced techniques to elevate your FastAPI development skills.</p>
<p>In this chapter, we’re going to cover the following recipes:</p>
<ul>
<li>Implementing dependency injection</li>
<li>Creating custom middleware</li>
<li>Internationalization and localization</li>
<li>Optimizing application performance</li>
<li>Implementing rate limiting</li>
<li>Implementing background tasks</li>
</ul>
<h1 id="_idParaDest-261"><a id="_idTextAnchor264"/>Technical requirements</h1>
<p>To be able to follow the recipes in this chapter, you must have a good grasp of the following essentials:</p>
<ul>
<li><strong class="bold">Python</strong>: You should have a good understanding of Python version 3.7 or higher. You should know how annotation works and about basic class inheritance.</li>
<li><code>fastapi</code><code>asyncio</code><code>async</code>/<code>await</code> syntax.</li>
</ul>
<p>The code used in the chapter is hosted on GitHub at <a href="https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter08">https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter08</a>.</p>
<p>To manage dependencies more efficiently and keep your project isolated, consider creating a virtual environment within the <code>project</code> root folder. You can easily install all the dependencies simultaneously by using the <code>requirements.txt</code> file provided on the GitHub repository in the <code>project</code> folder:</p>
<pre class="console">
$  pip install –r requirements.txt</pre> <p>You can then start with the first recipe and efficiently implement dependency injection in your FastAPI application.</p>
<h1 id="_idParaDest-262"><a id="_idTextAnchor265"/>Implementing dependency injection</h1>
<p><strong class="bold">Dependency injection</strong> is a powerful design pattern used in software development to manage dependencies between components. In the context of FastAPI, dependency injection allows you to efficiently<a id="_idIndexMarker529"/> manage and inject dependencies, such as database connections, authentication services, and configuration settings, into your application’s endpoints and middleware. Although we have already used dependency injection in previous recipes, such as <em class="italic">Setting up SQL databas</em><em class="italic">es</em> in <a href="B21025_02.xhtml#_idTextAnchor052"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Data</em>, or <em class="italic">Setting up user registration</em> in <a href="B21025_04.xhtml#_idTextAnchor122"><em class="italic">Chapter 4</em></a>, <em class="italic">Authentication and Authorization</em>, this recipe will show you how to implement dependency injections in FastAPI and how to tackle trickier use cases with nested dependency injections.</p>
<h2 id="_idParaDest-263"><a id="_idTextAnchor266"/>Getting ready</h2>
<p>To follow along with the recipe, you only need to have Python installed with the <code>fastapi</code> and <code>uvicorn</code> packages installed in your environment, as well as <code>pytest</code>. If you haven’t installed the packages with the <code>requirements.txt</code> file provided in the GitHub repository, you can install them with <code>pip</code> from the command line:</p>
<pre class="console">
$ pip install fastapi uvicorn pytest</pre> <p>Also, it would be beneficial to<a id="_idIndexMarker530"/> know already how to create a simple server in FastAPI. You can refer to the <em class="italic">Creating a </em><em class="italic">new</em><em class="italic"> FastAPI </em><em class="italic">project</em> recipe in <a href="B21025_01.xhtml#_idTextAnchor020"><em class="italic">Chapter 1</em></a>, <em class="italic">First Steps with FastAPI</em>, for more details.</p>
<h2 id="_idParaDest-264"><a id="_idTextAnchor267"/>How to do it…</h2>
<p>Let's start by creating the project root folder called <code>trip_platform</code> containing the <code>app</code> folder. Then let's continue the recipe through the following steps.</p>
<ol>
<li>In the <code>app</code> folder, create the <code>main.py</code> module that will contain the server as:<pre class="source-code">
from fastapi import FastAPI
app = FastAPI()</pre><p class="list-inset">We will write the dependencies in a separate module called <code>dependencies.py</code> inside the <code>app</code> folder.</p></li> <li>Let’s imagine we need to create an endpoint to retrieve all the trips between a start date and an end date. We need to handle two parameters, the start date and end date, and check that the start date is earlier than the end date. Both parameters can be optional; if the start date is not provided, it defaults to the current day.<p class="list-inset">In a dedicated module, <code>dependencies.py</code> in the <code>app</code> folder, let’s define the condition function, which checks that the start date is earlier than the end date:</p><pre class="source-code">
from fastapi import HTTPException
def check_start_end_condition(start: date, end: date):
    if end and end &lt; start:
        raise HTTPException(
            status_code=400,
            detail=(
                "End date must be "
                "greater than start date"
            ),
        )</pre></li> <li>We use the <code>check_start_end_condition</code> function to define the <code>dependable</code> function – namely, the function that will be<a id="_idIndexMarker531"/> used as a dependency – as follows:<pre class="source-code">
from datetime import date, timedelta
from fastapi import Query
def time_range(
    start: date | None = Query(
        default=date.today(),
        description=(
            "If not provided the current date is used"
        ),
        example=date.today().isoformat(),
    ),
    end: date | None = Query(
        None,
        example=date.today() + timedelta(days=7),
    ),
) -&gt; Tuple[date, date | None]:
    check_start_end_condition(start, end)
    return start, end</pre><p class="list-inset">The <code>Query</code> object is used to<a id="_idIndexMarker532"/> manage metadata of the query parameters, such as the default value, description, and example used when generating the documentation.</p></li> <li>We can use the dependable <code>time_range</code> function to create the endpoint in the <code>main.py</code> module. To specify that it is a dependency, we use the <code>Depends</code> object like this:<pre class="source-code">
from fastapi import Depends
@app.get("/v1/trips")
def get_tours(
    time_range = Depends(time_range),
):
    start, end = time_range
    message = f"Request trips from {start}"
    if end:
        return f"{message} to {end}"
    return message</pre><p class="list-inset">You can alternatively use the <code>Annotated</code> class from the <code>typing</code> package to define the dependency as follows:</p><pre class="source-code"><strong class="bold">from typing import Annotated</strong>
from fastapi import Depends
@app.get("/v1/trips")
def get_tours(
<strong class="bold">    time_range: Annotated[time_range, Depends()]</strong>
):</pre></li> </ol>
<p class="callout-heading">Important note</p>
<p class="callout">The use of <code>Annotated</code> in FastAPI is currently evolving to avoid duplicates and improve readability; take a look at the<a id="_idIndexMarker533"/> dedicated documentation section: <a href="https://fastapi.tiangolo.com/tutorial/dependencies/#share-annotated-dependencies">https://fastapi.tiangolo.com/tutorial/dependencies/#share-annotated-dependencies</a>.</p>
<p class="callout">For the rest of the chapter, we will use the latest <code>Annotated</code> convention.</p>
<p>Now, if you spin up the server by running <code>uvicorn app.main:app</code> on the terminal, you will find the endpoint in the interactive documentation at <code>http://localhost:8000/docs</code>. You will see that you just created the endpoint with the parameters correctly documented. The database logic is replaced by a string construction returning a significant message in the example.</p>
<p>You have just implemented a dependency injection strategy to define query parameters for the endpoint. You can use the same strategy to write path or body parameters to write modular and readable code.</p>
<p>One of the advantages of using dependency injection is to logically separate pieces of code that can be replaced by something else, like in testing. Let’s have a look at how to do it.</p>
<h3>Overriding dependency injections in tests</h3>
<p>Let’s create a test for the <code>GET /v1/trips</code> endpoint. If you don’t have <code>pytest</code> in the environment, install it with <code>pip install pytest</code>. Then, under the project root folder, create the <code>pytest.ini</code> file containing <code>pythonpath</code> for <code>pytest</code>, as follows:</p>
<pre class="source-code">
[pytest]
pythonpath=.</pre> <p>The test will be in the<a id="_idIndexMarker534"/> test module, <code>test_main.py</code>, under the <code>tests</code> folder. Let’s write a unit test by overriding the client’s dependency:</p>
<pre class="source-code">
from datetime import date
from fastapi.testclient import TestClient
from app.dependencies import time_range
from app.main import app
def test_get_v1_trips_endpoint():
    client = TestClient(app)
<strong class="bold">    app.dependency_overrides[time_range] = lambda: (</strong>
<strong class="bold">        date.fromisoformat("2024-02-01"),</strong>
<strong class="bold">        None,</strong>
<strong class="bold">    </strong><strong class="bold">)</strong>
    response = client.get("/v1/trips")
    assert (
        response.json()
        == "Request trips from 2024-02-01"
    )</pre> <p>By overriding the <code>time_range</code> dependency, we won’t need to pass the parameters when calling the endpoint, and the<a id="_idIndexMarker535"/> response will depend on the lambda function defined.</p>
<p>Then, you can run the test from the command line:</p>
<pre class="console">
$ pytest tests</pre> <p>This technique is very useful when writing tests that should not interfere with a production database. Also, an eventual heavy computation logic can be mocked if it is not in the test’s interest.</p>
<p>The use of dependency injection can significantly improve test quality by enabling modularity.</p>
<h2 id="_idParaDest-265"><a id="_idTextAnchor268"/>How it works…</h2>
<p>The <code>Depends</code> object and dependency injection leverage Python’s powerful function annotations and type hinting features.</p>
<p>When you define a dependency<a id="_idIndexMarker536"/> function and annotate it with <code>Depends</code>, FastAPI interprets it as a dependency that needs to be resolved before executing the endpoint function. When a request is made to an endpoint that depends on one or more dependencies, FastAPI introspects the endpoint function signature, identifies the dependencies, and resolves them by invoking the corresponding dependency functions in the correct order.</p>
<p>FastAPI uses Python’s type hinting mechanism to determine the type of each dependency parameter and automatically injects the resolved dependency into the endpoint function. This process ensures that the required data or services are available to the endpoint function at runtime, enabling seamless integration of external services, database connections, authentication mechanisms, and other dependencies into FastAPI applications.</p>
<p>Overall, the <code>Depends</code> class and dependency injection in FastAPI provide a clean and efficient way to manage dependencies and promote modular, maintainable code architecture. One of the advantages is that they can be overwritten in testing to be easily mocked or replaced.</p>
<h2 id="_idParaDest-266"><a id="_idTextAnchor269"/>There’s more…</h2>
<p>We can push things further by leveraging sub-dependencies.</p>
<p>Let’s create an endpoint that returns the trips for one of the three categories (cruises, city breaks, and resort stays) and, simultaneously, checks the coupon validity for the category.</p>
<p>In the <code>dependencies.py</code> module, let’s create the <code>dependable</code> function for the category.</p>
<p>Imagine we can group our trips into three categories – cruises, city breaks, and resort stays. We need to add a parameter<a id="_idIndexMarker537"/> to retrieve trips only for a specific category. We will need a <code>dependable</code> function, as follows:</p>
<pre class="source-code">
def select_category(
    category: Annotated[
        str,
        Path(
            description=(
                "Kind of travel "
                "you are interested in"
            ),
            enum=[
                "Cruises",
                "City Breaks",
                "Resort Stay",
            ],
        ),
    ],
) -&gt; str:
    return category</pre> <p>Now, let’s imagine we need to validate a coupon for a discount.</p>
<p>The <code>dependable</code> function<a id="_idIndexMarker538"/> will be used as a dependency for another <code>dependable</code> function that will check the coupon. Let’s define it, as follows:</p>
<pre class="source-code">
def check_coupon_validity(
    category: Annotated[select_category, Depends()],
    code: str | None = Query(
        None, description="Coupon code"
    ),
) -&gt; bool:
    coupon_dict = {
        "cruises": "CRUISE10",
        "city-breaks": "CITYBREAK15",
        "resort-stays": "RESORT20",
    }
    if (
        code is not None
        and coupon_dict.get(category, ...) == code
    ):
        return True
    return False</pre> <p>In the <code>main.py</code> module, let’s define a new endpoint, <code>GET /v2/trips/{category}</code>, that returns the trips for the specified category:</p>
<pre class="source-code">
@app.get("/v2/trips/{category}")
def get_trips_by_category(
    category: Annotated[select_category, Depends()],
    discount_applicable: Annotated[
        bool, Depends(check_coupon_validity)
    ],
):
    category = category.replace("-", " ").title()
    message = f"You requested {category} trips."
    if discount_applicable:
        message += (
            "\n. The coupon code is valid! "
            "You will get a discount!"
        )
    return message</pre> <p>If you run the server with the <code>uvicorn app.main:app</code> command and open the interactive documentation at <code>http://localhost:8000/docs</code>, you will see the new endpoint. The accepted<a id="_idIndexMarker539"/> parameters, <code>category</code> and <code>code</code>, both come from the dependencies, and the <code>category</code> parameter is not repeated within the code.</p>
<p class="callout-heading">Important note</p>
<p class="callout">You can use both <code>def</code> and <code>async def</code> keywords to declare dependencies, whether they are synchronous or asynchronous functions respectively. FastAPI will handle them automatically.</p>
<p>You have just created an endpoint that uses nested dependencies. By using nested dependencies and sub-dependencies, you will be able to write clear and modular code that is easier to read and maintain.</p>
<p class="callout-heading">Exercise</p>
<p class="callout">In FastAPI, dependencies can be also created as a class. Check out the documentation at <a href="https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/#classes-as-dependencies">https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/#classes-as-dependencies</a>, and create a new endpoint that uses all the parameters we defined in the recipe (<code>time_range</code>, <code>category</code>, and <code>code</code>). </p>
<p class="callout">Group all the parameters into a class, and define and use it as a dependency for the endpoint.</p>
<h2 id="_idParaDest-267"><a id="_idTextAnchor270"/>See also</h2>
<p>We have used <code>Query</code> and <code>Path</code> descriptor<a id="_idIndexMarker540"/> objects to set metadata and documentation-related data for <code>query</code> and <code>path</code> parameters, respectively. You can discover more about their potential at these documentation links:</p>
<ul>
<li><em class="italic">Query Parameters and String </em><em class="italic">Validations</em>: <a href="https://fastapi.tiangolo.com/tutorial/query-params-str-validations/">https://fastapi.tiangolo.com/tutorial/query-params-str-validations/</a></li>
<li><em class="italic">Path Parameters and Numeric </em><em class="italic">Validations</em>: <a href="https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/">https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/</a></li>
</ul>
<p>For dependency injections in FastAPI, you can find extensive documentation covering all the possible usages, explaining the potential of this powerful feature:</p>
<ul>
<li><em class="italic">Dependencies</em>: <a href="https://fastapi.tiangolo.com/tutorial/dependencies/">https://fastapi.tiangolo.com/tutorial/dependencies/</a></li>
<li><em class="italic">Advanced </em><em class="italic">Dependencies</em>: <a href="https://fastapi.tiangolo.com/advanced/advanced-dependencies/">https://fastapi.tiangolo.com/advanced/advanced-dependencies/</a></li>
<li><em class="italic">Testing Dependencies with </em><em class="italic">Overrides</em>: <a href="https://fastapi.tiangolo.com/advanced/testing-dependencies/">https://fastapi.tiangolo.com/advanced/testing-dependencies/</a></li>
</ul>
<h1 id="_idParaDest-268"><a id="_idTextAnchor271"/>Creating custom middleware</h1>
<p><strong class="bold">Middleware</strong> is an API component that allows <a id="_idIndexMarker541"/>you to intercept and modify incoming requests and outgoing responses, making it a powerful tool for implementing cross-cutting concerns such as authentication, logging, and error handling.</p>
<p>In this recipe, we’ll explore how to develop custom middleware to process requests and responses in FastAPI applications and retrieve information on the client.</p>
<h2 id="_idParaDest-269"><a id="_idTextAnchor272"/>Getting ready…</h2>
<p>All you need is to have a running FastAPI application. The recipe will use our trip platform defined in the previous recipe, <em class="italic">Implementing dependency injection</em>. However, middleware works for a generic running application.</p>
<h2 id="_idParaDest-270"><a id="_idTextAnchor273"/>How to do it…</h2>
<p>We will show you how to<a id="_idIndexMarker542"/> create a custom middleware object class that we will use in our application through the following steps.</p>
<ol>
<li>Let’s create a dedicated module in the app folder called <code>middleware.py</code>.<p class="list-inset">We want the middleware to intercept the request and print the host client and the method on the output terminal. In a real application scenario, this information can be stored in a database for analytics or used for security inspection purposes.</p><p class="list-inset">Let’s use the same <code>uvicorn</code> logger used by FastAPI by default:</p><pre class="source-code">
import logging
logger = logging.getLogger("uvicorn.error")</pre></li> <li>Then, let’s create our <code>ClientInfoMiddleware</code> class, as follows:<pre class="source-code">
from fastapi import Request
from starlette.middleware.base import BaseHTTPMiddleware
class ClientInfoMiddleware(BaseHTTPMiddleware):
    async def dispatch(
        self, request: Request, call_next
    ):
        host_client = request.client.host
        requested_path = request.url.path
        method = request.method
        logger.info(
            f"host client {host_client} "
            f"requested {method} {requested_path} "
            "endpoint"
        )
        return await call_next(request)</pre></li> <li>Then, we need to add our middleware to the FastAPI server in <code>main.py</code>. After defining the app server, we <a id="_idIndexMarker543"/>can add the middleware with the <code>add_middleware</code> method:<pre class="source-code">
# main.py import modules
from app.middleware import ClientInfoMiddleware
app = FastAPI()
<strong class="bold">app.add_middleware(ClientInfoMiddleware)</strong>
# rest of the code</pre></li> </ol>
<p>Now, spin up the server with the <code>uvicorn app.main:app</code> command, and try to connect to a subpath of <code>http://localhost:8000/v1/trips</code>. You don’t even need to call an existing endpoint. You will see the log messages in the application output terminal:</p>
<pre class="console">
<strong class="bold">INFO:host client 127.0.0.1 requested GET /v1/trips endpoint</strong></pre> <p>You have just implemented a basic custom middleware to retrieve information about the client. You can increase the<a id="_idIndexMarker544"/> complexity by adding more operations, such as redirecting requests based on the IP and integrating IP blocking or filtering.</p>
<h2 id="_idParaDest-271"><a id="_idTextAnchor274"/>How it works…</h2>
<p>FastAPI uses the <code>BasicHTTPMiddleware</code> class from the <code>Starlette</code> library. The strategy shown in the recipe creates a class derived from <code>BasicHTTPMiddleware</code>, with a specific <code>dispatch</code> method that implements the interception operation.</p>
<p>To create a middleware in FastAPI, you can add a decorator from the FastAPI class methods to a simple function. However, it is recommended to create a class, as it allows for better modularity and organization of the code. By creating a class, you can eventually create your collection module of middleware.</p>
<h2 id="_idParaDest-272"><a id="_idTextAnchor275"/>See also</h2>
<p>You can have a look at how to create a custom middleware on the official documentation page at the following link:</p>
<ul>
<li><em class="italic">FastAPI Middleware </em><em class="italic">documentation</em>: <a href="https://fastapi.tiangolo.com/tutorial/middleware/">https://fastapi.tiangolo.com/tutorial/middleware/</a></li>
</ul>
<p>An interesting discussion on how to <a id="_idIndexMarker545"/>create middleware classes in FastAPI can be found on the <strong class="bold">Stack </strong><strong class="bold">Overflow</strong> website:</p>
<ul>
<li><em class="italic">Create FastAPI Custom Middleware Class </em><em class="italic">Discussion</em>: <a href="https://stackoverflow.com/questions/71525132/how-to-write-a-custom-fastapi-middleware-class">https://stackoverflow.com/questions/71525132/how-to-write-a-custom-fastapi-middleware-class</a></li>
</ul>
<h1 id="_idParaDest-273"><a id="_idTextAnchor276"/>Internationalization and localization</h1>
<p><strong class="bold">Internationalization</strong> (<strong class="bold">i18n</strong>) and <strong class="bold">localization</strong> (<strong class="bold">l10n</strong>) are fundamental concepts in software development that <a id="_idIndexMarker546"/>enable applications to be adapted for <a id="_idIndexMarker547"/>different languages, regions, and cultures.</p>
<p><strong class="bold">i18n</strong> refers to the process of designing and developing software or products that can be adapted to different languages and cultures. This process mainly involves providing content in a specific language. Conversely, <strong class="bold">l10n</strong> involves adapting a product or content for a specific locale or market, such as currency or a unit of measure.</p>
<p>The <code>Accept-Language</code> header to implement i18n and l10n in our trip platform. This will enable our platform to provide targeted content to the client.</p>
<h2 id="_idParaDest-274"><a id="_idTextAnchor277"/>Getting ready</h2>
<p>It would be beneficial to have some knowledge of the <code>Accept-Language</code> header; take a look at this interesting article from Mozilla’s documentation: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language</a>.</p>
<p>You need to have a running FastAPI application to follow the recipe. You can follow along with the trip platform application used throughout the chapter.</p>
<p>We will make use of dependency injection, so it will be beneficial to complete the <em class="italic">Implementing dependency injection</em> recipe from this chapter.</p>
<p>Also, we will use the <code>babel</code> package to resolve language code references, so if haven’t installed the packages with the <code>requirements.txt</code> file, make sure to have <code>babel</code> in your environment by running the following:</p>
<pre class="console">
$ pip install babel</pre> <p>Once the installation is completed, you have all you need to start the recipe.</p>
<h2 id="_idParaDest-275"><a id="_idTextAnchor278"/>How to do it…</h2>
<p>To begin with, we must determine which regions and languages we wish to cater to. For this example, we will focus on two – <strong class="bold">American English</strong> (<strong class="bold">en_US</strong>) and <strong class="bold">French from France</strong> (<strong class="bold">fr_FR</strong>). All content pertaining to language will be in one of these two languages.</p>
<p>It is necessary to manage the <code>Accept-Language</code> header on the host client side, which is a list of languages <a id="_idIndexMarker549"/>with a preference weight parameter.</p>
<p>Examples of the header are <a id="_idIndexMarker550"/>as follows:</p>
<pre class="source-code">
Accept-Language: en
Accept-Language: en, fr
Accept-Language: en-US
Accept-Language: en-US;q=0.8, fr;q=0.5
Accept-Language: en, *
Accept-Language: en-US, en-GB
Accept-Language: zh-Hans-CN</pre> <p>We need a function that takes as an argument the header and the list of available languages in our app, returning the most appropriate one Let's implement it by applying the following steps.</p>
<ol>
<li>Create a dedicated module, <code>internationalization.py</code>, under the <code>app</code> folder.<p class="list-inset">First, we store the supported languages in a variable, as follows:</p><pre class="source-code">
SUPPORTED_LOCALES = [
    "en_US",
    "fr_FR",
]</pre></li> <li>Then, we start defining the <code>resolve_accept_lanugage</code> function, as follows:<pre class="source-code">
from babel import Locale, negotiate_locale
def resolve_accept_language(
    accept_language: str = Header("en-US"),
) -&gt; Locale:</pre></li> <li>Within the function, we<a id="_idIndexMarker551"/> parse the string into a list:<pre class="source-code">
    client_locales = []
    for language_q in accept_language.split(","):
        if ";q=" in language_q:
            language, q = language_q.split(";q=")
        else:
            language, q = (language_q, float("inf"))
        try:
            Locale.parse(language, sep="-")
            client_locales.append(
                (language, float(q))
            )
        except ValueError:
            continue</pre></li> <li>We then sort the string<a id="_idIndexMarker552"/> according to the preference <code>q</code> parameter:<pre class="source-code">
    client_locales.sort(
        key=lambda x: x[1], reverse=True
    )
    locales = [locale for locale, _ in client_locales]</pre></li> <li>Then, we use <code>negotiate_locale</code> from the <code>babel</code> package to get the most suited language:<pre class="source-code">
    locale = negotiate_locale(
        [str(locale) for locale in locales],
        SUPPORTED_LOCALES,
    )</pre></li> <li>If there is no match, we<a id="_idIndexMarker553"/> return <code>en_US</code> as default:<pre class="source-code">
    if locale is None:
        locale = "en_US"
    return locale</pre><p class="list-inset">The <code>resolve_accept_language</code> function will be used as a dependency for the endpoints that return <a id="_idIndexMarker554"/>content based on the language.</p></li> <li>In the same <code>internationalization.py</code> module, let’s create a <code>GET /homepage</code> endpoint that returns a welcome string, depending on the language. We will do it in a separate <code>APIRouter</code>, so the router will be as follows:<pre class="source-code">
from fastapi import APIRouter
router = APIRouter(
    tags=["Localizad Content Endpoints"]
)</pre><p class="list-inset">The <code>tags</code> parameter specifies that the router’s endpoint will be grouped separately in the interactive <a id="_idIndexMarker555"/>documentation under a specified tag name.</p><p class="list-inset">The <code>GET /home</code> endpoint <a id="_idIndexMarker556"/>will be as follows:</p><pre class="source-code">home_page_content = {
    "en_US": "Welcome to Trip Platform",
    "fr_FR": "Bienvenue sur Trip Platform",
}
@router.get("/homepage")
async def home(
    request: Request,
    language: Annotated[
        resolve_accept_language, Depends()
    ],
):
    return {"message": home_page_content[language]}</pre><p class="list-inset">In the example, the content has been hardcoded as a <code>dict</code> object with language code as a dictionary key.</p><p class="list-inset">In a real-world scenario, the content should be stored in a database for each language.</p><p class="list-inset">Similarly, you define a localization strategy to retrieve the currency.</p></li> <li>Let’s create a <code>GET /show/currency</code> endpoint as an example that uses a dependency to retrieve the currency from the <code>Accept-Language</code> header. The <code>dependency</code> function can<a id="_idIndexMarker557"/> be defined as follows:<pre class="source-code">
async def get_currency(
    language: Annotated[
        resolve_accept_language, Depends()
    ],
):
    currencies = {
        "en_US": "USD",
        "fr_FR": "EUR",
    }
    return currencies[language]</pre><p class="list-inset">The endpoint will then be as <a id="_idIndexMarker558"/>follows:</p><pre class="source-code">from babel.numbers import get_currency_name
@router.get("/show/currency")
async def show_currency(
    currency: Annotated[get_currency, Depends()],
    language: Annotated[
        resolve_accept_language,
        Depends(use_cache=True)
    ],
):
    currency_name = get_currency_name(
        currency, locale=language
    )
    return {
        "currency": currency,
        "currency_name": currency_name,
    }</pre></li> <li>To use both endpoints, we <a id="_idIndexMarker559"/>will need to add the router to<a id="_idIndexMarker560"/> the FastAPI object in <code>main.py</code>:<pre class="source-code">
from app import internationalization
# rest of the code
app.include_router(internationalization.router)</pre></li> </ol>
<p>This is all you need to implement internationalization and localization. To test it, spin up the server from the command line by running:</p>
<pre class="console">
<code>http:localhost:8000/docs</code>, you will find the <code>GET</code> <code>/homepage</code> and <code>GET</code> <code>/show/currency</code> endpoints. Both accept the <code>Accept-Language</code> header to provide the language choice; if you don’t, it will get the default language from the browser. To test the implementation, try experimenting with different values for the header.</p>
<p>You have successfully implemented internationalization and localization from scratch for your API. Using the recipe provided, you have integrated i18n and l10n into your applications, making them easily understandable worldwide.</p>
<h2 id="_idParaDest-276"><a id="_idTextAnchor279"/>See also</h2>
<p>You can find out more about the potential of <code>Babel</code> package on the official documentation page: <a href="https://babel.pocoo.org/en/latest/">https://babel.pocoo.org/en/latest/</a>.</p>
<h1 id="_idParaDest-277"><a id="_idTextAnchor280"/>Optimizing application performance</h1>
<p>Optimizing FastAPI applications is crucial for ensuring high performance and scalability, especially under heavy loads.</p>
<p>In this recipe, we’ll see a technique<a id="_idIndexMarker561"/> to profile our FastAPI application and explore actionable strategies to optimize performances. By the end of the recipe, you will be able to detect code bottlenecks and optimize your application.</p>
<h2 id="_idParaDest-278"><a id="_idTextAnchor281"/>Getting ready</h2>
<p>Before starting the recipe, make sure to have a FastAPI application running with some endpoints already set up. You can follow along with our trip platform application.</p>
<p>We will be using the <code>pyinstrument</code> package to set up a profiler for the application. If you haven’t installed the packages with <code>requirements.txt</code>, you can install <code>pyinstrument</code> in your environment by running the following:</p>
<pre class="console">
$ pip install pyinstrument</pre> <p>Also, it can be useful to have a look at the <em class="italic">Creating </em><em class="italic">custom middleware</em> recipe from earlier in the chapter.</p>
<h2 id="_idParaDest-279"><a id="_idTextAnchor282"/>How to do it…</h2>
<p>Let's implement the profiler in simple steps.</p>
<ol>
<li>Under the app folder, create a <code>profiler.py</code> module as follows:<pre class="source-code">
from pyinstrument import Profiler
profiler = Profiler(
    interval=0.001, async_mode="enabled"
)</pre><p class="list-inset">The <code>async_mode="enabled"</code> parameter specifies that the profiler logs the time each time it encounters an <code>await</code> statement in the function being awaited, rather than observing other coroutines or the event loop. The <code>interval</code> specifies the time between two samples.</p></li> <li>Before using the profiler, we <a id="_idIndexMarker562"/>should plan what we want to profile. Let’s plan to profile only the code executed in the endpoints. To do this, we can create simple middleware in a separate module that starts and stops the profiler before and after each call, respectively. We can create the middleware in the same <code>profiler.py</code> module, as follows:<pre class="source-code">
from starlette.middleware.base import (
    BaseHTTPMiddleware
)
class ProfileEndpointsMiddleWare(
    BaseHTTPMiddleware
):
    async def dispatch(
        self, request: Request, call_next
    ):
        if not profiler.is_running:
            profiler.start()
        response = await call_next(request)
        if profiler.is_running:
            profiler.stop()
            profiler.write_html(
                os.getcwd() + "/profiler.xhtml"
            )
            profiler.start()
        return response</pre><p class="list-inset">The profiler is initiated every time an endpoint is requested, and it is terminated after the request is complete. However, since the server operates asynchronously, there is a possibility that the profiler may already be running, due to another endpoint request. This can result in errors during the start and stop of the profiler. To prevent<a id="_idIndexMarker563"/> this, we verify before each request whether the profiler is not already running. After the request, we check whether the profiler is running before terminating it.</p></li> <li>You can attach the profiler to the FastAPI server by adding the middleware in the <code>main.py</code> module, as we did in the <em class="italic">Creating custom </em><em class="italic">middleware</em> recipe:<pre class="source-code">
app.add_middleware(ProfileEndpointsMiddleWare)</pre></li> </ol>
<p>To test the profiler, spin up the server by running <code>uvicorn app.main:app</code>. Once you start making some calls, you can do it from the interactive documentation at http://localhost:8000/docs. Then, a <code>profiler.xhtml</code> file will be created. You can open the file with a simple browser and check the status of the code.</p>
<p>You have just integrated a profiler into your FastAPI application.</p>
<h2 id="_idParaDest-280"><a id="_idTextAnchor283"/>There’s more...</h2>
<p>Integrating a profiler is the first step that allows you to spot code bottlenecks and optimize the performance of your application.</p>
<p>Let’s explore some techniques to optimize the performance of your FastAPI performances:</p>
<ul>
<li><code>Starlette</code> library and supports asynchronous <a id="_idIndexMarker564"/>request handlers, using the <code>async</code> and <code>await</code> keywords. By leveraging asynchronous programming, you can maximize CPU and <strong class="bold">input/output</strong> (<strong class="bold">I/O</strong>) utilization, reducing<a id="_idIndexMarker565"/> response times and improving scalability.</li>
<li><strong class="bold">Scaling Uvicorn workers</strong>: Increasing the number of Uvicorn workers distributes incoming requests across <a id="_idIndexMarker566"/>multiple processes. However, it might not be always the best solution. For purely I/O operations, asynchronous programming massively reduces CPU usage, and additional workers remain idle. Before adding additional workers, check the CPU usage of the main process.</li>
<li><strong class="bold">Caching</strong>: Implement caching<a id="_idIndexMarker567"/> mechanisms to store and reuse frequently accessed data, reducing database queries and computation overhead. Use dedicated libraries l to integrate caching into your FastAPI applications.</li>
</ul>
<p>Other techniques are related to external libraries or tools, and whatever strategy you use, make sure to properly validate it with proper profiling configuration.</p>
<p>Also, for high-traffic testing, take a look at the <em class="italic">Performance testing for high traffic applications</em> recipe in <a href="B21025_05.xhtml#_idTextAnchor157"><em class="italic">Chapter 5</em></a>, <em class="italic">Testing and Debugging </em><em class="italic">FastAPI Applications</em>.</p>
<p class="callout-heading">Exercise</p>
<p class="callout">We learned how to configure middleware to profile applications; however, it is more common to create tests to profile specific use cases. We learned how to configure middleware to profile applications; however, it is more common to create test scripts to profile specific use cases. Try to create one by yourself that attaches the profiler to the server, runs the server, makes API calls that reproduce the use case, and finally, writes the profiler output. The solution is provided on the GitHub repository in the <code>profiling_application.py</code> file. You can find it at <a href="https://github.com/PacktPublishing/FastAPI-Cookbook/blob/main/Chapter08/trip_platform/profiling_application.py">https://github.com/PacktPublishing/FastAPI-Cookbook/blob/main/Chapter08/trip_platform/profiling_application.py</a>.</p>
<h2 id="_idParaDest-281"><a id="_idTextAnchor284"/>See also</h2>
<p>You can discover more<a id="_idIndexMarker568"/> about the potential of <strong class="bold">pyinstrument</strong> profiler on the official documentation:</p>
<ul>
<li><em class="italic">pyinstrument</em> <em class="italic">documentation</em>: <a href="https://pyinstrument.readthedocs.io/en/latest/">https://pyinstrument.readthedocs.io/en/latest/</a></li>
</ul>
<p>Also, you can find a different approach to profile FastAPI endpoints on the page:</p>
<ul>
<li><em class="italic">pyinstrument – profiling FastAPI </em><em class="italic">requests</em>: <a href="https://pyinstrument.readthedocs.io/en/latest/guide.xhtml#profile-a-web-request-in-fastapi">https://pyinstrument.readthedocs.io/en/latest/guide.xhtml#profile-a-web-request-in-fastapi</a></li>
</ul>
<h1 id="_idParaDest-282"><a id="_idTextAnchor285"/>Implementing rate limiting</h1>
<p><strong class="bold">Rate limiting</strong> is an essential technique used to control and manage the flow of traffic to web applications, ensuring <a id="_idIndexMarker569"/>optimal performance, resource utilization, and protection against abuse or overload. In this recipe, we’ll explore how to implement rate limiting in FastAPI applications to safeguard against potential abuse, mitigate security risks, and optimize application responsiveness. By the end of this recipe, you’ll have a solid understanding of how to leverage rate limiting to enhance the security, reliability, and scalability of your FastAPI applications, ensuring optimal performance under varying traffic conditions and usage patterns.</p>
<h2 id="_idParaDest-283"><a id="_idTextAnchor286"/>Getting ready</h2>
<p>To follow the recipe, you need a running FastAPI application with some endpoints to use for rate limiting. To implement rate limiting, we will use the <code>slowapi</code> package; if you haven’t installed the packages with the <code>requirements.txt</code> file provided in the GitHub repository, you can install <code>slowapi</code> in your environment with <code>pip</code> by running the following:</p>
<pre class="console">
$ pip install slowapi</pre> <p>Once the installation is completed, you are ready to start the recipe.</p>
<h2 id="_idParaDest-284"><a id="_idTextAnchor287"/>How to do it…</h2>
<p>We will start by applying a<a id="_idIndexMarker570"/> rate limiter to a single endpoint in simple steps.</p>
<ol>
<li>Let’s create the <code>rate_limiter.py</code> module under the <code>app</code> folder that contains our limiter object class defined as follows:<pre class="source-code">
from slowapi import Limiter
from slowapi.util import get_remote_address
limiter = Limiter(
    key_func=get_remote_address,
)</pre><p class="list-inset">The limiter is designed to restrict the number of requests from a client based on their IP address. It is possible to create a function that can detect a user’s credentials and limit their calls according to their specific user profile. However, for the purpose of this example, we will use the client’s IP address to implement the limiter.</p></li> <li>Now, we need to configure the FastAPI server to implement the limiter. In <code>main.py</code>, we have to add the following configuration:<pre class="source-code">
from slowapi import _rate_limit_exceeded_handler
from slowapi.errors import RateLimitExceeded
# rest of the code
app.state.limiter = limiter
app.add_exception_handler(
    RateLimitExceeded, _rate_limit_exceeded_handler
)
# rest of the code</pre></li> <li>Now, we will apply a rate<a id="_idIndexMarker571"/> limit of two requests per minute to the <code>GET /homepage</code> endpoint defined in the <code>internalization.py</code> module:<pre class="source-code">
<strong class="bold">from fastapi import Request</strong>
<strong class="bold">from app.rate_limiter import limiter</strong>
@router.get("/homepage")
<strong class="bold">@limiter.limit("2/minute")</strong>
async def home(
<strong class="bold">    request: Request,</strong>
    language: Annotated[
        resolve_accept_language, Depends()
    ],
):
    return {"message": home_page_content[language]}</pre><p class="list-inset">The rate limit is applied as a decorator. Also, the request parameter needs to be added to make the limiter work.</p></li> </ol>
<p>Now, spin up the server from the command line by running the following:</p>
<pre class="console">
<code>http://localhost:8000/homepage</code>; you will get the home page content, and by the third call, you will get a <code>429</code> response with the<a id="_idIndexMarker572"/> following content:</p>
<pre class="console">
{
    "error": "Rate limit exceeded: 2 per 1 minute"
}</pre> <p>You’ve just added a limit rate to the <code>GET /homepage</code> endpoint. With the same strategy, you can add a specific rate limiter to each endpoint.</p>
<h2 id="_idParaDest-285"><a id="_idTextAnchor288"/>There's more...</h2>
<p>You can do more by adding a global rate limit to the entire application, as follows.</p>
<p>In <code>main.py</code>, you need to add a dedicated middleware, as follows:</p>
<pre class="source-code">
# rest of the code in main.py
from slowapi.middleware import SlowAPIMiddleware
# rest of the code
app.add_exception_handler(
    RateLimitExceeded, _rate_limit_exceeded_handler
)
app.add_middleware(SlowAPIMiddleware)</pre> <p>Then, you simply need to specify the default limit in the <code>Limiter</code> object instantiation in the <code>rate_limiter.py</code> module:</p>
<pre class="source-code">
limiter = Limiter(
    key_func=get_remote_address,
<strong class="bold">    </strong><strong class="bold">default_limits=["5/minute"],</strong>
)</pre> <p>And that’s it. Now, if you rerun the server and call any of the endpoints more than five times consecutively, you will get a <code>429</code> response.</p>
<p>You have successfully set up a<a id="_idIndexMarker573"/> global rate limiter for your FastAPI application.</p>
<h2 id="_idParaDest-286"><a id="_idTextAnchor289"/>See also</h2>
<p>You can find more on <strong class="bold">Slowapi</strong> features such as<a id="_idIndexMarker574"/> shared limits, limiting policies, and more in the official documentation at this link:</p>
<ul>
<li><em class="italic">SlowApi </em><em class="italic">documentation</em>: <a href="https://slowapi.readthedocs.io/en/latest/">https://slowapi.readthedocs.io/en/latest/</a></li>
</ul>
<p>You can check out more on the syntax of rate limit notation in the <strong class="bold">Limits</strong> project documentation at this link:</p>
<ul>
<li><em class="italic">Rate limit string </em><em class="italic">notation</em>: <a href="https://limits.readthedocs.io/en/stable/quickstart.xhtml#rate-limit-string-notation">https://limits.readthedocs.io/en/stable/quickstart.xhtml#rate-limit-string-notation</a></li>
</ul>
<h1 id="_idParaDest-287"><a id="_idTextAnchor290"/>Implementing background tasks</h1>
<p>Background tasks are a useful feature that <a id="_idIndexMarker575"/>enables you to delegate resource-intensive operations to separate processes. With background tasks, your application can remain responsive and handle multiple requests simultaneously. They are particularly important for handling long-running processes without blocking the main request-response cycle. This improves the overall efficiency and scalability of your application. In this recipe, we will explore how you can execute background tasks in FastAPI applications.</p>
<h2 id="_idParaDest-288"><a id="_idTextAnchor291"/>Getting ready</h2>
<p>To follow this recipe, all you need is a FastAPI application running with at least one endpoint to apply the background task. However, we will implement the background task into our trip platform into the <code>GET /v2/trips/{category}</code> endpoint, defined in the <em class="italic">Implementing dependency </em><em class="italic">injection</em> recipe.</p>
<h2 id="_idParaDest-289"><a id="_idTextAnchor292"/>How to do it…</h2>
<p>Let’s imagine we want to store the message of the <code>GET /v2/trips/{category}</code> endpoint in an external <a id="_idIndexMarker576"/>database for analytics purposes. Let's do it in two simple steps.</p>
<ol>
<li>First, we define a function that mocks the storing operation in a dedicated module, <code>background_tasks.py</code>, in the <code>app</code> folder. The function will look like the following:<pre class="source-code">
import asyncio
import logging
logger = logging.getLogger("uvicorn.error")
async def store_query_to_external_db(message: str):
    logger.info(f"Storing message '{message}'.")
    await asyncio.sleep(2)
    logger.info(f"Message '{message}' stored!")</pre><p class="list-inset">The storing operation is mocked by an <code>asyncio.sleep</code> non-blocking operation. We have also added some log messages to keep track of the execution.</p></li> <li>Now, we need to execute the <code>store_query_to_external_db</code> function as a background task of our <a id="_idIndexMarker577"/>endpoint. In <code>main.py</code>, let’s modify the <code>GET /v2/trips/cruises</code>, as follows:<pre class="source-code">
<strong class="bold">from fastapi import BackgroundTasks</strong>
@app.get("/v2/trips/{category}")
def get_trips_by_category(
<strong class="bold">    background_tasks: BackgroundTasks,</strong>
    category: Annotated[select_category, Depends()],
    discount_applicable: Annotated[
        bool, Depends(check_coupon_validity)
    ],
):
    category = category.replace("-", " ").title()
    message = f"You requested {category} trips."
    if discount_applicable:
        message += (
            "\n. The coupon code is valid! "
            "You will get a discount!"
        )
<strong class="bold">    background_tasks.add_task(</strong>
<strong class="bold">        store_query_to_external_db, message</strong>
<strong class="bold">    )</strong>
    logger.info(
        "Query sent to background task, "
        "end of request."
    )
    return message</pre></li> </ol>
<p>Now, if you spin up the server with <code>uvicorn app.main:app</code> and try to call the <code>GET /v2/trips/cruises</code> endpoint, you will see the logs from the <code>store_query_to_external_db</code> function <a id="_idIndexMarker578"/>on the terminal output:</p>
<pre class="console">
<strong class="bold">INFO:  Query sent to background task, end of request.</strong>
<strong class="bold">INFO:  127.0.0.1:58544 - "GET /v2/trips/cruises</strong>
<strong class="bold">INFO:  Storing message 'You requested Cruises trips.'</strong>
<strong class="bold">INFO:  Message 'You requested Cruises trips.' Stored!</strong></pre> <p>That is all you need to implement background tasks in FastAPI! However, if you have to perform extensive background computations, you might want to use dedicated tools to handle queued task execution. This would allow you to run the tasks in a separate process and avoid any performance issues that may arise from running them in the same process.</p>
<h2 id="_idParaDest-290"><a id="_idTextAnchor293"/>How it works…</h2>
<p>When a request is made to the endpoint, the background task is enqueued to the <code>BackgroundTasks</code> object. All the tasks are passed to the event loop so that they can be executed concurrently, allowing for non-blocking I/O operations.</p>
<p>If you have a task that requires a lot of processing power and doesn’t necessarily need to be completed by the same process, you might want to consider using larger tools such as Celery.</p>
<h2 id="_idParaDest-291"><a id="_idTextAnchor294"/>See also</h2>
<p>You can find more on creating background tasks in FastAPI on the official documentation page at this<a id="_idIndexMarker579"/> link:</p>
<ul>
<li><em class="italic">Background </em><em class="italic">Tasks</em>: <a href="https://fastapi.tiangolo.com/tutorial/background-tasks/">https://fastapi.tiangolo.com/tutorial/background-tasks/</a></li>
</ul>
</div>
</div></body></html>