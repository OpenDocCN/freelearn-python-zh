<html><head></head><body>
<div id="_idContainer018">
<h1 class="chapter-number" id="_idParaDest-75"><a id="_idTextAnchor129"/><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-76"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.2.1">Data Modeling in Flask</span></h1>
<p><span class="koboSpan" id="kobo.3.1">This chapter covers one of the most important aspects of any application, which is the interaction with the database systems. </span><span class="koboSpan" id="kobo.3.2">In this chapter, you will see how Flask can connect to database systems, define models, and query the databases for the retrieval and feeding of data. </span><span class="koboSpan" id="kobo.3.3">Flask has been designed to be flexible enough to support any database. </span><span class="koboSpan" id="kobo.3.4">The simplest way would be to use the direct </span><strong class="source-inline"><span class="koboSpan" id="kobo.4.1">SQLite3</span></strong><span class="koboSpan" id="kobo.5.1"> package, which is a </span><em class="italic"><span class="koboSpan" id="kobo.6.1">DB-API 2.0</span></em><span class="koboSpan" id="kobo.7.1"> interface and </span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.8.1">does not give an actual </span><strong class="bold"><span class="koboSpan" id="kobo.9.1">object-relational mapping</span></strong><span class="koboSpan" id="kobo.10.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.11.1">ORM</span></strong><span class="koboSpan" id="kobo.12.1">). </span><span class="koboSpan" id="kobo.12.2">Here, we need to write SQL queries to talk with the database. </span><span class="koboSpan" id="kobo.12.3">This approach is not recommended for large projects, as it can eventually become a nightmare to maintain the application. </span><span class="koboSpan" id="kobo.12.4">Also, with this approach, the models are virtually non-existent and everything happens in the view functions, and it is not a good practice to write database queries in your </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">view functions.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">In this chapter, we will talk about creating an ORM layer for our Flask applications with SQLAlchemy for relational database systems, which is recommended and widely used for applications of any size. </span><span class="koboSpan" id="kobo.14.2">Also, we will have a glance over how to write a Flask app with a NoSQL </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">database system.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.16.1">Information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.17.1">ORM implies how our application’s data models store and deal with data at a conceptual level. </span><span class="koboSpan" id="kobo.17.2">A powerful ORM makes the designing and querying of business logic easy </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">and streamlined.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">following recipes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.21.1">Creating an SQLAlchemy </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">DB instance</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Creating a basic </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">product model</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Creating a relational </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">category model</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Migrating databases using Alembic </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">and Flask-Migrate</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">Indexing model data </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">with Redis</span></span></li>
<li><span class="koboSpan" id="kobo.31.1">Opting for the NoSQL way </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">with MongoDB</span></span><a id="_idTextAnchor132"/></li>
</ul>
<h1 id="_idParaDest-77"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.33.1">Creating an SQLAlchemy DB instance</span></h1>
<p><span class="koboSpan" id="kobo.34.1">SQLAlchemy is a Python SQL toolkit and provides ORM, which combines the flexibility and power of SQL </span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.35.1">with the feel of Python’s object-oriented nature. </span><span class="koboSpan" id="kobo.35.2">In this recipe, we will understand how to create an SQLAlchemy database instance that can be used to perform any database operation that shall be covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">future recipes</span><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.37.1">.</span></span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.38.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.39.1">Flask-SQLAlchemy is the extension that provides the SQLAlchemy interface for Flask. </span><span class="koboSpan" id="kobo.39.2">This extension can simply be installed by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">pip</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.41.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.42.1">
$ pip install flask-sqlalchemy</span></pre>
<p><span class="koboSpan" id="kobo.43.1">The first thing to keep in mind with Flask-SQLAlchemy is the application configuration parameter, which tells SQLAlchemy about the location of the database to </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">be used:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.45.1">
app.config['SQLALCHEMY_DATABASE_URI'] =
  os.environ('DATABASE_URI')</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">SQLALCHEMY_DATABASE_URI</span></strong><span class="koboSpan" id="kobo.47.1"> is a combination of the database protocol, any authentication needed, and also the name of the database. </span><span class="koboSpan" id="kobo.47.2">In the case of SQLite, this would look something like </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.49.1">
sqlite:////tmp/test.db</span></pre>
<p><span class="koboSpan" id="kobo.50.1">In the case of PostgreSQL, it would look like </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.52.1">
postgresql://yourusername:yourpassword@localhost/yournewdb</span></pre>
<p><span class="koboSpan" id="kobo.53.1">This extension then provides a class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">Model</span></strong><span class="koboSpan" id="kobo.55.1">, which helps define models for our application. </span><span class="koboSpan" id="kobo.55.2">Read more </span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.56.1">about database URLs </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">at </span></span><a href="https://docs.sqlalchemy.org/en/14/core/engines.html#database-urls"><span class="No-Break"><span class="koboSpan" id="kobo.58.1">https://docs.sqlalchemy.org/en/14/core/engines.html#database-urls</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.59.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.60.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.61.1">The SQLite database URI is OS-specific, meaning the URI would be different for Unix/macOS/Linux </span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.62.1">and Windows. </span><span class="koboSpan" id="kobo.62.2">Please refer to the documentation at </span><a href="https://docs.sqlalchemy.org/en/14/core/engines.html#sqlite"><span class="koboSpan" id="kobo.63.1">https://docs.sqlalchemy.org/en/14/core/engines.html#sqlite</span></a><span class="koboSpan" id="kobo.64.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">more details.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.66.1">Information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.67.1">For all database systems other than SQLite, separate libraries are needed. </span><span class="koboSpan" id="kobo.67.2">For example, for using PostgreSQL, you </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">need </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">psycop</span><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.70.1">g2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">.</span></span></p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.72.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.73.1">Let’s create a </span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.74.1">small application in this recipe to understand the basic database connection with Flask. </span><span class="koboSpan" id="kobo.74.2">We will build over this application in the next few recipes. </span><span class="koboSpan" id="kobo.74.3">Here, we will just see how to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">db</span></strong><span class="koboSpan" id="kobo.76.1"> instance and validate its existence. </span><span class="koboSpan" id="kobo.76.2">The file’s structure would look like </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.78.1">
    flask_catalog/
        run.py
        my_app/
            __init__.py</span></pre>
<p><span class="koboSpan" id="kobo.79.1">First, we start with </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">flask_app/run.py</span></strong><span class="koboSpan" id="kobo.81.1">. </span><span class="koboSpan" id="kobo.81.2">This is the usual </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">run</span></strong><span class="koboSpan" id="kobo.83.1"> file that we have read about previously in this book in </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">multiple recipes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.85.1">
from my_app import app
app.run(debug=True)</span></pre>
<p><span class="koboSpan" id="kobo.86.1">Then, we configure our application configuration </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">file, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">flask_app/my_app/__init__.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.90.1">
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] =
  'sqlite:////tmp/test.db'
db = SQLAlchemy(app)
with app.app_context():
    db.create_all()</span></pre>
<p><span class="koboSpan" id="kobo.91.1">Here, we first </span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.92.1">configure our application to point </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">SQLALCHEMY_DATABASE_URI</span></strong><span class="koboSpan" id="kobo.94.1"> to a specific location. </span><span class="koboSpan" id="kobo.94.2">Then, we create an object of </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">SQLAlchemy</span></strong><span class="koboSpan" id="kobo.96.1"> with the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">db</span></strong><span class="koboSpan" id="kobo.98.1">. </span><span class="koboSpan" id="kobo.98.2">As the name suggests, this is the object that will handle all our ORM-related activities. </span><span class="koboSpan" id="kobo.98.3">As mentioned earlier, this object has a class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">Model</span></strong><span class="koboSpan" id="kobo.100.1">, which provides the base for creating models in Flask. </span><span class="koboSpan" id="kobo.100.2">Any class can just subclass or inherit the </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">Model</span></strong><span class="koboSpan" id="kobo.102.1"> class to create models, which will act as </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">database tables.</span></span></p>
<p><span class="koboSpan" id="kobo.104.1">Now, if we open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">http://127.0.0.1:5000</span></strong><span class="koboSpan" id="kobo.106.1"> URL in a browser, we will see nothing. </span><span class="koboSpan" id="kobo.106.2">This is because we have just configured the database connection for this application and there is nothing to be seen on the browser. </span><span class="koboSpan" id="kobo.106.3">However, you can always head to the location specified in </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">app.config</span></strong><span class="koboSpan" id="kobo.108.1"> for the database location to see the newly created </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">test.db</span></strong></span><span class="No-Break"> <a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.110.1">file.</span></span></p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.111.1">There’s more…</span></h2>
<p><span class="koboSpan" id="kobo.112.1">Sometimes, you may want a single SQLAlchemy </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">db</span></strong><span class="koboSpan" id="kobo.114.1"> instance to be used across multiple applications, or to create an application dynamically. </span><span class="koboSpan" id="kobo.114.2">In such cases, it is not preferable to bind the </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">db</span></strong><span class="koboSpan" id="kobo.116.1"> instance to a single application. </span><span class="koboSpan" id="kobo.116.2">Here, you will have to work with the application context to achieve the </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">desired outcome.</span></span></p>
<p><span class="koboSpan" id="kobo.118.1">In this case, register the application with SQLAlchemy differently, </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.120.1">
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
db = SQLAlchemy()
def create_app():
    app = Flask(__name__)
    db.init_app(app)
    return app</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.121.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.122.1">The preceding approach can be taken up while initializing the app with any Flask extension and is very common when dealing with </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">real-life applications.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">Now, all the </span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.125.1">operations that were earlier possible globally with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">db</span></strong><span class="koboSpan" id="kobo.127.1"> instance will require a Flask application context at </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">all times.</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">The Flask application context is </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.131.1">
&gt;&gt;&gt; from my_app import create_app
&gt;&gt;&gt; app = create_app()
&gt;&gt;&gt; app.test_request_context().push()
&gt;&gt;&gt; # Do whatever needs to be done
&gt;&gt;&gt; app.test_request_context().pop()</span></pre>
<p><span class="koboSpan" id="kobo.132.1">Or, you can use context manager, </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.134.1">
with app():
# We have flask application context now till we are inside the with</span><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.135.1"> block</span></pre>
<h2 id="_idParaDest-81"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.136.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.137.1">The next couple of recipes will extend the current application to make a complete application, which will help us to understand the ORM </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">layer b</span><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.139.1">etter.</span></span></p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.140.1">Creating a basic product model</span></h1>
<p><span class="koboSpan" id="kobo.141.1">In this recipe, we will create an application that will help us to store products to be displayed on </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.142.1">the catalog section of a website. </span><span class="koboSpan" id="kobo.142.2">It should be possible to add products to the catalog and then delete them as and when required. </span><span class="koboSpan" id="kobo.142.3">As you saw in the last chapter, this is possible to do using non-persistent storage as well. </span><span class="koboSpan" id="kobo.142.4">Here, however, we will store data in a database to have </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">persistent s</span><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.144.1">torage.</span></span></p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.145.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.146.1">The new directory layout would appear </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.148.1">
    flask_catalog/
        run.py
        my_app/
            __init__.py
            catalog/
                __init__.py
                views.py
                models.py</span></pre>
<p><span class="koboSpan" id="kobo.149.1">First of all, start by modifying the application configuration file, </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">flask_catalog/my_app/__init__.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.152.1">
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] =
    'sqlite:////tmp/test.db'
db = SQLAlchemy(app)
from my_app.catalog.views import catalog
app.register_blueprint(catalog)
with app.app_context():
    db.create_all()</span></pre>
<p><span class="koboSpan" id="kobo.153.1">The last statement in the file is </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">db.create_all()</span></strong><span class="koboSpan" id="kobo.155.1">, which tells the application to create all the tables in the database specified. </span><span class="koboSpan" id="kobo.155.2">So, as soon as the application runs, all the tables will be </span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.156.1">created if they are not already there. </span><span class="koboSpan" id="kobo.156.2">Since you are not in an application request at this point, create a context manually using </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">with app.app_context():</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">Now is the time to create models that are placed </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">flask_catalog/my_app/catalog/models.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.163.1">
from my_app import db
class Product(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(255))
    price = db.Column(db.Float)
    def __init__(self, name, price):
        self.name = name
        self.price = price
    def __repr__(self):
        return '&lt;Product %d&gt;' % self.id</span></pre>
<p><span class="koboSpan" id="kobo.164.1">In this file, we have created a model named </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">Product</span></strong><span class="koboSpan" id="kobo.166.1">, which has three fields, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">id</span></strong><span class="koboSpan" id="kobo.168.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">name</span></strong><span class="koboSpan" id="kobo.170.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">price</span></strong><span class="koboSpan" id="kobo.172.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">id</span></strong><span class="koboSpan" id="kobo.174.1"> is a self-generated field in the database, which will store the ID of the record and is the primary key. </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">name</span></strong><span class="koboSpan" id="kobo.176.1"> is a field of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">string</span></strong><span class="koboSpan" id="kobo.178.1"> type, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">price</span></strong><span class="koboSpan" id="kobo.180.1"> is a field of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">float</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.182.1"> type.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">Now, add a new file for views, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">lask_catalog/my_app/catalog/views.py</span></strong><span class="koboSpan" id="kobo.185.1">. </span><span class="koboSpan" id="kobo.185.2">In this file, we have multiple view methods, which control </span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.186.1">how we deal with the product model and the web application </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">in general.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.188.1">
from flask import request, jsonify, Blueprint
from my_app import db
from my_app.catalog.models import Product
catalog = Blueprint('catalog', __name__)
@catalog.route('/')
@catalog.route('/home')
def home():
    return "Welcome to the Catalog Home."</span></pre>
<p><span class="koboSpan" id="kobo.189.1">The preceding method handles how the home page or the application landing page looks or responds to users. </span><span class="koboSpan" id="kobo.189.2">You would most probably want to use a template for rendering this in your applications. </span><span class="koboSpan" id="kobo.189.3">We will cover this in the </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">next chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.191.1">Have a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.193.1">
@catalog.route('/product/&lt;id&gt;')
def product(id):
    product = Product.query.get_or_404(id)
    return 'Product - %s, $%s' % (product.name,
      product.price)</span></pre>
<p><span class="koboSpan" id="kobo.194.1">The preceding method controls the output to be shown when a user looks for a specific product using its ID. </span><span class="koboSpan" id="kobo.194.2">We filter for the product using the ID and then return its information if a product is found, or else abort with a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">404</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.196.1"> error.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.199.1">
@catalog.route('/products')
def products():
    products = Product.query.all()
    res = {}
    for product in products:
        res[product.id] = {
            'name': product.name,
            'price': str(product.price)
        }
    return jsonify(res)</span></pre>
<p><span class="koboSpan" id="kobo.200.1">The preceding method </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.201.1">returns a list of all products in the database in JSON format. </span><span class="koboSpan" id="kobo.201.2">If no product is found, it simply returns an empty </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">JSON: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">{}</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.205.1">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.207.1">
@catalog.route('/product-create', methods=['POST',])
def create_product():
    name = request.form.get('name')
    price = request.form.get('price')
    product = Product(name, price)
    db.session.add(product)
    db.session.commit()
    return 'Product created.'</span></pre>
<p><span class="koboSpan" id="kobo.208.1">The preceding method controls the creation of a product in the database. </span><span class="koboSpan" id="kobo.208.2">We first get the information from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">request</span></strong><span class="koboSpan" id="kobo.210.1"> object and then create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">Product</span></strong><span class="koboSpan" id="kobo.212.1"> instance from </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">this information.</span></span></p>
<p><span class="koboSpan" id="kobo.214.1">Then, we add this </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">Product</span></strong><span class="koboSpan" id="kobo.216.1"> instance to the database session and finally, use </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">commit</span></strong><span class="koboSpan" id="kobo.218.1"> to save the record to </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">the</span><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.220.1"> database.</span></span></p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.221.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.222.1">In the beginning, the database is empty and has no products. </span><span class="koboSpan" id="kobo.222.2">This can be confirmed by opening </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">http://127.0.0.1:5000/products</span></strong><span class="koboSpan" id="kobo.224.1"> in a browser. </span><span class="koboSpan" id="kobo.224.2">This would result in an empty JSON response, </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">{}</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.228.1">Now, first, we would </span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.229.1">want to create a product. </span><span class="koboSpan" id="kobo.229.2">For this, we need to send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">POST</span></strong><span class="koboSpan" id="kobo.231.1"> request, which can easily be sent from the Python prompt using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">requests</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.233.1"> library:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.234.1">
&gt;&gt;&gt; import requests
&gt;&gt;&gt; requests.post('http://127.0.0.1:5000/product-create', data={'name': 'iPhone 5S', 'price': '549.0'})</span></pre>
<p><span class="koboSpan" id="kobo.235.1">To confirm whether the product is now in the database, we can again open </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">http://127.0.0.1:5000/products</span></strong><span class="koboSpan" id="kobo.237.1"> in the browser. </span><span class="koboSpan" id="kobo.237.2">This time, it will show a JSON dump of the product details, which will look </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.239.1">
{
  "1": {
    "name": "iPhone 5S",
    "price": "</span><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.240.1">549."
</span><span class="koboSpan" id="kobo.240.2">  }
}</span></pre>
<h1 id="_idParaDest-85"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.241.1">Creating a relational category model</span></h1>
<p><span class="koboSpan" id="kobo.242.1">In our previous recipe, we created a simple product model, which had a couple of fields. </span><span class="koboSpan" id="kobo.242.2">In practice, however, </span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.243.1">applications are much more complex and have various relationships between their tables. </span><span class="koboSpan" id="kobo.243.2">These relationships can be one-to-one, one-to-many, many-to-one, or many-to-many. </span><span class="koboSpan" id="kobo.243.3">In this recipe, we will try to understand some of these relationships with the help of</span><a id="_idTextAnchor150"/> <span class="No-Break"><span class="koboSpan" id="kobo.244.1">an example.</span></span></p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.245.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.246.1">Let’s say we want to have product categories where each category can have multiple products, but each product should have only one category. </span><span class="koboSpan" id="kobo.246.2">Let’s do this by modifying some files from the application in the last recipe. </span><span class="koboSpan" id="kobo.246.3">We will make modifications to both models and views. </span><span class="koboSpan" id="kobo.246.4">In models, we will add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">Category</span></strong><span class="koboSpan" id="kobo.248.1"> model, and, in views, we will add new methods </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.249.1">to handle category-related calls and also modify the existing methods to accommodate the newly </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">added feature.</span></span></p>
<p><span class="koboSpan" id="kobo.251.1">First, modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">models.py</span></strong><span class="koboSpan" id="kobo.253.1"> file to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">Category</span></strong><span class="koboSpan" id="kobo.255.1"> model and make some modifications to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">Product</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.257.1"> model:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.258.1">
from my_app import db
class Product(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(255))
    price = db.Column(db.Float)
    category_id = db.Column(db.Integer,
      db.ForeignKey('category.id'))
    category = db.relationship(
        'Category', backref=db.backref('products',
          lazy='dynamic')
    )
    def __init__(self, name, price, category):
        self.name = name
        self.price = price
        self.category = category
    def __repr__(self):
        return '&lt;Product %d&gt;' % self.id</span></pre>
<p><span class="koboSpan" id="kobo.259.1">In the preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">Product</span></strong><span class="koboSpan" id="kobo.261.1"> model, check the newly added fields for </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">category_id</span></strong><span class="koboSpan" id="kobo.263.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">category</span></strong><span class="koboSpan" id="kobo.265.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">category_id</span></strong><span class="koboSpan" id="kobo.267.1"> is the foreign key to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">Category</span></strong><span class="koboSpan" id="kobo.269.1"> model, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">category</span></strong><span class="koboSpan" id="kobo.271.1"> represents the relationship table. </span><span class="koboSpan" id="kobo.271.2">As evident from the definitions themselves, one of </span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.272.1">them is a relationship, and the other uses this relationship to store the foreign key value in the database. </span><span class="koboSpan" id="kobo.272.2">This is a simple many-to-one relationship from </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">product</span></strong><span class="koboSpan" id="kobo.274.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">category</span></strong><span class="koboSpan" id="kobo.276.1">. </span><span class="koboSpan" id="kobo.276.2">Also, notice the </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">backref</span></strong><span class="koboSpan" id="kobo.278.1"> argument in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">category</span></strong><span class="koboSpan" id="kobo.280.1"> field; this argument allows us to access products from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">Category</span></strong><span class="koboSpan" id="kobo.282.1"> model by writing something as simple as </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">category.products</span></strong><span class="koboSpan" id="kobo.284.1"> in our views. </span><span class="koboSpan" id="kobo.284.2">This acts like a one-to-many relationship from the </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">other end.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.286.1">Important information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.287.1">Just adding the field to the model would not get reflected in the database right away. </span><span class="koboSpan" id="kobo.287.2">You might need to drop the whole database and then run the application again or run migrations, which shall be covered in the next recipe, </span><em class="italic"><span class="koboSpan" id="kobo.288.1">Migrating databases using Alembic </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.289.1">and Flask-Migrate</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.291.1">For SQLite, you can simply delete the database file that was created while initializing </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">Category</span></strong><span class="koboSpan" id="kobo.295.1"> model that has just one field </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">name</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.299.1">
class Category(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100))
    def __init__(self, name):
        self.name = name
    def __repr__(self):
        return '&lt;Category %d&gt;' % self.id</span></pre>
<p><span class="koboSpan" id="kobo.300.1">Now, modify </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">views.py</span></strong><span class="koboSpan" id="kobo.302.1"> to accommodate the change in the models. </span><span class="koboSpan" id="kobo.302.2">Make the first change </span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.303.1">in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">products()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.305.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.306.1">
from my_app.catalog.models import Product, Category
@catalog.route('/products')
def products():
    products = Product.query.all()
    res = {}
    for product in products:
        res[product.id] = {
            'name': product.name,
            'price': product.price,
            'category': product.category.name
        }
    return jsonify(res)</span></pre>
<p><span class="koboSpan" id="kobo.307.1">Here, we have just one change where we send the </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">category</span></strong><span class="koboSpan" id="kobo.309.1"> name in the product’s JSON data, which is being generated to be returned as a response when a request is made to the </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">preceding endpoint.</span></span></p>
<p><span class="koboSpan" id="kobo.311.1">Change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">create_product()</span></strong><span class="koboSpan" id="kobo.313.1"> method to look for the category before creating </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">the product:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.315.1">
@catalog.route('/product-create', methods=['POST',])
def create_product():
    name = request.form.get('name')
    price = request.form.get('price')
    categ_name = request.form.get('category')
    category =
      Category.query.filter_by(name=categ_name).first()
    if not category:
        category = Category(categ_name)
    product = Product(name, price, category)
    db.session.add(product)
    db.session.commit()
    return 'Product created.'</span></pre>
<p><span class="koboSpan" id="kobo.316.1">Here, we will first search for an existing category with the category name in the request. </span><span class="koboSpan" id="kobo.316.2">If an existing </span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.317.1">category is found, we will use the same in the product creation; otherwise, we will create a </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">new category.</span></span></p>
<p><span class="koboSpan" id="kobo.319.1">Create a new method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">create_category()</span></strong><span class="koboSpan" id="kobo.321.1">, to handle the creation of </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">a category:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.323.1">
@catalog.route('/category-create', methods=['POST',])
def create_category():
    name = request.form.get('name')
    category = Category(name)
    db.session.add(category)
    db.session.commit()
    return 'Category created.'</span></pre>
<p><span class="koboSpan" id="kobo.324.1">The preceding code is a relatively simple method for creating a category using the name provided in </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">the request.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">Create a new method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">categories()</span></strong><span class="koboSpan" id="kobo.328.1">, to handle the listing of all categories and </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">corresponding products:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.330.1">
@catalog.route('/categories')
def categories():
    categories = Category.query.all()
    res = {}
    for category in categories:
        res[category.id] = {
            'name': category.name
        }
        for product in category.products:
            res[category.id]['products'] = {
                'id': product.id,
                'name': product.name,
                'price': product.price
            }
    return jsonify(res)</span></pre>
<p><span class="koboSpan" id="kobo.331.1">The preceding </span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.332.1">method does a bit of tricky stuff. </span><span class="koboSpan" id="kobo.332.2">Here, we fetched all the categories from the database and then, for each category, we fetched all the products and then returned all the dat</span><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.333.1">a as a </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">JSON dump.</span></span></p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.335.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.336.1">This recipe works very similarly to the preceding recipe, </span><em class="italic"><span class="koboSpan" id="kobo.337.1">Creating a basic </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.338.1">product model</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.340.1">To create a product with a category, make a </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">POST</span></strong><span class="koboSpan" id="kobo.342.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">product-create</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.345.1"> endpoint:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.346.1">
&gt;&gt;&gt; import requests
&gt;&gt;&gt; requests.post('http://127.0.0.1:5000/product-create', data={'name': 'iPhone 5S', 'price': '549.0', 'category': 'Phones'})</span></pre>
<p><span class="koboSpan" id="kobo.347.1">To view how the data now looks when fetched from the database, open </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">http://127.0.0.1:5000/categories</span></strong><span class="koboSpan" id="kobo.349.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">your browser:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.351.1">
{
  "1": {
    "name": "Phones",
    "products": {
      "id": 1,
      "name": "iPhone 5S",
      "price": </span><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.352.1">549.0
    }
  }
}</span></pre>
<h2 id="_idParaDest-88"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.353.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.354.1">Refer to the </span><em class="italic"><span class="koboSpan" id="kobo.355.1">Creating a basic product model</span></em><span class="koboSpan" id="kobo.356.1"> recipe to understand the context of this recipe and </span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.357.1">how this recipe works for a browser, given that its workings are very similar to</span><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.358.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">previous one.</span></span></p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.360.1">Migrating databases using Alembic and Flask-Migrate</span></h1>
<p><span class="koboSpan" id="kobo.361.1">Updating database schema is an important use case for all applications, as it involves adding or </span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.362.1">removing tables and/or columns or changing </span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.363.1">column types. </span><span class="koboSpan" id="kobo.363.2">One way is to drop the database and then create a new one using </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">db.drop_all()</span></strong><span class="koboSpan" id="kobo.365.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">db.create_all()</span></strong><span class="koboSpan" id="kobo.367.1">. </span><span class="koboSpan" id="kobo.367.2">However, this approach cannot be followed for applications in production </span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.368.1">or even in staging. </span><span class="koboSpan" id="kobo.368.2">We would like </span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.369.1">to migrate our database to match the newly updated model with all the </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">data intact.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">For this, we </span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.372.1">have </span><strong class="bold"><span class="koboSpan" id="kobo.373.1">Alembic</span></strong><span class="koboSpan" id="kobo.374.1">, a Python-based tool for managing database migrations, which uses SQLAlchemy as the underlying engine. </span><span class="koboSpan" id="kobo.374.2">Alembic provides automatic migrations to a great extent with some limitations (of course, we cannot expect any tool to be seamless). </span><span class="koboSpan" id="kobo.374.3">As the </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.375.1"> icing on the cake, we have a Flask extension called </span><strong class="bold"><span class="koboSpan" id="kobo.376.1">Flask-Migrate</span></strong><span class="koboSpan" id="kobo.377.1">, which eases the process of migrations even more. </span><span class="koboSpan" id="kobo.377.2">In this recipe, we will cover the basics of database migration techniques using Al</span><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.378.1">embic </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">and Flask-Migrate.</span></span></p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.380.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.381.1">First of all, run the following command to </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">install </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">Flask-Migrate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.385.1">
$ pip install Flask-Migrate</span></pre>
<p><span class="koboSpan" id="kobo.386.1">This will also install Alembic, among a numbe</span><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.387.1">r of </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">other dependencies.</span></span></p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.389.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.390.1">To enable </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.391.1">migrations, we need to modify our app </span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.392.1">definition a bit. </span><span class="koboSpan" id="kobo.392.2">Let’s understand how such </span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.393.1">a config appears if we modify </span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.394.1">the same for our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">catalog</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.396.1"> application:</span></span></p>
<p><span class="koboSpan" id="kobo.397.1">The following lines of code show how </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">my_app/__init__.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.399.1"> appears:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.400.1">
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] =
  'sqlite:////tmp/test.db'
db = SQLAlchemy(app)
migrate = Migrate(app, db)
from my_app.catalog.views import catalog
app.register_blueprint(catalog)
with app.app_context():
    db.create_all()</span></pre>
<p><span class="koboSpan" id="kobo.401.1">If we </span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.402.1">pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">--help</span></strong><span class="koboSpan" id="kobo.404.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">flask</span></strong><span class="koboSpan" id="kobo.406.1"> command </span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.407.1">while running it as a script, the </span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.408.1">terminal will show all the available options, as </span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.409.1">shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<span class="koboSpan" id="kobo.411.1"><img alt="Figure 3.1 – Database migration﻿ option" src="image/B19111_03_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.412.1">Figure 3.1 – Database migration option</span></p>
<p><span class="koboSpan" id="kobo.413.1">To initialize migrations, run the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">init</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.415.1"> command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.416.1">
$ flask db init</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.417.1">Important information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.418.1">For the migration commands to work, the Flask application should be locatable; otherwise, you will get the </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">following error:</span></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">Error: Could not locate a Flask application. </span><span class="koboSpan" id="kobo.420.2">Use the 'flask --app' option, 'FLASK_APP' environment variable, or a 'wsgi.py' or 'app.py' file in the </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">current directory.</span></strong></span></p>
<p class="callout"><span class="koboSpan" id="kobo.422.1">In our case, simply export the Flask application to the </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">environment variable:</span></span></p>
<p class="callout"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">export FLASK_APP="my_app.__init__.py"</span></strong></span></p>
<p class="callout"><span class="koboSpan" id="kobo.425.1">Or, simply with </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">the following:</span></span></p>
<p class="callout"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">export FLASK_APP=my_app</span></strong></span></p>
<p><span class="koboSpan" id="kobo.428.1">Once </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.429.1">changes are made to the models, call </span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.430.1">the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">migrate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.432.1"> command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.433.1">
$ flask db migrate</span></pre>
<p><span class="koboSpan" id="kobo.434.1">To make </span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.435.1">the changes reflect on the database, call </span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.436.1">the </span><a id="_idTextAnchor162"/><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">upgrade</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.438.1"> command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.439.1">
$ flask db upgrade</span></pre>
<h2 id="_idParaDest-92"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.440.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.441.1">Now, let’s say we modify the model of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">product</span></strong><span class="koboSpan" id="kobo.443.1"> table to add a new </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">field called</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">company</span></strong><span class="koboSpan" id="kobo.446.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.448.1">
class Product(db.Model):
    # Same Product model as last recipe
    # ...
</span><span class="koboSpan" id="kobo.448.2">    company = db.Column(db.String(100))</span></pre>
<p><span class="koboSpan" id="kobo.449.1">The result of </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">migrate</span></strong><span class="koboSpan" id="kobo.451.1"> will be something like the </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">following snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.453.1">
$ flask db migrate
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
</span><span class="koboSpan" id="kobo.453.2">INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
</span><span class="koboSpan" id="kobo.453.3">INFO  [alembic.autogenerate.compare] Detected added column 'product.company'
Generating
&lt;path/to/application&gt;/flask_catalog/migrations/versions/2c08f71f9253_.py
... </span><span class="koboSpan" id="kobo.453.4">done</span></pre>
<p><span class="koboSpan" id="kobo.454.1">In the </span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.455.1">preceding code, we can see that </span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.456.1">Alembic compares the new model with the </span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.457.1">database table and detects a newly </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.458.1">added column for </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">company</span></strong><span class="koboSpan" id="kobo.460.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">product</span></strong><span class="koboSpan" id="kobo.462.1"> table (created by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">Product</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.464.1"> model).</span></span></p>
<p><span class="koboSpan" id="kobo.465.1">Similarly, the output of </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">upgrade</span></strong><span class="koboSpan" id="kobo.467.1"> will be something like the </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">following snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.469.1">
$ flask db upgrade
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
</span><span class="koboSpan" id="kobo.469.2">INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
</span><span class="koboSpan" id="kobo.469.3">INFO  [alembic.runtime.migration] Running upgrade None -&gt; 2c08f71f9253, empty message</span></pre>
<p><span class="koboSpan" id="kobo.470.1">Here, Alembic performs the upgrade of the database for the migration detected earlier. </span><span class="koboSpan" id="kobo.470.2">We can see a hex code in the preceding output. </span><span class="koboSpan" id="kobo.470.3">This represents the revision of the migration performed. </span><span class="koboSpan" id="kobo.470.4">This is for internal use by Alembic t</span><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.471.1">o track the changes to </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">database tables.</span></span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.473.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.474.1">Refer to the </span><em class="italic"><span class="koboSpan" id="kobo.475.1">Creating a basic product model</span></em><span class="koboSpan" id="kobo.476.1"> recipe for the context of this recipe</span><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.477.1"> around the catalog models </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">product</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">.</span></span></p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.481.1">Indexing model data with Redis</span></h1>
<p><span class="koboSpan" id="kobo.482.1">There may be some features we want to implement but do not want to have persistent </span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.483.1">storage for them. </span><span class="koboSpan" id="kobo.483.2">In such a use case, it is a good approach to have these stored in cache-like storage temporarily – for example, when we </span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.484.1">want to show a list of recently viewed products to visitors on a website. </span><span class="koboSpan" id="kobo.484.2">In this recipe, we will understand how to use Redis as an effective cache to store non-persistent d</span><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.485.1">ata that can be accessed at a </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">high speed.</span></span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.487.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.488.1">We will do this with the help of Redis, which can be installed using the </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.490.1">
$ pip install redis</span></pre>
<p><span class="koboSpan" id="kobo.491.1">Make sure that </span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.492.1">you run the Redis server for the connection to happen. </span><span class="koboSpan" id="kobo.492.2">To install and run a Redis server, refer </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">to </span></span><a href="http://redis.io/topics/quickstart"><span class="No-Break"><span class="koboSpan" id="kobo.494.1">http://redis.io/topics/quickstart</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.495.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.496.1">Then, we need to have the connection open to Redis. </span><span class="koboSpan" id="kobo.496.2">This can be done by adding the following lines of code </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">my_app/__init__.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.500.1">
from redis import Redis
redis = Redis()</span></pre>
<p><span class="koboSpan" id="kobo.501.1">We can do this in our application file, where we will define the app, or in the views file, where we will use it. </span><span class="koboSpan" id="kobo.501.2">It is preferred that you do this in the application file because then, the connection will be open throughout the application, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">redis</span></strong><span class="koboSpan" id="kobo.503.1"> object can be</span><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.504.1"> used by just importing it </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">where required.</span></span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.506.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.507.1">We will maintain a </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">set</span></strong><span class="koboSpan" id="kobo.509.1"> in Redis, which will store the products visited recently. </span><span class="koboSpan" id="kobo.509.2">This will be populated </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.510.1">whenever a product is visited. </span><span class="koboSpan" id="kobo.510.2">The entry will </span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.511.1">expire in 10 minutes. </span><span class="koboSpan" id="kobo.511.2">This change goes </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">views.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.515.1">
@catalog.route('/product/&lt;id&gt;')
def product(id):
    product = Product.query.get_or_404(id)
    product_key = 'product-%s' % product.id
    redis.set(product_key, product.name)
    redis.expire(product_key, 600)
    return 'Product - %s, $%s' % (product.name,
      product.price)</span></pre>
<p><span class="koboSpan" id="kobo.516.1">In the preceding method, note the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">set()</span></strong><span class="koboSpan" id="kobo.518.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">expire()</span></strong><span class="koboSpan" id="kobo.520.1"> methods on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">redis</span></strong><span class="koboSpan" id="kobo.522.1"> object. </span><span class="koboSpan" id="kobo.522.2">First, set the product ID using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">product_key</span></strong><span class="koboSpan" id="kobo.524.1"> value in the Redis store. </span><span class="koboSpan" id="kobo.524.2">Then, set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">expire</span></strong><span class="koboSpan" id="kobo.526.1"> time of the key to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">600</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.528.1"> seconds.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.529.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.530.1">It would be a good practice to fetch the </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">expire</span></strong><span class="koboSpan" id="kobo.532.1"> time – that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">600</span></strong><span class="koboSpan" id="kobo.534.1"> – from a configuration value. </span><span class="koboSpan" id="kobo.534.2">This can be set on the application object in </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">my_app/__init__.py</span></strong><span class="koboSpan" id="kobo.536.1">, and can then be fetched </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">from there.</span></span></p>
<p><span class="koboSpan" id="kobo.538.1">Now, we will look for the keys that are still alive in the cache and then fetch the products corresponding to these keys and </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">return them:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.540.1">
@catalog.route('/recent-products')
def recent_products():
    keys_alive = redis.keys('product-*')
    products = [redis.get(k).decode('utf-8') for k in
      keys_alive</span><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.541.1">]
    return jsonify({'products': products})</span></pre>
<h2 id="_idParaDest-97"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.542.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.543.1">An entry is added to the store whenever a user visits a product, and the entry is kept there for 600 seconds (10 minutes). </span><span class="koboSpan" id="kobo.543.2">Now, this product will be listed in the recent products list </span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.544.1">for the next 10 minutes unless it is visited again, which </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.545.1">will reset the time to 10 </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">minutes again.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">To test this, add a few products to </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">your database:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.549.1">
&gt;&gt;&gt; requests.post('http://127.0.0.1:5000/product-create', data={'name': 'iPhone 5S', 'price': '549.0', 'category': 'Phones'})
&gt;&gt;&gt; requests.post('http://127.0.0.1:5000/product-create', data={'name': 'iPhone 13', 'price': '799.0', 'category': 'Phones'})
&gt;&gt;&gt; requests.post('http://127.0.0.1:5000/product-create', data={'name': 'iPad Pro', 'price': '999.0', 'category': 'Tablets'})
&gt;&gt;&gt; requests.post('http://127.0.0.1:5000/product-create', data={'name': 'iPhone 5S', 'price': '549.0', 'category': 'Phones'})</span></pre>
<p><span class="koboSpan" id="kobo.550.1">Then, visit some products by simply opening the product URLs in the browser – for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">http://127.0.0.1:5000/product/1</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.552.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">http://127.0.0.1:5000/product/3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.555.1">Now, open </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">http://127.0.0.1:5000/recent-products</span></strong><span class="koboSpan" id="kobo.557.1"> in the browser to view the list of </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">recent products:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.559.1">
{
  "prod</span><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.560.1">ucts": [
    "iPad Pro",
    "iPhone 5S"
  ]
}</span></pre>
<h1 id="_idParaDest-98"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.561.1">Opting for the NoSQL way with MongoDB</span></h1>
<p><span class="koboSpan" id="kobo.562.1">Sometimes, the data to be used in the application we are building may not be structured at all; it may </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.563.1">be semi-structured, or there may be some data whose schema changes frequently over time. </span><span class="koboSpan" id="kobo.563.2">In such cases, we would refrain </span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.564.1">from using an RDBMS, as it adds to the pain and is difficult to scale and maintain. </span><span class="koboSpan" id="kobo.564.2">For such cases, it would be desirable to use a </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">NoSQL database.</span></span></p>
<p><span class="koboSpan" id="kobo.566.1">Also, as a result of fast and quick development in the currently prevalent development environment, it is not always possible to design the perfect schema the first time. </span><span class="koboSpan" id="kobo.566.2">NoSQL provides the flexibility to modify the schema without </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">much hassle.</span></span></p>
<p><span class="koboSpan" id="kobo.568.1">In production environments, the database usually grows to a huge size over a period of time. </span><span class="koboSpan" id="kobo.568.2">This drastically affects the performance of the overall system. </span><span class="koboSpan" id="kobo.568.3">Vertical and horizontal scaling techniques are available, but they can be very costly at times. </span><span class="koboSpan" id="kobo.568.4">In such cases, a NoSQL database can be considered, as it is designed from scratch for similar purposes. </span><span class="koboSpan" id="kobo.568.5">The ability of NoSQL databases to run on large multiple clusters and handle huge volumes of data generated with high velocity makes them a good choice when looking to handle scaling issues with </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">traditional RDBMSes.</span></span></p>
<p><span class="koboSpan" id="kobo.570.1">In this recipe, we will use Mon</span><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.571.1">goDB to learn how to integrate NoSQL </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">with Flask.</span></span></p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.573.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.574.1">There are many extensions available for using Flask with MongoDB. </span><span class="koboSpan" id="kobo.574.2">We will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">Flask-MongoEngine</span></strong><span class="koboSpan" id="kobo.576.1">, as it provides a good level of abstraction, which makes it easy to understand. </span><span class="koboSpan" id="kobo.576.2">It can be installed using the </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.578.1">
$ pip install flask-mongoengine</span></pre>
<p><span class="koboSpan" id="kobo.579.1">Remember to run the MongoDB server for the connection to happen. </span><span class="koboSpan" id="kobo.579.2">For more details on installing </span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.580.1">and running MongoDB, refer</span><a id="_idTextAnchor178"/> <span class="No-Break"><span class="koboSpan" id="kobo.581.1">to </span></span><a href="http://docs.mongodb.org/manual/installation/"><span class="No-Break"><span class="koboSpan" id="kobo.582.1">http://docs.mongodb.org/manual/installation/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.583.1">.</span></span></p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.584.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.585.1">First, manually </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.586.1">create a database in MongoDB </span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.587.1">using the command line. </span><span class="koboSpan" id="kobo.587.2">Let’s name this </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">database </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">my_catalog</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.591.1">
&gt;&gt;&gt; mongosh
Current Mongosh Log ID:  62fa8dtfd435df654150997b
Connecting to:  mongodb://127.0.0.1:27017/?directConnection
=true&amp;serverSelectionTimeoutMS=2000&amp;appName=mongosh+1.5.4
Using MongoDB:    6.0.0
Using Mongosh:    1.5.4
test&gt; use my_catalog
switched to db my_catalog</span></pre>
<p><span class="koboSpan" id="kobo.592.1">The following is a rewrite of our catalog application using MongoDB. </span><span class="koboSpan" id="kobo.592.2">The first change comes to our configuration </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">file, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">my_app/__init__.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.596.1">
from flask import Flask
from flask_mongoengine import MongoEngine
app = Flask(__name__)
app.config['MONGODB_SETTINGS'] = {'DB': 'my_catalog'}
app.debug = True
db = MongoEngine(app)
from my_app.catalog.views import catalog
app.register_blueprint(catalog)</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.597.1">Information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.598.1">Note that instead of the usual SQLAlchemy-centric settings, we now have </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">MONGODB_SETTINGS</span></strong><span class="koboSpan" id="kobo.600.1">. </span><span class="koboSpan" id="kobo.600.2">Here, we just specify the name of the database to use, which, in our case, </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">my_catalog</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.604.1">Next, we will </span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.605.1">create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">Product</span></strong><span class="koboSpan" id="kobo.607.1"> model using </span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.608.1">MongoDB fields. </span><span class="koboSpan" id="kobo.608.2">This happens as usual in the models </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">file, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">my_app/catalog/models.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.612.1">
import datetime
from my_app import db
class Product(db.Document):
    created_at = db.DateTimeField(
        default=datetime.datetime.now, required=True
    )
    key = db.StringField(max_length=255, required=True)
    name = db.StringField(max_length=255, required=True)
    price = db.DecimalField()
    def __repr__(self):
        return '&lt;Product %r&gt;' % self.id</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.613.1">Important information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.614.1">Now would </span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.615.1">be a good time to look at the MongoDB fields used to create the preceding model and their similarity to the SQLAlchemy fields used in the previous recipes. </span><span class="koboSpan" id="kobo.615.2">Here, instead of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">ID</span></strong><span class="koboSpan" id="kobo.617.1"> field, we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">key</span></strong><span class="koboSpan" id="kobo.619.1">, which stores the unique identifier that will be used to uniquely identify a record. </span><span class="koboSpan" id="kobo.619.2">Also, note the class that is inherited by </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">Product</span></strong><span class="koboSpan" id="kobo.621.1"> while creating the model. </span><span class="koboSpan" id="kobo.621.2">In the case of SQLAlchemy, it is </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">db.Model</span></strong><span class="koboSpan" id="kobo.623.1">, and in the case of MongoDB, it is </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">db.Document</span></strong><span class="koboSpan" id="kobo.625.1">. </span><span class="koboSpan" id="kobo.625.2">This is in accordance with how these database systems work. </span><span class="koboSpan" id="kobo.625.3">SQLAlchemy works with conventional RDBMSes, but MongoDB is a NoSQL document </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">database system.</span></span></p>
<p><span class="koboSpan" id="kobo.627.1">The following </span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.628.1">is the views file, </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">namely, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">my_app/catalog/views.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.632.1">
from decimal import Decimal
from flask import request, Blueprint, jsonify
from my_app.catalog.models import Product
catalog = Blueprint('catalog', __name__)
@catalog.route('/')
@catalog.route('/home')
def home():
    return "Welcome to the Catalog Home."
</span><span class="koboSpan" id="kobo.632.2">@catalog.route('/product/&lt;key&gt;')
def product(key):
    product = Product.objects.get_or_404(key=key)
    return 'Product - %s, $%s' % (product.name,
      product.price)
@catalog.route('/products')
def products():
    products = Product.objects.all()
    res = {}
    for product in products:
        res[product.key] = {
            'name': product.name,
            'price': str(product.price),
        }
    return jsonify(res)
@catalog.route('/product-create', methods=['POST',])
def create_product():
    name = request.form.get('name')
    key = request.form.get('key')
    price = request.form.get('price')
    product = Product(
        name=name,
        key=key,
        price=Decimal(price)
    )
    product.save()
    return 'Product created.'</span></pre>
<p><span class="koboSpan" id="kobo.633.1">You will notice that it is very similar to the views created for the SQLAlchemy-based models. </span><span class="koboSpan" id="kobo.633.2">There are just a few differences in the methods that are called from the MongoEn</span><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.634.1">gine extension, and these should be easy </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">to understand.</span></span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.636.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.637.1">First, add products </span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.638.1">to the database by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">product-create</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.641.1"> endpoint:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.642.1">
&gt;&gt;&gt; res = requests.post('http://127.0.0.1:5000/product-create', data={'key': 'iphone-5s', 'name': 'iPhone 5S', 'price': '549.0'})</span></pre>
<p><span class="koboSpan" id="kobo.643.1">Now, validate </span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.644.1">the product addition by visiting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">http://127.0.0.1:5000/products</span></strong><span class="koboSpan" id="kobo.646.1"> endpoint in the browser. </span><span class="koboSpan" id="kobo.646.2">The following is the resultant </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">JSON value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.648.1">
{
  "iphone-5s</span><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.649.1">": {
    "name": "iPhone 5S",
    "price": "549.00"
  }
}</span></pre>
<h2 id="_idParaDest-102"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.650.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.651.1">Refer to the </span><em class="italic"><span class="koboSpan" id="kobo.652.1">Creating a basic product model</span></em><span class="koboSpan" id="kobo.653.1"> recipe to understand how this application </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">is structured.</span></span></p>
</div>
</body></html>