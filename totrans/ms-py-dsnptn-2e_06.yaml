- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Architectural Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered **behavioral patterns**, patterns that help
    with object interconnection and algorithms. The next category of design patterns
    is **architectural design patterns**. These patterns provide a template for solving
    common architectural problems, facilitating the development of scalable, maintainable,
    and reusable systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Model-View-Controller** (**MVC**) pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Microservices** pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Serverless** pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Event** **Sourcing** pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other architectural design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of this chapter, you will understand how to build robust and flexible
    software using popular architectural design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'See the requirements presented in [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017).
    The additional technical requirements for the code discussed in this chapter are
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the *Microservices pattern* section, install the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`python -m pip` `install grpcio`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`python -m pip` `install grpcio-tools`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`python -m pip install "lanarky[openai]"==0.8.6 uvicorn==0.29.0` (Note that
    this is not compatible with Python 3.12, at the time of writing. In this case,
    you may reproduce the related example using Python 3.11 instead.)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the *Serverless pattern* section, install the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`python –m pip install localstack` (Note that this is not compatible with Python
    3.12, at the time of writing. You may use Python 3.11 instead for this case.)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`python -m pip` `install awscli-local`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`awscli`, using the command: `python -m pip` `install awscli`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the *Event Sourcing* section, install the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eventsourcing`, using the command: `python –m pip` `install eventsourcing`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The MVC pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The MVC pattern is another application of the **loose coupling** principle.
    The name of the pattern comes from the three main components used to split a software
    application: the model, the view, and the controller.'
  prefs: []
  type: TYPE_NORMAL
- en: Even if we will never have to implement it from scratch, we need to be familiar
    with it because all common frameworks use MVC or a slightly different version
    of it (more on this later).
  prefs: []
  type: TYPE_NORMAL
- en: The model is the core component. It represents knowledge. It contains and manages
    the (business) logic, data, state, and rules of an application. The view is a
    visual representation of the model. Examples of views are a computer GUI, the
    text output of a computer terminal, a smartphone’s application GUI, a PDF document,
    a pie chart, a bar chart, and so forth. The view only displays the data; it doesn’t
    handle it. The controller is the link/glue between the model and the view. All
    communication between the model and the view happens through a controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical use of an application that uses MVC, after the initial screen is
    rendered to the user, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The user triggers a view by clicking (typing, touching, and so on) a button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The view informs the controller of the user’s action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The controller processes user input and interacts with the model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The model performs all the necessary validation and state changes and informs
    the controller about what should be done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The controller instructs the view to update and display the output appropriately,
    following the model’s instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The MVC pattern](img/B21896_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – The MVC pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'But is the controller part necessary? Can’t we just skip it? We could, but
    then we would lose a big benefit that MVC provides: the ability to use more than
    one view (even at the same time, if that’s what we want) without modifying the
    model. To achieve decoupling between the model and its representation, every view
    typically needs its own controller. If the model communicated directly with a
    specific view, we wouldn’t be able to use multiple views (or, at least, not in
    a clean and modular way).'
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MVC is an application of the **separation of concern** principle. Separation
    of concern is used a lot in real life. For example, if you build a new house,
    you usually assign different professionals to 1) install the plumbing and electricity;
    and, 2) paint the house.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is a restaurant. In a restaurant, the waiters receive orders
    and serve dishes to the customers, but the meals are cooked by the chefs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In web development, several frameworks use the MVC idea, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Web2py framework** is a lightweight Python framework that embraces the
    MVC pattern. There are many examples that demonstrate how MVC can be used in Web2py
    on the project’s site ([http://web2py.com/](http://web2py.com/)) and in the GitHub
    repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Django** ([https://www.djangoproject.com/](https://www.djangoproject.com/))
    is also an MVC framework, although it uses different naming conventions. The controller
    is called *view*, and the view is called *template*. Django uses the name **Model-View
    Template** (**MVT**). According to the designers of Django, the view describes
    what data is seen by the user, and therefore, it uses the name view as the Python
    callback function for a particular URL. The term “template” in Django is used
    to separate content from representation. It describes how the data is seen by
    the user, not which data is seen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases for the MVC pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MVC is a very generic and useful design pattern. In fact, all popular web frameworks
    (Django, Rails, Symfony, and Yii) and application frameworks (iPhone SDK, Android,
    and QT) make use of MVC or a variation of it (**model-view-adapter** (**MVA**),
    **model-view-presenter** (**MVP**), or **MVT**, for example). However, even if
    we don’t use any of these frameworks, it makes sense to implement the pattern
    on our own because of the benefits it provides, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The separation between the view and model allows graphics designers to focus
    on the **user interface** (**UI**) part and programmers to focus on development,
    without interfering with each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of the loose coupling between the view and model, each part can be modified/extended
    without affecting the other. For example, adding a new view is trivial. Just implement
    a new controller for it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining each part is easier because the responsibilities are clear.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When implementing MVC from scratch, be sure that you create smart models, thin
    controllers, and dumb views.
  prefs: []
  type: TYPE_NORMAL
- en: 'A model is considered smart because it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It contains all the validation/business rules/logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It handles the state of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has access to application data (database, cloud, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not depend on the UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A controller is considered thin because it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It updates the model when the user interacts with the view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It updates the view when the model changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It processes the data before delivering it to the model/view, if necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not display the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not access the application data directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not contain validation/business rules/logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A view is considered dumb because it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It displays the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows the user to interact with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does only minimal processing, usually provided by a template language (for
    example, using simple variables and loop controls)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not store any data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not access the application data directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not contain validation/business rules/logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are implementing MVC from scratch and want to find out whether you did
    it right, you can try answering some key questions:'
  prefs: []
  type: TYPE_NORMAL
- en: If your application has a GUI, is it skinnable? How easily can you change the
    skin/look and feel of it? Can you give the user the ability to change the skin
    of your application during runtime? If this is not simple, it means that something
    is going wrong with your MVC implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your application has no GUI (for instance, if it’s a terminal application),
    how hard is it to add GUI support? Or, if adding a GUI is irrelevant, is it easy
    to add views to display the results in a chart (pie chart, bar chart, and so on)
    or a document (PDF, spreadsheet, and so on)? If these changes are not trivial
    (a matter of creating a new controller with a view attached to it, without modifying
    the model), MVC is not implemented properly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you make sure that these conditions are satisfied, your application will
    be more flexible and maintainable compared to an application that does not use
    MVC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the MVC pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I could use any of the common frameworks to demonstrate how to use MVC, but
    I feel that the picture will be incomplete. So, I decided to show you how to implement
    MVC from scratch, using a very simple example: a quote printer. The idea is extremely
    simple. The user enters a number and sees the quote related to that number. The
    quotes are stored in a `quotes` tuple. This is the data that normally exists in
    a database, file, and so on, and only the model has direct access to it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider this example for the `quotes` tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The model is minimalistic; it only has a `get_quote()` method that returns
    the quote (string) of the `quotes` tuple based on its index, `n`. The model class
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The view has three methods: `show()`, which is used to print a quote (or the
    `Not found!` message) on the screen; `error()`, which is used to print an error
    message on the screen; and `select_quote()`, which reads the user’s selection.
    This can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The controller does the coordination. The `__init__()` method initializes the
    model and view. The `run()` method validates the quoted index given by the user,
    gets the quote from the model, and passes it back to the view to be displayed,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `main()` function initializes and fires the controller, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a recap of our example (the full code is in `ch06/mvc.py` file):'
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining a variable for the list of quotes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the model class, `QuoteModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the view class, `QuoteTerminalView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the controller class, `QuoteTerminalController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we add the `main()` function to test the different classes, followed
    by the usual trick to call it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A sample execution of the `python ch06/mvc.py` command shows how the program
    prints quotes to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The Microservices pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, developers working on building a server-side application have
    been using a single code base and implementing all or most functionalities right
    there, using common development practices such as functions and classes, and design
    patterns such as the ones we have covered in this book so far.
  prefs: []
  type: TYPE_NORMAL
- en: However, with the evolution of the IT industry, economic factors, and pressure
    for fast times to market and returns on investment, there is a constant need to
    improve the practices of engineering teams and ensure more reactivity and scalability
    with servers, service delivery, and operations. We need to learn about other useful
    patterns, not only object-oriented programming ones.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – The Microservices pattern](img/B21896_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – The Microservices pattern
  prefs: []
  type: TYPE_NORMAL
- en: One of the main additions to the catalog of patterns for engineers in recent
    years has been the **Microservice Architecture** pattern or **Microservices**.
    The idea is that we can build an application as a set of loosely coupled, collaborating
    services. In this architectural style, an application might consist of services
    such as the order management service, the customer management service, and so
    on. These services are loosely coupled, independently deployable, and communicate
    via well-defined APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can cite several examples, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Netflix**: One of the pioneers in adopting microservices to handle millions
    of content streams simultaneously'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uber**: The company uses microservices to handle different aspects such as
    billing, notifications, and ride tracking'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon**: They transitioned from a monolithic architecture to microservices
    to support their ever-growing scale'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases for the Microservices pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can think of several use cases where Microservices offer a clever answer.
    We can use a Microservices architecture-based design every time we are building
    an application that has at least one of the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a requirement to support different clients, including desktop and mobile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is an API for third parties to consume
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must communicate with other applications using messaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We serve requests by accessing a database, communicating with other systems,
    and returning the right type of response (JSON, XML, HTML, or even PDF)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are logical components corresponding to different functional areas of
    the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the microservices pattern – a payment service using gRPC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s briefly talk about software installation and application deployment in
    the Microservices world. Switching from deploying a single application to deploying
    many small services means that the number of things that need to be handled increases
    exponentially. While you might have been fine with a single application server
    and a few runtime dependencies, when moving to Microservices, the number of dependencies
    will increase drastically. For example, one service could benefit from the relational
    database while the other would need **ElasticSearch**. You may need a service
    that uses **MySQL** and another one that uses the **Redis** server. So, using
    the Microservices approach also means you will need to use **containers**.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to Docker, things have become easier, since we can run those services
    as containers. The idea is that your application server, dependencies and runtime
    libraries, compiled code, configurations, and so on, are inside those containers.
    Then, all you must do is run services packed as containers and make sure that
    they can communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: You can implement the Microservices pattern, for a web app or an API, by directly
    using Django, Flask, or FastAPI. However, to quickly show a working example, we
    are going to use gRPC, a high-performance universal RPC framework that uses **Protocol
    Buffers** (**protobuf**) as its interface description language, making it an ideal
    candidate for microservices communication due to its efficiency and cross-language
    support.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a scenario where your application architecture includes a microservice
    dedicated to handling payment processing. This microservice (let’s call it `PaymentService`),
    is responsible for processing payments and interacts with other services such
    as `OrderService` and `AccountService`. We are going to focus on the implementation
    of such a service using gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the service and its methods using protobuf, in the `ch06/microservices/grpc/payment.proto`
    file. This includes specifying request and response message formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Then, you must compile the `payment.proto` file into Python code using the protobuf
    compiler (`protoc`). For that, you need to use a specific command line that invokes
    `protoc` with the appropriate plugins and options for Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the general form of the command line for compiling `.proto` files for
    use with gRPC in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: payment_pb2.py and payment_pb2_grpc.py. Those files are not to be manually edited.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we provide, in a `payment_service.py` file, the service logic for the
    payment processing, extending what has been provided in the generated `.py` files.
    In the module, we define the `PaymentServiceImpl` class, inheriting from the `payment_pb2_grpc.PaymentServiceServicer`
    class, and we override the `ProcessPayment()` method that will do what is needed
    to process the payment (e.g., calling external APIs, doing database updates, etc.)
    Note that here, we have a simplified example, but you would have more complex
    logic. The code is as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have the `main()` function, with the code needed to start the processing
    service, created by calling `grpc.server(ThreadPoolExecutor(max_workers=10))`.
    The code of the function is as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, the service is done and ready to be tested. We need a client to
    be able to test it. We can write a test client with code that calls the service
    using gRPC, with the following code (in the `ch06/microservices/grpc/client.py`
    file):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To start the service (in the `ch06/microservices/grpc/payment_service.py` file),
    you can run the following command:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output, showing that the service has started as
    expected:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: python ch06/microservices/grpc/client.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Payment Service responded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Response status: SUCCESS'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: import os
  prefs: []
  type: TYPE_NORMAL
- en: import uvicorn
  prefs: []
  type: TYPE_NORMAL
- en: from lanarky import Lanarky
  prefs: []
  type: TYPE_NORMAL
- en: from lanarky.adapters.openai.resources import ChatCompletionResource
  prefs: []
  type: TYPE_NORMAL
- en: from lanarky.adapters.openai.routing import OpenAIAPIRouter
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: os.environ["OPENAI_API_KEY"] = "Your OpenAI API key here"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: app = Lanarky()
  prefs: []
  type: TYPE_NORMAL
- en: router = OpenAIAPIRouter()
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '@router.post("/chat")'
  prefs: []
  type: TYPE_NORMAL
- en: 'def chat(stream: bool = True) -> ChatCompletionResource:'
  prefs: []
  type: TYPE_NORMAL
- en: system = "Here is your assistant"
  prefs: []
  type: TYPE_NORMAL
- en: return ChatCompletionResource(stream=stream, system=system)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'if __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: app.include_router(router)
  prefs: []
  type: TYPE_NORMAL
- en: uvicorn.run(app)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: import click
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: from lanarky.clients import StreamingClient
  prefs: []
  type: TYPE_NORMAL
- en: args = sys.argv[1:]
  prefs: []
  type: TYPE_NORMAL
- en: 'if len(args) == 1:'
  prefs: []
  type: TYPE_NORMAL
- en: message = args[0]
  prefs: []
  type: TYPE_NORMAL
- en: client = StreamingClient()
  prefs: []
  type: TYPE_NORMAL
- en: for event in client.stream_response(
  prefs: []
  type: TYPE_NORMAL
- en: '"POST",'
  prefs: []
  type: TYPE_NORMAL
- en: '"/chat",'
  prefs: []
  type: TYPE_NORMAL
- en: 'params={"stream": "false"},'
  prefs: []
  type: TYPE_NORMAL
- en: 'json={"messages": [dict(role="user", content=message)]},'
  prefs: []
  type: TYPE_NORMAL
- en: '):'
  prefs: []
  type: TYPE_NORMAL
- en: 'print(f"{event.event}: {event.data}")'
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: print("You need to pass a message!")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: python ch06/microservices/lanarky/llm_service.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: INFO:   Started server process [18617]
  prefs: []
  type: TYPE_NORMAL
- en: INFO:   Waiting for application startup.
  prefs: []
  type: TYPE_NORMAL
- en: INFO:   Application startup complete.
  prefs: []
  type: TYPE_NORMAL
- en: INFO:   Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: python ch06/microservices/lanarky/client.py "Hello"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'completion: Hello! How can I assist you today?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: python ch06/microservices/lanarky/client.py "What is the capital of Switzerland?"
  prefs: []
  type: TYPE_NORMAL
- en: 'completion: The capital of Switzerland is Bern.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: import json
  prefs: []
  type: TYPE_NORMAL
- en: 'def lambda_handler(event, context):'
  prefs: []
  type: TYPE_NORMAL
- en: number = event["number"]
  prefs: []
  type: TYPE_NORMAL
- en: squared = number * number
  prefs: []
  type: TYPE_NORMAL
- en: return f"The square of {number} is {squared}."
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'ch06/lambda_function_square.py) to a ZIP file, for example, by using the ZIP
    program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: awslocal lambda create-function \
  prefs: []
  type: TYPE_NORMAL
- en: --function-name lambda_function_square \
  prefs: []
  type: TYPE_NORMAL
- en: --runtime python3.11 \
  prefs: []
  type: TYPE_NORMAL
- en: --zip-file fileb://lambda.zip \
  prefs: []
  type: TYPE_NORMAL
- en: --handler lambda_function_square.lambda_handler \
  prefs: []
  type: TYPE_NORMAL
- en: --role arn:aws:iam::000000000000:role/lambda-role
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: awslocal lambda invoke --function-name lambda_function_square \
  prefs: []
  type: TYPE_NORMAL
- en: 'output.txt file’s content. You should see the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: awslocal lambda create-function-url-config \
  prefs: []
  type: TYPE_NORMAL
- en: --function-name lambda_function_square \
  prefs: []
  type: TYPE_NORMAL
- en: http://<XXXXXXXX>.lambda-url.us-east-1.localhost.localstack.cloud:4566 format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, for example, we can trigger the Lambda function URL using `cUrl`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For up-to-date and detailed guides related to AWS Lambda, consult the documentation
    at [https://docs.aws.amazon.com/lambda/](https://docs.aws.amazon.com/lambda/).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: This was a minimal example. Another example of a serverless application could
    be a function that generates PDF receipts for a business. This would allow the
    business to not worry about server management and only pay for the computing time
    that is consumed.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The Event Sourcing pattern
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The Event Sourcing pattern stores state changes as a sequence of events, allowing
    the reconstruction of past states and providing an audit trail. This pattern is
    particularly useful in systems where the state is complex and the business rules
    for transitions are complex.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: As we will see in implementation examples later, the Event Sourcing pattern
    emphasizes the importance of capturing all changes to an application state as
    a sequence of events. An outcome of this is that the application state can be
    reconstructed at any point in time by replaying these events.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There are several real-world examples in the software category:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Audit trails**: Keeping a record of all changes made to a database for compliance'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaborative editing**: Allowing multiple users to edit a document simultaneously'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Undo/redo features**: Providing the ability to undo or redo actions in an
    application'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases for the Event Sourcing pattern
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There are several use cases for the Event Sourcing pattern. Let’s consider
    the following three:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Financial transactions**: Event Sourcing can be used to record every change
    to an account’s balance as a chronological series of immutable events. This method
    ensures that every deposit, withdrawal, or transfer is captured as a distinct
    event. This way, we can provide a transparent, auditable, and secure ledger of
    all financial activities.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inventory management**: Within inventory management contexts, Event Sourcing
    helps in tracking each item’s life cycle by logging all changes as events. This
    enables businesses to maintain accurate and up-to-date records of stock levels,
    identify patterns in item usage or sales, and predict future inventory needs.
    It also facilitates tracing the history of any item, aiding in recall processes
    or quality assurance investigations.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customer behavior tracking**: Event Sourcing plays a critical role in capturing
    and storing every interaction a customer has with a platform, from browsing history
    and cart modifications to purchases and returns. This wealth of data, structured
    as a series of events, becomes a valuable resource for analyzing customer behavior,
    personalizing marketing strategies, enhancing user experience, and improving product
    recommendations.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s now see how we can implement this pattern.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Implementing the event sourcing pattern – the manual way
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s start with some definitions. The components of the Event Sourcing pattern
    implementation are as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Event**: A representation of a state change, typically containing the type
    of event and the data associated with that event. Once an event is created and
    applied, it cannot be changed.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aggregate**: An object (or group of objects) that represents a single unit
    of business logic or data. It keeps track of things, and every time something
    changes (an event), it makes a record of it.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event store**: A collection of all the events that have occurred.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: By handling state changes through events, the business logic becomes more flexible
    and easier to extend. For example, adding new types of events or modifying the
    handling of existing events can be done with minimal impact on the rest of the
    system.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In this first example, for the bank account use case, we will see how to implement
    the event sourcing pattern in a manual way. In such an implementation, you would
    typically define your event classes and manually write the logic to apply these
    events to your aggregates. Let’s see that.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We start by defining an `Account` class representing a bank account with a balance
    and a list of events attached to it, for the operations on the account. This class
    acts as the aggregate. Its `events` attribute represents the event store. Here,
    an event will be represented by a dictionary containing the type of operation
    (“deposited” or “withdrawn”) and the amount value.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We then add the `apply_event()` method taking an event as the input. Depending
    on `event["type"]`, we increment or decrement the account balance by the event’s
    amount, and we add the event to the `events` list, effectively storing the event:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add a `deposit()` method and a `withdraw()` method, which both call
    the `apply_event()` method, as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add the `main()` function, as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code, using the `python ch06/ event_sourcing/bankaccount.py` command,
    gives the following output:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This example provided a first understanding of Event Sourcing through a simple,
    manual implementation. For more complex systems, frameworks and libraries designed
    for Event Sourcing can help manage some of this complexity, providing utilities
    for event storage, querying, and processing. We will test such a library next.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Implementing the Event Sourcing pattern – using a library
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In this second example, we will use the `eventsourcing` library to implement
    the Event Sourcing pattern. Let’s consider an inventory management system where
    we track the quantity of items.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We start by importing what we need, as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define the class for the aggregate object, `InventoryItem`, by inheriting
    from the `Aggregate` class. The class has an `increase_quantity()` and a `decrease_quantity`
    method, each decorated with the `@event` decorator. The code for this class is
    as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create our inventory application’s class, `InventoryApp`, inheriting
    from the `eventsourcing` library’s `Application` class. The first method handles
    the creation of an item, taking an instance of the `InventoryItem` class (`item`)
    and calling the `save()` method on the `InventoryApp` object using the item. But
    what exactly does the `save()` method do? It collects pending events from given
    aggregates and puts them in the application’s event store. The definition of the
    class starts as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, similarly to what we did in the previous example, we add an `increase_item_quantity()`
    method, which handles the increase of the item’s quantity (for the aggregate object)
    and then saves the aggregate object on the application, followed by the corresponding
    `decrease_item_quantity()` method, for the decreasing action, as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add the `main()` function, with some code to test our design, as
    follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code, using the `python ch06/ event_sourcing/inventory.py` command,
    gives the following output:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
