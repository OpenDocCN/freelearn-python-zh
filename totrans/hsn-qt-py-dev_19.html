<html><head></head><body>
        

                            
                    <h1 class="header-title">Threading and Multiprocessing</h1>
                
            
            
                
<p class="mce-root">As we have seen throughout this book, if we keep on adding new functionalities to our GUI application, we will have some problems, such as the application freezing, operation speed dropping, problems with simultaneous execution, and many more uncomfortable cases. These are the problems that occur in any multi-functional application. In our own experience, when we use Microsoft Office, design tools, or other software that uses a lot of memory resources, we encounter various waits, freezes, and so on. If we add to the functionality of the app that we are creating, at some stage, the app will become slow (in the best case) and will be not as functional as we want it to be. Why does this happen? In most cases, almost every operating system details the processes and threads of execution. We can open the Task Manager of our operating system and see that various programs are running as processes (tasks). They have <strong>process IDs</strong> (<strong>PIDs</strong>), names, and so on. These applications (processes) operate with some internal tasks and usually have threads of execution from additional operations. They can also operate with external tasks, that is, independent processes. These processes can contain multiple threads that execute tasks concurrently. When our created application is running in one process and as one thread and the app has a lot of tasks, the available memory resources may be not enough to run them all. The solution to this problem is to split tasks into different threads and maybe into different processes if need be. This chapter will introduce these aspects of GUI creation. We will explore Qt library instruments such as <kbd>QProcess</kbd> and <kbd>QThread</kbd>. We will also demonstrate Python standard library tools that can easily be implemented in the GUI. We will also examine the advantages and disadvantages of these instruments.</p>
<p class="mce-root">In this chapter, we will cover the following topics:</p>
<ul>
<li>Processes</li>
<li>Threads</li>
<li>Locks</li>
<li>Python standard library tools</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Processes</h1>
                
            
            
                
<p>Processes (in computing) are the main part of any environment. In a broad sense, a process is an instance of a program that executes the application. It can have more than one process for operating tasks and usually includes multiple threads. If only a single CPU is used, only one process can be executed at any one time. However, if the CPU has multiple cores, the execution of tasks can be split between these cores. However, this doesn't mean that a multi-core architecture concurrently executes all processes/tasks that operate. In reality, the system multitasks, which means that when new tasks start, they can interrupt tasks that have already started, they can be interrupted by new tasks, and they can be started again. In this way, the execution of the processes is split into the segments that operate concurrently. A common situation is when the main program has a single parent process and the child processes are executed in parallel. Communication between processes usually occurs by using the input channel (stream of data) <kbd>STDIN</kbd> (standard input) and two predefined output channels (separate streams of data) – <kbd>STDOUT</kbd> (standard output) and <kbd>STDERR</kbd> (standard error), in this case. The channels of the process are also known as the <strong>read</strong> (<kbd>STDOUT</kbd> and <kbd>STDERR</kbd>) and <strong>write</strong> (<kbd>STDIN</kbd>) channels. One of the ways that the Qt library runs new processes and implements <strong>Inter-Process Communication</strong> (<strong>IPC</strong>) in applications is by using the <kbd>QProcess</kbd> class. This class allows us to manage an application's external processes. <kbd>QProcess</kbd> is a cross-platform class that's available in the <kbd>QtCore</kbd> module of the Qt library. In an application, it can be used to start external programs as child processes and communicate with them, depending on the operating tasks. This mechanism is an API that controls and monitors the states of the child processes. The <kbd>QProcess</kbd> class also provides access to the I/O (input/output) channels of child processes by inheriting from the <strong><kbd>QtCore.QIODevice</kbd></strong> class. A simple example of these operations is running a third-party application that implements additional functionality, such as opening a web browser or running servers. It also can be used for long-term tasks, including loops and estimation. However, the <kbd>QProcess</kbd> class does not support some platforms, such as iOS. Therefore, the application can use Python standard library tools such as the <kbd>subprocess</kbd> module and the multiprocessing package.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Application processes</h1>
                
            
            
                
<p>To understand application processes that occur when we create and run GUI or non-GUI applications, we need to know about the Qt modules and the inheritance scheme of the classes that participate in the application's processes. The <kbd>QCoreApplication</kbd> class of the <kbd>QtCore</kbd> module inherits from the <kbd>QObject</kbd> class and creates the event loop of non-GUI applications. The <kbd>QGuiApplication</kbd> class of the <kbd>QtGui</kbd> module inherits <kbd>QCoreApplication</kbd> and manages the control flow with the main settings of the GUI app. The <kbd>QApplication</kbd> class of the <kbd>QtWidgets</kbd> module inherits <kbd>QGuiApplication</kbd> and manages the control flow with the main settings of the GUI application relative to the <kbd>QWidget</kbd> class, based on additional functionality. To access the application object, you can use global pointers:</p>
<ul>
<li><kbd>QtCore.QCoreApplication.instance()</kbd>: For <kbd>QCoreApplication</kbd>, <kbd>QGuiApplication</kbd>, and <kbd>QApplication</kbd>.</li>
<li><kbd>QtGui.QGuiApplication.qGuiApp</kbd>: For <kbd>QGuiApplication</kbd>.</li>
<li><kbd>QtWidgets.QApplication.qApp</kbd>: For <kbd>QApplication</kbd>.</li>
</ul>
<p>In the application, long-term tasks (loops) can also be used with the <kbd>processEvents()</kbd> static method of the <kbd>QCoreApplication</kbd> class. The creation of long-term operations usually looks like this:</p>
<pre>...<br/>    def long_task():<br/>        while True:<br/>            QtWidgets.qApp.processEvents(QtCore.QEventLoop.AllEvents)<br/>            print("HELLO")<br/>    ...<br/>...</pre>
<p>This <kbd>while</kbd> instruction is infinite and will print the string until it is stopped by pressing <em>Ctrl</em> + <em>Z</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QProcess</h1>
                
            
            
                
<p>This class provides Qt library instruments that you can use when working with processes in an application. Using this class starts external tasks (programs) in separate processes and organizes communication with them. The declaration syntax of this class is as follows:</p>
<pre><strong>process</strong> = QtCore.QProcess()</pre>
<p><kbd>QProcess</kbd> inherits from <kbd>QIODevice</kbd>, which is the base interface class of all I/O devices in the Qt library, and improves functionality with the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These functions set the parameters/properties of the process:</p>
<p><kbd>process.setArguments([str])</kbd>: This sets the arguments, specified in the parameter, for the called program when this process starts.</p>
<p><kbd>process.setEnvironment(["environment"])</kbd>: This sets the environment, specified in the parameter, that will be used with this process.</p>
<p><kbd>process.setInputChannelMode(QtCore.QProcess.InputChannelMode)</kbd>: This sets the channel mode, specified in the parameter, for the <kbd>STDIN</kbd> of this process. The available input channel modes are as follows:</p>
<ul>
<li><strong><kbd>QtCore.QProcess.ManagedInputChannel</kbd></strong>—<kbd>0</kbd>: This process manages the input of the running process.</li>
<li><strong><kbd>QtCore.QProcess.ForwardedInputChannel</kbd></strong>—<kbd>1</kbd>: This process forwards the input of the main process onto the running process.</li>
</ul>
<p><kbd>process.setProcessChannelMode(QtCore.QProcess.ProcessChannelMode)</kbd>: This sets the channel mode, specified in the parameter, for the <kbd>STDOUT</kbd> (standard output) of this process. The available process channel modes are as follows:</p>
<ul>
<li><kbd>QtCore.QProcess.SeparateChannels</kbd>—<kbd>0</kbd>: <kbd>STDOUT</kbd> and <kbd>STDERR</kbd> data in separate internal buffers.</li>
<li><kbd>QtCore.QProcess.MergedChannels</kbd>—<kbd>1</kbd>: This merges the output of the process into the <kbd>STDOUT</kbd> (standard output) channel.</li>
<li><kbd>QtCore.QProcess.ForwardedChannels</kbd>—<kbd>2</kbd>: This forwards the output of the process to the main process.</li>
<li><kbd>QtCore.QProcess.ForwardedErrorChannel</kbd>—<kbd>4</kbd>: This forwards the <kbd>STDERR</kbd> (standard error) to the main process.</li>
</ul>
<p><kbd>process.setProcessEnvironment(QtCore.QProcessEnvironment)</kbd>: This sets the environment, specified in the parameter, that will be used with this process.</p>
<p><kbd>process.setProcessState(QtCore.QProcess.ProcessState)</kbd>: This sets the process state, specified in the parameter, of this process. The available states are as follows:</p>
<ul>
<li><kbd>QtCore.QProcess.NotRunning</kbd>—<kbd>0</kbd>: This process is not running.</li>
<li><kbd>QtCore.QProcess.Starting</kbd>—<kbd>1</kbd>: This process is starting, but the program that the process operates hasn't been invoked yet.</li>
<li><kbd>QtCore.QProcess.Running</kbd>—<kbd>2</kbd>: This process is running and ready.</li>
</ul>
<ul>
<li><kbd>process.setProgram("program")</kbd>: This sets the program, specified in the parameter, that will be started in this process.</li>
<li><kbd>process.setReadChannel(QtCore.QProcess.ProcessChannel)</kbd>: This sets the channel, specified in the parameter, for this process. The available process channels are as follows:
<ul>
<li><kbd>QtCore.QProcess.StandardOutput</kbd>—<kbd>0</kbd>: The <kbd>STDOUT</kbd> (standard output) of the process.</li>
<li><kbd>QtCore.QProcess.StandardError</kbd>—<kbd>1</kbd>: The <kbd>STDERR</kbd> (standard error) of the process.</li>
</ul>
</li>
</ul>
<p><kbd>process.setStandardErrorFile("path/to/the/filename", QtCore.QIODevice.OpenMode)</kbd>: This redirects the <kbd>STDERR</kbd> (standard error) to the file (the first parameter) relative to the file mode (the second parameter).</p>
<p><kbd>process.setStandardInputFile("path/to/the/filename")</kbd>: This redirects the <kbd>STDIN</kbd> (standard input) to the file specified in the parameter.</p>
<p><kbd>process.setStandardOutputFile("path/to/the/filename", QtCore.QIODevice.OpenMode)</kbd>: This redirects the <kbd>STDOUT</kbd> (standard output) to the file (the first parameter) relative to the file mode (the second parameter).</p>
<p><kbd>process.setStandardOutputProcess(QtCore.QProcess)</kbd>: This pipes the <kbd>STDOUT</kbd> (standard output) stream of this process to the <kbd>STDIN</kbd> (standard input) of the process specified in the parameter.</p>
<p><kbd>process.setWorkingDirectory("path/to/dir")</kbd>: This sets the working directory, specified in the parameter, where this process will be started.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">is</h1>
                
            
            
                
<p>This function returns a Boolean value (<kbd>bool</kbd>) related to the process' state:</p>
<p><kbd>process.isSequential()</kbd>: This returns <kbd>True</kbd> if this process is sequential.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These functions relate to the current values of the process, changes in functionality, and so on:</p>
<p><kbd>process.arguments()</kbd>: This returns the list of the most -recently started process' command-line arguments.</p>
<p><kbd>process.atEnd()</kbd>: This returns <kbd>True</kbd> if this process is not running, and there is no more data to read.</p>
<p><kbd>process.bytesAvailable()</kbd>: This returns the bytes that are available for reading with this process.</p>
<p><kbd>process.bytesToWrite()</kbd>: This returns the bytes that are available for writing with this process.</p>
<p><kbd>process.canReadLine()</kbd>: This returns <kbd>True</kbd> if a complete line of data can be read with this process.</p>
<p><kbd>process.close()</kbd>: This kills this process and closes all communications.</p>
<p><kbd>process.closeReadChannel(QtCore.QProcess.ProcessChannel)</kbd>: This closes the read channel specified in the parameter.</p>
<p><kbd>process.closeWriteChannel()</kbd>: This closes the channel once all the data has been written.</p>
<p><kbd>process.environment()</kbd>: This returns the environment for this process.</p>
<p><kbd>process.error()</kbd>: This returns the last error that occurred of the <kbd>QtCore.QProcess.ProcessError</kbd> type. The available process errors are as follows:</p>
<ul>
<li><kbd>QtCore.QProcess.FailedToStart</kbd>—<kbd>0</kbd>: This process failed to start.</li>
<li><kbd>QtCore.QProcess.Crashed</kbd>—<kbd>1</kbd>: This process crashed.</li>
<li><strong><kbd>QtCore.QProcess.Timedout</kbd></strong>—<kbd>2</kbd>: This process timed out.</li>
<li><kbd>QtCore.QProcess.ReadError</kbd>—<kbd>3</kbd>: An error with reading from this process.</li>
<li><kbd>QtCore.QProcess.WriteError</kbd>—<kbd>4</kbd>: An error with writing to this process.</li>
<li><kbd>QtCore.QProcess.UnknownError</kbd>—<kbd>5</kbd>: An unknown error in this process.</li>
</ul>
<p><kbd>process.execute("command")</kbd>: This starts the command, specified in the parameter, in the new process.</p>
<p><kbd>process.execute("program", "arguments")</kbd>: This starts the program (the first parameter) with arguments (the second parameter) in the new process.</p>
<p><kbd>process.exitCode()</kbd>: This returns the last process exit code.</p>
<p><kbd>process.exitStatus()</kbd>: This returns the last process exit status of the <strong><kbd>QtCore.QProcess.ExitStatus</kbd></strong> type. The available exit statuses are as follows:</p>
<ul>
<li><kbd>QtCore.QProcess.NormalExit</kbd>—<kbd>0</kbd>: This process exited normally.</li>
<li><kbd>QtCore.QProcess.CrashExit</kbd>—<kbd>1</kbd>: This process crashed.</li>
</ul>
<p><kbd>process.inputChannelMode()</kbd>: This returns the channel mode of the <kbd>QtCore.QProcess.InputChannelMode</kbd> type for this process' <kbd>STDIN</kbd> (standard input) channel.</p>
<p><kbd>process.kill()</kbd>: This kills this process and exits immediately.</p>
<p><kbd>process.nullDevice()</kbd>: This is the null device of the operating system that's used to discard the output streams of a process or empty files for input streams.</p>
<p><kbd>process.open(QtCore.QIODevice.OpenMode)</kbd>: This opens the process with the mode specified in the parameter.</p>
<p><kbd>process.processChannelMode()</kbd>: This returns the channel mode of the <kbd>QtCore.QProcess.ProcessChannelMode</kbd> type for the standard output and standard error channels of this process.</p>
<p><kbd>process.processEnvironment()</kbd>: This returns the environment of the <kbd>QtCore.QProcessEnvironment</kbd> type for this process.</p>
<p><kbd>process.processId()</kbd>: This returns the native ID for the running process.</p>
<p><kbd>process.program()</kbd>: This returns the last program that started with this process.</p>
<p><kbd>process.readAllStandardError()</kbd>: This returns all the error data of the <kbd>QtCore.QByteArray</kbd> type from the <kbd>STDERR</kbd> of this process.</p>
<p><kbd>process.readAllStandardOutput()</kbd>: This returns all the data of the <kbd>QtCore.QByteArray</kbd> type from the <kbd>STDOUT</kbd> of this process.</p>
<p><kbd>process.readChannel()</kbd>: This returns the read channel of the <strong><kbd>QtCore.QProcess.ProcessChannel</kbd></strong> type for this process.</p>
<p><kbd>process.readData(int)</kbd>: This reads the bytes limited to a maximum size, specified in the parameter, into data.</p>
<p><kbd>process.start(QtCore.QIODevice.OpenMode)</kbd>: This starts the program with the mode specified in the parameter in the new process.</p>
<p><kbd>process.start("command", QtCore.QIODevice.OpenMode)</kbd>: This starts the command (the first parameter) with the mode (the second parameter) in the new process.</p>
<p><kbd>process.start("program", ["arguments"], QtCore.QIODevice.OpenMode)</kbd>: This starts the program (the first parameter) with arguments (the second parameter) relative to the mode (the third parameter) in the new process.</p>
<p><kbd>process.startDetached()</kbd>: This starts the program in the new process, then detaches from this process.</p>
<p><kbd>process.startDetached(int)</kbd>: This starts the program in the new process with the process ID specified in the parameter, then detaches from this process.</p>
<p><kbd>process.startDetached("command")</kbd>: This starts the command specified in the parameter in the new process, then detaches from this process.</p>
<p><kbd>process.startDetached("program", ["arguments"])</kbd>: This starts the program (the first parameter) with arguments (the second parameter) in the new process, then detaches from this process.</p>
<p><kbd>process.startDetached("program", ["arguments"], "path/to/dir")</kbd>: This starts the program (the first parameter) with arguments (the second parameter) and the working directory (the third parameter) in the new process, then detaches from this process.</p>
<p><kbd>process.state()</kbd>: This returns the current state of the <kbd>QtCore.QProcess.ProcessState</kbd> type for this process.</p>
<p class="mce-root"/>
<p><kbd>process.systemEnvironment()</kbd>: This returns the system environment for this process.</p>
<p><kbd>process.terminate()</kbd>: This terminates the process.</p>
<p><kbd>process.waitForBytesWritten(int)</kbd>: This waits for the number of milliseconds specified in the parameter until a payload of buffered written bytes has been written.</p>
<p><kbd>process.waitForFinished(int)</kbd>: This waits for the number of milliseconds specified in the parameter, blocking the process until this process has finished.</p>
<p><kbd>process.waitForReadyRead(int)</kbd>: This waits for the number of milliseconds specified in the parameter, blocking the process until new data is available for reading.</p>
<p><kbd>process.waitForStarted(int)</kbd>: This waits for the number of milliseconds specified in the parameter, blocking the process until this process has started.</p>
<p><kbd>process.workingDirectory()</kbd>: This returns the working directory that's used for this process.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">signals</h1>
                
            
            
                
<p>The following signals are available with the <kbd>QProcess</kbd> class:</p>
<p><kbd>process.errorOccurred(QtCore.QProcess.ProcessError)</kbd>: This signal is emitted when an error occurs with this process, with the error passed in the parameter.</p>
<p><kbd>process.finished(int, QtCore.QProcess.ExitStatus)</kbd>: This signal is emitted when this process has finished, with the exit code and the exit status passed in the parameter.</p>
<p><kbd>process.readyReadStandardError()</kbd>: This signal is emitted when this process makes new data available on the <kbd>STDERR</kbd> channel.</p>
<p><kbd>process.readyReadStandardOutput()</kbd>: This signal is emitted when this process makes new data available on the <kbd>STDOUT</kbd> channel.</p>
<p><kbd>process.started()</kbd>: This signal is emitted when this process starts.</p>
<p><kbd>process.stateChanged(QtCore.QProcess.ProcessState)</kbd>: This signal is emitted when the state of this process changes, with the new process state passed in the parameter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QProcessEnvironment</h1>
                
            
            
                
<p>This class creates the environment variables that can be used when you start a program that uses processes in the application. The process' environment variables are represented as a set of <em>key/value</em> pairs, such as <kbd>["PATH=/Path/To/dir", "USER=user"]</kbd>.  The declaration syntax of this class is as follows:</p>
<pre><strong>process_env</strong> = QtCore.QProcessEnvironment()</pre>
<p>The <kbd>QProcessEnvironment</kbd> class improves functionality with the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">is</h1>
                
            
            
                
<p>This function returns a Boolean value (<kbd>bool</kbd>) related to the process environment states:</p>
<p><kbd>process_env.isEmpty()</kbd>: This returns <kbd>True</kbd> if this process environment is empty and doesn't have any environment variables.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These functions relate to the current values of the process environment, changes in functionality, and so on:</p>
<p><kbd>process_env.clear()</kbd>: This clears all key/value pairs from this process environment.</p>
<p><kbd>process_env.contains(str)</kbd>: This returns <kbd>True</kbd> if the variable with the name specified in the parameter is found in this process environment.</p>
<p><kbd>process_env.insert(QtCore.QProcessEnvironment)</kbd>: This inserts the contents of the process environment specified in the parameter in this process environment.</p>
<p><kbd>process_env.insert(str, str)</kbd>: This inserts the key (the first parameter) and value (the second parameter) of the environment variable in this process environment.</p>
<p><kbd>process_env.keys()</kbd>: This returns a list with all the environment variable keys of this process environment.</p>
<p><kbd>process_env.remove(str)</kbd>: This removes the environment variable that contains the name (key) specified in the parameter.</p>
<p><kbd>process_env.swap(QtCore.QProcessEnvironment)</kbd>: This swaps this process environment with the process environment specified in the parameter.</p>
<p><kbd>process_env.systemEnvironment()</kbd>: This returns the system environment of the <strong><kbd>QtCore.QProcessEnvironment</kbd></strong> type for the process.</p>
<p><kbd>process_env.toStringList()</kbd>: This converts this process environment into a list of strings of key/value pairs.</p>
<p><kbd>process_env.value(str, str)</kbd>: This returns the value of the name (key) specified in the first parameter, or the default value (the second parameter) if the variable with the name passed in does not exist in this process environment.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Process example</h1>
                
            
            
                
<p>Let's look at an example of the using <kbd>QProcess</kbd> class by making some additions to our application. We will use the QML script we used previously in this book to visualize the buttons in the applications section of the tab widget, and we will run these apps by clicking on a few of them. Note that processes created with the <kbd>QProcess</kbd> class may not work with some operating systems, and for this reason, the <kbd>subprocess</kbd> module constructions are still commented. So, to do this, we need to copy the directories we used with the QML implementation, such as <kbd>qmls/</kbd> and <kbd>jscripts/</kbd>, into our working directory. We also need to copy the <kbd>u_qml.qml</kbd> file. Now, we need to create new <kbd>apps.qml</kbd> files in both the <kbd>App/App_PySide2/</kbd> and <kbd>App/App_PyQt5/</kbd> directories, which will contain the QML script for the buttons in the applications. The <kbd>apps.qml</kbd> file looks as follows, and can be copied and modified from the <kbd>qmls/UGrid.qml</kbd> file we created earlier:</p>
<ol>
<li>Add the QML import section, a base <kbd>Rectangle</kbd>, along with its properties, and a grid layout for the buttons to the <kbd>apps.qml</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">import QtQuick 2.7<br/>import QtQuick.Layouts 1.3<br/>import "qmls" as Uqmls<br/><br/>Rectangle {<br/>    visible: true<br/>    color: Qt.rgba(0, 0.07, 0.14, 1);<br/>    GridLayout {<br/>        id: grid1; anchors.fill: parent; visible: true<br/>        function wsize() {<br/>            if (width &lt; 590) {return 1;} else {return 2;};<br/>        }<br/>        columns: wsize();<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This is the parent rectangle for all the rectangles in QML. Note that, while writing this book, the versions of Qt changed, and the <kbd>QtQuick</kbd> versions changed as well. So, before using the QML script, it is recommended that you check the available versions.</p>
<ol start="2">
<li>Add the first glow button, which will be used for running the video camera, to the grid layout:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        Uqmls.URectGlow {<br/>            id: g5; Layout.fillWidth: true<br/>            Layout.fillHeight: true<br/>            Layout.margins: 20<br/>            color: Qt.rgba(0, 0.07, 0.14, 1);<br/>            glowcolor: Qt.rgba(0.007, 1, 1, 1);<br/>            txglow: Qt.rgba(0.007, 0.7, 0.7, 1);<br/>            txtext: "Camera"<br/>            txcolor: Qt.rgba(0.2, 0.2, 0.2, 1)<br/>            signal clicked();<br/>            MouseArea { <br/>                anchors.fill: parent<br/>                onClicked: {<br/>                    g5.glowcolor == Qt.rgba(0.007, 1, 1, 1) ?<br/>                    g5.glowcolor = Qt.rgba(0, 0.07, 0.14, 1) :<br/>                    g5.glowcolor = Qt.rgba(0.007, 1, 1, 1);<br/>                    g5.txglow == Qt.rgba(0, 0.07, 0.14, 1) ?<br/>                    g5.txglow = Qt.rgba(0.007, 1, 1, 1) :<br/>                    g5.txglow = Qt.rgba(0, 0.07, 0.14, 1);<br/>                    g5.clicked();<br/>                }<br/>            }<br/>        }<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This is the first rectangle with a glow effect and will call the video camera application in a separate window. </p>
<ol start="3">
<li>Add the second glow button, which will be used to run the QML application example, to the grid layout:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        Uqmls.URectGlow {<br/>            id: g6; Layout.fillWidth: true;<br/>            Layout.fillHeight: true<br/>            Layout.margins: 20<br/>            color: Qt.rgba(0, 0.07, 0.14, 1);<br/>            glowcolor: Qt.rgba(0.95, 0, 0, 1);<br/>            txglow: Qt.rgba(0.77, 0, 0, 1);<br/>            txtext: "QMLS"<br/>            txcolor: Qt.rgba(0.2, 0.2, 0.2, 1)<br/>            signal clicked();<br/>            MouseArea {<br/>                anchors.fill: parent<br/>                onClicked: {<br/>                    g6.glowcolor == Qt.rgba(0.95, 0, 0, 1) ?<br/>                    g6.glowcolor = Qt.rgba(0, 0.07, 0.14, 1) :<br/>                    g6.glowcolor = Qt.rgba(0.95, 0, 0, 1);<br/>                    g6.txglow == Qt.rgba(0, 0.07, 0.14, 1) ?<br/>                    g6.txglow = Qt.rgba(0.77, 0, 0, 1) :<br/>                    g6.txglow = Qt.rgba(0, 0.07, 0.14, 1);<br/>                    g6.clicked(); <br/>                }<br/>            }<br/>        }<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This is the second rectangle with a glow effect, which will call the QML application through the created <kbd>clicked()</kbd> signal that will be used.</p>
<ol start="4">
<li>Add the third glow button, which will be used to run Jupyter Notebook, to the grid layout:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        Uqmls.URectGlow {<br/>            id: g7; Layout.fillWidth: true<br/>            Layout.fillHeight: true<br/>            Layout.margins: 20<br/>            color: Qt.rgba(0, 0.07, 0.14, 1);<br/>            glowcolor: Qt.rgba(0,0.95,0.37,1);<br/>            txglow: Qt.rgba(0,0.47,0.37,1);<br/>            txtext: "JUPYTER"<br/>            txcolor: Qt.rgba(0.2, 0.2, 0.2, 1)<br/>            signal clicked();<br/>            MouseArea {<br/>                anchors.fill: parent <br/>                onClicked: {<br/>                    g7.glowcolor == Qt.rgba(0, 0.95, 0.37, 1) ?<br/>                    g7.glowcolor = Qt.rgba(0, 0.07, 0.14, 1) :<br/>                    g7.glowcolor = Qt.rgba(0, 0.95, 0.37, 1);<br/>                    g7.txglow == Qt.rgba(0, 0.07, 0.14, 1) ?<br/>                    g7.txglow = Qt.rgba(0, 0.47, 0.37, 1) :<br/>                    g7.txglow = Qt.rgba(0, 0.07, 0.14, 1);<br/>                    g7.clicked(); <br/>                }<br/>            }<br/>        }<br/>        ...<br/>    ...<br/>...</pre>
<p class="mce-root" style="padding-left: 60px">The third rectangle with a glow effect will start the Jupyter Notebook in the separated process that's created with the <kbd>QProcess</kbd> class.</p>
<ol start="5">
<li>Finally, add the fourth glow button, which will be used to run the default web browser, to the grid layout, thereby completing the QML file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        Uqmls.URectGlow {<br/>            id: g8; Layout.fillWidth: true; Layout.fillHeight: true<br/>            Layout.margins: 20<br/>            color: Qt.rgba(0, 0.07, 0.14, 1);<br/>            glowcolor: Qt.rgba(1, 1, 1, 1);<br/>            txglow: "grey";<br/>            txtext: "WEB"<br/>            txcolor: Qt.rgba(0.2, 0.2, 0.2, 1)<br/>            signal clicked();<br/>            MouseArea {<br/>                anchors.fill: parent<br/>                onClicked: {<br/>                    g8.glowcolor == Qt.rgba(1, 1, 1, 1) ?<br/>                    g8.glowcolor = Qt.rgba(0, 0.07, 0.14, 1) :<br/>                    g8.glowcolor = Qt.rgba(1, 1, 1, 1);<br/>                    g8.txglow == Qt.rgba(0, 0.07, 0.14, 1) ?<br/>                    g8.txglow = "grey" :<br/>                    g8.txglow = Qt.rgba(0, 0.07, 0.14, 1);<br/>                    g8.clicked();<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">The fourth rectangle with a glow effect will open the default web browser for the system in a separate process.</p>
<p>Now, we need to make some changes in the <kbd>u_app.py</kbd> file to implement the QML script in the application that will run new processes, such as QML apps and other third-party programs:</p>
<ol>
<li>First, add the following lines to the import section of each file:</li>
</ol>
<ul>
<li style="padding-left: 30px">Add the following to the PySide2 <kbd>u_app.py</kbd> file:</li>
</ul>
<pre style="padding-left: 90px">...<br/>from PySide2 import QtQuickWidgets<br/>...</pre>
<ul>
<li style="padding-left: 30px">Add the following to the PyQt5 <kbd>u_app.py</kbd> file:</li>
</ul>
<pre style="padding-left: 90px">...<br/>from PyQt5 import QtQuickWidgets<br/>...</pre>
<ol start="2">
<li>Then, add/change some lines to/in the <kbd>__init__()</kbd> function of the <kbd>UApp</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UApp(UWindow, UTools):<br/><br/>    def __init__(self, parent=None):<br/>        ...<br/>        self.apps = QtQuickWidgets.QQuickWidget(self.twid1)<br/>        self.apps.setSource(QtCore.QUrl("apps.qml"))<br/>        self.properties = self.apps.rootObject()<br/>        ...<br/>        self.qmlbut1 = self.properties.childItems()[0].childItems()[0]<br/>        self.qmlbut1.clicked.connect(self.video_camera)<br/>        self.qmlbut2 = self.properties.childItems()[0].childItems()[1]<br/>        self.qmlbut2.clicked.connect(self.qml_apps)<br/>        self.qmlbut3 = self.properties.childItems()[0].childItems()[2]<br/>        self.qmlbut3.clicked.connect(self.jupyter)<br/>        self.qmlbut4 = self.properties.childItems()[0].childItems()[3]<br/>        self.qmlbut4.clicked.connect(self.web_browse)<br/>        ...<br/>        self.qapp1 = 0<br/>        self.qapp2 = 0<br/>        self.qapp3 = 0<br/>        self.qapp4 = 0<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The created signals in the QML file will be used to call the functions related to new processes that will run new tasks. Now, we need to add some functions to the <kbd>UApp</kbd> class to realize the QML and run the processes with specified applications.</p>
<ol start="3">
<li>Add the resize event handler in order to resize the QML elements in the view:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def resizeEvent(self, event):<br/>        self.properties.setWidth(<br/>             float(self.tabwid.currentWidget().width()))<br/>        self.properties.setHeight(<br/>             float(self.tabwid.currentWidget().height()))<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This event handler will resize the tab of the widget that contains the QML elements when the window of the application is resized with a mouse or in another way.</p>
<ol start="4">
<li>Add the first process for running a video camera device:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def video_camera(self):<br/>        self.qapp1 += 1<br/>        if self.qapp1 == 1:<br/>            # subprocess.Popen(["python", r"u_media.py"])<br/>            self.approc1 = QtCore.QProcess()<br/>            self.approc1.start("python", ["u_media.py"])<br/>        if self.qapp1 == 2:<br/>            self.approc1.kill()<br/>            self.qapp1 = 0<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This will start the camera widget in the new process. The camera device functionality provided by the Qt library may vary from version to version. If you are using an operating system that requires root privileges, you need to start this functionality according to these requirements.</p>
<ol start="5">
<li>Add the second process, which will run the QML application we created previously:</li>
</ol>
<pre>...<br/>    ...<br/>    def qml_apps(self):<br/>        self.qapp2 += 1<br/>        if self.qapp2 == 1:<br/>            # subprocess.Popen(["python", r"u_qml.py"])<br/>            self.approc2 = QtCore.QProcess()<br/>            self.approc2.start("python", ["u_qml.py"])<br/>        if self.qapp2 == 2:<br/>            self.approc2.kill()<br/>            self.qapp2 = 0<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This will run the QML application in the new process. We also need to create a <kbd>u_qml.py</kbd> file in both the <kbd>App/App_PySide2/</kbd> and <kbd>App/App_PyQt5/</kbd> directories and add the following lines.</p>
<p style="padding-left: 60px">Add the following lines in each <kbd>import</kbd> section:</p>
<ul>
<li style="padding-left: 30px">Add the following lines to the PySide2 <kbd>u_qml.py</kbd> file:</li>
</ul>
<pre style="padding-left: 90px">...<br/>from PySide2 import QtWidgets, QtCore<br/>from PySide2.QtQml import QQmlApplicationEngine<br/>import sys<br/>...</pre>
<ul>
<li style="padding-left: 30px">Add the following lines to the PyQt5 <kbd>u_qml.py</kbd> file:</li>
</ul>
<pre style="padding-left: 90px">...<br/>from PyQt5 import QtWidgets, QtCore<br/>from PyQt5.QtQml import QQmlApplicationEngine<br/>import sys<br/>...</pre>
<ul>
<li style="padding-left: 30px">Finally, add the following lines, which are for starting the QML in the application, to both files:</li>
</ul>
<pre style="padding-left: 90px">...<br/>app = QtWidgets.QApplication(sys.argv)<br/>qwid = QQmlApplicationEngine()<br/>qwid.load(QtCore.QUrl('u_qml.qml'))<br/>sys.exit(app.exec_())<br/>...</pre>
<p style="padding-left: 60px">We change this file in a similar manner to the QML application – without using the classes. However, the <kbd>u_qml.py</kbd><strong> </strong> file that we created in <a href="e8aa0a88-3426-4280-86f9-8d39cf7f6391.xhtml">Chapter 2</a>, <em>An Overview of QML</em>, can be used with additional modifications as well.</p>
<ol start="6">
<li>Add the third process in order to run Jupyter Notebook in a specified browser (which can be changed to your favorite browser; if one is not specified, the default browser will be used):</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def jupyter(self):<br/>        self.qapp3 += 1<br/>        if self.qapp3 == 1:<br/>            # subprocess.Popen(["jupyter", ["notebook", "-- <br/>            #                             browser=firefox"])<br/>            self.approc3 = QtCore.QProcess()<br/>            self.approc3.start("jupyter", ["notebook", "--<br/>                                         browser=firefox"])<br/>        if self.qapp3 == 2:<br/>            self.approc3.kill()<br/>            self.qapp3 = 0<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This function will start Jupyter Notebook in the new process, which will be displayed in the Firefox web browser. If we want to open the notebook in our default browser, this can be done by not specifying any browser in the browser parameter of the <kbd>start()</kbd> function. Or we can open with our favorite by specifying the browser parameter.</p>
<ol start="7">
<li>Finally, add the fourth process, which will run the default web browser with the Python standard library's <kbd>webbrowser</kbd> module, and the specified URL:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def web_browse(self):<br/>        self.qapp4 += 1<br/>        if self.qapp4 == 1:<br/>            # subprocess.Popen("python", ["-m", "webbrowser", "-n", <br/>            #                            "https://www.python.org"])<br/>            self.approc4 = QtCore.QProcess()<br/>            self.approc4.start("python", ["-m", "webbrowser", "-n",<br/>                                          "https://www.python.org"])<br/>        if self.qapp4 == 2:<br/>            self.approc4.kill()<br/>            self.qapp4 = 0<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">Here, we are specifying the command in the <kbd>start()</kbd> function of the <kbd>QProcess</kbd> class, similar to the construction of the <kbd>subprocess</kbd> module of the Python standard library. All of these functions for starting processes emulate the toggling of the buttons. When the button is clicked, the process will start. When it is no longer being clicked, the <kbd>kill()</kbd> function will be called. These functions are optional and can be used to start another program.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Threads</h1>
                
            
            
                
<p>The next element of execution operations that's related to the environment of applications and programs is threads. Threads are very similar to processes in nature, but there are some differences. Threads do things in parallel. In a broad sense, the thread of an execution is a sequence of instructions that can be managed independently by a scheduler of the operating system's operations. In most applications that are available at the moment, a thread is a component of a process. In the world around us, we usually encounter multitasking OSes that provide a multithreading model that allows multiple threads to exist within the context of one process. So, how we can describe threads?  When you are using your favorite operating system, or you are running your favorite editor, for example, the Spyder editor included in the Anaconda toolset, you want to find out the latest news and open a web browser. Let's say you open your media player to listen to some music or watch a video – these applications are usually used when you are doing something like this. This is an example of several processes working in parallel using the multitasking model of execution. Moreover, as we can see, each of these processes has other internal processes that execute in parallel in one single process. While you are using the text field of the editor, you can run another option of this editor simultaneously. This behavior describes the sense of the threads in an application – concurrency within one single process.</p>
<p>How we can describe concurrent execution? As we described in the <em>Processes</em> section of this chapter, parallel execution on a CPU with a single core is an illusion. For processes, this is as an interruption of a process when another process starts, and then another process is interrupted when another process starts. This situation with processes can be extrapolated to the execution of a program's segments of one single process. When a process starts, it always executes one code segment. This is known as a process having one thread. We can split the execution of a process into two code segments, which will make it look like two different code sequences are operating simultaneously. When we have a single-core CPU, concurrency is realized in a similar way to the parallel execution of processes. If we have a multi-core CPU, these threads can be assigned to multiple cores. This is concurrency in the real sense of the word.</p>
<p>In regard to GUI application development with Qt (although this is not only related to Qt), there are two types of threads that we need to know about. The first type is a GUI thread that is used as the main thread of the application. This is started by calling the <kbd>QtCore.QApplication.exec()</kbd> function when we run our application. All GUI components, such as widgets, and some classes, such as <kbd>QPixmap</kbd>, must run in this thread. The second type is a secondary thread, also known as the worker thread, which is used to offload the main thread and run long-term tasks. All the threads that have been demonstrated in this book that provide additional functionality, such as pandas, are worker threads. Each thread has its own stack (call history and local variables) with a size that is usually defined by the operating system. Threads share the same address space. We need to know about the following if we want to use threads in the application:</p>
<ul>
<li>The number of available threads for the real concurrent execution is equal to the number of available CPU cores</li>
<li>Several threads cannot access the same object at one time</li>
<li>All thread objects can only be used safely when other threads are not related to them and objects don't have an implicit coupling with other threads</li>
<li>We cannot change something in the GUI thread from the worker thread</li>
</ul>
<p>The Qt library provides several classes for working with threads in an application, such as <kbd>QThread</kbd> and <kbd>QThreadPool</kbd>. The advantages of the <kbd>QThread</kbd> class are that we can make changes in GUI components using the signals mechanism. The Qt library provides documentation terms such as <em>re-entrant</em> and <em>thread-safe</em>, which are used to mark classes and functions to indicate how they can be used in multithreading applications. The term <strong>thread-safe</strong> means that this method can be called from multiple threads, even when the invocations use shared data, because all references to the shared data are serialized.</p>
<p>The term <strong>re-entrant</strong> means that this method can be called from multiple threads, but only if each invocation uses its own data. In this section, we will cover the <kbd>QThread</kbd> and <kbd>QThreadPool</kbd> classes. We also recommend learning about the <kbd>QtConcurrent</kbd> module and the <kbd>WorkerScript</kbd> QML type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QThread</h1>
                
            
            
                
<p>This class manages the threads that can be used in an application. It is platform-independent and provides a way to separate the execution of tasks into different event loops. The declaration syntax of this class is as follows:</p>
<pre><strong>thread</strong> = QtCore.QThread()</pre>
<p><kbd>QThread</kbd> inherits from the <kbd>QObject</kbd> class and improves functionality with the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These functions set the parameters/properties to the thread:</p>
<p><kbd>thread.setEventDispatcher(QtCore.QAbstractEventDispatcher)</kbd>: This sets the event dispatcher, specified in the parameter, that will be used with this thread.</p>
<p><kbd>thread.setPriority(QtCore.QThread.Priority)</kbd>: This sets the priority, specified in the parameter, that will be used with the running of this thread. The available priorities are as follows:</p>
<ul>
<li><kbd>QtCore.QThread.IdlePriority</kbd>—<kbd>0</kbd>: This thread is running only when no other threads are running.</li>
<li><kbd>QtCore.QThread.LowestPriority</kbd>—<kbd>1</kbd>: This thread has the lowest running priority.</li>
<li><kbd>QtCore.QThread.LowPriority</kbd>—<kbd>2</kbd>: This thread has a low running priority.</li>
<li><kbd>QtCore.QThread.NormalPriority</kbd>—<kbd>3</kbd>: This thread has a normal (the default of the operating system) running priority.</li>
<li><kbd>QtCore.QThread.HighPriority</kbd>—<kbd>4</kbd>: This thread has a high running priority.</li>
<li><kbd>QtCore.QThread.HighestPriority</kbd>—<kbd>5</kbd>: This thread has the highest running priority.</li>
<li><kbd>QtCore.QThread.TimeCriticalPriority</kbd>—<kbd>6</kbd>: This thread runs as often as possible against other threads.</li>
<li><kbd>QtCore.QThread.InheritPriority</kbd>—<kbd>7</kbd>: This thread is running with the same priority as the creating thread.</li>
</ul>
<p><kbd>thread.setStackSize(int)</kbd>: This sets the maximum stack size as a number of bytes, specified in the parameter, for this thread.</p>
<p><kbd>thread.setTerminationEnabled(bool)</kbd>: If this parameter is <kbd>True</kbd>, it enables the thread's termination.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">is</h1>
                
            
            
                
<p>These functions return a Boolean value, <kbd>bool</kbd>, related to the threads' states:</p>
<p><kbd>thread.isFinished()</kbd>: This returns <kbd>True</kbd> if this thread is finished.</p>
<p><kbd>thread.isInterruptionRequested()</kbd>: This returns <kbd>True</kbd> if an interruption of this thread is requested.</p>
<p><kbd>thread.isRunning()</kbd>: This returns <kbd>True</kbd> if this thread is running.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These functions relate to the current values of the thread, changes in functionality, and so on:</p>
<p><kbd>thread.currentThread()</kbd>: This returns the currently operating thread object of the <kbd>QtCore.QThread</kbd> type.</p>
<p><kbd>thread.currentThreadId()</kbd>: This returns the thread handler of the current thread.</p>
<p><kbd>thread.eventDispatcher()</kbd>: This returns the event dispatcher object of the <kbd>QtCore.QAbstractEventDispatcher</kbd> type for the currently operating thread.</p>
<p><kbd>thread.exec_()</kbd>: This executes this thread by entering the event loop.</p>
<p><kbd>thread.exit(int)</kbd>: This exits the event loop of the thread with a return code specified in the parameter (<kbd>0</kbd> is a success; any nonzero value is an error).</p>
<p><kbd>thread.idealThreadCount()</kbd>: This returns the ideal number of threads that can be used on the system.</p>
<p><kbd>thread.loopLevel()</kbd>: This returns the event loop level for this thread.</p>
<p><kbd>thread.msleep(int)</kbd>: This thread falls asleep after the number of milliseconds specified in the parameter have elapsed.</p>
<p><kbd>thread.priority()</kbd>: This returns the priority of the <kbd>QtCore.QThread.Priority</kbd> type used for this thread.</p>
<p><kbd>thread.quit()</kbd>: This exits the event loop of this thread with a return code of <kbd>0</kbd>.</p>
<p><kbd>thread.requestInterruption()</kbd>: This requests the interruption of this thread</p>
<p><kbd>thread.run()</kbd>: This calls the <kbd>run()</kbd> function of the created thread.</p>
<p><kbd>thread.sleep(int)</kbd>: This thread falls asleep after the duration in seconds specified in the parameter.</p>
<p><kbd>thread.stackSize()</kbd>: This returns the maximum stack size for this thread as a number of bytes.</p>
<p><kbd>thread.start(QtCore.QThread.Priority)</kbd>: This starts this thread and begins executing the <kbd>run()</kbd> function instructions, with priority specified in the parameter.</p>
<p><kbd>thread.terminate()</kbd>: This terminates the execution of this thread.</p>
<p><kbd>thread.usleep(int)</kbd>: This thread falls asleep in the number of microseconds specified in the parameter.</p>
<p><kbd>thread.wait(int)</kbd>: This blocks this thread and waits until it has finished execution or waits for the number of milliseconds specified in the parameter.</p>
<p><kbd>thread.yieldCurrentThread()</kbd>: This yields the execution of this thread to another thread, which the operating system will switch to.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">signals</h1>
                
            
            
                
<p>These are the available signals of the <kbd>QThread</kbd> class:</p>
<p><kbd>thread.finished()</kbd>: This signal is emitted before this thread finishes executing.</p>
<p><kbd>thread.started()</kbd>: This signal is emitted before this thread starts executing.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">QThreadPool</h1>
                
            
            
                
<p>This class manages a collection of threads that can be used in an application. The Qt application has a global <kbd>QThreadPool</kbd> object that manages the main (<strong>GUI</strong>) and additional (<strong>worker</strong>) threads that are used in the application. This existing thread pool can be accessed by calling the <kbd>globalInstance()</kbd> static function. The declaration syntax of this class is as follows:</p>
<pre><strong>thread_pool</strong> = QtCore.QThreadPool()</pre>
<p><kbd>QThreadPool</kbd> inherits from the <kbd>QObject</kbd> class and enhances its functionality with the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These functions set the parameters/properties of the thread pool:</p>
<p><kbd>thread_pool.setExpiryTimeout(int)</kbd>: This sets the expiry timeout in milliseconds, specified in the parameter, for the thread pool, after which all unused threads are considered expired and exit.</p>
<p><kbd>thread_pool.setMaxThreadCount(int)</kbd>: This sets the maximum number of threads, specified in the parameter, that will be used in the pool.</p>
<p><kbd>thread_pool.setStackSize(int)</kbd>: This sets the maximum stack size as a number of bytes, specified in the parameter, for the worker threads in the pool.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These functions relate to the current values of the thread pool, changes in functionality, and so on:</p>
<p><kbd>thread_pool.activeThreadCount()</kbd>: This returns the number of active threads in the pool.</p>
<p><kbd>thread_pool.cancel(QtCore.QRunnable)</kbd>: This removes a runnable object that hasn't been started or specified in the parameter from the queue.</p>
<p><kbd>thread_pool.clear()</kbd>: This removes runnable objects that haven't been started from the queue.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><kbd>thread_pool.expiryTimeout()</kbd>: This returns the expiry timeout for the thread pool, or the time in milliseconds after which all unused threads are considered expired, and exit.</p>
<p><kbd>thread_pool.globalInstance()</kbd>: This returns the global instance of the <strong><kbd>QtCore.QThreadPool</kbd></strong> type for the thread pool.</p>
<p><kbd>thread_pool.maxThreadCount()</kbd>: This returns the maximum number of threads used in the pool.</p>
<p><kbd>thread_pool.releaseThread()</kbd>: This releases the thread that was previously reserved with the <kbd>reserveThread()</kbd> function.</p>
<p><kbd>thread_pool.reserveThread()</kbd>: This reserves the thread.</p>
<p><kbd>thread_pool.stackSize()</kbd>: This returns the maximum stack size as the number of bytes for the worker threads in the pool.</p>
<p><kbd>thread_pool.start(QtCore.QRunnable, int)</kbd>: This reserves this thread and uses it to run a runnable (the first parameter) object with priority (the second parameter) for the queue's order of execution.</p>
<p><kbd>thread_pool.tryStart(QtCore.QRunnable)</kbd>: This tries to reserve the thread in order to run a runnable object, specified in the parameter, in the queue.</p>
<p><kbd>thread_pool.tryTake(QtCore.QRunnable)</kbd>: This tries to remove the runnable object that's specified in the parameter from the queue.</p>
<p><kbd>thread_pool.waitForDone(int)</kbd>: This waits for the timeout in milliseconds, specified in the parameter, for all threads to exit, and removes all threads from the pool (the default timeout is <kbd>-1</kbd> or ignored).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Threads example</h1>
                
            
            
                
<p>In order to look at an example of threads, we will modify the previous code related to CouchDB and MongoDB functionality. In the <kbd>u_tools.py</kbd> files, let's add the classes with threads and functions that will make threads dependent on the tasks in the application:</p>
<ol>
<li>Add the thread class for the MongoDB server:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class MongoThread(QThread):<br/><br/>    sig1 = app_signal(object, str)<br/><br/>    def __init__(self, parent=None):<br/>        super(MongoThread, self).__init__(parent)<br/><br/>    def on_source(self, datas):<br/>        self.datas = datas<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This is the first part of the class with a signal that will emit data. It also has the <kbd>on_source()</kbd> function, which will receive data.</p>
<ol start="2">
<li>Now, we need to add the <kbd>run()</kbd> function, which will implement our threading functionality, to the <kbd>MongoThread</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def run(self):<br/>        try:<br/>            import pymongo<br/>            try:<br/>                self.client = pymongo.MongoClient('localhost',<br/>                                                         27017)<br/>                self.db = self.client['umongodb']<br/>            except pymongo.errors as err:<br/>                self.sig1.emit('', str(err))<br/>            if self.datas[1] == "insert":<br/>                posts = self.db.posts<br/>                posts.insert_one(self.datas[0])<br/>            if self.datas[1] == "select":<br/>                dbdata = self.db.posts.find()<br/>                self.sig1.emit(dbdata, '')<br/>            if self.isFinished():<br/>                self.quit()<br/>        except Exception as err:<br/>            self.sig1.emit('', str(err))<br/>            if self.isFinished():<br/>                self.quit()<br/>...</pre>
<p style="padding-left: 60px">The <kbd>run()</kbd> function of the thread will start the thread functionality. It will try to connect to the MongoDB server. When it is connected, it will try to insert/select the values to/from the database.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="3">
<li>Add the <kbd>CouchThread</kbd> class for the CouchDB server:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class CouchThread(QThread):<br/><br/>    sig1 = app_signal(object, str)<br/><br/>    def __init__(self, parent=None):<br/>        super(CouchThread, self).__init__(parent)<br/><br/>    def on_source(self, datas):<br/>        self.datas = datas<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This is the first part of the class and has a signal that will emit data, as well as the <kbd>on_source()</kbd> function, which will receive data.</p>
<ol start="4">
<li>Now, add the <kbd>run()</kbd> function, which will implement the threading functionality, to the <kbd>CouchThread</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def run(self):<br/>        try:<br/>            import couchdb<br/>            try:<br/>                self.couch = couchdb.Server(<br/>                                "http://127.0.0.1:5984/")<br/>                self.db = self.couch["u_couchdb"]<br/>            except Exception as err:<br/>                self.sig1.emit('', str(err))<br/>            if self.datas[1] == "insert":<br/>                self.db.save(self.datas[0])<br/>            if self.datas[1] == "select":<br/>                self.sig1.emit(self.db, '')<br/>            if self.isFinished():<br/>                self.quit()<br/>        except Exception as err:<br/>            self.sig1.emit('', str(err))<br/>            if self.isFinished():<br/>                self.quit()<br/>...</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p style="padding-left: 60px">The <kbd>run()</kbd> function of this thread will start the thread functionality. It will try to connect to the CouchDB server. When it is connected, it will try to insert/select values to/from the database. Now, we need to add the functions that will provide the threading functionality in the application. First, we need to add the signals that will be used in the <kbd>UTools</kbd> class.</p>
<ol start="5">
<li>The signals that will be used for communication look like this:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UTools(object):<br/><br/>    pandas_sig1 = app_signal(list)<br/>    pandas_sig2 = app_signal(list)<br/>    mongo_sig1 = app_signal(list)<br/>    mongo_sig2 = app_signal(list)<br/>    couch_sig1 = app_signal(list)<br/>    couch_sig2 = app_signal(list)<br/><br/>    def __init__(self):<br/>        ...<br/>    ...<br/>...</pre>
<p class="mce-root" style="padding-left: 60px">These new signals will communicate between the <kbd>UTools</kbd> class' functionality and the threads that were created for Mongo and Couch database realization. Then, we need to change the previously created functions in the <kbd>UTools</kbd> class of the <kbd>u_tools.py</kbd> files to write to and read from the Couch and Mongo databases.</p>
<ol start="6">
<li>Change the <kbd>mongo_insert()</kbd> function of the <kbd>UTools</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def mongo_insert(self, username=None, email=None,<br/>                                    passw=None, data=None):<br/>        datas = [{"User Name": username, "Email": email,<br/>        "Password": passw, "Data": data}, "insert"]<br/>        self.mongo_thread1 = MongoThread()<br/>        self.mongo_sig1.connect(self.mongo_thread1.on_source)<br/>        self.mongo_sig1.emit(datas)<br/>        self.mongo_thread1.start()<br/>    ...<br/>...</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p style="padding-left: 60px">This function will write the data specified in the <kbd>datas</kbd> list using a thread. The instance of this thread will be used, along with the connection of the signal for emitting this data to the thread. This will start the thread (by default, the priority is <kbd>InheritPriority</kbd>).</p>
<ol start="7">
<li>Change the <kbd>mongo_select()</kbd> function of the <kbd>UTools</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def mongo_select(self):<br/>        datas = [{}, "select"]<br/>        self.mongo_thread2 = MongoThread()<br/>        self.mongo_sig2.connect(self.mongo_thread2.on_source)<br/>        self.mongo_sig2.emit(datas)<br/>        self.mongo_thread2.start()<br/>        return self.mongo_thread2<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This function will read the data of the MongoDB instance using the thread. The instance of the thread will be created with the connection of the signal for emitting this data to the thread.  The emitted data will be a list with an empty dictionary (optional) and a string that indicates the reading operation. Then, the thread starts.</p>
<ol start="8">
<li>Now, change the <kbd>couch_insert()</kbd> function of the <kbd>UTools</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def couch_insert(self, username=None, email=None,<br/>                                passw=None, data=None):<br/>        datas = [{"User Name": username,<br/>          "User email": email,<br/>          "User password": passw,<br/>                  "User Data": data}, "insert"]<br/>        self.couch_thread1 = CouchThread()<br/>        self.couch_sig1.connect(self.couch_thread1.on_source)<br/>        self.couch_sig1.emit(datas)<br/>        self.couch_thread1.start()<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This function will write the data specified in the <kbd>datas</kbd> list using the thread to the Couch database. The instance of the thread will be used, along with the connection of the signal for emitting this data to the thread. Now, the thread will start.</p>
<p class="mce-root"/>
<ol start="9">
<li>Change the <kbd>couch_select()</kbd> function of the <kbd>UTools</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def couch_select(self):<br/>        datas = [{}, "select"]<br/>        self.couch_thread2 = CouchThread()<br/>        self.couch_sig2.connect(self.couch_thread2.on_source)<br/>        self.couch_sig2.emit(datas)<br/>        self.couch_thread2.start()<br/>        return self.couch_thread2<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This function will read the data using the thread. The instance of the thread will be created, along with the connection of the signal for emitting this data to the thread. The emitted data will be a list with an empty dictionary (optional) and a string that indicates the reading operation.</p>
<p>Now, we need to change the <kbd>data()</kbd> function of the <kbd>UApp</kbd> class from the <kbd>u_app.py</kbd> files that are related to reading from the Couch and Mongo databases. Let's get started:</p>
<ol>
<li>Change the <kbd>data()</kbd> function of the <kbd>UApp</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        if self.actx == "MongoDB":<br/>            try:<br/>                mongo_data = self.mongo_select()<br/>                def to_field(dbdata, er):<br/>                    if er == '':<br/>                        for dtx in dbdata:<br/>                            self.text_edit.append(<br/>                                    "%s\n%s\n%s\n%s" % (<br/>                                    dtx["User Name"],<br/>                                    dtx["Email"],<br/>                                    dtx["Password"],<br/>                                    dtx["Data"]))<br/>                    else:<br/>                        self.stat_bar.showMessage(<br/>                                    self.actx + ' ' + er)<br/>                mongo_data.sig1.connect(<br/>                     to_field, QtCore.Qt.QueuedConnection)<br/>                self.stat_bar.showMessage(<br/>                                    self.actx + " opened")<br/>            except Exception as err:<br/>                self.stat_bar.showMessage(<br/>                               self.actx + ' ' + str(err))<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">These lines provide MongoDB functionality when the  Data | MongoDB option in the top panel is selected. It calls the <kbd>mongo_select()</kbd> function when it receives the thread object, connects to the nested function with the signal of the thread, and puts the database data into the text field. If an error occurs, it shows this error in the status bar of the application.</p>
<ol start="2">
<li>Change the <kbd>data()</kbd> function of the <kbd>UApp</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        if self.actx == "CouchDB":<br/>            try:<br/>                couch_data = self.couch_select()<br/>                def to_field(dbdata, er):<br/>                    if er == '':<br/>                        for dtx in dbdata.view(<br/>                                        "_all_docs",<br/>                                        include_docs=True):<br/>                            self.text_edit.append(<br/>                                 "%s\n%s\n%s\n%s" % (<br/>                                 dtx["doc"]["User Name"],<br/>                                 dtx["doc"]["User email"],<br/>                                 dtx["doc"]["User password"],<br/>                                 dtx["doc"]["User Data"]))<br/>                    else:<br/>                        self.stat_bar.showMessage(<br/>                                      self.actx + ' ' + er)<br/>                couch_data.sig1.connect(<br/>                       to_field, QtCore.Qt.QueuedConnection)<br/>                self.stat_bar.showMessage(<br/>                                 self.actx + " opened")<br/>            except Exception as err:<br/>                self.stat_bar.showMessage(<br/>                                 self.actx + ' ' + str(err))<br/>        ...<br/>    ...<br/>...</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p style="padding-left: 60px">These lines provide CouchDB functionality when the <kbd>CouchDB</kbd> option is selected. It calls the <kbd>couch_select()</kbd> function when it receives the thread object, connects to the nested function with the signal of the thread, and puts the database data into the text field. If an error occurs, it shows this error in the status bar of the application.</p>
<p>These examples have some restrictions in regard to use. Note that when we use this functionality, we need to ensure that the CouchDB and MongoDB servers are configured and working, and that databases are created in the directory.  </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Locks</h1>
                
            
            
                
<p>When using threads in an application, problems may arise in relation to accessing a similar source with several threads, or when you need to lock the execution of part of the code. The Qt library provides several classes to solve this problem, such as <kbd>QMutex</kbd>, <kbd>QMutexLocker</kbd>, <kbd>QReadWriteLock</kbd>, <kbd>QSemaphore</kbd>, and <kbd>QWaitCondition</kbd>. Here, we will describe some of them. However, please note that locking some sources can create other problems related to blocking the GUI thread, or another thread. Therefore, using locks in an application is not trivial, and before implementation, we need to think about it carefully.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QMutex</h1>
                
            
            
                
<p>This class allows access serialization between threads. To enforce <strong>mutual exclusion</strong> (<strong>mutex</strong>), the thread locks a mutex in order to gain access to the resource. The declaration syntax of this class is as follows:</p>
<pre><strong>mutex</strong> = QtCore.QMutex(QtCore.QMutex.RecursionMode)</pre>
<p>The mutex can be constructed with the recursion mode specified in the parameter. The available recursion modes are as follows:</p>
<ul>
<li><kbd>QtCore.QMutex.Recursive</kbd>—<kbd>0</kbd>: This thread is capable of locking the same mutex multiple times. This mutex will not be unlocked until a corresponding number of <kbd>unlock()</kbd> function calls have been made.</li>
<li><kbd>QtCore.QMutex.NonRecursive</kbd>—<kbd>1</kbd>: This thread can lock the same mutex only once.</li>
</ul>
<p><kbd>QMutex</kbd> inherits from the <kbd>QBasicMutex</kbd> class and enhances its functionality with the following functions.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">is</h1>
                
            
            
                
<p>This function returns a Boolean value (<kbd>bool</kbd>) related to the mutex states:</p>
<p><kbd>mutex.isRecursive()</kbd>: This returns <kbd>True</kbd> if this mutex has a recursive mode.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These functions relate to the current values of the mutex, changes in functionality, and so on:</p>
<p><kbd>mutex.lock()</kbd>: This locks the mutex.</p>
<p><kbd>mutex.tryLock(int)</kbd>: This tries to lock the mutex. If another thread has locked the mutex, it will wait before the lock for the number of milliseconds specified in the parameter (the default timeout is <kbd>0</kbd>).</p>
<p><kbd>mutex.unlock()</kbd>: This unlocks the mutex.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QMutex example</h1>
                
            
            
                
<p>Mutexes can usually be implemented in an application when threads are used. Let's demonstrate this with the following lines of code:</p>
<pre>...<br/>class WPandas(QThread):<br/>    ...<br/>    def __init__(self, parent=None):<br/>        ...<br/>        self.mutex = QMutex()<br/>    ...<br/>    def run(self):<br/>        self.mutex.lock()<br/>        try:<br/>            ...<br/>        except Exception as err:<br/>            ...<br/>        self.mutex.unlock()<br/>...</pre>
<p>The <kbd>__init__()</kbd> function created the instance of the <kbd>QMutex</kbd> class that was imported from the <kbd>QtCore</kbd> module. Inside the <kbd>run()</kbd> function of the thread, we added the line with the <kbd>lock()</kbd> and <kbd>unlock()</kbd> methods of the mutex, which will lock and unlock the code between them, respectively.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">QMutexLocker</h1>
                
            
            
                
<p>This class provides the additional convenient functionality of locking and unlocking mutexes. The declaration syntax of this class is as follows:</p>
<pre><strong>mutex_locker</strong> = QtCore.QMutexLocker(QtCore.QBasicMutex)</pre>
<p>The <kbd>QMutexLocker</kbd> class improves functionality with the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These functions relate to the current values of the mutex locker, changes in functionality, and so on:</p>
<p><kbd>mutex_locker.mutex()</kbd>: This returns the mutex of the <kbd>QtCore.QMutex</kbd> type that operates by this mutex locker.</p>
<p><kbd>mutex_locker.relock()</kbd>: This relocks the unlocked mutex locker.</p>
<p><kbd>mutex_locker.unlock()</kbd>: This unlocks the mutex locker.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QMutexLocker example</h1>
                
            
            
                
<p>The previous example of mutexes has some flaws. If an exception occurs during the execution of the code before the <kbd>unlock()</kbd> method, the mutex can be locked forever. To solve this problem, we can use the <kbd>QMutexLocker</kbd> class. Let's demonstrate this with the previously created mutex:</p>
<pre>...<br/>class WPandas(QThread):<br/>    ...<br/>    def __init__(self, parent=None):<br/>        ...<br/>        self.mutex = QMutex()<br/>    ...<br/>    def run(self):<br/>        mutex_locker = QMutexLocker(self.mutex)<br/>        try:<br/>            ...<br/>        except Exception as err:<br/>            ...<br/>...</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In the <kbd>run()</kbd> function, we've created an instance of the <kbd>QMutexLocker</kbd> class that's been imported from the <kbd>QtCore</kbd> module, with the mutex specified in the parameter. After the end of scope, the destructor of the class will be called, and this lock will be automatically released. This can also be used in the construction of the context manager for things such as instructions; for example, <em>with</em>/<em>as</em>. Change the previous lines of code to the following:</p>
<pre>...<br/>class WPandas(QThread):<br/>    ...<br/>    def __init__(self, parent=None):<br/>        ...<br/>        self.mutex = QMutex()<br/>    ...<br/>    def run(self):<br/>        with QMutexLocker(self.mutex):<br/>            try:<br/>                ...<br/>            except Exception as err:<br/>                ...<br/>...</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">QSystemSemaphore</h1>
                
            
            
                
<p>This class provides a general counting system semaphore for working with threads and multiple processes in an application. The declaration syntax of this class is as follows:</p>
<pre><strong>system_semaphore</strong> = QtCore.QSystemSemaphore(str, int,<br/>                         QtCore.QSystemSemaphore.AccessMode)</pre>
<p>This system semaphore can be constructed with a key (the first parameter) and a system-dependent initialization of the number of resources (the second parameter) with the access mode (the third parameter). The available access modes are as follows:</p>
<ul>
<li><kbd>QtCore.QSystemSemaphore.Open</kbd>—<kbd>0</kbd>: If the system semaphore exists, its initial resource count is not reset; otherwise, it will be created.</li>
<li><kbd>QtCore.QSystemSemaphore.Create</kbd>—<kbd>0</kbd>: The system semaphore will be created.</li>
</ul>
<p>The <kbd>QSystemSemaphore</kbd> class improves functionality with the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>This function sets the parameters/properties of the system semaphore:</p>
<p><kbd>system_semaphore.setKey(str, int, QtCore.QSystemSemaphore.AccessMode)</kbd>: This reconstructs the system semaphore object with a key (the first parameter) and a system-dependent initialization of the number of resources (the second parameter) with the access mode (the third parameter)</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These functions relate to the current values of the system semaphore, changes in functionality, and so on:</p>
<p><kbd>system_semaphore.acquire()</kbd>: This acquires one of the resources that are guarded by this system semaphore.</p>
<p><kbd>system_semaphore.error(QtCore.QSystemSemaphore.SystemSemaphoreError)</kbd>: This returns a value of the error type if an error occurred with this system semaphore. The errors that can occur are as follows:</p>
<ul>
<li><kbd>QtCore.QSystemSemaphore.NoError</kbd>—<kbd>0</kbd>: No error.</li>
<li><kbd>QtCore.QSystemSemaphore.PermissionDenied</kbd>—<kbd>1</kbd>: Not enough permissions for the caller.</li>
<li><kbd>QtCore.QSystemSemaphore.KeyError</kbd>—<kbd>2</kbd>: An invalid key has been specified.</li>
<li><kbd>QtCore.QSystemSemaphore.AlreadyExists</kbd>—<kbd>3</kbd>: A system semaphore with the specified key already exists.</li>
<li><kbd>QtCore.QSystemSemaphore.NotFound</kbd>—<kbd>4</kbd>: A system semaphore with the specified key can't be found.</li>
<li><kbd>QtCore.QSystemSemaphore.OutOfResources</kbd>—<kbd>5</kbd>: Not enough memory.</li>
<li><kbd>QtCore.QSystemSemaphore.UnknownError</kbd>—<kbd>6</kbd>: The error is unknown.</li>
</ul>
<p><kbd>system_semaphore.errorString()</kbd>: This returns a text description of the error.</p>
<p><kbd>system_semaphore.key()</kbd>: This returns the key for this system semaphore or the name by which this system semaphore can be accessed from other processes.</p>
<p><kbd>system_semaphore.release(int)</kbd>: This releases the number, specified in the parameter, of resources guarded by this system semaphore.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QSemaphore</h1>
                
            
            
                
<p>This class creates the general counting semaphore for working with threads in the application. The declaration syntax of this class is as follows:</p>
<pre><strong>semaphore</strong> = QtCore.QSemaphore(int)</pre>
<p>The semaphore can be constructed with the initialization of the number of resources specified in the parameter. The <kbd>QSemaphore</kbd> class improves functionality with the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These functions relate to the current values of the semaphore, changes in functionality, and so on:</p>
<p><kbd>semaphore.acquire(int)</kbd>: This acquires the number, specified in the parameter, of the resources guarded by this semaphore.</p>
<p><kbd>semaphore.available()</kbd>: This returns the amount of resources available to this semaphore.</p>
<p><kbd>semaphore.release(int)</kbd>: This releases the amount, specified in the parameter, of resources guarded by this semaphore.</p>
<p><kbd>semaphore.tryAcquire(int)</kbd>: This tries to acquire the amount, specified in the parameter, of resources guarded by this semaphore.</p>
<p><kbd>semaphore.tryAcquire(int, int)</kbd>: This tries to acquire the amount (the first parameter) of resources guarded by this semaphore for the duration specified (the second parameter).</p>
<p>The semaphore constructions are commonly used to control access to the source by the several threads. A good example of semaphores can be found in the threading examples, with PyQt5/PySide bindings, and in the <kbd>/examples/threads/</kbd> folder of <kbd>site-packages/</kbd>, which is related to the binding used.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">QWaitCondition</h1>
                
            
            
                
<p>This class synchronizes the threads by providing a condition variable. The declaration syntax of this class is as follows:</p>
<pre><strong>wait_condition</strong> = QtCore.QWaitCondition()</pre>
<p>The <kbd>QWaitCondition</kbd> class improves functionality with the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These functions relate to the returns of the current values of the semaphore, changes in functionality, and so on:</p>
<p><kbd>wait_condition.wait(QtCore.QMutex, int)</kbd>: This releases the locked mutex (the first parameter) and waits on the wait condition, such as other thread signals, including <kbd>wakeOne()</kbd> or <kbd>wakeAll()</kbd>, or the timeout in milliseconds (the second parameter) elapses.</p>
<p><kbd>wait_condition.wait(QtCore.QReadWriteLock, int)</kbd>: This releases the locked read/write lock (the first parameter) and waits on the wait condition, such as other thread signals, including <kbd>wakeOne()</kbd> or <kbd>wakeAll()</kbd>, or the timeout in milliseconds (the second parameter) elapses.</p>
<p><kbd>wait_condition.wakeAll()</kbd>: This wakes all threads that are waiting with the wait condition.</p>
<p><kbd>wait_condition.wakeOne()</kbd>: This wakes one of the threads that is waiting with the wait condition.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Python standard library tools</h1>
                
            
            
                
<p>The instruments of the Python standard library can be easily implemented with the PySide2/PyQt5 Python bindings of the Qt library in our GUI application. We can describe the tools we're going to use in a similar way to how we did earlier in this chapter.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">threading</h1>
                
            
            
                
<p>This Python standard library module implements the threading functionality with any Python-based application that has the PyQt and PySide bindings. This module can be used in a wider sense than the analogous <kbd>QThread</kbd> class for specialized tasks in the application. But we need to know that, in PyQt/PySide GUIs, the <kbd>QThread</kbd> class allows communication and functionality through the signals. To use threading in the application, we need to import this module:</p>
<pre>...<br/>import threading<br/>...</pre>
<p>We will only describe the commonly used part of this module. Full information about this module is available in the official documents: <a href="https://docs.python.org/3/">https://docs.python.org/3/</a>. This module uses the following useful functions:</p>
<p><kbd>threading.active_count()</kbd>: This returns the number of threads that are currently alive.</p>
<p><kbd>threading.current_thread()</kbd>: This returns the thread that's currently in use.</p>
<p><kbd>threading.get_ident()</kbd>: This returns the identifier of the current thread.</p>
<p><kbd>threading.enumerate()</kbd>: This returns the list of all threads that are currently alive.</p>
<p><kbd>threading.main_thread()</kbd>: This returns the main thread. In the Pythonic sense, this is a thread from which the Python interpreter, which operates the Python environment, was started.</p>
<p><kbd>threading.stack_size(int)</kbd>: This returns the stack size that will be used when creating new threads. If the optional parameter is specified, it will be used as the stack size. Note that the parameter is a number of bytes, and that <kbd>0</kbd> or at least 32 KiB (<kbd>32768</kbd>) can be used; for example, 512 KiB is represented as <kbd>524288</kbd> in numeric form.</p>
<p>The <kbd>threading</kbd> module implements this functionality through several classes (the arguments that are provided are related to Python 3.x).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Thread</h1>
                
            
            
                
<p>The <kbd>thread</kbd> class of the <kbd>threading</kbd> module is as follows:</p>
<pre><strong>thread1</strong> = threading.Thread(group=None, target=None, name=None,<br/>                             args=(), kwargs={}, *, daemon=None)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p><kbd>group</kbd> is reserved for future extension when a <kbd>ThreadGroup</kbd> class is implemented; <kbd>target</kbd> is a callable object; <kbd>name</kbd> is the name of the thread; <kbd>args</kbd> is a tuple of arguments that are used; <kbd>kwargs</kbd> is a dictionary of the keyword arguments; and <kbd>daemon</kbd> sets the thread as daemonic. The <kbd>Thread</kbd> class has the following functions:</p>
<ul>
<li><kbd>thread1.start()</kbd>: This starts the thread.</li>
<li><kbd>thread1.run()</kbd>: This represents thread activity.</li>
<li><kbd>thread1.join(float)</kbd>: This waits until the thread terminates. The timeout parameter optionally waits before blocking the operation or blocking immediately after termination.</li>
<li><kbd>thread1.is_alive()</kbd>: This returns <kbd>True</kbd> if this thread is alive, otherwise it returns <kbd>False</kbd>.</li>
</ul>
<p>Construction of this class usually looks like this:</p>
<pre>def func(n):<br/>    ...<br/><br/>thread1 = threading.Thread(target=func, args=(14,))<br/>thread1.start()<br/>thread1.join()</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Lock</h1>
                
            
            
                
<p>These are primitive lock objects:</p>
<pre><strong>thread1_lock</strong> = threading.Lock</pre>
<p>The <kbd>Lock</kbd> class has the following functions:</p>
<p><kbd>thread1_lock.acquire(blocking=True, timeout=-1)</kbd>: This acquires blocking or non-blocking.</p>
<p><kbd>thread1_lock.release()</kbd>: This releases the lock.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">RLock</h1>
                
            
            
                
<p>These are re-entrant lock objects:</p>
<pre><strong>thread1_rlock</strong> = threading.RLock</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>RLock</kbd> class has the following functions:</p>
<p><kbd>thread1_rlock.acquire(blocking=True, timeout=-1)</kbd>: This acquires blocking or non-blocking.</p>
<p><kbd>thread1_rlock.release()</kbd>: This releases the lock.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Condition</h1>
                
            
            
                
<p>These are the condition variable objects:</p>
<pre><strong>thread1_cond</strong> = threading.Condition(lock=None)</pre>
<p>The <kbd>Condition</kbd> class has the following functions:</p>
<p><kbd>thread1_cond.acquire(*args)</kbd>: This acquires the underlying lock.</p>
<p><kbd>thread1_cond.release()</kbd>: This releases the underlying lock.</p>
<p><kbd>thread1_cond.wait(timeout=None)</kbd>: This waits until it's notified, or a timeout occurs.</p>
<p><kbd>thread1_cond.wait_for(predicate, timeout=None)</kbd>: This waits until a condition evaluates to <kbd>True</kbd>. The predicate parameter is a callable that returns a Boolean (<kbd>True</kbd> or <kbd>False</kbd>).</p>
<p><kbd>thread1_cond.notify(n=1)</kbd>: This wakes up <kbd>n</kbd> threads.</p>
<p><kbd>thread1_cond.notify_all()</kbd>: This wakes up all threads.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Semaphore</h1>
                
            
            
                
<p>These are semaphore objects, which manage a counter that counts the number of releases minus the number of acquires, plus an initial value:</p>
<pre><strong>thread1_sema</strong> = threading.Semaphore(value=1)</pre>
<p>The <kbd>Semaphore</kbd> class has the following functions:</p>
<p><kbd>thread1_sema.acquire(*args)</kbd>: This acquires the semaphore.</p>
<p><kbd>thread1_sema.release()</kbd>: This releases the semaphore.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">BoundedSemaphore</h1>
                
            
            
                
<p>These are the bounded semaphore objects that check that the  current value doesn't exceed its initial value:</p>
<pre><strong>thread1_bsema</strong> = threading.BoundedSemaphore(value=1)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Event</h1>
                
            
            
                
<p>These are event objects that are used for communication between threads. This is done by managing internal flags:</p>
<pre><strong>thread1_event</strong> = threading.Event</pre>
<p>The <kbd>Event</kbd> class has the following functions:</p>
<p><kbd>thread1_event.is_set()</kbd>: This returns <kbd>True</kbd> if the internal flag is <kbd>True</kbd>.</p>
<p><kbd>thread1_event.set()</kbd>: This sets the internal flag to <kbd>True</kbd>.</p>
<p><kbd>thread1_event.clear()</kbd>: This sets the internal flag to <kbd>False</kbd>.</p>
<p><kbd>thread1_event.wait(timeout=None)</kbd>: This blocks until the flag is <kbd>True</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Timer</h1>
                
            
            
                
<p>These are timer objects that run the timing for the action. This will only be run after a duration that is specified. The parameters that are provided are the <kbd>interval</kbd> after which the action will run; the <kbd>function</kbd> that will be run; <kbd>args</kbd> as the arguments that will be used; and <kbd>kwargs</kbd> as keyword arguments:</p>
<pre><strong>thread1_timer</strong> = threading.Timer(interval, function,<br/>                                args=None, kwargs=None)</pre>
<p>The <kbd>Timer</kbd> class has the following function:</p>
<p><kbd>thread1_timer.cancel()</kbd>: This stops the timer by canceling its execution.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Barrier</h1>
                
            
            
                
<p>These are barrier objects that are realized with a fixed number of threads that need to wait for each other. Threads try to pass the barrier by calling the <kbd>wait()</kbd> method. The parameters provided are <kbd>parties</kbd>, which is the number of threads; <kbd>action</kbd>, which is the callable that will be called by one of the threads; and <kbd>timeout</kbd>, which is the value that's used for the <kbd>wait()</kbd> method:</p>
<pre><strong>thread1_barrier</strong> = threading.Barrier(parties, action=None,<br/>                                             timeout=None)</pre>
<p>The <kbd>Barrier</kbd> class has the following functions:</p>
<p><kbd>thread1_barrier.wait(timeout=None)</kbd>: This passes the barrier.</p>
<p><kbd>thread1_barrier.reset()</kbd>: This resets the barrier and sets the empty state.</p>
<p><kbd>thread1_barrier.abort()</kbd>: This aborts the barrier and sets the broken state.</p>
<p><kbd>thread1_barrier.parties</kbd>: This returns the number of threads required to pass the barrier.</p>
<p><kbd>thread1_barrier.n_waiting</kbd>: This returns the number of threads waiting in the barrier.</p>
<p><kbd>thread1_barrier.broken</kbd>: This returns <kbd>True</kbd> if the barrier is in a broken state.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">queue</h1>
                
            
            
                
<p>In cases when several threads wait to run a task, it is very important to run this task using a queue. The standard library <kbd>queue</kbd> module can use the multi-producer and multi-consumer queue functionality in our application. Python bindings to Qt have not-so-simple instruments for the implementation of queues, and this module is widely used with threading constructions in GUIs. This module implements three types of queues: <strong>First In First Out</strong> (<strong>FIFO</strong>), <strong>Last In First Out</strong> (<strong>LIFO</strong>), and queues with priorities. To use them in our application, we need to import the following module:</p>
<pre>...<br/>import queue<br/>..</pre>
<p>Let's describe the most important classes and methods that can be used.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Queue</h1>
                
            
            
                
<p>These are the FIFO queues with the <kbd>maxsize</kbd> upper-bound limit of items that can be placed in the queue:</p>
<pre><strong>queue1</strong> = queue.Queue(maxsize=0)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">LifoQueue</h1>
                
            
            
                
<p>These are the LIFO queues with the <kbd>maxsize</kbd> upper-bound limit of items that can be placed in the queue:</p>
<pre><strong>queue1</strong> = queue.LifoQueue(maxsize=0)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">PriorityQueue</h1>
                
            
            
                
<p>These are the priority queues with the <kbd>maxsize</kbd> upper-bound limit of items that can be placed in the queue:</p>
<pre><strong>queue1</strong> = queue.PriorityQueue(maxsize=0)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">SimpleQueue</h1>
                
            
            
                
<p>These are unbounded FIFO queues:</p>
<pre><strong>queue1</strong> = queue.SimpleQueue</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">functions</h1>
                
            
            
                
<p>The methods of the <kbd>Queue</kbd>, <kbd>LifoQueue</kbd>, <kbd>PriorityQueue</kbd>, and <kbd>SimpleQueue</kbd> classes that can be used are as follows:</p>
<p><kbd>queue1.qsize()</kbd>: This returns the approximate size of the queue because the queues usually change (<kbd>Queue</kbd>, <kbd>LifoQueue</kbd>, <kbd>PriorityQueue</kbd>, <kbd>SimpleQueue</kbd>).</p>
<p><kbd>queue1.empty()</kbd>: This returns <kbd>True</kbd> if the queue is approximately empty (<kbd>Queue</kbd>, <kbd>LifoQueue</kbd>, <kbd>PriorityQueue</kbd>, <kbd>SimpleQueue</kbd>).</p>
<p><kbd>queue1.full()</kbd>: This returns <kbd>True</kbd> if the queue is approximately full (has at least one item) (<kbd>Queue</kbd>, <kbd>LifoQueue</kbd>, <kbd>PriorityQueue</kbd>).</p>
<p class="mce-root"/>
<p><kbd>queue1.put(item, block=True, timeout=None)</kbd>: This puts the specified item into the queue. The optional block and timeout arguments are provided (<kbd>Queue</kbd>, <kbd>LifoQueue</kbd>, <kbd>SimpleQueue</kbd>).</p>
<p><kbd>queue1.put((priority, item), block=True, timeout=None)</kbd>: This puts the specified item into the queue with an integer priority value. The optional block and timeout arguments are provided (<kbd>PriorityQueue</kbd>).</p>
<p><kbd>queue1.put_nowait(item)</kbd>: This puts the specified item into the queue. The optional block and timeout arguments are provided (<kbd>Queue</kbd>, <kbd>LifoQueue</kbd>, <kbd>SimpleQueue</kbd>).</p>
<p><kbd>queue1.put_nowait((priority, item))</kbd>: This puts the specified item into the queue with an integer priority value. The optional block and timeout arguments are provided (<kbd>PriorityQueue</kbd>).</p>
<p><kbd>queue1.get(block=True, timeout=None)</kbd>: This returns an item from the queue. The optional block and timeout arguments are provided (<kbd>Queue</kbd>, <kbd>LifoQueue</kbd>, <kbd>PriorityQueue</kbd>, <kbd>SimpleQueue</kbd>).</p>
<p><kbd>queue1.get_nowait()</kbd>: This returns an item from the queue (<kbd>Queue</kbd>, <kbd>LifoQueue</kbd>, <kbd>PriorityQueue</kbd>, <kbd>SimpleQueue</kbd>).</p>
<p><kbd>queue1.task_done()</kbd>: This indicates that the task of the queue is complete (<kbd>Queue</kbd>, <kbd>LifoQueue</kbd>, <kbd>PriorityQueue</kbd>).</p>
<p><kbd>queue1.join()</kbd>: This blocks until all items have been processed and have completed (<kbd>Queue</kbd>, <kbd>LifoQueue</kbd>, <kbd>PriorityQueue</kbd>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">subprocess</h1>
                
            
            
                
<p>This Python standard library module realizes the functionality related to running processes in a similar manner to the <kbd>QProcess</kbd> class of the Qt library. This module runs tasks as new processes, connects to the input/output/error pipes of the processes, and obtains their return codes. Previously, we implemented subprocesses such as running the camera device functionality. Let's describe this module in more detail. To use it in our application, we need to import the following module:</p>
<pre>...<br/>import subprocess<br/>...</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The most important classes and methods that can be used in the application are described in the following section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">run()</h1>
                
            
            
                
<p>The <kbd>run()</kbd> method, which is available from Python version 3.5, runs the tasks in the new process. The syntax is as follows:</p>
<pre><strong>subprocess1</strong> = subprocess.run(["command", "-flags", "args"],<br/>                    *, stdin=None, input=None, stdout=None,<br/>                         stderr=None, capture_output=False,<br/>                       shell=False, cwd=None, timeout=None,<br/>                   check=False, encoding=None, errors=None,<br/>                   text=None, env=None, universal_newlines=None)</pre>
<p>The first parameter is a list with a command and arguments, as well as flags if they are provided. The <kbd>stdin</kbd>, <kbd>stdout</kbd>, and <kbd>stderr</kbd> arguments specify the executed program's <kbd>STDIN</kbd> (standard input), <kbd>STDOUT</kbd> (standard output), and <kbd>STDERR</kbd> (standard error). Values such as <kbd>PIPE</kbd>, <kbd>DEVNULL</kbd>, and <kbd>STDOUT</kbd> can be used. The <kbd>input</kbd> is used for the <kbd>communicate()</kbd> method. If <kbd>capture_output</kbd> is <kbd>True</kbd>, <kbd>stdout</kbd> and <kbd>stderr</kbd> will be captured. If <kbd>shell</kbd> is <kbd>True</kbd>, it specifies the command to execute through the shell. If <kbd>cwd</kbd> is not <kbd>None</kbd>, it changes the <kbd>cwd</kbd> (current working directory) before executing. <kbd>timeout</kbd> is used for the <kbd>communicate()</kbd> method. When the timeout expires, the child process will be killed and waited for. If <kbd>check</kbd> is <kbd>True</kbd>, and the process exits with a nonzero exit code, a <kbd>CalledProcessError</kbd> exception will be raised. <kbd>encoding</kbd> specifies which encoding will be used, such as <kbd>"utf-8"</kbd> or <kbd>" cp1252"</kbd>. <kbd>errors</kbd> specifies how encoding and decoding errors are to be handled with string values such as <kbd>"strict"</kbd>, <kbd>"ignore"</kbd>, <kbd>"replace"</kbd>, <kbd>"backslashreplace"</kbd>, <kbd>"xmlcharrefreplace"</kbd>,  and <kbd>"namereplace"</kbd>. If <kbd>text</kbd> is <kbd>True</kbd>, the file objects for <kbd>stdin</kbd>, <kbd>stdout</kbd>, and <kbd>stderr</kbd> are opened in text mode. <kbd>env</kbd> defines the environment variables for the new process. <kbd>universal_newlines</kbd> is equivalent to text and is provided for backward compatibility.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Popen</h1>
                
            
            
                
<p>The <kbd>Popen</kbd> class handles the underlying process creation and management in the <kbd>subprocess</kbd> module. This class provides additional optional arguments that can be used. The syntax of this class looks like this:</p>
<pre><strong>subprocess1</strong> = subprocess.Popen(["command", "-flags", "args"],<br/>                     bufsize=-1, executable=None, stdin=None,<br/>                   stdout=None, stderr=None, preexec_fn=None,<br/>                       close_fds=True, shell=False, cwd=None,<br/>                           env=None, universal_newlines=None,<br/>                           startupinfo=None, creationflags=0,<br/>                                        restore_signals=True,<br/>                     start_new_session=False, pass_fds=(), *,<br/>                       encoding=None, errors=None, text=None)</pre>
<p class="CDPAlignLeft CDPAlign">The first parameter is a list with a command and arguments, as well as flags if they are provided. <kbd>bufsize</kbd> will be used with the <kbd>open()</kbd> function when creating the <kbd>stdin</kbd>/<kbd>stdout</kbd>/<kbd>stderr</kbd> pipe file objects. <kbd>executable</kbd> specifies a replacement program to execute. The <kbd>stdin</kbd>, <kbd>stdout</kbd>, and <kbd>stderr</kbd> arguments specify the executed program's <kbd>STDIN</kbd> (standard input), <kbd>STDOUT</kbd> (standard output), and <kbd>STDERR</kbd> (standard error). Valid values include <kbd>PIPE</kbd>, <kbd>DEVNULL</kbd>, and <kbd>STDOUT</kbd>.  The object is called in the child process just before the child is executed (POSIX only) if <kbd>preexec_fn</kbd> is set. If <kbd>close_fds</kbd> is <kbd>True</kbd>, all file descriptors will be closed before execution, except <kbd>0</kbd>, <kbd>1</kbd>, and <kbd>2</kbd>. The command will get executed through the shell if the shell is <kbd>True</kbd>. If <kbd>cwd</kbd> is not <kbd>None</kbd>, it changes the <kbd>cwd</kbd> (current working directory) before executing. <kbd>env</kbd> defines the environment variables for the new process. <kbd>universal_newlines</kbd> is equivalent to text and is provided for backward compatibility. <kbd>startupinfo</kbd> will be a <kbd>STARTUPINFO</kbd> object that is passed to the <kbd>CreateProcess</kbd> function with creation flags. If <kbd>restore_signals</kbd> is <kbd>True</kbd>, all signals that are set to <kbd>SIG_IGN</kbd> are restored to <kbd>SIG_DFL</kbd> before execution (POSIX only). If <kbd>start_new_session</kbd> is <kbd>True</kbd>, a <kbd>setsid()</kbd> system call will be made in the child process prior to the execution of the subprocess (POSIX only). <kbd>pass_fds</kbd> is a sequence of file descriptors that will be kept open between the parent and child (POSIX only). <kbd>encoding</kbd> specifies which encoding will be used, such as <kbd>"utf-8"</kbd> or <kbd>"cp1252"</kbd>. <kbd>errors</kbd> specifies how encoding and decoding errors are to be handled, with string values such as <kbd>"strict"</kbd>, <strong><kbd>"ignore"</kbd></strong>, <kbd>"replace"</kbd>, <kbd>"backslashreplace"</kbd>, <kbd>"xmlcharrefreplace"</kbd>, and <kbd>"namereplace"</kbd>. If <kbd>text</kbd> is <kbd>True</kbd>, the file objects for <kbd>stdin</kbd>, <kbd>stdout</kbd>, and <kbd>stderr</kbd> are opened in text mode.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functions</h1>
                
            
            
                
<p>The following methods can be used with this module:</p>
<p><kbd>subprocess1.poll()</kbd>: This checks if the sub-process has terminated.</p>
<p><kbd>subprocess1.wait(timeout=None)</kbd>: This waits for the termination of the sub-process with a timeout, if specified.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><kbd>subprocess1.communicate(input=None, timeout=None)</kbd>: This interacts with the process by sending the data to <kbd>STDIN</kbd> and reading the data from <kbd>STDOUT</kbd>/<kbd>STDERR</kbd>, while waiting for termination. The input can be data to be sent to the sub-process.</p>
<p><kbd>subprocess1.send_signal(signal)</kbd>: This sends the signal to the sub-process. It has the following functions:</p>
<ul>
<li><kbd>subprocess1.terminate()</kbd>: This terminates the sub-process using OS parameters.</li>
<li><kbd>subprocess1.kill()</kbd>: This kills the sub-process using OS parameters.</li>
<li><kbd>subprocess1.args</kbd>: This returns the arguments passed to <kbd>Popen</kbd>.</li>
<li><kbd>subprocess1.stdin</kbd>: This returns the argument passed to <kbd>Popen</kbd> standard input.</li>
<li><kbd>subprocess1.stdout</kbd>: This returns the argument passed to <kbd>Popen</kbd> standard output.</li>
<li><kbd>subprocess1.stderr</kbd>: This returns the argument passed to <kbd>Popen</kbd> standard error.</li>
<li><kbd>subprocess1.pid</kbd>: This returns the process ID of the sub-process.</li>
<li><kbd>subprocess1.returncode</kbd>: This returns the return code of the sub-process.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">multiprocessing</h1>
                
            
            
                
<p>This Python standard library package manages the spawning processes that can be used in the application. When using local and remote concurrency, this instrument side steps the <strong>Global Interpreter Lock</strong> (<strong>GIL</strong>) limitations by using sub-processes instead of threads, and, as a result, effectively leverages multiple processors if the device has them. The API of the multiprocessing package is similar to the <kbd>threading</kbd> module, and the methods mostly replicate the <kbd>Thread</kbd> class of the <kbd>threading</kbd> module, similar to <kbd>Queue</kbd> of the <kbd>queue</kbd> module that was shown earlier. To use it in our application, we need to import the following package:</p>
<pre>...<br/>import multiprocessing<br/>..</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Process</h1>
                
            
            
                
<p>This class represents the process objects that enable multiprocessing and the activity of the separate processes. The syntax is as follows:</p>
<pre><strong>process1</strong> = multiprocessing.Process(group=None, target=None,<br/>                                        name=None, args=(),<br/>                                 kwargs={}, *, daemon=None)</pre>
<p>The parameters have similar meanings to those in the <kbd>Thread</kbd> class of the threading module. The methods that are used in this class are as follows:</p>
<p><kbd>process1.run()</kbd>: This represents the activity of the processes.</p>
<p><kbd>process1.start()</kbd>: This starts the processes.</p>
<p><kbd>process1.join(float)</kbd>: This waits until the process terminates. The timeout parameter (optional) waits before blocking the operation or blocking immediately after termination.</p>
<p><kbd>process1.is_alive()</kbd>: This returns <kbd>True</kbd> if this process is alive, otherwise it returns <kbd>False</kbd>.</p>
<p><kbd>process1.close()</kbd>: This closes the process and releases all associated resources.</p>
<p><kbd>process1.kill()</kbd>: This kills the process.</p>
<p><kbd>process1.terminate()</kbd>: This terminates the process.</p>
<p><kbd>process1.name</kbd>: This returns the name of the process.</p>
<p><kbd>process1.daemon</kbd>: This returns the daemon flag of the process, that is, <kbd>True</kbd> or <kbd>False</kbd>.</p>
<p><kbd>process1.pid</kbd>: This returns the ID of the process.</p>
<p><kbd>process1.exitcode</kbd>: This returns the sub-process exit code.</p>
<p><kbd>process1.authkey</kbd>: This returns the authentication key of the process.</p>
<p><kbd>process1.sentinel</kbd>: This returns the numeric handle of a system object that will be ready when the process ends.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Connection</h1>
                
            
            
                
<p>This class creates the connection objects that allow us to send and receive pickleable objects or strings. The syntax is as follows:</p>
<pre><strong>conn</strong> = multiprocessing.connection.Connection</pre>
<p>The methods that can be used are as follows:</p>
<p><kbd>conn.send(obj)</kbd>: This sends the pickleable object to the other end of the connection.</p>
<p><kbd>conn.recv()</kbd>: This returns an object that's received from the other end of the connection.</p>
<p><kbd>conn.fileno()</kbd>: This returns the file descriptor or handle of the connection.</p>
<p><kbd>conn.close()</kbd>: This closes the connection.</p>
<p><kbd>conn.poll(timeout)</kbd>: This returns <kbd>True</kbd> if any data is available to be read.</p>
<p><kbd>conn.send_bytes(buffer, offset, size)</kbd>: This sends the data from a bytes-like object. The data will read from the position in<strong> <kbd>buffer</kbd></strong> if <kbd>offset</kbd> is specified, with the <kbd>size</kbd> of bytes, if specified.</p>
<p><kbd>conn.recv_bytes(maxlength)</kbd>: This returns the message of byte data received from the other end of the connection. <kbd>maxlength</kbd> limits the message, if specified.</p>
<p><kbd>conn.recv_bytes_into(buffer, offset)</kbd>: This reads the message of byte data that's received from the other end of the connection and returns the number of bytes in the message. If <kbd>offset</kbd> is specified, the message will be written into <kbd>buffer</kbd> from that position.</p>
<p>Connections are usually created with the <kbd>Pipe</kbd> class. Constructing a connection like this has the following syntax:</p>
<pre><strong>conn1, conn2</strong> = multiprocessing.Pipe(duplex)</pre>
<p>If the duplex parameter is <kbd>True</kbd>, the pipe is bidirectional, and if it's <kbd>False</kbd>, the pipe is unidirectional. This means that <kbd>conn1</kbd> is used for receiving messages and <kbd>conn2</kbd> is used for sending messages. An example of connections is as follows:</p>
<pre>def func1(msg, conn):<br/>    conn.send(str(msg))<br/>    conn.close()<br/><br/>def func2(msg, conn):<br/>    conn.send(msg)<br/>    conn.close()<br/><br/>if __name__ == "__main__":<br/>    conn1, conn2 = multiprocessing.Pipe()<br/>    process1 = multiprocessing.Process(<br/>           target=func1, args=(<br/>                  "Hello Process # 1", conn2))<br/>    process2 = multiprocessing.Process(<br/>           target=func2, args=(<br/>                  "Hello Process # 2", conn1))<br/>    process1.start()<br/>    process2.start()<br/>    print(conn1.recv())<br/>    print(conn2.recv())<br/>    process1.join()<br/>    process2.join()</pre>
<p>Here, we have created functions with the send methods of the <kbd>Connection</kbd> class; the <kbd>Pipe</kbd> class was used for the connection, and the methods that were described previously were also used. This construction is not random. In terms of multiprocessing, we need to operate the processes inside the <strong><kbd>if __name__ == "__main__"</kbd></strong> instruction, or call the function with multiprocessing functionality. With the <kbd>multiprocessing</kbd> package, classes such as <kbd>Pool</kbd>, which creates the pool of processes; <kbd>Queue</kbd>, which creates the queues; <kbd>Manager</kbd>, which controls the server process that manages shared objects; and the <kbd>Listener</kbd> and <kbd>Client</kbd> classes of the connection module, are also available. It is recommended that you learn about these classes and modules. In addition, the multiprocessing package has the following methods, which can be useful:</p>
<ul>
<li><kbd>multiprocessing.active_children()</kbd>: This returns all the live children of the current process.</li>
<li><kbd>multiprocessing.cpu_count()</kbd>: This returns the number of CPUs used in the device.</li>
<li><kbd>multiprocessing.current_process()</kbd>: This returns the current process.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter completes the basic part of this book's material. The use of threads improves the productivity of the application. The importance and size of the instruments is such a vast subject that we would need a separate book to cover it all. This is why we just looked at the starting points. More information about these interesting and useful tools is available in the official documentations of PySide2 (<a href="https://doc.qt.io/qtforpython/index.html">https://doc.qt.io/qtforpython/index.html</a>), PyQt5 (<a href="https://www.riverbankcomputing.com/static/Docs/PyQt5/">https://www.riverbankcomputing.com/static/Docs/PyQt5/</a>), and of course Python (<a href="https://docs.python.org/3/">https://docs.python.org/3/</a>). Constructions of multithreading and multiprocessing and implementing them in our application have pole positions because they make the GUI application comfortable and user-friendly. Almost everything that's necessary for use in GUI development was covered in this chapter.</p>
<p>The next chapter will complete this book. We will finalize our GUI application, provide mechanisms for embedding the application in different platforms, and try out some code while explaining the basics.</p>


            

            
        
    </body></html>