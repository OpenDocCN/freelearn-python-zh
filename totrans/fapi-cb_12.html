<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-380"><a id="_idTextAnchor384"/>12</h1>
<h1 id="_idParaDest-381"><a id="_idTextAnchor385"/>Deploying and Managing FastAPI Applications</h1>
<p>In this chapter, we delve into the essential aspects of deploying and managing FastAPI applications. As you develop your FastAPI projects, understanding how to effectively run, secure, and scale them is crucial for ensuring performance and reliability in production environments. This chapter will equip you with the knowledge and tools needed to deploy your FastAPI applications seamlessly, leveraging various technologies and best practices.</p>
<p>You will learn how to<a id="_idIndexMarker783"/> utilize the <strong class="bold">FastAPI CLI</strong> to run your server efficiently, enabling <strong class="bold">HTTPS</strong> to <a id="_idIndexMarker784"/>secure your applications, and containerizing your FastAPI projects <a id="_idIndexMarker785"/>with <strong class="bold">Docker</strong>. Additionally, we will explore techniques for scaling your applications across multiple workers, packaging your applications for distribution, and deploying them on cloud platforms such <a id="_idIndexMarker786"/>as <strong class="bold">Railway</strong>. Each recipe in this chapter provides step-by-step instructions, practical examples, and insights into optimizing your deployment workflow.</p>
<p>By the end of this chapter, you will be proficient in deploying FastAPI applications using modern tools and methodologies. You’ll be able to always secure your applications with HTTPS, run them in Docker containers, scale them with multiple workers, and deploy them on the cloud. These skills are invaluable for any developer aiming to take their FastAPI applications from development to production.</p>
<p>In this chapter, we’re going to cover the following recipes:</p>
<ul>
<li>Running the server with the FastAPI CLI</li>
<li>Enabling HTTPS on FastAPI applications</li>
<li>Running FastAPI applications in Docker containers</li>
<li>Running the server across multiple workers</li>
<li>Deploying your FastAPI application on the cloud</li>
<li>Shipping FastAPI applications with Hatch</li>
</ul>
<h1 id="_idParaDest-382"><a id="_idTextAnchor386"/>Technical requirements</h1>
<p>This chapter is for advanced users who want to learn how to deploy their FastAPI applications on the cloud. If you are new to FastAPI or Python, you might want to check out the first two chapters of the book.</p>
<p>You can find the chapter’s code on GitHub here: <a href="https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter12">https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter12</a>.</p>
<p>To manage dependencies and isolate the project, set up a virtual environment in the project root folder.</p>
<p>For the <em class="italic">Running FastAPI applications in Docker containers</em> and <em class="italic">Running the server across multiple workers</em> recipes, we will be using Docker. Make sure to install it on your machine.</p>
<h1 id="_idParaDest-383"><a id="_idTextAnchor387"/>Running the server with the FastAPI CLI</h1>
<p>The FastAPI <code>$ fastapi</code> command to run a FastAPI application, manage a FastAPI project, and do other things. This feature was added in version 0.111.0 recently.</p>
<p>In this recipe, we’ll explore how to run a FastAPI application using the FastAPI CLI. This approach can streamline your development workflow and provide a more intuitive way to manage your server.</p>
<h2 id="_idParaDest-384"><a id="_idTextAnchor388"/>Getting ready</h2>
<p>To run the recipe, ensure you have a minimum FastAPI module with the application with at least one endpoint. We will work on a new application called <code>Live Application</code>, so create a new project folder called <code>live_application</code> with an <code>app</code> subfolder containing a <code>main.py</code> module as follows:</p>
<pre class="source-code">
from fastapi import FastAPI
app = FastAPI(title="FastAPI Live Application")
@app.get("/")
def read_root():
    return {"Hello": "World"}</pre> <p>Also, make sure you have a version of FastAPI higher than <code>0.111.0</code> in your environment by running the following from the command line:</p>
<pre class="console">
$ pip install "fastapi~=0.111.0"</pre> <p>If you already have installed it, make sure to have the latest version of <code>fastapi</code> in your environment. You can do it by running the following:</p>
<pre class="console">
$ pip install fastapi --upgrade</pre> <p>Once the installation or the upgrade is completed, we can start the recipe.</p>
<h2 id="_idParaDest-385"><a id="_idTextAnchor389"/>How to do it…</h2>
<p>With your <a id="_idIndexMarker788"/>application set <a id="_idIndexMarker789"/>up, simply run the following from the command line:</p>
<pre class="console">
$ fastapi dev</pre> <p>You will see detailed information printed on the terminal. Let’s check the most important ones.</p>
<p>The first message is like this:</p>
<pre class="console">
INFO    Using path app\main.py</pre> <p>In the <code>fastapi dev</code> command, we didn’t specify an <code>app.main:app</code> argument as we used to do with the <code>uvicorn</code> command. The FastAPI CLI automatically detects the <code>FastAPI</code> object class in the code according to a set of default paths.</p>
<p>The following messages are about the building of the server by looking at the packages and modules to be considered. Then, it explicitly shows the resolved import for the <code>FastAPI</code> object class:</p>
<pre class="console">
╭─ Python module file ─╮
│                      │
│   main.py            │
│                      │
╰──────────────────────╯
INFO    Importing module main
INFO    Found importable FastAPI app
╭─ Importable FastAPI app ─╮
│                          │
│  from main import app    │
│                          │
╰──────────────────────────╯
INFO    Using import string main:app</pre> <p>Then, you<a id="_idIndexMarker790"/> will see<a id="_idIndexMarker791"/> messages specifying the running mode with the main addresses similar to this one:</p>
<pre class="console">
╭────────── FastAPI CLI - Development mode ───────────╮
│                                                     │
│  Serving at: http://127.0.0.1:8000                  │
│                                                     │
│  API docs: http://127.0.0.1:8000/docs               │
│                                                     │
│  Running in development mode, for production use:   │
│                                                     │
│  fastapi run                                        │
│                                                     │
╰─────────────────────────────────────────────────────╯</pre> <p>This message indicates that the application is operating in development mode.</p>
<p>This means that it will restart the server automatically when there are code updates, and the server will run on the local address <code>127.0.0.1</code>.</p>
<p>You can alternatively run the server in production mode by running the following:</p>
<pre class="console">
$ fastapi run</pre> <p>This won’t apply any reload and the server will make the application visible to the local network of the machine hosting the server.</p>
<p>These <a id="_idIndexMarker792"/>are some<a id="_idIndexMarker793"/> of the basic commands that you can use to run your FastAPI application with different settings and options. For more advanced features and configurations, you can refer to the FastAPI documentation.</p>
<h2 id="_idParaDest-386"><a id="_idTextAnchor390"/>There’s more…</h2>
<p>The FastAPI CLI relies on the <code>uvicorn</code> command<a id="_idIndexMarker794"/> to run. Some of the arguments are similar. For instance, if we want to run the service on a different port number than <code>8000</code>, we can use the <code>--port</code> parameter, or to specify the host address, we can use <code>--host</code>. You can use the <code>--help</code> parameter to see the command-line documentation with the list of all the available parameters. For example, you can run the following:</p>
<pre class="console">
$ fastapi run --help</pre> <p>As an example, to run the application visible to the network, you can pass the unspecified address <code>0.0.0.0</code> to the host as follows:</p>
<pre class="console">
$ fastapi run</pre> <p>This is the equivalent of the following:</p>
<pre class="console">
$ uvicorn app.main:app --host 0.0.0.0</pre> <p>Your application will now be visible to the hosting local network.</p>
<h2 id="_idParaDest-387"><a id="_idTextAnchor391"/>See also</h2>
<p>You can check more on the functionalities of the <a id="_idIndexMarker795"/>FastAPI CLI on the official documentation page:</p>
<ul>
<li><em class="italic">FastAPI </em><em class="italic">CLI</em>: https://fastapi.tiangolo.com/fastapi-cli/</li>
</ul>
<h1 id="_idParaDest-388"><a id="_idTextAnchor392"/>Enabling HTTPS on FastAPI applications</h1>
<p>Web applications need<a id="_idIndexMarker796"/> security, and <strong class="bold">Hypertext Transfer Protocol Secure</strong> (<strong class="bold">HTTPS</strong>) is a basic way to secure communication between clients and servers.</p>
<p>HTTPS scrambles the data sent over the network, preventing unauthorized access and modification.</p>
<p>In this recipe, we will learn how to enable HTTPS on FastAPI applications for local testing. We’ll use <code>mkcert</code> to<a id="_idIndexMarker797"/> make a <strong class="bold">Secure Sockets Layer/Transport Layer Security</strong> (<strong class="bold">SSL/TLS</strong>) certificate<a id="_idIndexMarker798"/> for local development and give some advice for production deployment. By the end of the recipe, you’ll be able to protect your FastAPI application with HTTPS, improving its security and reliability.</p>
<h2 id="_idParaDest-389"><a id="_idTextAnchor393"/>Getting ready</h2>
<p>Some background information about HTTPS and SSL/TLS certificates can help with this recipe. From a consumer perspective, you can find a good overview at this link: <a href="https://howhttps.works/">https://howhttps.works/</a>.</p>
<p>We will also use an existing application as an example. You can either apply the recipe to your own application or use <code>Live Application</code> as a reference.</p>
<p>You will also need <code>mkcert</code>, so install it correctly on your machine. Installation depends on your operating system, and you can see the instructions here: <a href="https://github.com/FiloSottile/mkcert?tab=readme-ov-file#installation">https://github.com/FiloSottile/mkcert?tab=readme-ov-file#installation</a>.</p>
<p>After installing, run this command from your terminal to see how to use it and check that it works:</p>
<pre class="console">
$ mkcert</pre> <p>When the installation is complete, we can start the recipe.</p>
<h2 id="_idParaDest-390"><a id="_idTextAnchor394"/>How to do it…</h2>
<p>Let’s<a id="_idIndexMarker799"/> set up our certificates<a id="_idIndexMarker800"/> through the following steps.</p>
<ol>
<li>Let’s start by allowing our browser to trust certificates created locally with <code>mkcert</code>. Run this simple command:<pre class="source-code">
<strong class="bold">$ mkcert -install</strong>
<strong class="bold">The local CA is now installed in the system trust store! </strong><strong class="bold">⚡</strong></pre><p class="list-inset">This command has added a local certificate in your operating system trust store so that your browsers will automatically accept it as a reliable source of certificates.</pre></li> <li>We can then create the certificates and the private key that the server will use for some domain ranges by running the following:<pre class="source-code">
<code>example.com+5-key.pem</code> for the key and <code>example.com+5.pem</code> for the certificate.</p></li> </ol>
<p class="callout-heading">Warning</p>
<p class="callout">To ensure security, do not include certificates and keys in your Git history when you create them. Add the <code>*.pem</code> file extension to the <code>.</code><code>gitignore</code> file</p>
<ol>
<li value="3">We will <a id="_idIndexMarker801"/>have to give the key and the certificate to the server when it starts. At the<a id="_idIndexMarker802"/> time of writing, the <code>fastapi</code> command does not support the arguments to pass the key and the certificate to the server, so we will start the server with <code>uvicorn</code> by running the following:<pre class="source-code">
<strong class="bold">$ uvicorn app.main:app --port 443  \</strong>
<strong class="bold">--ssl-keyfile example.com+5-key.pem \</strong>
<strong class="bold">--ssl-certfile example.com+5.pem</strong></pre><p class="list-inset">This command will start the server with the certificate and the key.</p></li> </ol>
<p>This is all you need to set up an HTTPS server connection.</p>
<p>To test it, open your browser, and go to the <code>localhost</code> address.</p>
<p>You will see the lock icon on the address bar, which means that the connection is HTTPS.</p>
<p>However, if you try to reach the address with an HTTP connection at <code>http://localhost:443</code>, you will get an error response.</p>
<p>You can fix this by adding automatic redirection to the HTTPS of the server by using a dedicated middleware provided by FastAPI. Change the <code>main.py</code> file as follows:</p>
<pre class="source-code">
from fastapi import FastAPI
<strong class="bold">from fastapi.middleware.httpsredirect import (</strong>
<strong class="bold">    HTTPSRedirectMiddleware,</strong>
<strong class="bold">)</strong>
app = FastAPI(title="FastAPI Live Application")
<strong class="bold">app.add_middleware(HTTPSRedirectMiddleware)</strong>
# rest of the module</pre> <p>Then, restart the server. If you try to connect to <code>localhost</code> with an HTTP connection, (for example, <code>http://localhost:443</code>), it will automatically redirect you to an HTTPS connection, <code>https://localhost</code>. However, since it does not support port redirection, you have to specify port <code>443</code> anyway.</p>
<p>You have<a id="_idIndexMarker803"/> just enabled an HTTPS connection for your FastAPI application within the server. By<a id="_idIndexMarker804"/> enabling HTTPS for your FastAPI application, you have taken an important step toward enhancing web security and user experience. You can now enjoy the features of FastAPI with more confidence and trust.</p>
<h2 id="_idParaDest-391"><a id="_idTextAnchor395"/>There’s more…</h2>
<p>We have seen how to generate TLS/SSL certificates for local testing. In a production environment, it will be similar with the difference that this will<a id="_idIndexMarker805"/> involve the <strong class="bold">Domain Name System</strong> (<strong class="bold">DNS</strong>) hosting provider.</p>
<p>Here are general guidelines on how to do it:</p>
<ol>
<li>Generate a private key <a id="_idIndexMarker806"/>and a <strong class="bold">certificate signing request</strong> (<strong class="bold">CSR</strong>) for your domain name. Use tools<a id="_idIndexMarker807"/> such as <strong class="bold">OpenSSL</strong> or <strong class="bold">mkcert</strong> as<a id="_idIndexMarker808"/> well. Keep the private key secret. The CSR has information about your domain name and organization that a <strong class="bold">certificate authority</strong> (<strong class="bold">CA</strong>) will <a id="_idIndexMarker809"/>verify.</li>
<li>Submit the CSR to a CA and get a signed certificate. A CA is a trusted entity that issues and validates TLS/SSL certificates. There are self-signed, free, or paid CAs. You may need to provide more proof of your identity and domain ownership depending on the <a id="_idIndexMarker810"/>CA. Some <a id="_idIndexMarker811"/>popular CAs<a id="_idIndexMarker812"/> are <strong class="bold">Let’s Encrypt</strong>, <strong class="bold">DigiCert</strong>, and <strong class="bold">Comodo</strong>.</li>
<li>Install the certificate and the private key on your web server. The procedure may differ based on the server software and the operating system. You may also need to install intermediate certificates from the CA. Configure your web server to use HTTPS and redirect HTTP to HTTPS.</li>
</ol>
<p>Often, your hosting service provider may handle the TLS/SSL certificates and configuration for you. Some providers use tools such<a id="_idIndexMarker813"/> as <strong class="bold">Certbot</strong> to get and renew certificates from Let’s Encrypt, or they use their own CA. Check with your provider to see whether they offer such options and how to use them.</p>
<h2 id="_idParaDest-392"><a id="_idTextAnchor396"/>See also</h2>
<p>The GitHub repository at the following link shows you more possibilities <a id="_idIndexMarker814"/>of <code>mkcert</code>: </p>
<ul>
<li><em class="italic">mkcert: </em><a href="https://github.com/FiloSottile/mkcert">https://github.com/FiloSottile/mkcert</a></li>
</ul>
<p>In the FastAPI official documentation, you can<a id="_idIndexMarker815"/> have a look at HTTPS functioning on the page: </p>
<ul>
<li><em class="italic">About </em><em class="italic">HTTPS: </em><a href="https://fastapi.tiangolo.com/deployment/https/">https://fastapi.tiangolo.com/deployment/https/</a></li>
</ul>
<p>Instructions on how to run <code>uvicorn</code> in HTTPS mode<a id="_idIndexMarker816"/> can be found at the following link: </p>
<ul>
<li><em class="italic">Running with </em><em class="italic">HTTPS</em>: <a href="https://www.uvicorn.org/deployment/#running-with-https">https://www.uvicorn.org/deployment/#running-with-https</a></li>
</ul>
<p>You can find details on <code>HTTPSRedirectMiddle</code> on the<a id="_idIndexMarker817"/> official documentation page at this link:</p>
<ul>
<li><em class="italic"> </em><em class="italic">HTTPSRedirectMiddleware: </em><a href="https://fastapi.tiangolo.com/advanced/middleware/#httpsredirectmiddleware">https://fastapi.tiangolo.com/advanced/middleware/#httpsredirectmiddleware</a></li>
</ul>
<h1 id="_idParaDest-393"><a id="_idTextAnchor397"/>Running FastAPI applications in Docker containers</h1>
<p><strong class="bold">Docker</strong> is a <a id="_idIndexMarker818"/>useful tool that lets developers wrap applications with their dependencies into a container. This method makes sure that the application operates reliably in different environments, avoiding the common <em class="italic">works on my machine</em> issue. In this recipe, we will see how to make a Dockerfile and run a FastAPI application inside a Docker container. By the end of this guide, you will know how to put your FastAPI application into a container, making it more flexible and simpler to deploy.</p>
<h2 id="_idParaDest-394"><a id="_idTextAnchor398"/>Getting ready</h2>
<p>You will benefit from some knowledge of container technology, especially Docker, to follow the recipe better. But first, check <a id="_idIndexMarker819"/>that <strong class="bold">Docker Engine</strong> is set up properly on your machine. You can see how to do it at this link: <a href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/</a>.</p>
<p>If you use Windows, it is better to <a id="_idIndexMarker820"/>install <strong class="bold">Docker Desktop</strong>, which is a Docker virtual machine distribution with a built-in graphical interface.</p>
<p>Whether you have Docker Engine or Docker Desktop, make sure the daemon is running by typing this command:</p>
<pre class="console">
$ docker images</pre> <p>If you don’t see any error about the daemon, that means that Docker is installed and working on the machine. The way to start the Docker daemon depends on the installation you choose. Look at the related documentation to see how to do it.</p>
<p>You can use the recipe for your applications or follow along with the <code>Live Application</code> application that we introduced in the first recipe, which we are using throughout the chapter.</p>
<h2 id="_idParaDest-395"><a id="_idTextAnchor399"/>How to do it…</h2>
<p>It is not <a id="_idIndexMarker821"/>very complicated to run a simple FastAPI<a id="_idIndexMarker822"/> application in a Docker container. The process consists of three steps:</p>
<ol>
<li>Create the Dockerfile.</li>
<li>Build the image.</li>
<li>Generate the container.</li>
</ol>
<p>Then, you just have to run the container to have the application working.</p>
<h3>Creating the Dockerfile</h3>
<p>The Dockerfile<a id="_idIndexMarker823"/> contains the instructions needed to build the image from an operating system and the file we want to specify.</p>
<p>It is good practice to create a separate Dockerfile for the development environment. We will name it <code>Dockerfile.dev</code> and place it under the project root folder.</p>
<p>We start the file by specifying the base image, which will be as follows:</p>
<pre class="source-code">
FROM python:3.10</pre> <p>This will pull an image from the Docker Hub, which already comes with Python 3.10 integrated. Then, we create a folder called <code>/code</code> that will host our code:</p>
<pre class="source-code">
WORKDIR /code</pre> <p>Next, we copy <code>requirements.txt</code> into the image and install the packages inside the image:</p>
<pre class="source-code">
COPY ./requirements.txt /code/requirements.txt
RUN pip install --no-cache-dir -r /code/requirements.txt</pre> <p>The <code>pip install</code> command runs with the <code>--no-cache-dir</code> parameter to avoid <code>pip</code> caching operations that wouldn’t be beneficial inside a container. Also, in a production environment, for larger applications, it is recommended to pin fixed versions of the packages in <code>requirements.txt</code> to avoid potential compatibility issues due to package upgrades.</p>
<p>Then, we can copy the <code>app</code> folder containing the application into the image with the following command:</p>
<pre class="source-code">
COPY ./app /code/app</pre> <p>Finally, we define the server startup instruction as follows:</p>
<pre class="source-code">
CMD ["fastapi", "run", "app/main.py", "--port", "80"]</pre> <p>This is all we<a id="_idIndexMarker824"/> need to create our <code>Dockerfile.dev</code> file.</p>
<h3>Building the image</h3>
<p>Once we <a id="_idIndexMarker825"/>have <code>Dockerfile.dev</code>, we can build the image. We can do it by running the following from the command line at the project root folder level:</p>
<pre class="console">
$ docker build -f Dockerfile.dev -t live-application .</pre> <p>Since we named our Dockerfile <code>Dockerfile.dev</code>, we should specify it in an argument. Once the build is finished, you can check that the image has been correctly built by running the following:</p>
<pre class="console">
$ docker images live-application</pre> <p>You should see the details of the image on the output print like this:</p>
<pre class="console">
REPOSITORY      TAG    IMAGE ID    CREATED        SIZE
live-application latest  7ada80a535c2 43 seconds ago 1.06GB</pre> <p>With the image built, we<a id="_idIndexMarker826"/> can proceed with creating the container creation.</p>
<h3>Creating the container</h3>
<p>To create the<a id="_idIndexMarker827"/> container and run it; simply run the following:</p>
<pre class="console">
$ docker run -p 8000:80 live-application</pre> <p>This will create the container and run it. We can see the container by running the following:</p>
<pre class="console">
$ docker ps -a</pre> <p>Since we didn’t specify a container name, it will automatically affect a fancy name. Mine, for example, is <code>bold_robinson</code>.</p>
<p>Open the browser on <code>http://localhost:8000</code> and you will see the home page response of our application.</p>
<p>This is all you need to run a FastAPI application inside a Docker container. Running a FastAPI application in a Docker container is a great way to use the advantages of both technologies. You can easily scale, update, and deploy your web app with minimal configuration.</p>
<h2 id="_idParaDest-396"><a id="_idTextAnchor400"/>See also</h2>
<p>The Dockerfile <a id="_idIndexMarker828"/>can be used to specify several features of the image. Check the list of commands in the official documentation: </p>
<ul>
<li><em class="italic">Dockerfile </em><em class="italic">reference</em>: <a href="https://docs.docker.com/reference/dockerfile/">https://docs.docker.com/reference/dockerfile/</a></li>
</ul>
<p>Also, you can have a look at the Docker CLI documentation<a id="_idIndexMarker829"/> on the following page: </p>
<ul>
<li><em class="italic">Docker: </em><a href="https://docs.docker.com/reference/cli/docker/">https://docs.docker.com/reference/cli/docker/</a></li>
</ul>
<p>You can have a look at the FastAPI documentation page<a id="_idIndexMarker830"/> dedicated to the integration with Docker at this link: </p>
<ul>
<li><em class="italic">FastAPI in Containers - Docker: </em><a href="https://fastapi.tiangolo.com/deployment/docker/">https://fastapi.tiangolo.com/deployment/docker/</a> </li>
</ul>
<h1 id="_idParaDest-397"><a id="_idTextAnchor401"/>Running the server across multiple workers</h1>
<p>In high-traffic<a id="_idIndexMarker831"/> environments, running a FastAPI application with a single worker may not be sufficient to handle all incoming requests efficiently. To improve performance and ensure better resource use, you can run your FastAPI instance across multiple workers. This can be achieved using tools such<a id="_idIndexMarker832"/> as <strong class="bold">Gunicorn</strong>.</p>
<p>In this recipe, we will explore how to run a FastAPI application with multiple workers using Gunicorn in a Docker container, and we will also discuss Uvicorn’s ability to handle multiple workers along with its limitations.</p>
<h2 id="_idParaDest-398"><a id="_idTextAnchor402"/>Getting ready</h2>
<p>The <code>gunicorn</code> package is not Windows compatible. To ensure operating system operability, we will run our <code>Live Application</code> in a Docker container.</p>
<p>The recipe will be based on the project created in the previous recipe, <em class="italic">Running FastAPI applications in </em><em class="italic">Docker containers</em>.</p>
<h2 id="_idParaDest-399"><a id="_idTextAnchor403"/>How to do it…</h2>
<p>FastAPI with multiple workers runs multiple copies of the app on different CPU processes.</p>
<p>To see this better, let’s make the endpoint show <a id="_idIndexMarker833"/>the <code>main.py</code>, add these lines:</p>
<pre class="source-code">
<strong class="bold">import logging</strong>
<strong class="bold">from os import getpid</strong>
# rest of the module
<strong class="bold">logger = logging.getLogger("uvicorn")</strong>
# rest of the module
@app.get("/")
def read_root():
<strong class="bold">    logger.info(f"Processd by worker {getpid()}")</strong>
    return {"Hello": "World"}</pre> <p>Let’s add<a id="_idIndexMarker834"/> the <code>gunicorn</code> dependency in the <code>requirements.txt</code> file as follows:</p>
<pre class="source-code">
fastapi
<code>gunicorn</code> instead of <code>uvicorn</code> to run the server.</p>
<p>If you are on Linux or macOS, you simply install <code>gunicorn</code> in your environment like this:</p>
<pre class="console">
$ pip install gunicorn</pre> <p>Then, run the server with four workers with the following command:</p>
<pre class="console">
$ gunicorn app.main:app --workers 4 \
--worker-class uvicorn.workers.UvicornWorker</pre> <p>If you are on Windows, we will use Docker. In the <code>Dockerfile.dev</code> file, add the new <code>CMD</code> instruction below the existing one, which will be ignored:</p>
<pre class="source-code">
CMD ["gunicorn",\
    "app.main:app",\
    "--bind", "0.0.0.0:80",\
    "--workers", "4",\
    "--worker-class",\
    "uvicorn.workers.UvicornWorker",\
    "--log-level", "debug"]</pre> <p>Then, build the Docker image with the following:</p>
<pre class="console">
$ docker build -t live-application-gunicorn \
-f Dockerfile.dev .</pre> <p>Next, run the container from the image:</p>
<pre class="console">
$ docker run -p 8000:80 -i live-application-gunicorn</pre> <p>The <code>-i</code> parameter allows you to run the container in interactive mode to see the logs.</p>
<p>After the server is running, open the browser on <code>http://localhost:8000/docs</code> and use the interactive documentation to make calls. On the terminal output, you will notice different PIDs that vary for each call.</p>
<p>This shows <a id="_idIndexMarker835"/>that Gunicorn can distribute the load among different processes, and you can take advantage of multiple CPU cores.</p>
<p>You have learned how to run a FastAPI app with Gunicorn and multiple workers, which can improve the performance and scalability of your web service. You can experiment with different settings and options to find the optimal configuration for your needs.</p>
<p class="callout-heading">Important note</p>
<p class="callout">You can run multiple workers with Uvicorn as well. However, Uvicorn’s worker process management is not as advanced as Gunicorn’s at the moment.</p>
<h2 id="_idParaDest-400"><a id="_idTextAnchor404"/>There’s more…</h2>
<p>One of the benefits of running Gunicorn<a id="_idIndexMarker836"/> with multiple workers is that it can handle more concurrent requests and improve the performance and availability of the web application. However, there are also some challenges and trade-offs that come with this approach.</p>
<p>For example, when using multiple workers, each worker process has its own memory space and cannot share data with other workers. This means that any stateful components of the application, such as caches or sessions, need to be stored in a centralized or distributed service, such as Redis or Memcached. Moreover, multiple workers may increase resource consumption and the risk of contention on the server machine, especially if the application is CPU-intensive or input/output-bound. Therefore, it is important to choose the optimal number of workers based on the characteristics of the application and the available resources.</p>
<p>A common heuristic is to use the formula <em class="italic">workers = (2 x cores) + 1</em>, where <em class="italic">cores</em> means the number of CPU cores on the server. However, this may not be suitable for all scenarios and may require some experimentation and fine-tuning.</p>
<h2 id="_idParaDest-401"><a id="_idTextAnchor405"/>See also</h2>
<p>You can discover more about<a id="_idIndexMarker837"/> Gunicorn in the official documentation at this link: </p>
<ul>
<li><em class="italic">gunicorn: </em><a href="https://gunicorn.org/">https://gunicorn.org/</a></li>
</ul>
<p>Also, you can have a look at the page in the FastAPI documentation<a id="_idIndexMarker838"/> dedicated to server workers:</p>
<ul>
<li><em class="italic"> Server Workers – Gunicorn with </em><em class="italic">Uvicorn: </em><a href="https://fastapi.tiangolo.com/deployment/server-workers/">https://fastapi.tiangolo.com/deployment/server-workers/</a></li>
</ul>
<h1 id="_idParaDest-402"><a id="_idTextAnchor406"/>Deploying your FastAPI application on the cloud</h1>
<p>Deploying your FastAPI application on the cloud is an essential step to make it accessible to users worldwide. In this recipe, we will demonstrate how to deploy a FastAPI application on Railway.</p>
<p>Railway is a<a id="_idIndexMarker839"/> versatile and user-friendly platform that enables developers to deploy, manage, and scale their applications with ease. By the end of the recipe, you will have a FastAPI application running on Railway, ready to serve users on the internet.</p>
<h2 id="_idParaDest-403"><a id="_idTextAnchor407"/>Getting started</h2>
<p>Before we begin, ensure that you have already set up an application, as we will be deploying it on the cloud. The recipe will be applied to our <code>Live Application</code>, the basic application created in the <em class="italic">Running the server with the FastAPI </em><em class="italic">CLI</em> recipe.</p>
<p>Also, put the project folder on GitHub, since it will be used as a reference for the deployment.</p>
<p>You will also need to set up an <a id="_idIndexMarker840"/>account at <a href="https://railway.app">https://railway.app</a>. The creation is straightforward, and you can use your GitHub account as well. When you sign up, you will receive a $5 credit, which is more than enough to cover the recipe.</p>
<h2 id="_idParaDest-404"><a id="_idTextAnchor408"/>How to do it…</h2>
<p>We will demonstrate how to deploy the application on Railway through the following steps:</p>
<ol>
<li>Create the configuration file.</li>
<li>Connect the Git repository.</li>
<li>Configure the deployment.<p class="list-inset">Although we will demonstrate it specifically for Railway, these steps are also common for other cloud services.</p></li>
</ol>
<h3>Creating the configuration file</h3>
<p>Every deployment tool requires a <a id="_idIndexMarker841"/>configuration file that contains specifications for the deployment. To deploy on Railway, under our project root folder, let’s create a file called <code>Procfile</code>. The file content will be as follows:</p>
<pre class="source-code">
web: fastapi run --port $PORT</pre> <p>Remember to push the file to the GitHub repository hosting your project to be visible to Railway.</p>
<h3>Connecting the Git repository</h3>
<p>Once the<a id="_idIndexMarker842"/> configuration file is set up, log in to Railway (<a href="https://railway.app/login">https://railway.app/login</a>) with your account and you will be redirected to your dashboard (<a href="https://railway.app/dashboard">https://railway.app/dashboard</a>).</p>
<p>Then, click on the <code>FastAPI-Cookbook</code> repository (<a href="https://github.com/PacktPublishing/FastAPI-Cookbook">https://github.com/PacktPublishing/FastAPI-Cookbook</a>), you can select it.</p>
<p>Then select <code>profound-enchantment</code>.</p>
<p>Once finished, the <em class="italic">deployment</em> icon will appear on the project dashboard. By default, the deployment takes the name of the chosen GitHub repository. In my case, it’s <code>FastAPI-Cookbook</code>.</p>
<h3>Configuring the deployment</h3>
<p>When you click on the <em class="italic">deployment</em> icon, you<a id="_idIndexMarker843"/> can see a warning indicating that the deployment has failed. To resolve this, we need to add some parameters.</p>
<p>Click on the <em class="italic">deployment</em> icon, which will open a window on the left. Then, click on the <strong class="bold">Settings</strong> tab. This will display a list of configurations with sections such as <strong class="bold">Source</strong>, <strong class="bold">Networking</strong>, <strong class="bold">Build</strong>, and <strong class="bold">Deploy</strong>.</p>
<p>Begin with the <code>FastAPI-Cookbook</code> repository or if your project’s root directory is not the repository root, click on <strong class="bold">Add Root Directory</strong> under the <strong class="bold">Source</strong> repository specification and enter the path.</p>
<p>For the <code>FastAPI-Cookbook</code> repository, the path will be <code>/Chapter12/live_application</code>. After adding the path, click on the <em class="italic">save</em> icon.</p>
<p>Leave the branch selected as <strong class="bold">main</strong>.</p>
<p>Moving on to the <code>fastapi-cookbook-production.up.railway.app</code>. You will have a slightly different domain.</p>
<p>Leave the remaining settings as they are.</p>
<p>At the top left of the screen, you will see a text bar with the text <strong class="bold">Apply 2 changes</strong> with a <strong class="bold">Deploy</strong> button. Click on it to apply the modification we have done.</p>
<p>After the deployment process is complete, your application will begin to handle live web traffic. The public address is defined in the <strong class="bold">Networking</strong> section of the <strong class="bold">Settings</strong> panel.</p>
<p>Open the address in a new browser tab, and check the response. You should see the implemented response:</p>
<pre class="source-code">
{
    "Hello": "World"
}</pre> <p>In your web browser’s address bar, you can see a <em class="italic">lock</em> icon, which indicates that the connection is secure and has a certificate. Usually, when you expose your service to the web, the hosting <a id="_idIndexMarker844"/>platform provides you with certificates.</p>
<p>You have just deployed your FastAPI application to be accessible on the World Wide Web. Now, users from all over the world can access your service.</p>
<h2 id="_idParaDest-405"><a id="_idTextAnchor409"/>There’s more…</h2>
<p>To deploy your service, Railway creates an image and then a container to run your service. You can specify a custom image with a Dockerfile and it will be automatically detected.</p>
<h2 id="_idParaDest-406"><a id="_idTextAnchor410"/>See also</h2>
<p>You can discover more about Railway services<a id="_idIndexMarker845"/> on the official documentation website: </p>
<ul>
<li><em class="italic">Railway </em><em class="italic">Docs: </em><a href="https://docs.railway.app/">https://docs.railway.app/</a></li>
</ul>
<p>You can check the official FastAPI template<a id="_idIndexMarker846"/> used for Railway at this link: </p>
<ul>
<li><em class="italic">FastAPI </em><em class="italic">Example: </em><a href="https://github.com/railwayapp-templates/fastapi">https://github.com/railwayapp-templates/fastapi</a></li>
</ul>
<p>FastAPI is one of the fastest-growing production applications, especially on the major public cloud service providers. That’s why you can find extensive documentation on how to use it:</p>
<p>For <strong class="bold">Google Cloud Platform</strong> (<strong class="bold">GCP</strong>), you<a id="_idIndexMarker847"/> can follow the article at the link: </p>
<ul>
<li><em class="italic">Deploying FastAPI app with Google Cloud Run</em> article at the following link: <a href="https://dev.to/0xnari/deploying-fastapi-app-with-google-cloud-run-13f3">https://dev.to/0xnari/deploying-fastapi-app-with-google-cloud-run-13f3</a></li>
</ul>
<p>For <strong class="bold">Amazon Web Services</strong> (<strong class="bold">AWS</strong>), check this <a id="_idIndexMarker848"/>Medium article:</p>
<ul>
<li><em class="italic">Deploy FastAPI on AWS </em><em class="italic">EC2</em>: <a href="https://medium.com/@shreyash966977/deploy-fastapi-on-aws-ec2-quick-and-easy-steps-954d4a1e4742">https://medium.com/@shreyash966977/deploy-fastapi-on-aws-ec2-quick-and-easy-steps-954d4a1e4742</a></li>
</ul>
<p>For Microsoft Azure, you can check the official documentation page:</p>
<ul>
<li><em class="italic">Using FastAPI Framework with Azure </em><em class="italic">Functions</em>: <a href="https://learn.microsoft.com/en-us/samples/azure-samples/fastapi-on-azure-functions/fastapi-on-azure-functions/">https://learn.microsoft.com/en-us/samples/azure-samples/fastapi-on-azure-functions/fastapi-on-azure-functions/</a></li>
</ul>
<p>On the FastAPI website, you can check other examples for other cloud providers at the following link:</p>
<ul>
<li><em class="italic">Deploy FastAPI on Cloud </em><em class="italic">Providers</em>: <a href="https://fastapi.tiangolo.com/deployment/cloud/">https://fastapi.tiangolo.com/deployment/cloud/</a></li>
</ul>
<p>A useful tool is the Porter platform, which<a id="_idIndexMarker849"/> allows you to deploy your applications on different cloud services such as AWS, GCP, and Azure from one centralized platform. Have a look at this link:</p>
<ul>
<li><em class="italic">Deploy a FastAPI </em><em class="italic">app: </em><a href="https://docs.porter.run/guides/fastapi/deploy-fastapi">https://docs.porter.run/guides/fastapi/deploy-fastapi</a></li>
</ul>
<h1 id="_idParaDest-407"><a id="_idTextAnchor411"/>Shipping FastAPI applications with Hatch</h1>
<p>Packaging and shipping a FastAPI application as a distributable package are essential for deploying and sharing your application efficiently.</p>
<p><strong class="bold">Hatch</strong> is a <a id="_idIndexMarker850"/>modern Python project management tool that simplifies the packaging, versioning, and distribution process. In this recipe, we’ll explore how to use Hatch to build and ship a package containing a FastAPI application. This will ensure that your application is portable, easy to install, and maintainable, making it easier to deploy and share with others.</p>
<h2 id="_idParaDest-408"><a id="_idTextAnchor412"/>Getting ready</h2>
<p>Hatch <a id="_idIndexMarker851"/>facilitates the use of multiple virtual environments<a id="_idIndexMarker852"/> for our project. It uses the <code>venv</code> package<a id="_idIndexMarker853"/> under the hood.</p>
<p>To run the recipe, you need to install Hatch on your local machine. The installation process may vary depending on your operating system. Detailed instructions can be found on the official documentation page: <a href="https://hatch.pypa.io/1.9/install/">https://hatch.pypa.io/1.9/install/</a>.</p>
<p>Once the installation is complete, verify that it has been correctly installed by running the following from the command-line terminal:</p>
<pre class="console">
$ hatch --version</pre> <p>You should have the version printed on the output like this:</p>
<pre class="console">
Hatch, version 1.11.1</pre> <p>Make sure that you installed a version higher than <code>1.11.1</code>. We can then start creating our package.</p>
<h2 id="_idParaDest-409"><a id="_idTextAnchor413"/>How to do it…</h2>
<p>We divide the process of shipping our FastAPI package into five steps:</p>
<ol>
<li>Initialize the project.</li>
<li>Install dependencies.</li>
<li>Create the app.</li>
<li>Build the distribution.</li>
<li>Test the package.</li>
</ol>
<p>Let’s start building our package.</p>
<h3>Initializing the project</h3>
<p>We start by <a id="_idIndexMarker854"/>creating our project by bootstrapping the structure. Let’s call our application <code>FCA</code>, which stands<a id="_idIndexMarker855"/> for <strong class="bold">FastAPI Cookbook Application</strong>. Let’s bootstrap our <a id="_idIndexMarker856"/>project by running the following command:</p>
<pre class="console">
$ hatch new "FCA Server"</pre> <p>The command will create a project bootstrap under the <code>fca-server</code> folder as follows:</p>
<pre class="console">
fca-server
├──src
│  └── fca_server
│      ├── __about__.py
│      └── __init__.py
├──tests
│  └── __init__.py
├──LICENSE.txt
├──README.md
└──pyproject.tomt</pre> <p>We can then directly use a virtual environment by entering the <code>fca-server</code> directory and running the following:</p>
<pre class="console">
$ hatch shell</pre> <p>The command will automatically create a default virtual environment and activate it. You will see your command-line terminal with a prepend value, <code>(fca-server)</code>, like so:</p>
<pre class="console">
(fca-server) path/to/fca-server $</pre> <p>Verify that the environment is correctly activated by checking the Python executable. You do it by running the following:</p>
<pre class="console">
$ python -c "import sys; print(sys.executable)"</pre> <p>The executable should come from the virtual environment called <code>fca-server</code>, which will present a path such as <code>&lt;virtual </code><code>environment locations&gt;\fca-server\Scripts\python</code>.</p>
<p>This will give you information on the virtual environment that you can also provide to your <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>) to <a id="_idIndexMarker857"/>work with the code.</p>
<p>You can <a id="_idIndexMarker858"/>exit from the shell by typing <code>exit</code> in the terminal. Also, you can run commands in the virtual environment without spawning the shell. For example, you can check the Python executable of the default environment by running the following:</p>
<pre class="console">
$ hatch run python -c "import sys; print(sys.executable)"</pre> <p>We can now proceed to install the package dependencies in our environment.</p>
<h3>Installing dependencies</h3>
<p>Now that you <a id="_idIndexMarker859"/>have created a virtual<a id="_idIndexMarker860"/> environment, let’s add the <code>fastapi</code> dependency to our project. We can do it by modifying the <code>pyproject.toml</code> file. Add it in the <code>dependencies</code> field under the <code>[project]</code> section like so:</p>
<pre class="source-code">
[project]
...
dependencies = [
  "fastapi"
]</pre> <p>Next time you spawn a shell, the dependencies will synchronized and the <code>fastapi</code> package will be installed.</p>
<p>Let’s see, for example, whether the <code>fastapi</code> command works by running the following:</p>
<pre class="console">
$ hatch run fastapi --help</pre> <p>If you see the help documentation of the command, the dependency has been added correctly.</p>
<h3>Creating the app</h3>
<p>Now <a id="_idIndexMarker861"/>that we have the environment with the <code>fastapi</code> package installed, we can develop our application.</p>
<p>Let’s create the <code>main.py</code> module <a id="_idIndexMarker862"/>under the <code>src/fca_server</code> folder and initialize the <code>APIRouter</code> object with one endpoint like this:</p>
<pre class="source-code">
from fastapi import APIRouter
app = APIRouter()
@app.get("/")
def read_root():
    return {
        "message":
        "Welcome to the FastAPI Cookbook Application!"
    }</pre> <p>Then, let’s import the router into the <code>src/fca_server.__init__.py</code> file as follows:</p>
<pre class="source-code">
from fca_server.main import router</pre> <p>This will allow us to directly import the router from the <code>fca_server</code> package from an external project.</p>
<h3>Building the distribution</h3>
<p>Now that <a id="_idIndexMarker863"/>we have finalized the package, let’s leverage Hatch to build the package distribution.</p>
<p>We will generate the package in the form of a <code>.tar.gz</code> file by running the following:</p>
<pre class="console">
$ hatch build -t sdist ../dist</pre> <p>It will generate the <code>fca_server-0.0.1.tar.gz</code> file placed outside of the project in a <code>dist</code> folder. We<a id="_idIndexMarker864"/> will then use the file <a id="_idIndexMarker865"/>in an external project.</p>
<h3>Testing the package</h3>
<p>Next, we<a id="_idIndexMarker866"/> will make a different project that uses the <code>fca_server</code> package we made.</p>
<p>Create an <code>import-fca-server</code> folder outside of the <code>fca-server</code> folder for the package and use it as the project root folder.</p>
<p>In the folder, make a local virtual environment with <code>venv</code> by running the following:</p>
<pre class="console">
$ python -m venv .venv</pre> <p>Activate the environment. On Linux or macOS, type the following:</p>
<pre class="console">
$ source .venv/Scripts/activate</pre> <p>On Windows, type this instead:</p>
<pre class="console">
$ .venv\Scripts\activate</pre> <p>Install the <code>fca_server</code> package with <code>pip</code>:</p>
<pre class="console">
$ pip install ..\dist\fca_server-0.0.1.tar.gz</pre> <p>Use the path where the <code>fca_server-0.0.1.tar.gz</code> file is.</p>
<p>Now, try to import the package.</p>
<p>Make a <code>main.py</code> file and import the router from the <code>fca_server</code> package:</p>
<pre class="source-code">
from fastapi import FastAPI
from fca_server import router
app = FastAPI(
    title="Import FCA Server Application"
)
app.include_router(router)</pre> <p>Run the server from the command line:</p>
<pre class="console">
$ fastapi run</pre> <p>Go to the interactive documentation at <code>http://localhost:8000/docs</code> and see the endpoint in the external package. You have just created a custom package and imported it into another project.</p>
<p>You have learned how to use Hatch to create and manage your Python projects with ease. This is a powerful tool that can save you time and effort and help you write better code. Now, you <a id="_idIndexMarker867"/>can experiment with different <a id="_idIndexMarker868"/>options and features of Hatch and see what else you can do with it.</p>
<h2 id="_idParaDest-410"><a id="_idTextAnchor414"/>There’s more…</h2>
<p>Hatch<a id="_idIndexMarker869"/> is a versatile packaging system for Python that allows you to create scripts and multiple environments for your projects.</p>
<p>With Hatch, you can also customize the location of the virtual environment files, such as whether you want them to be centralized or in the project folder. You can specify this option in the <code>config.toml</code> file, which <a id="_idIndexMarker870"/>contains the configuration settings for Hatch.</p>
<p>To find the location of the <code>config.toml</code> file, you can run the following command in your terminal:</p>
<pre class="console">
$ hatch config find</pre> <p>Hatch also lets you create the build of your package in a wheel format, which is a binary distribution format that is more efficient and compatible than the traditional source distribution.</p>
<p>Moreover, you can publish your package directly to the <strong class="bold">Python Package Index </strong>(<strong class="bold">PyPI</strong>), where other users <a id="_idIndexMarker871"/>can find and install it. Hatch makes it easy to share your code with the world.</p>
<h2 id="_idParaDest-411"><a id="_idTextAnchor415"/>See also</h2>
<p>You can find more information about Hatch<a id="_idIndexMarker872"/> in the official documentation at </p>
<ul>
<li><em class="italic">Hatch</em>: <a href="https://hatch.pypa.io/latest/">https://hatch.pypa.io/latest/</a></li>
</ul>
<p>We learned how to create a project bootstrap, but with Hatch, you can also initialize an existing project. Check out the documentation page: </p>
<ul>
<li><em class="italic">Existing project: </em>https://hatch.pypa.io/1.9/intro/#existing-project </li>
</ul>
<p>One of the greatest advantages of using Hatch is the flexibility of running the project for several virtual environments. Check more on the documentation page: </p>
<ul>
<li><em class="italic">Environments: </em><a href="https://hatch.pypa.io/1.9/environment/">https://hatch.pypa.io/1.9/environment/</a></li>
</ul>
<p>The <code>pyproject.toml</code> file<a id="_idIndexMarker873"/> is a configuration file for Python projects, introduced in <code>PEP 518</code> (<a href="https://peps.python.org/pep-0518/">https://peps.python.org/pep-0518/</a>). It aims to standardize and simplify the configuration of Python projects by providing a single place to specify build system requirements and other project metadata. It is used by other build tools. You can have a look at the Python Package User Guide page at the following link: </p>
<ul>
<li><em class="italic">Writing your </em><em class="italic">pyproject.toml: </em><a href="https://packaging.python.org/en/latest/guides/writing-pyproject-toml/">https://packaging.python.org/en/latest/guides/writing-pyproject-toml/</a></li>
</ul>
<p>You can see more on how to manage Python dependencies on this page: </p>
<ul>
<li><em class="italic">Dependency </em><em class="italic">configuration: </em><a href="https://hatch.pypa.io/dev/config/dependency/">https://hatch.pypa.io/dev/config/dependency/</a></li>
</ul>
</div>
</div></body></html>