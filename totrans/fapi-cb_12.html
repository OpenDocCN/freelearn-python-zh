<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer016">
<h1 class="chapter-number" id="_idParaDest-380"><a id="_idTextAnchor384"/>12</h1>
<h1 id="_idParaDest-381"><a id="_idTextAnchor385"/>Deploying and Managing FastAPI Applications</h1>
<p>In this chapter, we delve into the essential aspects of deploying and managing FastAPI applications. As you develop your FastAPI projects, understanding how to effectively run, secure, and scale them is crucial for ensuring performance and reliability in production environments. This chapter will equip you with the knowledge and tools needed to deploy your FastAPI applications seamlessly, leveraging various technologies and <span class="No-Break">best practices.</span></p>
<p>You will learn how to<a id="_idIndexMarker783"/> utilize the <strong class="bold">FastAPI CLI</strong> to run your server efficiently, enabling <strong class="bold">HTTPS</strong> to <a id="_idIndexMarker784"/>secure your applications, and containerizing your FastAPI projects <a id="_idIndexMarker785"/>with <strong class="bold">Docker</strong>. Additionally, we will explore techniques for scaling your applications across multiple workers, packaging your applications for distribution, and deploying them on cloud platforms such <a id="_idIndexMarker786"/>as <strong class="bold">Railway</strong>. Each recipe in this chapter provides step-by-step instructions, practical examples, and insights into optimizing your <span class="No-Break">deployment workflow.</span></p>
<p>By the end of this chapter, you will be proficient in deploying FastAPI applications using modern tools and methodologies. You’ll be able to always secure your applications with HTTPS, run them in Docker containers, scale them with multiple workers, and deploy them on the cloud. These skills are invaluable for any developer aiming to take their FastAPI applications from development <span class="No-Break">to production.</span></p>
<p>In this chapter, we’re going to cover the <span class="No-Break">following recipes:</span></p>
<ul>
<li>Running the server with the <span class="No-Break">FastAPI CLI</span></li>
<li>Enabling HTTPS on <span class="No-Break">FastAPI applications</span></li>
<li>Running FastAPI applications in <span class="No-Break">Docker containers</span></li>
<li>Running the server across <span class="No-Break">multiple workers</span></li>
<li>Deploying your FastAPI application on <span class="No-Break">the cloud</span></li>
<li>Shipping FastAPI applications <span class="No-Break">with Hatch</span></li>
</ul>
<h1 id="_idParaDest-382"><a id="_idTextAnchor386"/>Technical requirements</h1>
<p>This chapter is for advanced users who want to learn how to deploy their FastAPI applications on the cloud. If you are new to FastAPI or Python, you might want to check out the first two chapters of <span class="No-Break">the book.</span></p>
<p>You can find the chapter’s code on GitHub <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter12"><span class="No-Break">https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter12</span></a><span class="No-Break">.</span></p>
<p>To manage dependencies and isolate the project, set up a virtual environment in the project <span class="No-Break">root folder.</span></p>
<p>For the <em class="italic">Running FastAPI applications in Docker containers</em> and <em class="italic">Running the server across multiple workers</em> recipes, we will be using Docker. Make sure to install it on <span class="No-Break">your machine.</span></p>
<h1 id="_idParaDest-383"><a id="_idTextAnchor387"/>Running the server with the FastAPI CLI</h1>
<p>The FastAPI <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) is a <a id="_idIndexMarker787"/>program that runs in the command line. You can use the <strong class="source-inline">$ fastapi</strong> command to run a FastAPI application, manage a FastAPI project, and do other things. This feature was added in version <span class="No-Break">0.111.0 recently.</span></p>
<p>In this recipe, we’ll explore how to run a FastAPI application using the FastAPI CLI. This approach can streamline your development workflow and provide a more intuitive way to manage <span class="No-Break">your server.</span></p>
<h2 id="_idParaDest-384"><a id="_idTextAnchor388"/>Getting ready</h2>
<p>To run the recipe, ensure you have a minimum FastAPI module with the application with at least one endpoint. We will work on a new application called <strong class="source-inline">Live Application</strong>, so create a new project folder called <strong class="source-inline">live_application</strong> with an <strong class="source-inline">app</strong> subfolder containing a <strong class="source-inline">main.py</strong> module <span class="No-Break">as follows:</span></p>
<pre class="source-code">
from fastapi import FastAPI
app = FastAPI(title="FastAPI Live Application")
@app.get("/")
def read_root():
    return {"Hello": "World"}</pre> <p>Also, make sure you have a version of FastAPI higher than <strong class="source-inline">0.111.0</strong> in your environment by running the following from the <span class="No-Break">command line:</span></p>
<pre class="console">
$ pip install "fastapi~=0.111.0"</pre> <p>If you already have installed it, make sure to have the latest version of <strong class="source-inline">fastapi</strong> in your environment. You can do it by running <span class="No-Break">the following:</span></p>
<pre class="console">
$ pip install fastapi --upgrade</pre> <p>Once the installation or the upgrade is completed, we can start <span class="No-Break">the recipe.</span></p>
<h2 id="_idParaDest-385"><a id="_idTextAnchor389"/>How to do it…</h2>
<p>With your <a id="_idIndexMarker788"/>application set <a id="_idIndexMarker789"/>up, simply run the following from the <span class="No-Break">command line:</span></p>
<pre class="console">
$ fastapi dev</pre> <p>You will see detailed information printed on the terminal. Let’s check the most <span class="No-Break">important ones.</span></p>
<p>The first message is <span class="No-Break">like this:</span></p>
<pre class="console">
INFO    Using path app\main.py</pre> <p>In the <strong class="source-inline">fastapi dev</strong> command, we didn’t specify an <strong class="source-inline">app.main:app</strong> argument as we used to do with the <strong class="source-inline">uvicorn</strong> command. The FastAPI CLI automatically detects the <strong class="source-inline">FastAPI</strong> object class in the code according to a set of <span class="No-Break">default paths.</span></p>
<p>The following messages are about the building of the server by looking at the packages and modules to be considered. Then, it explicitly shows the resolved import for the <strong class="source-inline">FastAPI</strong> <span class="No-Break">object class:</span></p>
<pre class="console">
╭─ Python module file ─╮
│                      │
│   main.py            │
│                      │
╰──────────────────────╯
INFO    Importing module main
INFO    Found importable FastAPI app
╭─ Importable FastAPI app ─╮
│                          │
│  from main import app    │
│                          │
╰──────────────────────────╯
INFO    Using import string main:app</pre> <p>Then, you<a id="_idIndexMarker790"/> will see<a id="_idIndexMarker791"/> messages specifying the running mode with the main addresses similar to <span class="No-Break">this one:</span></p>
<pre class="console">
╭────────── FastAPI CLI - Development mode ───────────╮
│                                                     │
│  Serving at: http://127.0.0.1:8000                  │
│                                                     │
│  API docs: http://127.0.0.1:8000/docs               │
│                                                     │
│  Running in development mode, for production use:   │
│                                                     │
│  fastapi run                                        │
│                                                     │
╰─────────────────────────────────────────────────────╯</pre> <p>This message indicates that the application is operating in <span class="No-Break">development mode.</span></p>
<p>This means that it will restart the server automatically when there are code updates, and the server will run on the local <span class="No-Break">address </span><span class="No-Break"><strong class="source-inline">127.0.0.1</strong></span><span class="No-Break">.</span></p>
<p>You can alternatively run the server in production mode by running <span class="No-Break">the following:</span></p>
<pre class="console">
$ fastapi run</pre> <p>This won’t apply any reload and the server will make the application visible to the local network of the machine hosting <span class="No-Break">the server.</span></p>
<p>These <a id="_idIndexMarker792"/>are some<a id="_idIndexMarker793"/> of the basic commands that you can use to run your FastAPI application with different settings and options. For more advanced features and configurations, you can refer to the <span class="No-Break">FastAPI documentation.</span></p>
<h2 id="_idParaDest-386"><a id="_idTextAnchor390"/>There’s more…</h2>
<p>The FastAPI CLI relies on the <strong class="source-inline">uvicorn</strong> command<a id="_idIndexMarker794"/> to run. Some of the arguments are similar. For instance, if we want to run the service on a different port number than <strong class="source-inline">8000</strong>, we can use the <strong class="source-inline">--port</strong> parameter, or to specify the host address, we can use <strong class="source-inline">--host</strong>. You can use the <strong class="source-inline">--help</strong> parameter to see the command-line documentation with the list of all the available parameters. For example, you can run <span class="No-Break">the following:</span></p>
<pre class="console">
$ fastapi run --help</pre> <p>As an example, to run the application visible to the network, you can pass the unspecified address <strong class="source-inline">0.0.0.0</strong> to the host <span class="No-Break">as follows:</span></p>
<pre class="console">
$ fastapi run</pre> <p>This is the equivalent of <span class="No-Break">the following:</span></p>
<pre class="console">
$ uvicorn app.main:app --host 0.0.0.0</pre> <p>Your application will now be visible to the hosting <span class="No-Break">local network.</span></p>
<h2 id="_idParaDest-387"><a id="_idTextAnchor391"/>See also</h2>
<p>You can check more on the functionalities of the <a id="_idIndexMarker795"/>FastAPI CLI on the official <span class="No-Break">documentation page:</span></p>
<ul>
<li><em class="italic">FastAPI </em><span class="No-Break"><em class="italic">CLI</em></span><span class="No-Break">: </span><span class="No-Break">https://fastapi.tiangolo.com/fastapi-cli/</span></li>
</ul>
<h1 id="_idParaDest-388"><a id="_idTextAnchor392"/>Enabling HTTPS on FastAPI applications</h1>
<p>Web applications need<a id="_idIndexMarker796"/> security, and <strong class="bold">Hypertext Transfer Protocol Secure</strong> (<strong class="bold">HTTPS</strong>) is a basic way to secure communication between clients <span class="No-Break">and servers.</span></p>
<p>HTTPS scrambles the data sent over the network, preventing unauthorized access <span class="No-Break">and modification.</span></p>
<p>In this recipe, we will learn how to enable HTTPS on FastAPI applications for local testing. We’ll use <strong class="source-inline">mkcert</strong> to<a id="_idIndexMarker797"/> make a <strong class="bold">Secure Sockets Layer/Transport Layer Security</strong> (<strong class="bold">SSL/TLS</strong>) certificate<a id="_idIndexMarker798"/> for local development and give some advice for production deployment. By the end of the recipe, you’ll be able to protect your FastAPI application with HTTPS, improving its security <span class="No-Break">and reliability.</span></p>
<h2 id="_idParaDest-389"><a id="_idTextAnchor393"/>Getting ready</h2>
<p>Some background information about HTTPS and SSL/TLS certificates can help with this recipe. From a consumer perspective, you can find a good overview at this <span class="No-Break">link:</span><span class="No-Break"><span class="P---URL"> </span></span><a href="https://howhttps.works/"><span class="No-Break">https://howhttps.works/</span></a><span class="No-Break">.</span></p>
<p>We will also use an existing application as an example. You can either apply the recipe to your own application or use <strong class="source-inline">Live Application</strong> as <span class="No-Break">a reference.</span></p>
<p>You will also need <strong class="source-inline">mkcert</strong>, so install it correctly on your machine. Installation depends on your operating system, and you can see the instructions <span class="No-Break">here: </span><a href="https://github.com/FiloSottile/mkcert?tab=readme-ov-file#installation"><span class="No-Break">https://github.com/FiloSottile/mkcert?tab=readme-ov-file#installation</span></a><span class="No-Break">.</span></p>
<p>After installing, run this command from your terminal to see how to use it and check that <span class="No-Break">it works:</span></p>
<pre class="console">
$ mkcert</pre> <p>When the installation is complete, we can start <span class="No-Break">the recipe.</span></p>
<h2 id="_idParaDest-390"><a id="_idTextAnchor394"/>How to do it…</h2>
<p>Let’s<a id="_idIndexMarker799"/> set up our certificates<a id="_idIndexMarker800"/> through the <span class="No-Break">following steps.</span></p>
<ol>
<li>Let’s start by allowing our browser to trust certificates created locally with <strong class="source-inline">mkcert</strong>. Run this <span class="No-Break">simple command:</span><pre class="source-code">
<strong class="bold">$ mkcert -install</strong></pre><p class="list-inset">You will get a message <span class="No-Break">like this:</span></p><pre class="source-code"><strong class="bold">The local CA is now installed in the system trust store! </strong><strong class="bold">⚡</strong></pre><p class="list-inset">This command has added a local certificate in your operating system trust store so that your browsers will automatically accept it as a reliable source <span class="No-Break">of certificates.</span></p></li> <li>We can then create the certificates and the private key that the server will use for some domain ranges by running <span class="No-Break">the following:</span><pre class="source-code">
<strong class="bold">$ mkcert localhost 127.0.0.1</strong></pre><p class="list-inset">This command will generate two files: <strong class="source-inline">example.com+5-key.pem</strong> for the key and <strong class="source-inline">example.com+5.pem</strong> for <span class="No-Break">the certificate.</span></p></li> </ol>
<p class="callout-heading">Warning</p>
<p class="callout">To ensure security, do not include certificates and keys in your Git history when you create them. Add the <strong class="source-inline">*.pem</strong> file extension to the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">gitignore</strong></span><span class="No-Break"> file</span></p>
<ol>
<li value="3">We will <a id="_idIndexMarker801"/>have to give the key and the certificate to the server when it starts. At the<a id="_idIndexMarker802"/> time of writing, the <strong class="source-inline">fastapi</strong> command does not support the arguments to pass the key and the certificate to the server, so we will start the server with <strong class="source-inline">uvicorn</strong> by running <span class="No-Break">the following:</span><pre class="source-code">
<strong class="bold">$ uvicorn app.main:app --port 443  \</strong>
<strong class="bold">--ssl-keyfile example.com+5-key.pem \</strong>
<strong class="bold">--ssl-certfile example.com+5.pem</strong></pre><p class="list-inset">This command will start the server with the certificate and <span class="No-Break">the key.</span></p></li> </ol>
<p>This is all you need to set up an HTTPS <span class="No-Break">server connection.</span></p>
<p>To test it, open your browser, and go to the <span class="No-Break"><strong class="source-inline">localhost</strong></span><span class="No-Break"> address.</span></p>
<p>You will see the lock icon on the address bar, which means that the connection <span class="No-Break">is HTTPS.</span></p>
<p>However, if you try to reach the address with an HTTP connection at <strong class="source-inline">http://localhost:443</strong>, you will get an <span class="No-Break">error response.</span></p>
<p>You can fix this by adding automatic redirection to the HTTPS of the server by using a dedicated middleware provided by FastAPI. Change the <strong class="source-inline">main.py</strong> file <span class="No-Break">as follows:</span></p>
<pre class="source-code">
from fastapi import FastAPI
<strong class="bold">from fastapi.middleware.httpsredirect import (</strong>
<strong class="bold">    HTTPSRedirectMiddleware,</strong>
<strong class="bold">)</strong>
app = FastAPI(title="FastAPI Live Application")
<strong class="bold">app.add_middleware(HTTPSRedirectMiddleware)</strong>
# rest of the module</pre> <p>Then, restart the server. If you try to connect to <strong class="source-inline">localhost</strong> with an HTTP connection, (for example, <strong class="source-inline">http://localhost:443</strong>), it will automatically redirect you to an HTTPS connection, <strong class="source-inline">https://localhost</strong>. However, since it does not support port redirection, you have to specify port <span class="No-Break"><strong class="source-inline">443</strong></span><span class="No-Break"> anyway.</span></p>
<p>You have<a id="_idIndexMarker803"/> just enabled an HTTPS connection for your FastAPI application within the server. By<a id="_idIndexMarker804"/> enabling HTTPS for your FastAPI application, you have taken an important step toward enhancing web security and user experience. You can now enjoy the features of FastAPI with more confidence <span class="No-Break">and trust.</span></p>
<h2 id="_idParaDest-391"><a id="_idTextAnchor395"/>There’s more…</h2>
<p>We have seen how to generate TLS/SSL certificates for local testing. In a production environment, it will be similar with the difference that this will<a id="_idIndexMarker805"/> involve the <strong class="bold">Domain Name System</strong> (<strong class="bold">DNS</strong>) <span class="No-Break">hosting provider.</span></p>
<p>Here are general guidelines on how to <span class="No-Break">do it:</span></p>
<ol>
<li>Generate a private key <a id="_idIndexMarker806"/>and a <strong class="bold">certificate signing request</strong> (<strong class="bold">CSR</strong>) for your domain name. Use tools<a id="_idIndexMarker807"/> such as <strong class="bold">OpenSSL</strong> or <strong class="bold">mkcert</strong> as<a id="_idIndexMarker808"/> well. Keep the private key secret. The CSR has information about your domain name and organization that a <strong class="bold">certificate authority</strong> (<strong class="bold">CA</strong>) <span class="No-Break">will </span><span class="No-Break"><a id="_idIndexMarker809"/></span><span class="No-Break">verify.</span></li>
<li>Submit the CSR to a CA and get a signed certificate. A CA is a trusted entity that issues and validates TLS/SSL certificates. There are self-signed, free, or paid CAs. You may need to provide more proof of your identity and domain ownership depending on the <a id="_idIndexMarker810"/>CA. Some <a id="_idIndexMarker811"/>popular CAs<a id="_idIndexMarker812"/> are <strong class="bold">Let’s Encrypt</strong>, <strong class="bold">DigiCert</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="bold">Comodo</strong></span><span class="No-Break">.</span></li>
<li>Install the certificate and the private key on your web server. The procedure may differ based on the server software and the operating system. You may also need to install intermediate certificates from the CA. Configure your web server to use HTTPS and redirect HTTP <span class="No-Break">to HTTPS.</span></li>
</ol>
<p>Often, your hosting service provider may handle the TLS/SSL certificates and configuration for you. Some providers use tools such<a id="_idIndexMarker813"/> as <strong class="bold">Certbot</strong> to get and renew certificates from Let’s Encrypt, or they use their own CA. Check with your provider to see whether they offer such options and how to <span class="No-Break">use them.</span></p>
<h2 id="_idParaDest-392"><a id="_idTextAnchor396"/>See also</h2>
<p>The GitHub repository at the following link shows you more possibilities <a id="_idIndexMarker814"/>of <strong class="source-inline">mkcert</strong>: </p>
<ul>
<li><span class="No-Break"><em class="italic">mkcert: </em></span><a href="https://github.com/FiloSottile/mkcert"><span class="No-Break">https://github.com/FiloSottile/mkcert</span></a></li>
</ul>
<p>In the FastAPI official documentation, you can<a id="_idIndexMarker815"/> have a look at HTTPS functioning on the page: </p>
<ul>
<li><em class="italic">About </em><span class="No-Break"><em class="italic">HTTPS: </em></span><a href="https://fastapi.tiangolo.com/deployment/https/"><span class="No-Break">https://fastapi.tiangolo.com/deployment/https/</span></a></li>
</ul>
<p>Instructions on how to run <strong class="source-inline">uvicorn</strong> in HTTPS mode<a id="_idIndexMarker816"/> can be found at the following link: </p>
<ul>
<li><em class="italic">Running with </em><span class="No-Break"><em class="italic">HTTPS</em></span><span class="No-Break">: </span><a href="https://www.uvicorn.org/deployment/#running-with-https"><span class="No-Break">https://www.uvicorn.org/deployment/#running-with-https</span></a></li>
</ul>
<p>You can find details on <strong class="source-inline">HTTPSRedirectMiddle</strong> on the<a id="_idIndexMarker817"/> official documentation page at <span class="No-Break">this link:</span></p>
<ul>
<li><em class="italic"> </em><span class="No-Break"><em class="italic">HTTPSRedirectMiddleware: </em></span><a href="https://fastapi.tiangolo.com/advanced/middleware/#httpsredirectmiddleware"><span class="No-Break">https://fastapi.tiangolo.com/advanced/middleware/#httpsredirectmiddleware</span></a></li>
</ul>
<h1 id="_idParaDest-393"><a id="_idTextAnchor397"/>Running FastAPI applications in Docker containers</h1>
<p><strong class="bold">Docker</strong> is a <a id="_idIndexMarker818"/>useful tool that lets developers wrap applications with their dependencies into a container. This method makes sure that the application operates reliably in different environments, avoiding the common <em class="italic">works on my machine</em> issue. In this recipe, we will see how to make a Dockerfile and run a FastAPI application inside a Docker container. By the end of this guide, you will know how to put your FastAPI application into a container, making it more flexible and simpler <span class="No-Break">to deploy.</span></p>
<h2 id="_idParaDest-394"><a id="_idTextAnchor398"/>Getting ready</h2>
<p>You will benefit from some knowledge of container technology, especially Docker, to follow the recipe better. But first, check <a id="_idIndexMarker819"/>that <strong class="bold">Docker Engine</strong> is set up properly on your machine. You can see how to do it at this <span class="No-Break">link: </span><a href="https://docs.docker.com/engine/install/"><span class="No-Break">https://docs.docker.com/engine/install/</span></a><span class="No-Break">.</span></p>
<p>If you use Windows, it is better to <a id="_idIndexMarker820"/>install <strong class="bold">Docker Desktop</strong>, which is a Docker virtual machine distribution with a built-in <span class="No-Break">graphical interface.</span></p>
<p>Whether you have Docker Engine or Docker Desktop, make sure the daemon is running by typing <span class="No-Break">this command:</span></p>
<pre class="console">
$ docker images</pre> <p>If you don’t see any error about the daemon, that means that Docker is installed and working on the machine. The way to start the Docker daemon depends on the installation you choose. Look at the related documentation to see how to <span class="No-Break">do it.</span></p>
<p>You can use the recipe for your applications or follow along with the <strong class="source-inline">Live Application</strong> application that we introduced in the first recipe, which we are using throughout <span class="No-Break">the chapter.</span></p>
<h2 id="_idParaDest-395"><a id="_idTextAnchor399"/>How to do it…</h2>
<p>It is not <a id="_idIndexMarker821"/>very complicated to run a simple FastAPI<a id="_idIndexMarker822"/> application in a Docker container. The process consists of <span class="No-Break">three steps:</span></p>
<ol>
<li>Create <span class="No-Break">the Dockerfile.</span></li>
<li>Build <span class="No-Break">the image.</span></li>
<li>Generate <span class="No-Break">the container.</span></li>
</ol>
<p>Then, you just have to run the container to have the <span class="No-Break">application working.</span></p>
<h3>Creating the Dockerfile</h3>
<p>The Dockerfile<a id="_idIndexMarker823"/> contains the instructions needed to build the image from an operating system and the file we want <span class="No-Break">to specify.</span></p>
<p>It is good practice to create a separate Dockerfile for the development environment. We will name it <strong class="source-inline">Dockerfile.dev</strong> and place it under the project <span class="No-Break">root folder.</span></p>
<p>We start the file by specifying the base image, which will be <span class="No-Break">as follows:</span></p>
<pre class="source-code">
FROM python:3.10</pre> <p>This will pull an image from the Docker Hub, which already comes with Python 3.10 integrated. Then, we create a folder called <strong class="source-inline">/code</strong> that will host <span class="No-Break">our code:</span></p>
<pre class="source-code">
WORKDIR /code</pre> <p>Next, we copy <strong class="source-inline">requirements.txt</strong> into the image and install the packages inside <span class="No-Break">the image:</span></p>
<pre class="source-code">
COPY ./requirements.txt /code/requirements.txt
RUN pip install --no-cache-dir -r /code/requirements.txt</pre> <p>The <strong class="source-inline">pip install</strong> command runs with the <strong class="source-inline">--no-cache-dir</strong> parameter to avoid <strong class="source-inline">pip</strong> caching operations that wouldn’t be beneficial inside a container. Also, in a production environment, for larger applications, it is recommended to pin fixed versions of the packages in <strong class="source-inline">requirements.txt</strong> to avoid potential compatibility issues due to <span class="No-Break">package upgrades.</span></p>
<p>Then, we can copy the <strong class="source-inline">app</strong> folder containing the application into the image with the <span class="No-Break">following command:</span></p>
<pre class="source-code">
COPY ./app /code/app</pre> <p>Finally, we define the server startup instruction <span class="No-Break">as follows:</span></p>
<pre class="source-code">
CMD ["fastapi", "run", "app/main.py", "--port", "80"]</pre> <p>This is all we<a id="_idIndexMarker824"/> need to create our <span class="No-Break"><strong class="source-inline">Dockerfile.dev</strong></span><span class="No-Break"> file.</span></p>
<h3>Building the image</h3>
<p>Once we <a id="_idIndexMarker825"/>have <strong class="source-inline">Dockerfile.dev</strong>, we can build the image. We can do it by running the following from the command line at the project root <span class="No-Break">folder level:</span></p>
<pre class="console">
$ docker build -f Dockerfile.dev -t live-application .</pre> <p>Since we named our Dockerfile <strong class="source-inline">Dockerfile.dev</strong>, we should specify it in an argument. Once the build is finished, you can check that the image has been correctly built by running <span class="No-Break">the following:</span></p>
<pre class="console">
$ docker images live-application</pre> <p>You should see the details of the image on the output print <span class="No-Break">like this:</span></p>
<pre class="console">
REPOSITORY      TAG    IMAGE ID    CREATED        SIZE
live-application latest  7ada80a535c2 43 seconds ago 1.06GB</pre> <p>With the image built, we<a id="_idIndexMarker826"/> can proceed with creating the <span class="No-Break">container creation.</span></p>
<h3>Creating the container</h3>
<p>To create the<a id="_idIndexMarker827"/> container and run it; simply run <span class="No-Break">the following:</span></p>
<pre class="console">
$ docker run -p 8000:80 live-application</pre> <p>This will create the container and run it. We can see the container by running <span class="No-Break">the following:</span></p>
<pre class="console">
$ docker ps -a</pre> <p>Since we didn’t specify a container name, it will automatically affect a fancy name. Mine, for example, <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">bold_robinson</strong></span><span class="No-Break">.</span></p>
<p>Open the browser on <strong class="source-inline">http://localhost:8000</strong> and you will see the home page response of <span class="No-Break">our application.</span></p>
<p>This is all you need to run a FastAPI application inside a Docker container. Running a FastAPI application in a Docker container is a great way to use the advantages of both technologies. You can easily scale, update, and deploy your web app with <span class="No-Break">minimal configuration.</span></p>
<h2 id="_idParaDest-396"><a id="_idTextAnchor400"/>See also</h2>
<p>The Dockerfile <a id="_idIndexMarker828"/>can be used to specify several features of the image. Check the list of commands in the official documentation: </p>
<ul>
<li><em class="italic">Dockerfile </em><span class="No-Break"><em class="italic">reference</em></span><span class="No-Break">: </span><a href="https://docs.docker.com/reference/dockerfile/"><span class="No-Break">https://docs.docker.com/reference/dockerfile/</span></a></li>
</ul>
<p>Also, you can have a look at the Docker CLI documentation<a id="_idIndexMarker829"/> on the following page: </p>
<ul>
<li><span class="No-Break"><em class="italic">Docker: </em></span><a href="https://docs.docker.com/reference/cli/docker/"><span class="No-Break">https://docs.docker.com/reference/cli/docker/</span></a></li>
</ul>
<p>You can have a look at the FastAPI documentation page<a id="_idIndexMarker830"/> dedicated to the integration with Docker at this link: </p>
<ul>
<li><em class="italic">FastAPI in Containers - Docker: </em><a href="https://fastapi.tiangolo.com/deployment/docker/">https://fastapi.tiangolo.com/deployment/docker/</a> </li>
</ul>
<h1 id="_idParaDest-397"><a id="_idTextAnchor401"/>Running the server across multiple workers</h1>
<p>In high-traffic<a id="_idIndexMarker831"/> environments, running a FastAPI application with a single worker may not be sufficient to handle all incoming requests efficiently. To improve performance and ensure better resource use, you can run your FastAPI instance across multiple workers. This can be achieved using tools such<a id="_idIndexMarker832"/> <span class="No-Break">as </span><span class="No-Break"><strong class="bold">Gunicorn</strong></span><span class="No-Break">.</span></p>
<p>In this recipe, we will explore how to run a FastAPI application with multiple workers using Gunicorn in a Docker container, and we will also discuss Uvicorn’s ability to handle multiple workers along with <span class="No-Break">its limitations.</span></p>
<h2 id="_idParaDest-398"><a id="_idTextAnchor402"/>Getting ready</h2>
<p>The <strong class="source-inline">gunicorn</strong> package is not Windows compatible. To ensure operating system operability, we will run our <strong class="source-inline">Live Application</strong> in a <span class="No-Break">Docker container.</span></p>
<p>The recipe will be based on the project created in the previous recipe, <em class="italic">Running FastAPI applications in </em><span class="No-Break"><em class="italic">Docker containers</em></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-399"><a id="_idTextAnchor403"/>How to do it…</h2>
<p>FastAPI with multiple workers runs multiple copies of the app on different <span class="No-Break">CPU processes.</span></p>
<p>To see this better, let’s make the endpoint show <a id="_idIndexMarker833"/>the <strong class="bold">process ID</strong> (<strong class="bold">PID</strong>) number of the process. In <strong class="source-inline">main.py</strong>, add <span class="No-Break">these lines:</span></p>
<pre class="source-code">
<strong class="bold">import logging</strong>
<strong class="bold">from os import getpid</strong>
# rest of the module
<strong class="bold">logger = logging.getLogger("uvicorn")</strong>
# rest of the module
@app.get("/")
def read_root():
<strong class="bold">    logger.info(f"Processd by worker {getpid()}")</strong>
    return {"Hello": "World"}</pre> <p>Let’s add<a id="_idIndexMarker834"/> the <strong class="source-inline">gunicorn</strong> dependency in the <strong class="source-inline">requirements.txt</strong> file <span class="No-Break">as follows:</span></p>
<pre class="source-code">
fastapi
<strong class="bold">gunicorn</strong></pre> <p>We will use <strong class="source-inline">gunicorn</strong> instead of <strong class="source-inline">uvicorn</strong> to run <span class="No-Break">the server.</span></p>
<p>If you are on Linux or macOS, you simply install <strong class="source-inline">gunicorn</strong> in your environment <span class="No-Break">like this:</span></p>
<pre class="console">
$ pip install gunicorn</pre> <p>Then, run the server with four workers with the <span class="No-Break">following command:</span></p>
<pre class="console">
$ gunicorn app.main:app --workers 4 \
--worker-class uvicorn.workers.UvicornWorker</pre> <p>If you are on Windows, we will use Docker. In the <strong class="source-inline">Dockerfile.dev</strong> file, add the new <strong class="source-inline">CMD</strong> instruction below the existing one, which will <span class="No-Break">be ignored:</span></p>
<pre class="source-code">
CMD ["gunicorn",\
    "app.main:app",\
    "--bind", "0.0.0.0:80",\
    "--workers", "4",\
    "--worker-class",\
    "uvicorn.workers.UvicornWorker",\
    "--log-level", "debug"]</pre> <p>Then, build the Docker image with <span class="No-Break">the following:</span></p>
<pre class="console">
$ docker build -t live-application-gunicorn \
-f Dockerfile.dev .</pre> <p>Next, run the container from <span class="No-Break">the image:</span></p>
<pre class="console">
$ docker run -p 8000:80 -i live-application-gunicorn</pre> <p>The <strong class="source-inline">-i</strong> parameter allows you to run the container in interactive mode to see <span class="No-Break">the logs.</span></p>
<p>After the server is running, open the browser on <strong class="source-inline">http://localhost:8000/docs</strong> and use the interactive documentation to make calls. On the terminal output, you will notice different PIDs that vary for <span class="No-Break">each call.</span></p>
<p>This shows <a id="_idIndexMarker835"/>that Gunicorn can distribute the load among different processes, and you can take advantage of multiple <span class="No-Break">CPU cores.</span></p>
<p>You have learned how to run a FastAPI app with Gunicorn and multiple workers, which can improve the performance and scalability of your web service. You can experiment with different settings and options to find the optimal configuration for <span class="No-Break">your needs.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">You can run multiple workers with Uvicorn as well. However, Uvicorn’s worker process management is not as advanced as Gunicorn’s at <span class="No-Break">the moment.</span></p>
<h2 id="_idParaDest-400"><a id="_idTextAnchor404"/>There’s more…</h2>
<p>One of the benefits of running Gunicorn<a id="_idIndexMarker836"/> with multiple workers is that it can handle more concurrent requests and improve the performance and availability of the web application. However, there are also some challenges and trade-offs that come with <span class="No-Break">this approach.</span></p>
<p>For example, when using multiple workers, each worker process has its own memory space and cannot share data with other workers. This means that any stateful components of the application, such as caches or sessions, need to be stored in a centralized or distributed service, such as Redis or Memcached. Moreover, multiple workers may increase resource consumption and the risk of contention on the server machine, especially if the application is CPU-intensive or input/output-bound. Therefore, it is important to choose the optimal number of workers based on the characteristics of the application and the <span class="No-Break">available resources.</span></p>
<p>A common heuristic is to use the formula <em class="italic">workers = (2 x cores) + 1</em>, where <em class="italic">cores</em> means the number of CPU cores on the server. However, this may not be suitable for all scenarios and may require some experimentation <span class="No-Break">and fine-tuning.</span></p>
<h2 id="_idParaDest-401"><a id="_idTextAnchor405"/>See also</h2>
<p>You can discover more about<a id="_idIndexMarker837"/> Gunicorn in the official documentation at this link: </p>
<ul>
<li><span class="No-Break"><em class="italic">gunicorn: </em></span><a href="https://gunicorn.org/"><span class="No-Break">https://gunicorn.org/</span></a></li>
</ul>
<p>Also, you can have a look at the page in the FastAPI documentation<a id="_idIndexMarker838"/> dedicated to <span class="No-Break">server workers:</span></p>
<ul>
<li><em class="italic"> Server Workers – Gunicorn with </em><span class="No-Break"><em class="italic">Uvicorn: </em></span><a href="https://fastapi.tiangolo.com/deployment/server-workers/"><span class="No-Break">https://fastapi.tiangolo.com/deployment/server-workers/</span></a></li>
</ul>
<h1 id="_idParaDest-402"><a id="_idTextAnchor406"/>Deploying your FastAPI application on the cloud</h1>
<p>Deploying your FastAPI application on the cloud is an essential step to make it accessible to users worldwide. In this recipe, we will demonstrate how to deploy a FastAPI application <span class="No-Break">on </span><span class="No-Break">Railway.</span></p>
<p>Railway is a<a id="_idIndexMarker839"/> versatile and user-friendly platform that enables developers to deploy, manage, and scale their applications with ease. By the end of the recipe, you will have a FastAPI application running on Railway, ready to serve users on <span class="No-Break">the internet.</span></p>
<h2 id="_idParaDest-403"><a id="_idTextAnchor407"/>Getting started</h2>
<p>Before we begin, ensure that you have already set up an application, as we will be deploying it on the cloud. The recipe will be applied to our <strong class="source-inline">Live Application</strong>, the basic application created in the <em class="italic">Running the server with the FastAPI </em><span class="No-Break"><em class="italic">CLI</em></span><span class="No-Break"> recipe.</span></p>
<p>Also, put the project folder on GitHub, since it will be used as a reference for <span class="No-Break">the deployment.</span></p>
<p>You will also need to set up an <a id="_idIndexMarker840"/>account at <a href="https://railway.app">https://railway.app</a>. The creation is straightforward, and you can use your GitHub account as well. When you sign up, you will receive a $5 credit, which is more than enough to cover <span class="No-Break">the recipe.</span></p>
<h2 id="_idParaDest-404"><a id="_idTextAnchor408"/>How to do it…</h2>
<p>We will demonstrate how to deploy the application on Railway through the <span class="No-Break">following steps:</span></p>
<ol>
<li>Create the <span class="No-Break">configuration file.</span></li>
<li>Connect the <span class="No-Break">Git repository.</span></li>
<li>Configure <span class="No-Break">the deployment.</span><p class="list-inset">Although we will demonstrate it specifically for Railway, these steps are also common for other <span class="No-Break">cloud services.</span></p></li>
</ol>
<h3>Creating the configuration file</h3>
<p>Every deployment tool requires a <a id="_idIndexMarker841"/>configuration file that contains specifications for the deployment. To deploy on Railway, under our project root folder, let’s create a file called <strong class="source-inline">Procfile</strong>. The file content will be <span class="No-Break">as follows:</span></p>
<pre class="source-code">
web: fastapi run --port $PORT</pre> <p>Remember to push the file to the GitHub repository hosting your project to be visible <span class="No-Break">to Railway.</span></p>
<h3>Connecting the Git repository</h3>
<p>Once the<a id="_idIndexMarker842"/> configuration file is set up, log in to Railway (<a href="https://railway.app/login">https://railway.app/login</a>) with your account and you will be redirected to your <span class="No-Break">dashboard (</span><a href="https://railway.app/dashboard"><span class="No-Break">https://railway.app/dashboard</span></a><span class="No-Break">).</span></p>
<p>Then, click on the <strong class="bold">+ New Project</strong> button at the top right of the screen. Once on the new page, choose the <strong class="bold">Deploy from Github repo</strong> option and select the repository that hosts your project. If you forked the <strong class="source-inline">FastAPI-Cookbook</strong> repository (<a href="https://github.com/PacktPublishing/FastAPI-Cookbook">https://github.com/PacktPublishing/FastAPI-Cookbook</a>), you can <span class="No-Break">select it.</span></p>
<p>Then select <strong class="bold">Deploy now</strong> and wait for the deployment to set up. It will automatically create a new project with a fictional name. Mine, for example, <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">profound-enchantment</strong></span><span class="No-Break">.</span></p>
<p>Once finished, the <em class="italic">deployment</em> icon will appear on the project dashboard. By default, the deployment takes the name of the chosen GitHub repository. In my case, <span class="No-Break">it’s </span><span class="No-Break"><strong class="source-inline">FastAPI-Cookbook</strong></span><span class="No-Break">.</span></p>
<h3>Configuring the deployment</h3>
<p>When you click on the <em class="italic">deployment</em> icon, you<a id="_idIndexMarker843"/> can see a warning indicating that the deployment has failed. To resolve this, we need to add <span class="No-Break">some parameters.</span></p>
<p>Click on the <em class="italic">deployment</em> icon, which will open a window on the left. Then, click on the <strong class="bold">Settings</strong> tab. This will display a list of configurations with sections such as <strong class="bold">Source</strong>, <strong class="bold">Networking</strong>, <strong class="bold">Build</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="bold">Deploy</strong></span><span class="No-Break">.</span></p>
<p>Begin with the <strong class="bold">Source</strong> section. If you’ve chosen the project from the <strong class="source-inline">FastAPI-Cookbook</strong> repository or if your project’s root directory is not the repository root, click on <strong class="bold">Add Root Directory</strong> under the <strong class="bold">Source</strong> repository specification and enter <span class="No-Break">the path.</span></p>
<p>For the <strong class="source-inline">FastAPI-Cookbook</strong> repository, the path will be <strong class="source-inline">/Chapter12/live_application</strong>. After adding the path, click on the <span class="No-Break"><em class="italic">save</em></span><span class="No-Break"> icon.</span></p>
<p>Leave the branch selected <span class="No-Break">as </span><span class="No-Break"><strong class="bold">main</strong></span><span class="No-Break">.</span></p>
<p>Moving on to the <strong class="bold">Networking</strong> section, click on the <strong class="bold">Generate Domain</strong> button under the <strong class="bold">Public Network</strong> subsection. This will create a unique domain for exposing your application. Mine is <strong class="source-inline">fastapi-cookbook-production.up.railway.app</strong>. You will have a slightly <span class="No-Break">different domain.</span></p>
<p>Leave the remaining settings as <span class="No-Break">they are.</span></p>
<p>At the top left of the screen, you will see a text bar with the text <strong class="bold">Apply 2 changes</strong> with a <strong class="bold">Deploy</strong> button. Click on it to apply the modification we <span class="No-Break">have done.</span></p>
<p>After the deployment process is complete, your application will begin to handle live web traffic. The public address is defined in the <strong class="bold">Networking</strong> section of the <span class="No-Break"><strong class="bold">Settings</strong></span><span class="No-Break"> panel.</span></p>
<p>Open the address in a new browser tab, and check the response. You should see the <span class="No-Break">implemented response:</span></p>
<pre class="source-code">
{
    "Hello": "World"
}</pre> <p>In your web browser’s address bar, you can see a <em class="italic">lock</em> icon, which indicates that the connection is secure and has a certificate. Usually, when you expose your service to the web, the hosting <a id="_idIndexMarker844"/>platform provides you <span class="No-Break">with certificates.</span></p>
<p>You have just deployed your FastAPI application to be accessible on the World Wide Web. Now, users from all over the world can access <span class="No-Break">your service.</span></p>
<h2 id="_idParaDest-405"><a id="_idTextAnchor409"/>There’s more…</h2>
<p>To deploy your service, Railway creates an image and then a container to run your service. You can specify a custom image with a Dockerfile and it will be <span class="No-Break">automatically detected.</span></p>
<h2 id="_idParaDest-406"><a id="_idTextAnchor410"/>See also</h2>
<p>You can discover more about Railway services<a id="_idIndexMarker845"/> on the official documentation website: </p>
<ul>
<li><em class="italic">Railway </em><span class="No-Break"><em class="italic">Docs: </em></span><a href="https://docs.railway.app/"><span class="No-Break">https://docs.railway.app/</span></a></li>
</ul>
<p>You can check the official FastAPI template<a id="_idIndexMarker846"/> used for Railway at this link: </p>
<ul>
<li><em class="italic">FastAPI </em><span class="No-Break"><em class="italic">Example: </em></span><a href="https://github.com/railwayapp-templates/fastapi"><span class="No-Break">https://github.com/railwayapp-templates/fastapi</span></a></li>
</ul>
<p>FastAPI is one of the fastest-growing production applications, especially on the major public cloud service providers. That’s why you can find extensive documentation on how to <span class="No-Break">use it:</span></p>
<p>For <strong class="bold">Google Cloud Platform</strong> (<strong class="bold">GCP</strong>), you<a id="_idIndexMarker847"/> can follow the article at the link: </p>
<ul>
<li><em class="italic">Deploying FastAPI app with Google Cloud Run</em> article at the following <span class="No-Break">link: </span><a href="https://dev.to/0xnari/deploying-fastapi-app-with-google-cloud-run-13f3"><span class="No-Break">https://dev.to/0xnari/deploying-fastapi-app-with-google-cloud-run-13f3</span></a></li>
</ul>
<p>For <strong class="bold">Amazon Web Services</strong> (<strong class="bold">AWS</strong>), check this <a id="_idIndexMarker848"/><span class="No-Break">Medium article:</span></p>
<ul>
<li><em class="italic">Deploy FastAPI on AWS </em><span class="No-Break"><em class="italic">EC2</em></span><span class="No-Break">: </span><a href="https://medium.com/@shreyash966977/deploy-fastapi-on-aws-ec2-quick-and-easy-steps-954d4a1e4742"><span class="No-Break">https://medium.com/@shreyash966977/deploy-fastapi-on-aws-ec2-quick-and-easy-steps-954d4a1e4742</span></a></li>
</ul>
<p>For Microsoft Azure, you can check the official <span class="No-Break">documentation page:</span></p>
<ul>
<li><em class="italic">Using FastAPI Framework with Azure </em><span class="No-Break"><em class="italic">Functions</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/samples/azure-samples/fastapi-on-azure-functions/fastapi-on-azure-functions/"><span class="No-Break">https://learn.microsoft.com/en-us/samples/azure-samples/fastapi-on-azure-functions/fastapi-on-azure-functions/</span></a></li>
</ul>
<p>On the FastAPI website, you can check other examples for other cloud providers at the <span class="No-Break">following link:</span></p>
<ul>
<li><em class="italic">Deploy FastAPI on Cloud </em><span class="No-Break"><em class="italic">Providers</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/deployment/cloud/"><span class="No-Break">https://fastapi.tiangolo.com/deployment/cloud/</span></a></li>
</ul>
<p>A useful tool is the Porter platform, which<a id="_idIndexMarker849"/> allows you to deploy your applications on different cloud services such as AWS, GCP, and Azure from one centralized platform. Have a look at <span class="No-Break">this link:</span></p>
<ul>
<li><em class="italic">Deploy a FastAPI </em><span class="No-Break"><em class="italic">app: </em></span><a href="https://docs.porter.run/guides/fastapi/deploy-fastapi"><span class="No-Break">https://docs.porter.run/guides/fastapi/deploy-fastapi</span></a></li>
</ul>
<h1 id="_idParaDest-407"><a id="_idTextAnchor411"/>Shipping FastAPI applications with Hatch</h1>
<p>Packaging and shipping a FastAPI application as a distributable package are essential for deploying and sharing your <span class="No-Break">application efficiently.</span></p>
<p><strong class="bold">Hatch</strong> is a <a id="_idIndexMarker850"/>modern Python project management tool that simplifies the packaging, versioning, and distribution process. In this recipe, we’ll explore how to use Hatch to build and ship a package containing a FastAPI application. This will ensure that your application is portable, easy to install, and maintainable, making it easier to deploy and share <span class="No-Break">with others.</span></p>
<h2 id="_idParaDest-408"><a id="_idTextAnchor412"/>Getting ready</h2>
<p>Hatch <a id="_idIndexMarker851"/>facilitates the use of multiple virtual environments<a id="_idIndexMarker852"/> for our project. It uses the <strong class="source-inline">venv</strong> package<a id="_idIndexMarker853"/> under <span class="No-Break">the hood.</span></p>
<p>To run the recipe, you need to install Hatch on your local machine. The installation process may vary depending on your operating system. Detailed instructions can be found on the official documentation <span class="No-Break">page: </span><a href="https://hatch.pypa.io/1.9/install/"><span class="No-Break">https://hatch.pypa.io/1.9/install/</span></a><span class="No-Break">.</span></p>
<p>Once the installation is complete, verify that it has been correctly installed by running the following from the <span class="No-Break">command-line terminal:</span></p>
<pre class="console">
$ hatch --version</pre> <p>You should have the version printed on the output <span class="No-Break">like this:</span></p>
<pre class="console">
Hatch, version 1.11.1</pre> <p>Make sure that you installed a version higher than <strong class="source-inline">1.11.1</strong>. We can then start creating <span class="No-Break">our package.</span></p>
<h2 id="_idParaDest-409"><a id="_idTextAnchor413"/>How to do it…</h2>
<p>We divide the process of shipping our FastAPI package into <span class="No-Break">five steps:</span></p>
<ol>
<li>Initialize <span class="No-Break">the project.</span></li>
<li><span class="No-Break">Install dependencies.</span></li>
<li>Create <span class="No-Break">the app.</span></li>
<li>Build <span class="No-Break">the distribution.</span></li>
<li>Test <span class="No-Break">the package.</span></li>
</ol>
<p>Let’s start building <span class="No-Break">our package.</span></p>
<h3>Initializing the project</h3>
<p>We start by <a id="_idIndexMarker854"/>creating our project by bootstrapping the structure. Let’s call our application <strong class="source-inline">FCA</strong>, which stands<a id="_idIndexMarker855"/> for <strong class="bold">FastAPI Cookbook Application</strong>. Let’s bootstrap our <a id="_idIndexMarker856"/>project by running the <span class="No-Break">following command:</span></p>
<pre class="console">
$ hatch new "FCA Server"</pre> <p>The command will create a project bootstrap under the <strong class="source-inline">fca-server</strong> folder <span class="No-Break">as follows:</span></p>
<pre class="console">
fca-server
├──src
│  └── fca_server
│      ├── __about__.py
│      └── __init__.py
├──tests
│  └── __init__.py
├──LICENSE.txt
├──README.md
└──pyproject.tomt</pre> <p>We can then directly use a virtual environment by entering the <strong class="source-inline">fca-server</strong> directory and running <span class="No-Break">the following:</span></p>
<pre class="console">
$ hatch shell</pre> <p>The command will automatically create a default virtual environment and activate it. You will see your command-line terminal with a prepend value, <strong class="source-inline">(fca-server)</strong>, <span class="No-Break">like so:</span></p>
<pre class="console">
(fca-server) path/to/fca-server $</pre> <p>Verify that the environment is correctly activated by checking the Python executable. You do it by running <span class="No-Break">the following:</span></p>
<pre class="console">
$ python -c "import sys; print(sys.executable)"</pre> <p>The executable should come from the virtual environment called <strong class="source-inline">fca-server</strong>, which will present a path such as <strong class="source-inline">&lt;virtual </strong><span class="No-Break"><strong class="source-inline">environment locations&gt;\fca-server\Scripts\python</strong></span><span class="No-Break">.</span></p>
<p>This will give you information on the virtual environment that you can also provide to your <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>) to <a id="_idIndexMarker857"/>work with <span class="No-Break">the code.</span></p>
<p>You can <a id="_idIndexMarker858"/>exit from the shell by typing <strong class="source-inline">exit</strong> in the terminal. Also, you can run commands in the virtual environment without spawning the shell. For example, you can check the Python executable of the default environment by running <span class="No-Break">the following:</span></p>
<pre class="console">
$ hatch run python -c "import sys; print(sys.executable)"</pre> <p>We can now proceed to install the package dependencies in <span class="No-Break">our environment.</span></p>
<h3>Installing dependencies</h3>
<p>Now that you <a id="_idIndexMarker859"/>have created a virtual<a id="_idIndexMarker860"/> environment, let’s add the <strong class="source-inline">fastapi</strong> dependency to our project. We can do it by modifying the <strong class="source-inline">pyproject.toml</strong> file. Add it in the <strong class="source-inline">dependencies</strong> field under the <strong class="source-inline">[project]</strong> section <span class="No-Break">like so:</span></p>
<pre class="source-code">
[project]
...
dependencies = [
  "fastapi"
]</pre> <p>Next time you spawn a shell, the dependencies will synchronized and the <strong class="source-inline">fastapi</strong> package will <span class="No-Break">be installed.</span></p>
<p>Let’s see, for example, whether the <strong class="source-inline">fastapi</strong> command works by running <span class="No-Break">the following:</span></p>
<pre class="console">
$ hatch run fastapi --help</pre> <p>If you see the help documentation of the command, the dependency has been <span class="No-Break">added correctly.</span></p>
<h3>Creating the app</h3>
<p>Now <a id="_idIndexMarker861"/>that we have the environment with the <strong class="source-inline">fastapi</strong> package installed, we can develop <span class="No-Break">our application.</span></p>
<p>Let’s create the <strong class="source-inline">main.py</strong> module <a id="_idIndexMarker862"/>under the <strong class="source-inline">src/fca_server</strong> folder and initialize the <strong class="source-inline">APIRouter</strong> object with one endpoint <span class="No-Break">like this:</span></p>
<pre class="source-code">
from fastapi import APIRouter
app = APIRouter()
@app.get("/")
def read_root():
    return {
        "message":
        "Welcome to the FastAPI Cookbook Application!"
    }</pre> <p>Then, let’s import the router into the <strong class="source-inline">src/fca_server.__init__.py</strong> file <span class="No-Break">as follows:</span></p>
<pre class="source-code">
from fca_server.main import router</pre> <p>This will allow us to directly import the router from the <strong class="source-inline">fca_server</strong> package from an <span class="No-Break">external project.</span></p>
<h3>Building the distribution</h3>
<p>Now that <a id="_idIndexMarker863"/>we have finalized the package, let’s leverage Hatch to build the <span class="No-Break">package distribution.</span></p>
<p>We will generate the package in the form of a <strong class="source-inline">.tar.gz</strong> file by running <span class="No-Break">the following:</span></p>
<pre class="console">
$ hatch build -t sdist ../dist</pre> <p>It will generate the <strong class="source-inline">fca_server-0.0.1.tar.gz</strong> file placed outside of the project in a <strong class="source-inline">dist</strong> folder. We<a id="_idIndexMarker864"/> will then use the file <a id="_idIndexMarker865"/>in an <span class="No-Break">external project.</span></p>
<h3>Testing the package</h3>
<p>Next, we<a id="_idIndexMarker866"/> will make a different project that uses the <strong class="source-inline">fca_server</strong> package <span class="No-Break">we made.</span></p>
<p>Create an <strong class="source-inline">import-fca-server</strong> folder outside of the <strong class="source-inline">fca-server</strong> folder for the package and use it as the project <span class="No-Break">root folder.</span></p>
<p>In the folder, make a local virtual environment with <strong class="source-inline">venv</strong> by running <span class="No-Break">the following:</span></p>
<pre class="console">
$ python -m venv .venv</pre> <p>Activate the environment. On Linux or macOS, type <span class="No-Break">the following:</span></p>
<pre class="console">
$ source .venv/Scripts/activate</pre> <p>On Windows, type <span class="No-Break">this instead:</span></p>
<pre class="console">
$ .venv\Scripts\activate</pre> <p>Install the <strong class="source-inline">fca_server</strong> package <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">pip</strong></span><span class="No-Break">:</span></p>
<pre class="console">
$ pip install ..\dist\fca_server-0.0.1.tar.gz</pre> <p>Use the path where the <strong class="source-inline">fca_server-0.0.1.tar.gz</strong> <span class="No-Break">file is.</span></p>
<p>Now, try to import <span class="No-Break">the package.</span></p>
<p>Make a <strong class="source-inline">main.py</strong> file and import the router from the <span class="No-Break"><strong class="source-inline">fca_server</strong></span><span class="No-Break"> package:</span></p>
<pre class="source-code">
from fastapi import FastAPI
from fca_server import router
app = FastAPI(
    title="Import FCA Server Application"
)
app.include_router(router)</pre> <p>Run the server from the <span class="No-Break">command line:</span></p>
<pre class="console">
$ fastapi run</pre> <p>Go to the interactive documentation at <strong class="source-inline">http://localhost:8000/docs</strong> and see the endpoint in the external package. You have just created a custom package and imported it into <span class="No-Break">another project.</span></p>
<p>You have learned how to use Hatch to create and manage your Python projects with ease. This is a powerful tool that can save you time and effort and help you write better code. Now, you <a id="_idIndexMarker867"/>can experiment with different <a id="_idIndexMarker868"/>options and features of Hatch and see what else you can do <span class="No-Break">with it.</span></p>
<h2 id="_idParaDest-410"><a id="_idTextAnchor414"/>There’s more…</h2>
<p>Hatch<a id="_idIndexMarker869"/> is a versatile packaging system for Python that allows you to create scripts and multiple environments for <span class="No-Break">your projects.</span></p>
<p>With Hatch, you can also customize the location of the virtual environment files, such as whether you want them to be centralized or in the project folder. You can specify this option in the <strong class="source-inline">config.toml</strong> file, which <a id="_idIndexMarker870"/>contains the configuration settings <span class="No-Break">for Hatch.</span></p>
<p>To find the location of the <strong class="source-inline">config.toml</strong> file, you can run the following command in <span class="No-Break">your terminal:</span></p>
<pre class="console">
$ hatch config find</pre> <p>Hatch also lets you create the build of your package in a wheel format, which is a binary distribution format that is more efficient and compatible than the traditional <span class="No-Break">source distribution.</span></p>
<p>Moreover, you can publish your package directly to the <strong class="bold">Python Package Index </strong>(<strong class="bold">PyPI</strong>), where other users <a id="_idIndexMarker871"/>can find and install it. Hatch makes it easy to share your code with <span class="No-Break">the world.</span></p>
<h2 id="_idParaDest-411"><a id="_idTextAnchor415"/>See also</h2>
<p>You can find more information about Hatch<a id="_idIndexMarker872"/> in the official documentation at </p>
<ul>
<li><span class="No-Break"><em class="italic">Hatch</em></span><span class="No-Break">: </span><a href="https://hatch.pypa.io/latest/"><span class="No-Break">https://hatch.pypa.io/latest/</span></a></li>
</ul>
<p>We learned how to create a project bootstrap, but with Hatch, you can also initialize an existing project. Check out the documentation page: </p>
<ul>
<li><em class="italic">Existing project: </em>https://hatch.pypa.io/1.9/intro/#existing-project </li>
</ul>
<p>One of the greatest advantages of using Hatch is the flexibility of running the project for several virtual environments. Check more on the documentation page: </p>
<ul>
<li><span class="No-Break"><em class="italic">Environments: </em></span><a href="https://hatch.pypa.io/1.9/environment/"><span class="No-Break">https://hatch.pypa.io/1.9/environment/</span></a></li>
</ul>
<p>The <strong class="source-inline">pyproject.toml</strong> file<a id="_idIndexMarker873"/> is a configuration file for Python projects, introduced in <strong class="source-inline">PEP 518</strong> (<a href="https://peps.python.org/pep-0518/">https://peps.python.org/pep-0518/</a>). It aims to standardize and simplify the configuration of Python projects by providing a single place to specify build system requirements and other project metadata. It is used by other build tools. You can have a look at the Python Package User Guide page at the following link: </p>
<ul>
<li><em class="italic">Writing your </em><span class="No-Break"><em class="italic">pyproject.toml: </em></span><a href="https://packaging.python.org/en/latest/guides/writing-pyproject-toml/"><span class="No-Break">https://packaging.python.org/en/latest/guides/writing-pyproject-toml/</span></a></li>
</ul>
<p>You can see more on how to manage Python dependencies on this page: </p>
<ul>
<li><em class="italic">Dependency </em><span class="No-Break"><em class="italic">configuration: </em></span><a href="https://hatch.pypa.io/dev/config/dependency/"><span class="No-Break">https://hatch.pypa.io/dev/config/dependency/</span></a></li>
</ul>
</div>
</div></body></html>