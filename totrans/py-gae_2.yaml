- en: Chapter 2. A More Complex Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web applications commonly provide a set of features such as user authentication
    and data storage. As we know from the previous chapter, App Engine provides the
    services and tools needed to implement such features and the best way to learn
    how to use them is by writing a web application and seeing the platform in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Further details of the webapp2 framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to authenticate users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing data on Google Cloud Datastore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building HTML pages using templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving static files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experimenting on the Notes application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To better explore App Engine and Cloud Platform capabilities, we need a real-world
    application to experiment on; something that's not trivial to write, with a reasonable
    list of requirements so that it can fit in this book. A good candidate is a note-taking
    application; we will name it Notes.
  prefs: []
  type: TYPE_NORMAL
- en: Notes enable the users to add, remove, and modify a list of notes; a note has
    a title and a body of text. Users can only see their personal notes, so they must
    authenticate before using the application.
  prefs: []
  type: TYPE_NORMAL
- en: The main page of the application will show the list of notes for logged-in users
    and a form to add new ones.
  prefs: []
  type: TYPE_NORMAL
- en: The code from the `helloworld` example in the previous chapter is a good starting
    point. We can simply change the name of the root folder and the `application`
    field in the `app.yaml` file to match the new name we chose for the application,
    or we can start a new project from scratch named `notes`.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first requirement for our Notes application is showing the home page only
    to users who are logged in and redirect others to the login form; the **users**
    service provided by App Engine is exactly what we need and adding it to our `MainHandler`
    class is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `user` package we import on the second line of the previous code provides
    access to users' service functionalities. Inside the `get()` method of the `MainHandler`
    class, we first check whether the user visiting the page has logged in or not.
    If they have, the `get_current_user()` method returns an instance of the `user`
    class provided by App Engine and representing an authenticated user; otherwise,
    it returns `None` as output. If the user is valid, we provide the response as
    we did before; otherwise, we redirect them to the Google login form. The URL of
    the login form is returned using the `create_login_url()` method, and we call
    it, passing as a parameter the URL we want to redirect users to after a successful
    authentication. In this case, we want to redirect users to the same URL they are
    visiting, provided by webapp2 in the `self.request.uri` property. The webapp2
    framework also provides handlers with a `redirect()` method we can use to conveniently
    set the right status and location properties of the response object so that the
    client browsers will be redirected to the login page.
  prefs: []
  type: TYPE_NORMAL
- en: HTML templates with Jinja2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Web applications provide rich and complex HTML user interfaces, and Notes is
    no exception but, so far, response objects in our applications contained just
    small pieces of text. We could include HTML tags as strings in our Python modules
    and write them in the response body but we can imagine how easily it could become
    messy and hard to maintain the code. We need to completely separate the Python
    code from HTML pages and that''s exactly what a template engine does. A template
    is a piece of HTML code living in its own file and possibly containing additional,
    special tags; with the help of a template engine, from the Python script, we can
    load this file, properly parse special tags, if any, and return valid HTML code
    in the response body. App Engine includes in the Python runtime a well-known template
    engine: the Jinja2 library.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the Jinja2 library available to our application, we need to add this
    code to the `app.yaml` file under the `libraries` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can put the HTML code for the main page in a file called `main.html` inside
    the application root. We start with a very simple page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Most of the content is static, which means that it will be rendered as standard
    HTML as we see it but there is a part that is dynamic and whose content depend
    on which data will be passed at runtime to the rendering process. This data is
    commonly referred to as **template context**.
  prefs: []
  type: TYPE_NORMAL
- en: What has to be dynamic is the username of the current user and the link used
    to log out from the application. The HTML code contains two special elements written
    in the Jinja2 template syntax, `{{user}}` and `{{logout_url}}`, that will be substituted
    before the final output occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the Python script; we need to add the code to initialize the template
    engine before the `MainHandler` class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The environment instance stores engine configuration and global objects, and
    it's used to load templates instances; in our case, instances are loaded from
    HTML files on the filesystem in the same directory as the Python script.
  prefs: []
  type: TYPE_NORMAL
- en: 'To load and render our template, we add the following code to the `MainHandler.get()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Similar to how we get the login URL, the `create_logout_url()` method provided
    by the user service returns the absolute URI to the logout procedure that we assign
    to the `logout_url` variable.
  prefs: []
  type: TYPE_NORMAL
- en: We then create the `template_context` dictionary that contains the context values
    we want to pass to the template engine for the rendering process. We assign the
    nickname of the current user to the `user` key in the dictionary and the logout
    URL string to the `logout_url` key.
  prefs: []
  type: TYPE_NORMAL
- en: The `get_template()` method from the `jinja_env` instance takes the name of
    the file that contains the HTML code and returns a Jinja2 template object. To
    obtain the final output, we call the `render()` method on the `template` object
    passing in the `template_context` dictionary whose values will be accessed, specifying
    their respective keys in the HTML file with the template syntax elements `{{user}}`
    and `{{logout_url}}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the result of the template rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HTML templates with Jinja2](img/8194OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Handling forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main page of the application is supposed to list all the notes that belong
    to the current user but there isn't any way to create such notes at the moment.
    We need to display a web form on the main page so that users can submit details
    and create a note.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display a form to collect data and create notes, we put the following HTML
    code right below the username and the logout link in the `main.html` template
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Before showing the form, a message is displayed only when the template context
    contains a variable named `note_title`. To do this, we use an `if` statement,
    executed between the `{% if note_title %}` and `{% endif %}` delimiters; similar
    delimiters are used to perform `for` loops or assign values inside a template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `action` property of the `form` tag is empty; this means that upon form
    submission, the browser will perform a `POST` request to the same URL, which in
    this case is the home page URL. As our WSGI application maps the home page to
    the `MainHandler` class, we need to add a method to this class so that it can
    handle `POST` requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When the form is submitted, the handler is invoked and the `post()` method
    is called. We first check whether a valid user is logged in; if not, we raise
    an **HTTP 401: Unauthorized** error without serving any content in the response
    body. Since the HTML template is the same served by the `get()` method, we still
    need to add the logout URL and the user name to the context. In this case, we
    also store the data coming from the HTML form in the context. To access the form
    data, we call the `get()` method on the `self.request` object. The last three
    lines are boilerplate code to load and render the home page template. We can move
    this code in a separate method to avoid duplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the handler class, we will then use something like this to output the template
    rendering result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can try to submit the form and check whether the note title and content are
    actually displayed above the form.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting data in Datastore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if users can log in and submit a note, our application isn't very useful
    until notes are stored somewhere. Google Cloud Datastore is the perfect place
    to store our notes. As part of App Engine's infrastructure, it takes care of data
    distribution and replication, so all we have to do is define store and retrieve
    our entities using the Python **NDB** (**Next DB**) **Datastore API**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are currently two APIs available in the Python runtime to interact with
    Datastore: the **DB Datastore API**, also known as `ext.db`, and the NDB Datastore
    API. Even if both the APIs store exactly the same data in Datastore, in this book,
    we will only use NDB; it is more recent, provides more features, and its API is
    slightly more robust.'
  prefs: []
  type: TYPE_NORMAL
- en: An entity has one or more properties that in turn have a name and a type; each
    entity has a unique key that identifies it, and instead of storing different data
    in different tables as in a relational database, every entity in Datastore is
    categorized by a kind. In the Python world, a kind is determined by its model
    class that we need to define in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To represent a kind, Datastore models must derive from the `ndb.Model` class
    provided by the NDB API. We define our models in a Python module called `models.py`
    that contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Note` class has a property named `title` that contains small text (up
    to 500 characters), another one named `content` that contains text of unlimited
    length, and a property named `date_created` that contains a date and a time. Entities
    of this kind must contain at least a value for the `user` and `content` properties,
    and if not provided, the `date_created` property value will store the date and
    time at the moment the entity was created. We can now add new entities of the
    type `Note` class to the Datastore when users submit the form in the main page
    of the Notes application. In the `main.py` module, we first need to import the
    `Note` class from the `models` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we modify the `post()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: From now on, each time a user submits the form in the main page, an instance
    of the `Note` class is created and an entity is persisted in the Datastore right
    after the `put()` method is called. As we have not modified the `template_context`
    dictionary, the storing process won't do anything apparently. To verify that data
    is actually stored, we can use the local Development Console by opening the browser
    at `http://localhost:8000` and checking out Datastore Viewer.
  prefs: []
  type: TYPE_NORMAL
- en: Basic querying
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An entity can optionally specify another entity as its **parent** and an entity
    without a parent is a **root entity**; entities in Datastore form a hierarchically
    structured space similar to the directory structure in a filesystem. An entity
    together with all its descendants form an **entity group** and the key of the
    common ancestor is defined as the **parent key**.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to understand entities' relationship because of the intrinsic
    distributed nature of the Datastore. Without digging too much into the details,
    what we have to know is that queries across multiple entity groups cannot guarantee
    consistent results and the result of such queries can sometimes fail to reflect
    recent changes to the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have an alternative though; to get strongly consistent results, we can perform
    a so-called **ancestor query**, which is a query that limits the results to a
    particular entity group. To use ancestor queries in our code, the first thing
    to do is add a parent to our note entities when we create the model instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As every note belongs to the user who creates it, we can use the same logic
    to structure our data; we use the currently logged-in user as the parent key for
    an entity group that contains all the notes belonging to that user. This is why
    we specify the `parent` keyword when calling the `Note` constructor in the previous
    code. To obtain the key of the currently logged-in user, we use the `ndb.Key`
    class constructor, passing in the kind and the identifier of the corresponding
    entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need to do now is retrieve our notes from Datastore and show them to
    our users. As we will use ancestor queries, before proceeding, we add a utility
    method to the `Note` model class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `owner_query()` method returns a query object already filtered and containing
    the group entities for the parent key specified with the `parent_key` function
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To load all notes belonging to the current user, we then write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As we want to show the notes in the main page in the case of the `GET` and
    `POST` requests, we can load the entities inside the `_render_template()` method,
    which is called by the handler in both cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the list of the notes as a value for the `notes` key in the `context`
    dictionary so that we can use them in the HTML template by writing the following
    right below the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A `div` element will be printed out for each note in the query result and nothing
    will be printed out if the query returned an empty list. Even if the `title` property
    is optional for entities of the kind Note, we can safely access it. If it's not
    present, an empty string will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's very common for web applications to define and use Datastore models that
    depend on each other so that when we update an entity, we will likely need to
    update dependent entities as well. However, what happens if, during a series of
    Datastore operations, some of them fail? In such cases, we can encapsulate these
    operations in a transaction so that either all of them succeed or all of them
    fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see a use case for transactions, we add a small feature to our Note model:
    a checklist. A checklist is a list of items that provide a Boolean property that
    determines their checked state. We first need to define a Datastore model for
    a single checklist item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The entity has two properties, the `title` property for the string that will
    be displayed and the `checked` property to store whether the item is checked or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then add a property to the `Node` model class referencing item entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `checklist_items` property stores key values of the `CheckListItem` kind;
    the `repeated=True` parameter is needed to define that the property can hold more
    than one value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users can create checklist items for a note filling the creation form with
    a comma-separated list of values, so we add the following to the HTML template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to handle the comma-separated list in the `MainHandler` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We first retrieve the comma-separated values representing checklist items from
    the request. Then, for each of them, we create a `CheckListItem` instance. Until
    a model instance is not persisted, Datastore does not assign any key to it. So,
    we need to first store each item by calling the `put()` method before accessing
    the `key` property and retrieving a `Key` instance for that entity. Once we have
    a valid key, we append it to the list of items of the `Note` instance. We pass
    the key of the note as parent for the items so that all these entities will be
    part of the same entity group. The last step is to call the `put()` method and
    update the Node entity and store the new data for the `checklist_items` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now what happens if the `note.put()` method fails? We have a bunch of entities
    of `CheckListItem` type that are not tied to any note, and this is a consistency
    problem. Transactions can help us refactor the creation of a note so that it can
    either succeed or fail, without leaving behind any dangling data. We encapsulate
    the creation of note objects in a separate `_create_node()` method in the handler
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@ndb.transactional` decorator is all the Python code we need. Datastore
    will then ensure that any operation in the decorated method happens within a transaction.
    In this way, either we create a note entity along with all the checklist items
    entities or we get an error without touching the underlying data. To complete
    the code, we have to call the `_create_node()` method inside the `post()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To show the list of items in a checklist for our notes, we must add the code
    needed in the HTML template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We add an unordered list if the `checklist_items` property is not empty. We
    then iterate the list of items, adding a `class` attribute containing the `checked`
    parameter whenever an item has its `checked` property set to the `true` value:
    later in this chapter, we''ll learn how to add a **CSS (Cascading Style Sheets)**
    rule so that when this class is present, the item is shown with a horizontal line
    through its center.'
  prefs: []
  type: TYPE_NORMAL
- en: Using static files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually web applications make use of CSS and JavaScript resources to provide
    a better user experience. For efficiency reasons, such content is not dynamically
    served by the WSGI application and are delivered by App Engine as static files
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know from the previous chapter that App Engine provides two types of handlers,
    script handlers and static file handlers. We add a static file handler to our
    `app.yaml` configuration file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The syntax is almost the same as for script handlers. We specify a URL to map
    as a regular expression but instead of providing a Python script to handle requests,
    we specify a filesystem path relative to the application root where the files
    and directories that need to be served as static resources are located.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are now going to provide a minimal style for our HTML pages by manually coding
    some CSS rules. While it is acceptable for the scope of the book to get our hands
    dirty learning how to build a custom design from scratch, in the real world, we
    might prefer to use frontend frameworks such as Bootstrap ([http://getbootstrap.com/](http://getbootstrap.com/))
    or Foundation ([http://foundation.zurb.com/](http://foundation.zurb.com/)) to
    easily provide state-of-the-art aesthetics, cross-browser capabilities, and responsive
    layouts for mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide a CSS for our application, we then create the `static/css` folder
    into our application root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This folder should contain a file called `notes.css` that will contain the
    style sheet for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The first part is for global layout elements; we will put the form and the
    notes one below another in a centered container. We then style the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The form will be contained in a white box and the legend will look like a note
    title. Form elements will be styled as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We then proceed with styling the white boxes that contain the Notes data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of the style sheet is dedicated to notes checklists. We provide
    a style for unordered lists contained in `div` elements with a `note` class and
    a style for list items in checked state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the style sheet, we add this in our HTML template, inside the `<meta>`
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the application should appear once the style sheet is applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using static files](img/8194OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks to App Engine, we have already implemented a rich set of features with
    a relatively small effort so far.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have discovered some more details about the webapp2 framework
    and its capabilities, implementing a nontrivial request handler. We have learned
    how to use the App Engine users service to provide users authentication. We have
    delved into some fundamental details of Datastore and now we know how to structure
    data in grouped entities and how to effectively retrieve data with ancestor queries.
    In addition, we have created an HTML user interface with the help of the Jinja2
    template library, learning how to serve static content such as CSS files.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will keep on adding more and more features to the Notes
    application, learning how to store uploaded files on Google Cloud Storage, manipulate
    images, and deal with long operations and scheduled tasks. We will also make the
    application capable of sending and receiving e-mails.
  prefs: []
  type: TYPE_NORMAL
