- en: Chapter 7. Window Layout and Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a `BoxSizer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding proportions, flags, and borders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laying out controls with the `GridBagSizer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard dialog button layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using XML resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a custom resource handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `AuiFrameManager`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have an idea of how the interface of your applications should look,
    it comes the time to put it all together. Being able to take your vision and translate
    it into code can be a tricky and often tedious task. A window's layout is defined
    on a two dimensional plane with the origin being the window's top-left corner.
    All positioning and sizing of any widgets, no matter what it's onscreen appearance,
    is based on rectangles. Clearly understanding these two basic concepts goes a
    long way towards being able to understand and efficiently work with the toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally in older applications, window layout was commonly done by setting
    explicit static sizes and positions for all the controls contained within a window.
    This approach, however, can be rather limiting as the windows will not be resizable,
    they may not fit on the screen under different resolutions, trying to support
    localization becomes more difficult because labels and other text will differ
    in length in different languages, the native widgets will often be different sizes
    on different platforms making it difficult to write platform independent code,
    and the list goes on.
  prefs: []
  type: TYPE_NORMAL
- en: So, you may ask what the solution to this is. In wxPython, the method of choice
    is to use the `Sizer` classes to define and manage the layout of controls. Sizers
    are classes that manage the size and positioning of controls through an algorithm
    that queries all of the controls that have been added to the Sizer for their recommended
    best minimal sizes and their ability to stretch or not, if the amount of available
    space increases, such as if a user makes a dialog bigger. Sizers also handle cross-platform
    widget differences, for example, buttons on GTK tend to have an icon and be generally
    larger than the buttons on Windows or OS X. Using a `Sizer` to manage the button's
    layout will allow the rest of the dialog to be proportionally sized correctly
    to handle this without the need for any platform-specific code.
  prefs: []
  type: TYPE_NORMAL
- en: So let us begin our adventure into the world of window layout and design by
    taking a look at a number of the tools that wxPython provides in order to facilitate
    this task.
  prefs: []
  type: TYPE_NORMAL
- en: Using a BoxSizer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `BoxSizer` is the most basic of `Sizer` classes. It supports a layout that
    goes in a single direction—either a vertical column or a horizontal row. Even
    though it is the most basic to work with, a `BoxSizer` is one of the most useful
    `Sizer` classes and tends to produce more consistent cross-platform behavior when
    compared to some of the other `Sizers` types. This recipe creates a simple window
    where we want to have two text controls stacked in a vertical column, each with
    a label to the left of it. This will be used to illustrate the most simplistic
    usage of a `BoxSizer` in order to manage the layout of a window's controls.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here we define our top level Frame, which will use a BoxSizer to manage the
    size of its Panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BoxSizerPanel` class is the next layer in the window hierarchy, and is
    where we will perform the main layout of the controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Just to help reduce clutter in the `__init__` method, we will do all the layout
    in a separate `_DoLayout` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous code shows the basic pattern of how to create a simple window layout
    programmatically, using sizers to manage the controls. First let's start by taking
    a look at the `BoxSizerPanel` class's `_DoLayout` method, as this is where the
    majority of the layout in this example takes place.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we started off by creating three `BoxSizer` classes: one with a vertical
    orientation, and two with a horizontal orientation. The layout we desired for
    this window requires us to use three `BoxSizer` classes and this is why. If you
    break down what we want to do into simple rectangles, you will see that:'
  prefs: []
  type: TYPE_NORMAL
- en: We wanted two `TextCtrl` objects each with a label to the left of them which
    can simply be thought of as two horizontal rectangles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We wanted the `TextCtrl` objects stacked vertically in the window which is just
    a vertical rectangle that will contain the other two rectangles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is illustrated by the following screenshot (borders are drawn in and labels
    are added to show the area managed by each of `Panel's` three `BoxSizers):`
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1780_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the section where we populate the first horizontal sizer (`field1_sz`), we
    use two of the `BoxSizer` methods to add items to the layout. The first is `AddSpacer`,
    which does simply as its named and adds a fixed amount of empty space in the left-hand
    side of the sizer. Then we use the `Add` method to add our `StaticText` control
    to the right of the spacer, and continue from here to add other items to complete
    this row. As you can see, these methods add items to the layout from left to right
    in the sizer. After this, we again do the same thing with the other label and
    `TextCtrl` in the second horizontal sizer.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of the Panel's layout is done by adding the two horizontal sizers
    to the vertical sizer. This time, since the sizer was created with a `VERTICAL`
    orientation, the items are added from top to bottom. Finally, we use the `Panel's
    SetSizer` method to assign the main outer `BoxSizer` as the `Panel's` sizer.
  prefs: []
  type: TYPE_NORMAL
- en: The `BoxSizerFrame` also uses a `BoxSizer` to manage the layout of its `Panel`.
    The only difference here is that we used the `Add` method's `proportion` and `flags`
    parameters to tell it to make the Panel expand to use the entire space available.
    After setting the Frame's sizer, we used its `SetInitialSize` method, which queries
    the window's sizer and its descendents to get and set the best minimal size to
    set the window to. We will go into more detail about these other parameters and
    their effects in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Included below is a little more additional information about adding spacers
    and items to a sizer's layout.
  prefs: []
  type: TYPE_NORMAL
- en: Spacers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `AddSpacer` will add a square-shaped spacer that is X pixels wide by X pixels
    tall to the `BoxSizer`, where X is the value passed to the `AddSpacer` method.
    Spacers of other dimensions can be added by passing a `tuple` as the first argument
    to the `BoxSizer's Add` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will add a 20x5 pixel spacer to the sizer. This can be useful when you
    don't want the vertical space to be increased by as much as the horizontal space,
    or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: AddMany
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `AddMany` method can be used to add an arbitrary number of items to the
    sizer in one call. `AddMany` takes a `list` of `tuples` that contain values that
    are in the same order as the `Add` method expects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will add three items to the sizer: the first two items only specify the
    one required parameter, and the third specifies the `proportion` and `flags` parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Understanding proportions, flags, and borders* recipe in this chapter expands
    into further detail about the behavioral attributes of `SizerItems`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding proportions, flags, and borders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through the use of the optional parameters in a sizer's various `Add` methods,
    it is possible to control the relative proportions, alignment, and padding around
    every item that is managed by the sizer. Without using these additional settings,
    all the items in the sizer will just use their "best" minimum size and will be
    aligned to the top-left of the rectangle of space that the sizer provides. This
    means that the controls will not stretch or contract when the window is resized.
    Also, for example, if in a horizontal row of items in a `BoxSizer` one of the
    items has a greater height than some of the other items in that same row, they
    may not be aligned as desired (see the following diagram).
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding proportions, flags, and borders](img/1780_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This diagram illustrates an alignment issue that can occur when some controls
    have a different-sized rectangle than the one next to it. This is a realistic
    example of a problem that can occur on GTK (Linux), as its `ComboBoxes` tend to
    be much taller than a `StaticTextCtrl`. So where on other platforms these two
    controls may appear to be properly center-aligned, they will look like this on
    Linux.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will re-implement the previous recipe's `BoxSizerPanel`, using these
    additional `Add` parameters to improve its layout, in order to show how these
    parameters can be used to influence how the sizer manages each of the controls
    that have been added to it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before getting started on this recipe, make sure you have reviewed the previous
    recipe, *Using a BoxSizer*, as we will be modifying its `_DoLayout` method in
    this recipe to define some additional behaviors that the sizers should apply to
    its layout.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will make some modifications to the `SizerItems` proportions, flags,
    and borders to change the behavior of the layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe just shows what we changed in the previous recipe's `__DoLayout`
    method to take advantage of some of these extra options. The first thing to notice
    in the section where we add the controls to the horizontal sizers is that we no
    longer have the `AddSpacer` calls. These have been replaced by specifying a border
    in the `Add` calls. When adding each of the labels we added two sizer flags, `ALIGN_CENTER_VERTICAL`
    and `RIGHT`. The first flag is an alignment flag that specifies the desired behavior
    of the alignment and the second is a border flag that specifies where we want
    the border parameter to be applied. In this case, the sizer will align the `StaticText`
    in the center of the vertical space and add a 5px padding to the right side of
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, where we add the `TextCtrl` objects to the sizer, we specified a `1` for
    the proportion and `EXPAND` for the sizer flag. Setting the proportion greater
    than the default of `0` will tell the sizer to give that control proportionally
    more of the space in the sizer's managed area. A proportion value greater than
    0 in combination with the `EXPAND` flag which tells the control to get bigger
    as space is available will let it stretch as the dialog is resized to a bigger
    size. Typically you will only need to specify `0` or `1` for the proportion parameter,
    but under some complex layouts it may be necessary to give different controls
    a relatively different amount of the total available space. For example, in a
    layout with two controls if both are given a proportion of 1, they would each
    get 50 percent of the space. Changing the proportion of one of the controls to
    2 would change the space allocation to a 66/33 percent balance.
  prefs: []
  type: TYPE_NORMAL
- en: We also made some changes to the final layout with the vertical sizer. First,
    instead of using the regular `AddSpacer` function to add some static spacers to
    the layout, we changed it to use `AddStretchSpacer` instead. `AddStretchSpacer`
    is basically the equivalent of doing `Add((-1,-1), 1, wx.EXPAND)`, which just
    adds a spacer of indeterminate size that will stretch as the window size is changed.
    This allows us to keep the controls in the center of the dialog as its vertical
    size changes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when adding the two horizontal sizers to the vertical sizer, we used
    some flags to apply a static 50px of spacing around the `LEFT, RIGHT`, and `TOP`
    or `BOTTOM` of the sizers. It's also important to notice that we once again passed
    the `EXPAND` flag. If we did not do this, the vertical sizer would not allow those
    two items to expand which in turn would nullify us adding the `EXPAND` flag for
    the `TextCtrl` objects. Try running this and the previous sample side-by-side
    and resizing each window to see the difference in behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1780_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The previous screenshot has had some lines drawn over it to show the five items
    that are managed by the main top level `VERTICAL` sizer `vsizer`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a number of flags that can be used to affect the layout in various
    ways. The following three tables list the different categories of these flags
    that can be combined in the flag''s bitmask:'
  prefs: []
  type: TYPE_NORMAL
- en: Alignment flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This table shows a listing of all the alignment flags and a description of
    what each one does:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Alignment flags | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.ALIGN_TOP` | Align the item to the top of the available space |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.ALIGN_BOTTOM` | Align the item to the bottom of the available space |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.ALIGN_LEFT` | Align the item to the left of the available space |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.ALIGN_RIGHT` | Align the item to the right of the available space |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.ALIGN_CENTER_VERTICAL``wx.ALIGN_CENTRE_VERTICAL` | Align the item in
    the center of the vertical space |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.ALIGN_CENTER_HORIZONTAL``wx.ALIGN_CENTRE_HORIZONTAL` | Align the item
    in the center of the horizontal space |'
  prefs: []
  type: TYPE_TB
- en: Border flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following flags can be used to control which side(s) of the control the
    border argument of the Sizer''s `Add` method is applied to:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Border flags | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.TOP` | Apply the border to the top of the item |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.BOTTOM` | Apply the border to the bottom of item |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.LEFT` | Apply the border to the left of the item |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.RIGHT` | Apply the border to the right of the item |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.ALL` | Apply the border to all sides of the item |'
  prefs: []
  type: TYPE_TB
- en: Behavior flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The sizer flags in this table can be used to control how a control is resized
    within a sizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Behaviour flags | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.EXPAND` | Item will expand to fill the space provided to it (`wx.GROW`
    is the same) |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.SHAPED` | Similar to `EXPAND` but maintains the item''s aspect ratio
    |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.FIXED_MINSIZE` | Don''t let the item become smaller than its initial
    minimum size |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.RESERVE_SPACE_EVEN_IF_HIDDEN` | Don''t allow the sizer to reclaim an
    item''s space when it is hidden |'
  prefs: []
  type: TYPE_TB
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Using a BoxSizer* recipe in this chapter for the basics of using a
    `BoxSizer`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Laying out controls with the GridBagSizer* recipe in this chapter shows
    how to use one of the more complex sizer classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laying out controls with the GridBagSizer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of other types of sizers in wxPython, besides the `BoxSizer`,
    that are designed to help simplify different kinds of layouts. The `GridSizer,
    FlexGridSizer`, and `GridBagSizer` can be used to lay items out in a grid-like
    manner. The `GridSizer` provides a fixed grid layout where items are added into
    different "cells" in the grid. The `FlexGridSizer` is just like the `GridSizer`,
    except that the columns in the grid can be different widths. Finally, the `GridBagSizer`
    is similar to the `FlexGridSizer` but also allows items to span over multiple
    "cells" in the grid, which makes it possible to achieve layouts that can usually
    only be achieved by nesting several `BoxSizers`. This recipe will discuss the
    use of the `GridBagSizer`, and use it to create a dialog that could be used for
    viewing the details of a log event.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here we will create a custom `DetailsDialog` that could be used for viewing
    log messages or system events. It has two fields in it for displaying the type
    of message and the verbose message text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `GridBagSizer's Add` method of `GridBagSizer` takes some additional parameters
    compared to the other types of sizers. It is necessary to specify the grid position
    and optionally the number of columns and rows to span. We used this in our details
    dialog in order to allow the `TextCtrl` fields to span multiple columns and multiple
    rows in the case of the details field. The way this layout works can get a little
    complicated, so let's go over our `__DoLayout` method line-by-line to see how
    each of them affect the dialog's layout.
  prefs: []
  type: TYPE_NORMAL
- en: First, we create out `GridBagSizer`, and in its constructor we specify how much
    padding we want between the rows and columns. Next, we start adding our items
    to the sizer. The first item that we add is the type `StaticText` label, which
    we added at row 1, column 1\. This was done to leave some padding around the outside
    edge. Next, we added the `TextCtrl` to the right of the label at row 1, column
    2\. For this item, we also specified the span parameter to tell the item to span
    1 row and 15 columns. The column width is proportionally based upon the size of
    the first column in the grid.
  prefs: []
  type: TYPE_NORMAL
- en: Next we add the details fields, starting with the details label, which is added
    at row 2, column 1, in order to line up with the type `StaticText` label. Since
    the details text may be long, we want it to span multiple rows. Hence, for its
    span parameter we specified for it to span 5 rows and 15 columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, so that the padding around our controls on the bottom and right-hand
    side matches the top and left, we need to add a spacer to the right and bottom
    to create an extra column and row. Notice that for this step we need to take into
    account the span parameters of the previous items we added, so that our items
    do not overlap. Items cannot occupy the same column or row as any other item in
    the sizer. So first we add a spacer to row 2, column 17, to create a new column
    on the right-hand side of our `TextCtrl` objects. We specified column 17 because
    the `TextCtrl` objects start at column 2 and span 15 columns. Likewise, we did
    the same when adding one to the bottom, to take into account the span of the details
    text field. Note that instead of offsetting the first item in the grid and then
    adding spacers, it would have been easier to nest our `GridBagSizer` inside of
    a `BoxSizer` and specify a border. The approach in this recipe was done just to
    illustrate the need to account for an item''s span when adding additional items
    to the grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1780_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See the sample code that accompanies this chapter for a small application that
    uses this dialog.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Understanding proportions, flags, and borders* recipe in this chapter describes
    the use of sizer flags in detail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard dialog button layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each platform has different standards for how different dialog buttons are placed
    in the dialog. This is where the `StdDialogButtonSizer` comes into play. It can
    be used to add standard buttons to a dialog, and automatically take care of the
    specific platform standards for where the button is positioned. This recipe shows
    how to use the `StdDialogButtonSizer` to quickly and easily add standard buttons
    to a `Dialog`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the code for our custom message box class that can be used as a replacement
    for the standard `MessageBox` in cases where the application wants to display
    custom icons in their pop-up dialogs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we created a custom `MessageBox` clone that can accept a custom `Bitmap`
    to display instead of just the standard icons available in the regular `MessageBox`
    implementation. This class is pretty simple, so let's jump into the `__DoLayout`
    method to see how we made use of the `StdDialogButtonSizer`.
  prefs: []
  type: TYPE_NORMAL
- en: In `__DoLayout`, we first created some regular `BoxSizers` to do the main part
    of the layout, and then in one single line of code we created the entire layout
    for our buttons. To do this, we used the `CreateButtonSizer` method of the base
    `wx.Dialog` class. This method takes a bitmask of flags that specifies the buttons
    to create, then creates them, and adds them to a `StdDialogButtonSizer` that it
    returns. All we need to do after this is to add the sizer to our dialog's main
    sizer and we are done!
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshots show how the `StdDialogButtonSizer` handles the differences
    in platform standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the **OK** and **Cancel** buttons on a dialog are ordered as **OK/Cancel**
    on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1780_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On Macintosh OS X, the standard layout for the buttons is **Cancel/OK:**
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1780_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a quick reference to the flags that can be passed as a bitmask to the
    `CreateButtonSizer` method in order to create the buttons that the button sizer
    will manage:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Flags | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.OK` | Creates an OK button |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.CANCEL` | Creates a Cancel button |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.YES` | Creates a Yes button |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.NO` | Creates a No button |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.HELP` | Creates a Help button |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.NO_DEFAULT` | Sets the No button as the default |'
  prefs: []
  type: TYPE_TB
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating Stock Buttons* recipe in [Chapter 3](ch03.html "Chapter 3. Basic
    Building Blocks of a User Interface"), *Basic Building Blocks of a User Interface*
    discusses how to create common buttons from built-in IDs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using a BoxSizer* recipe in this chapter discusses the basics of window
    layout using `BoxSizers`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using XML resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XRC is a way of creating and design window layouts with XML resource files.
    The hierarchical nature of XML parallels that of an application's window hierarchy,
    which makes it a very sensible data format to serialize a window layout with.
    This recipe shows how to create and load a simple dialog with two `CheckBoxe`
    objects and two `Button` objects on it, from an XML resource file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is the XML for our dialog that we have in a file called `xrcdlg.xrc:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When loaded, the above XML will generate the following dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1780_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a minimal program to load this XML resource to make and show the dialog
    it represents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The XML in this recipe was created with the help of `xrced`, which is an XML
    resource editor tool that is a part of the wxPython tools package. The `object`
    tag is used to represent a class object. Nesting other objects inside is how the
    parent child relationship is represented with the XML. The `class` attribute of
    the `object` tag is what is used to specify the type of class to create. The values
    should be a class name and in the case of wxPython provided classes, they use
    the `wxWidgets` names, which are prefixed with "wx". To work with `XmlResource`
    classes, it is highly recommended to use a tool like `xrced` to generate the XML.
  prefs: []
  type: TYPE_NORMAL
- en: In order to load the XML to create the object(s) that are used for representation,
    you need to import the `wx.xrc` package, which provides the `XmlResource` class.
    There are a few ways to use `XmlResource` to perform the transformations on the
    XML. In this example, we created our `XmlResource` object by passing the path
    to our `xrc` file in its constructor. This object has a number of load methods
    for instantiating different types of objects. We want to load a dialog, so we
    called its `LoadDialog` method, passing a parent window as the first argument
    and then the name of the dialog we want to load from the XML. It will then instantiate
    an instance of that dialog and return it so that we can show it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Included below are some additional references to features available when using
    the XRC library.
  prefs: []
  type: TYPE_NORMAL
- en: Loading other types of resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `XmlResource` object has methods for loading many different kinds of resources
    from XML. Here is quick reference to some of the additional methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Methods | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `LoadBitmap(name)` | Loads and returns the Bitmap identified by name |'
  prefs: []
  type: TYPE_TB
- en: '| `LoadDialog(parent, name)` | Loads and returns the Dialog identified by name
    |'
  prefs: []
  type: TYPE_TB
- en: '| `LoadFrame(parent, name)` | Loads and returns the Frame identified by name
    |'
  prefs: []
  type: TYPE_TB
- en: '| `LoadIcon(name)` | Loads and returns the Icon identified by name |'
  prefs: []
  type: TYPE_TB
- en: '| `LoadMenu(name)` | Loads and returns the Menu identified by name |'
  prefs: []
  type: TYPE_TB
- en: '| `LoadMenuBar(parent, name)` | Loads and returns the MenuBar identified by
    name |'
  prefs: []
  type: TYPE_TB
- en: '| `LoadPanel(parent, name)` | Loads and returns the Panel identified by name
    |'
  prefs: []
  type: TYPE_TB
- en: '| `LoadToolBar(parent, name)` | Loads and returns the ToolBar identified by
    name |'
  prefs: []
  type: TYPE_TB
- en: Specifying standard IDs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to give an object a standard ID in XRC, it should be specified in the
    `object` tag's `name` attribute, using the `wxWidgets` naming for the ID (that
    is, `wxID_OK` without the '.').
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Making a custom resource handler* recipe in this chapter contains some
    additional information on using XRC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a custom resource handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although XRC has built-in support for a large number of the standard controls,
    any non-trivial application will use its own subclasses and/or custom widgets.
    Creating a custom `XmlResource` class will allow these custom classes to be loaded
    from an XML resource file. This recipe shows how to create an XML resource handler
    for a custom `Panel` class and then use that handler to load the resource.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe discusses how to customize and extend the handling of XML resources.
    Please review the *Using XML resources* recipe in this chapter to learn the basics
    of how XRC works.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following code, we will show how to create a custom XML resource handler
    for a Panel and then how to use XRC to load that resource into a Frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, in our Frame subclass, we simply create an instance of our custom resource
    handler and use it to load our custom Panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the Panel class that our custom resource handler will be used to create.
    It is just a simple Panel with a `TextCtrl` and two `Buttons` on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here is our custom XML resource handler class, where we just have
    to override two methods to implement the handling for our `TextEditPanel` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `TextEditPanel` is our custom class that we want to create a custom resource
    handler for. The `TextEditPanelXmlHandler` class is a minimal resource handler
    that we created to be able to load our class from XML. This class has two required
    overrides that need to be implemented for it to function properly. The first is
    `CanHandle`, which is called by the framework to check if the handler can handle
    a given node type. We used the `IsOfClass` method to check if the node was of
    the same type as our `TextEditPanel`. The second is `DoCreateResource`, which
    is what is called to create our class. To create the class, all of its arguments
    can be retrieved from the resource handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `XrcTestFrame` class is where we made use of our custom resource handler.
    First, we created an `EmptyXmlResource` object and used its `InsertHandler` method
    to add our custom handler to it. Then we loaded the XML from the `RESOURCE` string
    that we defined using the handler''s `LoadFromString` method. After that, all
    there was to do was load the object using the resource''s `LoadObject` method,
    which takes three arguments: the `parent` window of the object to be loaded, the
    `name` of the object in the XML resource, and the `classname`.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Understanding inheritance limitations* recipe in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with wxPython"), *Getting Started with wxPython* for
    some additional information about overriding virtual methods in wxPython classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Using XML resources* recipe in this chapter for more examples of using
    XML to create screen layouts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the AuiFrameManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `AuiFrameManager` is part of the Advanced User Interface (wx.aui) library
    added to wxPython in 2.8\. It allows a Frame to have a very user customizable
    interface. It automatically manages children windows in panes that can be undocked
    and turned into separate floating windows. There are also some built-in features
    to help with persisting and restoring the window's layout during running the application.
    This recipe will create a Frame base class that has AUI support and will automatically
    save its perspective and reload it when the application is next launched.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following code will define a base class that encapsulates some of the usage
    of an `AuiManager:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`OnAuiBaseClose` will be called when the Frame closes. We use this as the point
    to get the current window layout perspective and save it for the next time the
    application is launched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`AddPane` simply wraps getting access to the Frame''s `AuiManager` and adds
    the given pane and `auiInfo` to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The next method is simply a convenience method for creating and adding the
    main center pane to the managed window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This final method is used to load the last saved window layout from the last
    time the window was opened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we created a class to help encapsulate some of the `AuiManager's`
    functionality. So let's take a look at some of the functionality that this class
    provides, and how it works.
  prefs: []
  type: TYPE_NORMAL
- en: The `__init__` method is where we create the `AuiManager` object that will manage
    the panes that we want to add to the Frame. The `AuiManager` accepts a number
    of possible flags to dictate its behavior. We employed a small workaround for
    a bug on Linux platforms that use desktop compositing. Using the transparent docking
    hints can cause an AUI application to crash in this scenario, so we replaced it
    with the venetian blind style instead.
  prefs: []
  type: TYPE_NORMAL
- en: '`OnAuiBaseClose` is used as an event handler for when the `Frame` closes. We
    use this as a hook to automatically store the current layout of the `AuiManager`,
    which is called a perspective, for the next application launch. To implement this
    feature, we have created a requirement that the App object''s `SetName` method
    was called to set the application name because we need this in order to use `wx.Config`.
    The `wx.Config` object is simply an interface used to access the Registry on Windows
    or an application configuration file on other platforms. `SavePerspective` returns
    a string encoded with all of the information that the `AuiManager` needs in order
    to restore the current window layout. The application can then simply call our
    `LoadDefaultPerspective` method when the application starts up, in order to restore
    the user''s last window layout.'
  prefs: []
  type: TYPE_NORMAL
- en: The other two methods in this class are quite simple and are provided simply
    for convenience to delegate to the `AuiManager` of the `Frame`. The `AddPane`
    method of the `AuiManager` is how to add panes to be managed by it. The `pane`
    argument needs to be a window object that is a child of the `Frame`. In practice,
    this is usually some sort of `Panel` subclass. The `auiInfo` argument is an `AuiPaneInfo`
    object. This is what the `AuiManager` uses to determine how to manage the pane.
    See the sample code that accompanies this recipe for an example of this class
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a quick reference to the flags that can be used in the flags bitmask
    for the `AuiManager` in order to customize its behavior and the styles of some
    of its components:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Flags | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `AUI_MGR_DEFAULT` | Equivalent of `AUI_MGR_ALLOW_FLOATING&#124; AUI_MGR_TRANSPARENT_HINT&#124;
    AUI_MGR_HINT_FADE&#124; AUI_MGR_NO_VENETIAN_BLINDS_FADE` |'
  prefs: []
  type: TYPE_TB
- en: '| `AUI_MGR_ALLOW_FLOATING` | Allow for floating panes |'
  prefs: []
  type: TYPE_TB
- en: '| `AUI_MGR_ALLOW_ACTIVE_PANE` | Highlight the caption bar of the currently-active
    pane |'
  prefs: []
  type: TYPE_TB
- en: '| `AUI_MGR_HINT_FADE` | Fade docking hints out of view |'
  prefs: []
  type: TYPE_TB
- en: '| `AUI_MGR_LIVE_RESIZE` | Resize panes while the sash between them is being
    dragged |'
  prefs: []
  type: TYPE_TB
- en: '| `AUI_MGR_NO_VENETIAN_BLINDS_FADE` | Disable the venetian blind fade in/out
    |'
  prefs: []
  type: TYPE_TB
- en: '| `AUI_MGR_RECTANGLE_HINT` | Show a simple rectangle docking hint when dragging
    floating panes |'
  prefs: []
  type: TYPE_TB
- en: '| `AUI_MGR_TRANSPARENT_DRAG` | Make floating panes partially-transparent when
    they are being dragged |'
  prefs: []
  type: TYPE_TB
- en: '| `AUI_MGR_TRANSPARENT_HINT` | Show a partially-transparent light blue docking
    hint when dragging floating panels |'
  prefs: []
  type: TYPE_TB
- en: '| `AUI_MGR_VENETIAN_BLINDS_HINT` | Use a venetian blind style docking hint
    for floating panels |'
  prefs: []
  type: TYPE_TB
