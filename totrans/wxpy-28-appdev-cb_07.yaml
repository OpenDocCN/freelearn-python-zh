- en: Chapter 7. Window Layout and Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 窗口布局与设计
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Using a `BoxSizer`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `BoxSizer`
- en: Understanding proportions, flags, and borders
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解比例、旗帜和边框
- en: Laying out controls with the `GridBagSizer`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `GridBagSizer` 布置控件
- en: Standard dialog button layout
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准对话框按钮布局
- en: Using XML resources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 XML 资源
- en: Making a custom resource handler
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义资源处理器
- en: Using the `AuiFrameManager`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `AuiFrameManager`
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Once you have an idea of how the interface of your applications should look,
    it comes the time to put it all together. Being able to take your vision and translate
    it into code can be a tricky and often tedious task. A window's layout is defined
    on a two dimensional plane with the origin being the window's top-left corner.
    All positioning and sizing of any widgets, no matter what it's onscreen appearance,
    is based on rectangles. Clearly understanding these two basic concepts goes a
    long way towards being able to understand and efficiently work with the toolkit.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对应用程序界面的外观有了想法，就是时候将所有元素整合在一起了。能够将你的愿景转化为代码可能是一项棘手且常常繁琐的任务。窗口布局是在一个二维平面上定义的，其原点位于窗口的左上角。任何小部件的位置和尺寸，无论其在屏幕上的外观如何，都是基于矩形的。清楚地理解这两个基本概念对于理解和高效地使用工具包大有裨益。
- en: Traditionally in older applications, window layout was commonly done by setting
    explicit static sizes and positions for all the controls contained within a window.
    This approach, however, can be rather limiting as the windows will not be resizable,
    they may not fit on the screen under different resolutions, trying to support
    localization becomes more difficult because labels and other text will differ
    in length in different languages, the native widgets will often be different sizes
    on different platforms making it difficult to write platform independent code,
    and the list goes on.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的旧应用中，窗口布局通常是通过为窗口内包含的所有控件设置显式的静态大小和位置来完成的。然而，这种方法可能相当受限，因为窗口将无法调整大小，它们可能在不同分辨率下无法适应屏幕，尝试支持本地化变得更加困难，因为标签和其他文本在不同语言中的长度会有所不同，原生控件在不同平台上通常会有不同的大小，这使得编写平台无关的代码变得困难，问题还有很多。
- en: So, you may ask what the solution to this is. In wxPython, the method of choice
    is to use the `Sizer` classes to define and manage the layout of controls. Sizers
    are classes that manage the size and positioning of controls through an algorithm
    that queries all of the controls that have been added to the Sizer for their recommended
    best minimal sizes and their ability to stretch or not, if the amount of available
    space increases, such as if a user makes a dialog bigger. Sizers also handle cross-platform
    widget differences, for example, buttons on GTK tend to have an icon and be generally
    larger than the buttons on Windows or OS X. Using a `Sizer` to manage the button's
    layout will allow the rest of the dialog to be proportionally sized correctly
    to handle this without the need for any platform-specific code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可能想知道这个问题的解决方案是什么。在wxPython中，首选的方法是使用`Sizer`类来定义和管理控件布局。`Sizer`类通过查询已添加到`Sizer`中的所有控件的建议最佳最小尺寸以及它们在可用空间增加时是否能够拉伸或不能拉伸的能力，来管理控件的大小和位置。例如，如果用户将对话框放大，Sizer也会处理这种情况。Sizer还处理跨平台小部件的差异，例如，GTK上的按钮通常带有图标，并且通常比Windows或OS
    X上的按钮要大。使用`Sizer`来管理按钮布局将允许对话框的其余部分按比例正确地调整大小，以处理这种情况，而无需任何特定于平台的代码。
- en: So let us begin our adventure into the world of window layout and design by
    taking a look at a number of the tools that wxPython provides in order to facilitate
    this task.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们通过查看wxPython提供的用于简化此任务的众多工具，开始我们的窗口布局与设计之旅。
- en: Using a BoxSizer
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 BoxSizer
- en: A `BoxSizer` is the most basic of `Sizer` classes. It supports a layout that
    goes in a single direction—either a vertical column or a horizontal row. Even
    though it is the most basic to work with, a `BoxSizer` is one of the most useful
    `Sizer` classes and tends to produce more consistent cross-platform behavior when
    compared to some of the other `Sizers` types. This recipe creates a simple window
    where we want to have two text controls stacked in a vertical column, each with
    a label to the left of it. This will be used to illustrate the most simplistic
    usage of a `BoxSizer` in order to manage the layout of a window's controls.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`BoxSizer` 是 `Sizer` 类中最基本的类。它支持单方向的布局——要么是垂直的列，要么是水平的行。尽管它是使用起来最基础的，但 `BoxSizer`
    是最有用的 `Sizer` 类之一，并且与其他一些 `Sizer` 类型相比，它往往能产生更一致的跨平台行为。这个示例创建了一个简单的窗口，我们希望在窗口中堆叠两个文本控件，每个控件旁边都有一个标签。这将用来展示如何最简单地使用
    `BoxSizer` 来管理窗口控件布局。'
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here we define our top level Frame, which will use a BoxSizer to manage the
    size of its Panel:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义我们的顶级框架，它将使用BoxSizer来管理其面板的大小：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `BoxSizerPanel` class is the next layer in the window hierarchy, and is
    where we will perform the main layout of the controls:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`BoxSizerPanel` 类是窗口层次结构的下一层，也是我们将执行控件主要布局的地方：'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Just to help reduce clutter in the `__init__` method, we will do all the layout
    in a separate `_DoLayout` method:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅为了帮助减少`__init__`方法中的杂乱，我们将所有布局操作放在一个单独的`_DoLayout`方法中：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The previous code shows the basic pattern of how to create a simple window layout
    programmatically, using sizers to manage the controls. First let's start by taking
    a look at the `BoxSizerPanel` class's `_DoLayout` method, as this is where the
    majority of the layout in this example takes place.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码展示了如何通过程序创建一个简单的窗口布局的基本模式，使用sizers来管理控件。首先，让我们先看看`BoxSizerPanel`类的`_DoLayout`方法，因为在这个示例中，大部分的布局都发生在这里。
- en: 'First, we started off by creating three `BoxSizer` classes: one with a vertical
    orientation, and two with a horizontal orientation. The layout we desired for
    this window requires us to use three `BoxSizer` classes and this is why. If you
    break down what we want to do into simple rectangles, you will see that:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了三个`BoxSizer`类：一个具有垂直方向，另外两个具有水平方向。我们希望这个窗口的布局需要我们使用三个`BoxSizer`类，原因如下。如果你将我们想要做的事情分解成简单的矩形，你会看到：
- en: We wanted two `TextCtrl` objects each with a label to the left of them which
    can simply be thought of as two horizontal rectangles.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要两个`TextCtrl`对象，每个对象旁边都有一个标签，这可以简单地理解为两个水平的矩形。
- en: We wanted the `TextCtrl` objects stacked vertically in the window which is just
    a vertical rectangle that will contain the other two rectangles.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望`TextCtrl`对象在窗口中垂直堆叠，这个窗口仅仅是一个包含其他两个矩形的垂直矩形。
- en: This is illustrated by the following screenshot (borders are drawn in and labels
    are added to show the area managed by each of `Panel's` three `BoxSizers):`
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下截图来说明（图中已绘制边界并添加标签以显示每个`Panel`的三个`BoxSizers`管理的区域）：
- en: '![How it works...](img/1780_07_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1780_07_01.jpg)'
- en: In the section where we populate the first horizontal sizer (`field1_sz`), we
    use two of the `BoxSizer` methods to add items to the layout. The first is `AddSpacer`,
    which does simply as its named and adds a fixed amount of empty space in the left-hand
    side of the sizer. Then we use the `Add` method to add our `StaticText` control
    to the right of the spacer, and continue from here to add other items to complete
    this row. As you can see, these methods add items to the layout from left to right
    in the sizer. After this, we again do the same thing with the other label and
    `TextCtrl` in the second horizontal sizer.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在填充第一个水平布局器（`field1_sz`）的部分，我们使用了两个`BoxSizer`方法来添加项目到布局中。第一个是`AddSpacer`，正如其名，它简单地添加一定量的空空间到布局器的左侧。然后我们使用`Add`方法将我们的`StaticText`控件添加到空格器的右侧，并从这里继续添加其他项目以完成这一行。正如你所见，这些方法在布局器中从左到右添加项目。之后，我们再次在第二个水平布局器中对其他标签和`TextCtrl`执行同样的操作。
- en: The last part of the Panel's layout is done by adding the two horizontal sizers
    to the vertical sizer. This time, since the sizer was created with a `VERTICAL`
    orientation, the items are added from top to bottom. Finally, we use the `Panel's
    SetSizer` method to assign the main outer `BoxSizer` as the `Panel's` sizer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 面板布局的最后部分是通过向垂直尺寸器添加两个水平尺寸器来完成的。这次，由于尺寸器是以`VERTICAL`方向创建的，因此项目是从上到下添加的。最后，我们使用`Panel`的`SetSizer`方法将主外部的`BoxSizer`分配为`Panel`的尺寸器。
- en: The `BoxSizerFrame` also uses a `BoxSizer` to manage the layout of its `Panel`.
    The only difference here is that we used the `Add` method's `proportion` and `flags`
    parameters to tell it to make the Panel expand to use the entire space available.
    After setting the Frame's sizer, we used its `SetInitialSize` method, which queries
    the window's sizer and its descendents to get and set the best minimal size to
    set the window to. We will go into more detail about these other parameters and
    their effects in the next recipe.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`BoxSizerFrame` 也使用 `BoxSizer` 来管理其 `Panel` 的布局。这里唯一的区别在于，我们使用了 `Add` 方法的 `proportion`
    和 `flags` 参数来告诉它让 Panel 扩展以使用整个可用空间。在设置 Frame 的布局管理器后，我们使用了它的 `SetInitialSize`
    方法，该方法查询窗口的布局管理器及其子代，以获取和设置最佳最小尺寸来设置窗口。我们将在下一个菜谱中详细介绍这些其他参数及其影响。'
- en: There's more...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Included below is a little more additional information about adding spacers
    and items to a sizer's layout.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下包含关于向sizer布局中添加间隔和项目的一些额外信息。
- en: Spacers
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 间隔件
- en: The `AddSpacer` will add a square-shaped spacer that is X pixels wide by X pixels
    tall to the `BoxSizer`, where X is the value passed to the `AddSpacer` method.
    Spacers of other dimensions can be added by passing a `tuple` as the first argument
    to the `BoxSizer's Add` method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddSpacer` 方法将添加一个正方形形状的间隔，其宽度和高度均为 X 像素，并将其添加到 `BoxSizer` 中，其中 X 是传递给 `AddSpacer`
    方法的值。通过将一个 `tuple` 作为 `BoxSizer` 的 `Add` 方法的第一个参数传递，可以添加其他尺寸的间隔。'
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will add a 20x5 pixel spacer to the sizer. This can be useful when you
    don't want the vertical space to be increased by as much as the horizontal space,
    or vice versa.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为sizer添加一个20x5像素的间隔。这在您不想垂直空间增加得像水平空间那么多，或者相反的情况下很有用。
- en: AddMany
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AddMany
- en: The `AddMany` method can be used to add an arbitrary number of items to the
    sizer in one call. `AddMany` takes a `list` of `tuples` that contain values that
    are in the same order as the `Add` method expects.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddMany` 方法可以在一次调用中向 sizer 添加任意数量的项目。`AddMany` 接收一个包含值的 `tuple` 列表，这些值与 `Add`
    方法期望的顺序相同。'
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will add three items to the sizer: the first two items only specify the
    one required parameter, and the third specifies the `proportion` and `flags` parameters.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在sizer中添加三个项目：前两个项目仅指定一个必需的参数，第三个项目指定了`比例`和`标志`参数。
- en: See also
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Understanding proportions, flags, and borders* recipe in this chapter expands
    into further detail about the behavioral attributes of `SizerItems`.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于*理解比例、旗帜和边框*的配方进一步详细介绍了`SizerItems`的行为属性。
- en: Understanding proportions, flags, and borders
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解比例、旗帜和边框
- en: Through the use of the optional parameters in a sizer's various `Add` methods,
    it is possible to control the relative proportions, alignment, and padding around
    every item that is managed by the sizer. Without using these additional settings,
    all the items in the sizer will just use their "best" minimum size and will be
    aligned to the top-left of the rectangle of space that the sizer provides. This
    means that the controls will not stretch or contract when the window is resized.
    Also, for example, if in a horizontal row of items in a `BoxSizer` one of the
    items has a greater height than some of the other items in that same row, they
    may not be aligned as desired (see the following diagram).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用sizer的各种`Add`方法中的可选参数，可以控制由sizer管理的每个项目的相对比例、对齐方式和周围填充。如果不使用这些额外设置，sizer中的所有项目将仅使用它们的“最佳”最小尺寸，并将对齐到sizer提供的矩形空间顶部左侧。这意味着当窗口大小调整时，控件不会拉伸或收缩。例如，在一个`BoxSizer`的水平行项目列表中，如果其中某个项目的宽度大于同一行中的其他项目，它们可能不会按照期望对齐（参见以下图表）。
- en: '![Understanding proportions, flags, and borders](img/1780_07_02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![理解比例、旗帜和边框](img/1780_07_02.jpg)'
- en: This diagram illustrates an alignment issue that can occur when some controls
    have a different-sized rectangle than the one next to it. This is a realistic
    example of a problem that can occur on GTK (Linux), as its `ComboBoxes` tend to
    be much taller than a `StaticTextCtrl`. So where on other platforms these two
    controls may appear to be properly center-aligned, they will look like this on
    Linux.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此图展示了当某些控件与相邻的矩形大小不同时可能出现的对齐问题。这是GTK（Linux）上可能发生的一个实际问题的例子，因为其`ComboBoxes`通常比`StaticTextCtrl`高得多。所以，在其他平台上这两个控件可能看起来是正确居中对齐的，但在Linux上它们会看起来像这样。
- en: This recipe will re-implement the previous recipe's `BoxSizerPanel`, using these
    additional `Add` parameters to improve its layout, in order to show how these
    parameters can be used to influence how the sizer manages each of the controls
    that have been added to it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将重新实现之前的食谱中的`BoxSizerPanel`，使用这些额外的`Add`参数来改进其布局，以便展示这些参数如何被用来影响调整器如何管理添加到其中的每个控件。
- en: Getting Started
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门指南
- en: Before getting started on this recipe, make sure you have reviewed the previous
    recipe, *Using a BoxSizer*, as we will be modifying its `_DoLayout` method in
    this recipe to define some additional behaviors that the sizers should apply to
    its layout.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始这个菜谱之前，请确保你已经复习了之前的菜谱，*使用BoxSizer*，因为在这个菜谱中，我们将修改其`_DoLayout`方法以定义一些sizers应该应用到其布局中的额外行为。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here, we will make some modifications to the `SizerItems` proportions, flags,
    and borders to change the behavior of the layout:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将对`SizerItems`的比例、标志和边框进行一些修改，以改变布局的行为：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe just shows what we changed in the previous recipe's `__DoLayout`
    method to take advantage of some of these extra options. The first thing to notice
    in the section where we add the controls to the horizontal sizers is that we no
    longer have the `AddSpacer` calls. These have been replaced by specifying a border
    in the `Add` calls. When adding each of the labels we added two sizer flags, `ALIGN_CENTER_VERTICAL`
    and `RIGHT`. The first flag is an alignment flag that specifies the desired behavior
    of the alignment and the second is a border flag that specifies where we want
    the border parameter to be applied. In this case, the sizer will align the `StaticText`
    in the center of the vertical space and add a 5px padding to the right side of
    it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱仅展示了我们在上一个菜谱的 `__DoLayout` 方法中做了哪些改动以利用这些额外的选项。在添加控件到水平尺寸器的部分，首先要注意的是我们不再有
    `AddSpacer` 调用。这些调用已经被在 `Add` 调用中指定边框所取代。当我们添加每个标签时，我们添加了两个尺寸器标志，`ALIGN_CENTER_VERTICAL`
    和 `RIGHT`。第一个标志是一个对齐标志，它指定了对齐的期望行为，第二个是一个边框标志，它指定了我们要将边框参数应用到哪个位置。在这种情况下，尺寸器将把
    `StaticText` 对象对齐到垂直空间中央，并在其右侧添加5px的内边距。
- en: Next, where we add the `TextCtrl` objects to the sizer, we specified a `1` for
    the proportion and `EXPAND` for the sizer flag. Setting the proportion greater
    than the default of `0` will tell the sizer to give that control proportionally
    more of the space in the sizer's managed area. A proportion value greater than
    0 in combination with the `EXPAND` flag which tells the control to get bigger
    as space is available will let it stretch as the dialog is resized to a bigger
    size. Typically you will only need to specify `0` or `1` for the proportion parameter,
    but under some complex layouts it may be necessary to give different controls
    a relatively different amount of the total available space. For example, in a
    layout with two controls if both are given a proportion of 1, they would each
    get 50 percent of the space. Changing the proportion of one of the controls to
    2 would change the space allocation to a 66/33 percent balance.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们将 `TextCtrl` 对象添加到布局管理器时，我们指定了 `1` 作为比例值，并将布局管理器的标志设置为 `EXPAND`。将比例值设置为大于默认的
    `0`，将告诉布局管理器为该控件在布局管理器管理区域中分配更多空间。当比例值大于 `0` 并与 `EXPAND` 标志结合时，该标志指示控件在空间可用时增大，这将允许控件在对话框大小调整到更大时进行拉伸。通常，您只需要为比例参数指定
    `0` 或 `1`，但在某些复杂的布局中，可能需要为不同的控件分配相对不同数量的总可用空间。例如，在一个有两个控件的布局中，如果两个控件都被分配了比例值 `1`，那么它们各自将获得
    50% 的空间。将其中一个控件的比例值更改为 `2` 将改变空间分配为 66/33 的比例平衡。
- en: We also made some changes to the final layout with the vertical sizer. First,
    instead of using the regular `AddSpacer` function to add some static spacers to
    the layout, we changed it to use `AddStretchSpacer` instead. `AddStretchSpacer`
    is basically the equivalent of doing `Add((-1,-1), 1, wx.EXPAND)`, which just
    adds a spacer of indeterminate size that will stretch as the window size is changed.
    This allows us to keep the controls in the center of the dialog as its vertical
    size changes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用垂直尺寸调整器对最终布局做了一些修改。首先，我们不再使用常规的`AddSpacer`函数来向布局中添加一些静态间隔，而是改为使用`AddStretchSpacer`。`AddStretchSpacer`基本上等同于执行`Add((-1,-1),
    1, wx.EXPAND)`，这仅仅添加了一个不确定大小的间隔，当窗口大小改变时它会进行拉伸。这使得我们能够在对话框的垂直尺寸变化时保持控件位于中心。
- en: Finally, when adding the two horizontal sizers to the vertical sizer, we used
    some flags to apply a static 50px of spacing around the `LEFT, RIGHT`, and `TOP`
    or `BOTTOM` of the sizers. It's also important to notice that we once again passed
    the `EXPAND` flag. If we did not do this, the vertical sizer would not allow those
    two items to expand which in turn would nullify us adding the `EXPAND` flag for
    the `TextCtrl` objects. Try running this and the previous sample side-by-side
    and resizing each window to see the difference in behavior.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当将两个水平尺寸调整器添加到垂直尺寸调整器时，我们使用了一些标志来在尺寸调整器的`LEFT, RIGHT`和`TOP`或`BOTTOM`周围应用静态的50px间距。同样重要的是要注意，我们再次传递了`EXPAND`标志。如果我们没有这样做，垂直尺寸调整器将不允许这两个项目扩展，这反过来又会导致我们为`TextCtrl`对象添加的`EXPAND`标志失效。尝试将这个示例和上一个示例并排运行，并调整每个窗口的大小以查看行为差异。
- en: '![How it works...](img/1780_07_03.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1780_07_03.jpg)'
- en: The previous screenshot has had some lines drawn over it to show the five items
    that are managed by the main top level `VERTICAL` sizer `vsizer`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的截图上已经画了一些线条来展示由主顶级 `VERTICAL` 大小调整器 `vsizer` 管理的五个项目。
- en: There's more...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are a number of flags that can be used to affect the layout in various
    ways. The following three tables list the different categories of these flags
    that can be combined in the flag''s bitmask:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多标志可以用来以各种方式影响布局。以下三个表格列出了这些标志的不同类别，这些类别可以在标志的位掩码中组合：
- en: Alignment flags
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对齐标志
- en: 'This table shows a listing of all the alignment flags and a description of
    what each one does:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此表显示了所有对齐标志的列表以及每个标志的作用描述：
- en: '| Alignment flags | Description |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 对齐标志 | 描述 |'
- en: '| --- | --- |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `wx.ALIGN_TOP` | Align the item to the top of the available space |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `wx.ALIGN_TOP` | 将项目对齐到可用空间顶部 |'
- en: '| `wx.ALIGN_BOTTOM` | Align the item to the bottom of the available space |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `wx.ALIGN_BOTTOM` | 将项目对齐到可用空间的底部 |'
- en: '| `wx.ALIGN_LEFT` | Align the item to the left of the available space |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `wx.ALIGN_LEFT` | 将项目对齐到可用空间的左侧 |'
- en: '| `wx.ALIGN_RIGHT` | Align the item to the right of the available space |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `wx.ALIGN_RIGHT` | 将项目对齐到可用空间的右侧 |'
- en: '| `wx.ALIGN_CENTER_VERTICAL``wx.ALIGN_CENTRE_VERTICAL` | Align the item in
    the center of the vertical space |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `wx.ALIGN_CENTER_VERTICAL` | `wx.ALIGN_CENTRE_VERTICAL` | 将项目在垂直空间中居中对齐 |'
- en: '| `wx.ALIGN_CENTER_HORIZONTAL``wx.ALIGN_CENTRE_HORIZONTAL` | Align the item
    in the center of the horizontal space |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `wx.ALIGN_CENTER_HORIZONTAL` | `wx.ALIGN_CENTRE_HORIZONTAL` | 在水平空间中居中对齐项目
    |'
- en: Border flags
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边界旗帜
- en: 'The following flags can be used to control which side(s) of the control the
    border argument of the Sizer''s `Add` method is applied to:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标志可用于控制 Sizer 的 `Add` 方法的 `border` 参数应用于哪个（些）控制边：
- en: '| Border flags | Description |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 边界旗帜 | 描述 |'
- en: '| --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `wx.TOP` | Apply the border to the top of the item |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `wx.TOP` | 将边框应用于项目的顶部 |'
- en: '| `wx.BOTTOM` | Apply the border to the bottom of item |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `wx.BOTTOM` | 将边框应用于项目底部 |'
- en: '| `wx.LEFT` | Apply the border to the left of the item |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `wx.LEFT` | 应用到项目左侧的边框 |'
- en: '| `wx.RIGHT` | Apply the border to the right of the item |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `wx.RIGHT` | 将边框应用于项目的右侧 |'
- en: '| `wx.ALL` | Apply the border to all sides of the item |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `wx.ALL` | 将边框应用于项目的所有边 |'
- en: Behavior flags
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行为标志
- en: 'The sizer flags in this table can be used to control how a control is resized
    within a sizer:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此表中的尺寸标志可用于控制控件在尺寸调整器内的缩放方式：
- en: '| Behaviour flags | Description |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 行为标志 | 描述 |'
- en: '| --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `wx.EXPAND` | Item will expand to fill the space provided to it (`wx.GROW`
    is the same) |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `wx.EXPAND` | 项目将扩展以填充分配给它的空间 (`wx.GROW` 与之相同) |'
- en: '| `wx.SHAPED` | Similar to `EXPAND` but maintains the item''s aspect ratio
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `wx.SHAPED` | 与 `EXPAND` 类似，但保持项目的宽高比 |'
- en: '| `wx.FIXED_MINSIZE` | Don''t let the item become smaller than its initial
    minimum size |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `wx.FIXED_MINSIZE` | 不要让项目的大小小于其初始最小尺寸 |'
- en: '| `wx.RESERVE_SPACE_EVEN_IF_HIDDEN` | Don''t allow the sizer to reclaim an
    item''s space when it is hidden |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `wx.RESERVE_SPACE_EVEN_IF_HIDDEN` | 不允许调整器在项目隐藏时回收项目空间 |'
- en: See also
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Using a BoxSizer* recipe in this chapter for the basics of using a
    `BoxSizer`.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅本章中的*使用BoxSizer*配方，了解如何使用`BoxSizer`的基本方法。
- en: The *Laying out controls with the GridBagSizer* recipe in this chapter shows
    how to use one of the more complex sizer classes.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于“使用GridBagSizer布局控件”的配方展示了如何使用较为复杂的布局类之一。
- en: Laying out controls with the GridBagSizer
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GridBagSizer 布局控件
- en: There are a number of other types of sizers in wxPython, besides the `BoxSizer`,
    that are designed to help simplify different kinds of layouts. The `GridSizer,
    FlexGridSizer`, and `GridBagSizer` can be used to lay items out in a grid-like
    manner. The `GridSizer` provides a fixed grid layout where items are added into
    different "cells" in the grid. The `FlexGridSizer` is just like the `GridSizer`,
    except that the columns in the grid can be different widths. Finally, the `GridBagSizer`
    is similar to the `FlexGridSizer` but also allows items to span over multiple
    "cells" in the grid, which makes it possible to achieve layouts that can usually
    only be achieved by nesting several `BoxSizers`. This recipe will discuss the
    use of the `GridBagSizer`, and use it to create a dialog that could be used for
    viewing the details of a log event.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在wxPython中，除了`BoxSizer`之外，还有许多其他类型的`sizers`，它们被设计用来简化不同类型的布局。`GridSizer`、`FlexGridSizer`和`GridBagSizer`可以用来以网格状方式排列项目。`GridSizer`提供了一种固定网格布局，其中项目被添加到网格中的不同“单元格”中。`FlexGridSizer`与`GridSizer`类似，但网格中的列可以有不同宽度。最后，`GridBagSizer`与`FlexGridSizer`类似，但还允许项目跨越网格中的多个“单元格”，这使得实现通常只能通过嵌套多个`BoxSizers`才能实现的布局成为可能。本食谱将讨论`GridBagSizer`的使用，并使用它来创建一个对话框，该对话框可以用来查看日志事件的详细信息。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here we will create a custom `DetailsDialog` that could be used for viewing
    log messages or system events. It has two fields in it for displaying the type
    of message and the verbose message text:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个自定义的 `DetailsDialog`，它可以用于查看日志消息或系统事件。它包含两个字段，用于显示消息类型和详细的文本信息：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `GridBagSizer's Add` method of `GridBagSizer` takes some additional parameters
    compared to the other types of sizers. It is necessary to specify the grid position
    and optionally the number of columns and rows to span. We used this in our details
    dialog in order to allow the `TextCtrl` fields to span multiple columns and multiple
    rows in the case of the details field. The way this layout works can get a little
    complicated, so let's go over our `__DoLayout` method line-by-line to see how
    each of them affect the dialog's layout.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`GridBagSizer` 的 `Add` 方法与其他类型的 `sizer` 相比，需要一些额外的参数。必须指定网格位置，并且可选地指定跨越的列数和行数。我们在详情对话框中使用了这个方法，以便在详情字段的情况下允许
    `TextCtrl` 字段跨越多列和多行。这种布局的工作方式可能会有些复杂，所以让我们逐行查看我们的 `__DoLayout` 方法，看看它们是如何影响对话框布局的。'
- en: First, we create out `GridBagSizer`, and in its constructor we specify how much
    padding we want between the rows and columns. Next, we start adding our items
    to the sizer. The first item that we add is the type `StaticText` label, which
    we added at row 1, column 1\. This was done to leave some padding around the outside
    edge. Next, we added the `TextCtrl` to the right of the label at row 1, column
    2\. For this item, we also specified the span parameter to tell the item to span
    1 row and 15 columns. The column width is proportionally based upon the size of
    the first column in the grid.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个 `GridBagSizer`，并在其构造函数中指定了行与列之间想要的多余空间。接下来，我们开始向这个布局管理器中添加项目。我们添加的第一个项目是一个类型为
    `StaticText` 的标签，它位于第1行第1列。这样做是为了在边缘周围留出一些空间。然后，我们在第1行第2列的标签右侧添加了一个 `TextCtrl`。对于这个项目，我们还指定了跨度参数，告诉项目跨越1行和15列。列宽是按网格中第一列的大小成比例的。
- en: Next we add the details fields, starting with the details label, which is added
    at row 2, column 1, in order to line up with the type `StaticText` label. Since
    the details text may be long, we want it to span multiple rows. Hence, for its
    span parameter we specified for it to span 5 rows and 15 columns.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们添加详细字段，从详细标签开始，该标签添加在第2行第1列，以便与类型`StaticText`标签对齐。由于详细文本可能很长，我们希望它跨越多行。因此，对于其跨度参数，我们指定它跨越5行和15列。
- en: 'Finally, so that the padding around our controls on the bottom and right-hand
    side matches the top and left, we need to add a spacer to the right and bottom
    to create an extra column and row. Notice that for this step we need to take into
    account the span parameters of the previous items we added, so that our items
    do not overlap. Items cannot occupy the same column or row as any other item in
    the sizer. So first we add a spacer to row 2, column 17, to create a new column
    on the right-hand side of our `TextCtrl` objects. We specified column 17 because
    the `TextCtrl` objects start at column 2 and span 15 columns. Likewise, we did
    the same when adding one to the bottom, to take into account the span of the details
    text field. Note that instead of offsetting the first item in the grid and then
    adding spacers, it would have been easier to nest our `GridBagSizer` inside of
    a `BoxSizer` and specify a border. The approach in this recipe was done just to
    illustrate the need to account for an item''s span when adding additional items
    to the grid:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了使底部和右侧的控制周围的填充与顶部和左侧相匹配，我们需要在右侧和底部添加一个填充空间来创建额外的列和行。请注意，对于这一步，我们需要考虑之前添加的项目所占用的跨度参数，以确保我们的项目不会重叠。项目不能占用与sizer中任何其他项目相同的列或行。因此，我们首先在行2、列17处添加一个填充空间，以在`TextCtrl`对象的右侧创建一个新的列。我们指定列17是因为`TextCtrl`对象从列2开始，跨越15列。同样，我们在底部添加一个时也做了同样的事情，以考虑详细文本字段的范围。请注意，与先偏移网格中的第一个项目然后添加填充空间相比，将`GridBagSizer`嵌套在`BoxSizer`内部并指定边框会更简单。这个食谱中的方法只是为了说明在向网格添加额外项目时需要考虑项目跨度：
- en: '![How it works...](img/1780_07_04.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1780_07_04.jpg)'
- en: See the sample code that accompanies this chapter for a small application that
    uses this dialog.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅本章附带示例代码，了解使用此对话框的小型应用程序。
- en: See also
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Understanding proportions, flags, and borders* recipe in this chapter describes
    the use of sizer flags in detail.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于*理解比例、旗帜和边框*的配方详细描述了使用尺寸标志的方法。
- en: Standard dialog button layout
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准对话框按钮布局
- en: Each platform has different standards for how different dialog buttons are placed
    in the dialog. This is where the `StdDialogButtonSizer` comes into play. It can
    be used to add standard buttons to a dialog, and automatically take care of the
    specific platform standards for where the button is positioned. This recipe shows
    how to use the `StdDialogButtonSizer` to quickly and easily add standard buttons
    to a `Dialog`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每个平台对于如何在对话框中放置不同的对话框按钮都有自己的标准。这就是`StdDialogButtonSizer`发挥作用的地方。它可以用来向对话框添加标准按钮，并自动处理按钮具体位置的平台标准。本食谱展示了如何使用`StdDialogButtonSizer`快速轻松地向`Dialog`添加标准按钮。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here is the code for our custom message box class that can be used as a replacement
    for the standard `MessageBox` in cases where the application wants to display
    custom icons in their pop-up dialogs:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们自定义消息框类的代码，该类可以用作标准`MessageBox`的替代品，在应用程序需要在其弹出对话框中显示自定义图标的情况下使用：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Here, we created a custom `MessageBox` clone that can accept a custom `Bitmap`
    to display instead of just the standard icons available in the regular `MessageBox`
    implementation. This class is pretty simple, so let's jump into the `__DoLayout`
    method to see how we made use of the `StdDialogButtonSizer`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个自定义的 `MessageBox` 克隆，它可以接受一个自定义的 `Bitmap` 来显示，而不是仅仅使用常规 `MessageBox`
    实现中可用的标准图标。这个类相当简单，所以让我们跳转到 `__DoLayout` 方法，看看我们是如何利用 `StdDialogButtonSizer` 的。
- en: In `__DoLayout`, we first created some regular `BoxSizers` to do the main part
    of the layout, and then in one single line of code we created the entire layout
    for our buttons. To do this, we used the `CreateButtonSizer` method of the base
    `wx.Dialog` class. This method takes a bitmask of flags that specifies the buttons
    to create, then creates them, and adds them to a `StdDialogButtonSizer` that it
    returns. All we need to do after this is to add the sizer to our dialog's main
    sizer and we are done!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `__DoLayout` 函数中，我们首先创建了一些常规的 `BoxSizers` 来完成布局的主要部分，然后在一行代码中就创建了所有按钮的整个布局。为了实现这一点，我们使用了基类
    `wx.Dialog` 的 `CreateButtonSizer` 方法。此方法接受一个标志掩码，用于指定要创建的按钮，然后创建它们，并将它们添加到它返回的
    `StdDialogButtonSizer` 中。完成这些操作后，我们只需将该布局器添加到对话框的主布局器中，任务就完成了！
- en: The following screenshots show how the `StdDialogButtonSizer` handles the differences
    in platform standards.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了`StdDialogButtonSizer`如何处理平台标准之间的差异。
- en: 'For example, the **OK** and **Cancel** buttons on a dialog are ordered as **OK/Cancel**
    on Windows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对话框中的**确定**和**取消**按钮在Windows上的顺序是**确定/取消**：
- en: '![How it works...](img/1780_07_05.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1780_07_05.jpg)'
- en: On Macintosh OS X, the standard layout for the buttons is **Cancel/OK:**
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Macintosh OS X上，按钮的标准布局是**取消/确定**：
- en: '![How it works...](img/1780_07_06.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1780_07_06.jpg)'
- en: There's more...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Here is a quick reference to the flags that can be passed as a bitmask to the
    `CreateButtonSizer` method in order to create the buttons that the button sizer
    will manage:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个快速参考，列出了可以作为掩码传递给`CreateButtonSizer`方法的标志，以便创建按钮管理器将管理的按钮：
- en: '| Flags | Description |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 描述 |'
- en: '| --- | --- |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `wx.OK` | Creates an OK button |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `wx.OK` | 创建一个确定按钮 |'
- en: '| `wx.CANCEL` | Creates a Cancel button |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `wx.CANCEL` | 创建一个取消按钮 |'
- en: '| `wx.YES` | Creates a Yes button |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `wx.YES` | 创建一个“是”按钮 |'
- en: '| `wx.NO` | Creates a No button |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `wx.NO` | 创建一个“否”按钮 |'
- en: '| `wx.HELP` | Creates a Help button |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `wx.HELP` | 创建一个帮助按钮 |'
- en: '| `wx.NO_DEFAULT` | Sets the No button as the default |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `wx.NO_DEFAULT` | 设置“否”按钮为默认选项 |'
- en: See also
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating Stock Buttons* recipe in [Chapter 3](ch03.html "Chapter 3. Basic
    Building Blocks of a User Interface"), *Basic Building Blocks of a User Interface*
    discusses how to create common buttons from built-in IDs.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章。用户界面基本构建块")中的 *创建股票按钮* 菜单，*用户界面基本构建块* 讨论了如何从内置ID创建常用按钮。'
- en: The *Using a BoxSizer* recipe in this chapter discusses the basics of window
    layout using `BoxSizers`.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中关于*使用BoxSizer*的配方讨论了使用`BoxSizers`进行窗口布局的基础知识。
- en: Using XML resources
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 XML 资源
- en: XRC is a way of creating and design window layouts with XML resource files.
    The hierarchical nature of XML parallels that of an application's window hierarchy,
    which makes it a very sensible data format to serialize a window layout with.
    This recipe shows how to create and load a simple dialog with two `CheckBoxe`
    objects and two `Button` objects on it, from an XML resource file.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: XRC 是一种使用 XML 资源文件创建和设计窗口布局的方法。XML 的层次结构性质与应用程序窗口层次结构相平行，这使得它成为序列化窗口布局的非常合理的数据格式。本食谱展示了如何从一个
    XML 资源文件中创建和加载一个简单的对话框，该对话框上有两个 `CheckBoxe` 对象和两个 `Button` 对象。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Here is the XML for our dialog that we have in a file called `xrcdlg.xrc:`
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们存储在名为 `xrcdlg.xrc:` 的文件中的对话框的 XML 代码：
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When loaded, the above XML will generate the following dialog:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载上述 XML 时，将生成以下对话框：
- en: '![How to do it...](img/1780_07_07.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1780_07_07.jpg)'
- en: 'This is a minimal program to load this XML resource to make and show the dialog
    it represents:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个最小的程序，用于加载此XML资源以创建并显示它所代表的对话框：
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The XML in this recipe was created with the help of `xrced`, which is an XML
    resource editor tool that is a part of the wxPython tools package. The `object`
    tag is used to represent a class object. Nesting other objects inside is how the
    parent child relationship is represented with the XML. The `class` attribute of
    the `object` tag is what is used to specify the type of class to create. The values
    should be a class name and in the case of wxPython provided classes, they use
    the `wxWidgets` names, which are prefixed with "wx". To work with `XmlResource`
    classes, it is highly recommended to use a tool like `xrced` to generate the XML.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中的XML是在`xrced`的帮助下创建的，`xrced`是一个XML资源编辑工具，它是wxPython工具包的一部分。`object`标签用于表示类对象。通过在内部嵌套其他对象来表示XML中的父子关系。`object`标签的`class`属性用于指定要创建的类的类型。值应该是类名，在wxPython提供的类的情况下，它们使用`wxWidgets`的名称，这些名称以“wx”为前缀。为了与`XmlResource`类一起工作，强烈建议使用像`xrced`这样的工具来生成XML。
- en: In order to load the XML to create the object(s) that are used for representation,
    you need to import the `wx.xrc` package, which provides the `XmlResource` class.
    There are a few ways to use `XmlResource` to perform the transformations on the
    XML. In this example, we created our `XmlResource` object by passing the path
    to our `xrc` file in its constructor. This object has a number of load methods
    for instantiating different types of objects. We want to load a dialog, so we
    called its `LoadDialog` method, passing a parent window as the first argument
    and then the name of the dialog we want to load from the XML. It will then instantiate
    an instance of that dialog and return it so that we can show it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 XML 加载以创建用于表示的对象，您需要导入 `wx.xrc` 包，它提供了 `XmlResource` 类。有几种方法可以使用 `XmlResource`
    对 XML 进行转换。在这个例子中，我们通过将 `xrc` 文件的路径传递给其构造函数来创建我们的 `XmlResource` 对象。此对象具有多种加载方法，用于实例化不同类型的对象。我们想要加载一个对话框，因此我们调用了它的
    `LoadDialog` 方法，将父窗口作为第一个参数传递，然后是我们要从 XML 中加载的对话框的名称。然后它将实例化该对话框的一个实例并返回，这样我们就可以显示它了。
- en: There's more...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Included below are some additional references to features available when using
    the XRC library.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下包含了一些在使用 XRC 库时可用功能的附加参考。
- en: Loading other types of resources
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载其他类型的资源
- en: 'The `XmlResource` object has methods for loading many different kinds of resources
    from XML. Here is quick reference to some of the additional methods:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`XmlResource` 对象提供了从 XML 加载多种不同类型资源的方法。以下是其中一些附加方法的快速参考：'
- en: '| Methods | Description |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `LoadBitmap(name)` | Loads and returns the Bitmap identified by name |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `LoadBitmap(name)` | 加载并返回由名称标识的位图 |'
- en: '| `LoadDialog(parent, name)` | Loads and returns the Dialog identified by name
    |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `LoadDialog(parent, name)` | 加载并返回名为name的对话框 |'
- en: '| `LoadFrame(parent, name)` | Loads and returns the Frame identified by name
    |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `LoadFrame(parent, name)` | 加载并返回由名称标识的 Frame |'
- en: '| `LoadIcon(name)` | Loads and returns the Icon identified by name |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `LoadIcon(name)` | 加载并返回由名称标识的图标 |'
- en: '| `LoadMenu(name)` | Loads and returns the Menu identified by name |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `LoadMenu(name)` | 加载并返回由名称标识的菜单 |'
- en: '| `LoadMenuBar(parent, name)` | Loads and returns the MenuBar identified by
    name |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `LoadMenuBar(parent, name)` | 加载并返回由名称标识的菜单栏 |'
- en: '| `LoadPanel(parent, name)` | Loads and returns the Panel identified by name
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `LoadPanel(parent, name)` | 加载并返回由名称标识的Panel |'
- en: '| `LoadToolBar(parent, name)` | Loads and returns the ToolBar identified by
    name |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `LoadToolBar(parent, name)` | 加载并返回由名称标识的工具栏 |'
- en: Specifying standard IDs
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定标准ID
- en: In order to give an object a standard ID in XRC, it should be specified in the
    `object` tag's `name` attribute, using the `wxWidgets` naming for the ID (that
    is, `wxID_OK` without the '.').
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在XRC中给一个对象赋予一个标准的ID，应在`object`标签的`name`属性中指定，使用`wxWidgets`的命名方式为ID（即，`wxID_OK`，不带`.`）。
- en: See also
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Making a custom resource handler* recipe in this chapter contains some
    additional information on using XRC.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *制作自定义资源处理器* 菜谱包含了一些关于使用 XRC 的额外信息。
- en: Making a custom resource handler
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义资源处理器
- en: Although XRC has built-in support for a large number of the standard controls,
    any non-trivial application will use its own subclasses and/or custom widgets.
    Creating a custom `XmlResource` class will allow these custom classes to be loaded
    from an XML resource file. This recipe shows how to create an XML resource handler
    for a custom `Panel` class and then use that handler to load the resource.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管XRC内置了对大量标准控件的支持，但任何非平凡的应用程序都将使用自己的子类和/或自定义小部件。创建一个自定义的`XmlResource`类将允许这些自定义类从XML资源文件中加载。本菜谱展示了如何创建一个用于自定义`Panel`类的XML资源处理器，然后使用该处理器来加载资源。
- en: Getting Started
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门指南
- en: This recipe discusses how to customize and extend the handling of XML resources.
    Please review the *Using XML resources* recipe in this chapter to learn the basics
    of how XRC works.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱讨论了如何自定义和扩展对XML资源的处理。请查阅本章中的*使用XML资源*食谱，以了解XRC工作的基础知识。
- en: How to do it...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In the following code, we will show how to create a custom XML resource handler
    for a Panel and then how to use XRC to load that resource into a Frame:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将展示如何为Panel创建一个自定义的XML资源处理器，然后如何使用XRC将该资源加载到Frame中：
- en: '[PRE10]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, in our Frame subclass, we simply create an instance of our custom resource
    handler and use it to load our custom Panel:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在我们的Frame子类中，我们简单地创建了一个自定义资源处理器的实例，并使用它来加载我们的自定义Panel：
- en: '[PRE11]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is the Panel class that our custom resource handler will be used to create.
    It is just a simple Panel with a `TextCtrl` and two `Buttons` on it:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们自定义资源处理器将要使用的Panel类。它只是一个简单的Panel，上面有一个`TextCtrl`和两个`Buttons`：
- en: '[PRE12]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, here is our custom XML resource handler class, where we just have
    to override two methods to implement the handling for our `TextEditPanel` class:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是我们的自定义 XML 资源处理类，我们只需重写两个方法来实现对 `TextEditPanel` 类的处理：
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `TextEditPanel` is our custom class that we want to create a custom resource
    handler for. The `TextEditPanelXmlHandler` class is a minimal resource handler
    that we created to be able to load our class from XML. This class has two required
    overrides that need to be implemented for it to function properly. The first is
    `CanHandle`, which is called by the framework to check if the handler can handle
    a given node type. We used the `IsOfClass` method to check if the node was of
    the same type as our `TextEditPanel`. The second is `DoCreateResource`, which
    is what is called to create our class. To create the class, all of its arguments
    can be retrieved from the resource handler.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextEditPanel` 是我们想要为其创建自定义资源处理器的自定义类。`TextEditPanelXmlHandler` 类是一个最小化的资源处理器，我们创建它以便能够从
    XML 加载我们的类。这个类有两个必须实现的重写方法，以便它能正常工作。第一个是 `CanHandle`，它被框架调用以检查处理器是否可以处理给定的节点类型。我们使用了
    `IsOfClass` 方法来检查节点是否与我们的 `TextEditPanel` 类型相同。第二个是 `DoCreateResource`，它是用来创建我们的类的。为了创建这个类，所有它的参数都可以从资源处理器中检索到。'
- en: 'The `XrcTestFrame` class is where we made use of our custom resource handler.
    First, we created an `EmptyXmlResource` object and used its `InsertHandler` method
    to add our custom handler to it. Then we loaded the XML from the `RESOURCE` string
    that we defined using the handler''s `LoadFromString` method. After that, all
    there was to do was load the object using the resource''s `LoadObject` method,
    which takes three arguments: the `parent` window of the object to be loaded, the
    `name` of the object in the XML resource, and the `classname`.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`XrcTestFrame` 类是我们使用自定义资源处理器的位置。首先，我们创建了一个 `EmptyXmlResource` 对象，并使用它的 `InsertHandler`
    方法将其自定义处理器添加到其中。然后，我们使用处理器的 `LoadFromString` 方法从我们定义的 `RESOURCE` 字符串中加载 XML。之后，我们只需使用资源的
    `LoadObject` 方法加载对象即可，该方法需要三个参数：要加载的对象的 `parent` 窗口、XML 资源中对象的 `name` 以及 `classname`。'
- en: See also
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Understanding inheritance limitations* recipe in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with wxPython"), *Getting Started with wxPython* for
    some additional information about overriding virtual methods in wxPython classes.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第1章](ch01.html "第1章. wxPython入门")中的*理解继承限制*配方，在*wxPython入门*中获取有关wxPython类中重写虚拟方法的一些额外信息。
- en: See the *Using XML resources* recipe in this chapter for more examples of using
    XML to create screen layouts.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅本章中的*使用XML资源*配方，以获取更多使用XML创建屏幕布局的示例。
- en: Using the AuiFrameManager
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AuiFrameManager
- en: The `AuiFrameManager` is part of the Advanced User Interface (wx.aui) library
    added to wxPython in 2.8\. It allows a Frame to have a very user customizable
    interface. It automatically manages children windows in panes that can be undocked
    and turned into separate floating windows. There are also some built-in features
    to help with persisting and restoring the window's layout during running the application.
    This recipe will create a Frame base class that has AUI support and will automatically
    save its perspective and reload it when the application is next launched.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuiFrameManager` 是wxPython 2.8版本中添加的先进用户界面（wx.aui）库的一部分。它允许框架拥有一个非常用户可定制的界面。它自动管理可以在窗格中解绑并转换为独立浮动窗口的子窗口。此外，还有一些内置功能，有助于在应用程序运行期间持久化和恢复窗口布局。本菜谱将创建一个具有AUI支持的框架基类，并在应用程序下次启动时自动保存其视角并重新加载。'
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The following code will define a base class that encapsulates some of the usage
    of an `AuiManager:`
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将定义一个基类，该类封装了`AuiManager`的一些用法：
- en: '[PRE14]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`OnAuiBaseClose` will be called when the Frame closes. We use this as the point
    to get the current window layout perspective and save it for the next time the
    application is launched:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当框架关闭时将调用 `OnAuiBaseClose`。我们利用这个点来获取当前窗口布局视角并将其保存，以便下次应用程序启动时使用：
- en: '[PRE15]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`AddPane` simply wraps getting access to the Frame''s `AuiManager` and adds
    the given pane and `auiInfo` to it:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddPane` 简单地封装了对 Frame 的 `AuiManager` 的访问，并将给定的面板和 `auiInfo` 添加到其中：'
- en: '[PRE16]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The next method is simply a convenience method for creating and adding the
    main center pane to the managed window:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下一种方法是一个简单的便利方法，用于创建并添加主中心面板到管理窗口：
- en: '[PRE17]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This final method is used to load the last saved window layout from the last
    time the window was opened:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这种最终方法用于从上次打开窗口时加载最后保存的窗口布局：
- en: '[PRE18]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created a class to help encapsulate some of the `AuiManager's`
    functionality. So let's take a look at some of the functionality that this class
    provides, and how it works.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一个类来帮助封装一些`AuiManager`的功能。所以，让我们来看看这个类提供的一些功能以及它是如何工作的。
- en: The `__init__` method is where we create the `AuiManager` object that will manage
    the panes that we want to add to the Frame. The `AuiManager` accepts a number
    of possible flags to dictate its behavior. We employed a small workaround for
    a bug on Linux platforms that use desktop compositing. Using the transparent docking
    hints can cause an AUI application to crash in this scenario, so we replaced it
    with the venetian blind style instead.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__` 方法是我们创建将要添加到 Frame 中的 `AuiManager` 对象的地方。`AuiManager` 接受一系列可能的标志来指定其行为。我们针对使用桌面合成的
    Linux 平台上的一个错误采用了一个小的解决方案。使用透明停靠提示可能导致在此场景下 AUI 应用程序崩溃，因此我们将其替换为百叶窗样式。'
- en: '`OnAuiBaseClose` is used as an event handler for when the `Frame` closes. We
    use this as a hook to automatically store the current layout of the `AuiManager`,
    which is called a perspective, for the next application launch. To implement this
    feature, we have created a requirement that the App object''s `SetName` method
    was called to set the application name because we need this in order to use `wx.Config`.
    The `wx.Config` object is simply an interface used to access the Registry on Windows
    or an application configuration file on other platforms. `SavePerspective` returns
    a string encoded with all of the information that the `AuiManager` needs in order
    to restore the current window layout. The application can then simply call our
    `LoadDefaultPerspective` method when the application starts up, in order to restore
    the user''s last window layout.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnAuiBaseClose` 被用作处理 `Frame` 关闭时的事件处理器。我们使用这个钩子来自动存储 `AuiManager` 的当前布局，这被称为视角，以便于下一次应用程序启动。为了实现这个功能，我们创建了一个要求，即调用
    App 对象的 `SetName` 方法来设置应用程序名称，因为我们需要这个来使用 `wx.Config`。`wx.Config` 对象是一个简单的接口，用于访问
    Windows 上的注册表或在其他平台上的应用程序配置文件。`SavePerspective` 返回一个字符串，其中包含了 `AuiManager` 需要的所有信息，以便恢复当前窗口布局。然后，应用程序可以在启动时简单地调用我们的
    `LoadDefaultPerspective` 方法，以恢复用户的最后窗口布局。'
- en: The other two methods in this class are quite simple and are provided simply
    for convenience to delegate to the `AuiManager` of the `Frame`. The `AddPane`
    method of the `AuiManager` is how to add panes to be managed by it. The `pane`
    argument needs to be a window object that is a child of the `Frame`. In practice,
    this is usually some sort of `Panel` subclass. The `auiInfo` argument is an `AuiPaneInfo`
    object. This is what the `AuiManager` uses to determine how to manage the pane.
    See the sample code that accompanies this recipe for an example of this class
    in action.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本类中的另外两种方法相当简单，主要是为了方便将任务委托给`Frame`的`AuiManager`。`AuiManager`的`AddPane`方法是用来添加由它管理的面板。`pane`参数需要是一个`Frame`的子窗口对象。在实践中，这通常是一些`Panel`子类的实例。`auiInfo`参数是一个`AuiPaneInfo`对象。这是`AuiManager`用来确定如何管理面板的依据。请参阅随本食谱附带的示例代码，以了解此类在实际中的应用。
- en: There's more...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Here is a quick reference to the flags that can be used in the flags bitmask
    for the `AuiManager` in order to customize its behavior and the styles of some
    of its components:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关于可用于`AuiManager`标志掩码中的标志的快速参考，以便自定义其行为以及某些组件的样式：
- en: '| Flags | Description |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 描述 |'
- en: '| --- | --- |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `AUI_MGR_DEFAULT` | Equivalent of `AUI_MGR_ALLOW_FLOATING&#124; AUI_MGR_TRANSPARENT_HINT&#124;
    AUI_MGR_HINT_FADE&#124; AUI_MGR_NO_VENETIAN_BLINDS_FADE` |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `AUI_MGR_DEFAULT` | 等同于 `AUI_MGR_ALLOW_FLOATING&#124; AUI_MGR_TRANSPARENT_HINT&#124;
    AUI_MGR_HINT_FADE&#124; AUI_MGR_NO_VENETIAN_BLINDS_FADE` |'
- en: '| `AUI_MGR_ALLOW_FLOATING` | Allow for floating panes |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `AUI_MGR_ALLOW_FLOATING` | 允许浮动窗格 |'
- en: '| `AUI_MGR_ALLOW_ACTIVE_PANE` | Highlight the caption bar of the currently-active
    pane |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `AUI_MGR_ALLOW_ACTIVE_PANE` | 高亮显示当前活动窗格的标题栏 |'
- en: '| `AUI_MGR_HINT_FADE` | Fade docking hints out of view |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `AUI_MGR_HINT_FADE` | 淡出视图中的停靠提示 |'
- en: '| `AUI_MGR_LIVE_RESIZE` | Resize panes while the sash between them is being
    dragged |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `AUI_MGR_LIVE_RESIZE` | 在拖动它们之间的分割条时调整窗格大小 |'
- en: '| `AUI_MGR_NO_VENETIAN_BLINDS_FADE` | Disable the venetian blind fade in/out
    |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `AUI_MGR_NO_VENETIAN_BLINDS_FADE` | 禁用百叶窗淡入/淡出功能 |'
- en: '| `AUI_MGR_RECTANGLE_HINT` | Show a simple rectangle docking hint when dragging
    floating panes |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `AUI_MGR_RECTANGLE_HINT` | 显示拖动浮动窗格时的简单矩形停靠提示 |'
- en: '| `AUI_MGR_TRANSPARENT_DRAG` | Make floating panes partially-transparent when
    they are being dragged |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `AUI_MGR_TRANSPARENT_DRAG` | 在拖动时使浮动面板部分透明 |'
- en: '| `AUI_MGR_TRANSPARENT_HINT` | Show a partially-transparent light blue docking
    hint when dragging floating panels |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `AUI_MGR_TRANSPARENT_HINT` | 显示在拖动浮动面板时部分透明的浅蓝色停靠提示 |'
- en: '| `AUI_MGR_VENETIAN_BLINDS_HINT` | Use a venetian blind style docking hint
    for floating panels |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `AUI_MGR_VENETIAN_BLINDS_HINT` | 使用威尼斯百叶风格停靠提示为浮动面板 |'
