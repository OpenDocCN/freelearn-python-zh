["```py\n# Task management Request model - internal only\nclass CreateTaskRequest:\n    \"\"\"Data structure for task creation requests.\"\"\"\n    title: str\n    description: str\n    project_id: Optional[str] = None\n\n    def to_execution_params(self) -> dict:\n        \"\"\"Convert validated request data to use case parameters.\"\"\"\n        return {\n            'title': self.title.strip(),\n            'project_id': UUID(self.project_id)\n            if self.project_id else None,\n            'description': self.description.strip()\n        } \n```", "```py\n# API Request DTO - now a public contract\nclass CreateTaskRequest:\n    title: str\n    description: str\n    project_id: Optional[str] = None \n```", "```py\n# Task management - manual validation\nclass CreateTaskRequest:\n    \"\"\"Request data for creating a new task.\"\"\"\n    title: str\n    description: str\n\n    def __post_init__(self):\n        if not self.title.strip():\n            raise ValueError(\"Title cannot be empty\")\n\n    def to_execution_params(self) -> dict:\n        return {\"title\": self.title.strip(),\n                \"description\": self.description.strip()} \n```", "```py\n# FastAPI/Pydantic - automatic validation\nfrom pydantic import BaseModel, Field\nclass CreateTaskRequest(BaseModel):\n    title: str = Field(..., min_length=1)\n    description: str \n```", "```py\n# How validation works with FastAPI/Pydantic\n@app.post(\"/tasks/\")\ndef create_task(task_data: CreateTaskRequest):\n    # FastAPI has already validated all fields\n    # Invalid requests are rejected with 422 Unprocessable Entity\n\n    result = task_controller.handle_create(\n        title=task_data.title,\n        description=task_data.description\n    )\n    return result.success \n```", "```py\n{\n  \"title\": \"\",\n  \"description\": \"Test description\"\n} \n```", "```py\n{\n  \"detail\": [\n    {\n      \"loc\": [\"body\", \"title\"],\n      \"msg\": \"ensure this value has at least 1 characters\",\n      \"type\": \"value_error.any_str.min_length\",\n      \"ctx\": {\"limit_value\": 1}\n    }\n  ]\n} \n```", "```py\n# Pure Clean Architecture approach with FastAPI\n@app.post(\"/tasks/\")\ndef create_task(task_data: CreateTaskRequest):  # Using Pydantic here is fine - we're in the Frameworks layer\n    # Transform the Pydantic model to our internal domain model\n    # to avoid letting Pydantic penetrate inner layers\n    request = InternalCreateTaskRequest(\n        title=task_data.title.strip(),\n        description=task_data.description.strip()\n    )\n\n    # Pass our internal model to the controller\n    result = task_controller.handle_create(request)\n    return result.success \n```", "```py\n# Framework layer (infrastructure/api/routes.py)\n@app.post(\"/tasks/\", response_model=TaskResponse, status_code=201)\ndef create_task(task_data: CreateTaskRequest):\n    \"\"\"Create a new task.\"\"\"\n    # The controller handles translation between API and domain\n    result = task_controller.handle_create(\n        title=task_data.title,\n        description=task_data.description,\n        project_id=task_data.project_id\n    )\n\n    if not result.is_success:\n        # Error handling at the framework boundary\n        raise HTTPException(status_code=400, detail=result.error.message)\n\n    return result.success  # Automatic serialization to TaskResponse \n```", "```py\n# Anti-pattern: Domain entity directly publishing events\nclass Task:\n    def complete(self, user_id: UUID):\n        self.status = TaskStatus.DONE\n        self.completed_at = datetime.now()\n        self.completed_by = user_id\n\n        # Direct dependency on messaging system –\n        # violates Clean Architecture\n        kafka_producer = KafkaProducer(bootstrap_servers='kafka:9092')\n        event_data = {\n            \"task_id\": str(self.id),\n            \"completed_by\": str(user_id),\n            \"completed_at\": self.completed_at.isoformat()\n        }\n        kafka_producer.send(\n            'task_events',\n            json.dumps(event_data).encode()\n        ) \n```", "```py\n# Clean domain entity - no messaging dependencies\nclass Task:\n    def complete(self, user_id: UUID) -> None:\n        if self.status == TaskStatus.DONE:\n            raise ValueError(\"Task is already completed\")\n        self.status = TaskStatus.DONE\n        self.completed_at = datetime.now()\n        self.completed_by = user_id \n```", "```py\n# Application layer handles event creation\n@dataclass\nclass CompleteTaskUseCase:\n    task_repository: TaskRepository\n    # Abstract interface, not implementation:\n    event_publisher: EventPublisher\n\n    def execute(self, task_id: UUID, user_id: UUID) -> Result:\n        try:\n            task = self.task_repository.get_by_id(task_id)\n            task.complete(user_id)\n            self.task_repository.save(task)\n\n            # Create domain event and publish through abstract interface\n            event = TaskCompletedEvent.from_task(task, user_id)\n            self.event_publisher.publish(event)\n\n            return Result.success(task)\n        except ValueError as e:\n            return Result.failure(Error(str(e))) \n```", "```py\n# ADR-001: Use of Pydantic Models in Domain Layer\n## Status\nAccepted\n## Context\nOur API-first system requires extensive validation and serialization. Implementing these capabilities manually would require significant effort and potentially introduce bugs. Pydantic provides robust validation, serialization, and documentation through type annotations.\n## Decision\nWe will allow Pydantic models in our domain layer, treating it as a stable extension to Python's type system rather than a volatile third-party dependency.\n## Consequences\n* Positive: Reduced boilerplate, improved validation, better documentation\n* Positive: Consistent validation across system boundaries\n* Negative: Creates dependency on external library in inner layers\n* Negative: May complicate testing of domain entities\n## Compliance\nWhen using Pydantic in domain entities:\n* Keep models focused on data structure, not behavior\n* Avoid Pydantic-specific features that don't relate to validation\n* Include comprehensive tests to verify domain rules still apply \n```"]