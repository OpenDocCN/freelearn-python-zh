- en: Improving Our API and Adding Authentication to it with Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will improve the capabilities of the RESTful API that we
    started in the previous chapter and we will add authentication-related security
    to it. We will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Improve unique constraints in the models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the differences between the `PUT` and the `PATCH` methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update fields for a resource with the `PATCH` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code a generic pagination class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add pagination features to the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the steps to add authentication and permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a user model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a schema to validate, serialize, and deserialize users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add authentication to resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create resource classes to handle users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run migrations to generate the user table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compose requests with the necessary authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving unique constraints in the models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we coded the `NotificationCategory` model in the previous chapter, we specified
    the `True` value for the `unique` argument in the creation of the `orm.Column`
    instance named `name`. As a result, the migrations process generated the necessary
    unique constraint to make sure that the `name` field has unique values in the
    `notification_category` table. This way, the PostgreSQL database won't allow us
    to insert duplicate values for the `notification_category.name` column. However,
    the error message generated when we try to do so is not clear. The message includes
    details about the database structure that shouldn't be mentioned in the error
    message.
  prefs: []
  type: TYPE_NORMAL
- en: Run the following command to create a category with a duplicate ...
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the differences between the PUT and the PATCH methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTTP `PUT` and `PATCH` methods have different purposes. The HTTP `PUT` method
    is meant to replace an entire resource. The HTTP `PATCH` method is meant to apply
    a delta to an existing resource.
  prefs: []
  type: TYPE_NORMAL
- en: Our API is able to update a single field for an existing resource, and therefore,
    we provide an implementation for the `PATCH` method. For example, we can use the
    `PATCH` method to update an existing notification and set the value for its `displayed_once`
    and `displayed_times` fields to `true` and `1`.
  prefs: []
  type: TYPE_NORMAL
- en: We don't want to use the `PUT` method to update two fields because this method
    is meant to replace an entire notification. The `PATCH` method is meant to apply
    a delta to an existing notification, and therefore, it is the appropriate method
    to just change the value of those two fields.
  prefs: []
  type: TYPE_NORMAL
- en: Updating fields for a resource with the PATCH method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we will compose and send an HTTP request to update an existing notification,
    specifically, to update the value of the `displayed_once` and `displayed_times`
    fields. Because we just want to update two fields, we will use the `PATCH` method
    instead of `PUT`. Make sure you replace `2` with the ID or primary key of an existing
    notification in your configuration. The code file for the sample is included in
    the `restful_python_2_03_01` folder, in the `Flask01/cmd307.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_03_01` folder, in the `Flask01/cmd308.txt
    ...`
  prefs: []
  type: TYPE_NORMAL
- en: Coding a generic pagination class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, the table that persists the notifications in the database has just
    a few rows. However, after we start working with our API encapsulated in a microservice
    in a real-life production environment, we will have hundreds of notifications,
    and therefore, we will have to deal with large result sets. We don't want an HTTP
    `GET` request to retrieve 1,000 notifications in a single call. Thus, we will
    create a generic pagination class and we will use it to easily specify how we
    want large results sets to be split into individual pages of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will compose and send HTTP `POST` requests to create nine notifications
    that belong to one of the notification categories we have created: `Information`.
    This way, we will have a total of 12 messages persisted in the database. We had
    three messages and we add nine more. The code file for the sample is included
    in the `restful_python_2_03_01` folder, in the `Flask01/cmd309.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The following are the equivalent `curl` commands. The code file for the sample
    is included in the `restful_python_2_03_01` folder, in the `Flask01/cmd310.txt`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The previous commands will compose and send nine HTTP `POST` requests with the
    specified JSON key-value pairs. The requests specify `/service/notifications/`,
    and therefore, they will match `'/notifications/'` and run the `NotificationListResource.post`
    method, that is, the `post` method for the `NotificationListResource` class.
  prefs: []
  type: TYPE_NORMAL
- en: After running the previous commands, we will have 12 notifications persisted
    in our PostgreSQL database. However, we don't want to retrieve the 12 messages
    when we compose and send an HTTP `GET` request to `/service/notifications/`. We
    will create a customizable generic pagination class to include a maximum of four
    resources in each individual page of data.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `config.py` file within the `service` folder and add the following
    lines that declare two variables that configure the global pagination settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `service/config.py` file and add the following lines that declare
    two variables that configure the global pagination settings. The code file for
    the sample is included in the `restful_python_2_03_01` folder, in the `Flask01/service/config.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The value for the `PAGINATION_PAGE_SIZE` variable specifies a global setting
    with the default value for the page size, also known as limit. The value for `PAGINATION_PAGE_ARGUMENT_NAME`
    specifies a global setting with the default value for the argument name that we
    will use in our requests to specify the page number we want to retrieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `helpers.py` file within the `service` folder. The following lines
    show the code that creates a new `PaginationHelper` class. The code file for the
    sample is included in the `restful_python_2_03_01` folder, in the `Flask01/service/helpers.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PaginationHelper` class declares a constructor, that is, the `__init__`
    method, which receives the following arguments and uses them to initialize the
    attributes with the same names:'
  prefs: []
  type: TYPE_NORMAL
- en: '`request`: The Flask request object that will allow the `paginate_query` method
    to retrieve the page number value specified with the HTTP request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`query`: The SQLAlchemy query that the `paginate_query` method has to paginate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource_for_url`: A string with the resource name that the `paginate_query`
    method will use to generate the full URLs for the previous page and the next page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`key_name`: A string with the key name that the `paginate_query` method will
    use to return the serialized objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema`: The Flask-Marshmallow `Schema` subclass that the `paginate_query`
    method must use to serialize the objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, the constructor reads and saves the values for the configuration
    variables we added to the `config.py` file in the `page_size` and `page_argument_name`
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The class declares the `paginate_query` method. First, the code retrieves the
    page number specified in the request and saves it in the `page_number` variable.
    If no page number is specified, the code assumes that the request requires the
    first page. Then, the code calls the `self.query.paginate` method to retrieve
    the page number specified by `page_number` of the paginated result of objects
    from the database, with a number of results per page indicated by the value of
    the `self.page_size` attribute. The next line saves the paginated items from the
    `paginated_object.items` attribute in the `objects` variable.
  prefs: []
  type: TYPE_NORMAL
- en: If the value for the `paginated_objects.has_prev` attribute is `True`, it means
    that there is a previous page available. In this case, the code calls the `flask.url_for`
    function to generate the full URL for the previous page with the value of the
    `self.resource_for_url` attribute. The `_external` argument is set to `True` because
    we want to provide the full URL.
  prefs: []
  type: TYPE_NORMAL
- en: If the value for the `paginated_objects.has_next` attribute is `True`, it means
    that there is a next page available. In this case, the code calls the `flask.url_for`
    function to generate the full URL for the next page with the value of the `self.resource_for_url`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code calls the `self.schema.dump` method to serialize the partial
    results previously saved in the `objects` variable, with the `many` argument set
    to `True`. The `dumped_objects` variable saves the reference to the `data` attribute
    of the results returned by the call to the `dump` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the method returns a dictionary with the following key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Key | Value |'
  prefs: []
  type: TYPE_TB
- en: '| `self.key_name` | The serialized partial results saved in the `dumped_objects`
    variable. |'
  prefs: []
  type: TYPE_TB
- en: '| `''previous''` | The full URL for the previous page saved in the `previous_page_url`
    variable. |'
  prefs: []
  type: TYPE_TB
- en: '| `''next''` | The full URL for the next page saved in the `next_page_url`
    variable. |'
  prefs: []
  type: TYPE_TB
- en: '| `''count''` | The total number of objects available in the complete result
    set retrieved from the `paginated_objects.total` attribute. |'
  prefs: []
  type: TYPE_TB
- en: Adding pagination features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the `views.py` file within the `service` folder and replace the code for
    the `NotificationListResource.get` method with the highlighted lines in the next
    listing. In addition, make sure that you add the highlighted import statement.
    The code file for the sample is included in the `restful_python_2_03_01` folder,
    in the `Flask01/service/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The new code for the ...
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the steps to add authentication and permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our current version of the API processes all the incoming requests without requiring
    any kind of authentication. We will use a Flask extension and other packages to
    use an HTTP authentication scheme to identify the user that originated the request
    or the token that signed the request. Then, we will use these credentials to apply
    the permissions that will determine whether the request must be permitted or not.
    Unluckily, neither Flask nor Flask-RESTful provide an authentication framework
    that we can easily plug and configure. Thus, we will have to write code to perform
    many tasks related to authentication and permissions.
  prefs: []
  type: TYPE_NORMAL
- en: We want to be able to create a new user without any authentication. However,
    all the other API calls are only going to be available for authenticated users.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will install the `Flask-HTTPAuth` Flask extension to make it easier
    for us to work with HTTP authentication and the `passlib` package to allow us
    to hash a password and check whether a provided password is valid or not.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a new `User` model that will represent a user. The model will
    provide methods to allow us to hash a password and verify whether a password provided
    for a user is valid or not. We will create a `UserSchema` class to specify how
    we want to serialize and deserialize a user.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will configure the Flask extension to work with our `User` model to
    verify passwords and set the authenticated user associated with a request. We
    will make changes to the existing resources to require authentication and we will
    add new resources to allow us to retrieve existing users and create a new one.
    Finally, we will configure the routes for the resources related to users.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have completed the previously mentioned tasks, we will run the migrations
    process to generate the new table that persists the users in the database. Then,
    we will compose and send HTTP requests to understand how the authentication and
    permissions work with our new version of the API.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you quit Flask's development server. You just need to press Ctrl +
    C in the Terminal or Command Prompt window in which it is running.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will install many additional packages. Make sure you have activated
    the virtual environment we have created in [Chapter 1](dbf75cef-4962-4e40-8192-03873b774c48.xhtml),
    *Developing RESTful APIs and Microservices with Flask 1.0.2*, and we named `Flask01`.
    After you activate the virtual environment, it is time to run many commands that
    will be the same for either macOS, Linux, or Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will edit the existing `requirements.txt` file to specify the additional
    set of packages that our application requires to be installed in any supported
    platform. This way, it will be extremely easy to repeat the installation of the
    specified packages with their versions in any new virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your favorite editor to edit the existing text file named `requirements.txt`
    within the root folder for the virtual environment. Add the following lines after
    the last line to declare the additional packages and the versions that our new
    version of the API requires. The code file for the sample is included in the `restful_python_2_03_02`
    folder, in the `Flask01/requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Each additional line added to the `requirements.txt` file indicates the package
    and the version that needs to be installed. The following table summarizes the
    packages and the version numbers that we specified as additional requirements
    to the previously included packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Package name | Version to be installed |'
  prefs: []
  type: TYPE_TB
- en: '| `Flask-HTTPAuth` | 3.2.4 |'
  prefs: []
  type: TYPE_TB
- en: '| `passlib` | 1.7.1 |'
  prefs: []
  type: TYPE_TB
- en: 'Now we must run the following command on macOS, Linux, or Windows to install
    the additional packages and the versions explained in the previous table with
    `pip` by using the recently edited `requirements.txt` file. Make sure you are
    in the folder that has the `requirements.txt` file before running the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines for the output will indicate that all the new packages and their
    dependencies have been successfully installed. If you downloaded the source code
    for the example and you didn''t work with the previous version of the API, `pip`
    will also install the other packages included in the `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Adding a user model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we will create the model that we will use to represent and persist a user.
    Open the `models.py` file within the `service` folder and add the following lines
    after the declaration of the `ResourceAddUpdateDelete` class. Make sure that you
    add the highlighted import statements. The code file for the sample is included
    in the `restful_python_2_03_02` folder, in the `Flask01/service/models.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Creating schemas to validate, serialize, and deserialize users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we will create the Flask-Marshmallow schema that we will use to validate,
    serialize, and deserialize the previously declared `User` model. Open the `models.py`
    file within the `service` folder and add the following code after the existing
    lines. The code file for the sample is included in the `restful_python_2_03_02`
    folder, in the `Flask01/service/models.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The code declares the `UserSchema` schema, specifically a subclass of the `ma.Schema`
    class. Remember that the previous code we wrote for the `service/models.py` file
    created a `flask_marshmallow.Mashmallow` instance named `ma`.
  prefs: []
  type: TYPE_NORMAL
- en: We declare the attributes that represent fields as instances of the appropriate
    class declared in the `marshmallow.fields` module. The `UserSchema` class declares
    the `name` attribute as an instance of `fields.String`. The `required` argument
    is set to `True` to specify that the field cannot be an empty string. The `validate`
    argument is set to `validate.Length(5)` to specify that the field must have a
    minimum length of five characters.
  prefs: []
  type: TYPE_NORMAL
- en: The validation for the password isn't included in the schema. We will use the
    `check_password_strength_and_hash_if_ok` method defined in the `User` class to
    validate the password.
  prefs: []
  type: TYPE_NORMAL
- en: Adding authentication to resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we will perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure the `Flask-HTTPAuth` extension to work with our `User` model to verify
    passwords and set the authenticated user associated with a request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare a custom function that the `Flask-HTTPAuth` extension will use as a
    callback to verify a password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new base class for our resources that will require authentication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `views.py` file within the `service` folder and add the following
    code after the last line that uses the `import` statement and before the lines
    that declare the `Blueprint` instance named `service_blueprint`. The code file
    for the sample is included in the `restful_python_2_03_02` folder, in the `Flask01/service/views.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Creating resource classes to handle users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just want to be able to create users and use them to authenticate requests.
    Thus, we will just focus on creating resource classes with just a few methods.
    We won't create a complete user management system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create the resource classes that represent the user and the collection
    of users. First, we will create a `UserResource` class, which we will use to represent
    a user resource. Open the `views.py` file within the `service` folder and add
    the following lines after the line that creates the `Api` instance named `service`
    and before the declaration of the `NotificationResource` class. The code file
    for the sample is included in the `restful_python_2_03_02` folder, in the `Flask01/service/views.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `UserResource` class is a subclass of the previously coded `AuthenticationRequiredResource`
    and declares a `get` method that will be called when the HTTP method with the
    same name arrives as a request on the represented resource.
  prefs: []
  type: TYPE_NORMAL
- en: The method receives the id of the user that has to be retrieved in the `id`
    argument. The code calls the `User.query.get_or_404` method to return an HTTP
    `404 Not Found` status if there is no user with the requested id in the underlying
    database. If the user exists, the code calls the `user_schema.dump` method with
    the retrieved user as an argument to use the `UserSchema` instance to serialize
    the `User` instance whose `id` matches the specified `id`. The `dump` method takes
    the `User` instance and applies the field filtering and output formatting specified
    in the `UserSchema` class. The field filtering specifies that we don't want the
    hash for the password to be serialized. The code returns the `data` attribute
    of the result returned by the `dump` method, that is, the serialized message in
    JSON format as the body, with the default HTTP `200 OK` status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will create the `UserListResource` class that we will use to represent
    the collection of users. Open the `views.py` file within the `service` folder
    and add the following lines after the code that creates the `UserResource` class.
    The code file for the sample is included in the `restful_python_2_03_02` folder,
    in the `Flask01/service/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UserListResource` class is a subclass of the `flask_restful.Resource`
    superclass because we don''t want all the methods to require authentication. We
    want to be able to create a new user without being authenticated, and therefore,
    we apply the `@auth.login_required` decorator only for the `get` method. The `post`
    method doesn''t require authentication. The class declares the following two methods
    that will be called when the HTTP method with the same name arrives as a request
    on the represented resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get`: This method returns a list with all the `User` instances persisted in
    the database. First, the code calls the `User.query.all` method to retrieve all
    the `User` instances. Then, the code calls the `user_schema.dump` method with
    the retrieved users and the `many` argument set to `True` to serialize the iterable
    collection of objects. The `dump` method will take each `User` instance retrieved
    from the database and apply the field filtering and output formatting specified
    the `UserSchema` class. The code returns the `data` attribute of the result returned
    by the `dump` method, that is, the serialized messages in JSON format as the body,
    with the default HTTP `200 OK` status code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`post`: This method retrieves the key-value pairs received in the JSON body,
    creates a new `User` instance and persists it in the database. First, the code
    calls the `request.get_json` method to retrieve the key-value pairs received as
    arguments with the request. Then, the code calls the `user_schema.validate` method
    to validate the new user built with the retrieved key-value pairs. In this case,
    the call to this method will just validate the `name` field for the user. If there
    were validation errors, the code returns a tuple composed of the validation errors
    and an HTTP `400 Bad Request` status code. If the validation is successful, the
    code checks whether a user with the same name already exists in the database or
    not to return an appropriate error for the field that must be unique. If the username
    is unique, the code creates a new user with the specified `name` and calls its
    `check_password_strength_and_hash_if_ok` method. If the provided password fulfills
    all the quality requirements, the code persists the user with the hash for its
    password in the database. Finally, the code returns a tuple composed of the serialized
    saved user in JSON format as the body, with the HTTP `201 Created` status code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table shows the methods of our previously created classes related
    to users that we want to be executed for each combination of HTTP verb and scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '| HTTP verb | Scope | Class and method | Requires authentication |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Collection of users | `UserListResource.get` | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | User | `UserResource.get` | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Collection of users | `UserListResource.post` | No |'
  prefs: []
  type: TYPE_TB
- en: 'We must make the necessary resource routing configurations to call the appropriate
    methods and pass them all the necessary arguments by defining URL rules. The following
    lines configure the resource routing for the user-related resources to the `service`
    object. Open the `views.py` file within the `service` folder and add the following
    lines at the end of the code. The code file for the sample is included in the
    `restful_python_2_03_02` folder, in the `Flask01/service/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Each call to the `service.add_resource` method routes a URL to one of the previously
    coded user-related resources. When there is a request to the API, and the URL
    matches one of the URLs specified in the `service.add_resource` method, Flask
    will call the method that matches the HTTP verb in the request for the specified
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Running migrations to generate the user table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will run many scripts to run migrations and generate the necessary table
    to persist users in the PostgreSQL 10.5 database. Make sure you run the scripts
    in the Terminal or Command Prompt window in which you have activated the virtual
    environment and that you are located in the `service` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the first command that populates the migration script with the detected
    changes in the models. In this case, it is the second time we populate the migration
    script, and therefore, the migration script will generate the new table that will
    persist our new `User` model: `user`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The following lines show the sample output generated after running the previous
    command. Your output will ...
  prefs: []
  type: TYPE_NORMAL
- en: Composing requests with the necessary authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we will compose and send an HTTP request to retrieve the first page of
    the notifications without authentication credentials. The code file for the sample
    is included in the `restful_python_2_03_01` folder, in the `Flask01/cmd317.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_03_01` folder, in the `Flask01/cmd318.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive a `401 Unauthorized` status code in the response header. The
    following lines show a sample response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to retrieve notification, that is, to make a `GET` request to `/service/notifications/`,
    we need to provide authentication credentials by using HTTP authentication. However,
    before we can do this, it is necessary to create a new user. We will use the new
    user to test our new resource classes related to users and our changes in the
    permissions policies. Run the following command to create a new user. The code
    file for the sample is included in the `restful_python_2_03_01` folder, in the
    `Flask01/cmd319.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_03_01` folder, in the `Flask01/cmd320.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the creation of a user and the execution of the methods that require
    authentication should only be possible under HTTPS. This way, the username and
    the password would be encrypted. The microservice that encapsulates the API in
    production must work under HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: The previous command will compose and send an HTTP `POST` request with the specified
    JSON key-value pairs. The request specifies `/service/users/`, and therefore,
    it will match the `'/users/'` URL route for the `UserList` resource and run the
    `UserList.post` method that doesn't require authentication. The method doesn't
    receive arguments because the URL route doesn't include any parameters. As the
    HTTP verb for the request is `POST`, Flask calls the `post` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previously specified password only includes lowercase letters, and therefore,
    it doesn''t fulfill all the qualitative requirements we have specified for the
    passwords in the `User.check_password_strength_and_hash_if_ok` method. Thus, we
    will receive a `400 Bad Request` status code in the response header and the error
    message indicating the requirement that the password didn''t fulfill the quality
    requirements in the JSON body. The following lines show a sample response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will create a user with a valid password. The code file
    for the sample is included in the `restful_python_2_03_01` folder, in the `Flask01/cmd321.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_03_01` folder, in the `Flask01/cmd322.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If the new `User` instance is successfully persisted in the database, the call
    will return an HTTP `201 Created` status code and the recently persisted `User`
    serialized to JSON in the response body. The following lines show an example response
    for the HTTP request, with the new `User` object in the JSON responses. Notice
    that the response includes the URL, `url`, for the created user and doesn''t include
    any information related to the password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the previously explained command to check the contents of the `user`
    table that the migrations created in the PostgreSQL database. We will notice that
    the `password_hash` field contents are hashed for the new row in the `user` table.
    The following screenshot shows the contents for the new row of the `user` table
    in a PostgreSQL database after running the HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f485275a-696b-4908-b9a6-1bf1317daee4.png)'
  prefs: []
  type: TYPE_IMG
- en: If we want to retrieve the first page of notifications, that is, to make an
    HTTP `GET` request to `/service/notifications/`, we need to provide authentication
    credentials using HTTP authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will compose and send an HTTP request to retrieve the first page of
    messages with authentication credentials, that is, with the username we have recently
    created and his password. The code file for the sample is included in the `restful_python_2_03_01`
    folder, in the `Flask01/cmd323.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command. The code file for the sample
    is included in the `restful_python_2_03_01` folder, in the `Flask01/cmd324.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The user will be successfully authenticated and we will be able to process the
    request to retrieve the first page of the notifications persisted in the database.
    With all the changes we have made to our API, unauthenticated requests can only
    create a new user.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see whether you can answer the following questions correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Which HTTP verb is meant to replace an entire resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PATCH`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`POST`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PUT`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which HTTP verb is meant to apply a delta to an existing resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PATCH`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`POST`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PUT`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, the `passlib` library will use the SHA-512 scheme for 64-bit platforms
    with the minimum number of rounds set to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 135,000
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 335,000
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 535,000
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `flask.g` object is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A proxy that provides access to the current request
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An instance of the `flask_httpauth.HTTPBasicAuth` class
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A proxy that allows us to store on this whatever we want to share for one request
    only
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `passlib` package provides:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A password hashing framework that supports more than 30 schemes
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An authentication framework ...
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we improved the RESTful API in many ways. We added user-friendly
    error messages for when resources aren't unique. We tested how to update single
    or multiple fields with the `PATCH` method and we created our own generic pagination
    class to enable us to paginate result sets.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we started working with authentication and permissions. We added a user
    model and we updated the underlying PostgreSQL database. We made many changes
    in the different pieces of code to achieve a specific security goal and we took
    advantage of `Flask-HTTPAuth` and `passlib` to use HTTP authentication in our
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have built an improved a complex API that uses pagination and authentication,
    we will use additional abstractions included in the framework and we will code,
    execute and improve unit tests to get ready to encapsulate our API in a microservice,
    which are the topics of the next chapter.
  prefs: []
  type: TYPE_NORMAL
