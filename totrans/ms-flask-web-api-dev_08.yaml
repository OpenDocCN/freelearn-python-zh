- en: <st c="0">8</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">Building Workflows with Flask</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="31">Workflows are sequences or groups of repetitive tasks, activities,
    or small processes that require a complete start-to-end execution to satisfy a
    particular business process.</st> <st c="207">Each task is equivalent to routinary
    transactions such as sending emails, running scripts or terminal commands, data
    transformation and serialization, database transactions, and other highly computational
    operations.</st> <st c="424">These tasks can be simple sequence, parallel, and</st>
    <st c="474">complex types.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="488">Several tools and platforms can provide best practices, rules, and
    technical specifications to build workflows for industry, enterprise, and scientific
    problems.</st> <st c="651">However, most of these solutions require Java more
    than Python as their core language.</st> <st c="738">Now, the main goal of this
    chapter is to prove that Python, particularly the Flask framework, can simulate
    workflows that utilize</st> **<st c="868">Business Process Modeling Notation</st>**
    <st c="902">(</st>**<st c="904">BPMN</st>**<st c="908">) and also</st> **<st c="920">non-BPMN</st>**
    <st c="928">workflows using popular and modern platforms such as</st> *<st c="982">Zeebe/Camunda</st>*<st
    c="995">,</st> *<st c="997">Airflow 2.0</st>*<st c="1008">, and</st> *<st c="1014">Temporal</st>*<st
    c="1022">. Moreover, the chapter will also showcase the use of</st> *<st c="1076">Celery
    tasks</st>* <st c="1088">in building custom workflows for</st> <st c="1122">Flask
    applications.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1141">This chapter will cover the following topics that will discuss
    the different mechanisms and procedures in implementing workflow activities with
    the</st> <st c="1290">Flask framework:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1306">Building workflows with</st> <st c="1331">Celery tasks</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1343">Creating BPMN and non-BPMN workflows</st> <st c="1381">with SpiffWorkflow</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1399">Building service tasks with the</st> <st c="1432">Zeebe/Camunda
    platforms</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1455">Using Airflow 2.x in orchestrating</st> <st c="1491">API endpoints</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1504">Implementing workflows</st> <st c="1528">using Temporal.io</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1545">Technical requirements</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1568">This chapter aims to implement</st> *<st c="1600">Doctor’s Appointment
    Management Software</st>* <st c="1640">that uses workflows to implement its business
    processes.</st> <st c="1698">It has the following five different Flask projects,
    showcasing the varying workflow solutions to build the</st> <st c="1805">Flask
    application:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="1823">ch08-celery-redis</st>`<st c="1841">, which focuses on designing
    dynamic workflows with</st> <st c="1893">Celery tasks.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="1906">ch08-spiff-web</st>`<st c="1921">, which implements a web application
    for the appointment system using the</st> <st c="1995">SpiffWorkflow library.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="2017">ch08-temporal</st>`<st c="2031">, which uses the Temporal platform
    to build</st> <st c="2075">distributed architecture.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="2100">ch08-zeebe</st>`<st c="2111">, which utilizes the Zeebe/Camunda
    platform for</st> <st c="2159">BPMN workflows.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="2174">ch08-airflow</st>`<st c="2187">, which integrates with the Airflow
    2.x workflow engine to manage</st> <st c="2253">API services.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2266">Although with different workflow solutions, each of these projects
    targets the practical and optimal process performance for the</st> *<st c="2396">user’s
    login transactions</st>*<st c="2421">,</st> *<st c="2423">appointment processes</st>*<st
    c="2444">,</st> *<st c="2446">doctor engagement</st>*<st c="2463">,</st> *<st
    c="2465">billing processes</st>*<st c="2482">, and</st> *<st c="2488">releasing
    transactions</st>*<st c="2510">. All database transactions are relational and
    use PostgreSQL as their database.</st> <st c="2591">All these projects, on the
    other hand, are available</st> <st c="2644">at</st> [<st c="2647">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch08</st>](https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch08)<st
    c="2728">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2729">Building workflows with Celery tasks</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2766">Utilizing</st> **<st c="2777">Celery</st>** <st c="2783">as a task
    queue manager and</st> **<st c="2812">Redis</st>** <st c="2817">as its broker
    was part of our</st> [*<st c="2848">Chapter 5</st>*](B19383_05.xhtml#_idTextAnchor111)
    <st c="2857">content.</st> <st c="2867">The chapter explicitly discussed all setups
    and installations to build Flask-Celery-Redis integration.</st> <st c="2970">It
    also</st> <st c="2977">expounded on how Celery can run background processes asynchronously
    outside the context of Flask’s request-response transaction.</st> <st c="3107">Additionally,
    this chapter will show us another feature of Celery that can solve business</st>
    <st c="3197">process optimization.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3218">Celery has a mechanism to build dynamic workflows, types of workflows
    that run outside the bounds of some schema definitions and rules from start to
    end of workflow activities.</st> <st c="3396">Its first requirement is</st> <st
    c="3420">to wrap all tasks</st> <st c="3439">in</st> *<st c="3442">signatures</st>*<st
    c="3452">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3453">Creating task signatures</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="3478">In a typical scenario, calling Celery tasks requires invoking directly
    its</st> `<st c="3554">delay()</st>` <st c="3561">method to run the underlying
    process the standard way or</st> `<st c="3619">apply_async()</st>` <st c="3632">to
    run it asynchronously.</st> <st c="3659">But to manage</st> <st c="3672">Celery
    tasks to build custom dynamic workflows, individual tasks must invoke the</st>
    `<st c="3754">signature()</st>` <st c="3765">or</st> `<st c="3769">s()</st>` <st
    c="3772">method first.</st> <st c="3787">This allows passing the Celery task invocation
    to workflow operations, linking a Celery task to another task as callbacks after
    its successful execution, and also helps manage its inputs, arguments, and execution
    options.</st> <st c="4009">A signature is like a wrapper to a task ready to be
    passed as an argument to Celery’s</st> <st c="4095">workflow operations.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4115">The following</st> `<st c="4130">add_login_task_wrapper()</st>`
    <st c="4154">task, for instance, can be wrapped inside a signature just by calling
    its</st> `<st c="4229">signature()</st>` <st c="4240">or</st> `<st c="4244">s()</st>`
    <st c="4247">method:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'add_login_task_wrapper.signature(<st c="4936">s()</st> equivalent with a typical
    parameter list containing the arguments, as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <st c="6964">from modules.login.services.workflow_tasks import add_user_login_task_wrapper,
    add_user_profile_task_wrapper, show_complete_login_task_wrapper</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="7107">@login_bp.post(''/login/user/add'')</st> async def add_user_workflow():'
  prefs: []
  type: TYPE_NORMAL
- en: user_json = request.get_json()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: user_str = dumps(user_json) <st c="7232">task = chain(add_user_login_task_wrapper.s(user_str),</st>
    <st c="7285">add_user_profile_task_wrapper.s(),</st> <st c="7320">show_complete_login_task_wrapper.s())()</st><st
    c="7360">result = task.get()</st> records = loads(result)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return jsonify(profile=records), 201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '@shared_task(ignore_result=False) <st c="8567">def add_user_login_task_wrapper(details):</st>
    async def add_user_task(<st c="8633">details</st>):'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'async with db_session() as sess:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'async with sess.begin():'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: repo = LoginRepository(sess) <st c="8737">details_dict = loads(details)</st>
    … … … … … …
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: login = Login(**user_dict)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: result = await repo.insert_login(login)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if result:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: profile_details = dumps(details_dict)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return profile_details
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return ""
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'except Exception as e:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return ""
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'return <st c="9014">details</st> parameter is the complete JSON details passed
    from the endpoint function to the <st c="9102">s()</st> method so that the task
    will retrieve only the *<st c="9153">login credentials</st>* for the *<st c="9179">INSERT</st>*
    login transaction. Now, the task will return the remaining details, the user profile
    information, as input to the next task in the sequence, <st c="9327">add_user_profile_task_wrapper()</st>.
    The following code shows the presence of a local parameter in the <st c="9426">add_user_profile_task_wrapper()</st>
    task that will receive the result of the previous task:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: <st c="12243">from modules.admin.services.reports_tasks import generate_csv_admin_task_wrapper,</st>
    <st c="12325">generate_csv_doctor_task_wrapper,</st> <st c="12359">generate_csv_patient_task_wrapper</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="12393">@admin_bp.get(''/admin/reports/create'')</st> async def create_reports():'
  prefs: []
  type: TYPE_NORMAL
- en: admin_csv_filename = os.getcwd() + "/files/dams_admin.csv"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: patient_csv_filename = os.getcwd() + "/files/dams_patient.csv"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: doctor_csv_filename = os.getcwd() + "/files/dams_doc.csv" <st c="12641">workflow
    = group(</st><st c="12658">generate_csv_admin_task_wrapper.s(admin_csv_filename),</st>
    <st c="12713">generate_csv_doctor_task_wrapper.s(</st><st c="12749">doctor_csv_filename),</st>
    <st c="12771">generate_csv_patient_task_wrapper.s(</st><st c="12808">patient_csv_filename))()</st><st
    c="12833">workflow.get()</st> return jsonify(message="done backup"), 201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: <st c="13811">from modules.admin.services.doctor_stats_tasks import count_patients_doctor_task_wrapper,
    count_request_doctor_task_wrapper, create_doctor_stats_task_wrapper</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="13969">@admin_bp.get(''/admin/doc/stats'')</st> async def derive_doctor_stats():'
  prefs: []
  type: TYPE_NORMAL
- en: docid = request.args.get("docid") <st c="14071">workflow =</st> <st c="14081">chord((count_patients_doctor_task_wrapper.s(docid),
    count_request_doctor_task_wrapper.s(docid)), create_doctor_stats_task_wrapper.s(docid))()</st><st
    c="14223">result = workflow.get()</st> return jsonify(message=result), 201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: pip install spiffworkflow
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: pip install lxml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: pip install celery
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: from SpiffWorkflow.bpmn.workflow import BpmnWorkflow
  prefs: []
  type: TYPE_NORMAL
- en: from SpiffWorkflow.camunda.parser.CamundaParser import CamundaParser
  prefs: []
  type: TYPE_NORMAL
- en: from SpiffWorkflow.bpmn.specs.defaults import ScriptTask
  prefs: []
  type: TYPE_NORMAL
- en: from SpiffWorkflow.camunda.specs.user_task import UserTask
  prefs: []
  type: TYPE_NORMAL
- en: from SpiffWorkflow.task import Task, TaskState
  prefs: []
  type: TYPE_NORMAL
- en: from SpiffWorkflow.util.deep_merge import DeepMerge <st c="23145">parser = CamundaParser()</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23169">filepath = os.path.join("bpmn/dams_appointment.bpmn")</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23223">parser.add_bpmn_file(filepath)</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="23304">add_bpmn_file()</st> function of the API will load the BPMN file,
    while the <st c="23375">get_spec()</st> function will parse the document starting
    with the process definition ID call. Now, *<st c="23470">Figure 8</st>**<st c="23478">.5</st>*
    shows a snapshot of the BPMN file with the process definition ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – A snapshot of a BPMN file containing the process definition
    ID](img/B19383_08_005.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: <st c="24570">Figure 8.5 – A snapshot of a BPMN file containing the process
    definition ID</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="24645">After activating SpiffWorkflow with its parser, the next step
    is to build web flows through the view functions.</st> <st c="24758">The</st>
    <st c="24761">view implementations will be a series of page redirections that
    will gather all the necessary form data values for the</st> *<st c="24881">user
    tasks</st>* <st c="24891">of the BPMN workflow.</st> <st c="24914">The following</st>
    `<st c="24928">choose_specialization()</st>` <st c="24951">view will be the first
    web form to start since it will simulate the</st> **<st c="25020">Doctor’s Specialization</st>**
    **<st c="25044">Form</st>** <st c="25048">task:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '@doc_bp.route("/doctor/select", methods = ["GET", "POST"])'
  prefs: []
  type: TYPE_NORMAL
- en: 'async def select_doctor():'
  prefs: []
  type: TYPE_NORMAL
- en: 'if request.method == "GET":'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return render_template("doc_doctors_form.html")
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: session['docid'] = request.form['docid']
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return redirect(url_for("doc_bp.reserve_schedule") )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: <st c="26144">@doc_bp.route("/doctor/schedule",</st><st c="26178">methods =
    ["GET", "POST"])</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="26205">async def reserve_schedule():</st> if request.method == "GET":
    <st c="26264">return render_template("doc_schedule_form.html"), 201</st> session[''appt_date'']
    = request.form[''appt_date'']'
  prefs: []
  type: TYPE_NORMAL
- en: 'session[''appt_time''] = request.form[''appt_time''] <st c="26505">provide_patient_details()</st>,
    will trigger the workflow execution besides its goal to extract the patient information
    required for the appointment scheduling and consolidate it with the other details
    from the previous views. The following is the code for the <st c="26761">provide_patient_details()</st>
    view:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*<st c="28271">Session handling</st>* <st c="28288">provides the</st> `<st
    c="28302">provide_patient_details()</st>` <st c="28327">view with the ability
    to gather all appointment details from the previous web views.</st> <st c="28413">As
    depicted in the given code, all session data, including</st> <st c="28471">the
    patient details from its form, are placed in its</st> `<st c="28525">form_data</st>`
    <st c="28534">dictionary.</st> <st c="28547">Utilizing the session is a workaround
    because it is not feasible to fuse the workflow loops required by the SpiffWorkflow
    library and the web flows.</st> <st c="28696">The last redirected page must initiate
    the workflow with the</st> `<st c="28757">BpmnWorkflow</st>` <st c="28769">class.</st>
    <st c="28777">But what is the difference between the</st> `<st c="28816">CamundaParser</st>`
    <st c="28829">and</st> `<st c="28834">BpmnWorkflow</st>` <st c="28846">API classes?</st>
    <st c="28860">We answer this question in the</st> <st c="28891">next section.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="28904">Distinguishing between workflow specifications and instances</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="28965">There are two categories of components in SpiffWorkflow:</st>
    *<st c="29023">specification</st>* <st c="29036">and</st> *<st c="29041">instance</st>*
    <st c="29049">objects.</st> `<st c="29059">CamundaParser</st>`<st c="29072">,
    through</st> <st c="29082">its</st> `<st c="29086">get_spec()</st>` <st c="29096">method,
    returns a</st> `<st c="29115">WorkflowSpec</st>` <st c="29127">instance object,
    a specification or model object that defines the BPMN workflow.</st> <st c="29209">On
    the other hand,</st> `<st c="29228">BpmnWorkflow</st>` <st c="29240">creates a</st>
    `<st c="29251">Workflow</st>` <st c="29259">instance object, which tracks and
    returns actual workflow activities.</st> <st c="29330">However,</st> `<st c="29339">BpmnWorkflow</st>`
    <st c="29351">requires the workflow specification object as its constructor parameter</st>
    <st c="29424">before instantiation.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="29445">The workflow instance will provide all sequence flows from the
    start until the stop event and the tasks with their corresponding state.</st>
    <st c="29582">All the states, such as</st> `<st c="29606">READY</st>`<st c="29611">,</st>
    `<st c="29613">CANCELLED</st>`<st c="29622">,</st> `<st c="29624">COMPLETED</st>`<st
    c="29633">, and</st> `<st c="29639">FUTURE</st>`<st c="29645">, are indicated
    in the</st> `<st c="29668">TaskState</st>` <st c="29677">API coupled with hook
    methods found in the</st> `<st c="29721">Task</st>` <st c="29725">instance object.</st>
    <st c="29743">But how does SpiffWorkflow determine a BPMN task?</st> <st c="29793">We
    will see that in the</st> <st c="29817">next section.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="29830">Identifying between task specifications and instances</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="29884">As with the workflow, each SpiffWorkflow task has a specification
    object called</st> `<st c="29965">TaskSpec</st>`<st c="29973">, which provides
    details such as the</st> *<st c="30010">name of the task definition</st>* <st
    c="30037">and</st> *<st c="30042">task type</st>*<st c="30051">, such as</st>
    `<st c="30061">UserTask</st>` <st c="30069">or</st> `<st c="30073">ScriptTask</st>`<st
    c="30083">. On the other hand, the task instance object is named</st> `<st c="30138">Task</st>`<st
    c="30142">. The workflow instance</st> <st c="30165">object provides</st> `<st
    c="30182">get_tasks()</st>` <st c="30193">overrides that give all tasks based
    on a specific state or</st> `<st c="30253">TaskSpec</st>` <st c="30261">instance.</st>
    <st c="30272">Moreover, it has</st> `<st c="30289">get_task_from_id()</st>` <st
    c="30307">to extract the</st> `<st c="30323">Task</st>` <st c="30327">instance
    object based on</st> *<st c="30353">task ID</st>*<st c="30360">,</st> `<st c="30362">get_task_spec_from_name()</st>`
    <st c="30387">to retrieve the</st> `<st c="30404">TaskSpec</st>` <st c="30412">name
    based on its indicated BPMN name, and</st> `<st c="30456">get_tasks_from_spec_name()</st>`
    <st c="30482">to retrieve all tasks based on a</st> `<st c="30516">TaskSpec</st>`
    <st c="30524">definition name.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="30541">To traverse and track every</st> `<st c="30570">UserTask</st>`<st
    c="30578">,</st> `<st c="30580">ManualTask</st>`<st c="30590">, or</st> `<st c="30595">Gateway</st>`
    <st c="30602">task and their trailing</st> `<st c="30627">ScriptTask</st>` <st
    c="30637">task(s) based on the BPMN diagram starting from</st> `<st c="30686">StartEvent</st>`<st
    c="30696">, invoke the</st> `<st c="30709">do_engine_steps()</st>` <st c="30726">of
    the workflow instance.</st> <st c="30753">A loop must call the</st> `<st c="30774">do_engine_steps()</st>`
    <st c="30791">method to track every activity in the workflow, including events
    and</st> `<st c="30861">ScriptTask</st>` <st c="30871">tasks until it reaches</st>
    `<st c="30895">EndEvent</st>`<st c="30903">. Thus,</st> `<st c="30911">provide_patient_details()</st>`
    <st c="30936">has a</st> `<st c="30943">while</st>` <st c="30948">loop in the</st>
    `<st c="30961">POST</st>` <st c="30965">transaction to traverse the workflow and
    execute every</st> `<st c="31021">Task</st>` <st c="31025">object with the</st>
    `<st c="31042">run_task_from_id()</st>` <st c="31060">method of the</st> <st c="31075">workflow
    instance.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="31093">But running tasks, specifically</st> `<st c="31126">UserTask</st>`
    <st c="31134">and</st> `<st c="31139">ScriptTask</st>`<st c="31149">, is not only
    concerned with the fulfillment of the workflow activity but also the passing of
    some</st> <st c="31248">task data.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="31258">Passing form data to UserTask</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="31288">UserTask</st>`<st c="31297">’s form fields are among the several
    sources of BPMN workflow data.</st> <st c="31366">The Camunda Modeler allows the
    BPMN</st> <st c="31402">designer to create form variables for each</st> `<st c="31445">UserTask</st>`
    <st c="31453">task.</st> *<st c="31460">Figure 8</st>**<st c="31468">.6</st>*
    <st c="31470">shows the three form fields, namely</st> `<st c="31507">patientid</st>`<st
    c="31516">,</st> `<st c="31518">ticketid</st>`<st c="31526">, and</st> `<st c="31532">priority_level</st>`<st
    c="31546">, of the</st> **<st c="31555">Patient Detail Form</st>** <st c="31574">task
    and the portion of the Camunda Modeler where to add</st> <st c="31632">form variables:</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Adding form fields to UserTask](img/B19383_08_006.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: <st c="31777">Figure 8.6 – Adding form fields to UserTask</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="31820">The presence of form fields in a custom-generated form requires
    data passing to these form variables through the view function.</st> <st c="31949">Form
    fields without values will yield exceptions that can halt workflow</st> <st c="32021">executions,
    eventually ruining the Flask application.</st> <st c="32075">The</st> `<st c="32079">while</st>`
    <st c="32084">loop in the following code snippet of the</st> `<st c="32127">provide_patient_details()</st>`
    <st c="32152">view calls an</st> `<st c="32167">upload_login_form_data()</st>`
    <st c="32191">custom method that assigns values from the</st> `<st c="32235">form_data</st>`
    <st c="32244">dictionary to each</st> `<st c="32264">UserTask</st>` <st c="32272">form
    variable:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: <st c="33232">The</st> `<st c="33237">upload_login_form_data()</st>` <st c="33261">method
    determines each form field through its</st> *<st c="33308">ID</st>* <st c="33310">and
    extracts its appropriate</st> <st c="33340">value from the</st> `<st c="33355">form_data</st>`
    <st c="33364">dictionary.</st> <st c="33377">Then, the custom method, shown in
    the following snippet, assigns the value to the form field and uploads the field-value
    pair as</st> *<st c="33506">workflow data</st>* <st c="33519">using the</st> `<st
    c="33530">DeepMerge</st>` <st c="33539">utility class</st> <st c="33554">of SpiffWorkflow:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: <st c="33779">Technically,</st> `<st c="33793">update_data()</st>` <st c="33806">creates
    a dictionary object containing the field name as the key and its corresponding</st>
    `<st c="33894">form_data</st>` <st c="33903">value.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="33910">But how about</st> `<st c="33925">ScriptTask</st>`<st c="33935">?
    Can it have</st> <st c="33948">form variables, too?</st> <st c="33970">Let’s explore
    that in the</st> <st c="33996">next section.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="34009">Adding input variables to ScriptTask</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="34046">ScriptTask</st>` <st c="34057">can also have input variables
    but not form fields.</st> <st c="34109">These input variables also need values
    from the view function</st> <st c="34171">because these are essential parts of
    its expressions.</st> <st c="34225">Sometimes,</st> `<st c="34236">ScriptTask</st>`
    <st c="34246">does not need inputs from views because it can extract existing
    workflow data to build its conditional expression.</st> <st c="34362">But for
    sure, it must emit output variable(s) that the succeeding</st> `<st c="34428">Gateway</st>`<st
    c="34435">,</st> `<st c="34437">ScriptTask</st>`<st c="34447">, or</st> `<st c="34452">UserTask</st>`
    <st c="34460">task needs to pursue their execution.</st> *<st c="34499">Figure
    8</st>**<st c="34507">.7</st>* <st c="34509">shows the</st> `<st c="34553">proceed</st>`
    <st c="34560">output variable and how it extracts and uses the profile information
    from the</st> <st c="34639">workflow data:</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Utilizing variables in ScriptTask](img/B19383_08_007.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: <st c="34909">Figure 8.7 – Utilizing variables in ScriptTask</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="34955">After running all the tasks and uploading all the values to the
    different variables in the workflow, the result of the</st> <st c="35074">workflow
    must be variables that will decide the result of the view function; in our case,
    the</st> `<st c="35169">provide_patient_details()</st>` <st c="35194">view.</st>
    <st c="35201">Let us now retrieve these results to determine the type of responses
    our views</st> <st c="35280">will render.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="35292">Managing the result of the workflow</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="35328">The goal of our workflow through SpiffWorkflow is to determine
    the view page a route function will render.</st> <st c="35436">Together with this
    is the execution of the required backend transactions, such as saving the</st>
    <st c="35529">scheduled appointment into the database, sending notifications to
    the doctors for the newly created appointment, and generating the necessary documents
    for the schedule.</st> <st c="35699">The workflow’s generated data will determine
    the resulting processes of the view.</st> <st c="35781">In our appointment workflow,
    when the generated</st> `<st c="35829">finalize_sched</st>` <st c="35843">variable
    is</st> `<st c="35856">True</st>`<st c="35860">, the view will redirect the user
    to the doctor’s dashboard page.</st> <st c="35926">Otherwise, the user will see
    the first page of the</st> <st c="35977">data-gathering process.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="36000">Let us now explore the capability of SpiffWorkflow to implement</st>
    <st c="36065">non-BPMN workflows.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="36084">Implementing a non-BPMN workflow</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="36117">SpiffWorkflow can implement workflows in JSON or Python configurations.</st>
    <st c="36190">In our</st> `<st c="36197">ch08-spiff-web</st>` <st c="36211">project,
    we have the</st> <st c="36232">following Python class that implements a prototype
    of a payment</st> <st c="36297">process workflow:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '@payment_bp.route("/payment/start", methods = ["GET", "POST"])'
  prefs: []
  type: TYPE_NORMAL
- en: 'async def start_payment_form():'
  prefs: []
  type: TYPE_NORMAL
- en: 'if request.method == "GET":'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return render_template("payment_form.html"), 201
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '… … … … … … <st c="39220">Task</st> list will start the workflow:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: <st c="39450">This</st> `<st c="39456">Task</st>` <st c="39460">list will load
    all payment data to the workflow and execute the</st> `<st c="39525">tx_patient_pay()</st>`
    <st c="39541">callback method</st> <st c="39557">to process</st> <st c="39569">payment
    transactions:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: <st c="39954">This part of the workflow will execute the</st> `<st c="39998">ExclusiveChoice</st>`
    <st c="40013">event to compare the payment amount paid by the</st> <st c="40062">patient
    against the patient’s</st> <st c="40092">total charges:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: <st c="40324">If the patient fully paid the charges, the following tasks will
    execute the</st> `<st c="40401">tx_patient_release()</st>` <st c="40421">callback
    method to clear and issue release notifications to</st> <st c="40482">the patient:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: <st c="40766">If the patient has partially paid the charges, the following tasks
    will execute the</st> `<st c="40851">tx_patient_onhold()</st>` <st c="40870">callback
    method:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: <st c="41272">The result of the workflow will decide on what page the view will
    redirect the user to, whether the</st> *<st c="41373">releasing</st>* <st c="41382">or</st>
    *<st c="41386">on-hold</st>* <st c="41393">page.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="41399">Now, SpiffWorkflow will lessen the coding effort in building the
    workflow because it has defined API classes that support both BPMN and non-BPMN
    workflow implementation.</st> <st c="41570">But what if the need is to trigger</st>
    <st c="41604">workflows through API endpoints that SpiffWorkflow can</st> <st
    c="41660">hardly handle?</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="41674">The next topic will focus on using a BPMN workflow engine that
    the Camunda platform uses in running tasks through</st> <st c="41789">API endpoints.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="41803">Building service tasks with the Zeebe/Camunda platforms</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="41859">Camunda</st>** <st c="41867">is a popular lightweight workflow
    and decision automation engine with built-in powerful tools, such as the</st>
    *<st c="41975">Camunda Modeler</st>*<st c="41990">,</st> *<st c="41992">Cawemo</st>*<st
    c="41998">, and the</st> *<st c="42008">Zeebe</st>* <st c="42013">broker.</st>
    <st c="42022">But this chapter is not about Camunda</st> <st c="42059">but about
    using Camunda’s</st> *<st c="42086">Zeebe server</st>* <st c="42098">to deploy,
    run, and execute workflow tasks built by the</st> <st c="42155">Flask framework.</st>
    <st c="42172">The goal is to create a Flask client application that will deploy
    and run BPMN workflows designed by the Camunda Modeler using the Zeebe</st> <st
    c="42309">workflow engine.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="42325">Let us start with the setup and configurations needed to integrate
    Flask with the</st> <st c="42408">Zeebe server.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="42421">Setting up the Zeebe server</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="42449">The easiest way to</st> <st c="42468">run the Zeebe server is
    to use Docker to run its</st> `<st c="42518">camunda/zeebe</st>` <st c="42531">image.</st>
    <st c="42539">So, read first the updated</st> *<st c="42566">Docker Subscription
    Service Agreement</st>* <st c="42603">before downloading and installing</st> <st
    c="42638">Docker Desktop, available</st> <st c="42664">from</st> [<st c="42669">https://docs.docker.com/desktop/install/windows-install/</st>](https://docs.docker.com/desktop/install/windows-install/)<st
    c="42725">.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="42726">After the installation, start the Docker engine, open a terminal,
    and run the following</st> <st c="42815">Docker command:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: <st c="42933">A</st> *<st c="42936">Docker network</st>*<st c="42950">, as with
    our</st> `<st c="42964">ch08-network</st>`<st c="42976">, is needed to expose
    the ports to the development platform.</st> <st c="43037">Zeebe’s port</st> `<st
    c="43050">26500</st>` <st c="43055">is where the Flask client application will
    communicate to the server’s gateway API.</st> <st c="43140">After using Zeebe,
    run the</st> `<st c="43167">docker stop</st>` <st c="43178">command with</st>
    *<st c="43192">Zeebe’s container ID</st>* <st c="43212">to shut down</st> <st
    c="43226">the broker.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="43237">Now, the next step is to install the suitable Python Zeebe client
    for</st> <st c="43308">the application.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="43324">Installing the pyzeebe library</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="43355">Lots of effective and popular Zeebe client libraries</st> <st
    c="43409">are Java-based.</st> <st c="43425">However,</st> `<st c="43434">pyzeebe</st>`
    <st c="43441">is one of the few Python external modules that are simple, easy
    to use, lightweight, and effective in establishing connectivity</st> <st c="43570">to
    the Zeebe server.</st> <st c="43591">It is a</st> *<st c="43599">gRPC</st>*<st
    c="43603">-based client library for Zeebe, typically designed to manage workflows
    that involve</st> <st c="43689">RESTful services.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="43706">Important note</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="43721">gRPC is a flexible and high-performance RPC framework that can
    run in any environment and easily connect to any cluster, with support for access
    authentication, API health checking, load balancing, and open tracing.</st> <st
    c="43938">All Zeebe client libraries use gRPC to communicate with</st> <st c="43994">the
    server.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="44005">Let us now install the</st> `<st c="44029">pyzeebe</st>` <st c="44036">library
    using the</st> `<st c="44055">pip</st>` <st c="44058">command:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: <st c="44087">After the installation and</st> <st c="44115">setup, it is time
    to create a BPMN workflow diagram using the</st> <st c="44177">Camunda Modeler.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="44193">Creating a BPMN diagram for pyzeebe</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '<st c="44229">The</st> `<st c="44234">pyzeebe</st>` <st c="44241">module can</st>
    <st c="44252">load and parse BPMN files used by</st> *<st c="44287">Camunda version
    8.0</st>*<st c="44306">. Since it is a small library, it can only read and execute</st>
    `<st c="44366">ServiceTask</st>` <st c="44377">tasks.</st> *<st c="44385">Figure
    8</st>**<st c="44393">.8</st>* <st c="44395">shows a BPMN diagram with two</st>
    `<st c="44426">ServiceTask</st>` <st c="44437">tasks:  the</st> **<st c="44449">Get
    Diagnostics</st>** <st c="44464">task, which</st> <st c="44476">retrieves all
    patients’ diagnoses, and the</st> **<st c="44520">Get Analysis</st>** <st c="44532">task,
    which returns the doctor’s resolutions or prescriptions to</st> <st c="44598">the
    diagnoses:</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.8 – A BPMN diagram with two ServiceTask tasks](img/B19383_08_008.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: <st c="44706">Figure 8.8 – A BPMN diagram with two ServiceTask tasks</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="44760">The next step is to load and run the final BPMN document using
    the</st> `<st c="44828">pyzeebe</st>` <st c="44835">client library.</st> <st c="44852">Running
    the workflow activities from the BPMN diagram is impossible without a</st> `<st
    c="44930">pyzeebe</st>` *<st c="44937">worker</st>* <st c="44944">and</st> *<st
    c="44949">client</st>*<st c="44955">. But implementation of the worker must</st>
    <st c="44995">come first.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="45006">Creating a pyzeebe worker</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="45032">A</st> `<st c="45035">pyzeebe</st>` <st c="45042">worker or a</st>
    `<st c="45055">ZeebeWorker</st>` <st c="45066">worker is a</st> <st c="45078">typical
    Zeebe worker that handles all</st> `<st c="45117">ServiceTask</st>` <st c="45128">tasks.</st>
    <st c="45136">It runs asynchronously in the background using</st> `<st c="45183">asyncio</st>`<st
    c="45190">.</st> `<st c="45192">pyzeebe</st>`<st c="45199">, as an asynchronous
    library, prefers a</st> `<st c="45239">Flask[async]</st>` <st c="45251">platform
    with</st> `<st c="45266">asyncio</st>` <st c="45273">utilities.</st> <st c="45285">But
    it requires</st> `<st c="45301">grpc.aio.Channel</st>` <st c="45317">as a constructor</st>
    <st c="45335">parameter</st> <st c="45345">before instantiation.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="45366">The library provides three methods to create the needed channel,
    namely</st> `<st c="45439">create_insecure_channel()</st>`<st c="45464">,</st>
    `<st c="45466">create_secure_channel()</st>`<st c="45489">, and</st> `<st c="45495">create_camunda_cloud_channel()</st>`<st
    c="45525">. All three instantiate the channel, but w</st> `<st c="45568">create_insecure_channel()</st>`
    <st c="45593">disregards the TLS protocol, and</st> `<st c="45627">create_camunda_cloud_channel()</st>`
    <st c="45657">considers the connection to the Camunda cloud.</st> <st c="45705">Our</st>
    `<st c="45709">ch08-zeebe</st>` <st c="45719">application uses the insecure one
    to instantiate the</st> `<st c="45773">ZeebeWorker</st>` <st c="45784">worker
    and</st> <st c="45795">eventually manage the</st> `<st c="45818">ServiceTask</st>`
    <st c="45829">tasks indicated in our BPMN file.</st> <st c="45864">The following</st>
    `<st c="45878">worker-tasks</st>` <st c="45890">module script shows an independent
    Python application that contains the</st> `<st c="45963">ZeebeWorker</st>` <st
    c="45974">instantiation and its tasks</st> <st c="46003">or jobs:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: <st c="46621">@worker.task(task_type="select_diagnosis",</st> <st c="46664">**Zeebe.TASK_DEFAULT_PARAMS)</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="46693">async def select_diagnosis(docid, patientid):</st> async with
    db_session() as sess:'
  prefs: []
  type: TYPE_NORMAL
- en: 'async with sess.begin():'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'try:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: repo = DiagnosisRepository(sess)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: records = await repo. select_diag_doc_patient(docid, patientid)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: diagnosis_rec = [rec.to_json() for rec in records]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: diagnosis_str = json.dumps(diagnosis_rec, default=json_date_serializer)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'return {"data": diagnosis_str}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'except Exception as e:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'return {"data": json.dumps([])}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: <st c="47616">@worker.task(task_type="retrieve_analysis", **Zeebe.TASK_DEFAULT_PARAMS)</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="47689">async def retrieve_analysis(records):</st> try:'
  prefs: []
  type: TYPE_NORMAL
- en: records_diagnosis = json.loads(records)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: diagnosis_text = [dt['resolution'] for dt in records_diagnosis]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'return {"result": diagnosis_text}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'except Exception as e:'
  prefs: []
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'return {"result": []}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'if __name__ == "__main__": <st c="48821">ZeebeWorker</st> instance has a <st
    c="48848">work()</st> coroutine that must be running asynchronously at the back
    using an independent event, disconnected from Flask operations. Always run the
    module with the Python command, such as <st c="49032">python worker-tasks.py</st>.'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49055">Let us now implement the</st> `<st c="49081">pyzeebe</st>` <st
    c="49088">client.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="49096">Implementing the pyzeebe client</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="49128">The Flask application needs to</st> <st c="49159">instantiate
    the</st> `<st c="49176">ZeebeClient</st>` <st c="49187">class to connect to Zeebe.</st>
    <st c="49215">As with the</st> `<st c="49227">ZeebeWorker</st>`<st c="49238">,
    it also requires the same</st> `<st c="49266">grpc.aio.Channel</st>` <st c="49282">parameter
    as a constructor parameter before its instantiation.</st> <st c="49346">Since</st>
    `<st c="49352">ZeebeClient</st>` <st c="49363">behaves asynchronously like</st>
    `<st c="49392">ZeebeWorker</st>`<st c="49403">, all its operations must run asynchronously
    in the background as Celery tasks.</st> <st c="49483">But, unlike the worker,</st>
    `<st c="49507">ZeebeClient</st>` <st c="49518">appears in every Blueprint</st>
    <st c="49546">module as part of its Celery service</st> <st c="49582">tasks.</st>
    <st c="49590">The following is the</st> `<st c="49611">diagnosis_tasks</st>` <st
    c="49626">module script of the</st> *<st c="49648">doctor</st>* <st c="49654">Blueprint
    module that instantiates</st> `<st c="49690">ZeebeClient</st>` <st c="49701">with
    the</st> <st c="49711">Celery tasks:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: <st c="50028">@shared_task(ignore_result=False)</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="50061">def deploy_zeebe_wf(bpmn_file):</st> async def zeebe_wf(bpmn_file):'
  prefs: []
  type: TYPE_NORMAL
- en: 'try: <st c="50130">await client.deploy_process(bpmn_file)</st> return True'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'except Exception as e:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'return False <st c="50314">deploy_zeebe_wf()</st> task is the first process
    to run before anything else. The API endpoint calling this will load, parse, and
    deploy the BPMN file with the workflow to the Zeebe server using the asynchronous
    <st c="50521">deploy_process()</st> method of <st c="50548">ZeebeClient</st>.
    The task will throw an exception if the BPMN file has schema problems, is not
    well formed, or is invalid:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: <st c="52475">@doc_bp.get("/diagnosis/bpmn/deploy")</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="52513">async def deploy_diagnosis_analysis_bpmn():</st> try:'
  prefs: []
  type: TYPE_NORMAL
- en: filepath = os.path.join(Zeebe.BPMN_DUMP_PATH, "<st c="52610">dams_diagnosis.bpmn</st>")
    <st c="52634">task = deploy_zeebe_wf.apply_async(args=[filepath])</st><st c="52685">result
    = task.get()</st> return jsonify(data=result), 201
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'except Exception as e:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return jsonify(data="error"), 500
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: <st c="52928">@doc_bp.post("/diagnosis/analysis/text")</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="52969">async def extract_analysis_text():</st> try:'
  prefs: []
  type: TYPE_NORMAL
- en: data = request.get_json()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: docid = data['docid']
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: patientid = int(data['patientid']) <st c="53093">task = run_zeebe_task.apply_async(args=[docid,</st>
    <st c="53139">patientid])</st><st c="53151">result = task.get()</st> return jsonify(result),
    201
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'except Exception as e:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return jsonify(data="error"), 500
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="55684">airflow</st> module using the <st c="55709">pip</st> command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="59548">from airflow import DAG</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59571">from airflow.operators.python import PythonOperator</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="59623">from airflow.providers.http.operators.http import</st> <st c="59673">SimpleHttpOperator</st>
    from datetime import datetime <st c="59723">with DAG(dag_id="report_login_count",</st>
    description="Report the number of login accounts", <st c="59812">start_date=datetime(2023,
    12, 27),</st><st c="59846">schedule_interval="0 12 * * *",</st> ) as <st c="59918">dag_id</st>
    value. Aside from <st c="59943">description</st>, DAG has parameters, such as
    <st c="59984">start_date</st> and <st c="59999">schedule_interval</st>, that work
    like a Cron (time) scheduler for the workflow. The <st c="60079">schedule_interval</st>
    parameter can have the <st c="60120">@hourly</st>, <st c="60129">@daily</st>,
    <st c="60137">@weekly</st>, <st c="60146">@monthly</st>, or <st c="60159">@yearly</st>
    Cron preset options run periodically or a Cron-based expression, such as <st c="60240">*/15
    * * * *</st>, that schedules the workflow to run every *<st c="60295">15 minutes</st>*.
    Setting the parameter to <st c="60332">None</st> will disable the periodic execution,
    requiring a trigger to run the tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: <st c="60782">An</st> *<st c="60785">Airflow operator</st>* <st c="60801">implements
    a task.</st> <st c="60821">But, there are many types of operators to choose from
    depending on what kind</st> <st c="60898">of task the DAG requires.</st> <st c="60924">Some
    widely used operators in training and workplaces are</st> <st c="60982">the following:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="60996">EmptyOperator</st>` <st c="61010">– Initiates a</st> <st c="61025">built-in
    execution.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="61044">PythonOperator</st>` <st c="61059">– Calls a Python function
    that implements a</st> <st c="61104">business logic.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="61119">BashOperator</st>` <st c="61132">– Aims to run</st> `<st c="61147">bash</st>`
    <st c="61151">commands.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="61161">EmailOperator</st>` <st c="61175">– Sends an email through</st>
    <st c="61201">a protocol.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="61212">SimpleHttpOperator</st>` <st c="61231">– Sends an</st> <st c="61243">HTTP
    request.</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="61256">Other operators may require installing the needed modules.</st>
    <st c="61316">For example, the</st> `<st c="61333">PostgresOperator</st>` <st
    c="61349">operator used for executing PostgreSQL commands requires installing
    the</st> `<st c="61422">apache-airflow[postgres]</st>` <st c="61446">module through
    the</st> `<st c="61466">pip</st>` <st c="61469">command.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="61478">Each task must have a unique</st> `<st c="61508">task_id</st>`
    <st c="61515">value for Airflow identification.</st> <st c="61550">Our</st> `<st
    c="61554">Task1</st>` <st c="61559">task is a</st> `<st c="61570">SimpleHTTPOperator</st>`
    <st c="61588">operator that sends a</st> `<st c="61611">GET</st>` <st c="61614">request
    to an HTTP</st> `<st c="61634">GET</st>` <st c="61637">API endpoint expected to
    return a JSON resource.</st> <st c="61687">It has an ID named</st> `<st c="61706">list_all_login</st>`
    <st c="61720">and connects to Airflow’s HTTP connection object named</st> `<st
    c="61776">packt_dag</st>`<st c="61785">. All</st> `<st c="61791">SimpleHTTPOperator</st>`
    <st c="61809">needs is a</st> `<st c="61821">Connection</st>` <st c="61831">object,
    which stores the HTTP details of the external server resource that the operation
    will need to establish a connection.</st> <st c="61958">Accessing the</st> `<st
    c="62075">Connection</st>` <st c="62085">object.</st> *<st c="62094">Figure 8</st>**<st
    c="62102">.12</st>* <st c="62105">shows the form that accepts HTTP details of
    the connection and creates</st> <st c="62177">the object:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Creating an HTTP Connection object](img/B19383_08_012.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: <st c="62503">Figure 8.12 – Creating an HTTP Connection object</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="62551">Also, a</st> `<st c="62560">SimpleHTTPOperator</st>` <st c="62578">operator
    provides a callback method indicated by its</st> `<st c="62632">response_check</st>`
    <st c="62646">parameter.</st> <st c="62658">The callback method accesses the response
    and other related data and can perform</st> <st c="62738">evaluation and logging
    on the API response.</st> <st c="62783">The following is the implementation of
    the callback method</st> <st c="62842">of</st> `<st c="62845">Task1</st>`<st c="62850">:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: <st c="63027">On the other hand,</st> `<st c="63047">Task2</st>` <st c="63052">is
    a</st> `<st c="63058">PythonOperator</st>` <st c="63072">operator that runs a
    Python function,</st> `<st c="63111">count_login()</st>`<st c="63124">, for retrieving
    the JSON data from the API executed in</st> `<st c="63180">Task1</st>` <st c="63185">and
    counting the number of records from the JSON resource.</st> <st c="63245">Setting
    its</st> `<st c="63257">provide_context</st>` <st c="63272">parameter to</st>
    `<st c="63286">True</st>` <st c="63290">allows its</st> `<st c="63302">python_callable</st>`
    <st c="63317">method to access the</st> `<st c="63339">taskInstance</st>` <st
    c="63351">object that pulls the API resource from</st> `<st c="63392">Task1</st>`<st
    c="63397">. The</st> `<st c="63403">count_login()</st>` <st c="63416">function
    can also set an</st> `<st c="63442">xcom</st>` <st c="63446">variable, a form
    of workflow data, because the value of</st> `<st c="63503">Task2</st>`<st c="63508">’s</st>
    `<st c="63512">do_xcom_push</st>` <st c="63524">parameter is</st> `<st c="63538">True</st>`<st
    c="63542">. The following snippet is the implementation</st> <st c="63588">of</st>
    `<st c="63591">count_login()</st>`<st c="63604">:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="66486">@login_bp.get("/login/dag/report/login/count")</st> async def
    trigger_report_login_count(): <st c="66574">token = "cGFja3RhZG1pbjpwYWNrdGFkbWlu"</st>
    dag_id = "report_login_count"'
  prefs: []
  type: TYPE_NORMAL
- en: deployment_url = "localhost:8080"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'response = <st c="66688">requests.post(</st><st c="66702">url=f"http://{deployment_url}</st>
    <st c="66732">/api/v1/dags/{dag_id}/dagRuns",</st> headers={ <st c="66775">"Authorization":
    f"Basic {token}",</st> "Content-Type": "application/json",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"Accept": "*/*",'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"Connection": "keep-alive",'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"Accept-Encoding": "gzip, deflate, br"'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}, <st c="66933">data = ''{"dag_run_id": "d08a62c6-ed71-49fc-81a4-47991221aea5"}''</st>
    )'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: result = response.content.decode(encoding="utf-8")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return jsonify(message=result), 201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"conf": {}, <st c="67485">"dag_id": "report_login_count",</st><st c="67516">"dag_run_id":
    "01c04a4b-a3d9-4dc5-b0c3-e4e59e2db554",</st> "data_interval_end": "2023-12-27T12:00:00+00:00",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"data_interval_start": "2023-12-26T12:00:00+00:00",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"end_date": null,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"execution_date": "2023-12-27T13:55:44.910773+00:00",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"external_trigger": true,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"last_scheduling_decision": null,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"logical_date": "2023-12-27T13:55:44.910773+00:00",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"note": null, <st c="67871">"run_type": "manual",</st> "start_date": null,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"state": "queued"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '@login_bp.get("/login/dag/xcom/values")'
  prefs: []
  type: TYPE_NORMAL
- en: 'async def extract_xcom_count():'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: token = "cGFja3RhZG1pbjpwYWNrdGFkbWlu"
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: dag_id = "report_login_count"
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: task_id = "return_report" <st c="68236">dag_run_id = "d08a62c6-ed71-49fc-81a4-47991221aea5"</st>
    deployment_url = "localhost:8080"
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'response = <st c="68333">requests.get(</st><st c="68346">url=f"http://{deployment_url}</st>
    <st c="68376">/api/v1/dags/{dag_id}/dagRuns</st> <st c="68406">/{dag_run_id}/taskInstances/{task_id}</st>
    <st c="68444">/xcomEntries/{''report_msg''}",</st> headers={ <st c="68485">"Authorization":
    f"Basic {token}",</st> … … … … … …'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: result = response.json()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: message = result['value']
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return jsonify(message=message)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'except Exception as e:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return jsonify(message="")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"message": "There are 20 users as of 2023-12-28 00:38:17.592287." }'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: from temporalio.client import Client
  prefs: []
  type: TYPE_NORMAL
- en: from modules import create_app
  prefs: []
  type: TYPE_NORMAL
- en: import asyncio
  prefs: []
  type: TYPE_NORMAL
- en: 'app, celery_app= create_app("../config_dev.toml") <st c="70653">async def connect_temporal(app):</st><st
    c="70685">client = await Client.connect("localhost:7233")</st><st c="70733">app.temporal_client
    = client</st> if __name__ == "__main__": <st c="70790">asyncio.run(connect_temporal(app))</st>
    app.run(debug=True)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: <st c="71631">from temporalio import activity</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="71663">@activity.defn</st> async def reserve_schedule(appointmentwf:
    AppointmentWf) -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'async with db_session() as sess:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'async with sess.begin(): <st c="71807">repo = AppointmentRepository(sess)</st>
    … … … … … … … <st c="71855">result = await repo.insert_appt(appt)</st> if result
    == False:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '… … … … … … <st c="71925">return "failure"</st> … … … … … … <st c="71953">return
    "success"</st> except Exception as e:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: print(e)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … … <st c="72084">@activity.defn</st> annotation, with a workflow data
    class as a local parameter, and returns a non-varying and non-changing value.
    The returned value can be a fixed string, number, or any string with a non-varying
    length. Avoid returning collection or model objects with varying property values.
    Our <st c="72379">reserve_schedule()</st> activity accepts an <st c="72418">AppointmentWf</st>
    object containing appointment details and saves the record of information into
    the database. It returns only either <st c="72548">"successful"</st> or <st c="72564">"failure"</st>.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="72574">An activity is where access to external services, such as databases,
    emails, or APIs, is permitted by Temporal and</st> <st c="72690">not in the workflow
    implementation.</st> <st c="72726">The following code is a</st> *<st c="72750">Temporal
    workflow</st>* <st c="72768">that runs the</st> `<st c="72782">reserve_schedule()</st>`
    <st c="72800">activity:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="73904">@workflow.run</st> async def run(self, data: ReqAppointment)
    -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: duration = 12
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: self.appointmentwf.ticketid = data.ticketid
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: self.appointmentwf.patientid = data.patientid
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … … <st c="74085">while self.appointmentwf.status:</st> self.appointmentwf.remarks
    = "Doctor reservation being processed...." <st c="74188">try:</st><st c="74192">await
    workflow.execute_activity(</st><st c="74225">reserve_schedule,</st><st c="74243">self.appointmentwf,</st><st
    c="74263">start_to_close_timeout=timedelta(</st> <st c="74297">seconds=10),</st>
    ) <st c="74313">await asyncio.sleep(duration)</st><st c="74342">except asyncio.CancelledError
    as err:</st> self.appointmentwf.status = False
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: self.appointmentwf.remarks = "Appointment with doctor done." <st c="74739">ReserveAppointmentWorkflow</st>
    instance, when canceled, will throw a <st c="74804">CancelledError</st> exception
    that will trigger the exception clause that sets <st c="74878">appointmentwf.status</st>
    to <st c="74902">False</st> and executes the <st c="74925">start_to_close()</st>
    activity.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="74951">Aside from the loop and the</st> <st c="74979">constructor, a
    workflow implementation can emit</st> `<st c="75028">resultset</st>` <st c="75037">instances
    or information about the workflow.</st> <st c="75083">To carry this out, implement
    an instance method and decorate it with</st> `<st c="75152">@workflow.query</st>`<st
    c="75167">. The following method returns an</st> <st c="75201">appointment record:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: <st c="75298">Unlike in Zeebe/Camunda, where the server executes and manages
    the workflow, the Temporal.io server does not run any workflow instance but the
    worker.</st> <st c="75450">We learn more about workers in the</st> <st c="75485">following
    section.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="75503">Building a worker</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="75521">A</st> `<st c="75579">Worker</st>` <st c="75585">class from the</st>
    `<st c="75601">temporalio.worker</st>` <st c="75618">module requires the</st>
    `<st c="75639">client</st>` <st c="75645">connection,</st> `<st c="75658">task_queue</st>`<st
    c="75668">,</st> `<st c="75670">workflows</st>`<st c="75679">, and</st> `<st c="75685">activities</st>`
    <st c="75695">as constructor</st> <st c="75711">parameters before its instantiation.</st>
    <st c="75748">Our worker should be outside the</st> <st c="75781">context of Flask,
    so we added the</st> `<st c="75815">workflow_runner</st>` <st c="75830">parameter
    to the parameters.</st> <st c="75860">The following code is our implementation
    of the</st> <st c="75908">Temporal worker:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="77849">@admin_bp.route("/appointment/doctor", methods=["POST"])</st>
    async def request_appointment(): <st c="77940">client = get_client()</st> appt_json
    = request.get_json()'
  prefs: []
  type: TYPE_NORMAL
- en: appointment = ReqAppointment(**appt_json) <st c="78035">await client.start_workflow(</st><st
    c="78063">ReserveAppointmentWorkflow.run,</st><st c="78095">appointment,</st><st
    c="78108">id=appointment.ticketid,</st><st c="78133">task_queue=appt_queue_id,</st>
    )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'message = jsonify({"message": "Appointment for doctor requested...."})'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: response = make_response(message, 201)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return response
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="78567">@admin_bp.route("/appointment/details", methods=["GET"])</st>
    async def get_appointment_details():'
  prefs: []
  type: TYPE_NORMAL
- en: client = get_client()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ticketid = request.args.get("ticketid")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print(ticketid)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: handle = <st c="78749">client.get_workflow_handle_for( ReserveAppointmentWorkflow.run,
    ticketid)</st><st c="78822">results = await handle.query(</st> <st c="78852">ReserveAppointmentWorkflow.details)</st>
    message = jsonify({
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"ticketid": results.ticketid,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"patientid": results.patientid,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"docid": results.docid,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"date_scheduled": results.date_scheduled,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '"time_scheduled": results.time_scheduled,'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: response = make_response(message, 200)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return response
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="79396">@admin_bp.route("/appointment/close", methods=["DELETE"])</st>
    async def end_subscription():'
  prefs: []
  type: TYPE_NORMAL
- en: client = get_client()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ticketid = request.args.get("ticketid") <st c="79547">handle = client.get_workflow_handle(ticketid,)</st><st
    c="79593">await handle.cancel()</st> message = jsonify({"message": "Requesting
    cancellation"})'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: response = make_response(message, 202)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return response
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
