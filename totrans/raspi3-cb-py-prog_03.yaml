- en: Using Python for Automation and Productivity
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 进行自动化和生产力提升
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using Tkinter to create graphical user interfaces
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Tkinter创建图形用户界面
- en: Creating a graphical Start menu application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建图形化启动菜单应用程序
- en: Displaying photo information in an application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序中显示照片信息
- en: Organizing your photos automatically
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动整理您的照片
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Until now, we have focused purely on command-line applications; however, there
    is much more to Raspberry Pi than just the command line. By using **graphical
    user interfaces** (**GUIs**), it is often easier to obtain input from a user and
    provide feedback in a simpler way. After all, we continuously process multiple
    inputs and outputs all the time, so why limit ourselves to the procedural format
    of the command line when we don't have to?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于命令行应用程序；然而，树莓派的功能远不止命令行那么简单。通过使用**图形用户界面**（**GUIs**），通常更容易从用户那里获取输入并以更简单的方式提供反馈。毕竟，我们一直在不断地处理多个输入和输出，所以为什么非得限制自己只使用命令行的程序格式呢？
- en: Fortunately, Python can support this. Much like other programming languages,
    such as Visual Basic and C/C++/C#, this can be achieved using prebuilt objects
    that provide standard controls. We will use a module called **Tkinter** which
    provides a good range of controls (also referred to as **widgets**) and tools
    for creating graphical applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python 可以支持这一点。和其他编程语言一样，例如 Visual Basic 和 C/C++/C#，这可以通过使用预构建的对象来实现，这些对象提供了标准控件。我们将使用一个名为
    **Tkinter** 的模块，它提供了一系列良好的控件（也称为 **小部件**）和工具，用于创建图形应用程序。
- en: First, we will take an example, `encryptdecrypt.py`, and demonstrate how useful
    modules can be written and reused in a variety of ways. This is an example of
    good coding practice. We should aim to write code that can be tested thoroughly
    and then reused in many places.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将以一个示例，`encryptdecrypt.py`，来展示如何以多种方式编写和重用有用的模块。这是一个良好的编码实践示例。我们应该努力编写可以彻底测试并在许多地方重用的代码。
- en: Next, we will extend our previous examples by creating a small graphical Start
    menu application to run our favorite applications from.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过创建一个小的图形化启动菜单应用程序来扩展我们之前的示例，以便从该应用程序运行我们的最爱应用。
- en: Then, we will explore using **classes** within our applications to display and
    then to
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将探讨在我们的应用程序中使用**类**来显示信息，然后进行操作的方法。
- en: organize photos.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 组织照片。
- en: Using Tkinter to create graphical user interfaces
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Tkinter创建图形用户界面
- en: We will create a basic GUI to allow the user to enter information, and the program
    can then be used to encrypt and decrypt it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个基本的图形用户界面，以便用户输入信息，然后程序可以用来加密和解密这些信息。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You must ensure that this file is placed in the same directory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须确保此文件放置在同一目录下。
- en: 'Since we are using Tkinter (one of many available add-ons for Python), we need
    to ensure that it is installed. It should be installed by default on the standard
    Raspbian image. We can confirm it is installed by importing it from the Python
    prompt, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用Tkinter（Python众多可用插件之一），我们需要确保它已安装。它应该默认安装在标准的Raspbian镜像中。我们可以通过从Python提示符导入它来确认它已安装，如下所示：
- en: '`   Python3`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`   Python3`'
- en: '`   >>> import tkinter`'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`   >>> import tkinter`'
- en: 'If it is not installed, an `ImportError` exception will be raised, in which
    case you can install it using the following command (use *Ctrl* + *Z* to exit
    the Python prompt):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未安装，将会抛出 `ImportError` 异常，在这种情况下，您可以使用以下命令进行安装（使用 *Ctrl* + *Z* 退出 Python 提示符）：
- en: '`   sudo apt-get install python3-tk`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo apt-get install python3-tk`'
- en: 'If the module did load, you can use the following command to read more about
    the module (use *Q* to quit when you are done reading):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块已成功加载，您可以使用以下命令来了解更多关于该模块的信息（阅读完毕后，使用 *Q* 退出）：
- en: '`   >>>help(tkinter)`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>>help(tkinter)`'
- en: 'You can also get information about all the classes, functions, and methods
    within the module using the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用以下命令获取模块中所有类、函数和方法的详细信息：
- en: '`   >>>help(tkinter.Button)`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>>help(tkinter.Button)`'
- en: The following `dir` command will list any valid commands or variables that are
    in the scope of the `module:`
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `dir` 命令将列出 `module:` 范围内的任何有效命令或变量。
- en: '`   >>>dir(tkinter.Button)`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>>dir(tkinter.Button)`'
- en: You will see that our own modules will have the information about the functions
    marked by triple quotes; this will show up if we use the `help` command.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现我们自己的模块将包含由三引号标记的函数信息；如果我们使用`help`命令，这些信息将会显示出来。
- en: The command line will not be able to display the graphical displays created
    in this chapter, so you will have to start Raspberry Pi desktop (using the command
    `startx`), or if you are using it remotely.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have **X11 forwarding** enabled and an **X server** running (see
    [Chapter 1](b2230c60-fd75-45fd-82c8-e477459db3e0.xhtml), *Getting Started with
    a Raspberry Pi 3 Computer*).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will use the `tkinter` module to produce a GUI for the `encryptdecrypt.py`
    script.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate the GUI we will create the following `tkencryptdecrypt.py` script:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成GUI，我们将创建以下`tkencryptdecrypt.py`脚本：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Run the script using the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行脚本：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We start by importing two modules; the first is our own `encryptdecrypt` module
    and the second is the `tkinter` module. To make it easier to see which items have
    come from where, we use `ENC`/`TK`. If you want to avoid the extra reference,
    you can use `from <module_name> import *` to refer to the module items directly.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The `encryptButton()` and `decryptButton()` functions will be called when we
    click on the Encrypt and Decrypt buttons; they are explained in the following
    sections.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The main Tkinter window is created using the `Tk()` command, which returns the
    main window where all the widgets/controls can be placed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define six controls as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '`Label`: This displays the prompt Enter message to encrypt:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Entry`: This provides a textbox to receive the user''s message to be encrypted'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Button`: This is an Encrypt button to trigger the message to be encrypted'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Button`: This is a Decrypt button to reverse the encryption'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Label`: This displays the Key: field to prompt the user for an encryption
    key value'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Entry`: This provides a second textbox to receive values for the encryption
    keys'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These controls will produce a GUI similar to the one shown in the following
    screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25cc32ac-9411-441c-b8af-b720909623a8.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: The GUI to encrypt/decrypt messages
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the first `label1` definition:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All controls must be linked to the application window; hence, we have to specify
    our Tkinter window `root`. The text used for the label is set by `text`; in this
    case, we have set it to a string named `prompt`, which has been defined previously
    with the text we require. We also set the `width` to match the number of characters
    of the message (while not essential, it provides a neater result if we add more
    text to our labels later), and finally, we set the background color using `bg='green'`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define the text `Entry` box for our message:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will define `textvariable`—a useful way to link a variable to the contents
    of the box which is a special string variable. We could access the `text` directly
    using `textEnter.get()`, but we shall use a `Tkinter StringVar()` object instead
    to access it indirectly. If required, this will allow us to separate the data
    we are processing from the code that handles the GUI layout. The `enycrptvalue`
    variable automatically updates the `Entry` widget it is linked to whenever the
    `.set()` command is used (and the `.get()` command obtains the latest value from
    the `Entry` widget).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have our two `Button` widgets, Encrypt and Decrypt, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this case, we can set a function to be called when the `Button` widget is
    clicked by setting the `command` attribute. We can define the two functions that
    will be called when each button is clicked. In the following code snippet, we
    have the `encryptButton()` function, which will set the `encryptvalue StringVar`
    that controls the contents of the first `Entry` box. This string is set to the
    result we get by calling `ENC.encryptText()` with the message we want to encrypt
    (the current value of `encryptvalue`) and the `keyvalue` variable. The `decrypt()`
    function is exactly the same, except we make the `keyvalue` variable negative
    to decrypt the message:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We then set the final `Label` and `Entry` widgets in a similar way. Note that
    `textvariable` can also be an integer (numerical value) if required, but there
    is no built-in check to ensure that only numbers can be entered. You will encounter
    a `ValueError` exception when the `.get()` command is used.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have defined all the widgets to be used in the Tkinter window, we
    have to set the layout. There are three ways to define the layout in Tkinter:
    *place*, *pack*, and *grid*.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: The place layout allows us to specify the positions and sizes using exact pixel
    positions. The pack layout places the items in the window in the order that they
    have been added in. The grid layout allows us to place the items in a specific
    layout. It is recommended that you avoid the place layout wherever possible since
    any small change to one item can have a knock-on effect on the positions and sizes
    of all the other items; the other layouts account for this by determining their
    positions relative to the other items in the window.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'We will place the items as laid out in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53ee12ff-f352-43f6-871f-20ce50fdeecb.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: Grid layout for the Encrypt/Decrypt GUI
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'The positions of first two items in the GUI are set using the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can specify that the first `Label` and `Entry` box will span both columns
    (`columnspan=2`), and we can set the sticky values to ensure they span right to
    the edges. This is achieved by setting both the `TK.E` for the east and `TK.W`
    for the west sides. We'd use `TK.N` for the north and `TK.S` for the south sides
    if we needed to do the same vertically. If the `column` value is not specified,
    the grid function defaults to `column=0`. The other items are similarly defined.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to call `TK.mainloop()`, which allows Tkinter to run; this
    allows the buttons to be monitored for clicks and Tkinter to call the functions
    linked to them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Creating a graphical application – Start menu
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example in this recipe shows how we can define our own variations of Tkinter
    objects to generate custom controls and dynamically construct a menu with them.
    We will also take a quick look at using threads to allow other tasks to continue
    to function while a particular task is being executed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To view the GUI display, you will need a monitor displaying the Raspberry Pi
    desktop, or you need to be connected to another computer running the X server.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a graphical Start menu application, create the following `graphicmenu.py`
    script:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The previous code produces the following application:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/81acc2fb-5452-4f1b-8507-28bbdbaa02ee.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: The App Menu GUI
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We create the Tkinter window as we did before; however, instead of defining
    all the items separately, we create a special class for the application buttons.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The class we create acts as a blueprint or specification of what we want the
    `appButtons` items to include. Each item will consist of a string value for `app_cmd`,
    a function called `startApp()`, and an `__init__()` function. The `__init__()`
    function is a special function (called a **constructor**) that is called when
    we create an `appButtons` item; it will allow us to create any setup that is required.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the `__init__()` function allows us to create a new Tkinter button
    with the text to be set to an item in `app_list` and the command to be called
    in the `startApp()` function when the button is clicked. The `self` keyword is
    used so that the command called will be the one that is part of the item; this
    means that each button will call a locally defined function that has access to
    the local data of the item.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: We set the value of `self.app_cmd` to the command from `app_list` and make it
    ready for use via the `startApp()` function. We now create the `startApp()` function.
    If we run the application command here directly, the Tkinter window will freeze
    until the application we have opened is closed again. To avoid this, we can use
    the Python threading module, which allows us to perform multiple actions at the
    same time.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The `runApplicationThread()` class is created using the `threading.Thread` class
    as a template—this inherits all the features of the `threading.Thread` class in
    a new class. Just like our previous class, we provide an `__init__()` function
    for this as well. We first call the `__init__()` function of the inherited class
    to ensure it is set up correctly, and then we store the `app_cmd` value in `self.cmd`.
    After the `runApplicationThread()` function has been created and initialized,
    the `start()` function is called. This function is part of `threading.Thread`,
    which our class can use. When the `start()` function is called, it will create
    a separate application thread (that is, simulate running two things at the same
    time), allowing Tkinter to continue monitoring button clicks while executing the
    `run()` function within the class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we can place the code in the `run()` function to run the required
    application (using `call(self.cmd)`).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One aspect that makes Python particularly powerful is that it supports the programming
    techniques used in **Object-Orientated Design** (**OOD**). This is commonly used
    by modern programming languages to help translate the tasks we want our program
    to perform into meaningful constructs and structures in code. The principle of
    OOD lies in the fact that we think of most problems as consisting of several objects
    (a GUI window, a button, and so on) that interact with each other to produce a
    desired result.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we found that we could use classes to create unique
    objects that could be reused multiple times. We created an `appButton` class,
    which generated an object with all the features of the class, including its own
    personal version of `app_cmd` that will be used by the `startApp()` function.
    Another object of the `appButton` type will have its own unrelated `[app_cmd]`
    data that its `startApp()` function will use.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: You can see that classes are useful to keep together a collection of related
    variables and functions in a single object, and the class will hold its own data
    in one place. Having multiple objects of the same type (class), each with their
    own functions and data inside them, results in better program structure. The traditional
    approach would be to keep all the information in one place and send each item
    back and forth for various functions to process; however, this may become cumbersome
    in large systems.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the organization of related functions and data:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/492bc7ec-fea9-40dd-8eea-8e1552388b07.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: Data and functions
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have used Python modules to separate parts of our programs into different
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: files; this allows us to conceptually separate different parts of the program
    (an interface, encoder/decoder, or library of classes, such as Tkinter). Modules
    can provide code to control a particular bit of hardware, define an interface
    for the internet, or provide a library of common functionality; however, its most
    important function is to control the interface (the collection of functions, variables,
    and classes that are available when the item is imported). A well-implemented
    module should have a clear interface that is centered around how it is used, rather
    than how it is implemented. This allows you to create multiple modules that can
    be swapped and changed easily since they share the same interface. In our previous
    example, imagine how easy it would be to change the `encryptdecrypt` module for
    another one just by supporting `encryptText(input_text,key)`. Complex functionality
    can be split into smaller, manageable blocks that can be reused in multiple applications.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Python makes use of classes and modules all the time. Each time you import a
    library, such as `sys` or Tkinter or convert a value using `value.str()` and iterate
    through a list using `for...in`, you can use them without worrying about the details.
    You don't have to use classes or modules in every bit of code you write, but they
    are useful tools to keep in your programmer's toolbox for times when they fit
    what you are doing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: We will understand how classes and modules allow us to produce well-structured
    code that is easier to test and maintain by using them in the examples of this
    book.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Displaying photo information in an application
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we shall create a utility class to handle photos that can be
    used by other applications (as modules) to access photo metadata and display preview
    images easily.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following script makes use of **Python Image Library** (**PIL**); a compatible
    version for Python 3 is **Pillow**.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Pillow has not been included in the Raspbian repository (used by `apt-get`);
    therefore, we will need to install Pillow using a **Python Package Manager** called
    **PIP**.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: To install packages for Python 3, we will use the Python 3 version of PIP (this
    requires 50 MB of available space).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands can be used to install PIP:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Before you use PIP, ensure that you have installed `libjpeg-dev` to allow Pillow
    to handle JPEG files. You can do this using the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now you can install Pillow using the following PIP command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: PIP also makes it easy to uninstall packages using `uninstall` instead of `install`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can confirm that it has installed successfully by running `python3`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should not get any errors and see lots of information about PIL and its
    uses (press *Q* to finish). Check the version installed as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You should see `2.7.0` (or similar).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'PIP can also be used with Python 2 by installing pip-2.x using the following
    command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '`   sudo apt-get install python-pip`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Any packages installed using `sudo pip install` will be installed just for Python
    2.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To display photo information in an application, create the following `photohandler.py`
    script:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The previous code defines our `Photo` class; it is of no use to us until we
    run it in the *There's more...* section and in the next example.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We define a general class called `Photo`; it contains details about itself and
    provides
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: functions to access **Exchangeable Image File Format** (**EXIF**) information
    and generate
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: a preview image.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: In the `__init__()` function, we set values for our class variables and call
    `self.initImage()`, which will open the image using the `Image()` function from
    the PIL. We then call `self.initExif()` and `self.initDates()` and set a flag
    to indicate whether the file was valid or not. If not valid, the `Image()` function
    would raise an `IOError` exception.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'The `initExif()` function uses PIL to read the EXIF data from the `img` object,
    as shown in the following code snippet:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The previous code is a series of compound statements that results in `self.exif_info`
    being populated with a dictionary of tag names and their related values.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '`ExifTag.TAGS` is a dictionary that contains a list of possible tag names linked
    with their IDs, as shown in the following code snippet:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `image._getexif()` function returns a dictionary that contains all the
    values set by the camera of the image, each linked to their relevant IDs, as shown
    in the following code snippet:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `for` loop will go through each item in the image''s EXIF value dictionary
    and check for its occurrence in the `ExifTags.TAGS` dictionary; the result will
    get stored in `self.exif_info`. The code for this is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Again, if there are no exceptions, we set a flag to indicate that the EXIF data
    is valid, or if there is no EXIF data, we raise an `AttributeError` exception.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The `initDates()` function allows us to gather all the possible file dates and
    dates from the EXIF data so that we can select one of them as the date we wish
    to use for the file. For example, it allows us to rename all the images to a filename
    in the standard date format. We create a `self.filedates` dictionary that we populate
    with three dates extracted from the EXIF information. We then add the filesystem
    dates (created and modified) just in case no EXIF data is available. The `os`
    module allows us to use `os.path.getctime()` and `os.path.getmtime()` to obtain
    an epoch value of the file creation. It can also be the date and time when the
    file was moved – and the file modification – when it was last written to (for
    example, it often refers to the date when the picture was taken). The epoch value
    is the number of seconds since January 1, 1970, but we can use `datetime.datetime.fromtimestamp()`
    to convert it into years, months, days, hours, and seconds. Adding `date()` simply
    limits it to years, months, and days.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Now, if the `Photo` class was to be used by another module, and we wished to
    know the date of the image that was taken, we could look at the `self.dates` dictionary
    and pick out a suitable date. However, this would require the programmer to know
    how the `self.dates` values are arranged, and if we later changed how they are
    stored, it would break their program. For this reason, it is recommended that
    we access data in a class through access functions so the implementation is independent
    of the interfaces (this process is known as **encapsulation**). We provide a function
    that returns a date when called; the programmer does not need to know that it
    could be one of the five available dates or even that they are stored as epoch
    values. Using a function, we can ensure that the interface will remain the same
    no matter how the data is stored or collected.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last function we want the `Photo` class to provide is `previewPhoto()`.
    This function provides a method to generate a small thumbnail image and saves
    it as a **Portable Pixmap Format** (**PPM**) file. As we will discover in a moment,
    Tkinter allows us to place images on its `Canvas` widget, but unfortunately, it
    does not support JPEGs directly and only supports GIF or PPM. Therefore, we simply
    save a small copy of the image we want to display in the PPM format – with the
    added warning that the image pallet must be converted to RGB too – and then get
    Tkinter to load it onto the `Canvas` when required.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, the `Photo` class we have created is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operations** | **Description** |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: '| `__init__(self,filename)` | This is the object initializer. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| `initImage(self)` | This returns `img`, a PIL-type image object. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| `initExif(self,image)` | This extracts all the EXIF information, if any is
    present. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| `initDates(self)` | This creates a dictionary of all the dates available
    from the file and photo information. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| `getDate(self)` | This returns a string of the date when the photo was taken/created.
    |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| `previewPhoto(self)` | This returns a string of the filename of the previewed
    thumbnail. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: 'The properties and their respective descriptions are as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '| **Properties** | **Description** |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| `self.filename` | The filename of the photo. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| `self.filevalid` | This is set to `True` if the file is opened successfully.
    |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| `self.exifvalid` | This is set to `True` if the photo contains EXIF information.
    |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: '| `self.exif_info` | This contains the EXIF information from the photo. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| `self.filedates` | This contains a dictionary of the available dates from
    the file and photo information. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: To test the new class, we will create some test code to confirm that everything
    is working as we expect; see the following section.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We previously created the `Photo` class. Now we can add some test code to our
    module to ensure that it functions as we expect. We can use the `__name__ ="__main__"`
    attribute
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: as before to detect whether the module has been run directly or not.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add the subsequent section of code at the end of the `photohandler.py`
    script to produce the following test application, which looks as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f11a6a8e-e92f-4692-8a5d-cdf01d247317.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: The Photo View Demo application
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code at the end of `photohandler.py`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The previous test code will run the `main()` function, which takes the filename
    of a photo to use and creates a new `Photo` object called `viewPhoto`. If `viewPhoto`
    is opened successfully, we will call `dispPreview()` to display the image and
    its details.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dispPreview()` function creates four Tkinter widgets to be displayed:
    a `Canvas` to load the thumbnail image, a `Listbox` widget to display the photo
    information, and two scroll bars to control the `Listbox`. First, we create a
    `Canvas` widget the size of the thumbnail image (`previewsize`).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create `photoInfo`, which will be our `listvariable` parameter linked
    to the `Listbox` widget. Since Tkinter doesn't provide a `ListVar()` function
    to create a suitable item, we use the generic type `TK.Variable()` and then ensure
    we convert it to a tuple type before setting the value. The `Listbox` widget gets
    added; we need to make sure that the `listvariable` parameter is set to `photoInfo`
    and also set the font to `monospace`. This will allow us to line up our data values
    using spaces, as `monospace` is a fixed width font, so each character takes up
    the same width as any other.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the two scroll bars, linking them to the `Listbox` widget, by setting
    the `Scrollbar` command parameters for vertical and horizontal scroll bars to
    `lbPhotoInfo.yview` and `lbPhotoInfo.xview`. Then, we adjust the parameters of
    the `Listbox` using the following command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `configure` command allows us to add or change the widget's parameters after
    it has been created, in this case linking the two scroll bars so the `Listbox`
    widget can also control them if the user scrolls within the list.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: As before, we make use of the grid layout to ensure that the `Listbox` widget
    has the two scroll bars placed correctly next to it and the `Canvas` widget is
    to the left of the `Listbox` widget.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'We now use the `Photo` object to create the `preview.ppm` thumbnail file (using
    the `aPhoto.previewPhoto()` function) and create a `TK.PhotoImage` object that
    can then be added to the `Canvas` widget with the following command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, we use the date information that the `Photo` class gathers and the
    EXIF information (ensuring it is valid first) to populate the `Listbox` widget.
    We do this by converting each item into a list of strings that are spaced out
    using `.ljust(25)`—it adds left justification to the name and pads it out to make
    the string 25 characters wide. Once we have the list, we convert it to a tuple
    type and set the `listvariable` (`photoInfo`) parameter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: As always, we call `app.mainloop()` to start monitoring for events to respond
    to.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Organizing your photos automatically
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a class that allows us to gather information about photos,
    we can apply this information to perform useful tasks. In this case, we will use
    the file information to automatically organize a folder full of photos into a
    subset of folders based on the dates
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'the photos were taken on. The following screenshot shows the output of the
    script:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/791ad614-7a78-4a55-8e19-2e94924fda3e.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: Script output to organize photos in folder
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a selection of photos placed in a folder on Raspberry Pi. Alternatively,
    you can insert a USB memory stick or a card reader with photos on it—they will
    be located in `/mnt/`. However, please make sure you test the scripts with a copy
    of your photos first, just in case there are any problems.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the following script in `filehandler.py` to automatically organize your
    photos:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We shall make a class called `FileList`; it will make use of the `Photo` class
    to manage
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'the photos within a specific folder. There are two main steps for this: we
    first need to find all the images within the folder, and then generate a list
    containing both the filename and the photo date. We will use this information
    to generate new subfolders and move the photos into these folders.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: When we create the `FileList` object, we will create the list using `listFileDates()`.
    We will then confirm that the folder provided is valid and use `os.listdir` to
    obtain the full list of files within the directory. We will check that each file
    is a JPEG file and obtain each photo's date (using the function defined in the
    `Photo` class). Next, we will add the filename and date as a tuple to the `self.photo_namedates`
    list.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will use the built-in `sorted` function to place all the files in
    order of their date. While we don't need to do this here, this function would
    make it easier to remove duplicate dates if we were to use this module elsewhere.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The `sorted` function requires the list to be sorted, and, in this case, we
    want to sort it by the `date values:`
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '`   sorted(self.photo_namedates,key=lambda date: date[DATE])`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: We will substitute `date[DATE]` with `lambda date:` as the value to sort by.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Once the `FileList` object has been initialized, we can use it by calling `genFolders()`.
    First, we convert the date text into a suitable format for our folders (YYYYMMDD),
    allowing our folders to be easily sorted in order of their date. Next, it will
    create the folders within the current directory if they don't already exist. Finally,
    it will move each of the files into the required subfolder.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'We end up with our `FileList` class that is ready to be tested:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operations** | **Description** |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| `__init__(self,folder)` | This is the object initializer. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '| `getPhotoNamedates(self)` | This returns a list of the filenames of the dates
    of the photos. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: '| `listFileDates(self)` | This creates a list of the filenames and dates of
    the photos in the folder. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| `genFolders(self)` | This creates new folders based on a photo''s date and
    moves the files into them. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: 'The properties are listed as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '| **Properties** | **Description** |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: '| `self.folder` | The folder we are working with. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: '| `self.photo_namedates` | This contains a list of the filenames and dates.
    |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
- en: 'The `FileList` class encapsulates all the functions and the relevant data together,
    keeping everything in one logical place:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4a862df-0e43-4755-9c7b-af620e6ce07d.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: Tkinter filediaglog.askdirectory() is used to select the photo directory
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: To test this, we use the Tkinter `filedialog.askdirectory()` widget to allow
    us to select a target directory of pictures. We use `app.withdrawn()` to hide
    the main Tkinter window since it isn't required this time. We just need to create
    a new `FileList` object and then call `genFolders()` to move all our photos to
    new locations!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Two additional flags have been defined in this script that provide extra control
    for testing. `DEBUG` allows us to enable or disable extra debugging messages by
    setting them to either `True` or `False`. Furthermore, `FOLDERSONLY`, when set
    to `True`, only generates the folders and doesn't move the files (this is helpful
    for testing whether the new subfolders are correct).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Once you have run the script, you can check if all the folders have been created
    correctly. Finally, change `FOLDERSONLY` to `True`, and your program will automatically
    move and organize your photos according to their dates the next time. It is recommended
    that you
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: only run this on a copy of your photos, just in case you get an error.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
