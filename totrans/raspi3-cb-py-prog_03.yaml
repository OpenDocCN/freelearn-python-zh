- en: Using Python for Automation and Productivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Tkinter to create graphical user interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a graphical Start menu application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying photo information in an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing your photos automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have focused purely on command-line applications; however, there
    is much more to Raspberry Pi than just the command line. By using **graphical
    user interfaces** (**GUIs**), it is often easier to obtain input from a user and
    provide feedback in a simpler way. After all, we continuously process multiple
    inputs and outputs all the time, so why limit ourselves to the procedural format
    of the command line when we don't have to?
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Python can support this. Much like other programming languages,
    such as Visual Basic and C/C++/C#, this can be achieved using prebuilt objects
    that provide standard controls. We will use a module called **Tkinter** which
    provides a good range of controls (also referred to as **widgets**) and tools
    for creating graphical applications.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will take an example, `encryptdecrypt.py`, and demonstrate how useful
    modules can be written and reused in a variety of ways. This is an example of
    good coding practice. We should aim to write code that can be tested thoroughly
    and then reused in many places.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will extend our previous examples by creating a small graphical Start
    menu application to run our favorite applications from.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will explore using **classes** within our applications to display and
    then to
  prefs: []
  type: TYPE_NORMAL
- en: organize photos.
  prefs: []
  type: TYPE_NORMAL
- en: Using Tkinter to create graphical user interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a basic GUI to allow the user to enter information, and the program
    can then be used to encrypt and decrypt it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You must ensure that this file is placed in the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are using Tkinter (one of many available add-ons for Python), we need
    to ensure that it is installed. It should be installed by default on the standard
    Raspbian image. We can confirm it is installed by importing it from the Python
    prompt, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`   Python3`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   >>> import tkinter`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If it is not installed, an `ImportError` exception will be raised, in which
    case you can install it using the following command (use *Ctrl* + *Z* to exit
    the Python prompt):'
  prefs: []
  type: TYPE_NORMAL
- en: '`   sudo apt-get install python3-tk`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the module did load, you can use the following command to read more about
    the module (use *Q* to quit when you are done reading):'
  prefs: []
  type: TYPE_NORMAL
- en: '`   >>>help(tkinter)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also get information about all the classes, functions, and methods
    within the module using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`   >>>help(tkinter.Button)`'
  prefs: []
  type: TYPE_NORMAL
- en: The following `dir` command will list any valid commands or variables that are
    in the scope of the `module:`
  prefs: []
  type: TYPE_NORMAL
- en: '`   >>>dir(tkinter.Button)`'
  prefs: []
  type: TYPE_NORMAL
- en: You will see that our own modules will have the information about the functions
    marked by triple quotes; this will show up if we use the `help` command.
  prefs: []
  type: TYPE_NORMAL
- en: The command line will not be able to display the graphical displays created
    in this chapter, so you will have to start Raspberry Pi desktop (using the command
    `startx`), or if you are using it remotely.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have **X11 forwarding** enabled and an **X server** running (see
    [Chapter 1](b2230c60-fd75-45fd-82c8-e477459db3e0.xhtml), *Getting Started with
    a Raspberry Pi 3 Computer*).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the `tkinter` module to produce a GUI for the `encryptdecrypt.py`
    script.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate the GUI we will create the following `tkencryptdecrypt.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We start by importing two modules; the first is our own `encryptdecrypt` module
    and the second is the `tkinter` module. To make it easier to see which items have
    come from where, we use `ENC`/`TK`. If you want to avoid the extra reference,
    you can use `from <module_name> import *` to refer to the module items directly.
  prefs: []
  type: TYPE_NORMAL
- en: The `encryptButton()` and `decryptButton()` functions will be called when we
    click on the Encrypt and Decrypt buttons; they are explained in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: The main Tkinter window is created using the `Tk()` command, which returns the
    main window where all the widgets/controls can be placed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define six controls as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Label`: This displays the prompt Enter message to encrypt:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Entry`: This provides a textbox to receive the user''s message to be encrypted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Button`: This is an Encrypt button to trigger the message to be encrypted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Button`: This is a Decrypt button to reverse the encryption'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Label`: This displays the Key: field to prompt the user for an encryption
    key value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Entry`: This provides a second textbox to receive values for the encryption
    keys'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These controls will produce a GUI similar to the one shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25cc32ac-9411-441c-b8af-b720909623a8.png)'
  prefs: []
  type: TYPE_IMG
- en: The GUI to encrypt/decrypt messages
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the first `label1` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: All controls must be linked to the application window; hence, we have to specify
    our Tkinter window `root`. The text used for the label is set by `text`; in this
    case, we have set it to a string named `prompt`, which has been defined previously
    with the text we require. We also set the `width` to match the number of characters
    of the message (while not essential, it provides a neater result if we add more
    text to our labels later), and finally, we set the background color using `bg='green'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define the text `Entry` box for our message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will define `textvariable`—a useful way to link a variable to the contents
    of the box which is a special string variable. We could access the `text` directly
    using `textEnter.get()`, but we shall use a `Tkinter StringVar()` object instead
    to access it indirectly. If required, this will allow us to separate the data
    we are processing from the code that handles the GUI layout. The `enycrptvalue`
    variable automatically updates the `Entry` widget it is linked to whenever the
    `.set()` command is used (and the `.get()` command obtains the latest value from
    the `Entry` widget).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have our two `Button` widgets, Encrypt and Decrypt, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we can set a function to be called when the `Button` widget is
    clicked by setting the `command` attribute. We can define the two functions that
    will be called when each button is clicked. In the following code snippet, we
    have the `encryptButton()` function, which will set the `encryptvalue StringVar`
    that controls the contents of the first `Entry` box. This string is set to the
    result we get by calling `ENC.encryptText()` with the message we want to encrypt
    (the current value of `encryptvalue`) and the `keyvalue` variable. The `decrypt()`
    function is exactly the same, except we make the `keyvalue` variable negative
    to decrypt the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We then set the final `Label` and `Entry` widgets in a similar way. Note that
    `textvariable` can also be an integer (numerical value) if required, but there
    is no built-in check to ensure that only numbers can be entered. You will encounter
    a `ValueError` exception when the `.get()` command is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have defined all the widgets to be used in the Tkinter window, we
    have to set the layout. There are three ways to define the layout in Tkinter:
    *place*, *pack*, and *grid*.'
  prefs: []
  type: TYPE_NORMAL
- en: The place layout allows us to specify the positions and sizes using exact pixel
    positions. The pack layout places the items in the window in the order that they
    have been added in. The grid layout allows us to place the items in a specific
    layout. It is recommended that you avoid the place layout wherever possible since
    any small change to one item can have a knock-on effect on the positions and sizes
    of all the other items; the other layouts account for this by determining their
    positions relative to the other items in the window.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will place the items as laid out in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53ee12ff-f352-43f6-871f-20ce50fdeecb.png)'
  prefs: []
  type: TYPE_IMG
- en: Grid layout for the Encrypt/Decrypt GUI
  prefs: []
  type: TYPE_NORMAL
- en: 'The positions of first two items in the GUI are set using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can specify that the first `Label` and `Entry` box will span both columns
    (`columnspan=2`), and we can set the sticky values to ensure they span right to
    the edges. This is achieved by setting both the `TK.E` for the east and `TK.W`
    for the west sides. We'd use `TK.N` for the north and `TK.S` for the south sides
    if we needed to do the same vertically. If the `column` value is not specified,
    the grid function defaults to `column=0`. The other items are similarly defined.
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to call `TK.mainloop()`, which allows Tkinter to run; this
    allows the buttons to be monitored for clicks and Tkinter to call the functions
    linked to them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a graphical application – Start menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example in this recipe shows how we can define our own variations of Tkinter
    objects to generate custom controls and dynamically construct a menu with them.
    We will also take a quick look at using threads to allow other tasks to continue
    to function while a particular task is being executed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To view the GUI display, you will need a monitor displaying the Raspberry Pi
    desktop, or you need to be connected to another computer running the X server.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a graphical Start menu application, create the following `graphicmenu.py`
    script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code produces the following application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/81acc2fb-5452-4f1b-8507-28bbdbaa02ee.png)'
  prefs: []
  type: TYPE_IMG
- en: The App Menu GUI
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We create the Tkinter window as we did before; however, instead of defining
    all the items separately, we create a special class for the application buttons.
  prefs: []
  type: TYPE_NORMAL
- en: The class we create acts as a blueprint or specification of what we want the
    `appButtons` items to include. Each item will consist of a string value for `app_cmd`,
    a function called `startApp()`, and an `__init__()` function. The `__init__()`
    function is a special function (called a **constructor**) that is called when
    we create an `appButtons` item; it will allow us to create any setup that is required.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the `__init__()` function allows us to create a new Tkinter button
    with the text to be set to an item in `app_list` and the command to be called
    in the `startApp()` function when the button is clicked. The `self` keyword is
    used so that the command called will be the one that is part of the item; this
    means that each button will call a locally defined function that has access to
    the local data of the item.
  prefs: []
  type: TYPE_NORMAL
- en: We set the value of `self.app_cmd` to the command from `app_list` and make it
    ready for use via the `startApp()` function. We now create the `startApp()` function.
    If we run the application command here directly, the Tkinter window will freeze
    until the application we have opened is closed again. To avoid this, we can use
    the Python threading module, which allows us to perform multiple actions at the
    same time.
  prefs: []
  type: TYPE_NORMAL
- en: The `runApplicationThread()` class is created using the `threading.Thread` class
    as a template—this inherits all the features of the `threading.Thread` class in
    a new class. Just like our previous class, we provide an `__init__()` function
    for this as well. We first call the `__init__()` function of the inherited class
    to ensure it is set up correctly, and then we store the `app_cmd` value in `self.cmd`.
    After the `runApplicationThread()` function has been created and initialized,
    the `start()` function is called. This function is part of `threading.Thread`,
    which our class can use. When the `start()` function is called, it will create
    a separate application thread (that is, simulate running two things at the same
    time), allowing Tkinter to continue monitoring button clicks while executing the
    `run()` function within the class.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we can place the code in the `run()` function to run the required
    application (using `call(self.cmd)`).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One aspect that makes Python particularly powerful is that it supports the programming
    techniques used in **Object-Orientated Design** (**OOD**). This is commonly used
    by modern programming languages to help translate the tasks we want our program
    to perform into meaningful constructs and structures in code. The principle of
    OOD lies in the fact that we think of most problems as consisting of several objects
    (a GUI window, a button, and so on) that interact with each other to produce a
    desired result.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we found that we could use classes to create unique
    objects that could be reused multiple times. We created an `appButton` class,
    which generated an object with all the features of the class, including its own
    personal version of `app_cmd` that will be used by the `startApp()` function.
    Another object of the `appButton` type will have its own unrelated `[app_cmd]`
    data that its `startApp()` function will use.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that classes are useful to keep together a collection of related
    variables and functions in a single object, and the class will hold its own data
    in one place. Having multiple objects of the same type (class), each with their
    own functions and data inside them, results in better program structure. The traditional
    approach would be to keep all the information in one place and send each item
    back and forth for various functions to process; however, this may become cumbersome
    in large systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the organization of related functions and data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/492bc7ec-fea9-40dd-8eea-8e1552388b07.png)'
  prefs: []
  type: TYPE_IMG
- en: Data and functions
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have used Python modules to separate parts of our programs into different
  prefs: []
  type: TYPE_NORMAL
- en: files; this allows us to conceptually separate different parts of the program
    (an interface, encoder/decoder, or library of classes, such as Tkinter). Modules
    can provide code to control a particular bit of hardware, define an interface
    for the internet, or provide a library of common functionality; however, its most
    important function is to control the interface (the collection of functions, variables,
    and classes that are available when the item is imported). A well-implemented
    module should have a clear interface that is centered around how it is used, rather
    than how it is implemented. This allows you to create multiple modules that can
    be swapped and changed easily since they share the same interface. In our previous
    example, imagine how easy it would be to change the `encryptdecrypt` module for
    another one just by supporting `encryptText(input_text,key)`. Complex functionality
    can be split into smaller, manageable blocks that can be reused in multiple applications.
  prefs: []
  type: TYPE_NORMAL
- en: Python makes use of classes and modules all the time. Each time you import a
    library, such as `sys` or Tkinter or convert a value using `value.str()` and iterate
    through a list using `for...in`, you can use them without worrying about the details.
    You don't have to use classes or modules in every bit of code you write, but they
    are useful tools to keep in your programmer's toolbox for times when they fit
    what you are doing.
  prefs: []
  type: TYPE_NORMAL
- en: We will understand how classes and modules allow us to produce well-structured
    code that is easier to test and maintain by using them in the examples of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying photo information in an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we shall create a utility class to handle photos that can be
    used by other applications (as modules) to access photo metadata and display preview
    images easily.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following script makes use of **Python Image Library** (**PIL**); a compatible
    version for Python 3 is **Pillow**.
  prefs: []
  type: TYPE_NORMAL
- en: Pillow has not been included in the Raspbian repository (used by `apt-get`);
    therefore, we will need to install Pillow using a **Python Package Manager** called
    **PIP**.
  prefs: []
  type: TYPE_NORMAL
- en: To install packages for Python 3, we will use the Python 3 version of PIP (this
    requires 50 MB of available space).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands can be used to install PIP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Before you use PIP, ensure that you have installed `libjpeg-dev` to allow Pillow
    to handle JPEG files. You can do this using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can install Pillow using the following PIP command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: PIP also makes it easy to uninstall packages using `uninstall` instead of `install`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can confirm that it has installed successfully by running `python3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You should not get any errors and see lots of information about PIL and its
    uses (press *Q* to finish). Check the version installed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You should see `2.7.0` (or similar).
  prefs: []
  type: TYPE_NORMAL
- en: 'PIP can also be used with Python 2 by installing pip-2.x using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`   sudo apt-get install python-pip`'
  prefs: []
  type: TYPE_NORMAL
- en: Any packages installed using `sudo pip install` will be installed just for Python
    2.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To display photo information in an application, create the following `photohandler.py`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The previous code defines our `Photo` class; it is of no use to us until we
    run it in the *There's more...* section and in the next example.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We define a general class called `Photo`; it contains details about itself and
    provides
  prefs: []
  type: TYPE_NORMAL
- en: functions to access **Exchangeable Image File Format** (**EXIF**) information
    and generate
  prefs: []
  type: TYPE_NORMAL
- en: a preview image.
  prefs: []
  type: TYPE_NORMAL
- en: In the `__init__()` function, we set values for our class variables and call
    `self.initImage()`, which will open the image using the `Image()` function from
    the PIL. We then call `self.initExif()` and `self.initDates()` and set a flag
    to indicate whether the file was valid or not. If not valid, the `Image()` function
    would raise an `IOError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `initExif()` function uses PIL to read the EXIF data from the `img` object,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is a series of compound statements that results in `self.exif_info`
    being populated with a dictionary of tag names and their related values.
  prefs: []
  type: TYPE_NORMAL
- en: '`ExifTag.TAGS` is a dictionary that contains a list of possible tag names linked
    with their IDs, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `image._getexif()` function returns a dictionary that contains all the
    values set by the camera of the image, each linked to their relevant IDs, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for` loop will go through each item in the image''s EXIF value dictionary
    and check for its occurrence in the `ExifTags.TAGS` dictionary; the result will
    get stored in `self.exif_info`. The code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Again, if there are no exceptions, we set a flag to indicate that the EXIF data
    is valid, or if there is no EXIF data, we raise an `AttributeError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: The `initDates()` function allows us to gather all the possible file dates and
    dates from the EXIF data so that we can select one of them as the date we wish
    to use for the file. For example, it allows us to rename all the images to a filename
    in the standard date format. We create a `self.filedates` dictionary that we populate
    with three dates extracted from the EXIF information. We then add the filesystem
    dates (created and modified) just in case no EXIF data is available. The `os`
    module allows us to use `os.path.getctime()` and `os.path.getmtime()` to obtain
    an epoch value of the file creation. It can also be the date and time when the
    file was moved – and the file modification – when it was last written to (for
    example, it often refers to the date when the picture was taken). The epoch value
    is the number of seconds since January 1, 1970, but we can use `datetime.datetime.fromtimestamp()`
    to convert it into years, months, days, hours, and seconds. Adding `date()` simply
    limits it to years, months, and days.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if the `Photo` class was to be used by another module, and we wished to
    know the date of the image that was taken, we could look at the `self.dates` dictionary
    and pick out a suitable date. However, this would require the programmer to know
    how the `self.dates` values are arranged, and if we later changed how they are
    stored, it would break their program. For this reason, it is recommended that
    we access data in a class through access functions so the implementation is independent
    of the interfaces (this process is known as **encapsulation**). We provide a function
    that returns a date when called; the programmer does not need to know that it
    could be one of the five available dates or even that they are stored as epoch
    values. Using a function, we can ensure that the interface will remain the same
    no matter how the data is stored or collected.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last function we want the `Photo` class to provide is `previewPhoto()`.
    This function provides a method to generate a small thumbnail image and saves
    it as a **Portable Pixmap Format** (**PPM**) file. As we will discover in a moment,
    Tkinter allows us to place images on its `Canvas` widget, but unfortunately, it
    does not support JPEGs directly and only supports GIF or PPM. Therefore, we simply
    save a small copy of the image we want to display in the PPM format – with the
    added warning that the image pallet must be converted to RGB too – and then get
    Tkinter to load it onto the `Canvas` when required.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, the `Photo` class we have created is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operations** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `__init__(self,filename)` | This is the object initializer. |'
  prefs: []
  type: TYPE_TB
- en: '| `initImage(self)` | This returns `img`, a PIL-type image object. |'
  prefs: []
  type: TYPE_TB
- en: '| `initExif(self,image)` | This extracts all the EXIF information, if any is
    present. |'
  prefs: []
  type: TYPE_TB
- en: '| `initDates(self)` | This creates a dictionary of all the dates available
    from the file and photo information. |'
  prefs: []
  type: TYPE_TB
- en: '| `getDate(self)` | This returns a string of the date when the photo was taken/created.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `previewPhoto(self)` | This returns a string of the filename of the previewed
    thumbnail. |'
  prefs: []
  type: TYPE_TB
- en: 'The properties and their respective descriptions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Properties** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `self.filename` | The filename of the photo. |'
  prefs: []
  type: TYPE_TB
- en: '| `self.filevalid` | This is set to `True` if the file is opened successfully.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `self.exifvalid` | This is set to `True` if the photo contains EXIF information.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `self.exif_info` | This contains the EXIF information from the photo. |'
  prefs: []
  type: TYPE_TB
- en: '| `self.filedates` | This contains a dictionary of the available dates from
    the file and photo information. |'
  prefs: []
  type: TYPE_TB
- en: To test the new class, we will create some test code to confirm that everything
    is working as we expect; see the following section.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We previously created the `Photo` class. Now we can add some test code to our
    module to ensure that it functions as we expect. We can use the `__name__ ="__main__"`
    attribute
  prefs: []
  type: TYPE_NORMAL
- en: as before to detect whether the module has been run directly or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add the subsequent section of code at the end of the `photohandler.py`
    script to produce the following test application, which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f11a6a8e-e92f-4692-8a5d-cdf01d247317.png)'
  prefs: []
  type: TYPE_IMG
- en: The Photo View Demo application
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code at the end of `photohandler.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The previous test code will run the `main()` function, which takes the filename
    of a photo to use and creates a new `Photo` object called `viewPhoto`. If `viewPhoto`
    is opened successfully, we will call `dispPreview()` to display the image and
    its details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dispPreview()` function creates four Tkinter widgets to be displayed:
    a `Canvas` to load the thumbnail image, a `Listbox` widget to display the photo
    information, and two scroll bars to control the `Listbox`. First, we create a
    `Canvas` widget the size of the thumbnail image (`previewsize`).'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create `photoInfo`, which will be our `listvariable` parameter linked
    to the `Listbox` widget. Since Tkinter doesn't provide a `ListVar()` function
    to create a suitable item, we use the generic type `TK.Variable()` and then ensure
    we convert it to a tuple type before setting the value. The `Listbox` widget gets
    added; we need to make sure that the `listvariable` parameter is set to `photoInfo`
    and also set the font to `monospace`. This will allow us to line up our data values
    using spaces, as `monospace` is a fixed width font, so each character takes up
    the same width as any other.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the two scroll bars, linking them to the `Listbox` widget, by setting
    the `Scrollbar` command parameters for vertical and horizontal scroll bars to
    `lbPhotoInfo.yview` and `lbPhotoInfo.xview`. Then, we adjust the parameters of
    the `Listbox` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `configure` command allows us to add or change the widget's parameters after
    it has been created, in this case linking the two scroll bars so the `Listbox`
    widget can also control them if the user scrolls within the list.
  prefs: []
  type: TYPE_NORMAL
- en: As before, we make use of the grid layout to ensure that the `Listbox` widget
    has the two scroll bars placed correctly next to it and the `Canvas` widget is
    to the left of the `Listbox` widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now use the `Photo` object to create the `preview.ppm` thumbnail file (using
    the `aPhoto.previewPhoto()` function) and create a `TK.PhotoImage` object that
    can then be added to the `Canvas` widget with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we use the date information that the `Photo` class gathers and the
    EXIF information (ensuring it is valid first) to populate the `Listbox` widget.
    We do this by converting each item into a list of strings that are spaced out
    using `.ljust(25)`—it adds left justification to the name and pads it out to make
    the string 25 characters wide. Once we have the list, we convert it to a tuple
    type and set the `listvariable` (`photoInfo`) parameter.
  prefs: []
  type: TYPE_NORMAL
- en: As always, we call `app.mainloop()` to start monitoring for events to respond
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing your photos automatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a class that allows us to gather information about photos,
    we can apply this information to perform useful tasks. In this case, we will use
    the file information to automatically organize a folder full of photos into a
    subset of folders based on the dates
  prefs: []
  type: TYPE_NORMAL
- en: 'the photos were taken on. The following screenshot shows the output of the
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/791ad614-7a78-4a55-8e19-2e94924fda3e.png)'
  prefs: []
  type: TYPE_IMG
- en: Script output to organize photos in folder
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a selection of photos placed in a folder on Raspberry Pi. Alternatively,
    you can insert a USB memory stick or a card reader with photos on it—they will
    be located in `/mnt/`. However, please make sure you test the scripts with a copy
    of your photos first, just in case there are any problems.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the following script in `filehandler.py` to automatically organize your
    photos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We shall make a class called `FileList`; it will make use of the `Photo` class
    to manage
  prefs: []
  type: TYPE_NORMAL
- en: 'the photos within a specific folder. There are two main steps for this: we
    first need to find all the images within the folder, and then generate a list
    containing both the filename and the photo date. We will use this information
    to generate new subfolders and move the photos into these folders.'
  prefs: []
  type: TYPE_NORMAL
- en: When we create the `FileList` object, we will create the list using `listFileDates()`.
    We will then confirm that the folder provided is valid and use `os.listdir` to
    obtain the full list of files within the directory. We will check that each file
    is a JPEG file and obtain each photo's date (using the function defined in the
    `Photo` class). Next, we will add the filename and date as a tuple to the `self.photo_namedates`
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will use the built-in `sorted` function to place all the files in
    order of their date. While we don't need to do this here, this function would
    make it easier to remove duplicate dates if we were to use this module elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: The `sorted` function requires the list to be sorted, and, in this case, we
    want to sort it by the `date values:`
  prefs: []
  type: TYPE_NORMAL
- en: '`   sorted(self.photo_namedates,key=lambda date: date[DATE])`'
  prefs: []
  type: TYPE_NORMAL
- en: We will substitute `date[DATE]` with `lambda date:` as the value to sort by.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `FileList` object has been initialized, we can use it by calling `genFolders()`.
    First, we convert the date text into a suitable format for our folders (YYYYMMDD),
    allowing our folders to be easily sorted in order of their date. Next, it will
    create the folders within the current directory if they don't already exist. Finally,
    it will move each of the files into the required subfolder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We end up with our `FileList` class that is ready to be tested:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operations** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `__init__(self,folder)` | This is the object initializer. |'
  prefs: []
  type: TYPE_TB
- en: '| `getPhotoNamedates(self)` | This returns a list of the filenames of the dates
    of the photos. |'
  prefs: []
  type: TYPE_TB
- en: '| `listFileDates(self)` | This creates a list of the filenames and dates of
    the photos in the folder. |'
  prefs: []
  type: TYPE_TB
- en: '| `genFolders(self)` | This creates new folders based on a photo''s date and
    moves the files into them. |'
  prefs: []
  type: TYPE_TB
- en: 'The properties are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Properties** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `self.folder` | The folder we are working with. |'
  prefs: []
  type: TYPE_TB
- en: '| `self.photo_namedates` | This contains a list of the filenames and dates.
    |'
  prefs: []
  type: TYPE_TB
- en: 'The `FileList` class encapsulates all the functions and the relevant data together,
    keeping everything in one logical place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4a862df-0e43-4755-9c7b-af620e6ce07d.png)'
  prefs: []
  type: TYPE_IMG
- en: Tkinter filediaglog.askdirectory() is used to select the photo directory
  prefs: []
  type: TYPE_NORMAL
- en: To test this, we use the Tkinter `filedialog.askdirectory()` widget to allow
    us to select a target directory of pictures. We use `app.withdrawn()` to hide
    the main Tkinter window since it isn't required this time. We just need to create
    a new `FileList` object and then call `genFolders()` to move all our photos to
    new locations!
  prefs: []
  type: TYPE_NORMAL
- en: Two additional flags have been defined in this script that provide extra control
    for testing. `DEBUG` allows us to enable or disable extra debugging messages by
    setting them to either `True` or `False`. Furthermore, `FOLDERSONLY`, when set
    to `True`, only generates the folders and doesn't move the files (this is helpful
    for testing whether the new subfolders are correct).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have run the script, you can check if all the folders have been created
    correctly. Finally, change `FOLDERSONLY` to `True`, and your program will automatically
    move and organize your photos according to their dates the next time. It is recommended
    that you
  prefs: []
  type: TYPE_NORMAL
- en: only run this on a copy of your photos, just in case you get an error.
  prefs: []
  type: TYPE_NORMAL
