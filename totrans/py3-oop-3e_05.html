<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">When to Use Object-Oriented Programming</h1>
                </header>
            
            <article>
                
<p>In previous chapters, we've covered many of the defining features of object-oriented programming. We now know the principles and paradigms of object-oriented design, and we've covered the syntax of object-oriented programming in Python.</p>
<p>Yet, we don't know exactly how and, especially, when to utilize these principles and syntax in practice. In this chapter, we'll discuss some useful applications of the knowledge we've gained, looking at some new topics along the way:</p>
<ul>
<li>How to recognize objects</li>
<li>Data and behaviors, once again</li>
<li>Wrapping data behaviors using properties</li>
<li>Restricting data using behaviors</li>
<li>The Don't Repeat Yourself principle</li>
<li>Recognizing repeated code</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Treat objects as objects</h1>
                </header>
            
            <article>
                
<p>This may seem obvious; you should generally give separate objects in your problem domain a special class in your code. We've seen examples of this in the case studies in previous chapters: first, we identify objects in the problem, and then model their data and behaviors.</p>
<p>Identifying objects is a very important task in object-oriented analysis and programming. But it isn't always as easy as counting the nouns in short paragraphs that, frankly, I have constructed explicitly for that purpose. Remember, objects are things that have both data and behavior. If we are working only with data, we are often better off storing it in a list, set, dictionary, or other Python data structure (which we'll be covering thoroughly in <a href="6a121a79-7716-4a8f-94ab-f96781e82d25.xhtml"><span class="ChapterrefPACKT">Chapter 6</span></a>, <em>Python Data Structures</em>). On the other hand, if we are working only with behavior, but no stored data, a simple function is more suitable.</p>
<p>An object, however, has both data and behavior. Proficient Python programmers use built-in data structures unless (or until) there is an obvious need to define a class. There is no reason to add an extra level of abstraction if it doesn't help organize our code. On the other hand, the <em>obvious</em> need is not always self-evident.</p>
<p>We can often start our Python programs by storing data in a few variables. As the program expands, we will later find that we are passing the same set of related variables to a set of functions. This is the time to think about grouping both variables and functions into a class. If we are designing a program to model polygons in two-dimensional space, we might start with each polygon represented as a list of points. The points would be modeled as two tuples (<em>x</em>, <em>y</em>) describing where that point is located. This is all data, stored in a set of nested data structures (specifically, a list of tuples):</p>
<pre>square = [(1,1), (1,2), (2,2), (2,1)] </pre>
<p>Now, if we want to calculate the distance around the perimeter of the polygon, we need to sum the distances between each point. To do this, we need a function to calculate the distance between two points. Here are two such functions:</p>
<pre>import math<br/><br/>def distance(p1, p2):<br/>    return math.sqrt((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2)<br/><br/>def perimeter(polygon):<br/>    perimeter = 0<br/>    points = polygon + [polygon[0]]<br/>    for i in range(len(polygon)):<br/>        perimeter += distance(points[i], points[i+1])<br/>    return perimeter<br/><br/></pre>
<p>Now, as object-oriented programmers, we clearly recognize that a <kbd>polygon</kbd> class could encapsulate the list of points (data) and the <kbd>perimeter</kbd> function (behavior). Further, a <kbd>point</kbd> class, such as we defined in <a href="0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Objects in Python</em>, might encapsulate the <kbd>x</kbd> and <kbd>y</kbd> coordinates and the <kbd>distance</kbd> method. The question is: is it valuable to do this?</p>
<p>For the previous code, maybe yes, maybe no. With our recent experience in object-oriented principles, we can write an object-oriented version in record time. Let's compare them as follows:</p>
<pre><strong>class Point:</strong><br/><strong>    def __init__(self, x, y):</strong><br/><strong>        self.x = x</strong><br/><strong>        self.y = y</strong><br/><br/>    def distance(self, p2):<br/>        return math.sqrt((self.x-p2.x)**2 + (self.y-p2.y)**2)<br/><br/><strong>class Polygon:</strong><br/><strong>    def __init__(self):</strong><br/><strong>        self.vertices = []</strong><br/><br/><strong>    def add_point(self, point):</strong><br/><strong>        self.vertices.append((point))</strong><br/><br/>    def perimeter(self):<br/>        perimeter = 0<br/>        points = self.vertices + [self.vertices[0]]<br/>        for i in range(len(self.vertices)):<br/>            perimeter += points[i].distance(points[i+1])<br/>        return perimeter</pre>
<p>As we can see from the highlighted sections, there is twice as much code here as there was in our earlier version, although we could argue that the <kbd>add_point</kbd> method is not strictly necessary.</p>
<p>Now, to understand the differences a little better, let's compare the two APIs in use. Here's how to calculate the perimeter of a square using the object-oriented code:</p>
<pre><strong>&gt;&gt;&gt; square = Polygon()</strong>
<strong>&gt;&gt;&gt; square.add_point(Point(1,1))</strong>
<strong>&gt;&gt;&gt; square.add_point(Point(1,2))</strong>
<strong>&gt;&gt;&gt; square.add_point(Point(2,2))</strong>
<strong>&gt;&gt;&gt; square.add_point(Point(2,1))</strong>
<strong>&gt;&gt;&gt; square.perimeter()</strong>
<strong>4.0</strong>  </pre>
<p>That's fairly succinct and easy to read, you might think, but let's compare it to the function-based code:</p>
<pre><strong>&gt;&gt;&gt; square = [(1,1), (1,2), (2,2), (2,1)]</strong>
<strong>&gt;&gt;&gt; perimeter(square)</strong>
<strong>4.0</strong>  </pre>
<p>Hmm, maybe the object-oriented API isn't so compact! That said, I'd argue that it was easier to <em>read</em> than the functional example. How do we know what the list of tuples is supposed to represent in the second version? How do we remember what kind of object we're supposed to pass into the <kbd>perimeter</kbd> function? <span>(a list of two tuples? That's not intuitive!)</span> We would need a lot of documentation to explain how these functions should be used.</p>
<p>In contrast, the object-oriented code is relatively self-documenting. We just have to look at the list of methods and their parameters to know what the object does and how to use it. By the time we wrote all the documentation for the functional version, it would probably be longer than the object-oriented code.</p>
<p>Finally, code length is not a good indicator of code complexity. Some programmers get hung up on complicated <em>one liners</em> that do an incredible amount of work in one line of code. This can be a fun exercise, but the result is often unreadable, even to the original author the following day. Minimizing the amount of code can often make a program easier to read, but do not blindly assume this is the case.</p>
<p>Luckily, this trade-off isn't necessary. We can make the object-oriented <kbd>Polygon</kbd> API as easy to use as the functional implementation. All we have to do is alter our <kbd>Polygon</kbd> class so that it can be constructed with multiple points. Let's give it an initializer that accepts a list of <kbd>Point</kbd> objects. In fact, let's allow it to accept tuples too, and we can construct the <kbd>Point</kbd> objects ourselves, if needed:</p>
<pre>def __init__(self, points=None): 
    points = points if points else [] 
    self.vertices = [] 
    for point in points: 
        if isinstance(point, tuple): 
            point = Point(*point) 
        self.vertices.append(point) </pre>
<p>This initializer goes through the list and ensures that any tuples are converted to points. If the object is not a tuple, we leave it as is, assuming that it is either a <kbd>Point</kbd> object already, or an unknown duck-typed object that can act like a <kbd>Point</kbd> object.</p>
<div class="packt_tip">If you are experimenting with the above code, you could subclass <kbd>Polygon</kbd> and override the <kbd>__init__</kbd> function instead of replacing the initializer or copying the <kbd>add_point</kbd> and <kbd>perimeter</kbd> methods.</div>
<p>Still, there's no clear winner between the object-oriented and more data-oriented versions of this code. They both do the same thing. If we have new functions that accept a polygon argument, such as <kbd>area(polygon)</kbd> or <kbd>point_in_polygon(polygon, x, y)</kbd>, the benefits of the object-oriented code become increasingly obvious. Likewise, if we add other attributes to the polygon, such as <kbd>color</kbd> or <kbd>texture</kbd>, it makes more and more sense to encapsulate that data into a single class.</p>
<p>The distinction is a design decision, but in general, the more important a set of data is, the more likely it is to have multiple functions specific to that data, and the more useful it is to use a class with attributes and methods instead.</p>
<p>When making this decision, it also pays to consider how the class will be used. If we're only trying to calculate the perimeter of one polygon in the context of a much greater problem, using a function will probably be quickest to code and easier to use <em>one time only</em>. On the other hand, if our program needs to manipulate numerous polygons in a wide variety of ways (calculating the perimeter, area, and intersection with other polygons, moving or scaling them, and so on), we have almost certainly identified an object; one that needs to be extremely versatile.</p>
<p>Additionally, pay attention to the interaction between objects. Look for inheritance relationships; inheritance is impossible to model elegantly without classes, so make sure to use them. Look for the other types of relationships we discussed in <a href="f3a06c74-ab7f-450f-9663-bfe014b359bf.xhtml"><span class="ChapterrefPACKT">Chapter 1</span></a>, <em>Object-Oriented Design</em>, association and composition. Composition can, technically, be modeled using only data structures; for example, we can have a list of dictionaries holding tuple values, but it is sometimes less complicated to create a few classes of objects, especially if there is behavior associated with the data.</p>
<div class="packt_infobox">Don't rush to use an object just because you can use an object, but don't neglect to create a class when you need to use a class.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding behaviors to class data with properties</h1>
                </header>
            
            <article>
                
<p>Throughout this book, we've focused on the separation of behavior and data. This is very important in object-oriented programming, but we're about to see that, in Python, the distinction is uncannily blurry. Python is very good at blurring distinctions; it doesn't exactly help us to <em>think outside the box</em>. Rather, it teaches us to stop thinking about the box.</p>
<p>Before we get into the details, let's discuss some bad object-oriented theory. Many object-oriented languages teach us to never access attributes directly<span> (Java is the most notorious)</span>. They insist that we write attribute access like this:</p>
<pre>class Color: 
    def __init__(self, rgb_value, name): 
        self._rgb_value = rgb_value 
        self._name = name 
 
<strong>    def set_name(self, name):</strong> 
        self._name = name 
     
<strong>    def get_name(self):</strong> 
        return self._name </pre>
<p>The variables are prefixed with an underscore to suggest that they are private (other languages would actually force them to be private). Then, the <kbd>get</kbd> and <kbd>set</kbd> methods provide access to each variable. This class would be used in practice as follows:</p>
<pre><strong>&gt;&gt;&gt; c = Color("#ff0000", "bright red")</strong>
<strong>&gt;&gt;&gt; c.get_name()</strong>
<strong>'bright red'</strong>
<strong>&gt;&gt;&gt; c.set_name("red")</strong>
<strong>&gt;&gt;&gt; c.get_name()</strong>
<strong>'red'</strong>  </pre>
<p>This is not nearly as readable as the direct access version that Python favors:</p>
<pre>class Color: 
    def __init__(self, rgb_value, name): 
        self.rgb_value = rgb_value 
        self.name = name 
 
c = Color("#ff0000", "bright red") 
<strong>print(c.name) 
</strong><strong>c.name = "red"</strong><br/>print(c.name)</pre>
<p>So, why would anyone insist upon the method-based syntax? Their reasoning is that, someday, we may want to add extra code when a value is set or retrieved. For example, we could decide to cache a value to avoid complex computations, or we might want to validate that a given value is a suitable input.</p>
<p>In code, for example, we could decide to change the <kbd>set_name()</kbd> method as follows:</p>
<pre>def set_name(self, name): 
    if not name: 
        raise Exception("Invalid Name") 
    self._name = name </pre>
<p>Now, in Java and similar languages, if we had written our original code for direct attribute access, and then later changed it to a method like the preceding one, we'd have a problem: anyone who had written code that accessed the attribute directly would now have to access a method. If they didn't then change the access style from attribute access to a function call, their code will be broken.</p>
<p>The mantra in these languages is that we should never make public members private. This doesn't make much sense in Python since there isn't any real concept of private members!</p>
<p>Python gives us the <kbd>property</kbd> keyword to make methods that <em>look</em> like attributes. We can therefore write our code to use direct member access, and if we ever unexpectedly need to alter the implementation to do some calculation when getting or setting that attribute's value, we can do so without changing the interface. Let's see how it looks:</p>
<pre>class Color: 
    def __init__(self, rgb_value, name): 
        self.rgb_value = rgb_value 
        self._name = name 
 
    def _set_name(self, name): 
        if not name: 
            raise Exception("Invalid Name") 
        self._name = name 
 
    def _get_name(self): 
        return self._name 
 
<strong>    name = property(_get_name, _set_name)</strong> </pre>
<p>Compared to the earlier class, we first change the <kbd>name</kbd> attribute into a (semi-)private <kbd>_name</kbd> attribute. Then, we add two more (semi-)private methods to get and set that variable, performing our validation when we set it.</p>
<p>Finally, we have the <kbd>property</kbd> declaration at the bottom. This is the Python magic. It creates a new attribute on the <kbd>Color</kbd> class called <kbd>name</kbd>, to replace the direct <kbd>name</kbd> attribute. It sets this attribute to be a <strong>property</strong>. Under the hood, <kbd>property</kbd> calls the two methods we just created whenever the value is accessed or changed. This new version of the <kbd>Color</kbd> class can be used exactly the same way as the earlier version, yet it now performs validation when we set the <kbd>name</kbd> attribute:</p>
<pre><strong>&gt;&gt;&gt; c = Color("#0000ff", "bright red")</strong>
<strong>&gt;&gt;&gt; print(c.name)</strong>
<strong>bright red</strong>
<strong>&gt;&gt;&gt; c.name = "red"</strong>
<strong>&gt;&gt;&gt; print(c.name)</strong>
<strong>red</strong>
<strong>&gt;&gt;&gt; c.name = ""</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>  File "setting_name_property.py", line 8, in _set_name</strong>
<strong>    raise Exception("Invalid Name")</strong>
<strong>Exception: Invalid Name</strong>  </pre>
<p>So, if we'd previously written code to access the <kbd>name</kbd> attribute, and then changed it to use our <kbd>property</kbd>-based object, the previous code would still work, unless it was sending an empty <kbd>property</kbd> value, which is the behavior we wanted to forbid in the first place. Success!</p>
<p>Bear in mind that, even with the <kbd>name</kbd> property, the previous code is not 100% safe. People can still access the <kbd>_name</kbd> attribute directly and set it to an empty string if they want to. But if they access a variable we've explicitly marked with an underscore to suggest it is private, they're the ones that have to deal with the consequences, not us.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Properties in detail</h1>
                </header>
            
            <article>
                
<p>Think of the <kbd>property</kbd> function as returning an object that proxies any requests to set or access the attribute value through the methods we have specified. The <kbd>property</kbd> built-in is like a constructor for such an object, and that object is set as the public-facing member for the given attribute.</p>
<p>This <kbd>property</kbd> constructor can actually accept two additional arguments, a <kbd>delete</kbd> function and a docstring for the property. The <kbd>delete</kbd> function is rarely supplied in practice, but it can be useful for logging the fact that a value has been deleted, or possibly to veto deleting if we have reason to do so. The docstring is just a string describing what the property does, no different from the docstrings we discussed in <span class="ChapterrefPACKT"><a href="0786c893-abb9-4f35-9320-3f2f54de95eb.xhtml">Chapter 2</a></span>, <em>Objects in Python</em>. If we do not supply this parameter, the docstring will instead be copied from the docstring for the first argument: the <kbd>getter</kbd> method. Here is a silly example that states whenever any of the methods are called:</p>
<pre>class Silly:<br/>    def _get_silly(self):<br/>        print("You are getting silly")<br/>        return self._silly<br/><br/>    def _set_silly(self, value):<br/>        print("You are making silly {}".format(value))<br/>        self._silly = value<br/><br/>    def _del_silly(self):<br/>        print("Whoah, you killed silly!")<br/>        del self._silly<br/><br/><strong>    silly = property(_get_silly, _set_silly, _del_silly, "This is a silly property")</strong></pre>
<p>If we actually use this class, it does indeed print out the correct strings when we ask it to:</p>
<pre><strong>&gt;&gt;&gt; s = Silly()</strong>
<strong>&gt;&gt;&gt; s.silly = "funny"</strong>
<strong>You are making silly funny</strong>
<strong>&gt;&gt;&gt; s.silly</strong>
<strong>You are getting silly</strong>
<strong>'funny'</strong>
<strong>&gt;&gt;&gt; del s.silly</strong>
<strong>Whoah, you killed silly!</strong>  </pre>
<p>Further, if we look at the help file for the <kbd>Silly</kbd> class (by issuing <kbd>help(Silly)</kbd> at the interpreter prompt), it shows us the custom docstring for our <kbd>silly</kbd> attribute:</p>
<pre><strong>Help on class Silly in module __main__: 
 
class Silly(builtins.object) 
 |  Data descriptors defined here: 
 |   
 |  __dict__ 
 |      dictionary for instance variables (if defined) 
 |   
 |  __weakref__ 
 |      list of weak references to the object (if defined) 
 |   
 |  silly 
 |      This is a silly property</strong> </pre>
<p>Once again, everything is working as we planned. In practice, properties are normally only defined with the first two parameters: the <kbd>getter</kbd> and <kbd>setter</kbd> functions. If we want to supply a docstring for a property, we can define it on the <kbd>getter</kbd> function; the property proxy will copy it into its own docstring. The <kbd>delete</kbd> function is often left empty because object attributes are so rarely deleted. If a coder does try to delete a property that doesn't have a <kbd>delete</kbd> function specified, it will raise an exception. Therefore, if there is a legitimate reason to delete our property, we should supply that function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decorators – another way to create properties</h1>
                </header>
            
            <article>
                
<p>If you've never used Python decorators before, you might want to skip this section and come back to it after we've discussed the decorator pattern in <a href="345fe617-9a90-4c59-9355-e7076759f9a4.xhtml"><span class="ChapterrefPACKT">Chapter 10</span></a>, <em>Python Design Patterns I</em>. However, you don't need to understand what's going on to use the decorator syntax in order to make property methods more readable.</p>
<p>The <kbd>property</kbd> function can be used with the decorator syntax to turn a <kbd>get</kbd> function into a <kbd>property</kbd> function, as follows:</p>
<pre>class Foo: 
<strong>    @property</strong> 
    def foo(self): 
        return "bar" </pre>
<p>This applies the <kbd>property</kbd> function as a decorator, and is equivalent to the previous <kbd>foo = property(foo)</kbd> syntax. The main difference, from a readability perspective, is that we get to mark the <kbd>foo</kbd> function as a property at the top of the method, instead of after it is defined, where it can be easily overlooked. It also means we don't have to create private methods with underscore prefixes just to define a property.</p>
<p>Going one step further, we can specify a <kbd>setter</kbd> function for the new property as follows:</p>
<pre>class Foo: 
<strong>    @property</strong> 
    def foo(self): 
        return self._foo 
 
<strong>    @foo.setter</strong> 
    def foo(self, value): 
        self._foo = value </pre>
<p>This syntax looks pretty odd, although the intent is obvious. First, we decorate the <kbd>foo</kbd> method as a getter. Then, we decorate a second method with exactly the same name by applying the <kbd>setter</kbd> attribute of the originally decorated <kbd>foo</kbd> method! The <kbd>property</kbd> function returns an object; this object always comes with its own <kbd>setter</kbd> attribute, which can then be applied as a decorator to other functions. Using the same name for the get and set methods is not required, but it does help to group together the multiple methods that access one property.</p>
<p>We can also specify a <kbd>delete</kbd> function with <kbd>@foo.deleter</kbd>. We cannot specify a docstring using <kbd>property</kbd> decorators, so we need to rely on the property copying the docstring from the initial getter method. Here's our previous <kbd>Silly</kbd> class rewritten to use <kbd>property</kbd> as a decorator:</p>
<pre>class Silly: 
<strong>    @property</strong> 
    def silly(self): 
        "This is a silly property" 
        print("You are getting silly") 
        return self._silly 
 
<strong>    @silly.setter</strong> 
    def silly(self, value): 
        print("You are making silly {}".format(value)) 
        self._silly = value 
 
<strong>    @silly.deleter</strong> 
    def silly(self): 
        print("Whoah, you killed silly!") 
        del self._silly </pre>
<p>This class operates <em>exactly</em> the same as our earlier version, including the help text. You can use whichever syntax you feel is more readable and elegant.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deciding when to use properties</h1>
                </header>
            
            <article>
                
<p>With the <span>built-in </span>property clouding the division between behavior and data, it can be confusing to know when to choose an attribute, or a method, or a property. The use case<span> example</span> we saw earlier is one of the most common uses of properties; we have some data on a class that we later want to add behavior to. There are also other factors to take into account when deciding to use a property.</p>
<p>Technically, in Python, data, properties, and methods are all attributes on a class. The fact that a method is callable does not distinguish it from other types of attributes; indeed, we'll see in <a href="b70c8ea0-4778-4005-af13-bdae3d90d2c6.xhtml"><span class="ChapterrefPACKT">Chapter 7</span></a>, <em>Python Object-Oriented Shortcuts</em>, that it is possible to create normal objects that can be called like functions. We'll also discover that functions and methods are themselves normal objects.</p>
<p>The fact that methods are just callable attributes, and properties are just customizable attributes, can help us make this decision. Methods should typically represent actions; things that can be done to, or performed by, the object. When you call a method, even with only one argument, it should <em>do</em> something. Method names are generally verbs.</p>
<p>Once confirming that an attribute is not an action, we need to decide between standard data attributes and properties. In general, always use a standard attribute until you need to control access to that property in some way. In either case, your attribute is usually a noun. The only difference between an attribute and a property is that we can invoke custom actions automatically when a property is retrieved, set, or deleted.</p>
<p>Let's look at a more realistic example. A common need for custom behavior is caching a value that is difficult to calculate or expensive to look up (requiring, for example, a network request or database query). The goal is to store the value locally to avoid repeated calls to the expensive calculation.</p>
<p>We can do this with a custom getter on the property. The first time the value is retrieved, we perform the lookup or calculation. Then, we can locally cache the value as a private attribute on our object (or in dedicated caching software), and the next time the value is requested, we return the stored data. Here's how we might cache a web page:</p>
<pre>from urllib.request import urlopen<br/><br/><br/>class WebPage:<br/>    def __init__(self, url):<br/>        self.url = url<br/>        self._content = None<br/><br/>    @property<br/><strong> def content(self):</strong><br/><strong> if not self._content:</strong><br/><strong> print("Retrieving New Page...")</strong><br/><strong> self._content = urlopen(self.url).read()</strong><br/><strong> return self._content</strong></pre>
<p>We can test this code to see that the page is only retrieved once:</p>
<pre><strong>&gt;&gt;&gt; import time</strong>
<strong>&gt;&gt;&gt; webpage = WebPage("http://ccphillips.net/")</strong>
<strong>&gt;&gt;&gt; now = time.time()</strong>
<strong>&gt;&gt;&gt; content1 = webpage.content</strong>
<strong>Retrieving New Page...</strong>
<strong>&gt;&gt;&gt; time.time() - now</strong>
<strong>22.43316888809204</strong>
<strong>&gt;&gt;&gt; now = time.time()</strong>
<strong>&gt;&gt;&gt; content2 = webpage.content</strong>
<strong>&gt;&gt;&gt; time.time() - now</strong>
<strong>1.9266459941864014</strong>
<strong>&gt;&gt;&gt; content2 == content1</strong>
<strong>True</strong>  </pre>
<p>I was on an awful satellite connection when I originally tested this code for the first version of this book back in 2010 and it took 20 seconds the first time I loaded the content. The second time, I got the result in 2 seconds (which is really just the amount of time it took to type the lines into the interpreter). On my more modern connection it looks as follows:</p>
<pre><strong>&gt;&gt;&gt; webpage = WebPage("https://dusty.phillips.codes")</strong><br/><strong>&gt;&gt;&gt; import time</strong><br/><strong>&gt;&gt;&gt; now = time.time() ; content1 = webpage.content ; print(time.time() - now)</strong><br/><strong>Retrieving New Page...</strong><br/><strong>0.6236202716827393</strong><br/><strong>&gt;&gt;&gt; now = time.time() ; content2 = webpage.content ; print(time.time() - now)</strong><br/><strong>1.7881393432617188e-05M</strong></pre>
<p>It takes about 620 milliseconds to retrieve a page from my web host. From my laptop's RAM, it takes 0.018 milliseconds!</p>
<p>Custom getters are also useful for attributes that need to be calculated on the fly, based on other object attributes. For example, we might want to calculate the average for a list of integers:</p>
<pre>class AverageList(list): 
    @property 
    def average(self): 
        return sum(self) / len(self) </pre>
<p>This very simple class inherits from <kbd>list</kbd>, so we get list-like behavior for free. We just add a property to the class, and hey presto, our list can have an average as follows:</p>
<pre><strong>&gt;&gt;&gt; a = AverageList([1,2,3,4])</strong>
<strong>&gt;&gt;&gt; a.average</strong>
<strong>2.5</strong>  </pre>
<p>Of course, we could have made this a method instead, but then we ought to call it <kbd>calculate_average()</kbd>, since methods represent actions. But a property called <kbd>average</kbd> is more suitable, and is both easier to type and easier to read.</p>
<p>Custom setters are useful for validation, as we've already seen, but they can also be used to proxy a value to another location. For example, we could add a content setter to the <kbd>WebPage</kbd> class that automatically logs into our web server and uploads a new page whenever the value is set.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Manager objects</h1>
                </header>
            
            <article>
                
<p>We've been focused on objects and their attributes and methods. Now, we'll take a look at designing higher-level objects; the kind of objects that manage other objects – the objects that tie everything together.</p>
<p>The difference between these objects and most of the previous examples is that the latter usually represent concrete ideas. Management objects are more like office managers; they don't do the actual <em>visible</em> work out on the floor, but without them, there would be no communication between departments and nobody would know what they are supposed to do (although, this can be true anyway if the organization is badly managed!). Analogously, the attributes on a management class tend to refer to other objects that do the <em>visible</em> work; the behaviors on such a class delegate to those other classes at the right time, and pass messages between them.</p>
<p>As an example, we'll write a program that does a find-and-replace action for text files stored in a compressed ZIP file. We'll need objects to represent the ZIP file and each individual text file (luckily, we don't have to write these classes, as they're available in the Python standard library). The manager object will be responsible for ensuring the following three steps occur in order:</p>
<ol>
<li>Unzipping the compressed file</li>
<li>Performing the find-and-replace action</li>
<li>Zipping up the new files</li>
</ol>
<p>The class is initialized with the <kbd>.zip</kbd> filename, and search and replace strings. We create a temporary directory to store the unzipped files in, so that the folder stays clean. The <kbd>pathlib</kbd> library helps out with file and directory manipulation. We'll learn more about it in <span class="ChapterrefPACKT"><a href="9a6335a2-1c69-4fa8-a685-02bbeeba23be.xhtml">Chapter 8</a></span>, <em>Strings and Serialization</em>, but the interface should be pretty clear in the following example:</p>
<pre>import sys 
import shutil 
import zipfile 
from pathlib import Path 
 
class ZipReplace: 
    def __init__(self, filename, search_string, replace_string): 
        self.filename = filename 
        self.search_string = search_string 
        self.replace_string = replace_string 
        self.temp_directory = Path(f"unzipped-{filename}")</pre>
<p>Then, we create an overall <em>manager</em> method for each of the three steps. This method delegates responsibility to other objects:</p>
<pre>def zip_find_replace(self): <br/>    self.unzip_files() <br/>    self.find_replace() <br/>    self.zip_files() </pre>
<p>Obviously, we could do all three steps in one method, or indeed in one script, without ever creating an object. There are several advantages to separating the three steps:</p>
<ul>
<li><strong>Readability</strong>: The code for each step is in a self-contained unit that is easy to read and understand. The method name describes what the method does, and less additional documentation is required to understand what is going on.</li>
<li><strong>Extensibility</strong>: If a subclass wanted to use compressed TAR files instead of ZIP files, it could override the <kbd>zip</kbd> and <kbd>unzip</kbd> methods without having to duplicate the <kbd>find_replace</kbd> method.</li>
<li><strong>Partitioning</strong>: An external class could create an instance of this class and call the <kbd>find_replace</kbd> method directly on some folder without having to <kbd>zip</kbd> the content.</li>
</ul>
<p>The delegation method is the first in the following code; the rest of the methods are included for completeness:</p>
<pre>    def unzip_files(self):<br/>        self.temp_directory.mkdir()<br/>        with zipfile.ZipFile(self.filename) as zip:<br/>            zip.extractall(self.temp_directory)<br/><br/>    def find_replace(self):<br/>        for filename in self.temp_directory.iterdir():<br/>            with filename.open() as file:<br/>                contents = file.read()<br/>            contents = contents.replace(self.search_string, self.replace_string)<br/>            with filename.open("w") as file:<br/>                file.write(contents)<br/><br/>    def zip_files(self):<br/>        with zipfile.ZipFile(self.filename, "w") as file:<br/>            for filename in self.temp_directory.iterdir():<br/>                file.write(filename, filename.name)<br/>        shutil.rmtree(self.temp_directory)<br/><br/><br/>if __name__ == "__main__":<br/>    ZipReplace(*sys.argv[1:4]).zip_find_replace()</pre>
<p>For brevity, the code for zipping and unzipping files is sparsely documented. Our current focus is on object-oriented design; if you are interested in the inner details of the <kbd>zipfile</kbd> module, refer to the documentation in the standard library, either online or by typing <kbd>import zipfile ; help(zipfile)</kbd> into your interactive interpreter. Note that this toy example only searches the top-level files in a ZIP file; if there are any folders in the unzipped content, they will not be scanned, nor will any files inside those folders.</p>
<div class="packt_infobox">If you are using a Python version older than 3.6, you will need to convert the path objects to strings before calling <kbd>extractall</kbd>, <kbd>rmtree</kbd>, and <kbd>file.write</kbd> on the <kbd>ZipFile</kbd> object.</div>
<p>The last two lines in the example allow us to run the program from the command line by passing the <kbd>zip</kbd> filename, the search string, and the replace string as arguments, as follows:</p>
<pre>$<strong>python zipsearch.py hello.zip hello hi</strong>  </pre>
<p>Of course, this object does not have to be created from the command line; it could be imported from another module (to perform batch ZIP file processing), or accessed as part of a GUI interface or even a higher-level management object that knows where to get ZIP files (for example, to retrieve them from an FTP server or back them up to an external disk).</p>
<p>As programs become more and more complex, the objects being modeled become less and less like physical objects. Properties are other abstract objects, and methods are actions that change the state of those abstract objects. But at the heart of every object, no matter how complex, is a set of concrete data and well-defined behaviors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Removing duplicate code</h1>
                </header>
            
            <article>
                
<p>Often, the code in management style classes such as <kbd>ZipReplace</kbd> is quite generic and can be applied in a variety of ways. It is possible to use either composition or inheritance to help keep this code in one place, thus eliminating duplicate code. Before we look at any examples of this, let's discuss a tiny bit of theory. Specifically, why is duplicate code a bad thing?</p>
<p>There are several reasons, but they all boil down to readability and maintainability. When we're writing a new piece of code that is similar to an earlier piece, the easiest thing to do is copy the old code and change whatever needs to be changed (variable names, logic, comments) to make it work in the new location. Alternatively, if we're writing new code that seems similar, but not identical, to code elsewhere in the project, it is often easier to write fresh code with similar behavior, rather than figuring out how to extract the overlapping functionality.</p>
<p>But as soon as someone has to read and understand the code and they come across duplicate blocks, they are faced with a dilemma. Code that might have appeared to make sense suddenly has to be understood. How is one section different from the other? How are they the same? Under what conditions is one section called? When do we call the other? You might argue that you're the only one reading your code, but if you don't touch that code for eight months, it will be as incomprehensible to you as it is to a fresh coder. When we're trying to read two similar pieces of code, we have to understand why they're different, as well as how they're different. This wastes the reader's time; code should always be written to be readable first.</p>
<div class="packt_infobox">I once had to try to understand someone's code that had three identical copies of the same 300 lines of very poorly written code. I had been working with the code for a month before I finally comprehended that the three <em>identical</em> versions were actually performing slightly different tax calculations. Some of the subtle differences were intentional, but there were also obvious areas where someone had updated a calculation in one function without updating the other two. The number of subtle, incomprehensible bugs in the code could not be counted. I eventually replaced all 900 lines with an easy-to-read function of 20 lines or so.</div>
<p>Reading such duplicate code can be tiresome, but code maintenance is even more tormenting. As the preceding story suggests, keeping two similar pieces of code up to date can be a nightmare. We have to remember to update both sections whenever we update one of them, and we have to remember how multiple sections differ so we can modify our changes when we are editing each of them. If we forget to update all sections, we will end up with extremely annoying bugs that usually manifest themselves as, But I fixed that already, why is it still happening<em>?</em></p>
<p>The result is that people who are reading or maintaining our code have to spend astronomical amounts of time understanding and testing it compared to the time required to write it in a non-repetitive manner in the first place. It's even more frustrating when we are the ones doing the maintenance; we find ourselves saying, Why didn't I do this right the first time? The time we save by <span>copying and pasting</span> existing code is lost the very first time we have to maintain it. Code is both read and modified many more times and much more often than it is written. Comprehensible code should always be a priority.</p>
<p>This is why programmers, especially Python programmers (who tend to value elegant code more than average developers), follow what is known as the <strong>Don't Repeat Yourself</strong> (<strong>DRY</strong>) principle. DRY code is maintainable code. My advice for beginning programmers is to never use the copy-and-paste feature of their editor. To intermediate programmers, I suggest they think thrice before they hit <em><span class="KeyPACKT">Ctrl</span></em> + <em><span class="KeyPACKT">C</span></em>.</p>
<p>But what should we do instead of code duplication? The simplest solution is often to move the code into a function that accepts parameters to account for whatever parts are different. This isn't a terribly object-oriented solution, but it is frequently optimal.</p>
<p>For example, if we have two pieces of code that unzip a ZIP file into two different directories, we can easily replace it with a function that accepts a parameter for the directory to which it should be unzipped. This may make the function itself slightly more difficult to read, but a good function name and docstring can easily make up for that, and any code that invokes the function will be easier to read.</p>
<p>That's certainly enough theory! The moral of the story is: always make the effort to refactor your code to be easier to read instead of writing bad code that may seem easier to write.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">In practice</h1>
                </header>
            
            <article>
                
<p>Let's explore two ways we can reuse existing code. After writing our code to replace strings in a ZIP file full of text files, we are later contracted to scale all the images in a ZIP file to 640 x 480. It looks like we could use a very similar paradigm to what we used in <kbd>ZipReplace</kbd>. Our first impulse might be to save a copy of that file and change the <kbd>find_replace</kbd> method to <kbd>scale_image</kbd> or something similar.</p>
<p>But, that's suboptimal. What if someday we want to change the <kbd>unzip</kbd> and <kbd>zip</kbd> methods to also open TAR files? Or maybe we'll want to use a guaranteed unique directory name for temporary files. In either case, we'd have to change it in two different places!</p>
<p>We'll start by demonstrating an inheritance-based solution to this problem. First, we'll modify our original <kbd>ZipReplace</kbd> class into a superclass for processing generic ZIP files:</p>
<pre>import sys<br/>import shutil<br/>import zipfile<br/>from pathlib import Path<br/><br/><br/>class ZipProcessor:<br/>    def __init__(self, zipname):<br/>        self.zipname = zipname<br/>        self.temp_directory = Path(f"unzipped-{zipname[:-4]}")<br/><br/>    def process_zip(self):<br/>        self.unzip_files()<br/>        self.process_files()<br/>        self.zip_files()<br/><br/>    def unzip_files(self):<br/>        self.temp_directory.mkdir()<br/>        with zipfile.ZipFile(self.zipname) as zip:<br/>            zip.extractall(self.temp_directory)<br/><br/>    def zip_files(self):<br/>        with zipfile.ZipFile(self.zipname, "w") as file:<br/>            for filename in self.temp_directory.iterdir():<br/>                file.write(filename, filename.name)<br/>        shutil.rmtree(self.temp_directory)</pre>
<p>We changed the <kbd>filename</kbd> property to <kbd>zipname</kbd> to avoid confusion with the <kbd>filename</kbd> local variables inside the various methods. This helps make the code more readable, even though it isn't actually a change in design.</p>
<p>We also dropped the two parameters to <kbd>__init__</kbd> (<kbd>search_string</kbd> and <kbd>replace_string</kbd>) that were specific to <kbd>ZipReplace</kbd>. Then, we renamed the <kbd>zip_find_replace</kbd> method to <kbd>process_zip</kbd> and made it call an (as yet undefined) <kbd>process_files</kbd> method instead of <kbd>find_replace</kbd>; these name changes help demonstrate the more generalized nature of our new class. Notice that we have removed the <kbd>find_replace</kbd> method altogether; that code is specific to <kbd>ZipReplace</kbd> and has no business here.</p>
<p>This new <kbd>ZipProcessor</kbd> class doesn't actually define a <kbd>process_files</kbd> method. If we ran it directly, it would raise an exception. Because it isn't meant to run directly, we removed the main call at the bottom of the original script. We could make this an abstract base class in order to communicate that this method needs to be defined in a subclass, but I've left it out for brevity.</p>
<p>Now, before we move on to our image processing application, let's fix up our original <kbd>zipsearch</kbd> class to make use of this parent class, as follows:</p>
<pre>class ZipReplace(ZipProcessor):<br/>    def __init__(self, filename, search_string, replace_string):<br/>        super().__init__(filename)<br/>        self.search_string = search_string<br/>        self.replace_string = replace_string<br/><br/>    def process_files(self):<br/>        """perform a search and replace on all files in the<br/>        temporary directory"""<br/>        for filename in self.temp_directory.iterdir():<br/>            with filename.open() as file:<br/>                contents = file.read()<br/>            contents = contents.replace(self.search_string, self.replace_string)<br/>            with filename.open("w") as file:<br/>                file.write(contents)</pre>
<p>This code is shorter than the original version, since it inherits its ZIP processing abilities from the parent class. We first import the base class we just wrote and make <kbd>ZipReplace</kbd> extend that class. Then, we use <kbd>super()</kbd> to initialize the parent class. The <kbd>find_replace</kbd> method is still here, but we renamed it <kbd>process_files</kbd> so the parent class can call it from its management interface. Because this name isn't as descriptive as the old one, we added a docstring to describe what it is doing.</p>
<p>Now, that was quite a bit of work, considering that all we have now is a program that is functionally not different from the one we started with! But having done that work, it is now much easier for us to write other classes that operate on files in a ZIP archive, such as the (hypothetically requested) photo scaler. Further, if we ever want to improve or bug fix the zip functionality, we can do it for all subclasses at once by changing only the one <kbd>ZipProcessor</kbd> base class. Therefore maintenance will be much more effective.</p>
<p>See how simple it is now to create a photo scaling class that takes advantage of the <kbd>ZipProcessor</kbd> functionality:</p>
<pre>from PIL import Image 
 
class ScaleZip(ZipProcessor): 
  
    def process_files(self): 
        '''Scale each image in the directory to 640x480''' 
        for filename in self.temp_directory.iterdir(): 
            im = Image.open(str(filename)) 
            scaled = im.resize((640, 480)) 
            scaled.save(filename)
 
if __name__ == "__main__": 
    ScaleZip(*sys.argv[1:4]).process_zip() </pre>
<p>Look how simple this class is! All that work we did earlier paid off. All we do is open each file (assuming that it is an image; it will unceremoniously crash if a file cannot be opened or isn't an image), scale it, and save it back. The <kbd>ZipProcessor</kbd> class takes care of the zipping and unzipping without any extra work on our part.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case study</h1>
                </header>
            
            <article>
                
<p>For this case study, we'll try to delve further into the question, When should I choose an object versus a built-in type? We'll be modeling a <kbd>Document</kbd> class that might be used in a text editor or word processor. What objects, functions, or properties should it have?</p>
<p>We might start with a <kbd>str</kbd> for the <kbd>Document</kbd> contents, but in Python, strings aren't mutable (able to be changed). Once a <kbd>str</kbd> is defined, it is forever. We can't insert a character into it or remove one without creating a brand new string object. That would be leaving a lot of <kbd>str</kbd> objects taking up memory until Python's garbage collector sees fit to clean up behind us.</p>
<p>So, instead of a string, we'll use a list of characters, which we can modify at will. In addition, we'll need to know the current cursor position within the list, and should probably also store a filename for the document.</p>
<div class="packt_infobox">Real text editors use a binary tree-based data structure called a <kbd>rope</kbd> to model their document contents. This book's title isn't <em>Advanced Data Structures</em>, so if you're interested in learning more about this fascinating topic, you may want to search the web for <em>rope data structure</em>.</div>
<p>There are a lot of things we might want to do to a text document, including inserting, deleting, and selecting characters; cutting, copying, and, pasting the selection; and saving or closing the document. It looks like there are copious amounts of both data and behavior, so it makes sense to put all this stuff into its own <kbd>Document</kbd> class.</p>
<p>A pertinent question is: should this class be composed of a bunch of basic Python objects such as <kbd>str</kbd> filenames, <kbd>int</kbd> cursor positions, and a <kbd>list</kbd> of characters? Or should some or all of those things be specially defined objects in their own right? What about individual lines and characters? Do they need to have classes of their own?</p>
<p>We'll answer these questions as we go, but let's start with the simplest possible <span>class first-</span> <kbd>Document</kbd>  and see what it can do:</p>
<pre>class Document: 
    def __init__(self): 
        self.characters = [] 
        self.cursor = 0 
        self.filename = '' 
 
    def insert(self, character): 
        self.characters.insert(self.cursor, character) 
        self.cursor += 1 
 
    def delete(self): 
        del self.characters[self.cursor] 
 
    def save(self): 
        with open(self.filename, 'w') as f: 
            f.write(''.join(self.characters)) 
 
    def forward(self): 
        self.cursor += 1 
 
    def back(self): 
        self.cursor -= 1 </pre>
<p>This basic class allows us full control over editing a basic document. Have a look at it in action:</p>
<pre><strong>&gt;&gt;&gt; doc = Document()</strong>
<strong>&gt;&gt;&gt; doc.filename = "test_document"</strong>
<strong>&gt;&gt;&gt; doc.insert('h')</strong>
<strong>&gt;&gt;&gt; doc.insert('e')</strong>
<strong>&gt;&gt;&gt; doc.insert('l')</strong>
<strong>&gt;&gt;&gt; doc.insert('l')</strong>
<strong>&gt;&gt;&gt; doc.insert('o')</strong>
<strong>&gt;&gt;&gt; "".join(doc.characters)</strong>
<strong>'hello'</strong>
<strong>&gt;&gt;&gt; doc.back()</strong>
<strong>&gt;&gt;&gt; doc.delete()</strong>
<strong>&gt;&gt;&gt; doc.insert('p')</strong>
<strong>&gt;&gt;&gt; "".join(doc.characters)</strong>
<strong>'hellp'</strong>  </pre>
<p>It looks like it's working. We could connect a keyboard's letter and arrow keys to these methods and the document would track everything just fine.</p>
<p>But what if we want to connect more than just arrow keys. What if we want to connect the <em><span class="KeyPACKT">Home</span></em> and <em><span class="KeyPACKT">End</span></em> keys as well? We could add more methods to the <kbd>Document</kbd> class that search forward or backward for newline characters (a newline character, escaped as <kbd>\n</kbd>, represents the end of one line and the beginning of a new one) in the string and jump to them, but if we did that for every possible movement action (move by words, move by sentences, <em>P<span class="KeyPACKT">age Up</span></em>, <em>P</em><span class="KeyPACKT"><em>age Down</em></span>, end of line, beginning of white space, and others), the class would be huge. Maybe it would be better to put those methods on a separate object. So, let's turn the <kbd>Cursor</kbd> attribute into an object that is aware of its position and can manipulate that position. We can move the forward and back methods to that class, and add a couple more for the <kbd><span class="KeyPACKT">Home</span></kbd> and <kbd><span class="KeyPACKT">End</span></kbd> keys, as follows:</p>
<pre>class Cursor:<br/>    def __init__(self, document):<br/>        self.document = document<br/>        self.position = 0<br/><br/>    def forward(self):<br/>        self.position += 1<br/><br/>    def back(self):<br/>        self.position -= 1<br/><br/>    def home(self):<br/>        while self.document.characters[self.position - 1].character != "\n":<br/>            self.position -= 1<br/>            if self.position == 0:<br/>                # Got to beginning of file before newline<br/>                break<br/><br/>    def end(self):<br/>        while (<br/>            self.position &lt; len(self.document.characters)<br/>            and self.document.characters[self.position] != "\n"<br/>        ):<br/>            self.position += 1</pre>
<p>This class takes the document as an initialization parameter so the methods have access to the content of the document's character list. It then provides simple methods for moving backward and forward, as before, and for moving to the <kbd>home</kbd> and <kbd>end</kbd> positions.</p>
<div class="packt_tip">This code is not very safe. You can very easily move past the ending position, and if you try to go home on an empty file, it will crash. These examples are kept short to make them readable, but that doesn't mean they are defensive! You can improve the error checking of this code as an exercise; it might be a great opportunity to expand your exception-handling skills.</div>
<p>The <kbd>Document</kbd> class itself is hardly changed, except for removing the two methods that were moved to the <kbd>Cursor</kbd> class:</p>
<pre>class Document: 
    def __init__(self): 
        self.characters = [] 
        self.cursor = Cursor(self) 
        self.filename = '' 
 
       def insert(self, character): 
        self.characters.insert(self.cursor.position, 
                character) 
        self.cursor.forward() 
 
    def delete(self): 
        del self.characters[self.cursor.position] 
 
    def save(self):<br/>        with open(self.filename, "w") as f:<br/>            f.write("".join(self.characters))</pre>
<p>We just updated anything that accessed the old cursor integer to use the new object instead. We can now test that the <kbd>home</kbd> method is really moving to the newline character, as follows:</p>
<pre><strong>&gt;&gt;&gt; d = Document()</strong>
<strong>&gt;&gt;&gt; d.insert('h')</strong>
<strong>&gt;&gt;&gt; d.insert('e')</strong>
<strong>&gt;&gt;&gt; d.insert('l')</strong>
<strong>&gt;&gt;&gt; d.insert('l')</strong>
<strong>&gt;&gt;&gt; d.insert('o')</strong>
<strong>&gt;&gt;&gt; d.insert('\n')</strong>
<strong>&gt;&gt;&gt; d.insert('w')</strong>
<strong>&gt;&gt;&gt; d.insert('o')</strong>
<strong>&gt;&gt;&gt; d.insert('r')</strong>
<strong>&gt;&gt;&gt; d.insert('l')</strong>
<strong>&gt;&gt;&gt; d.insert('d')</strong>
<strong>&gt;&gt;&gt; d.cursor.home()</strong>
<strong>&gt;&gt;&gt; d.insert("*")</strong>
<strong>&gt;&gt;&gt; print("".join(d.characters))</strong>
<strong>hello</strong>
<strong>*world</strong>  </pre>
<p>Now, since we've been using that string <kbd>join</kbd> function a lot (to concatenate the characters so we can see the actual document contents), we can add a property to the <kbd>Document</kbd> class to give us the complete string as follows:</p>
<pre>@property 
def string(self): 
    return "".join(self.characters) </pre>
<p>This makes our testing a little simpler:</p>
<pre><strong>&gt;&gt;&gt; print(d.string)</strong>
<strong>hello</strong>
<strong>world</strong>  </pre>
<p>This framework is simple to extend, create and edit a complete plain text document <span>(though it might be a bit time consuming!)</span> Now, let's extend it to work for rich text; text that can have <strong>bold</strong>, <span class="underline">underlined</span>, or <em>italic</em> characters.</p>
<p>There are two ways we could process this. The first is to insert <em>fake</em> characters into our character list that act like instructions, such as <em>bold characters until you find a stop bold character</em>. The second is to add information to each character, indicating what formatting it should have. While the former method is more common in real editors, we'll implement the latter solution. To do that, we're obviously going to need a class for characters. This class will have an attribute representing the character, as well as three Boolean attributes representing whether it is <em>bold, italic, or underlined</em>.</p>
<p>Hmm, wait! Is this <kbd>Character</kbd> class going to have any methods? If not, maybe we should use one of the many Python data structures instead; a tuple or named tuple would probably be sufficient. Are there any actions that we would want to execute or invoke on a character?</p>
<p>Well, clearly, we might want to do things with characters, such as delete or copy them, but those are things that need to be handled at the <kbd>Document</kbd> level, since they are really modifying the list of characters. Are there things that need to be done to individual characters?</p>
<p>Actually, now that we're thinking about what a <kbd>Character</kbd> class actually <strong>is</strong>... what is it? Would it be safe to say that a <kbd>Character</kbd> class is a string? Maybe we should use an inheritance relationship here? Then we can take advantage of the numerous methods that <kbd>str</kbd> instances come with.</p>
<p>What sorts of methods are we talking about? There's <kbd>startswith</kbd>, <kbd>strip</kbd>, <kbd>find</kbd>, <kbd>lower</kbd>, and many more. Most of these methods expect to be working on strings that contain more than one character. In contrast, if <kbd>Character</kbd> were to subclass <kbd>str</kbd>, we'd probably be wise to override <kbd>__init__</kbd> to raise an exception if a multi-character string were supplied. Since all those methods we'd get for free wouldn't really apply to our <kbd>Character</kbd> class, it seems we shouldn't use inheritance, after all.</p>
<p>This brings us back to our original question; should <kbd>Character</kbd> even be a class? There is a very important special method on the <kbd>object</kbd> class that we can take advantage of to represent our characters. This method, called <kbd>__str__</kbd> (two underscores at each end, like <kbd>__init__</kbd>), is used in string-manipulation functions such as <kbd>print</kbd> and the <kbd>str</kbd> constructor to convert any class to a string. The default implementation does some boring stuff, such as printing the name of the module and class, and its address in memory. But if we override it, we can make it print whatever we like. For our implementation, we could make it prefix characters with special characters to represent whether they are bold, italic, or underlined. So, we will create a class to represent a character, and here it is:</p>
<pre>class Character: 
    def __init__(self, character, 
            bold=False, italic=False, underline=False): 
        assert len(character) == 1 
        self.character = character 
        self.bold = bold 
        self.italic = italic 
        self.underline = underline 
 
    def __str__(self): 
        bold = "*" if self.bold else '' 
        italic = "/" if self.italic else '' 
        underline = "_" if self.underline else '' 
        return bold + italic + underline + self.character </pre>
<p>This class allows us to create characters and prefix them with a special character when the <kbd>str()</kbd> function is applied to them. Nothing too exciting there. We only have to make a few minor modifications to the <kbd>Document</kbd> and <kbd>Cursor</kbd> classes to work with this class. In the <kbd>Document</kbd> class, we add these two lines at the beginning of the <kbd>insert</kbd> method, as follows:</p>
<pre>def insert(self, character): 
    if not hasattr(character, 'character'): 
        character = Character(character) </pre>
<p>This is a rather strange bit of code. Its basic purpose is to check whether the character being passed in is a <kbd>Character</kbd> or a <kbd>str</kbd>. If it is a string, it is wrapped in a <kbd>Character</kbd> class so all objects in the list are <kbd>Character</kbd> objects. However, it is entirely possible that someone using our code would want to use a class that is neither a <kbd>Character</kbd> nor a string, using duck typing. If the object has a character attribute, we assume it is a <kbd>Character</kbd>-like object. But if it does not, we assume it is a <kbd>str</kbd>-like object and wrap it in <kbd>Character</kbd>. This helps the program take advantage of duck typing as well as polymorphism; as long as an object has a character attribute, it can be used in the <kbd>Document</kbd> class.</p>
<p>This generic check could be very useful. For example, if we wanted to make a programmer's editor with syntax highlighting, we'd need extra data on the character, such as what type of syntax token the character belongs to. Note that, if we are doing a lot of this kind of comparison, it's probably better to implement <kbd>Character</kbd> as an abstract base class with an appropriate <kbd>__subclasshook__</kbd>, as discussed in <a href="ba7b3eb7-17cc-4f1c-bb74-fb7d5ee7d517.xhtml"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>When Objects Are Alike</em>.</p>
<p>In addition, we need to modify the string property on <kbd>Document</kbd> to accept the new <kbd>Character</kbd> values. All we need to do is call <kbd>str()</kbd> on each character before we join it<span>, as demonstrated in the following:</span></p>
<pre>    @property 
    def string(self): 
        return "".join((str(c) for c in self.characters)) </pre>
<p>This code uses a generator expression, which we'll discuss in <a href="0abbcae0-eb3f-4237-adda-32765e1cce32.xhtml"><span class="ChapterrefPACKT">Chapter 9</span></a>, <em>The Iterator Pattern</em>. It's a shortcut to perform a specific action on all the objects in a sequence.</p>
<p>Finally, we also need to check <kbd>Character.character</kbd>, instead of just the string character we were storing before, in the <kbd>home</kbd> and <kbd>end</kbd> functions when we're looking to see whether it matches a newline character, as demonstrated in the following:</p>
<pre>    def home(self): 
        while self.document.characters[ 
                self.position-1].character != '\n': 
            self.position -= 1 
            if self.position == 0: 
                # Got to beginning of file before newline 
                break 
 
    def end(self): 
        while self.position &lt; len( 
                self.document.characters) and \ 
                self.document.characters[ 
                        self.position 
                        ].character != '\n': 
            self.position += 1 </pre>
<p>This completes the formatting of characters. We can test it to see that it works as follows:</p>
<pre><strong>&gt;&gt;&gt; d = Document()</strong>
<strong>&gt;&gt;&gt; d.insert('h')</strong>
<strong>&gt;&gt;&gt; d.insert('e')</strong>
<strong>&gt;&gt;&gt; d.insert(Character('l', bold=True))</strong>
<strong>&gt;&gt;&gt; d.insert(Character('l', bold=True))</strong>
<strong>&gt;&gt;&gt; d.insert('o')</strong>
<strong>&gt;&gt;&gt; d.insert('\n')</strong>
<strong>&gt;&gt;&gt; d.insert(Character('w', italic=True))</strong>
<strong>&gt;&gt;&gt; d.insert(Character('o', italic=True))</strong>
<strong>&gt;&gt;&gt; d.insert(Character('r', underline=True))</strong>
<strong>&gt;&gt;&gt; d.insert('l')</strong>
<strong>&gt;&gt;&gt; d.insert('d')</strong>
<strong>&gt;&gt;&gt; print(d.string)</strong>
<strong>he*l*lo</strong>
<strong>/w/o_rld</strong>
<strong>&gt;&gt;&gt; d.cursor.home()</strong>
<strong>&gt;&gt;&gt; d.delete()</strong>
<strong>&gt;&gt;&gt; d.insert('W')</strong>
<strong>&gt;&gt;&gt; print(d.string)</strong>
<strong>he*l*lo</strong>
<strong>W/o_rld</strong>
<strong>&gt;&gt;&gt; d.characters[0].underline = True</strong>
<strong>&gt;&gt;&gt; print(d.string)</strong>
<strong>_he*l*lo</strong>
<strong>W/o_rld</strong>  </pre>
<p>As expected, whenever we print the string, each bold character is preceded by a <kbd>*</kbd> character, each italicized character by a <kbd>/</kbd> character, and each underlined character by a <kbd>_</kbd> character. All our functions seem to work, and we can modify characters in the list after the fact. We have a working rich text document object that could be plugged into a proper graphical user interface and hooked up with a keyboard for input and a screen for output. Naturally, we'd want to display real <em>bold, italic, and underlined</em> fonts in a UI, instead of using our <kbd>__str__</kbd> method, but it was sufficient for the basic testing we demanded of it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exercises</h1>
                </header>
            
            <article>
                
<p>We've looked at various ways that objects, data, and methods can interact with each other in an object-oriented Python program. As usual, your first thoughts should be how you can apply these principles to your own work. Do you have any messy scripts lying around that could be rewritten using an object-oriented manager? Look through some of your old code and look for methods that are not actions. If the name isn't a verb, try rewriting it as a property.</p>
<p>Think about code you've written in any language. Does it break the DRY principle? Is there any duplicate code? Did you copy and paste code? Did you write two versions of similar pieces of code because you didn't feel like understanding the original code? Go back over some of your recent code now and see whether you can refactor the duplicate code using inheritance or composition. Try to pick a project you're still interested in maintaining; not code so old that you never want to touch it again. That will help to keep you interested when you do the improvements!</p>
<p>Now, look back over some of the examples we looked at in this chapter. Start with the cached web page example that uses a property to cache the retrieved data. An obvious problem with this example is that the cache is never refreshed. Add a timeout to the property's getter, and only return the cached page if the page has been requested before the timeout has expired. You can use the <kbd>time</kbd> module (<kbd>time.time() - an_old_time</kbd> returns the number of seconds that have elapsed since <kbd>an_old_time</kbd>) to determine whether the cache has expired.</p>
<p>Also look at the inheritance-based <kbd>ZipProcessor</kbd>. It might be reasonable to use composition instead of inheritance here. Instead of extending the class in the <kbd>ZipReplace</kbd> and <kbd>ScaleZip</kbd> classes, you could pass instances of those classes into the <kbd>ZipProcessor</kbd> constructor and call them to do the processing part. Implement this.</p>
<p>Which version do you find easier to use? Which is more elegant? What is easier to read? These are subjective questions; the answer varies for each of us. Knowing the answer, however, is important. If you find you prefer inheritance over composition, you need to pay attention that you don't overuse inheritance in your daily coding. If you prefer composition, make sure you don't miss opportunities to create an elegant inheritance-based solution.</p>
<p>Finally, add some error handlers to the various classes we created in the case study. They should ensure single characters are entered, that you don't try to move the cursor past the end or beginning of the file, that you don't delete a character that doesn't exist, and that you don't save a file without a filename. Try to think of as many edge cases as you can, and account for them (thinking about edge cases is about 90% of a professional programmer's job!). Consider different ways to handle them; should you raise an exception when the user tries to move past the end of the file, or just stay on the last character?</p>
<p>In your daily coding, pay attention to the <span class="packt_screen">copy</span> and <span class="packt_screen">paste</span> commands. Every time you use them in your editor, consider whether it would be a good idea to improve your program's organization so that you only have one version of the code you are about to copy.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we focused on identifying objects, especially objects that are not immediately apparent; objects that manage and control. Objects should have both data and behaviors, but properties can be used to blur the distinction between the two. The DRY principle is an important indicator of code quality, and inheritance and composition can be applied to reduce code duplication.</p>
<p>In the next chapter, we'll cover several of the built-in Python data structures and objects, focusing on their object-oriented properties and how they can be extended or adapted.</p>


            </article>

            
        </section>
    </body></html>