["```py\nclass GitFetcher:\n    _current_tag = None\n    def __init__(self, tag):\n        self.current_tag = tag\n    @property\n    def current_tag(self):\n        if self._current_tag is None:\n            raise AttributeError(\"tag was never set\")\n        return self._current_tag\n    @current_tag.setter\n    def current_tag(self, new_tag):\n        self.__class__._current_tag = new_tag\n    def pull(self):\n        logger.info(\"pulling from %s\", self.current_tag)\n        return self.current_tag \n```", "```py\n>>> f1 = GitFetcher(0.1)\n>>> f2 = GitFetcher(0.2)\n>>> f1.current_tag = 0.3\n>>> f2.pull()\n0.3\n>>> f1.pull()\n0.3 \n```", "```py\nclass SharedAttribute:\n    def __init__(self, initial_value=None):\n        self.value = initial_value\n        self._name = None\n    def __get__(self, instance, owner):\n        if instance is None:\n            return self\n        if self.value is None:\n            raise AttributeError(f\"{self._name} was never set\")\n        return self.value\n    def __set__(self, instance, new_value):\n        self.value = new_value\n    def __set_name__(self, owner, name):\n        self._name = name \n```", "```py\nclass GitFetcher:\n    current_tag = SharedAttribute()\n    current_branch = SharedAttribute()\n    def __init__(self, tag, branch=None):\n        self.current_tag = tag\n        self.current_branch = branch\n    def pull(self):\n        logger.info(\"pulling from %s\", self.current_tag)\n        return self.current_tag \n```", "```py\nclass BaseFetcher:\n    def __init__(self, source):\n        self.source = source\nclass TagFetcher(BaseFetcher):\n    _attributes = {}\n    def __init__(self, source):\n        self.__dict__ = self.__class__._attributes\n        super().__init__(source)\n    def pull(self):\n        logger.info(\"pulling from tag %s\", self.source)\n        return f\"Tag = {self.source}\"\nclass BranchFetcher(BaseFetcher):\n    _attributes = {}\n    def __init__(self, source):\n        self.__dict__ = self.__class__._attributes\n        super().__init__(source)\n    def pull(self):\n        logger.info(\"pulling from branch %s\", self.source)\n        return f\"Branch = {self.source}\" \n```", "```py\nclass SharedAllMixin:\n    def __init__(self, *args, **kwargs):\n        try:\n            self.__class__._attributes\n        except AttributeError:\n            self.__class__._attributes = {}\n        self.__dict__ = self.__class__._attributes\n        super().__init__(*args, **kwargs)\nclass BaseFetcher:\n    def __init__(self, source):\n        self.source = source\nclass TagFetcher(SharedAllMixin, BaseFetcher):\n    def pull(self):\n        logger.info(\"pulling from tag %s\", self.source)\n        return f\"Tag = {self.source}\"\nclass BranchFetcher(SharedAllMixin, BaseFetcher):\n    def pull(self):\n        logger.info(\"pulling from branch %s\", self.source)\n        return f\"Branch = {self.source}\" \n```", "```py\nfrom _adapter_base import UsernameLookup\nclass UserSource(UsernameLookup):\n    def fetch(self, user_id, username):\n        user_namespace = self._adapt_arguments(user_id, username)\n        return self.search(user_namespace)\n    @staticmethod\n    def _adapt_arguments(user_id, username):\n        return f\"{user_id}:{username}\" \n```", "```py\nclass UserSource:\n    ...\n    def fetch(self, user_id, username):\n        user_namespace = self._adapt_arguments(user_id, username)\n        return self.username_lookup.search(user_namespace) \n```", "```py\nclass Product:\n    def __init__(self, name: str, price: float) -> None:\n        self._name = name\n        self._price = price\n    @property\n    def price(self):\n        return self._price\nclass ProductBundle:\n    def __init__(\n        self,\n        name: str,\n        perc_discount: float,\n        *products: Iterable[Union[Product, \"ProductBundle\"]]\n    ) -> None:\n        self._name = name\n        self._perc_discount = perc_discount\n        self._products = products\n    @property\n    def price(self) -> float:\n        total = sum(p.price for p in self._products)\n        return total * (1 - self._perc_discount) \n```", "```py\nclass DictQuery:\n    def __init__(self, **kwargs):\n        self._raw_query = kwargs\n    def render(self) -> dict:\n        return self._raw_query \n```", "```py\nclass QueryEnhancer:\n    def __init__(self, query: DictQuery):\n        self.decorated = query\n    def render(self):\n        return self.decorated.render()\nclass RemoveEmpty(QueryEnhancer):\n    def render(self):\n        original = super().render()\n        return {k: v for k, v in original.items() if v}\nclass CaseInsensitive(QueryEnhancer):\n    def render(self):\n        original = super().render()\n        return {k: v.lower() for k, v in original.items()} \n```", "```py\n>>> original = DictQuery(key=\"value\", empty=\"\", none=None, upper=\"UPPERCASE\", title=\"Title\")\n>>> new_query = CaseInsensitive(RemoveEmpty(original))\n>>> original.render()\n{'key': 'value', 'empty': '', 'none': None, 'upper': 'UPPERCASE', 'title': 'Title'}\n>>> new_query.render()\n{'key': 'value', 'upper': 'uppercase', 'title': 'title'} \n```", "```py\nclass QueryEnhancer:\n    def __init__(\n        self,\n        query: DictQuery,\n        *decorators: Iterable[Callable[[Dict[str, str]], Dict[str, str]]]\n    ) -> None:\n        self._decorated = query\n        self._decorators = decorators\n    def render(self):\n        current_result = self._decorated.render()\n        for deco in self._decorators:\n            current_result = deco(current_result)\n        return current_result \n```", "```py\n>>> query = DictQuery(foo=\"bar\", empty=\"\", none=None, upper=\"UPPERCASE\", title=\"Title\")\n>>> QueryEnhancer(query, remove_empty, case_insensitive).render()\n{'foo': 'bar', 'upper': 'uppercase', 'title': 'title'} \n```", "```py\nimport re\nfrom typing import Optional, Pattern\nclass Event:\n    pattern: Optional[Pattern[str]] = None\n    def __init__(self, next_event=None):\n        self.successor = next_event\n    def process(self, logline: str):\n        if self.can_process(logline):\n            return self._process(logline)\n        if self.successor is not None:\n            return self.successor.process(logline)\n    def _process(self, logline: str) -> dict:\n        parsed_data = self._parse_data(logline)\n        return {\n            \"type\": self.__class__.__name__,\n            \"id\": parsed_data[\"id\"],\n            \"value\": parsed_data[\"value\"],\n        }\n    @classmethod\n    def can_process(cls, logline: str) -> bool:\n        return (\n            cls.pattern is not None and cls.pattern.match(logline) is not None\n        )\n    @classmethod\n    def _parse_data(cls, logline: str) -> dict:\n        if not cls.pattern:\n            return {}\n        if (parsed := cls.pattern.match(logline)) is not None:\n            return parsed.groupdict()\n        return {}\nclass LoginEvent(Event):\n    pattern = re.compile(r\"(?P<id>\\d+):\\s+login\\s+(?P<value>\\S+)\")\nclass LogoutEvent(Event):\n    pattern = re.compile(r\"(?P<id>\\d+):\\s+logout\\s+(?P<value>\\S+)\") \n```", "```py\n>>> chain = LogoutEvent(LoginEvent())\n>>> chain.process(\"567: login User\")\n{'type': 'LoginEvent', 'id': '567', 'value': 'User'} \n```", "```py\nclass SessionEvent(Event):\n    pattern = re.compile(r\"(?P<id>\\d+):\\s+log(in|out)\\s+(?P<value>\\S+)\") \n```", "```py\nchain = SessionEvent(LoginEvent(LogoutEvent())) \n```", "```py\nclass InvalidTransitionError(Exception):\n    \"\"\"Raised when trying to move to a target state from an unreachable \n    Source\n    state.\n    \"\"\"\nclass MergeRequestState(abc.ABC):\n    def __init__(self, merge_request):\n        self._merge_request = merge_request\n    @abc.abstractmethod\n    def open(self):\n        ...\n    @abc.abstractmethod\n    def close(self):\n        ...\n    @abc.abstractmethod\n    def merge(self):\n        ...\n    def __str__(self):\n        return self.__class__.__name__\nclass Open(MergeRequestState):\n    def open(self):\n        self._merge_request.approvals = 0\n    def close(self):\n        self._merge_request.approvals = 0\n        self._merge_request.state = Closed\n    def merge(self):\n        logger.info(\"merging %s\", self._merge_request)\n        logger.info(\n            \"deleting branch %s\", \n            self._merge_request.source_branch\n        )\n        self._merge_request.state = Merged\nclass Closed(MergeRequestState):\n    def open(self):\n        logger.info(\n            \"reopening closed merge request %s\", \n            self._merge_request\n        )\n        self._merge_request.state = Open\n    def close(self):\n        \"\"\"Current state.\"\"\"\n    def merge(self):\n        raise InvalidTransitionError(\"can't merge a closed request\")\nclass Merged(MergeRequestState):\n    def open(self):\n        raise InvalidTransitionError(\"already merged request\")\n    def close(self):\n        raise InvalidTransitionError(\"already merged request\")\n    def merge(self):\n        \"\"\"Current state.\"\"\"\nclass MergeRequest:\n    def __init__(self, source_branch: str, target_branch: str) -> None:\n        self.source_branch = source_branch\n        self.target_branch = target_branch\n        self._state = None\n        self.approvals = 0\n        self.state = Open\n    @property\n    def state(self):\n        return self._state\n    @state.setter\n    def state(self, new_state_cls):\n        self._state = new_state_cls(self)\n    def open(self):\n        return self.state.open()\n    def close(self):\n        return self.state.close()\n    def merge(self):\n        return self.state.merge()\n    def __str__(self):\n        return f\"{self.target_branch}:{self.source_branch}\" \n```", "```py\n>>> mr = MergeRequest(\"develop\", \"mainline\") \n>>> mr.open()\n>>> mr.approvals\n0\n>>> mr.approvals = 3\n>>> mr.close()\n>>> mr.approvals\n0\n>>> mr.open()\nINFO:log:reopening closed merge request mainline:develop\n>>> mr.merge()\nINFO:log:merging mainline:develop\nINFO:log:deleting branch develop\n>>> mr.close()\nTraceback (most recent call last):\n...\nInvalidTransitionError: already merged request \n```", "```py\nclass MergeRequest:\n    def __init__(self, source_branch: str, target_branch: str) -> None:\n        self.source_branch = source_branch\n        self.target_branch = target_branch\n        self._state: MergeRequestState\n        self.approvals = 0\n        self.state = Open\n    @property\n    def state(self) -> MergeRequestState:\n        return self._state\n    @state.setter\n    def state(self, new_state_cls: Type[MergeRequestState]):\n        self._state = new_state_cls(self)\n    @property\n    def status(self):\n        return str(self.state)\n    def __getattr__(self, method):\n        return getattr(self.state, method)\n    def __str__(self):\n        return f\"{self.target_branch}:{self.source_branch}\" \n```", "```py\nAttributeError: 'NoneType' object has no attribute 'keys' \n```"]