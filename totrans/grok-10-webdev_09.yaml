- en: Chapter 8. Application Presentation and Page Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we have developed a fairly simple, but a complete application.
    There are some rough edges that need to be polished, obviously. For example, the
    templates that we use, all have a different layout, and although they use more
    or less the same styles and colors, they lack uniformity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to learn how to lay out an application. Some
    important points that we will cover include:'
  prefs: []
  type: TYPE_NORMAL
- en: Viewlet managers and viewlets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layout definition using viewlets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting forms into viewlets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layers and skins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining an alternative skin for the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewlets and viewlet managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a typical web application, there are many parts of its layout that need to
    be repeated on almost every page. Sometimes these pieces need to be present in
    different combinations. For example, a login prompt should not appear if the user
    is already logged in, but a search box should be visible at all times.
  prefs: []
  type: TYPE_NORMAL
- en: Grok solves this problem by allowing the developer to break up web pages into
    small pieces of HTML called **viewlets**, which can then be assembled as required
    inside a given view.
  prefs: []
  type: TYPE_NORMAL
- en: Viewlets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Viewlets provide a mechanism for separating the different components of a page
    into independent pieces, such as header, footer, and navigation. It's possible
    to further decompose these into HTML snippets, which can be shown on the page
    or not, depending on contextual information. This concept allows us to have great
    flexibility in assembling pages.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike a view, which is meant to show a complete page, a viewlet is the representation
    of an HTML snippet that usually has one clear function. When using viewlets, we
    can think of a page as a collection of these snippets.
  prefs: []
  type: TYPE_NORMAL
- en: Viewlet managers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To avoid making a view, keep track of all possible viewlet combinations. Viewlets
    are assigned to specific viewlet managers. A **viewlet manager** can represent
    a section of the page layout, such as the header, for instance. Viewlets register
    with this manager, so that it takes care of their order and rendering. In our
    header viewlet manager, we could have for example title, login, search box, and
    main navigation viewlets.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the viewlets are never called directly from a template. Instead,
    their viewlet manager is called and this, in turn, calls each of its registered
    viewlets in the desired order and renders them on the page. Viewlet managers have
    a few other responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation of all viewlets registered to the manager.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying a set of filters to determine the availability of the viewlets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting the viewlets based on an implemented policy. The default is to show
    them in the order in which they were declared, and Grok can also numerically sort
    them according to the `grok.order([number])` directive for the viewlets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing an environment in which the viewlets are rendered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering itself, containing the HTML content of the viewlets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewlets can also be tied to specific views, contexts, or permissions, so the
    overall system is very flexible, and is easier to manage than a collection of
    macros with conditional tags.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how the pieces fit together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have all of the pieces of how Grok constructs the page layout. When
    a Grok application serves a page, here''s what''s going on behind the scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: The browser makes a request, which contains the desired URL as well as any form
    input, together with the usual `HTTP` headers, to Grok.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Based on the URL parts, Grok traverses (walks) the site, starting at the root
    and continuing on to the next part of the URL until it gets to the last model
    object. This model object is called the **context.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the model object is found, Grok takes the remainder of the URL and uses
    it as the name of a view. If there is no URL remainder, the name "index" is used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once it has the name of the view, Grok finds it and initializes the view, passing
    to it the context and the request used to find the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The view usually has a template assigned to it, which is used to render the
    response to the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The template may include calls to a number of viewlet managers, which in turn
    call their contained viewlets to assemble the HTML that will be returned in the
    response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The template is the final result of calling the Grok application, and it represents
    the rendering of the view. The view, in turn, is associated with a context, which
    is the model object that has been assigned to that view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Grok passes a lot of information to the template, in order to let the developer
    use all of the pieces. This information is in the form of variables that point
    to the following objects that can be used by the developer to build the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '`request:` The `HTTP` request that was sent by the browser, including all of
    the headers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context:` The model object pointed to by the requested URL. In our application,
    this could be a project or a to-do list item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`view:` The view that is configured to be used for the context, according to
    its name. This is the code that is associated with the current template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`viewlet:` Inside a viewlet template, this variable represents the viewlet
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`viewletmanager:` Inside a viewlet template, this variable points to the viewlet
    manager responsible for the current viewlet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View methods and attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These methods and attributes are a part of the `view` variable, and can be used
    by the developer, inside the template.
  prefs: []
  type: TYPE_NORMAL
- en: '| View methods and attributes | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `context` | The object that the view is presenting. This is often an instance
    of a `grok.Model` class, but can be a `grok.Application`, a `grok.Container` object,
    or any type of Python object. |'
  prefs: []
  type: TYPE_TB
- en: '| `request` | The `HTTP Request` object. |'
  prefs: []
  type: TYPE_TB
- en: '| `response` | The `HTTP Response` object that is associated with the request.
    This is also available as `self.request.response`, but the `response` attribute
    is provided as a convenience. |'
  prefs: []
  type: TYPE_TB
- en: '| `static` | Directory resource containing the static files of the view''s
    package. |'
  prefs: []
  type: TYPE_TB
- en: '| `redirect(url)` | Redirects to a given URL. |'
  prefs: []
  type: TYPE_TB
- en: '| `url(obj=None, name=None, data=None)` | Constructs URL.If no arguments are
    given, constructs the URL to the view itself.If only the `obj` argument is given,
    constructs the URL to `obj`.If only `name` is given as the first argument, constructs
    the URL to context/name.If both of the object and name arguments are supplied,
    constructs the URL to `obj/name`.Optionally, you can pass a `data` keyword argument
    that is added to the URL as a `cgi` query string. |'
  prefs: []
  type: TYPE_TB
- en: '| `default_namespace()` | Returns a dictionary of namespaces that the template
    implementation expects to be available always. This method is *not* intended to
    be overridden by application developers. |'
  prefs: []
  type: TYPE_TB
- en: '| `namespace()` | Returns a dictionary that is injected into the template namespace
    in addition to the default namespace. This method is intended to be overridden
    by the application developer. |'
  prefs: []
  type: TYPE_TB
- en: '| View methods and attributes | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `update(**kw)` | This method is meant to be implemented by `grok.View` subclasses.
    It will be called before the view''s associated template is rendered, and can
    be used to precompute values for the template.`update()` can take arbitrary keyword
    parameters that will be filled in from the request (in which case they *must*
    be present in the request). |'
  prefs: []
  type: TYPE_TB
- en: '| `render(**kw)` | A view can either be rendered by an associated template,
    or it can implement this method to render itself from Python. This is useful if
    the view''s output isn''t XML/HTML but something computed in Python (such as plain
    text, PDF, and so on).`render()` can take arbitrary keyword parameters that will
    be filled in from the request (in which case they *must* be present in the request).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `application_url(name=None)` | Returns the URL of the closest application
    object in the hierarchy, or the URL of a named object (name parameter) relative
    to the closest application object. |'
  prefs: []
  type: TYPE_TB
- en: '| `flash(message, type=''message'')` | Sends a short message to the user. |'
  prefs: []
  type: TYPE_TB
- en: Viewlet methods and attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From inside a viewlet template, the following methods and attributes are available
    to the developer:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Viewlet methods and attributes | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `context` | Typically, this is the model object for which this viewlet is
    being rendered in the context of. |'
  prefs: []
  type: TYPE_TB
- en: '| `request` | The `Request` object. |'
  prefs: []
  type: TYPE_TB
- en: '| `view` | A reference to the view that the viewlet is being provided in. |'
  prefs: []
  type: TYPE_TB
- en: '| `viewletmanager` | A reference to the `ViewletManager` that is rendering
    this viewlet. |'
  prefs: []
  type: TYPE_TB
- en: '| `update()` | This method is called before the viewlet is rendered, and can
    be used to perform precomputation. |'
  prefs: []
  type: TYPE_TB
- en: '| `render(*args, **kw)` | This method renders the content provided by this
    viewlet. |'
  prefs: []
  type: TYPE_TB
- en: Viewlet manager methods and attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `viewletmanager` variable is available to developers from inside a viewlet.
    These are the methods and attributes that it contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Viewlet manager methods and attributes | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `context` | This is typically the model object for which this `ViewletManager`
    is being rendered in the context of. |'
  prefs: []
  type: TYPE_TB
- en: '| `request` | The `Request` object. |'
  prefs: []
  type: TYPE_TB
- en: '| `view` | A reference to the view in which the `ViewletManager` is being provided.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `update()` | This method is called before the `ViewletManager` is rendered,
    and can be used to perform precomputation. |'
  prefs: []
  type: TYPE_TB
- en: '| `render(*args, **kw)` | This method renders the content provided by this
    `ViewletManager`. Typically this will mean rendering and concatenating all of
    the viewlets managed by this `ViewletManager`. |'
  prefs: []
  type: TYPE_TB
- en: In addition to these methods, the viewlets contained inside the viewlet manager
    can be accessed using standard Python dictionary syntax.
  prefs: []
  type: TYPE_NORMAL
- en: To-do list manager layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our application then, we will use viewlets to generate the layout. First,
    let''s define our layout structure, which will be more or less what we have now.
    Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![To-do list manager layout](img/7481_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s a very simple layout. Each of the three sections (Header, **Main**, and
    **Footer)** represents a viewlet manager and the list of things inside these sections
    refers to the viewlets that will be needed. To do this in a page template, we
    need to use a special kind of template expression called a **provider**. This
    is how our master template will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As we are thinking about our application's final presentation, the first thing
    to note is that we inserted a correct`<DOCTYPE>` declaration. We also removed
    the`<title>` and`<style>` tags from the header, as they will go inside a viewlet
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define four layout areas: headslot, header, main, and footer. The content
    for each one of those will be provided by a separate viewlet manager. The `provider:name`
    expression tells Grok to find a viewlet manager with this name, render all of
    its registered viewlets, and return them in their configured order. As you may
    recall, the `structure` prefix means to interpret whatever comes from the function
    call as HTML to be rendered.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining viewlet managers in application code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We looked at the template first, to see how it relates to the desired layout,
    but we actually need to define some viewlet managers and viewlets to make this
    work. Fortunately, Grok has `Viewlet` and `ViewletManager` classes that we can
    use for this. First, let''s define our viewlet managers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That's it. We just subclass from `grok.ViewletManager` and Grok will pretty
    much do it all for us. The key part is the `grok.name` class declaration, as the
    name we use here is the one that goes inside the provider expressions in the templates.
    The `grok.context` directive uses `Interface` because it is the most general declaration
    possible, so doing this will enable the managers in all of our application's views
    and models.
  prefs: []
  type: TYPE_NORMAL
- en: Registering viewlets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get the viewlets going, we need to modify our application a bit. Up to now,
    we have been using separate views to define what goes on on each page and who
    can see it. As may be apparent from the master template that we just defined,
    this will now be the responsibility of the viewlets themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert our application to use viewlets, the first step is to take the parts
    that we want to turn into viewlets from the `dashboard.pt` template and put them
    in their own templates. We''ll do the title first, as an example. In the project,
    create a file named `apptitle.pt` and enter the following code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Right now, this contains only the title, but we could eventually include a logo
    and other similar elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To register this viewlet with a viewlet manager, the `Viewlet` class is used
    as a base, and the `grok.viewletmanager` class is invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: That's it. This viewlet will be registered with the `Header` viewlet manager
    defined earlier. Viewlets also require a context, to let the viewlet managers
    know if they are to be displayed in the current context or not. As is the case
    for viewlet managers, we use `Interface` as the context, so that the viewlet is
    enabled everywhere in the application. Also note the `grok.order` directive, which
    is useful for specifying the order that the viewlet manager should use when rendering
    the viewlets. If `grok.order` is not used, the viewlets will be rendered in the
    order that they are defined.
  prefs: []
  type: TYPE_NORMAL
- en: A `Viewlet` class is very similar to a view. It has an `update` method to prepare
    it for rendering, and a `render` method to do the actual rendering. If these methods
    are omitted, Grok simply renders the corresponding template, which in this case
    is `apptitle.pt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s go for the other simple viewlets. The template for the head section,
    `head.pt`, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The template for the search box, `searchbox.pt:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The logged in information and logout link, `loggedin.pt`, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And a simple navigational aid, `navigation.pt`, is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For the footer, we will use a simple **Powered by Grok** message, along with
    Grok's logo, which will be defined in `grokpowered.pt:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll register these viewlets with their managers. We just need to add
    the appropriate class declarations in `app.py`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This way, the `Header` viewlet manager has four viewlets registered in a specific
    order. The `Footer` has just one viewlet at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying existing views to use the master template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already have several working views in our application. To get them to use
    the new layout defined in the master template, we need to do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Make them use the master template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create viewlets that show the main parts of the old template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first part is easy; we just need to use the `grok.template` directive to
    force each view to use the master template, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The viewlet itself is very similar to the other ones that we have defined,
    with the addition of a couple of lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We use the `grok.template` directive to force the viewlet to use the `dashboard_viewlet`
    template. The `grok.view` directive is used next, to make this viewlet show up
    only in the `DashBoard` view. We have to do this to prevent multiple viewlets
    that are registered with the `Main` viewlet manager from showing up all at once
    in every view. In other words, this means that the `DashBoardViewlet` will only
    be rendered inside the `Main` viewlet manager when the user is browsing the default
    view of the application, which happens to be the `DashBoard` view.
  prefs: []
  type: TYPE_NORMAL
- en: To make this work, we need an additional step. Currently, we have the template
    `dashboard.pt` in the `app_templates` directory. We can't keep this name because
    then the `DashBoard` view would have two possible templates to use and Grok will
    refuse to guess which one to use. Therefore, we'll change the name to `dashboard_viewlet.pt`,
    which is what we put in the `grok.template` directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is to change the template itself, and remove all of the structure
    from it. This structure is now included in the `master.pt` template. This is the
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have to perform the same steps to make the `TodoSearch` and `UserList` views
    work. We'll end up with `TodoSearchViewlet` and `UserListViewlet` declarations,
    along with `todosearch_viewlet.pt` and `userlist_viewlet.pt` templates. The `ProjectIndex`
    view requires extra work, because of its use of JavaScript. We'll see how to fix
    that later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, you can take a look at the next screenshot and see how the layout
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Modifying existing views to use the master template](img/7481_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Inserting forms into viewlets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the "add user" and "add project" forms are generated automatically, they
    are still not using our new layout. We have to put these forms inside a viewlet
    so that we can take advantage of the layout. This requires a bit more work because
    the viewlet needs to render the form.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We previously defined the `AddProjectForm` and gave it the name "add". This
    code uses that form directly to render the viewlet. First, we define a view that
    will use the master template. We keep the same context that the real form uses,
    which is `Todo` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a viewlet that we register with the `Main` viewlet manager in
    the same context. We assign this viewlet to the view that was just defined. The
    trick here is to get hold of the form, which we do by using the `getMultiAdapter`
    method imported from `zope.component`. We'll have more to say about adapters in
    Chapter 11, but for now, take it on faith that this call will get us the form
    named "add" in the current context. Once we have the form, we store it in the
    viewlet and use it in the viewlet's `render` method in order to pull the rendering
    from the real form.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s all there is to it, we just need to change the link in `dashboard_viewlet.pt`
    to point to "addproject" instead of just "add", and we''ll get the result that
    we want, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inserting forms into viewlets](img/7481_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using viewlets to insert different static resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have almost converted the whole application to use our new layout. The only
    thing missing is the project view. The problem with this view is that it uses
    some JavaScript code that is not used elsewhere, so we need to include it in the
    header, somehow.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we already have a `headslot` viewlet manager, the easiest way to accomplish
    this is by registering a viewlet with this manager that will only be applied to
    the project view. We have done this before. The trick is to use the `grok.view`
    directive to make the viewlet show only for the selected view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add a new template named `projectjavascript.pt` that will include
    our JavaScript calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now the JavaScript code will work properly in this view and the project viewlet
    can be seen without problems.
  prefs: []
  type: TYPE_NORMAL
- en: Layers and skins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have shown how building a flexible layout is possible by using viewlets.
    Grok allows us to have even more flexibility, by using layers and skins.
  prefs: []
  type: TYPE_NORMAL
- en: The look and feel of our application was created by combining some viewlets
    and using appropriate CSS styles. The final combination can be thought of as the
    'theme' of the application. In Grok, the name we use for this is 'skin'.
  prefs: []
  type: TYPE_NORMAL
- en: A **skin** represents the look and feel of our application. It should be possible
    to rearrange all of the viewlets and edit the styles to create a totally different
    look and feel without changing the way that the application works. Thus, having
    a mechanism to handle skins allows us to easily create themes for our applications
    or create special skins for other uses, such as mobile browser presentation, views
    that respond to specific HTTP verbs (known as REST views, which are actually built
    like this inside Grok), or special power-user skins, depending on who is logged
    in.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the creation and use of skins, they are composed of a number of
    layers, each of which will include only the parts of the look and feel that are
    different for them. This makes it easy to reuse most of the application UI and
    focus only on what's particular to the skin in question.
  prefs: []
  type: TYPE_NORMAL
- en: Skins in Grok
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Grok, all views and viewlets have to be assigned to a layer. Up to now, this
    has been happening in the background because by default there is a layer that
    all of them use. This is called the **default browser layer**. All applications
    in Grok have a default skin, which has no name and is composed of only one layer.
  prefs: []
  type: TYPE_NORMAL
- en: However, the difference between a skin and a layer is subtle. In reality they
    are very similar, but a skin has a name that will be known to the user, whereas
    a layer is anonymous. The intention is to have skins consisting of a number of
    layers, and to use the name to refer to the result.
  prefs: []
  type: TYPE_NORMAL
- en: Adding themes to our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's add different themes to our application by using skins. We'll make it
    very simple for now. We already have a viewlet that includes the`<link>` tag for
    our stylesheet. To design a theme, we'll simply create a layer that overrides
    this viewlet and uses a different stylesheet. In this way, we can create a new
    theme just by adding seven lines of code, a template, and a stylesheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using blue for the masthead of our application. We''ll add a second
    theme, which uses red, and another one that uses green. As the names will be known
    to the users, we''ll use fancy names: the red theme will be called "martian" and
    the green theme will be known as "forest".'
  prefs: []
  type: TYPE_NORMAL
- en: 'A layer in Grok needs to inherit from the `IDefaultBrowserLayer` defined in
    `zope.publisher`. So the first thing we need to do is to import that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now define the skins in `app.py`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: For each skin, we just define a class based on `IDefaultBrowserLayer`, and then
    use the `grok.skin` directive to name it. This name will be used to browse to
    the skin.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding a viewlet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the skins, we can override the `Head` viewlet, where the stylesheet
    link is defined. This viewlet is managed by the `HeadSlot` viewlet manager. To
    override a viewlet, we just have to create another one, with the same name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the `HeadMartian` and `HeadForest` viewlets have exactly the same
    viewlet manager, context, and name as those used by the `Head` viewlet that they
    override. The difference is that they will use another template. To make the `HeadMartian`
    viewlet work only on the `MartianLayer` skin, we add the `grok.layer` directive
    and pass it to the skin. Keep in mind that `grok.layer` can be used in any viewlet
    or view that we define, so we could override anything from the application, or
    create new views or viewlets that appear only when using a specific skin.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, this is all the code that needs to be added to these two themes
    for our application. We just need to add the templates and styles and we are done.
    For the martian theme, we directed the viewlet to use the `head_martian` template,
    so we create a file named `head_martian.pt` and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The only change is the name of the stylesheet in the`<link>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: For the forest theme, we'll create the `head_forest.pt` file and add the same
    text, except that we have to change the name of the CSS file to `styles_forest.css`
    in order to use the correct stylesheet.
  prefs: []
  type: TYPE_NORMAL
- en: All that's left now is to add the new stylesheets. To keep things simple, we'll
    just copy the `styles.css` file to `styles_martian.css` and `styles_forest.css`,
    and then make some color substitutions. Using your favorite text editor, change
    all occurrences of `#223388` to `#883322` in martian and to `#338822` in forest.
    Other than that, the themes will be exactly the same, but we'll easily be able
    to see the difference. Feel free to make more style changes if you like.
  prefs: []
  type: TYPE_NORMAL
- en: Using the new skins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To actually see the new skins, we need to tell Grok that a different skin than
    the default has to be used. The simplest way to do this is to use the special
    `++skin++` name in the URL, along with the skin name. Grok will see this, and
    use the correct skin.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we''ll see the martian skin if we point the browser to the following
    URL: [http://localhost:8080/++skin++martian/todo](http://localhost:8080/++skin++martian/todo).
    Notice how the `++skin++` name goes immediately after the hostname. Grok will
    signal an error if we put it anywhere else in the URL. To see the forest skin,
    just change the word `martian` to `forest` in the preceding URL. See the next
    screenshot to take a look at the martian skin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the new skins](img/7481_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are done. If we browse through the application, we'll see that all of the
    pages now show the header with the corresponding background color.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, asking the user to type the name of the skin in the URL will not
    do for production use. In Chapter 11, we'll see how to let the user choose a skin
    via a preferences menu, and get Grok to apply the correct skin itself.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about Grok's layout and presentation facilities,
    including viewlets, layers, and skins. We modified our application to have a consistent
    look and feel, by using these tools. We will now go on to learn about the ZODB
    and how Grok uses it.
  prefs: []
  type: TYPE_NORMAL
