- en: 12\. Building a REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces **REST APIs** and **Django REST Framework** (**DRF**).
    You will start by implementing a simple API for the Bookr project. Next, you will
    learn about the serialization of model instances, which is a key step in delivering
    data to the frontend side of Django applications. You will explore different types
    of API views, including both functional and class-based types. By the end of this
    chapter, you will be able to implement custom API endpoints, including simple
    authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about templates and class-based views. These
    concepts greatly help expand the range of functionalities we can provide to the
    user on the frontend (that is, in their web browser). However, that is not sufficient
    to build a modern web application. Web apps typically have the frontend built
    with an entirely separate library, such as **ReactJS** or **AngularJS**. These
    libraries provide powerful tools for building dynamic user interfaces; however,
    they do not communicate directly with our backend Django code or database. The
    frontend code simply runs in the web browser and does not have direct access to
    any data on our backend server. Therefore, we need to create a way for these applications
    to "talk" to our backend code. One of the best ways to do this in Django is by
    using REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: '**API** stands for **Application Programming Interface**. APIs are used to
    facilitate interaction between different pieces of software, and they communicate
    using **HTTP** (**Hypertext Transfer Protocol**). This is the standard protocol
    for communication between servers and clients and is fundamental to information
    transfer on the web. APIs receive requests and send responses in HTTP format.'
  prefs: []
  type: TYPE_NORMAL
- en: In our use case in this chapter, an API will help facilitate interaction between
    our Django backend, and our frontend JS code. For example, imagine that we want
    to create a frontend application that allows users to add new books to the Bookr
    database. The user's web browser would send a message (an HTTP request) to our
    API to say that they want to create an entry for a new book, and perhaps include
    some details about the book in that message. Our server would send back a response
    to report on whether the book was successfully added or not. The web browser would
    then be able to display to the user the outcome of their action.
  prefs: []
  type: TYPE_NORMAL
- en: REST APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**REST** stands for **Representational State Transfer**. Most modern web APIs
    can be classified as REST APIs. REST APIs are simply a type of API that focuses
    on communicating and synchronizing the *state* of objects between the database
    server and frontend client.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine that you are updating your details on a website for which
    you are signed into your account. When you go to the account details page, the
    web server tells your browser about the various details attached to your account.
    When you change the values on that page, the browser sends back the updated details
    to the web server and tells it to update these details on the database. If the
    action is successful, the website will show you a confirmation message.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very simple example of what is known as **decoupled** architecture
    between frontend and backend systems. Decoupling allows greater flexibility and
    makes it easier to update or change components in your architecture. So, let's
    say you want to create a new frontend website. In such a case, you don't have
    to change the backend code at all, as long as your new frontend is built to make
    the same API requests as the old one.
  prefs: []
  type: TYPE_NORMAL
- en: REST APIs are *stateless*, which means that neither the client nor the server
    stores any states in-between to do the communication. Every time a request is
    made, the data is processed, and a response is sent back without having to store
    any intermediate data by the protocol itself. What this means is that the API
    is processing each request in isolation. It doesn't need to store information
    regarding the session itself. This is in contrast to a stateful protocol (such
    as **TCP**), which maintains information regarding the session during its life.
  prefs: []
  type: TYPE_NORMAL
- en: So, a **RESTful web service**, as the name suggests, is a collection of REST
    APIs used to carry out a set of tasks. For example, if we develop a set of REST
    APIs for the Bookr application to carry out a certain set of tasks, then we can
    call it a RESTful web service.
  prefs: []
  type: TYPE_NORMAL
- en: Django REST Framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Django REST Framework**, also called **DRF** for short, is an open-source
    Python library that can be used to develop REST APIs for a Django project. DRF
    has most of the necessary functionality built in to help develop APIs for any
    Django project. Throughout this chapter, we will be using it to develop APIs for
    our Bookr project.'
  prefs: []
  type: TYPE_NORMAL
- en: Installation and Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install `djangorestframework` in the `virtual env` setup along with PyCharm.
    Enter the following code in your Terminal app or Command Prompt to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open the `settings.py` file and add `rest_framework` to `INSTALLED_APPS`
    as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You are now ready to start using DRF to create your first simple API.
  prefs: []
  type: TYPE_NORMAL
- en: Functional API Views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Chapter 3*, *URL Mapping, Views, and Templates*, we learned about simple
    functional views that take a request and return a response. We can write similar
    functional views using DRF. However, note that class-based views are more commonly
    used, and will be covered next. A functional view is created by simply adding
    the following decorator onto a normal view, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This decorator takes the functional view and turns it into a subclass of the
    DRF `APIView`. It's a quick way to include an existing view as part of your API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.01: Creating a Simple REST API'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create your first REST API using DRF and implement
    an endpoint using a functional view. You will create this endpoint to view the
    total number of books in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You'll need to have DRF installed on your system to proceed with this exercise.
    If you haven't already installed it, make sure you refer to the section titled
    *Installation and Configuration* earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Create `api_views.py` in the `bookr/reviews` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: REST API views work like Django's conventional views. We could have added the
    API views, along with the other views, in the `views.py` folder. However, having
    our REST API views in a separate file will help us maintain a cleaner code base.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following code in `api_views.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: from . import views, api_views
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: urlpatterns = [path('api/first_api_view/)',\
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: path(api_views.first_api_view)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We could also use the Linux `curl` (client URL) command to send an HTTP request
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, if you are using Windows 10, you can make an equivalent HTTP
    request with `curl.exe` from Command Prompt as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we learned how to create an API view using DRF and a simple
    functional view. We will now look at a more elegant way to convert between information
    stored in the database and what gets returned by our API using serializers.
  prefs: []
  type: TYPE_NORMAL
- en: Serializers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, we are well versed in the way Django works with data in our application.
    Broadly, the columns of a database table are defined in a class in `models.py`,
    and when we access a row of the table, we are working with an instance of that
    class. Ideally, we often just want to pass this object to our frontend application.
    For example, if we wanted to build a website that displayed a list of books in
    our Bookr app, we would want to call the `title` property of each book instance
    to know what string to display to the user. However, our frontend application
    knows nothing about Python and needs to retrieve this data through an HTTP request,
    which just returns a string in a specific format.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that any information translated between Django and the frontend
    (via our API) must be done by representing the information in **JavaScript Object
    Notation** (**JSON**) format. JSON objects look similar to a Python dictionary,
    except there are some extra rules that constrict the exact syntax. In our previous
    example in *Exercise 12.01*, *Creating a Simple REST API*, the API returned the
    following JSON object containing the number of books in our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: But what if we wanted to return the full details about an actual book in our
    database with our API? DRF's `serializer` class helps to convert complex Python
    objects into formats such as JSON or XML so that they can be transmitted across
    the web using the HTTP protocol. The part of DRF that does this conversion is
    named `serializer`. Serializers also perform deserialization, which refers to
    converting serialized data back into Python objects, so that the data can be processed
    in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.02: Creating an API View to Display a List of Books'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will use serializers to create an API that returns a
    list of all books present in the `bookr` application:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `serializers.py` in the `bookr/reviews` folder. This is
    the file where we will place all the serializer code for the APIs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to `serializers.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the first line imports the serializers from the `rest_framework` module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Following the imports, we have defined two classes, `PublisherSerializer` and
    `BookSerializer`. As the names suggest, they are serializers for the `Publisher`
    and `Book` models respectively. Both these serializers are subclasses of `serializers.Serializer`
    and we have defined field types for each serializer such as `CharField`, `URLField`,
    and `EmailField`, and so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Look at the `Publisher` model in the `bookr/reviews/models.py` file. The `Publisher`
    model has `name`, `website`, and `email` attributes. So, to serialize a `Publisher`
    object, we need `name`, `website`, and `email` attributes in the `serializer`
    class, which we have defined accordingly in `PublisherSerializer`. Similarly,
    for the `Book` model, we have defined `title`, `publication_date`, `isbn`, and
    `publisher` as the desired attributes in `BookSerializer`. Since `publisher` is
    a foreign key for the `Book` model, we have used `PublisherSerializer` as the
    serializer for the `publisher` attribute.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open `bookr/reviews/api_views.py`, remove any pre-existing code, and add the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the second line, we have imported the newly created `BookSerializer` from
    the `serializers` module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We then add a functional view, `all_books` (as in the previous exercise). This
    view takes a query set containing all books and then serializes them using `BookSerializer`.
    The `serializer` class is also taking an argument, `many=True`, which indicates
    that the `books` object is a `queryset` or a list of many objects. Remember that
    serialization takes Python objects and returns them in a JSON serializable format,
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `bookr/reviews/urls.py`, remove the previous example path for `first_api_view`,
    and add the `all_books` path as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This newly added path calls the view function `all_books` when it comes across
    the `api/all_books/` path in the URL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once all the code is added, run the Django server with the `python manage.py
    runserver` command and navigate to `http://0.0.0.0:8000/api/all_books/`. You should
    see something similar to *Figure 12.2*:![Figure 12.2: List of books shown in the
    all_books endpoint'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_12_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.2: List of books shown in the all_books endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows that the list of all books is returned upon calling
    the `/api/all_books` endpoint. And with that, you have successfully used a serializer
    to return data efficiently in your database, with the help of a REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Till now, we have been focusing on functional views. However, you will now learn
    that class-based views are more commonly used in DRF and will make your life much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Class-Based API Views and Generic Views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to what we learned in *Chapter 11*, *Advanced Templating and Class-Based
    Views*, we can write class-based views for REST APIs as well. Class-based views
    are the most preferred way for writing views among developers as a lot can be
    achieved by writing very little code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with conventional views, DRF offers a set of generic views that makes
    writing class-based views even simpler. Generic views are designed keeping in
    mind some of the most common operations needed while creating APIs. Some of the
    generic views offered by DRF are `ListAPIView`, `RetrieveAPIView`, and so on.
    In *Exercise 12.02*, *Creating an API View to Display a List of Books*, our functional
    view was responsible for creating a `queryset` of the objects and then calling
    the serializer. Equivalently, we could use `ListAPIView` to do the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `queryset` of objects is defined as a class attribute. Passing the
    `queryset` through to the `serializer` is handled by methods on `ListAPIView`.
  prefs: []
  type: TYPE_NORMAL
- en: Model Serializers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Exercise 12.02*, *Creating an API View to Display a List of Books*, our
    serializer was defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'However, our model for `Book` looks like this (note how similar the definitions
    of the model and serializer appear to be):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We would prefer not to specify that the title must be `serializers.CharField()`.
    It would be easier if the serializer just looked at how `title` was defined in
    the model and could figure out what serializer field to use.
  prefs: []
  type: TYPE_NORMAL
- en: This is where model serializers come in. They provide shortcuts to create serializers
    by utilizing the definition of the fields on the model. Instead of specifying
    that `title` should be serialized using a `CharField`, we just tell the model
    serializer we want to include the `title`, and it uses the `CharField` serializer
    because the `title` field on the model is also a `CharField`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we wanted to create a serializer for the `Contributor`
    model in `models.py`. Instead of specifying the types of serializers that should
    be used for each field, we can give it a list of the field names, and let it figure
    out the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the following exercise, we will see how we can use a model serializer to
    avoid the duplication of code in the preceding classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.03: Creating Class-Based API Views and Model Serializers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create class-based views to display a list of all
    books while using model serializers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file `bookr/reviews/serializers.py`, remove any pre-existing code,
    and replace it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have included two model serializer classes, `PublisherSerializer` and
    `BookSerializer`. Both these classes inherit the parent class `serializers.ModelSerializer`.
    We do not need to specify how each field gets serialized, instead, we can simply
    pass a list of field names, and the field types are inferred from the definition
    in `models.py`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Although mentioning the field inside `fields` is sufficient for the model serializer,
    under certain special cases, such as this one, we may have to customize the field
    since the `publisher` field is a foreign key. Hence, we must use `PublisherSerializer`
    to serialize the `publisher` field.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, open `bookr/reviews/api_views.py`, remove any pre-existing code, and
    add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we use the DRF class-based `ListAPIView` instead of a functional view.
    This means that the list of books is defined as a class attribute, and we do not
    have to write a function that directly handles the request and calls the serializer.
    The book serializer from the previous step is also imported and assigned as an
    attribute of this class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `bookr/reviews/urls.py` file and modify the `/api/all_books` API path
    to include the new class-based view as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since we are using a class-based view, we have to use the class name along with
    the `as_view()` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once all the preceding modifications are completed, wait till the Django service
    restarts or start the server with the `python manage.py runserver` command, and
    then open the API at `http://0.0.0.0:8000/api/all_books/` in the web browser.
    You should see something like *Figure 12.3*:![Figure 12.3: List of books shown
    in the all_books endpoint'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_12_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.3: List of books shown in the all_books endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: Like what we saw in *Exercise 12.02*, *Creating an API View to Display a List
    of Books*, this is a list of all books present in the book review application.
    In this exercise, we used model serializers to simplify our code, and the generic
    class-based `ListAPIView` to return a list of the books in our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 12.01: Creating an API Endpoint for a Top Contributors Page'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that your team decides to create a web page that displays the top contributors
    (that is, authors, coauthors, and editors) in your database. They decide to enlist
    the services of an external developer to create an app in React JavaScript. To
    integrate with the Django backend, the developer will need an endpoint that provides
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A list of all contributors in the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each contributor, a list of all books they contributed to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each contributor, the number of books they contributed to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each book they contributed to, their role in the book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final API view should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4: Top contributors endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_12_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.4: Top contributors endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform this task, execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a method to the `Contributor` class that returns the number of contributions
    made.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `ContributionSerializer`, which serializes the `BookContribution` model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `ContributorSerializer`, which serializes the `Contributor` model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `ContributorView`, which uses `ContributorSerializer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a pattern to `urls.py` to enable access to `ContributorView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ViewSets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how we can optimize our code and make it more concise using class-based
    generic views. `AllBooks` view to return a list of all books in the application
    and the `BookDetail` view to return the details of a single book. Using viewsets,
    we could combine both these classes into a single class.
  prefs: []
  type: TYPE_NORMAL
- en: 'DRF also provides a class named `ModelViewSet`. This class not only combines
    the two views mentioned in the preceding discussion (that is, list and detail)
    but also allows you to create, update, and delete model instances. The code needed
    to implement all this functionality could be as simple as specifying the serializer
    and `queryset`. For example, a view that allows you to manage all these actions
    for your user model could be defined as tersely as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, DRF provides a `ReadOnlyModelViewSet` class. This is a simpler version
    of the preceding `ModelViewSet`. It is identical, except that it only allows you
    to list and retrieve specific users. You cannot create, update, or delete records.
  prefs: []
  type: TYPE_NORMAL
- en: Routers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Routers, when used along with a viewset, take care of automatically creating
    the required URL endpoints for the viewset. This is because a single viewset is
    accessed at different URLs. For example, in the preceding `UserViewSet`, you would
    access a list of users at the URL `/api/users/`, and a specific user record at
    the URL `/api/users/123`, where `123` is the primary key of that user record.
    Here is a simple example of how you might use a router in the context of the previously
    defined `UserViewSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's try to combine the concepts of routers and viewsets in a simple exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.04: Using ViewSets and Routers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will combine the existing views to create a viewset and
    create the required routing for the viewset:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file `bookr/reviews/serializers.py`, remove the pre-existing code,
    and add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we added two new fields to `BookSerializer`, namely `reviews` and `rating`.
    The interesting thing about these fields is that the logic behind them is defined
    as a method on the serializer itself. This is why we use the `serializers.SerializerMethodField`
    type to set the `serializer` class attributes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the file `bookr/reviews/api_views.py`, remove the pre-existing code, and
    add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have removed the `AllBook` and the `BookDetail` views and replaced
    them with `BookViewSet` and `ReviewViewSet`. In the first line, we import the
    `ViewSets` module from `rest_framework`. The `BookViewSet` class is a subclass
    of `ReadOnlyModelViewSet`, which ensures that the views are used for the `GET`
    operation only.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, open the `bookr/reviews/urls.py` file, remove the first two URL patterns
    starting with `api/`, and then add the following (highlighted) code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save all the files, and once the Django service restarts (or you start it manually
    with the `python manage.py runserver` command), go to the URL `http://0.0.0.0:8000/api/books/`
    to get a list of all the books. You should see the following view in the API explorer:![Figure
    12.5: Book list at the path /api/books'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_12_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.5: Book list at the path /api/books'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can also access the details for a specific book using the URL `http://0.0.0.0:8000/api/books/1/`.
    In this case, it will return details for the book with a primary key of `1` (if
    it exists in your database):![Figure 12.6: Book details for "Advanced Deep Learning
    with Keras"'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_12_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.6: Book details for "Advanced Deep Learning with Keras"'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we saw how we can use viewsets and routers to combine the
    list and detail views into a single viewset. Using viewsets will make our code
    more consistent and idiomatic, making it easier to collaborate with other developers.
    This becomes particularly important when integrating with a separate frontend
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned in *Chapter 9*, *Sessions and Authentication*, it is important
    to authenticate the users of our application. It is good practice to only allow
    those users who have registered in the application to log in and access information
    from the application. Similarly, for REST APIs too, we need to design a way to
    authenticate and authorize users before any information is passed on. For example,
    suppose Facebook's website makes an API request to get a list of all comments
    for a post. If they did not have authentication on this endpoint, you could use
    it to programmatically get comments for any post you want. They obviously don't
    want to allow this, so some sort of authentication needs to be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: There are different authentication schemes, such as **Basic Authentication**,
    **Session Authentication**, **Token Authentication**, **Remote User Authentication**,
    and various third-party authentication solutions. For the scope of this chapter,
    and for our Bookr application, we will use **Token Authentication**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For further reading on all the authentication schemes, please refer to the official
    documentation at [https://www.django-rest-framework.org/api-guide/authentication](https://www.django-rest-framework.org/api-guide/authentication).
  prefs: []
  type: TYPE_NORMAL
- en: Token-Based Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Token-based authentication works by generating a unique token for a user in
    exchange for the user's username and password. Once the token is generated, it
    will be stored in the database for further reference and will be returned to the
    user upon every login.
  prefs: []
  type: TYPE_NORMAL
- en: This token is unique for a user and the user can then use this token to authorize
    every API request they make. Token-based authentication eliminates the need to
    pass the username and password on every request. It is much safer and is best
    suited to client-server communication, such as a JavaScript-based web client interacting
    with the backend application via REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: An example of this would be a ReactJS or AngularJS application interacting with
    a Django backend via REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The same architecture can be used if you are developing a mobile application
    to interact with the backend server via REST APIs, for instance, an Android or
    iOS application interacting with a Django backend via REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.05: Implementing Token-Based Authentication for Bookr APIs'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will implement token-based authentication for the `bookr`
    application''s APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `bookr/settings.py` file and add `rest_framework.authtoken` to `INSTALLED_APPS`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since the `authtoken` app has associated database changes, run the `migrate`
    command in the command line/terminal as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `bookr/reviews/api_views.py` file, remove any pre-existing code, and
    replace it with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have defined a view called `Login`. The purpose of this view is to
    allow a user to get (or create if it does not already exist) a token that they
    can use to authenticate with the API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We override the `post` method of this view because we want to customize the
    behavior when a user sends us data (that is, their login details). First, we use
    the `authenticate` method from Django's `auth` library to check whether the username
    and password are correct. If they are correct, then we will have a `user` object.
    If not, we return an `HTTP 404` error. If we do have a valid `user` object, then
    we simply get or create a token, and return it to the user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let''s add the authentication class to our `BookViewSet`. This means
    that when a user tries to access this viewset, it will require them to authenticate
    using token-based authentication. Note that it''s possible to include a list of
    different accepted authentication methods, not just one. We also add the `permissions_classes`
    attribute, which just uses DRF''s built-in class that checks to see if the given
    user has permission to view the data in this model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The preceding code (highlighted) won't match the code you see on GitHub as we'll
    be modifying it later in *step 9*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open `bookr/reviews/urls.py` file and add the following path into url patterns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file and wait for the application to restart, or start the server
    manually with the `python manage.py runserver` command. Then access the application
    using the URL `http://0.0.0.0:8000/api/login`. Your screen should appear as follows:![Figure
    12.7: Login page'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_12_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.7: Login page'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The API at `/api/login` is a `POST` only message, hence `Method GET not allowed`
    is displayed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, enter the following snippet in the content and click on `POST`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will need to replace this with an actual username and password for your
    account in the database. Now you can see the token generated for the user. This is
    the token we need to use to access `BookSerializer`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.8: Token generated for the user'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_12_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.8: Token generated for the user'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Try to access the list of books using the API that we previously created at
    `http://0.0.0.0:8000/api/books/`. Note that you are now not allowed to access
    it. This is because this viewset now requires you to use your token to authenticate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The same API can be accessed using `curl` on the command line:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since the token was not provided, the message `Authentication credentials were
    not provided` is displayed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.9: Message saying that the authentication details weren''t provided'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_12_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This operation ensured that only an existing user of the application can access
    and fetch the collection of all books.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Before moving on, set the authentication and permission classes on `BookViewSet`
    to an empty string. Future chapters will not utilize these authentication methods,
    and we will assume for sake of simplicity that our API can be accessed by an unauthenticated
    user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we implemented token-based authentication in our Bookr app.
    We created a login view that allows us to retrieve the token for a given authenticated
    user. This then enabled us to make API requests from the command line by passing
    through the token as a header in the request.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced REST APIs, a fundamental building block in most real-world
    web applications. These APIs facilitate communication between the backend server
    and the web browser, so they are central to your growth as a Django web developer.
    We learned how to serialize data in our database so that it can be transmitted
    via an HTTP request. We also learned the various options DRF gives us to simplify
    the code we write, taking advantage of the existing definitions of the models
    themselves. We also covered viewsets and routers, and saw how they can be used
    to condense code even further by combining the functionality of multiple views.
    We also learned about authentication and authorization and implemented token-based
    authentication for the book review app. In the next chapter, we will extend Bookr's
    functionality for its users by learning how to generate CSVs, PDFs, and other
    binary filetypes.
  prefs: []
  type: TYPE_NORMAL
