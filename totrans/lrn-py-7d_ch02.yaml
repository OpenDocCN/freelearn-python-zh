- en: Type Variables and Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, you learned a little bit about the history of Python. You learned
    the steps to install Python and some basic syntax of the language. In the basic
    syntax, you learned about types of comments that can be used in the code, various
    types of quotes, escape sequence that can be handy, and finally, you learned about
    the formatting of strings. In this chapter, you will learn about assignment statements,
    arithmetic operators, comparison operators, assignment operators, bitwise operators,
    logical operators, membership operators, and identity operators.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, what is a variable? Consider that your house needs a name. You place a
    nameplate at the front gate of your house. People will now recognize your house
    through that nameplate. That nameplate can be considered as variable. Like a nameplate
    points to the house, a variable points to the value that is stored in memory.
    When you create a variable, the interpreter will reserve some space in the memory
    to store values. Depending on the data type of the variable, the interpreter allocates
    memory and makes a decision to store a particular data type in the reserved memory.
    Various data types, such as integers, decimals, or characters, can be stored by
    assigning different data types to the variables. Python variables are usually
    dynamically typed, that is, the type of the variable is interpreted during runtime
    and you need not specifically provide a type to the variable name, unlike what
    other programming languages require. There are certain rules or naming conventions
    for naming variables. The following are the rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Reserved key words such as `if`, `else`, and so on cannot be used for naming
    variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable names can begin with `_`, `$`, or a letter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable names can be in lower case and uppercase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable names cannot start with a number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: White space characters are not allowed in the naming of a variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can assign values to the variable using `=` or assignment operator.
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Single assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we will illustrate the use of the assignment operator (`=`) with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we assigned three different values to three variables using the `=`
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A single value can be assigned to several variables simultaneously. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Data types in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is a data type in any programming language? Let''s try to understand with
    a real life problem. We use water, oil, liquid soap, syrups, and so on in our
    day to day life. How do you categorize these items? Let''s take another set of
    examples of bar soap, cell phone, and so on; what classification would you like
    to give these items? Answer to all these questions is simple: solid, liquid, and
    gases. Yes, we have these three broader classifications for any item that we have
    heard about or used in our day to day life. Same is the case in the programming
    world. Each and every thing needs to be categorized under different types. There
    are many types of data, such as numbers, strings, character, images, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Data types can be broadly categorized into five different types, listed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numeric data types or numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are generally four numeric data types in Python. They are integers, long
    integers, floating point numbers, and complex numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Integers and long integers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Integers include zero, all of the positive whole numbers, and all of the negative
    whole numbers. The interpreter first checks the expression on the right hand side
    of the assignment operator and then binds the value with its variable name; this
    process is termed as variable definition or initialization. The `int` or integer
    data type ranges from -2^(31) to (2^(31)-1); the leading minus sign shows the
    negative values. Beyond these ranges, the interpreter will add `L` to indicate
    a long integer, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_001-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Floating point numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Numbers with certain places after the decimal point are referred to as floating
    point numbers in the programming language:'
  prefs: []
  type: TYPE_NORMAL
- en: The floating point number type ranges approximately from -10 to 10^(^308) and
    has 16 digits of precision.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two ways to write a floating point number. It can be written using
    ordinary decimal notation or scientific notation. Scientific notation is often
    useful for mentioning very large numbers, as shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/image_02_002-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Complex numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A complex number has both real and imaginary parts, and Python allows you to
    specify this data type in a very easy and convenient way.
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: OR
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, `x` is the real part and `y` is the imaginary part. Here, `j` plays the
    role of iota.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will be clearer with the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_003-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we declare two variables to denote complex numbers. One way to achieve
    is to use `complex()` method and the other way is to use the standard notation
    as used in mathematics.
  prefs: []
  type: TYPE_NORMAL
- en: In standard complex number notation, *x+ij*, *i* is used to denote the starting
    of the imaginary part and stands for iota. *j* denotes the imaginary part. The
    credit for conceiving the idea of complex numbers goes to Italian mathematician
    Gerolamo Cardano in 1545.
  prefs: []
  type: TYPE_NORMAL
- en: 'Source: [https://en.wikipedia.org/wiki/Complex_number](https://en.wikipedia.org/wiki/Complex_number)'
  prefs: []
  type: TYPE_NORMAL
- en: Boolean data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Boolean data type generally has only two values `'True'` or `'False'`. Boolean
    data type is a sub type of integers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Boolean data types can be referred to as an on and off switch, which has only
    two values to chose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_004-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we try to compare the value of `x` with the value
    of `y`, and when we use the `==` operator, the value of the Boolean is returned
    as `True`.
  prefs: []
  type: TYPE_NORMAL
- en: String data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Python string is a contiguous sequence of Unicode characters. Single quotes
    or double quotes can be used to denote a string, as we saw in [Chapter 1](lrn-py-7d_ch01.html),
    *Getting Started with Python*. For multiline string representation, `'''` or `"""`
    can be used.
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You will understand better with the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_005-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: More details on strings, tuples, list, and dictionary will be covered in the
    coming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: American Standard Code for Information Interchange (ASCII) character sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The succeeding table shows the mapping of the first 128 ASCII codes to character
    values. The left column digits are the leftmost digits of the ASCII code. The
    top row's digits represent the rightmost digits. For example, the ASCII code of
    character *A* would be *65*.
  prefs: []
  type: TYPE_NORMAL
- en: '|  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | NUL | SOH | STX | ETX | EOT | ENQ | ACK | BEL | BS | HT |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | LF | VT | FF | CR | SO | SI | DLE | DCI | DC2 | DC3 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | DC4 | NAK | SYN | ETB | CAN | EM | SUB | ESC | FS | GS |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | RS | US | SP | ! | " | # | $ | % | & | ` |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | ( | ) | * | + | , | - | . | / | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | : | ; |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | < | = | > | ? | @ | A | B | C | D | E |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | F | G | H | I | J | K | L | M | N | O |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | P | Q | R | S | T | U | V | W | X | Y |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | Z | [ |  | ] | ^ | _ | '' | a | b | c |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | d | e | f | g | h | i | j | k | l | m |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | n | o | p | q | r | s | t | u | v | w |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | x | y | z | { | &#124; | } | ~ | DEL |  |  |'
  prefs: []
  type: TYPE_TB
- en: ASCII was developed primarily for telegraph code. Bell labs brought out 7-bit
    teleprinter code for commercial promotion and official work on the ASCII code
    began on October 6, 1960.
  prefs: []
  type: TYPE_NORMAL
- en: 'Source: [https://en.wikipedia.org/wiki/ASCII](https://en.wikipedia.org/wiki/ASCII)'
  prefs: []
  type: TYPE_NORMAL
- en: Conversion functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to convert a character value to ASCII code, the `ord()` function is
    used, and for converting ASCII code to character, the `chr()` function is used,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_006-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, when we want to get the ASCII code for `'A'`, it shows `65`, which you
    can easily get from the aforementioned table. The letter `'A'` can be located
    on the sixth row and fifth column; thus, its value is `65`. Likewise, we can get
    the letter corresponding to a particular ASCII code.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arithmetic expressions in any language comprise operands and operators. For
    reference, *x* and *y* are used as operands having values *10* and *20*, respectively. The
    following table shows the precedence order:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `**` | **Exponent**: Performs exponential (power) calculations on operators
    |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | **Multiplication**: Multiplies values on either side of the operator
    |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | **Division**: Divides the left-hand operand by the right-hand operand
    |'
  prefs: []
  type: TYPE_TB
- en: '| `%` | **Modulus**: Divides the left-hand operand by the right-hand operand
    and returns the remainder |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | **Addition**: Adds values on either side of the operator |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | **Subtraction**: Subtracts the right-hand operand from the left-hand
    operand |'
  prefs: []
  type: TYPE_TB
- en: In an arithmetic expression, generally, the rule of **Bracket, Of, Division,
    Multiplication, Addition, and Subtraction** (**BODMAS**) is followed, and operators
    have their own precedence order. Exponentiation enjoys a higher precedence order,
    while addition and subtraction have a lower precedence order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The decreasing precedence order is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Exponent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unary negation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplication, division, modulus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Addition, subtraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If operands are of the same data type, then the resulting value is also of that
    type. However, addition of two `int` data types can produce a `long` integer.
  prefs: []
  type: TYPE_NORMAL
- en: Mixed mode arithmetic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The arithmetic operation involving both integer and floating point numbers is
    called **mixed mode arithmetic**. When each operand is of a different data type,
    the resulting value is of the more general type, and `float` is the more general
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot will make it clearer for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_007-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mixed Mode Conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding example, `11/2.0`, the less general type integer, `11`, is
    temporarily and automatically converted into float `11.0`. Then, the calculation
    is performed. It is called **mixed mode conversion**.
  prefs: []
  type: TYPE_NORMAL
- en: Type conversions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is easy to convert the data type of operands using a type conversion function.
    Let''s understand with some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_008-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, `4.77` is converted into `4`. In order to convert
    `4.77` into the `int` data type, the `int()` function is used. Likewise, if you
    want to convert into `float`, use the `float()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python supports the following types of operators:'
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparison operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assignment operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitwise operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Membership operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identity operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arithmetic operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arithmetic expressions comprise operands and operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `**` | **Exponent**: Performs exponential (power) calculations on operands
    |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | **Multiplication**: Performs multiplication between operands |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | **Division**: Performs division between operands |'
  prefs: []
  type: TYPE_TB
- en: '| `%` | **Modulus**: Performs modulus division between operands |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | **Addition**: Performs addition between operands |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | **Subtraction**: Performs subtraction between operands |'
  prefs: []
  type: TYPE_TB
- en: We have already discussed the precedence order of the operators.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like any other language, Python also supports comparison operators. Comparison
    operators return `True` or `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `==` | Checks the equality |'
  prefs: []
  type: TYPE_TB
- en: '| `<` | Returns `True` if the left-hand side operand is less than the right-hand
    side operand |'
  prefs: []
  type: TYPE_TB
- en: '| `>` | Returns `True` if the left-hand side operand is greater than the right-hand
    side operand |'
  prefs: []
  type: TYPE_TB
- en: '| `<=` | Returns `True` if the left-hand side operand is less than or equal
    to the right-hand side operand |'
  prefs: []
  type: TYPE_TB
- en: '| `>=` | Returns `True` if the left-hand side operand is greater than or equal
    to the right-hand side operand |'
  prefs: []
  type: TYPE_TB
- en: '| `!=` | Returns `True` if the left-hand side operand is not equal to the right-hand
    side operand |'
  prefs: []
  type: TYPE_TB
- en: '| `<>` | Returns `True` if the left-hand side operand is not equal to the right-hand
    side operand |'
  prefs: []
  type: TYPE_TB
- en: 'Some examples of comparison operators and their outcome are shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_009-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s evaluate the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `and` operator is used, `b` is evaluated only once, and `c` will
    not be evaluated if `a < b` is found `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_010-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, `12<5` is evaluated first; if it is `False`, then
    the next expression will not be evaluated. If the operands are of different types,
    then they are converted to a common type. Otherwise, the `==` and `!=` operators
    always consider objects of different types to be unequal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at two different scenarios where we try to evaluate a `float` data
    type with an `int` data type, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_011-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, the operator evaluates to `True` in both the cases, as the interpreter
    converts one data type to another and then compares both the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comparison between different data types:'
  prefs: []
  type: TYPE_NORMAL
- en: Numbers are compared arithmetically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings are compared as per the alphabetical order, using the numeric equivalents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuples and lists are compared according to the alphabetical order using the
    comparison of corresponding elements, which we will see in the coming chapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variants of assignment operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier in the chapter, you learned about the assignment operator, `=`. Now,
    we will see some more variants of the assignment operator, often used in combination
    with arithmetic operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `=` | `x=y` , `y` is assigned to `x` |'
  prefs: []
  type: TYPE_TB
- en: '| `+=` | `x+=y` is equivalent to `x=x+y` |'
  prefs: []
  type: TYPE_TB
- en: '| `-=` | `x-=y` is equivalent to `x=x-y` |'
  prefs: []
  type: TYPE_TB
- en: '| `*=` | `x*=y` is equivalent to `x=x*y` |'
  prefs: []
  type: TYPE_TB
- en: '| `/=` | `x/=y` is equivalent to `x=x/y` |'
  prefs: []
  type: TYPE_TB
- en: '| `**=` | `x**=y` is equivalent to `x=x**y` |'
  prefs: []
  type: TYPE_TB
- en: 'Here, we will look at a few examples of the variants of the assignment operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_012-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Bitwise operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python supports bitwise operations. You might have come across *AND*, *OR*,
    or complementary operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | Performs binary *OR* operation |'
  prefs: []
  type: TYPE_TB
- en: '| `&` | Performs binary *AND* operation |'
  prefs: []
  type: TYPE_TB
- en: '| `~` | Performs binary *XOR* operation |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Performs binary one''s complement operation |'
  prefs: []
  type: TYPE_TB
- en: '| `<<` | **Left shift operator**: The left-hand side operand bit is moved left
    by the number specified on the right-hand side |'
  prefs: []
  type: TYPE_TB
- en: '| `>>` | **Right shift operator**: The left-hand side operand bit is moved
    right by the number specified on the right-hand side |'
  prefs: []
  type: TYPE_TB
- en: 'The following screenshot illustrates the various usages of bitwise operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_013-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`~x` will give `-241`, which is in *2''s complement* form due to a signed binary
    number.'
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python supports logical operators *AND*, *OR*, and *NOT*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `and` | Returns `True` if both the right-hand and left-hand sides of the
    operator are true |'
  prefs: []
  type: TYPE_TB
- en: '| `or` | Returns `True` if any side, either the right-hand side or the left-hand
    side, of the operator is true |'
  prefs: []
  type: TYPE_TB
- en: '| `not` | If condition in the `not` operator is `True`, the `not` operator
    makes it `False` |'
  prefs: []
  type: TYPE_TB
- en: 'These only evaluate their second argument if needed for their outcome, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_014-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Membership operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python has two membership operators to test the membership in a sequence, such
    as a string, list, tuple, and others:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `in` | Returns `True` if the specified operand is found in the sequence |'
  prefs: []
  type: TYPE_TB
- en: '| `not in` | Returns `True` if the specified operand is not found in the sequence
    |'
  prefs: []
  type: TYPE_TB
- en: 'The following screenshot will make it clearer for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_015-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we try to search for the character, `'o'`, in the
    string, `'John'`, and it returns `True`. However, `'k'` is not present in the
    string, and hence, it returns `False`.
  prefs: []
  type: TYPE_NORMAL
- en: Identity operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given in the table are the two identity operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `is` | Returns `True` if two variables point to the same object and `False`,
    otherwise |'
  prefs: []
  type: TYPE_TB
- en: '| `is not` | Returns `False` if two variables point to the same object and
    `True`, otherwise |'
  prefs: []
  type: TYPE_TB
- en: 'The following screenshot shows that the value can be same but `id` can be different.
    It returns `True` if `id` is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_016-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, as both `x` and `y` contain the same value (`10`), `id()` returns the
    same value for both. However, when `x` and `y` are provided with the same list,
    `id()` returns different values. This could be attributed to the fact that when
    `x` and `y` have `10` assigned to them, it essentially means that both are pointing
    to the same memory address, which has a value of `10`, while in the case of a
    list, this could be different. Why different? That is because lists are immutable,
    which means they can't be changed. So, when we assign the same list to `y`, it
    means that a new memory address is blocked again for a new list.
  prefs: []
  type: TYPE_NORMAL
- en: The `id()` function returns the *identity* of an object. This is an integer
    (or long integer), which is guaranteed to be unique and constant for this object
    during its lifetime. It is similar to memory addresses in the C language.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a small twist in our `id()` function. Python supports same
    memory allocation for integers only up to `256`. It will be clearer with the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_017-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, as you can see, once we pass values above `256` for `x` and `y`, both
    are given different memory allocations by the interpreter, but if the values are
    `256`, then the same memory allocation is provided for both `x` and `y`.
  prefs: []
  type: TYPE_NORMAL
- en: Operator precedence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Operators with the highest precedence are placed on the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `( )` | Parentheses |'
  prefs: []
  type: TYPE_TB
- en: '| `x[index]`,`x[index1:index2]`,`f(arg...)`,`x.attribute` | Subscription, slicing,
    call, and attribute reference |'
  prefs: []
  type: TYPE_TB
- en: '| `**` | Exponentiation |'
  prefs: []
  type: TYPE_TB
- en: '| `+x`, `-x`, `~x` | Positive, negative, and bitwise *NOT* |'
  prefs: []
  type: TYPE_TB
- en: '| `*`, `/`, `%` | Multiplication, division, and remainder |'
  prefs: []
  type: TYPE_TB
- en: '| `+`, `-` | Addition and subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| `<<`, `>>` | Shifts |'
  prefs: []
  type: TYPE_TB
- en: '| `&` | Bitwise *AND* |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Bitwise *XOR* |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | Bitwise *OR* |'
  prefs: []
  type: TYPE_TB
- en: '| `in`, `not in`, `is`, `is not`, `<`, `<=`, `>`, `>=`, `!=`, `==` | Comparisons,
    including membership tests and identity tests |'
  prefs: []
  type: TYPE_TB
- en: '| `not x` | Boolean *NOT* |'
  prefs: []
  type: TYPE_TB
- en: '| `and` | Boolean *AND* |'
  prefs: []
  type: TYPE_TB
- en: '| `or` | Boolean *OR* |'
  prefs: []
  type: TYPE_TB
- en: '| `if...else` | Conditional expression |'
  prefs: []
  type: TYPE_TB
- en: '| `lambda` | Lambda expression |'
  prefs: []
  type: TYPE_TB
- en: Operators that have the same precedence are evaluated from left to right, except
    for comparisons and exponentiation. Comparisons can be chained arbitrarily.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about various data types available in Python and
    the naming conventions required. You also learned about the Python character set
    and about converting a character set to ASCII code and vice versa, using `ord()`
    and `chr()` methods available in the language. In the next chapter, you will learn
    about two different data types, namely string and tuples.
  prefs: []
  type: TYPE_NORMAL
