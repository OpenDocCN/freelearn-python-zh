["```py\n    This is a simple doctest that checks some of Python's arithmetic\n    operations.\n\n    >>> 2 + 2\n    4\n\n    >>> 3 * 3\n    10\n    ```", "```py\n    $ python -m doctest test.txt\n\n    ```", "```py\n    $ python -c \"__import__('doctest').testfile('test.txt')\"\n    ```", "```py\n    Now we're going to take some more of doctest's syntax for a spin.\n\n    >>> import sys\n    >>> def test_write():\n    ...     sys.stdout.write(\"Hello\\n\")\n    ...     return True\n    >>> test_write()\n    Hello\n    True\n    ```", "```py\n    Here we use doctest's exception syntax to check that Python is correctly enforcing its grammar.\n\n    >>> def faulty():\n    ...     yield 5\n    ...     return 7\n    Traceback (most recent call last):\n    SyntaxError: 'return' with argument inside generator (<doctest test.txt[5]>, line 3)\n    ```", "```py\n    Next up, we're exploring the ellipsis.\n\n    >>> sys.modules # doctest: +ELLIPSIS\n    {...'sys': <module 'sys' (built-in)>...}\n\n    >>> 'This is an expression that evaluates to a string'\n    ... # doctest: +ELLIPSIS\n    'This is ... a string'\n    >>> 'This is also a string' # doctest: +ELLIPSIS\n    'This is ... a string'\n\n    >>> import datetime\n    >>> datetime.datetime.now().isoformat() # doctest: +ELLIPSIS\n        '...-...-...T...:...:...'\n    ```", "```py\n    Next, a demonstration of whitespace normalization.\n\n    >>> [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    ... # doctest: +NORMALIZE_WHITESPACE\n    [1, 2, 3,\n     4, 5, 6,\n     7, 8, 9]\n\n    >>> sys.stdout.write(\"This text\\n contains weird     spacing.\")\n    ... # doctest: +NORMALIZE_WHITESPACE\n    This text contains weird spacing.\n    ```", "```py\n    Now we're telling doctest to skip a test\n\n    >>> 'This test would fail.' # doctest: +SKIP\n    If it were allowed to run.\n    ```", "```py\n>>> def test1():\n...     import frob\n...     return frob.hash('qux')\n>>> test1()\n77\n```", "```py\nThe fib(N) function takes a single integer as its only parameter N. If N is 0 or 1, the function returns 1\\. If N is less than 0, the function raises a ValueError. Otherwise, the function returns the sum of fib(N – 1) and fib(N – 2). The returned value will never be less than 1\\. On versions of Python older than 2.2, and if N is at least 52, the function will raise an OverflowError. A naïve implementation of this function would get very slow as N increased.\n```", "```py\n    def testable(x):\n        r\"\"\"\n        The `testable` function returns the square root of its\n        parameter, or 3, whichever is larger.\n        >>> testable(7)\n        3.0\n        >>> testable(16)\n        4.0\n        >>> testable(9)\n        3.0\n        >>> testable(10) == 10 ** 0.5\n        True\n        \"\"\"\n        if x < 9:\n            return 3.0\n        return x ** 0.5\n    ```", "```py\n    $ python -m doctest test.py\n\n    ```", "```py\n    python -m doctest -v test.py\n\n    ```", "```py\nAn AVL Tree consists of a collection of nodes organized in a binary tree structure. Each node has left and right children, each of which may be either None or another tree node. Each node has a key, which must be comparable via the less-than operator. Each node has a value. Each node also has a height number, measuring how far the node is from being a leaf of the tree -- a node with height 0 is a leaf.\n\nThe binary tree structure is maintained in ordered form, meaning that of a node's two children, the left child has a key that compares less than the node's key and the right child has a key that compares greater than the node's key.\n\nThe binary tree structure is maintained in a balanced form, meaning that for any given node, the heights of its children are either the same or only differ by 1.\n\nThe node constructor takes either a pair of parameters representing a key and a value, or a dict object representing the key-value pairs with which to initialize a new tree.\n\nThe following methods target the node on which they are called, and can be considered part of the internal mechanism of the tree:\n\nEach node has a recalculate_height method, which correctly sets the height number.\n\nEach node has a make_deletable method, which exchanges the positions of the node and one of its leaf descendants, such that the the tree ordering of the nodes remains correct.\n\nEach node has rotate_clockwise and rotate_counterclockwise methods. Rotate_clockwise takes the node's right child and places it where the node was, making the node into the left child of its own former child. Other nodes in the vicinity are moved so as to maintain the tree ordering. The opposite operation is performed by rotate_counterclockwise.\n\nEach node has a locate method, taking a key as a parameter, which searches the node and its descendants for a node with the specified key, and either returns that node or raises a KeyError.\n\nThe following methods target the whole tree rooted at the current node. The intent is that they will be called on the root node:\n\nEach node has a get method taking a key as a parameter, which locates the value associated with the specified key and returns it, or raises KeyError if the key is not associated with any value in the tree.\n\nEach node has a set method taking a key and a value as parameters, and associating the key and value within the tree.\n\nEach node has a remove method taking a key as a parameter, and removing the key and its associated value from the tree. It raises KeyError if no values was associated with that key.\n```", "```py\n>>> from avl_tree import AVL\n\n>>> def valid_state(node):\n...     if node is None:\n...         return\n...     if node.left is not None:\n...         assert isinstance(node.left, AVL)\n...         assert node.left.key < node.key\n...         left_height = node.left.height + 1\n...     else:\n...         left_height = 0\n...\n...     if node.right is not None:\n...         assert isinstance(node.right, AVL)\n...         assert node.right.key > node.key\n...         right_height = node.right.height + 1\n...     else:\n...         right_height = 0\n...\n...     assert abs(left_height - right_height) < 2\n...     node.key < node.key\n...     node.value\n\n>>> def valid_tree(node):\n...     if node is None:\n...         return\n...     valid_state(node)\n...     valid_tree(node.left)\n...     valid_tree(node.right)\n```", "```py\n    >>> valid_state(AVL(2, 'Testing is fun'))\n    ```", "```py\n>>> def make_test_tree():\n...     root = AVL(7, 'seven')\n...     root.height = 2\n...     root.left = AVL(3, 'three')\n...     root.left.height = 1\n...     root.left.right = AVL(4, 'four')\n...     root.right = AVL(10, 'ten')\n...     return root\n\n>>> tree = make_test_tree()\n>>> tree.height = 0\n>>> tree.recalculate_height()\n>>> tree.height\n2\n```", "```py\nEach node has a make_deletable method, which exchanges the positions of the node and one of its leaf descendants, such that the the tree ordering of the nodes remains correct.\n\n>>> tree = make_test_tree()\n>>> target = tree.make_deletable()\n>>> (tree.value, tree.height)\n('four', 2)\n>>> (target.value, target.height)\n('seven', 0)\n```", "```py\n>>> tree = make_test_tree()\n>>> tree.value\n'seven'\n>>> tree.left.value\n'three'\n```", "```py\n>>> tree.rotate_counterclockwise()\n>>> tree.value\n'three'\n>>> tree.left\nNone\n>>> tree.right.value\n'seven'\n>>> tree.right.left.value\n'four'\n>>> tree.right.right.value\n'ten'\n>>> tree.right.left.value\n'four'\n>>> tree.left is None\nTrue\n```", "```py\n>>> tree.rotate_clockwise()\n>>> tree.value\n'seven'\n>>> tree.left.value\n'three'\n>>> tree.left.right.value\n'four'\n>>> tree.right.value\n'ten'\n>>> tree.right.left is None\nTrue\n>>> tree.left.left is None\nTrue\n\n```", "```py\n>>> tree = make_test_tree()\n>>> tree.locate(4).value\n'four'\n>>> tree.locate(17) # doctest: +ELLIPSIS\nTraceback (most recent call last):\nKeyError: …\n```"]