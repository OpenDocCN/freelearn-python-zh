- en: Chapter 10. Creating Components and Extending Functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the `ArtProvider`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding controls to a `StatusBar`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a tool window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `SearchBar`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with `ListCtrl` mixins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StyledTextCtrl` custom highlighting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you've been working with wxPython for a while, you may find that you need
    some functionality or behavior that is not provided by default with the common
    controls. So in order to get this, you need some level of customization, or even
    the creation of a completely new type of control may become necessary in order
    to provide the interface that your application and users need.
  prefs: []
  type: TYPE_NORMAL
- en: There is a fair amount of flexibility built into many controls to change their
    behavior through the use of their style flags. In this chapter however, we will
    explore some object-oriented approaches for creating new controls as well as extending
    the functionality of some of the standard controls through inheritance. So let's
    get going and jump into some recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the ArtProvider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ArtProvider` is a singleton object that can be used by any component that
    wants to display system theme provided bitmaps. In wxPython 2.8, only the GTK
    (Linux) port has a native implementation of this object, so other platforms use
    the icons that are built into wxPython. These built-in icons are a bit dated and
    out-of-place looking to say the least. This recipe shows how to create a custom
    `ArtProvider` to handle the display of custom icons on Windows and OS X while
    still retaining the native system theme icons on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here we define our custom `ArtProvider` implementation, which just requires
    us to override the `CreateBitmap` method, which is used to load our custom icons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then all that we need to do in order to use the custom `TangoArtProvider` in
    an application is to push it onto the `ArtProvider` stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ArtProvider` singleton maintains a stack of `ArtProvider` objects that
    are chained together. When calling `GetBitmap` on the `ArtProvider`, it will first
    ask the one at the top of the stack for the requested `Bitmap`. If that one returns
    `NullBitmap`, it will ask the next one, and so on and so forth until either the
    `Bitmap` is found or the bottom of the stack is reached.
  prefs: []
  type: TYPE_NORMAL
- en: All that needs to be done to create a custom `ArtProvider` is to create a subclass
    that overrides the `CreateBitmap` method. Our `TangoArtProvider` overrides this
    method and provides a small set of icons from the free Tango ([http://tango.freedesktop.org](http://tango.freedesktop.org))
    icon set. We simply have a folder with some PNG images in it that we map to some
    of the wxPython `ART_*` IDs and then load them from disk into a `Bitmap` when
    requested.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Creating Singletons* recipe in [Chapter 9](ch09.html "Chapter 9. Design
    Approaches and Techniques"), *Design Approaches and Techniques* for an explanation
    of what singletons, such as the `ArtProvider`, are.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding controls to a StatusBar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `StatusBar` is a common component found in many applications for the display
    of short information messages at the bottom of the main windows content area.
    The standard `StatusBar` supports the display of multiple status text fields.
    This recipe shows how to create an advanced `StatusBar` that has a `Gauge` built-in
    to it in order to show progress during long-running tasks. Just as a sneak peak
    of what we are going to create, take a look at the following screenshot to see
    the `ProgressStatusBar` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding controls to a StatusBar](img/1780_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we will create our `ProgressStatusBar` class by creating a subclass of
    `StatusBar`. In the constructor, we create the `Gauge` for showing the progress
    and a `Timer` to use for updating the `Gauge:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following helper method is used to make sure that the `Gauge` control is
    repositioned into the right-most status field when its `Frame` changes position
    or size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Timer` event handler is used for handling when the `Gauge` is being used
    in indeterminate mode to pulse the `Gauge:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Starting here with the `Run` method, we have added some public methods for manipulating
    the `StatusBar's Gauge` from user code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: See the sample code that accompanies this chapter for a sample application of
    the `ProgressStatusBar` in action.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main trick to this recipe is the need to manually maintain the size and
    position of the `Gauge` control so that it stays in the same relative place on
    the `StatusBar`, regardless of how the window is moved or resized. We handled
    this with our `__Reposition` method that simply positions and sizes the `Gauge`
    based on the right-most field in the `StatusBar`. Then we just call this method
    whenever we hide or show the Gauge, or when the window is resized, and during
    `OnIdle` as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The `ProgressStatusBar` class supports two modes of operation for the progress
    gauge. The `Gauge` can either be shown in busy mode (indeterminate) or in incremental
    mode. In busy mode, we just start and run a `Timer` to `Pulse` the `Gauge` in
    the event handler. In incremental mode, the `Gauge's` range is first set with
    `SetRange` and then its progress is updated incrementally by the application as
    necessary by calling `SetProgress`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Creating a custom SplashScreen* recipe in Chapter 5, *Providing Information
    and Alerting Users* for another example of using the Gauge control and Timers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a tool window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `ToolWindow` is a little floating window that often functions like a `ToolBar`
    by having many different tool icons on it that can be clicked to initiate various
    actions. These types of windows are often seen in paint applications for holding
    pallets and other tools. This recipe shows how to create a simple `ToolWindow`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First let''s define the base `ToolWindow` class by deriving from `MiniFrame`
    so that it will be a small, floating, top-level window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `ToolPanel` class acts as the container and manager for the tools that are
    added to the `ToolWindow:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddTool` method takes the passed in ID and Bitmap and creates a `BitmapButton`
    to use as the tool, and then simply adds this to the sizer''s layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnButton` handler catches all button clicks in the `Panel` and then publishes
    a notification to all observers that have subscribed to tool messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: See the example code that accompanies this chapter for a sample text editor
    application that uses `ToolWindow`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have seen the code, let's take a quick walkthrough so we can see
    how it all works together.
  prefs: []
  type: TYPE_NORMAL
- en: Our `ToolWindow` class is composed of a `MiniFrame` and a `Panel` that will
    have `BitmapButtons` added to it when the client code calls its `AddTool` method.
    The `ToolWindow` has two arguments, `rows` and `columns`, that can specify the
    dimensions to use when laying out the tools in the `ToolPanel's FlexGridSizer`.
    In order to ensure that the `ToolWindow` is the correct size and that all of its
    tools are visible, it is necessary to call `Layout` in the `ToolPanel's AddTool`
    method, and then call `Fit` on the `ToolWindow` to ensure that the layout is recalculated
    and that the window is resized to best fit its contents.
  prefs: []
  type: TYPE_NORMAL
- en: When a tool is clicked on the `ToolWindow`, the event handler for the button
    simply uses `pubsub` to send a message containing the tool's ID to any observers
    of the `MSG_TOOL_CLICKED` topic. This method of notification was chosen because
    this way, if the application has multiple windows, they can all share the same
    `ToolWindow` instead of each creating their own instance of it.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Implementing an observer pattern* recipe in [Chapter 9](ch09.html "Chapter 9. Design
    Approaches and Techniques"), *Design Approaches and Techniques* for an in-depth
    discussion about using the observer pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a SearchBar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Search bars have become a fairly familiar component in many applications as
    an alternative to showing a `FindDialog` that can cover part of the screen, obscuring
    the search area. There is no built-in control in wxPython that implements this
    functionality, so this recipe shows how to create a simple `SearchBar` control.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our `SearchBar` control will be a composite control composed of a `Panel` as
    the base, with a `SearchCtrl` on it to allow for the search text to be entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, in `OnCancel`, we handle the cancel button event of the `SearchCtrl`
    in order to clear the current search text and hide the cancel button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`OnEnter` will handle the keyboard events generated by the `SearchCtrl`. We
    use it to see when the user has pressed the return key to initiate a search. We
    do this by creating a `FindDialogEvent` to allow clients to bind to `EVT_FIND`
    and handle the searching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the example application that accompanies this recipe will result in
    a window like the following being shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1780_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe shows how to make a very basic composite control. The `SearchBar`
    is just a simple `Panel` that has a `SearchCtrl` on it. To use it in a `Frame`,
    all that needs to be done is to create a vertical `BoxSizer` and add the `SearchBar`
    to this, so that it is positioned below or above the main content area in which
    the searches will take place. The Frame can then respond to the events that the
    `SearchBar` emits. We had to do a few things in order to support the sending of
    a find event when the user presses the *Return* key in the `SearchCtrl`. So let's
    take a look at that now.
  prefs: []
  type: TYPE_NORMAL
- en: In the `SearchBar's` constructor we had to define some special case code for
    Windows and Linux to be able to bind our `EVT_KEY_UP` handler. This was necessary
    to work around a bug where the `KeyEvents` don't propagate properly due to the
    `SearchControl` being a composite control on those two platforms. On Macintosh,
    the `SearchCtrl` is a native widget so the event binding works normally. Next,
    in our `OnEnter` event handler, we check the value of the text in the control
    and generate either an `EVT_FIND` or `EVT_FIND_NEXT` event depending on the context
    of the search. Since these are command events, calling `self.ProcessEvent` will
    start the processing of our `FIND` event in the event handler chain allowing it
    to propagate until it is handled.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Understanding event propagation* recipe in [Chapter 2](ch02.html "Chapter 2. Responding
    to Events"), *Responding to Events* for a discussion of how events work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Using a BoxSizer* recipe in [Chapter 7](ch07.html "Chapter 7. Window
    Layout and Design"), *Window Layout and Design* for an explanation of how to use
    BoxSizers to perform window layout control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with ListCtrl mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like the `TreeCtrl`, there are a number of mixin classes available to extend
    the functionality of the standard `ListCtrl`. This recipe provides an introduction
    to using the `CheckListCtrlMixin, ListRowHighlighter`, and `ListCtrlAutoWidthMixin`
    mixin classes to create a `ListCtrl` that allows the selection of multiple items
    by using `CheckBoxes`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will define our base `CheckListCtrl` class that uses three mixin classes
    to customize the control''s look and feel, as well as add checkboxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we override the `CheckListCtlrMixin''s OnCheckItem` method and implement
    an observer interface to notify clients when a `CheckBox` in the list is toggled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'All that''s remaining is to add a `GetItems` method to return the list of checked
    items, and another method to allow clients to register themselves as observers
    of when items are checked in the control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we created a general use base class, `CheckListCtrl`, that will
    have the following extended features. It will have a `CheckBox` on each row in
    column 0, alternate rows will have their backgrounds highlighted, and the rightmost
    column of the `ListCtrl` will automatically be sized to fill the remaining space
    in the control. Each of these features are provided by the `CheckListCtrlMixin,
    ListRowHighlighter`, and `ListCtrlAutoWidthMixin` classes respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The `CheckListCtrlMixin` provides an overridable method, `OnCheckItem`, that
    will be called when one of the `CheckBoxes` in the `ListCtrl` is clicked on. We
    overrode this method and added a way for client code to register observer callback
    methods with the control. In this way, if any client code that uses this control
    wants to be notified when a `CheckBox` is toggled, they can register their own
    observer methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of our `CheckListCtrl` class is the `GetItems` method that was
    added to make it easy to get a list of the indexes of all the checked or unchecked
    items in the control. Please see the sample code that accompanies this topic for
    a sample application that uses this new control:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1780_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `wx.lib.mixins.listctrl` module provides a couple more mixin classes for
    the `ListCtrl`. Here is a quick reference to these other classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mixin classes | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ColumnSorterMixin` | Helps handle the sorting of the items in the control
    when a column header is clicked on. |'
  prefs: []
  type: TYPE_TB
- en: '| `TextEditMixin` | Makes it possible to edit the text in any column of a multi-column
    `ListCtrl`. |'
  prefs: []
  type: TYPE_TB
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Listing data with a ListCtrl* recipe in [Chapter 4](ch04.html "Chapter 4. Advanced
    Building Blocks of a User Interface"), *Advanced Building Blocks of a User Interface*
    for another example of using the `ListCtrl`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Implementing an observer pattern* recipe in [Chapter 9](ch09.html "Chapter 9. Design
    Approaches and Techniques"), *Design Approaches and Techniques* for a discussion
    of using the observer pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: StyledTextCtrl custom highlighting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in the *StyledTextCtrl using lexers* section of Chapter 4, *Advanced
    Building Blocks of a User Interface*, the `StyledTextCtrl` is a powerful source
    code editing component that has support for syntax-highlighting many different
    types of source code. However, if you find that you need to support some highlighting
    in your application that the `StyledTextCtrl` doesn't have a built-in lexer for,
    you might think that you are out of luck. This isn't the case, though. Custom
    lexers can be added through the use of the special container lexer. This recipe
    shows how to write and use a custom lexer that does some simple highlighting.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a part of this recipe, we will create a simple little framework that can
    be extended to do other kinds of highlighting. Let's start with the `BaseLexer`
    class, which defines a single method interface for handling the `EVT_STC_STYLENEEDED`
    event that is generated by the `StyledTextCtrl:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we have our example implementation of the `VowelLexer`, which will provide
    text styling for all vowels in a document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `StyleText` method is what our custom `StyledTextCtrl` will delegate to
    in its `EVT_STC_STYLENEEDED` event handler. The `VowelLexer` supports two different
    styles: one for its default style and another one for vowels.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CustomSTC` class will provide the framework for using `BaseLexer-derived`
    classes to customize the highlighting of the text in the control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Included with the sample code that accompanies this chapter is a simple application
    that uses the custom `VowelLexer` class defined above.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we first built a little framework for creating custom lexers
    for the `StyledTextCtrl`. Starting with our `BaseLexer` class, we defined a simple
    interface for objects that will delegate the task of handling `EVT_STC_STYLENEEDED`.
    Next, we created the `VowelLexer` class, which is a simple subclass of `BaseLexer`
    that will highlight vowels in the text of a document. Applying styling in the
    `StyledTextCtrl` involves three basic steps. First, you need to call `StartStyling`
    to indicate the position in the buffer you wish to start styling text, then you
    need to determine what style byte to set, and finally you need to call `SetStyling`
    to set how many characters from the start position to style with the given style.
  prefs: []
  type: TYPE_NORMAL
- en: Now in order for the `StyledTextCtrl` to make use of these lexers, we needed
    to do a couple things that we have encapsulated in the `CustomSTC` class. The
    `StyledTextCtrl` needs to bind to `EVT_STC_STYLENEEDED` and set the `STC_LEX_CONTAINER`
    lexer. The `StyledTextCtrl` will generate `EVT_STC_STYLEDNEEDED` when the container
    lexer is the current lexer and when it detects that some of the text in the buffer
    may need to be restyled due to changes in its contents. To handle this in our
    `CustomSTC` class, we simply delegate the event to the current lexer object that
    was set by the call to our overridden `SetLexer` method.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have a super-simple sample application that shows how our `CustomSTC`
    and `VowelLexer` can be used in an application. First, we needed to set up the
    styling by calling `SetStyleSpec` to set which colors will be applied for our
    lexer's two-style bytes. The `STC_STYLE_VOWEL_DEFAULT` will be styled with plain
    black text, and `STC_STYLE_VOWEL_KW` will be styled with red text. Then, all is
    left is to call `SetLexer` to set the `STC_LEX_CONTAINER` lexer and create an
    instance of our `VowelLexer` for the control to use. So give it a run and see
    that as you type into the buffer, all vowels should be colored red.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *StyledTextCtrl using lexers* recipe in [Chapter 4](ch04.html "Chapter 4. Advanced
    Building Blocks of a User Interface"), *Advanced Building Blocks of a User Interface*
    for another example of using the `StyleTextCtrl`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point, you may need to invent an entirely new control to fit some specific
    requirement of your application. So in this recipe we will take a look at some
    techniques for creating a new control completely from scratch. We will create
    a custom `CheckBox` control that has its label below the `CheckBox`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started, we will define the constructor of the `CustomCheckBox` control
    as a subclass of `PyControl`. In the constructor, we bind to a number of events
    that will let us define the behavior of the control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have this helper method to help manage what state the control is in
    with regards to the mouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a virtual override of the `PyControl''s DoGetBestSize` method to control
    what the size of the control is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we focus on the event handlers that will define the behavior of the control.
    First, in `OnPaint`, we do the drawing that gives the control its appearance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The next two event handlers manage the mouse click state in the control to
    toggle the `CheckBox` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, we define a couple of methods to implement part of the
    `wx.CheckBox` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This was a fairly simple control to implement, but it is a good example of some
    of the approaches to take when creating your own custom control. So let's break
    down each of the important parts and see how they affect the way in which the
    control works.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in the constructor, we define three attributes to manage the state of
    the control:'
  prefs: []
  type: TYPE_NORMAL
- en: '`self._hstate:` To hold the current highlight state of the control.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`self._checked:` To hold the `CheckBox` state.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`self._ldown:` To hold when the left mouse button was clicked down in the control.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we `Bind` to the events that are necessary to draw the control and implement
    its behavior. We made use of two paint events and four different mouse events.
    First, let's take a look at the mouse event handlers that are used to implement
    the control's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In `OnLeftDown`, we simply set our `self._ldown` flag to `True` in order to
    indicate that the down-click action was initiated in this window and not elsewhere.
    Then, in the `OnLeftUp` handler, if the `self._ldown` flag is `True`, we toggle
    the `self._checked` flag to reflect the new `CheckBox` state, and then call `Refresh`.
    Calling `Refresh` will cause an `EVT_PAINT` event to be generated so that we can
    redraw the control in its new state with our `OnPaint` handler. After this, we
    also generate an `EVT_CHECKBOX` event in order to inform the application that
    the `CheckBox` state has changed. The remaining two mouse events are used to update
    the control's highlight state when the mouse enters or leaves the controls area.
  prefs: []
  type: TYPE_NORMAL
- en: '`OnPaint` is where we draw the control and give it its appearance. We start
    in `OnPaint` by creating our drawing contexts and setting up the background. Next,
    we calculate the position to draw the `CheckBox` within the control''s rectangle
    and use `RendererNative` to draw the `CheckBox` according to the control''s current
    state. Then, all that is left is to draw the label below the `CheckBox` using
    our `GCDC''s DrawLabel` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish off the control, we added some methods to implement part of the regular
    interface for the `CheckBox` so that the application code using this control can
    get and set the `CheckBox` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1780_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Understanding inheritance limitations* recipe in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with wxPython"), *Getting Started with wxPython* for
    a discussion about overriding virtual methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the Understanding event propagation recipe in [Chapter 2](ch02.html "Chapter 2. Responding
    to Events"), *Responding to Events* for more information on working with events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Drawing with RendererNative* recipe in [Chapter 8](ch08.html "Chapter 8. Drawing
    to the Screen"), *Drawing to the Screen* for another example of using `RendererNative`
    for drawing native-looking controls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Reducing flicker in drawing routines* recipe in [Chapter 8](ch08.html
    "Chapter 8. Drawing to the Screen"), *Drawing to the Screen* for an explanation
    of how to reduce flicker in drawing routines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
