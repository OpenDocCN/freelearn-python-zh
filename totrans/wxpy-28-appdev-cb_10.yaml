- en: Chapter 10. Creating Components and Extending Functionality
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 创建组件和扩展功能
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Customizing the `ArtProvider`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义 `ArtProvider`
- en: Adding controls to a `StatusBar`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`StatusBar`添加控件
- en: Making a tool window
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个工具窗口
- en: Creating a `SearchBar`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 `搜索栏`
- en: Working with `ListCtrl` mixins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ListCtrl` 混合
- en: '`StyledTextCtrl` custom highlighting'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StyledTextCtrl` 自定义高亮'
- en: Creating a custom control
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义控件
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Once you've been working with wxPython for a while, you may find that you need
    some functionality or behavior that is not provided by default with the common
    controls. So in order to get this, you need some level of customization, or even
    the creation of a completely new type of control may become necessary in order
    to provide the interface that your application and users need.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您使用 wxPython 了一段时间，您可能会发现您需要一些默认情况下普通控件所不具备的功能或行为。因此，为了获得这些功能，您可能需要一定程度的定制，甚至可能需要创建一种全新的控件类型，以便提供您应用程序和用户所需的用户界面。
- en: There is a fair amount of flexibility built into many controls to change their
    behavior through the use of their style flags. In this chapter however, we will
    explore some object-oriented approaches for creating new controls as well as extending
    the functionality of some of the standard controls through inheritance. So let's
    get going and jump into some recipes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 许多控件内置了相当大的灵活性，可以通过使用它们的样式标志来改变它们的行为。然而，在本章中，我们将探讨一些面向对象的方法来创建新的控件，以及通过继承扩展一些标准控件的功能。那么，让我们开始并跳入一些食谱吧。
- en: Customizing the ArtProvider
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义 ArtProvider
- en: The `ArtProvider` is a singleton object that can be used by any component that
    wants to display system theme provided bitmaps. In wxPython 2.8, only the GTK
    (Linux) port has a native implementation of this object, so other platforms use
    the icons that are built into wxPython. These built-in icons are a bit dated and
    out-of-place looking to say the least. This recipe shows how to create a custom
    `ArtProvider` to handle the display of custom icons on Windows and OS X while
    still retaining the native system theme icons on Linux.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArtProvider` 是一个单例对象，可以被任何想要显示系统主题提供的位图的组件使用。在 wxPython 2.8 中，只有 GTK（Linux）端口有这个对象的本地实现，因此其他平台使用的是内置到
    wxPython 中的图标。这些内置图标至少看起来有些过时和不太合适。这个菜谱展示了如何创建一个自定义的 `ArtProvider` 来处理 Windows
    和 OS X 上自定义图标的显示，同时仍然保留 Linux 上的本地系统主题图标。'
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here we define our custom `ArtProvider` implementation, which just requires
    us to override the `CreateBitmap` method, which is used to load our custom icons:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义我们的自定义 `ArtProvider` 实现，这只需要我们重写 `CreateBitmap` 方法，该方法用于加载我们的自定义图标：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then all that we need to do in order to use the custom `TangoArtProvider` in
    an application is to push it onto the `ArtProvider` stack:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们只需要在应用程序中使用自定义的 `TangoArtProvider`，将其推送到 `ArtProvider` 栈中：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `ArtProvider` singleton maintains a stack of `ArtProvider` objects that
    are chained together. When calling `GetBitmap` on the `ArtProvider`, it will first
    ask the one at the top of the stack for the requested `Bitmap`. If that one returns
    `NullBitmap`, it will ask the next one, and so on and so forth until either the
    `Bitmap` is found or the bottom of the stack is reached.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArtProvider` 单例维护了一个由 `ArtProvider` 对象组成的栈，这些对象是相互链接的。当在 `ArtProvider` 上调用
    `GetBitmap` 方法时，它将首先向栈顶的对象请求所需的 `Bitmap`。如果该对象返回 `NullBitmap`，它将请求下一个对象，以此类推，直到找到
    `Bitmap` 或到达栈底。'
- en: All that needs to be done to create a custom `ArtProvider` is to create a subclass
    that overrides the `CreateBitmap` method. Our `TangoArtProvider` overrides this
    method and provides a small set of icons from the free Tango ([http://tango.freedesktop.org](http://tango.freedesktop.org))
    icon set. We simply have a folder with some PNG images in it that we map to some
    of the wxPython `ART_*` IDs and then load them from disk into a `Bitmap` when
    requested.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义的 `ArtProvider` 所需做的所有事情就是创建一个覆盖 `CreateBitmap` 方法的子类。我们的 `TangoArtProvider`
    覆盖了这个方法，并从免费的 Tango ([http://tango.freedesktop.org](http://tango.freedesktop.org))
    图标集中提供了一小套图标。我们仅仅有一个包含一些 PNG 图像的文件夹，我们将这些图像映射到一些 wxPython 的 `ART_*` ID 上，然后在需要时从磁盘加载它们到
    `Bitmap` 中。
- en: See also
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Creating Singletons* recipe in [Chapter 9](ch09.html "Chapter 9. Design
    Approaches and Techniques"), *Design Approaches and Techniques* for an explanation
    of what singletons, such as the `ArtProvider`, are.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第9章](ch09.html "第9章。设计方法和技巧")中的*创建单例*配方，*设计方法和技巧*，以了解单例（如`ArtProvider`）的解释。
- en: Adding controls to a StatusBar
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向状态栏添加控件
- en: 'The `StatusBar` is a common component found in many applications for the display
    of short information messages at the bottom of the main windows content area.
    The standard `StatusBar` supports the display of multiple status text fields.
    This recipe shows how to create an advanced `StatusBar` that has a `Gauge` built-in
    to it in order to show progress during long-running tasks. Just as a sneak peak
    of what we are going to create, take a look at the following screenshot to see
    the `ProgressStatusBar` in action:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`StatusBar` 是许多应用程序中常见的一个组件，用于在主窗口内容区域的底部显示简短的信息消息。标准的 `StatusBar` 支持显示多个状态文本字段。本食谱展示了如何创建一个高级的
    `StatusBar`，其中内置了一个 `Gauge` 以便在长时间运行的任务中显示进度。为了提前一睹我们将要创建的内容，请查看以下截图以查看 `ProgressStatusBar`
    的实际应用：'
- en: '![Adding controls to a StatusBar](img/1780_10_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![将控件添加到状态栏](img/1780_10_01.jpg)'
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: First, we will create our `ProgressStatusBar` class by creating a subclass of
    `StatusBar`. In the constructor, we create the `Gauge` for showing the progress
    and a `Timer` to use for updating the `Gauge:`
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过创建`StatusBar`的子类来创建我们的`ProgressStatusBar`类。在构造函数中，我们创建一个用于显示进度的`Gauge`和一个用于更新`Gauge`的`Timer`：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following helper method is used to make sure that the `Gauge` control is
    repositioned into the right-most status field when its `Frame` changes position
    or size:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下辅助方法用于确保当`Gauge`控制的位置或大小发生变化时，它会被重新定位到最右侧的状态字段：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Timer` event handler is used for handling when the `Gauge` is being used
    in indeterminate mode to pulse the `Gauge:`
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Timer`事件处理器用于处理在不确定模式下使用`Gauge`时进行脉冲的`Gauge:`'
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Starting here with the `Run` method, we have added some public methods for manipulating
    the `StatusBar's Gauge` from user code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里的 `Run` 方法开始，我们为用户代码操作 `StatusBar的Gauge` 添加了一些公共方法。
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: See the sample code that accompanies this chapter for a sample application of
    the `ProgressStatusBar` in action.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅本章附带的示例代码，以了解`ProgressStatusBar`的实际应用示例。
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The main trick to this recipe is the need to manually maintain the size and
    position of the `Gauge` control so that it stays in the same relative place on
    the `StatusBar`, regardless of how the window is moved or resized. We handled
    this with our `__Reposition` method that simply positions and sizes the `Gauge`
    based on the right-most field in the `StatusBar`. Then we just call this method
    whenever we hide or show the Gauge, or when the window is resized, and during
    `OnIdle` as necessary.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这道菜谱的主要技巧是需要手动维护`Gauge`控制的大小和位置，以确保它在`StatusBar`上保持相同的相对位置，无论窗口如何移动或调整大小。我们通过我们的`__Reposition`方法来处理这个问题，该方法简单地根据`StatusBar`中最右侧的字段来定位和调整`Gauge`的大小。然后，我们只需在隐藏或显示Gauge、窗口调整大小或必要时在`OnIdle`期间调用此方法即可。
- en: The `ProgressStatusBar` class supports two modes of operation for the progress
    gauge. The `Gauge` can either be shown in busy mode (indeterminate) or in incremental
    mode. In busy mode, we just start and run a `Timer` to `Pulse` the `Gauge` in
    the event handler. In incremental mode, the `Gauge's` range is first set with
    `SetRange` and then its progress is updated incrementally by the application as
    necessary by calling `SetProgress`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProgressStatusBar` 类支持进度条两种操作模式。`Gauge` 可以以忙碌模式（不确定）或增量模式显示。在忙碌模式下，我们只需在事件处理程序中启动并运行一个
    `Timer` 来 `Pulse` 进度条。在增量模式下，首先使用 `SetRange` 设置 `Gauge` 的范围，然后根据需要通过调用 `SetProgress`
    逐步更新其进度。'
- en: See also
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Creating a custom SplashScreen* recipe in Chapter 5, *Providing Information
    and Alerting Users* for another example of using the Gauge control and Timers.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅第5章，*提供信息和提醒用户*中的*创建自定义启动画面*配方，以了解使用仪表控件和计时器的另一个示例。
- en: Making a tool window
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建工具窗口
- en: A `ToolWindow` is a little floating window that often functions like a `ToolBar`
    by having many different tool icons on it that can be clicked to initiate various
    actions. These types of windows are often seen in paint applications for holding
    pallets and other tools. This recipe shows how to create a simple `ToolWindow`
    class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToolWindow` 是一个小型的浮动窗口，通常像 `ToolBar` 一样工作，在其上有很多不同的工具图标，可以通过点击来启动各种操作。这类窗口通常在绘画应用程序中用于存放调色板和其他工具。本食谱展示了如何创建一个简单的
    `ToolWindow` 类。'
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First let''s define the base `ToolWindow` class by deriving from `MiniFrame`
    so that it will be a small, floating, top-level window:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过从 `MiniFrame` 派生来定义基本的 `ToolWindow` 类，使其成为一个小型、浮动、顶级窗口：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `ToolPanel` class acts as the container and manager for the tools that are
    added to the `ToolWindow:`
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToolPanel` 类充当添加到 `ToolWindow:` 的工具的容器和管理者。'
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `AddTool` method takes the passed in ID and Bitmap and creates a `BitmapButton`
    to use as the tool, and then simply adds this to the sizer''s layout:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddTool` 方法接收传入的 ID 和位图，创建一个 `BitmapButton` 作为工具，然后简单地将它添加到布局管理器的布局中：'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `OnButton` handler catches all button clicks in the `Panel` and then publishes
    a notification to all observers that have subscribed to tool messages:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnButton` 处理器捕获 `Panel` 中的所有按钮点击，然后向所有已订阅工具消息的观察者发布通知：'
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See the example code that accompanies this chapter for a sample text editor
    application that uses `ToolWindow`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅本章附带示例代码，以了解使用`ToolWindow`的文本编辑器应用程序的示例。
- en: How it works...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Now that we have seen the code, let's take a quick walkthrough so we can see
    how it all works together.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了代码，让我们快速浏览一下，以便我们可以看到它是如何协同工作的。
- en: Our `ToolWindow` class is composed of a `MiniFrame` and a `Panel` that will
    have `BitmapButtons` added to it when the client code calls its `AddTool` method.
    The `ToolWindow` has two arguments, `rows` and `columns`, that can specify the
    dimensions to use when laying out the tools in the `ToolPanel's FlexGridSizer`.
    In order to ensure that the `ToolWindow` is the correct size and that all of its
    tools are visible, it is necessary to call `Layout` in the `ToolPanel's AddTool`
    method, and then call `Fit` on the `ToolWindow` to ensure that the layout is recalculated
    and that the window is resized to best fit its contents.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ToolWindow`类由一个`MiniFrame`和一个`Panel`组成，当客户端代码调用其`AddTool`方法时，将会向其添加`BitmapButtons`。`ToolWindow`有两个参数，`rows`和`columns`，可以指定在`ToolPanel`的`FlexGridSizer`中布局工具时使用的尺寸。为了确保`ToolWindow`的大小正确并且所有工具都可见，有必要在`ToolPanel`的`AddTool`方法中调用`Layout`，然后对`ToolWindow`调用`Fit`以确保布局重新计算并且窗口大小调整以最佳适应其内容。
- en: When a tool is clicked on the `ToolWindow`, the event handler for the button
    simply uses `pubsub` to send a message containing the tool's ID to any observers
    of the `MSG_TOOL_CLICKED` topic. This method of notification was chosen because
    this way, if the application has multiple windows, they can all share the same
    `ToolWindow` instead of each creating their own instance of it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 `ToolWindow` 上点击一个工具时，按钮的事件处理程序简单地使用 `pubsub` 发送一个包含工具 ID 的消息到 `MSG_TOOL_CLICKED`
    主题的任何观察者。选择这种通知方式是因为这样，如果应用程序有多个窗口，它们都可以共享同一个 `ToolWindow`，而不是每个窗口都创建它自己的实例。
- en: See also
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Implementing an observer pattern* recipe in [Chapter 9](ch09.html "Chapter 9. Design
    Approaches and Techniques"), *Design Approaches and Techniques* for an in-depth
    discussion about using the observer pattern.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第9章](ch09.html "第9章。设计方法和技巧")中的*实现观察者模式*配方，在*设计方法和技巧*中深入讨论使用观察者模式。
- en: Creating a SearchBar
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个搜索栏
- en: Search bars have become a fairly familiar component in many applications as
    an alternative to showing a `FindDialog` that can cover part of the screen, obscuring
    the search area. There is no built-in control in wxPython that implements this
    functionality, so this recipe shows how to create a simple `SearchBar` control.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索栏已成为许多应用中一个相当熟悉的组件，作为替代显示可以覆盖部分屏幕、遮挡搜索区域的`FindDialog`。wxPython中没有内置的控制来实现这一功能，因此这个菜谱展示了如何创建一个简单的`SearchBar`控制。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Our `SearchBar` control will be a composite control composed of a `Panel` as
    the base, with a `SearchCtrl` on it to allow for the search text to be entered:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `SearchBar` 控件将是一个由 `Panel` 作为基础，并在其上添加 `SearchCtrl` 以允许输入搜索文本的复合控件：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, in `OnCancel`, we handle the cancel button event of the `SearchCtrl`
    in order to clear the current search text and hide the cancel button:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在`OnCancel`中，我们处理`SearchCtrl`的取消按钮事件，以便清除当前搜索文本并隐藏取消按钮：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`OnEnter` will handle the keyboard events generated by the `SearchCtrl`. We
    use it to see when the user has pressed the return key to initiate a search. We
    do this by creating a `FindDialogEvent` to allow clients to bind to `EVT_FIND`
    and handle the searching:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnEnter` 将处理由 `SearchCtrl` 生成的键盘事件。我们使用它来查看用户何时按下回车键以启动搜索。我们通过创建一个 `FindDialogEvent`
    来允许客户端绑定到 `EVT_FIND` 并处理搜索：'
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Running the example application that accompanies this recipe will result in
    a window like the following being shown:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 运行本食谱所附带的示例应用程序，将显示如下窗口：
- en: '![How to do it...](img/1780_10_02.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1780_10_02.jpg)'
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe shows how to make a very basic composite control. The `SearchBar`
    is just a simple `Panel` that has a `SearchCtrl` on it. To use it in a `Frame`,
    all that needs to be done is to create a vertical `BoxSizer` and add the `SearchBar`
    to this, so that it is positioned below or above the main content area in which
    the searches will take place. The Frame can then respond to the events that the
    `SearchBar` emits. We had to do a few things in order to support the sending of
    a find event when the user presses the *Return* key in the `SearchCtrl`. So let's
    take a look at that now.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱展示了如何制作一个非常基本的复合控件。`SearchBar`只是一个简单的`Panel`，上面有一个`SearchCtrl`。要在`Frame`中使用它，只需创建一个垂直的`BoxSizer`并将`SearchBar`添加到其中，这样它就会位于搜索将进行的主体内容区域下方或上方。然后，`Frame`可以响应`SearchBar`发出的事件。为了支持在用户在`SearchCtrl`中按下*Return*键时发送查找事件，我们不得不做一些事情。现在，让我们看看这个吧。
- en: In the `SearchBar's` constructor we had to define some special case code for
    Windows and Linux to be able to bind our `EVT_KEY_UP` handler. This was necessary
    to work around a bug where the `KeyEvents` don't propagate properly due to the
    `SearchControl` being a composite control on those two platforms. On Macintosh,
    the `SearchCtrl` is a native widget so the event binding works normally. Next,
    in our `OnEnter` event handler, we check the value of the text in the control
    and generate either an `EVT_FIND` or `EVT_FIND_NEXT` event depending on the context
    of the search. Since these are command events, calling `self.ProcessEvent` will
    start the processing of our `FIND` event in the event handler chain allowing it
    to propagate until it is handled.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SearchBar`的构造函数中，我们不得不为Windows和Linux定义一些特殊情况的代码，以便能够绑定我们的`EVT_KEY_UP`处理程序。这是为了解决一个bug，由于`SearchControl`在这两个平台上是一个复合控件，导致`KeyEvents`无法正确传播。在Macintosh上，`SearchCtrl`是一个原生小部件，因此事件绑定可以正常工作。接下来，在我们的`OnEnter`事件处理程序中，我们检查控件中的文本值，并根据搜索的上下文生成一个`EVT_FIND`或`EVT_FIND_NEXT`事件。由于这些是命令事件，调用`self.ProcessEvent`将在事件处理程序链中启动我们的`FIND`事件的处理，允许它传播直到被处理。
- en: See also
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Understanding event propagation* recipe in [Chapter 2](ch02.html "Chapter 2. Responding
    to Events"), *Responding to Events* for a discussion of how events work.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第2章](ch02.html "第2章。响应事件")中的*理解事件传播*配方，以了解事件是如何工作的讨论。
- en: See the *Using a BoxSizer* recipe in [Chapter 7](ch07.html "Chapter 7. Window
    Layout and Design"), *Window Layout and Design* for an explanation of how to use
    BoxSizers to perform window layout control.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第7章](ch07.html "第7章。窗口布局与设计")中的*使用BoxSizer*配方，*窗口布局与设计*，以了解如何使用BoxSizers进行窗口布局控制。
- en: Working with ListCtrl mixins
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ListCtrl 混合
- en: Like the `TreeCtrl`, there are a number of mixin classes available to extend
    the functionality of the standard `ListCtrl`. This recipe provides an introduction
    to using the `CheckListCtrlMixin, ListRowHighlighter`, and `ListCtrlAutoWidthMixin`
    mixin classes to create a `ListCtrl` that allows the selection of multiple items
    by using `CheckBoxes`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `TreeCtrl`，有多个混合类（mixin classes）可供扩展标准 `ListCtrl` 的功能。本食谱介绍了如何使用 `CheckListCtrlMixin`、`ListRowHighlighter`
    和 `ListCtrlAutoWidthMixin` 混合类来创建一个 `ListCtrl`，该控件允许通过使用 `CheckBoxes` 来选择多个项目。
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here, we will define our base `CheckListCtrl` class that uses three mixin classes
    to customize the control''s look and feel, as well as add checkboxes:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将定义我们的基础 `CheckListCtrl` 类，该类使用三个混合类来自定义控件的外观和感觉，并添加复选框：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we override the `CheckListCtlrMixin''s OnCheckItem` method and implement
    an observer interface to notify clients when a `CheckBox` in the list is toggled:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们重写了`CheckListCtlrMixin`的`OnCheckItem`方法，并实现了一个观察者接口，以便在列表中的`CheckBox`被切换时通知客户端：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'All that''s remaining is to add a `GetItems` method to return the list of checked
    items, and another method to allow clients to register themselves as observers
    of when items are checked in the control:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是添加一个`GetItems`方法来返回已检查项目的列表，以及另一个方法允许客户端注册自己作为当项目在控制中检查时的观察者：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created a general use base class, `CheckListCtrl`, that will
    have the following extended features. It will have a `CheckBox` on each row in
    column 0, alternate rows will have their backgrounds highlighted, and the rightmost
    column of the `ListCtrl` will automatically be sized to fill the remaining space
    in the control. Each of these features are provided by the `CheckListCtrlMixin,
    ListRowHighlighter`, and `ListCtrlAutoWidthMixin` classes respectively.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了一个通用基类 `CheckListCtrl`，它将具有以下扩展功能。在列0的每一行都将有一个 `CheckBox`，交替的行将突出显示其背景，而
    `ListCtrl` 的最右侧列将自动调整大小以填充控件中的剩余空间。这些功能分别由 `CheckListCtrlMixin`、`ListRowHighlighter`
    和 `ListCtrlAutoWidthMixin` 类提供。
- en: The `CheckListCtrlMixin` provides an overridable method, `OnCheckItem`, that
    will be called when one of the `CheckBoxes` in the `ListCtrl` is clicked on. We
    overrode this method and added a way for client code to register observer callback
    methods with the control. In this way, if any client code that uses this control
    wants to be notified when a `CheckBox` is toggled, they can register their own
    observer methods.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckListCtrlMixin` 提供了一个可重写的方法，`OnCheckItem`，当在 `ListCtrl` 中的某个 `CheckBox`
    被点击时会被调用。我们重写了这个方法，并添加了一种方式让客户端代码可以注册观察者回调方法到该控件中。这样，如果任何使用这个控件的客户端代码希望在 `CheckBox`
    切换时收到通知，它们可以注册自己的观察者方法。'
- en: 'The last part of our `CheckListCtrl` class is the `GetItems` method that was
    added to make it easy to get a list of the indexes of all the checked or unchecked
    items in the control. Please see the sample code that accompanies this topic for
    a sample application that uses this new control:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`CheckListCtrl`类的最后一部分是`GetItems`方法，它是为了使获取控制中所有已勾选或未勾选项的索引列表变得容易而添加的。请参阅随此主题附带的示例代码，以了解使用此新控件的应用示例：
- en: '![How it works...](img/1780_10_03.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1780_10_03.jpg)'
- en: There's more...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `wx.lib.mixins.listctrl` module provides a couple more mixin classes for
    the `ListCtrl`. Here is a quick reference to these other classes:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`wx.lib.mixins.listctrl` 模块为 `ListCtrl` 提供了几个额外的混合类。以下是这些其他类的快速参考：'
- en: '| Mixin classes | Description |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 混入类 | 描述 |'
- en: '| --- | --- |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ColumnSorterMixin` | Helps handle the sorting of the items in the control
    when a column header is clicked on. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `ColumnSorterMixin` | 帮助处理在点击列标题时控件中项的排序。 |'
- en: '| `TextEditMixin` | Makes it possible to edit the text in any column of a multi-column
    `ListCtrl`. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `TextEditMixin` | 使之能够编辑多列 `ListCtrl` 中的任意列文本。 |'
- en: See also
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Listing data with a ListCtrl* recipe in [Chapter 4](ch04.html "Chapter 4. Advanced
    Building Blocks of a User Interface"), *Advanced Building Blocks of a User Interface*
    for another example of using the `ListCtrl`.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第4章](ch04.html "第4章。用户界面的高级构建块")中的*使用ListCtrl列出数据*配方，*用户界面的高级构建块*，以了解使用`ListCtrl`的另一个示例。
- en: See the *Implementing an observer pattern* recipe in [Chapter 9](ch09.html "Chapter 9. Design
    Approaches and Techniques"), *Design Approaches and Techniques* for a discussion
    of using the observer pattern.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第9章](ch09.html "第9章。设计方法和技巧")中的*实现观察者模式*配方，以了解如何使用观察者模式。
- en: StyledTextCtrl custom highlighting
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式文本控件自定义高亮
- en: As discussed in the *StyledTextCtrl using lexers* section of Chapter 4, *Advanced
    Building Blocks of a User Interface*, the `StyledTextCtrl` is a powerful source
    code editing component that has support for syntax-highlighting many different
    types of source code. However, if you find that you need to support some highlighting
    in your application that the `StyledTextCtrl` doesn't have a built-in lexer for,
    you might think that you are out of luck. This isn't the case, though. Custom
    lexers can be added through the use of the special container lexer. This recipe
    shows how to write and use a custom lexer that does some simple highlighting.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如第4章“用户界面的高级构建块”中“使用lexers的StyledTextCtrl”部分所述，`StyledTextCtrl`是一个功能强大的源代码编辑组件，它支持多种不同类型源代码的语法高亮。然而，如果你发现你的应用程序需要支持一些`StyledTextCtrl`没有内置lexers的语法高亮，你可能认为你运气不佳。但这并非事实。可以通过使用特殊的容器lexer来添加自定义lexers。本食谱展示了如何编写和使用一个执行一些简单高亮的自定义lexer。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: As a part of this recipe, we will create a simple little framework that can
    be extended to do other kinds of highlighting. Let's start with the `BaseLexer`
    class, which defines a single method interface for handling the `EVT_STC_STYLENEEDED`
    event that is generated by the `StyledTextCtrl:`
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个菜谱的一部分，我们将创建一个简单的框架，它可以扩展以执行其他类型的突出显示。让我们从定义处理由 `StyledTextCtrl:` 生成的 `EVT_STC_STYLENEEDED`
    事件的 `BaseLexer` 类开始。
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next we have our example implementation of the `VowelLexer`, which will provide
    text styling for all vowels in a document:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有我们的`VowelLexer`示例实现，它将为文档中所有的元音字母提供文本样式：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `StyleText` method is what our custom `StyledTextCtrl` will delegate to
    in its `EVT_STC_STYLENEEDED` event handler. The `VowelLexer` supports two different
    styles: one for its default style and another one for vowels.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`StyleText` 方法是我们自定义的 `StyledTextCtrl` 在其 `EVT_STC_STYLENEEDED` 事件处理程序中将要委托执行的方法。`VowelLexer`
    支持两种不同的样式：一种用于其默认样式，另一种用于元音字母。'
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `CustomSTC` class will provide the framework for using `BaseLexer-derived`
    classes to customize the highlighting of the text in the control:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomSTC` 类将为使用 `BaseLexer-derived` 类来定制控件中文本的高亮显示提供框架：'
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Included with the sample code that accompanies this chapter is a simple application
    that uses the custom `VowelLexer` class defined above.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章所附的示例代码一起包含的是一个使用上面定义的定制`VowelLexer`类的简单应用程序。
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we first built a little framework for creating custom lexers
    for the `StyledTextCtrl`. Starting with our `BaseLexer` class, we defined a simple
    interface for objects that will delegate the task of handling `EVT_STC_STYLENEEDED`.
    Next, we created the `VowelLexer` class, which is a simple subclass of `BaseLexer`
    that will highlight vowels in the text of a document. Applying styling in the
    `StyledTextCtrl` involves three basic steps. First, you need to call `StartStyling`
    to indicate the position in the buffer you wish to start styling text, then you
    need to determine what style byte to set, and finally you need to call `SetStyling`
    to set how many characters from the start position to style with the given style.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们首先为创建针对 `StyledTextCtrl` 的自定义词法分析器构建了一个小框架。从我们的 `BaseLexer` 类开始，我们定义了一个简单的接口，用于将处理
    `EVT_STC_STYLENEEDED` 任务委托给对象。接下来，我们创建了 `VowelLexer` 类，这是一个简单的 `BaseLexer` 子类，它将在文档文本中突出显示元音字母。在
    `StyledTextCtrl` 中应用样式涉及三个基本步骤。首先，你需要调用 `StartStyling` 来指示你希望在缓冲区中开始样式的位置，然后你需要确定要设置的样式字节，最后你需要调用
    `SetStyling` 来设置从起始位置开始应用给定样式的字符数。
- en: Now in order for the `StyledTextCtrl` to make use of these lexers, we needed
    to do a couple things that we have encapsulated in the `CustomSTC` class. The
    `StyledTextCtrl` needs to bind to `EVT_STC_STYLENEEDED` and set the `STC_LEX_CONTAINER`
    lexer. The `StyledTextCtrl` will generate `EVT_STC_STYLEDNEEDED` when the container
    lexer is the current lexer and when it detects that some of the text in the buffer
    may need to be restyled due to changes in its contents. To handle this in our
    `CustomSTC` class, we simply delegate the event to the current lexer object that
    was set by the call to our overridden `SetLexer` method.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为了让 `StyledTextCtrl` 能够使用这些词法分析器，我们需要做一些事情，这些事情我们已经封装在 `CustomSTC` 类中。`StyledTextCtrl`
    需要绑定到 `EVT_STC_STYLENEEDED` 并设置 `STC_LEX_CONTAINER` 词法分析器。当容器词法分析器是当前词法分析器，并且检测到缓冲区中的某些文本可能因为内容的变化需要重新格式化时，`StyledTextCtrl`
    将会生成 `EVT_STC_STYLEDNEEDED` 事件。为了在我们的 `CustomSTC` 类中处理这种情况，我们只需将事件委托给通过我们重写的 `SetLexer`
    方法设置的当前词法分析器对象。
- en: Finally, we have a super-simple sample application that shows how our `CustomSTC`
    and `VowelLexer` can be used in an application. First, we needed to set up the
    styling by calling `SetStyleSpec` to set which colors will be applied for our
    lexer's two-style bytes. The `STC_STYLE_VOWEL_DEFAULT` will be styled with plain
    black text, and `STC_STYLE_VOWEL_KW` will be styled with red text. Then, all is
    left is to call `SetLexer` to set the `STC_LEX_CONTAINER` lexer and create an
    instance of our `VowelLexer` for the control to use. So give it a run and see
    that as you type into the buffer, all vowels should be colored red.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个超级简单的示例应用程序，展示了如何在我们的应用程序中使用`CustomSTC`和`VowelLexer`。首先，我们需要通过调用`SetStyleSpec`来设置样式，指定为我们的词法分析器的两种样式字节应用哪些颜色。`STC_STYLE_VOWEL_DEFAULT`将以纯黑色文本样式显示，而`STC_STYLE_VOWEL_KW`将以红色文本样式显示。然后，剩下的就是调用`SetLexer`来设置`STC_LEX_CONTAINER`词法分析器，并为控件创建一个我们的`VowelLexer`实例。所以运行一下，当你将文本输入到缓冲区时，所有的元音字母都应该被涂成红色。
- en: See also
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *StyledTextCtrl using lexers* recipe in [Chapter 4](ch04.html "Chapter 4. Advanced
    Building Blocks of a User Interface"), *Advanced Building Blocks of a User Interface*
    for another example of using the `StyleTextCtrl`.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第4章](ch04.html "第4章。用户界面的高级构建块")中的*使用lexers的StyledTextCtrl*配方，*用户界面的高级构建块*，以了解使用`StyleTextCtrl`的另一个示例。
- en: Creating a custom control
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义控件
- en: At some point, you may need to invent an entirely new control to fit some specific
    requirement of your application. So in this recipe we will take a look at some
    techniques for creating a new control completely from scratch. We will create
    a custom `CheckBox` control that has its label below the `CheckBox`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，你可能需要发明一个全新的控件来满足你应用程序的一些特定需求。因此，在这个菜谱中，我们将探讨一些从头开始创建新控件的技术。我们将创建一个自定义的`CheckBox`控件，其标签位于`CheckBox`下方。
- en: How to do it...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To get started, we will define the constructor of the `CustomCheckBox` control
    as a subclass of `PyControl`. In the constructor, we bind to a number of events
    that will let us define the behavior of the control:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将定义`CustomCheckBox`控制器的构造函数为`PyControl`的子类。在构造函数中，我们将绑定一系列事件，这将使我们能够定义控制器的行为：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we have this helper method to help manage what state the control is in
    with regards to the mouse:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个辅助方法来帮助管理控制状态与鼠标的关系：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is a virtual override of the `PyControl''s DoGetBestSize` method to control
    what the size of the control is:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对`PyControl`的`DoGetBestSize`方法的虚拟覆盖，用于控制控件的大小：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we focus on the event handlers that will define the behavior of the control.
    First, in `OnPaint`, we do the drawing that gives the control its appearance:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们关注将定义控件行为的处理事件。首先，在`OnPaint`中，我们进行绘制操作，赋予控件外观：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The next two event handlers manage the mouse click state in the control to
    toggle the `CheckBox` state:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 下两个事件处理器管理控件中的鼠标点击状态，以切换`CheckBox`的状态：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Last but not least, we define a couple of methods to implement part of the
    `wx.CheckBox` interface:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们定义了几种方法来实现`wx.CheckBox`接口的一部分：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This was a fairly simple control to implement, but it is a good example of some
    of the approaches to take when creating your own custom control. So let's break
    down each of the important parts and see how they affect the way in which the
    control works.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种相对简单的控制实现，但它是一个很好的例子，展示了在创建自己的自定义控制时可以采取的一些方法。因此，让我们逐一分析每个重要部分，看看它们是如何影响控制工作方式的。
- en: 'First, in the constructor, we define three attributes to manage the state of
    the control:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在构造函数中，我们定义了三个属性来管理控制器的状态：
- en: '`self._hstate:` To hold the current highlight state of the control.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`self._hstate:` 用于存储控制器的当前高亮状态。'
- en: '`self._checked:` To hold the `CheckBox` state.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`self._checked:` 用于保存 `CheckBox` 的状态。'
- en: '`self._ldown:` To hold when the left mouse button was clicked down in the control.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`self._ldown:` 当在控件中点击了左鼠标按钮时保持。'
- en: Next, we `Bind` to the events that are necessary to draw the control and implement
    its behavior. We made use of two paint events and four different mouse events.
    First, let's take a look at the mouse event handlers that are used to implement
    the control's behavior.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要`绑定`到绘制控件和实现其行为所必需的事件。我们使用了两个绘图事件和四个不同的鼠标事件。首先，让我们看看用于实现控件行为的鼠标事件处理器。
- en: In `OnLeftDown`, we simply set our `self._ldown` flag to `True` in order to
    indicate that the down-click action was initiated in this window and not elsewhere.
    Then, in the `OnLeftUp` handler, if the `self._ldown` flag is `True`, we toggle
    the `self._checked` flag to reflect the new `CheckBox` state, and then call `Refresh`.
    Calling `Refresh` will cause an `EVT_PAINT` event to be generated so that we can
    redraw the control in its new state with our `OnPaint` handler. After this, we
    also generate an `EVT_CHECKBOX` event in order to inform the application that
    the `CheckBox` state has changed. The remaining two mouse events are used to update
    the control's highlight state when the mouse enters or leaves the controls area.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `OnLeftDown` 中，我们只需将我们的 `self._ldown` 标志设置为 `True`，以指示下点击动作是在此窗口中而不是在其他地方发起的。然后，在
    `OnLeftUp` 处理程序中，如果 `self._ldown` 标志为 `True`，我们将 `self._checked` 标志切换以反映新的 `CheckBox`
    状态，然后调用 `Refresh`。调用 `Refresh` 将会生成一个 `EVT_PAINT` 事件，这样我们就可以使用我们的 `OnPaint` 处理程序重新绘制控件以反映其新状态。之后，我们还会生成一个
    `EVT_CHECKBOX` 事件，以便通知应用程序 `CheckBox` 状态已更改。剩余的两个鼠标事件用于在鼠标进入或离开控件区域时更新控件的高亮状态。
- en: '`OnPaint` is where we draw the control and give it its appearance. We start
    in `OnPaint` by creating our drawing contexts and setting up the background. Next,
    we calculate the position to draw the `CheckBox` within the control''s rectangle
    and use `RendererNative` to draw the `CheckBox` according to the control''s current
    state. Then, all that is left is to draw the label below the `CheckBox` using
    our `GCDC''s DrawLabel` method.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnPaint` 是我们绘制控件并赋予其外观的地方。我们在 `OnPaint` 中创建绘图上下文并设置背景。接下来，我们计算在控件矩形内绘制 `CheckBox`
    的位置，并使用 `RendererNative` 根据控件的当前状态绘制 `CheckBox`。然后，剩下的就是使用我们的 `GCDC''s DrawLabel`
    方法在 `CheckBox` 下方绘制标签。'
- en: 'To finish off the control, we added some methods to implement part of the regular
    interface for the `CheckBox` so that the application code using this control can
    get and set the `CheckBox` state:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成控制功能，我们添加了一些方法来实现`CheckBox`部分常规界面的功能，以便使用此控件的应用程序代码可以获取和设置`CheckBox`的状态：
- en: '![How it works...](img/1780_10_04.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1780_10_04.jpg)'
- en: See also
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Understanding inheritance limitations* recipe in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with wxPython"), *Getting Started with wxPython* for
    a discussion about overriding virtual methods.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第1章](ch01.html "第1章. wxPython入门")中的*理解继承限制*配方，以了解关于重写虚拟方法的讨论。
- en: See the Understanding event propagation recipe in [Chapter 2](ch02.html "Chapter 2. Responding
    to Events"), *Responding to Events* for more information on working with events.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查阅[第2章](ch02.html "第2章。响应事件")中的“理解事件传播”配方，*响应事件*以获取更多关于处理事件的详细信息。
- en: See the *Drawing with RendererNative* recipe in [Chapter 8](ch08.html "Chapter 8. Drawing
    to the Screen"), *Drawing to the Screen* for another example of using `RendererNative`
    for drawing native-looking controls.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第8章](ch08.html "第8章。屏幕绘图")中的*使用RendererNative进行绘图*配方，*屏幕绘图*部分提供了使用`RendererNative`绘制原生外观控件的其他示例。
- en: See the *Reducing flicker in drawing routines* recipe in [Chapter 8](ch08.html
    "Chapter 8. Drawing to the Screen"), *Drawing to the Screen* for an explanation
    of how to reduce flicker in drawing routines.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第8章](ch08.html "第8章。屏幕绘图")中的*减少绘图过程中的闪烁*配方，*屏幕绘图*章节，以了解如何减少绘图过程中的闪烁。
