- en: Chapter 1. Meet Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the exciting world of GUI programming with Tkinter. This project
    aims at getting you acquainted with Tkinter, the built-in **graphical user interface**
    (**GUI**) interface for all standard Python distributions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tkinter** (pronounced tea-kay-inter) is the Python interface to Tk, the GUI
    toolkit for Tcl/Tk.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tcl** (pronounced "tickle" and is an acronym for **Tool Command Language**)
    is a popular scripting language in the domains of embedded applications, testing,
    prototyping, and GUI development. Tk on the other hand is an open source, multiplatform
    widget toolkit that is used by many different languages for building GUI programs.'
  prefs: []
  type: TYPE_NORMAL
- en: The Tkinter interface is implemented as a Python module, `Tkinter.py`, which
    is just a wrapper around a C-extension that uses Tcl/Tk libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter is suited for application to a wide variety of areas ranging from small
    desktop applications, to use in scientific modeling and research endeavors across
    various disciplines.
  prefs: []
  type: TYPE_NORMAL
- en: We believe that the concepts you will develop here will enable you to apply
    and develop GUI applications in your area of interest. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Mission Briefing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of this project is to make you comfortable with Tkinter. It aims
    at introducing you to various components of GUI programming with Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this project, you will have developed several partly functional
    dummy applications such as the one shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mission Briefing](img/7941_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The applications developed in this project are "dummy applications" because
    they are not fully functional. In fact, the purpose of each small dummy application
    is to introduce you to some specific aspects of programming with Tkinter. This
    will set up the context for developing some fun and fully functional project ideas
    from [Project 2](ch02.html "Chapter 2. Making a Text Editor like Notepad"), *Making
    a Text Editor*, onwards.
  prefs: []
  type: TYPE_NORMAL
- en: Why Is It Awesome?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ability to program a GUI application (as opposed to a simple console application)
    opens a whole world of possibilities for a programmer. It shifts the focus of
    the program from the programmer to the end user, enabling the programmer to reach
    out to a wider audience.
  prefs: []
  type: TYPE_NORMAL
- en: When a person learning Python needs to graduate to GUI programming, Tkinter
    seems to be the easiest and fastest way to get the work done. Tkinter is a great
    tool for programming GUI applications in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'The features that make Tkinter a great choice for GUI programming include:'
  prefs: []
  type: TYPE_NORMAL
- en: It is simple to learn (simpler than any other GUI package for Python)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relatively little code can produce powerful GUI applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layered design ensures that it is easy to grasp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is portable across all operating systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easily accessible as it comes pre-installed with standard Python distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None of the other GUI toolkits has all of these features at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Your Hotshot Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key concepts that we want you to take from this project include:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the concept of root window and main loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding widgets—the building blocks for your programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acquainting yourself with a list of available widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Developing layouts using three geometry managers: pack, grid, and place'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning to apply events and callbacks to make your program functional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling your widgets with styling options and configuring the root widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mission Checklist
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An elementary knowledge of data structures, syntax, and semantics of Python
    is assumed. To work along with this project, you must have a working copy of Python
    2.7.3 installed on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: The Python download package and instructions for downloading for different platforms
    are available at [http://www.Python.org/getit/releases/2.7.3/](http://www.Python.org/getit/releases/2.7.3/).
  prefs: []
  type: TYPE_NORMAL
- en: We will develop our application on the Windows 7 platform. However, since Tkinter
    is truly cross-platform, you can follow along on Mac or Linux distributions without
    any modifications to our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the installation, open the IDLE window and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you have installed Python 2.7, this shell command should execute without
    any errors.
  prefs: []
  type: TYPE_NORMAL
- en: If there are no error messages the Tkinter module is installed in your Python
    distribution. When working with examples from this book, we do not support any
    other Python version except for Python 2.7, which comes bundled with Tkinter Tcl/Tk
    Version 8.5.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test if you have the correct Tkinter version on your Python installation,
    type the following commands in your IDLE or interactive shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This should pop up a window where the first line in the window reads **This
    is Tcl/Tk version 8.5**. Make sure it is not 8.4 or any earlier version, as Version
    8.5 is a vast improvement over its previous versions.
  prefs: []
  type: TYPE_NORMAL
- en: You are ready to code your Tkinter GUI applications if your version test confirms
    it as Tcl/Tk version 8.5\. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: The root window – your drawing board
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GUI programming is an art, and like all art, you need a drawing board to capture
    your ideas. The drawing board you will use is called the **root window**. Our
    first goal is to get the root window ready.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following screenshot depicts the root window we are going to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Engage Thrusters](img/7941_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Drawing the root window is easy. You just need the following three lines of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Save this with the `.py` file extension or check out the code `1.01.py`. Open
    it in the IDLE window and run the program from the **Run** menu (*F5* in IDLE).
    Running this program should generate a blank root window as shown in the preceding
    screenshot. This window is furnished with functional minimize, maximize, and close
    buttons, and a blank frame.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The description of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line imports all (`*`) classes, attributes, and methods of Tkinter
    into the current workspace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second line creates an instance of the class `Tkinter.Tk`. This creates
    what is called the "root" window that you see in the screenshot provided. By convention,
    the root window in Tkinter is usually called "root", but you are free to call
    it by any other name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third line executes the `mainloop` (that is, the event loop) method of the
    `root` object. The `mainloop` method is what keeps the root window visible. If
    you remove the third line, the window created in line 2 will disappear immediately
    as the script stops running. This will happen so fast that you will not even see
    the window appearing on your screen. Keeping the mainloop running also lets you
    keep the program running until you press the close button, which exits the main
    loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Congratulations! You have completed your first objective, which was to draw
    the root window. You have now prepared your drawing canvas (root window). Now
    get ready to paint it with your imagination!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Commit the three lines of code (shown in *code 1.01.py*) to memory. These three
    lines generate your root window, which will accommodate all other graphical components.
    These lines constitute the skeleton of any GUI application that you will develop
    in Tkinter. All code that will make your GUI application functional will go between
    line 2 (new object creation) and line 3 (`mainloop`) of this code.
  prefs: []
  type: TYPE_NORMAL
- en: Classified Intel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section describes the different styles of importing Tkinter modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we imported Tkinter using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This method of import eases the handling of methods defined in the module. That
    is to say, you can simply access the methods directly. Generally, it is considered
    a bad practice to import all (`*`) methods of a module like we did here. This
    is because if you import all methods from some other module with a common method
    name, it would lead to the overwriting of methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to import Tkinter in which this overlapping can be avoided,
    a common one being:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This style of importing does not pollute the namespace with a list of all methods
    defined within Tkinter. However, every method within Tkinter will now have to
    be called using the format `Tkinter.methodA` instead of directly calling the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another commonly used import style is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here too, you do not pollute the current namespace with all Tkinter methods
    and now you can access methods such as `Tk.methodA`. "Tk" is a convenient, easy-to-type
    alias commonly used by many developers for importing Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: The big picture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a GUI programmer, you will generally be responsible for deciding three aspects
    of your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**What components should appear on screen?**: This involves choosing the components
    that make the user interface. Typical components include things such as buttons,
    entry fields, checkboxes, radio buttons, scroll bars, and the like. In Tkinter,
    the components that you add to your GUI are called widgets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Where should the components go?**: This involves deciding the positioning
    or placement of each component in the overall design structure. This includes
    decisions to be made on issues of positioning and the structural layout of various
    components. In Tkinter, this is referred to as **geometry management**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How do components interact and behave?**: This involves adding functionality
    to each component. Each component or widget does some work. For example, a button,
    when clicked on, does something in response; a scrollbar handles scrolling; and
    checkboxes and radio buttons enable the user to make some choices. In Tkinter,
    the functionality of various widgets is managed by `command` binding or `event`
    binding using **callback functions**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us delve deeper into each of these three components in the context of Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: Widgets – building blocks for your GUI program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our Toplevel window ready, it is time to think over the question,
    what components should appear in the window? In Tkinter jargon, these components
    are called **widgets** .
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax for adding a widget is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the following example (refer to the code `01.02.py`), we add two widgets,
    a label and a button, to the root frame. Notice how all widgets are added in between
    the skeleton code we defined in the first example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: This code adds a new instance, `mylabel`, for the **Label** widget. The first
    parameter defines `root` as its parent or container. The second parameter configures
    its text option as `"I am a label widget"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We similarly define an instance of a **Button** widget. This is also bound to
    the root window as its parent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `pack()` method, which is essentially required to position the label
    and button widgets within the window. We will discuss the `pack()` method and
    several other related concepts under the Geometry management task. However, you
    must note that some sort of geometry specification is essential for the widgets
    to display within the Toplevel window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running this code will generate a window as shown in the following screenshot.
    It will have a custom label and a custom button:![Engage Thrusters](img/7941_01_03.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this iteration, we have learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What widgets are.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How widgets are instantiated and displayed within a container window frame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set options for the widgets at the time of instantiation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of specifying a geometry option such as `pack()` to display a
    widget. We will discuss more about this in a subsequent task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classified Intel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All widgets are actually objects derived from their respective **widget class**.
    So, a statement such as `mybutton = Button(myContainer)`, actually creates the
    button instance from the `Button` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each widget has a set of options that decides its behavior and appearance. This
    includes attributes such as text labels, colors, font size, and many more. For
    example, the Button widget has attributes to manage its label, control its size,
    change its foreground and background colors, change the size of the border, and
    so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To set these attributes, you can set the values directly at the time of creation
    of the widget as we have done in the preceding example. Alternatively, you can
    later set or change the options of the widget by using the `.config()` or `.configure()`
    method. Note that the `.config()` or `.configure()` method are interchangeable
    and provide the same functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also add the `pack()` method on the same line in which you create a
    new instance of the widget. For example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are instantiating the widget directly, you can write both the lines
    together as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You may keep a reference to the widget created (as in the first example, `mylabel`)
    or you can create a widget without keeping any reference to it (as in the second
    example).
  prefs: []
  type: TYPE_NORMAL
- en: You should ideally keep the reference if the widget content is likely to be
    modified by some action at a later stage in the program. If the widget state is
    to remain static after its creation, you need not keep a reference for the widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note that calls to `pack()` (or other geometry managers) always returns
    `None`. So, consider you create a widget keeping a reference to it and add the
    geometry manager (say `pack()`) on the same line as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you are actually not creating a reference to the widget but instead
    creating a `None` type object for the variable `mylabel`.
  prefs: []
  type: TYPE_NORMAL
- en: So, when you later try to modify the widget through the reference, you get an
    error as you are actually trying to work on a `None` type object.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the most common errors committed by beginners.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know core Tkinter widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this iteration, we will get to know all core Tkinter widgets. We have already
    seen two of them in the previous example—the Label and Button widgets. Let's now
    see all other core Tkinter widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tkinter includes 21 core widgets. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Toplevel widget | Label widget | Button widget |'
  prefs: []
  type: TYPE_TB
- en: '| Canvas widget | Checkbutton widget | Entry widget |'
  prefs: []
  type: TYPE_TB
- en: '| Frame widget | LabelFrame widget | Listbox widget |'
  prefs: []
  type: TYPE_TB
- en: '| Menu widget | Menubutton widget | Message widget |'
  prefs: []
  type: TYPE_TB
- en: '| OptionMenu widget | PanedWindow widget | Radiobutton widget |'
  prefs: []
  type: TYPE_TB
- en: '| Scale widget | Scrollbar widget | Spinbox widget |'
  prefs: []
  type: TYPE_TB
- en: '| Text widget | Bitmap Class widget | Image Class widget |'
  prefs: []
  type: TYPE_TB
- en: Let's write a program to include these widgets on our root window.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The format for adding widgets is the same as we discussed in the previous task.
    To give you a flavor, here''s some sample code for adding some common widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Can you spot the pattern common to each widget? Can you spot the differences?
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, the syntax for adding a widget is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The method for creating all the previously mentioned widgets is the same. Most
    of the configuration options will also be similar. However, a few configuration
    options vary from widget to widget.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the Button and Label widgets will have an option to configure their
    text, but scrollbars do not have a text-configuration option.
  prefs: []
  type: TYPE_NORMAL
- en: Using the same pattern, let's now add all the 21 core Tkinter widgets into a
    dummy application (code `01.03.py`).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Do not be intimidated by the size of the program. Instead look for a common
    pattern that is used to initialize and display all the widgets. To reiterate,
    the syntax for adding a widget is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the configuration options for each widget differ slightly from each
    other depending on the type of widget being initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the code `1.03.py` for a demo of all Tkinter widgets. A summarized
    code description for `1.03.py` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a Toplevel window and create a main loop as seen in the earlier examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We add a Frame widget that we named `menubar`. Note that Frame widgets are
    just holder widgets that hold other widgets. Frame widgets are great for grouping
    widgets together. The syntax for adding a frame is the same as that of all other
    widgets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Keeping the `menubar` frame as the container, we add two widgets to it, the
    Menubutton and Menu widgets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We create another frame and name it `myframe1`. Keeping `myframe1` as the container/parent
    widget, we add seven widgets to it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Label, Entry, Button, Checkbutton, Radiobutton, OptionMenu, and Bitmap Class
    widgets.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We then proceed to create `myframe2`, another Frame widget. We add six more
    widgets to it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Image Class, Listbox, Spinbox, Scale, LabelFrame, and Message widgets.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We then create `myframe3`, another Frame widget. We add two more widgets to
    it, the Text and Scrollbar widgets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally we create the last frame, `myframe4`, another Frame widget. We add two
    more widgets to it, the Canvas and PanedWindow widgets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these widgets constitute the 21 core widgets of Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Read through the code explanation, and find the corresponding piece of code
    in the example code `01.03.py`. Look at how each widget is created. Try to identify
    each widget's class name as used in Tkinter. Look what remains the same in all
    widgets, and what changes between one widget and another?
  prefs: []
  type: TYPE_NORMAL
- en: A few minutes spent reading and understanding the code in `1.03.py` will really
    help you appreciate the simplicity and overall structure of a Tkinter program.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, note that we have used `.pack()` on each widget to display it inside
    its container frame. We discuss `.pack()` in the next task. However, for now just
    note that we have used something called `pack()`, without which the widgets would
    not have displayed at all.
  prefs: []
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have reached a major milestone in your GUI programming effort.
  prefs: []
  type: TYPE_NORMAL
- en: You now know all the 21 core widgets of Tkinter. You can identify them by their
    class names, and you can create them on a root frame or on a subframe within the
    root. You now know how to configure options of widgets.
  prefs: []
  type: TYPE_NORMAL
- en: With this you have now seen the first and the most important building block
    of a Tkinter program. You have mastered Tkinter widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Classified Intel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Widget options can be set at instantiation time as we have done in the examples
    so far. Alternatively, the options can be configured after instantiation using
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is a very handy tool that lets you change widget options dynamically after
    the widget has been created. We will be using this very often in all our projects.
  prefs: []
  type: TYPE_NORMAL
- en: For common widget configuration options, refer to the *Options common to widgets*
    section in [Appendix B](apb.html "Appendix B. Quick Reference Sheets"), *Quick
    Reference Sheets*.
  prefs: []
  type: TYPE_NORMAL
- en: Geometry management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having seen all the core Tkinter widgets, let us now turn our attention to the
    second component of GUI programming—the question of where to place those widgets.
  prefs: []
  type: TYPE_NORMAL
- en: This is taken care of by the geometry manager options of Tkinter. This component
    of GUI programming involves deciding the position of the widget, overall layout,
    and relative placement of various widgets on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall that we used the `pack()` method for adding widgets to the dummy application
    we developed in the previous section. `pack()` is an example of geometry management
    in Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: '`pack()` is not the only way you can manage the geometry in your interface.
    In fact, there are three geometry managers in Tkinter that let you specify the
    position of widgets inside a Toplevel or parent window.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The geometry managers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pack`: This is the one we have used so far. Simple to use for simpler layouts
    but may get very complex for slightly complex layouts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grid`: This is the most commonly used geometry manager that provides a table-like
    layout of management features for easy layout management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`place`: This is least popular, but provides the best control for absolute
    positioning of widgets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us now see examples of all three geometry managers in action.
  prefs: []
  type: TYPE_NORMAL
- en: The pack geometry manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `pack` geometry derives its name from the fact that it literally packs widgets
    on a first-come-first-serve basis in the space available in the master frame in
    which widgets are pushed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pack` geometry manager fits "slave widgets" into "parent spaces". When
    packing the slave widgets, the `pack` manager distinguishes between three kinds
    of spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: The unclaimed space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The claimed but unused space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The claimed and used space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most commonly used options in `pack()` include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`side`: `LEFT`, `TOP`, `RIGHT`, and `BOTTOM` (these decide the alignment of
    the widget)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fill`: `X`, `Y`, `BOTH`, and `NONE` (these decide whether the widget can grow
    in size)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expand` :`1`/`0` or `Yes`/`No` (corresponding to values respectively)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`anchor`: `NW`, `N`, `NE`, `E`, `SE`, `S`, `SW`, `W`, and `CENTER` (corresponding
    to the cardinal directions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal padding (`ipadx` and `ipady`) and external padding (`padx` and `pady`),
    which all defaulted to a value of zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at some demo code that illustrates some of the `pack` features.
    Here''s the code snippet (code `1.04.py`) that generates a GUI like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The pack geometry manager](img/7941_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When you insert button **A** in the `root` frame, it captures the left-most
    area of the frame, it expands, and fills the *Y* dimension. Because expand and
    fill options are specified in affirmative, it claims all the area it wants and
    fills the *Y* dimension. If you increase the size of the root window pulling it
    down, you will notice that the button **A** expands in the downward direction
    (along the *Y* coordinate) but a side-wise increase in the window does not result
    in a horizontal increase in the size of button **A**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you insert the next button, **B**, into the root window, it picks up space
    from the remaining area but aligns itself to `TOP`, expand-fills the available
    area, and fills both *X* and *Y* coordinates of the available space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third button, **C**, adjusts to the right-hand side of the remaining space.
    But because fill is specified as `NONE`, it takes up only that much space as is
    required to accommodate the text inside the button. If you expand the root window,
    the button **C** will not change its size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `anchor` attribute used in some lines provides a means to position a widget
    relative to a reference point. If the `anchor` attribute is not specified, the
    `pack` manager places the widget in the center of the available space or the **packing
    box**. Other allowed options include the four cardinal directions (`N`, `S`, `E`,
    and `W`) and a combination of any two directions. Therefore, valid values for
    the `anchor` attribute are: `CENTER` (default), `N`, `S`, `E`, `W`, `NW`, `NE`,
    `SW`, and `SE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The description for the rest of the lines is left as an exercise for you to
    explore. The best way to study this piece of code would be to comment out all
    lines of code and introduce each successive button one after another. At each
    step, try to resize the window to see the effect it has on various buttons.
  prefs: []
  type: TYPE_NORMAL
- en: '![The pack geometry manager](img/7941_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will use the `pack` geometry manager in some of our projects, so it would
    be a worthwhile exercise to get acquainted with `pack` and its options.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the value for most of the Tkinter geometry manager attributes can
    either be specified in capital letters without quotes (like `side=TOP`, `anchor=SE`)
    or in small letters but within quotes (like `side='top'`, `anchor='se'`).
  prefs: []
  type: TYPE_NORMAL
- en: For a complete `pack` manager reference refer to the *The pack manager* section
    in [Appendix B](apb.html "Appendix B. Quick Reference Sheets"), *Quick Reference
    Sheets*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Where should you use the pack() geometry manager?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `pack` manager is somewhat complicated compared to the `grid` method
    that we will discuss next, but it is a great choice in situations such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Having a widget fill the complete container frame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placing several widgets on top of each other or in a side by side position (as
    in the previous screenshot). See code `1.05.py`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While you can create complicated layouts by nesting widgets in multiple frames,
    you can find the `grid` geometry manager more suitable for most of the complex
    layouts.
  prefs: []
  type: TYPE_NORMAL
- en: The grid geometry manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `grid` geometry manager is most easy to understand and, perhaps, the most
    useful geometry manager in Tkinter. The central idea of the `grid` geometry manager
    is to divide the container frame into a two-dimensional table divided into a number
    of rows and columns. Each cell in the table can then be targeted to hold a widget.
    In this context, a **cell** is an intersection of imaginary rows and columns.
    Note that in the `grid` method, each cell can hold only one widget. However, widgets
    can be made to span multiple cells.
  prefs: []
  type: TYPE_NORMAL
- en: Within each cell you can further align the position of the widget using the
    `STICKY` option. The `sticky` option decides how the widget is expanded, if its
    container cell is larger than the size of the widget it contains. The `sticky`
    option can be specified using one or more of the `N`, `S`, `E`, and `W`, or `NW`,
    `NE`, `SW`, and `SE` options.
  prefs: []
  type: TYPE_NORMAL
- en: Not specifying stickiness defaults to stickiness to the center of the widget
    in the cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now see a demo code that illustrates some of the features of the `grid`
    geometry manager. The code in `1.06.py` generates a GUI-like figure as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The grid geometry manager](img/7941_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the grid position defined in terms of rows and column positions
    for an imaginary grid table spanning the entire frame. See how the use of `sticky=W`
    on both labels makes them stick to the west or left-hand side, resulting in a
    clean layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The width of each column (or height of each row) is automatically decided by
    the height or width of the widgets contained in the cell. Therefore, you need
    not worry about specifying the row or column width as equal. You may specify the
    width for widgets, if you need that extra bit of control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the argument `sticky=N+S+E+W` to make the widget expandable to fill
    the entire cell of the grid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a more complex scenario, your widgets may span across multiple cells in the
    grid. To enable a grid to span multiple cells, the `grid` method offers very handy
    options such as `rowspan` and `columnspan`.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, you may often need to provide some padding between cells in the
    grid. The `grid` manager provides `padx` and `pady` options to provide padding
    to place around the widget in a cell.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, there are `ipadx` and `ipady` options for internal padding. The default
    value of external and internal padding is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see an example of the `grid` manager, where we use most of the common
    arguments to the `grid` method such as `row`, `column`, `padx`, `pady`, `rowspan`,
    and `columnspan` in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code `1.08.py` is a demonstration of `grid()` geometry manager options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how just 14 lines of core `grid` manager code generates a complex layout
    such as the one shown in the following screenshot. In contrast, developing this
    with the `pack` manager would have been much more tedious:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The grid geometry manager](img/7941_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Another `grid` option that you can sometimes use is the `widget.grid_forget()`
    method. This method can be used to hide the widget from the screen. When you use
    this option, the widget exists in its place but becomes invisible. The hidden
    widget may be made visible again but any `grid` options that you had originally
    assigned to the widget will be lost.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, there is a `widget.grid_remove()` method that removes the widget,
    except that in this case when you make the widget visible again, all its `grid`
    options will be restored.
  prefs: []
  type: TYPE_NORMAL
- en: For a complete `grid()` reference, refer to the the *The grid manager* section
    in [Appendix B](apb.html "Appendix B. Quick Reference Sheets"), *Quick Reference
    Sheets*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Where should you use the grid() geometry manager?**'
  prefs: []
  type: TYPE_NORMAL
- en: The `grid` manager is a great tool for developing complex layouts. Complex structures
    can be easily achieved by breaking the container widget into grids of rows and
    columns and then placing the widgets in grids where they are wanted.
  prefs: []
  type: TYPE_NORMAL
- en: It is also commonly used in developing different kinds of dialog boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will delve into configuring grid column and row sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Different widgets have different heights and widths. So when you specify the
    position of a widget in terms of rows and columns, the cell automatically expands
    to accommodate the widget.
  prefs: []
  type: TYPE_NORMAL
- en: Normally the height of all grid rows is automatically adjusted to be the height
    of its tallest cell. Similarly, the width of all grid columns is adjusted to be
    equal to the width of the widest widget cell.
  prefs: []
  type: TYPE_NORMAL
- en: If you then want a smaller widget to fill a larger cell or to stay at any one
    side of the cell, you use the `sticky` attribute on the widget to control that.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can, however, override this automatic sizing of columns and rows using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Use these to configure the options for a given widget, `w`, in the column, `n`,
    specifying values for the options, `minsize`, `pad`, and `weight`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options available here are as mentioned in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Options | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `minsize` | The minimum size of column or row in pixels. If there is no widget
    in the given column or row, the cell does not appear despite this `minsize` specification.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pad` | External padding in pixels that will be added to the specified column
    or row over the size of largest cell. |'
  prefs: []
  type: TYPE_TB
- en: '| `weight` | This specifies the relative weight of the row or column, then
    distributes the extra space. This enables making the row or column stretchable.For
    example, the following code distributes two-fifths of the extra space to the first
    column and three-fifths to the second column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The `columnconfigure()` and `rowconfigure()` methods are often used to implement
    dynamic resizing of widgets, especially on resizing the root window.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You cannot use `grid` and `pack` methods together in the same container window.
    If you try doing that, your program will enter into an infinite negotiation loop.
  prefs: []
  type: TYPE_NORMAL
- en: The place geometry manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `place` geometry manager is the most rarely used geometry manager in Tkinter.
    Nevertheless, it has its uses in that it lets you precisely position widgets within
    its parent frame using the *X*-*Y* coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: The `place` manager can be assessed using the `place()` method on all standard
    widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The important options for `place` geometry include:'
  prefs: []
  type: TYPE_NORMAL
- en: Absolute positioning (specified in terms of `x=N` or `y=N`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relative positioning (key options include `relx`, `rely`, `relwidth`, and `relheight`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other options commonly used with `place()` include `width` and `anchor` (the
    default is `NW`). Refer to the code in `1.09.py` for a demonstration of the common
    `place` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You may not see much of a difference between absolute and relative positions
    simply by looking at the code or the window frame. If, however, you try resizing
    the window, you will notice that the button placed absolutely does not change
    its coordinates, while the relative button changes its coordinates and size to
    fit the new size of the root window.
  prefs: []
  type: TYPE_NORMAL
- en: '![The place geometry manager](img/7941_01_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For a complete `place()` reference, check out the *The place manager* section
    in [Appendix B](apb.html "Appendix B. Quick Reference Sheets"), *Quick Reference
    Sheets*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**When should you use the place manager?**'
  prefs: []
  type: TYPE_NORMAL
- en: The `place` manager is useful in situations where you have to implement the
    custom geometry managers where the widget placement is decided by the end user.
  prefs: []
  type: TYPE_NORMAL
- en: While `pack()` and `grid()` managers cannot be used together in the same frame,
    the `place()` manager can be used with any other geometry manager within the same
    container frame.
  prefs: []
  type: TYPE_NORMAL
- en: The `place` manager is rarely used. This is because if you use it you have to
    worry about the exact coordinates. If say you make a minor change for one widget,
    it is very likely that you will have to change the *X*-*Y* values for other widgets
    as well, which can be very cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: We will not use the `place` manager in our projects. However, knowing that options
    for coordinate-based placement exist can be helpful in certain situations.
  prefs: []
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This concludes our discussion on geometry management in Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: In this section you implemented examples of `pack`, `grid`, and `place` geometry
    managers. You also understood the strength and weaknesses of each geometry manager.
  prefs: []
  type: TYPE_NORMAL
- en: You learned that `pack` is best for a simple side-wise or top-down widget placement.
    You also saw that the `grid` manager is best suited for handling complex layouts.
    You saw examples of the `place` geometry manager and the reasons why it is rarely
    used.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be in a position to plan and execute different layouts for your
    programs using these geometry managers of Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: Events and callbacks – adding life to programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have learned how to add widgets to our screen and how to position
    them where we want, let's turn our attention to the third component of GUI programming.
    This addresses the question of how to make the widgets functional.
  prefs: []
  type: TYPE_NORMAL
- en: Making the widgets functional involves making them responsive to events such
    as the pressing of buttons, the pressing keys on keyboards, mouse clicks, and
    the like. This requires associating callbacks to specific events.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Callbacks are normally associated with specific widget events using the `command`
    binding the rules, which is elaborated on in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Command binding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest way to add functionality to a button is called `command` binding,
    whereby the callback function is mentioned in the form of `command = some_callback`
    in the widget option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that `my_callback` is called without parentheses `()` from within the widget
    `command` option. This is because when the callback functions are set, it is necessary
    to pass a reference to a function rather than actually calling it.
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments to the callback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the callback does not take any argument, it can be handled with a simple
    function like the one we just used. However, if the callback needs to take some
    arguments, we can use the `lambda` function as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Python borrows syntax from a functional program called the `lambda` function.
    The `lambda` function lets you define a single-line, nameless function on the
    fly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format for using `lambda` is `lambda arg: #do something with arg in a single
    line`, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that the `command` option available with the Button widget is really
    an alternative function to ease programming the Button event. Many other widgets
    do not provide any equivalent `command` binding option.
  prefs: []
  type: TYPE_NORMAL
- en: The command button binds by default to the left mouse click and the Space bar.
    It does not bind to the Return key. Therefore, if you bind a button using the
    `command` function, it will react to the Space bar and not the Return key. This
    is counter-intuitive to many Windows users. What's worse is you cannot change
    this binding of the `command` function. The moral is that `command` binding, though
    a very handy tool, does not provide you the the independence to decide your own
    bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Event binding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fortunately, Tkinter provides an alternative form of event binding mechanism
    called `bind()` to let you deal with different events. The standard syntax for
    binding an event is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When an event corresponding to the event description occurs in the widget, it
    calls the associated handle passing an instance of the event object as the argument,
    with the event details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at an example of the `bind()` method (refer to the code file `1.10.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We bind the Frame widget to the event, `<Button-1>`, which corresponds to left-click
    of the mouse. On the occurrence of this event, it calls the function `mycallback`,
    passing along an object instance as its argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We define the function `mycallback(event)`. Notice that it takes the event object
    generated by the event as the argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We inspect the event object using `dir(event)`, which returns a sorted list
    of attribute names for the event object passed to it. This prints the list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[''__doc__'', ''__module__'', ''char'', ''delta'', ''height'', ''keycode'',
    ''keysym'', ''keysym_num'', ''num'', ''send_event'', ''serial'', ''state'', ''time'',
    ''type'', ''widget'', ''width'', ''x'', ''x_root'', ''y'', ''y_root'']`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Out of the attributes list generated by the object, we use two attributes, `event.x`
    and `event.y`, to print the coordinates of the point of click.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you run this code, it produces a window like the one shown. When you left-click
    anywhere in the frame, it outputs messages to the console. A sample message passed
    to the console is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Event binding](img/7941_01_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Event pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous example, you saw how we used the event `<Button-1>` to denote
    the left-click of a mouse. This is a built-in pattern in Tkinter that maps it
    to the mouse's left-click event. Tkinter has an exhaustive mapping scheme that
    exactly identifies events such as this one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples to give you an idea of event patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Event pattern | Associated Event |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `<Button-1>` | Left-click of the mouse button |'
  prefs: []
  type: TYPE_TB
- en: '| `<KeyPress-B>` | Keyboard press of the key *B* |'
  prefs: []
  type: TYPE_TB
- en: '| `<Alt-Control-KeyPress- KP_Delete>` | Keyboard press of *Alt* + *Ctrl* +
    *Delete* |'
  prefs: []
  type: TYPE_TB
- en: 'In general, the mapping pattern takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Typically an event pattern will comprise of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**An event type** (required): Some common event types include `Button`, `ButtonRelease`,
    `KeyRelease`, `Keypress`, `FocusIn`, `FocusOut`, `Leave` (mouse leaves the widget),
    and `MouseWheel`. For a complete list of event types, refer to the *The event
    types* section in [Appendix B](apb.html "Appendix B. Quick Reference Sheets"),
    *Quick Reference Sheets*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An event modifier** (optional): Some common event modifiers include `Alt`,
    `Any` (used like in `<Any-KeyPress>`), `Control`, `Double` (used like in `<Double-Button-1>`
    to denote a double-click of the left mouse button), `Lock`, and `Shift`. For a
    complete list of event modifiers, refer to the *The event modifiers* section in
    [Appendix B](apb.html "Appendix B. Quick Reference Sheets"), *Quick Reference
    Sheets*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The event detail** (optional): The mouse event detail is captured by number
    `1` for a left-click and number `2` for a right-click. Similarly, each keyboard
    keypress is either represented by the key letter itself (say *B* in `<KeyPress-B>`)
    or using a key symbol abbreviated as **keysym**. For example, the up arrow key
    on the keyboard is represented by the `keysym` value of `KP_Up`. For a complete
    `keysym` mapping, refer to the *The event details* section in [Appendix B](apb.html
    "Appendix B. Quick Reference Sheets"), *Quick Reference Sheets*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Event pattern](img/7941_01_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at a practical example of the `event` binding on widgets.
    (See the code in `1.11.py` for the complete working example). The following is
    a modified snippet of code to give you a flavor of the commonly used the `event`
    bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Rather than binding an event to a particular widget, you can also bind it to
    the Toplevel window. The syntax remains the same except that now you call it on
    the root instance of the root window like `root.bind()`.
  prefs: []
  type: TYPE_NORMAL
- en: Levels of binding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, you saw how to bind an event to an instance of a widget.
    This can be called **instance level binding**.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there might be times when you need to bind events to the entire application.
    At other times you may want to bind the event to a particular class of widget.
    Tkinter provides different levels of binding options for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**An application-level binding**: Application-level bindings will let you use
    the same binding across all windows and widgets of the application, as long as
    any one window of the application is in focus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The syntax for application-level bindings is:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The typical usage pattern is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: An application-level binding here means that no matter what widget is under
    the current focus, a press of the *F1* key will always trigger the `show_help`
    callback as long as the application is under active focus.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**A class-level binding**: You can also bind events at a particular class level.
    This is normally used to set the same behavior of all instances of a particular
    widget class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This syntax for class level binding is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The typical usage pattern is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, all entry widgets will be bound to the `<Control-V>`
    event that would call a method called `'paste (event)'`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Event propagation**'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the keyboard events and mouse events occur at the operating system level.
    It propagates from the source of the event, hierarchically up, until it finds
    a window that has a corresponding binding. The event propagation does not stop
    there. It propagates itself upwards looking for other bindings from other widgets
    until it reaches the root window. If it does reach the root window and no bindings
    are discovered by it, the event is disregarded.
  prefs: []
  type: TYPE_NORMAL
- en: Handling widget-specific variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You need variables with a wide variety of widgets. You likely need a string
    variable to track what the user enters into the entry widget or text widget. You
    most probably need Boolean variables to track whether the user has checked the
    Checkbox widget. You need integer variables to track the value entered in a Spinbox
    or Slider widget.
  prefs: []
  type: TYPE_NORMAL
- en: In order to respond to changes in widget-specific variables, Tkinter offers
    its own variable class. The variable that you use to track widget-specific values
    must be subclassed from this Tkinter variable class. Tkinter offers some commonly
    used predefined variables. They are `StringVar`, `IntVar`, `BooleanVar`, and `DoubleVar`.
  prefs: []
  type: TYPE_NORMAL
- en: You can use these variables to capture and play with changes in the value of
    variables from within your callback functions. You can also define your own variable
    type, if required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a Tkinter variable is simple. You simply call the required constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the variable is created, you can use it as a widget option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, Tkinter provides access to the value of variables using `set()`
    and `get()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'A demonstration of the Tkinter variable class is available in the code file
    `1.12.py`. The code generates a window like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling widget-specific variables](img/7941_01_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this lesson, you learned:'
  prefs: []
  type: TYPE_NORMAL
- en: The `command` binding to bind simple widgets to certain functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of the `lambda` function, if you need to process arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `event` binding using the `widget.bind(event, callback)` method to bind
    keyboard and mouse events to your widgets and to invoke callbacks on the occurrence
    of some events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to pass extra arguments to a callback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to bind events to an entire application or to a particular class of widget
    using `bind_all()` and `bind_class()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Tkinter variable class to set and get values of widget specific
    variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short you now know how to make your GUI program functional!
  prefs: []
  type: TYPE_NORMAL
- en: Classified Intel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the `bind` method we previously saw, you might find these two
    event-related options useful in certain cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '`unbind`: Tkinter provides the `unbind` options to undo the effect of an earlier
    binding. The syntax is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following are some examples of its usage:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Virtual events**: Tkinter also lets you create your own events. You can give
    these virtual events any name you want.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, imagine you want to create a new event called `<<commit>>`, which
    is triggered by the *F9* key. To create this virtual event on a given widget,
    use the syntax:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can then bind `<<commit>>` to any callback using a normal `bind()` method
    like:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Other event-related methods are listed in the *Other event-related methods*
    section in [Appendix B](apb.html "Appendix B. Quick Reference Sheets"), *Quick
    Reference Sheets*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are ready to dive into real application development with Tkinter,
    let's spend some time exploring a few custom styling options that Tkinter offers.
    We will also see some of the configuration options commonly used with the root
    window.
  prefs: []
  type: TYPE_NORMAL
- en: Doing it in style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have have relied on Tkinter to provide specific platform-based styling
    for our widgets. However, you can specify your own styling of widgets in terms
    of their color, font size, border width, and relief. A brief introduction of styling
    features available in Tkinter is covered in the following task.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall that we could specify widget options at the time of its instantiation
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you could specify widget options using `configure ()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Styling options are also specified as options to the widgets, either at the
    time of instantiation or later using the configure option.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Under the purview of styling, we will cover how to apply different colors, fonts,
    border width, relief, cursor, and bitmap icons to our widgets. We will also look
    at some of the root configurations later in the section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first see how to specify color options for a widget. You can specify
    two types of color for most of the widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: Background color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foreground color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can specify the color using hexadecimal color codes using the proportion
    of red, green, and blue. Commonly used representations are `#rgb` (4 bits), `#rrggbb`
    (8 bits), and `#rrrgggbbb` (12 bits).
  prefs: []
  type: TYPE_NORMAL
- en: For example, `#fff` is white, `#000000` is black, and `#fff000000` is red.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, Tkinter provides mapping for standard color names. For a list
    of predefined colors, open the program titled `pynche` in the `Tools` folder within
    your Python installation directory (in my case, `C:\Python27\Tools\pynche`). Within
    the program click on **View** | **Color list Window**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the easiest and the most common way to specify a font is to represent
    it as a tuple. The standard representation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples to illustrate the method for specifying fonts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you set a Tkinter dimension in a plain integer, the measurements takes place
    in units of pixel. Alternatively, Tkinter accepts four other measurement units
    which are: m (millimeters), c (centimeters), i (inches), and p (printer''s points,
    which is about 1/72").'
  prefs: []
  type: TYPE_NORMAL
- en: 'The default border width for most Tkinter widgets is 2 pixels. You can change
    the border width of the widgets by specifying it explicitly, as shown in the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The relief style of a widget refers to the difference between the highest and
    lowest elevations in a widget. Tkinter offers five possible relief styles: `flat`,
    `raised`, `sunken`, `groove`, and `ridge`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Tkinter lets you change the style of mouse cursor when you hover over a particular
    widget. This is done using the option cursor as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: For a complete list of available cursors, refer to the *List of available cursors*
    section in [Appendix B](apb.html "Appendix B. Quick Reference Sheets"), *Quick
    Reference Sheets*.
  prefs: []
  type: TYPE_NORMAL
- en: 'While you can specify styling options at each widget level, sometimes it may
    be cumbersome to do so individually for each widget. Widget-specific styling has
    several disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It mixes logic and presentation into one file making the code bulky and difficult
    to manage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any change in styling is to be applied to each widget individually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It violates the **don't repeat yourself** (**DRY**) principle of effective coding
    as you keep specifying the same style for a large number of widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fortunately, Tkinter now offers a way to separate presentation from the logic
    and to specify styles in what is called the external "option database". This is
    nothing but a text file where you can specify the common styling options.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical option database text file may look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The asterisk (`*`) symbol here means that the particular style applies to all
    instances of the given widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'These entries are placed in an external text `(.txt)` file. To apply this styling
    to a particular piece of code, you simply call it using the `option_readfile()`
    call early in your code, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we are done discussing styling options, let us wrap up with a discussion
    on some commonly used options for the root window:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '| Specifying the title for the Title bar |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '| You can specify the size and location of a root window using a string of
    the form `widthxheight` + `xoffset` + `yoffset` |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '| Changing the Title bar icon to something different from the default Tk icon
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '| Removing the root border frame |'
  prefs: []
  type: TYPE_TB
- en: 'Now let''s take a look at an example where we apply all the styling options
    and root window options as discussed previously (see the code `01.13.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the preceding code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first segment of code uses some important root methods to define the geometry,
    title of the program, icon for the program, and method to remove the border of
    the root window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code then connects to an external styling file called `optionDB.txt` that
    defines common styling for the widgets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next segment of code creates a Text widget and specifies styling on the
    widget level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next segment of code has several buttons, all of which derive their styling
    from the centralized `optionDb.txt` file. One of the buttons also defines a custom
    cursor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last segment of code styles some buttons using built-in bitmap images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running this program would produce a window like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Engage Thrusters](img/7941_01_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we explored how to use styling options to modify the default styling
    of Tkinter. We saw how to specify custom colors, fonts, reliefs, and cursors for
    our GUI programs. We also saw how to separate styling from the logic using the
    option database. Finally, we explored some of the common options for configuring
    our root window.
  prefs: []
  type: TYPE_NORMAL
- en: Mission Accomplished
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This brings us to end of [Project 1](ch01.html "Chapter 1. Meet Tkinter"),
    *Meet Tkinter*. This project aimed to provide a high-level overview of Tkinter.
    We have worked our way through all the important concepts that drive a Tkinter
    program. We now know:'
  prefs: []
  type: TYPE_NORMAL
- en: What a root window is and how to set it up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the 21 core Tkinter widgets are and how to set them up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to layout our programs using `pack`, `grid`, and `place` geometry managers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make our programs functional using events and callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to apply custom styles to our GUI programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, we can now start thinking of making interesting, functional, and
    stylish GUI programs with Tkinter!
  prefs: []
  type: TYPE_NORMAL
- en: A Hotshot Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Time for your first Hotshot challenge! Your task is to build a simple calculator
    (or if you are ambitious, a scientific calculator). It should be fully functional
    and should have custom-styled buttons and a screen. Try to make it look as close
    to real physical calculators as you can.
  prefs: []
  type: TYPE_NORMAL
- en: When you are done, we invite you to search in your computer for complex GUI
    programs. These can range from your operating system programs such as the search
    bar, to some simple dialog-based widgets. Try to replicate any chosen GUIs using
    Tkinter.
  prefs: []
  type: TYPE_NORMAL
