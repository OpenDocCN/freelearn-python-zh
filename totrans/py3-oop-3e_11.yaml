- en: Python Design Patterns II
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be introduced to several more design patterns. Once
    again, we''ll cover the canonical examples as well as any common alternative implementations
    in Python. We''ll be discussing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The adapter pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The facade pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy initialization and the flyweight pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The command pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The abstract factory pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The composition pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The adapter pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike most of the patterns we reviewed in the previous chapter, the adapter
    pattern is designed to interact with existing code. We would not design a brand
    new set of objects that implement the adapter pattern. Adapters are used to allow
    two preexisting objects to work together, even if their interfaces are not compatible.
    Like the display adapters that allow you to plug your Micro USB charging cable
    into a USB-C phone, an adapter object sits between two different interfaces, translating
    between them on the fly. The adapter object's sole purpose is to perform this
    translation. Adapting may entail a variety of tasks, such as converting arguments
    to a different format, rearranging the order of arguments, calling a differently
    named method, or supplying default arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In structure, the adapter pattern is similar to a simplified decorator pattern.
    Decorators typically provide the same interface that they replace, whereas adapters
    map between two different interfaces. This is depicted in UML form in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bef847c5-155c-4661-91f7-b48a291ce802.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, **Interface1 **is expecting to call a method called **make_action(some,
    arguments)**. We already have this perfect **Interface2** class that does everything
    we want (and to avoid duplication, we don't want to rewrite it!), but it provides
    a method called **different_action(other, arguments)** instead. The **Adapter**
    class implements the **make_action** interface and maps the arguments to the existing
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage here is that the code that maps from one interface to another
    is all in one place. The alternative would be really ugly; we'd have to perform
    the translation in multiple places whenever we need to access this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine we have the following preexisting class, which takes a
    string date in the format `YYYY-MM-DD` and calculates a person''s age on that
    date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is a pretty simple class that does what it's supposed to do. But we have
    to wonder what the programmer was thinking, using a specifically formatted string
    instead of using Python's incredibly useful built-in `datetime` library. As conscientious
    programmers who reuse code whenever possible, most of the programs we write will
    interact with `datetime` objects, not strings.
  prefs: []
  type: TYPE_NORMAL
- en: We have several options to address this scenario. We could rewrite the class
    to accept `datetime` objects, which would probably be more accurate anyway. But
    if this class had been provided by a third party and we don't know how to or can't
    change its internal structure, we need an alternative. We could use the class
    as it is, and whenever we want to calculate the age on a `datetime.date` object,
    we could call `datetime.date.strftime('%Y-%m-%d')` to convert it to the proper
    format. But that conversion would be happening in a lot of places, and worse,
    if we mistyped the `%m` as `%M`, it would give us the current minute instead of
    the  month entered. Imagine if you wrote that in a dozen different places only
    to have to go back and change it when you realized your mistake. It's not maintainable
    code, and it breaks the DRY principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we can write an adapter that allows a normal date to be plugged into
    a normal `AgeCalculator` class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This adapter converts `datetime.date` and `datetime.time` (they have the same
    interface to `strftime`) into a string that our original `AgeCalculator` can use.
    Now we can use the original code with our new interface. I changed the method
    signature to `get_age` to demonstrate that the calling interface may also be looking
    for a different method name, not just a different type of argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a class as an adapter is the usual way to implement this pattern,
    but, as usual, there are other ways to do it in Python. Inheritance and multiple
    inheritance can be used to add functionality to a class. For example, we could
    add an adapter on the `date` class so that it works with the original `AgeCalculator`
    class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s code like this that makes one wonder whether Python should even be legal.
    We have added a `split` method to our subclass that takes a single argument (which
    we ignore) and returns a tuple of year, month, and day. This works flawlessly
    with the original `AgeCalculator` class because the code calls `strip` on a specially
    formatted string, and `strip`, in that case, returns a tuple of year, month, and
    day. The `AgeCalculator` code only cares if `strip` exists and returns acceptable
    values; it doesn''t care if we really passed in a string. The following code really
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It works but it's a stupid idea. In this particular instance, such an adapter
    would be hard to maintain. We'd soon forget why we needed to add a `strip` method
    to a `date` class. The method name is ambiguous. That can be the nature of adapters,
    but creating an adapter explicitly instead of using inheritance usually clarifies
    its purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of inheritance, we can sometimes also use monkey-patching to add a method
    to an existing class. It won't work with the `datetime` object, as it doesn't
    allow attributes to be added at runtime.  In normal classes, however, we can just
    add a new method that provides the adapted interface that is required by calling
    code. Alternatively, we could extend or monkey-patch the `AgeCalculator` itself
    to replace the `calculate_age` method with something more amenable to our needs.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is often possible to use a function as an adapter; this doesn't
    obviously fit the actual design of the adapter pattern, but if we recall that
    functions are essentially objects with a `__call__` method, it becomes an obvious
    adapter adaptation.
  prefs: []
  type: TYPE_NORMAL
- en: The facade pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The facade pattern is designed to provide a simple interface to a complex system
    of components. For complex tasks, we may need to interact with these objects directly,
    but there is often a *typical* usage for the system for which these complicated
    interactions aren''t necessary. The facade pattern allows us to define a new object
    that encapsulates this typical usage of the system. Any time we want access to
    common functionality, we can use the single object''s simplified interface. If
    another part of the project needs access to more complicated functionality, it
    is still able to interact with the system directly. The UML diagram for the facade
    pattern is really dependent on the subsystem, but in a cloudy way, it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/900379e3-b9e5-4451-b8ed-abcf6451c417.png)'
  prefs: []
  type: TYPE_IMG
- en: A facade is, in many ways, like an adapter. The primary difference is that a
    facade tries to abstract a simpler interface out of a complex one, while an adapter
    only tries to map one existing interface to another.
  prefs: []
  type: TYPE_NORMAL
- en: Let's write a simple facade for an email application. The low-level library
    for sending email in Python, as we saw in [Chapter 7](b70c8ea0-4778-4005-af13-bdae3d90d2c6.xhtml),
    *Python Object-Oriented Shortcuts*, is quite complicated. The two libraries for
    receiving messages are even worse.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be nice to have a simple class that allows us to send a single email,
    and list the emails currently in the inbox on an IMAP or POP3 connection. To keep
    our example short, we''ll stick with IMAP and SMTP: two totally different subsystems
    that happen to deal with email. Our facade performs only two tasks: sending an
    email to a specific address, and checking the inbox on an IMAP connection. It
    makes some common assumptions about the connection, such as that the host for
    both SMTP and IMAP is at the same address, that the username and password for
    both is the same, and that they use standard ports. This covers the case for many
    email servers, but if a programmer needs more flexibility, they can always bypass
    the facade and access the two subsystems directly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The class is initialized with the hostname of the email server, a username,
    and a password to log in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `send_email` method formats the email address and message, and sends it using
    `smtplib`. This isn''t a complicated task, but it requires quite a bit of fiddling to
    massage the *natural* input parameters that are passed into the facade to the
    correct format to enable `smtplib` to send the message, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement at the beginning of the method is catching whether or not
    the `username` is the entire *from* email address or just the part on the left-hand
    side of the `@` symbol; different hosts treat the login details differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the code to get the messages currently in the inbox is a royal mess.
    The IMAP protocol is painfully over-engineered, and the `imaplib` standard library
    is only a thin layer over the protocol. But we get to simplify it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we add all this together, we have a simple facade class that can send
    and receive messages in a fairly straightforward manner; much simpler than if
    we had to interact with these complex libraries directly.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is rarely mentioned by name in the Python community, the facade
    pattern is an integral part of the Python ecosystem. Because Python emphasizes
    language readability, both the language and its libraries tend to provide easy-to-comprehend
    interfaces to complicated tasks. For example, `for` loops, `list` comprehensions,
    and generators are all facades into a more complicated iterator protocol. The
    `defaultdict` implementation is a facade that abstracts away annoying corner cases
    when a key doesn't exist in a dictionary. The third-party **requests** library
    is a powerful facade over less readable libraries for HTTP requests, which are
    themselves a facade over managing the text-based HTTP protocol yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The flyweight pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The flyweight pattern is a memory optimization pattern. Novice Python programmers
    tend to ignore memory optimization, assuming the built-in garbage collector will
    take care of them. This is usually perfectly acceptable, but when developing larger
    applications with many related objects, paying attention to memory concerns can
    have a huge payoff.
  prefs: []
  type: TYPE_NORMAL
- en: The flyweight pattern ensures that objects that share a state can use the same
    memory for that shared state. It is normally implemented only after a program
    has demonstrated memory problems. It may make sense to design an optimal configuration
    from the beginning in some situations, but bear in mind that premature optimization
    is the most effective way to create a program that is too complicated to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following UML diagram for the flyweight pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fac04995-3717-4ad7-b0bb-2c2e85f65770.png)'
  prefs: []
  type: TYPE_IMG
- en: Each **Flyweight** has no specific state. Any time it needs to perform an operation
    on **SpecificState**, that state needs to be passed into the **Flyweight** by
    the calling code. Traditionally, the factory that returns a flyweight is a separate
    object; its purpose is to return a flyweight for a given key identifying that
    flyweight. It works like the singleton pattern we discussed in [Chapter 10](345fe617-9a90-4c59-9355-e7076759f9a4.xhtml),
    *Python Design Patterns I*; if the flyweight exists, we return it; otherwise,
    we create a new one. In many languages, the factory is implemented, not as a separate
    object, but as a static method on the `Flyweight` class itself.
  prefs: []
  type: TYPE_NORMAL
- en: Think of an inventory system for car sales. Each individual car has a specific
    serial number and is a specific color. But most of the details about that car
    are the same for all cars of a particular model. For example, the Honda Fit DX
    model is a bare-bones car with few features. The LX model has A/C, tilt, cruise,
    and power windows and locks. The Sport model has fancy wheels, a USB charger,
    and a spoiler. Without the flyweight pattern, each individual car object would
    have to store a long list of which features it did and did not have. Considering
    the number of cars Honda sells in a year, this would add up to a huge amount of
    wasted memory.
  prefs: []
  type: TYPE_NORMAL
- en: Using the flyweight pattern, we can instead have shared objects for the list
    of features associated with a model, and then simply reference that model, along
    with a serial number and color, for individual vehicles. In Python, the flyweight
    factory is often implemented using that funky `__new__` constructor, similar to
    what we did with the singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the singleton pattern, which only needs to return one instance of the
    class, we need to be able to return different instances depending on the keys.
    We could store the items in a dictionary and look them up based on the key. This
    solution is problematic, however, because the item will remain in memory as long
    as it is in the dictionary. If we sold out of LX model Fits, the Fit flyweight
    would no longer be necessary, yet it would still be in the dictionary. We could
    clean this up whenever we sell a car, but isn't that what a garbage collector
    is for?
  prefs: []
  type: TYPE_NORMAL
- en: We can solve this by taking advantage of Python's `weakref` module. This module
    provides a `WeakValueDictionary` object, which basically allows us to store items
    in a dictionary without the garbage collector caring about them. If a value is
    in a weak referenced dictionary and there are no other references to that object
    stored anywhere in the application (that is, we sold out of LX models), the garbage
    collector will eventually clean up for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build the factory for our car flyweights first, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, whenever we construct a new flyweight with a given name, we first
    look up that name in the weak referenced dictionary; if it exists, we return that
    model; if not, we create a new one. Either way, we know the `__init__` method
    on the flyweight will be called every time, regardless of whether it is a new
    or existing object. Our `__init__` method can therefore look like the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement ensures that we only initialize the object the first time
    `__init__` is called. This means we can call the factory later with just the model
    name and get the same flyweight object back. However, because the flyweight will
    be garbage-collected if no external references to it exist, we must be careful
    not to accidentally create a new flyweight with null values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a method to our flyweight that hypothetically looks up a serial
    number on a specific model of vehicle, and determines whether it has been involved
    in any accidents. This method needs access to the car''s serial number, which
    varies from car to car; it cannot be stored with the flyweight. Therefore, this
    data must be passed into the method by the calling code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define a class that stores the additional information, as well as a
    reference to the flyweight, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also keep track of the available models, as well as the individual cars
    on the lot, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s demonstrate the weak referencing at work in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `id` function tells us the unique identifier for an object. When we call
    it a second time, after deleting all references to the LX model and forcing garbage
    collection, we see that the ID has changed. The value in the `CarModel __new__`
    factory dictionary was deleted and a fresh one was created. If we then try to
    construct a second `CarModel` instance, however, it returns the same object (the
    IDs are the same), and, even though we did not supply any arguments in the second
    call, the `air` variable is still set to `True`. This means the object was not
    initialized the second time, just as we designed.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, using the flyweight pattern is more complicated than just storing
    features on a single car class. When should we choose to use it? The flyweight
    pattern is designed for conserving memory; if we have hundreds of thousands of
    similar objects, combining similar properties into a flyweight can have an enormous
    impact on memory consumption.
  prefs: []
  type: TYPE_NORMAL
- en: It is common for programming solutions that optimize CPU, memory, or disk space
    to result in more complicated code than their unoptimized brethren. It is therefore
    important to weigh up the trade-offs when deciding between code maintainability
    and optimization. When choosing optimization, try to use patterns such as flyweight
    to ensure that the complexity introduced by optimization is confined to a single
    (well-documented) section of the code.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a lot of Python objects in one program, one of the quickest ways
    to save memory is through the use of `__slots__`. The `__slots__` magic method
    is beyond the scope of this book, but there is plenty of information available
    if you check online. If you are still low on memory, flyweight may be a reasonable
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: The command pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The command pattern adds a level of abstraction between actions that must be
    done and the object that invokes those actions, normally at a later time. In the
    command pattern, client code creates a `Command` object that can be executed at
    a later date. This object knows about a receiver object that manages its own internal
    state when the command is executed on it. The `Command` object implements a specific
    interface (typically, it has an `execute` or `do_action` method, and also keeps
    track of any arguments required to perform the action. Finally, one or more `Invoker`
    objects execute the command at the correct time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the UML diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e52cf46a-6bfd-4406-ad35-8d763854b323.png)'
  prefs: []
  type: TYPE_IMG
- en: A common example of the command pattern is actions on a graphical window. Often,
    an action can be invoked by a menu item on the menu bar, a keyboard shortcut,
    a toolbar icon, or a context menu. These are all examples of `Invoker` objects.
    The actions that actually occur, such as `Exit`, `Save`, or `Copy`, are implementations
    of `CommandInterface`. A GUI window to receive exit, a document to receive save,
    and `ClipboardManager` to receive copy commands, are all examples of possible
    `Receivers`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement a simple command pattern that provides commands for `Save`
    and `Exit` actions. We''ll start with some modest receiver classes, themselves
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: These mock classes model objects that would likely be doing a lot more in a
    working environment. The window would need to handle mouse movement and keyboard
    events, and the document would need to handle character insertion, deletion, and
    selection. But for our example, these two classes will do what we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s define some invoker classes. These will model toolbar, menu, and
    keyboard events that can happen; again, they aren''t actually hooked up to anything,
    but we can see how they are decoupled from the command, receiver, and client code
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the various action methods each call the `execute` method on their
    respective commands? This code doesn't show the `command` attribute being set
    on each object. They could be passed into the `__init__` function, but because
    they may be changed (for example, with a customizable keybinding editor), it makes
    more sense to set the attributes on the objects afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s hook up the commands themselves with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These commands are straightforward; they demonstrate the basic pattern, but
    it is important to note that we can store state and other information with the
    command if necessary. For example, if we had a command to insert a character,
    we could maintain state for the character currently being inserted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is hook up some client and test code to make the commands
    work. For basic testing, we can just include the following code at the end of
    the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: First, we create two receivers and two commands. Then, we create several of
    the available invokers and set the correct command on each of them. To test, we
    can use `python3``-i``filename.py` and run code such as `exit_menu.click()`, which
    will end the program, or `save_keystroke.keystroke()`, which will save the fake
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the preceding examples do not feel terribly Pythonic. They have
    a lot of "boilerplate code" (code that does not accomplish anything, but only
    provides structure to the pattern), and the `Command` classes are all eerily similar
    to each other. Perhaps we could create a generic command object that takes a function
    as a callback?
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, why bother? Can we just use a function or method object for each command?
    Instead of an object with an `execute()` method, we can write a function and use
    that as the command directly. The following is a common paradigm for the command
    pattern in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now that looks a lot more like Python. At first glance, it looks like we've
    removed the command pattern altogether, and we've tightly connected the `menu_item`
    and `Window` classes. But if we look closer, we find there is no tight coupling
    at all. Any callable can be set up as the command on `MenuItem`, just as before.
    And the `Window.exit` method can be attached to any invoker. Most of the flexibility
    of the command pattern has been maintained. We have sacrificed complete decoupling
    for readability, but this code is, in my opinion, and that of many Python programmers,
    more maintainable than the fully abstracted version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, since we can add a `__call__` method to any object, we aren''t restricted
    to functions. The previous example is a useful shortcut when the method being
    called doesn''t have to maintain state, but in more advanced usage, we can use
    the following code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have something that looks like the first command pattern, but a bit
    more idiomatic. As you can see, making the invoker call a callable instead of
    a `command` object with an execute method has not restricted us in any way. In
    fact, it's given us more flexibility. We can link to functions directly when that
    works, yet we can build a complete callable `command` object when the situation
    calls for it.
  prefs: []
  type: TYPE_NORMAL
- en: The command pattern is often extended to support undoable commands. For example,
    a text program may wrap each insertion in a separate command with not only an
    `execute` method, but also an `undo` method that will delete that insertion. A
    graphics program may wrap each drawing action (rectangle, line, freehand pixels,
    and so on) in a command that has an `undo` method that resets the pixels to their
    original state. In such cases, the decoupling of the command pattern is much more
    obviously useful, because each action has to maintain enough of its state to undo
    that action at a later date.
  prefs: []
  type: TYPE_NORMAL
- en: The abstract factory pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The abstract factory pattern is normally used when we have multiple possible
    implementations of a system that depend on some configuration or platform issue.
    The calling code requests an object from the abstract factory, not knowing exactly
    what class of object will be returned. The underlying implementation returned
    may depend on a variety of factors, such as current locale, operating system,
    or local configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Common examples of the abstract factory pattern include code for operating-system-independent
    toolkits, database backends, and country-specific formatters or calculators. An
    operating-system-independent GUI toolkit might use an abstract factory pattern
    that returns a set of WinForm widgets under Windows, Cocoa widgets under Mac,
    GTK widgets under Gnome, and QT widgets under KDE. Django provides an abstract
    factory that returns a set of object relational classes for interacting with a
    specific database backend (MySQL, PostgreSQL, SQLite, and others) depending on
    a configuration setting for the current site. If the application needs to be deployed
    in multiple places, each one can use a different database backend by changing
    only one configuration variable. Different countries have different systems for
    calculating taxes, subtotals, and totals on retail merchandise; an abstract factory
    can return a particular tax calculation object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The UML class diagram for an abstract factory pattern is hard to understand
    without a specific example, so let''s turn things around and create a concrete
    example first. In our example, we''ll create a set of formatters that depend on
    a specific locale and help us format dates and currencies. There will be an abstract
    factory class that picks the specific factory, as well as a couple of example
    concrete factories, one for France and one for the USA. Each of these will create
    formatter objects for dates and times, which can be queried to format a specific
    value. This is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5f237a6-54d7-45f3-9978-66742550e887.png)'
  prefs: []
  type: TYPE_IMG
- en: Comparing that image to the earlier, simpler text shows that a picture is not
    always worth a thousand words, especially considering we haven't even allowed
    for factory selection code here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, in Python, we don''t have to implement any interface classes, so
    we can discard `DateFormatter`, `CurrencyFormatter`, and `FormatterFactory`. The
    formatting classes themselves are pretty straightforward, if verbose, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'These classes use some basic string manipulation to try to turn a variety of
    possible inputs (integers, strings of different lengths, and others) into the
    following formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **USA** | **France** |'
  prefs: []
  type: TYPE_TB
- en: '| **Date** | mm-dd-yyyy | dd/mm/yyyy |'
  prefs: []
  type: TYPE_TB
- en: '| **Currency** | $14,500.50 | 14 500€50 |'
  prefs: []
  type: TYPE_TB
- en: There could obviously be more validation on the input in this code, but let's
    keep it simple for this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the formatters set up, we just need to create the formatter
    factories, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we set up the code that picks the appropriate formatter. Since this is
    the kind of thing that only needs to be set up once, we could make it a singleton–except
    singletons aren''t very useful in Python. Let''s just make the current formatter
    a module-level variable instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we hardcode the current country code; in practice, it would
    likely introspect the locale, the operating system, or a configuration file to
    choose the code. This example uses a dictionary to associate the country codes
    with factory classes. Then, we grab the correct class from the dictionary and
    instantiate it.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is easy to see what needs to be done when we want to add support for more
    countries: create the new formatter classes and the abstract factory itself. Bear
    in mind that `Formatter` classes might be reused; for example, Canada formats
    its currency the same way as the USA, but its date format is more sensible than
    its Southern neighbor.'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract factories often return a singleton object, but this is not required.
    In our code, it's returning a new instance of each formatter every time it's called.
    There's no reason the formatters couldn't be stored as instance variables and
    the same instance returned for each factory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking back at these examples, we see that, once again, there appears to be
    a lot of boilerplate code for factories that just doesn''t feel necessary in Python.
    Often, the requirements that might call for an abstract factory can be more easily
    fulfilled by using a separate module for each factory type (for example: the USA
    and France), and then ensuring that the correct module is being accessed in a
    factory module. The package structure for such modules might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The trick is that `__init__.py` in the `localize` package can contain logic
    that redirects all requests to the correct backend. There are a variety of ways
    this might be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we know that the backend is never going to change dynamically (that is,
    without a program restart), we can just put some `if` statements in `__init__.py`
    that check the current country code, and use the (normally unacceptable) `from``.backends.USA``import``*`
    syntax to import all variables from the appropriate backend. Or, we could import
    each of the backends and set a `current_backend` variable to point at a specific
    module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Depending on which solution we choose, our client code would have to call either
    `localize.format_date` or `localize.current_backend.format_date` to get a date
    formatted in the current country's locale. The end result is much more Pythonic
    than the original abstract factory pattern and, in typical usage, is just as flexible.
  prefs: []
  type: TYPE_NORMAL
- en: The composite pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The composite pattern allows complex tree-like structures to be built from simple
    components. These components, called composite objects, are able to behave sort
    of like a container and sort of like a variable, depending on whether they have
    child components. Composite objects are container objects, where the content may
    actually be another composite object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, each component in a composite object must be either a leaf node
    (that cannot contain other objects) or a composite node. The key is that both
    composite and leaf nodes can have the same interface. The following UML diagram is
    very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fa1eb55-b038-4c5b-b10c-c5f34bf86e4d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This simple pattern, however, allows us to create complex arrangements of elements,
    all of which satisfy the interface of the component object. The following diagram
    depicts a concrete instance of such a complicated arrangement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99c562f9-c96b-4219-874e-c832fc7aa6ea.png)'
  prefs: []
  type: TYPE_IMG
- en: The composite pattern is commonly useful in file/folder-like trees. Regardless
    of whether a node in the tree is a normal file or a folder, it is still subject
    to operations such as moving, copying, or deleting the node. We can create a component
    interface that supports these operations, and then use a composite object to represent
    folders, and leaf nodes to represent normal files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, in Python, once again, we can take advantage of duck typing to implicitly
    provide the interface, so we only need to write two classes. Let''s define these
    interfaces first in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: For each folder (composite) object, we maintain a dictionary of children. For
    many composite implementations, a list is sufficient, but in this case, a dictionary
    will be useful for looking up children by name. Our paths will be specified as
    node names separated by the `/` character, similar to paths in a Unix shell.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking about the methods involved, we can see that moving or deleting a node
    behaves in a similar way, regardless of whether or not it is a file or folder
    node. Copying, however, has to do a recursive copy for folder nodes, while copying
    a file node is a trivial operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To take advantage of the similar operations, we can extract some of the common
    methods into a parent class. Let''s take that discarded `Component` interface
    and change it to a base class with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We've created the `move` and `delete` methods on the `Component` class. Both
    of them access a mysterious `parent` variable that we haven't set yet. The `move`
    method uses a module-level `get_path` function that finds a node from a predefined
    root node, given a path. All files will be added to this root node or a child
    of that node. For the `move` method, the target should be an existing folder,
    or we'll get an error. As in many examples in technical books, error handling
    is woefully absent, to help focus on the principles under consideration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set up that mysterious `parent` variable in the folder''s `add_child`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, that was easy enough. Let''s see if our composite file hierarchy is working
    properly with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Yes, we can create folders, add folders to other folders, add files to folders,
    and move them around! What more could we ask for in a file hierarchy?
  prefs: []
  type: TYPE_NORMAL
- en: Well, we could ask for copying to be implemented, but to conserve trees, let's
    leave that as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: The composite pattern is extremely useful for a variety of tree-like structures,
    including GUI widget hierarchies, file hierarchies, tree sets, graphs, and HTML
    DOM. It can be a useful pattern in Python when implemented according to the traditional
    implementation, as in the example demonstrated earlier. Sometimes, if only a shallow
    tree is being created, we can get away with a list of lists or a dictionary of
    dictionaries, and do not need to implement custom component, leaf, and composite
    classes. Other times, we can get away with implementing only one composite class,
    and treating leaf and composite objects as a single class. Alternatively, Python's
    duck typing can make it easy to add other objects to a composite hierarchy, as
    long as they have the correct interface.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into exercises for each design pattern, take a moment to implement
    the `copy` method for the `File` and `Folder` objects in the previous section.
    The `File` method should be quite trivial; just create a new node with the same
    name and contents, and add it to the new parent folder. The `copy` method on `Folder`
    is quite a bit more complicated, as you first have to duplicate the folder, and
    then recursively copy each of its children to the new location. You can call the
    `copy()` method on the children indiscriminately, regardless of whether each is
    a file or a folder object. This will drive home just how powerful the composite
    pattern can be.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as in the previous chapter, look at the patterns we've discussed and consider
    ideal places where you might implement them. You may want to apply the adapter
    pattern to existing code, as it is usually applicable when interfacing with existing
    libraries, rather than new code. How can you use an adapter to force two interfaces
    to interact with each other correctly?
  prefs: []
  type: TYPE_NORMAL
- en: Can you think of a system complex enough to justify using the facade pattern?
    Consider how facades are used in real-life situations, such as the driver-facing
    interface of a car, or the control panel in a factory. It is similar in software,
    except the users of the facade interface are other programmers, rather than people
    trained to use them. Are there complex systems in your latest project that could
    benefit from the facade pattern?
  prefs: []
  type: TYPE_NORMAL
- en: It's possible you don't have any huge, memory-consuming code that would benefit
    from the flyweight pattern, but can you think of situations where it might be
    useful? Anywhere that large amounts of overlapping data need to be processed,
    a flyweight is waiting to be used. Would it be useful in the banking industry?
    In web applications? At what point does adopting the flyweight pattern make sense?
    When is it overkill?
  prefs: []
  type: TYPE_NORMAL
- en: What about the command pattern? Can you think of any common (or better yet,
    uncommon) examples of places where the decoupling of action from invocation would
    be useful? Look at the programs you use on a daily basis and imagine how they
    are implemented internally. It's likely that many of them use the command pattern
    for one purpose or another.
  prefs: []
  type: TYPE_NORMAL
- en: The abstract factory pattern, or the somewhat more Pythonic derivatives we discussed,
    can be very useful for creating one-touch-configurable systems. Can you think
    of places where such systems are useful?
  prefs: []
  type: TYPE_NORMAL
- en: Finally, consider the composite pattern. There are tree-like structures all
    around us in programming; some of them, like our file hierarchy example, are blatant;
    others are fairly subtle. What situations might arise where the composite pattern
    would be useful? Can you think of places where you can use it in your own code?
    What if you adapted the pattern slightly; for example, to contain different types
    of leaf or composite nodes for different types of objects?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went into detail on several more design patterns, covering
    their canonical descriptions as well as alternatives for implementing them in
    Python, which is often more flexible and versatile than traditional object-oriented
    languages. The adapter pattern is useful for matching interfaces, while the facade
    pattern is suited to simplifying them. Flyweight is a complicated pattern and
    only useful if memory optimization is required. In Python, the command pattern
    is often more aptly implemented using first class functions as callbacks. Abstract
    factories allow runtime separation of implementations depending on configuration
    or system information. The composite pattern is used universally for tree-like
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: This is the last of the truly object-oriented chapters in this book, but I've
    thrown in a couple of freebies on topics very dear to my heart. In the next chapter,
    we'll discuss how important it is to test Python programs, and how to do it, focusing
    on object-oriented principles.
  prefs: []
  type: TYPE_NORMAL
