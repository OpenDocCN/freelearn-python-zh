<html><head></head><body>
		<div id="_idContainer038">
			<h1 id="_idParaDest-33"><em class="italic"><a id="_idTextAnchor037"/>Chapter 2</em>: Project Configuration</h1>
			<p>Source code is considered the meat and bones, or the framing of a home, in any software. In this chapter, we will build a project that contains the files where the source code lives. We will discuss several tools that will come in handy when developers are working directly with their source code. When working with Django, while any tool can be used to edit the source code, some tools are more productive than others. In this chapter, we will explore some of the countless tools that exist and discuss why an <strong class="bold">Integrated Development Environment</strong> (<strong class="bold">IDE</strong>) might also be used.</p>
			<p>We'll also learn about the importance of working with the Django <strong class="source-inline">settings.py</strong> file(s) of a project. Of course, software also requires a database to store and retrieve data entered and created by its users, and we will install a local and remote database for each environment of a project. We will go over the various database types that are available and then focus on the most popular type to use for the examples throughout this book. It is not required to use the same database type that we will be using, but you might encounter slight variations if you use a different one; proceed with caution. Reading this chapter is crucial before going through the rest of the book.</p>
			<p>In this chapter, we will cover how to do the following:</p>
			<ul>
				<li>Choosing developmental tools</li>
				<li>Starting a project</li>
				<li>Creating a virtual environment</li>
				<li>Project configuration</li>
				<li>Using basic database settings</li>
				<li>Preparing PostgreSQL for Heroku</li>
			</ul>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor038"/>Technical requirements</h1>
			<p>To work with the code in this chapter, the following tools will need to be installed on your local machine: </p>
			<ul>
				<li>Python version 3.9 – used as the underlying programming language for the project</li>
				<li>Django version 4.0 – used as the backend framework of the project</li>
				<li>pip package manager – used to manage third-party Python/Django packages</li>
			</ul>
			<p>Next, you will need a way to edit the code that we will be writing in this chapter and throughout the rest of this book. The first section of this chapter will provide you with several development tool choices from text editors to IDEs. The same IDE will be used to demonstrate a few actions but it is not necessary to use the same tool. You are welcome to use any IDE you like or use no IDE at all, using the terminal or command-line window instead. A database will also be required, and the third section of this chapter will provide several options to choose from. Any database type will work with your project and configuration examples will be provided, but only PostgreSQL will be used to work with our project and Heroku.</p>
			<p>This book will focus on the concepts of Django and enterprise development, instead of guiding you through how to use Git operations. For a crash course on how to use Git operations, you can watch the video found here: <a href="https://www.packtpub.com/product/git-and-github-the-complete-git-and-github-course-video/9781800204003">https://www.packtpub.com/product/git-and-github-the-complete-git-and-github-course-video/9781800204003</a>. </p>
			<p>All of the code created in this chapter can be found in the GitHub repository for this book: <a href="https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer">https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer</a>. The code used throughout this chapter will relate to every file in the core of the project. In every chapter, starting from <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, code related to a particular chapter will reside in its own Django app folder. Refer to the subsection of this chapter titled <em class="italic">Creating a Django app</em> to learn more about what that means. </p>
			<p>Check out the following video to see the <em class="italic">Code in Action</em>: <a href="https://bit.ly/3NqNuFG">https://bit.ly/3NqNuFG</a></p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor039"/>Choosing development tools</h1>
			<p>Configuring our <a id="_idIndexMarker173"/>project refers to how we will structure and arrange the files that make up an application. This also refers to how we share those files within a collaborative team. Some tools create files that can be shared among your team members, such as preconfigured settings related to development and debugging features. These files are sometimes referred to as configuration or solution files. This means you can preconfigure a set of development tools to help get your team up to speed quickly. Making sure that all members use similar tools makes debugging and looking at code that is not written by you much easier. This consistency also makes verbal and written communication among members of your team more efficient when synchronizing workflows. </p>
			<p>While there are benefits to sharing project configuration files, it is also not necessary for everyone on your team to be using the same tools. In fact, it's even possible to create many different configuration files for a variety of development tools all included in the same repository, giving your developers a multitude of preconfigured project files to choose from. Even if we provide configuration files in a repository, a developer can still use a basic text editor with the terminal or command-line window to make edits and run the project locally. Let's compare several of these text editor tools and discuss some of the benefits that they provide. Then, we will discuss what IDEs are and how they differ from text editors.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor040"/>Text editors</h2>
			<p>A <strong class="bold">text editor</strong> is quite<a id="_idIndexMarker174"/> simply<a id="_idIndexMarker175"/> exactly what it sounds like, a means to edit text, or in our case, source code. Text editors are sometimes referred to as lightweight IDEs, given the number of features that some of these popular editors come packed with. </p>
			<p>Likely, what are considered the three most popular text editors today are the following:</p>
			<ul>
				<li><strong class="bold">Atom</strong></li>
				<li><strong class="bold">Notepad++</strong></li>
				<li><strong class="bold">Sublime Text</strong></li>
			</ul>
			<h3>Atom</h3>
			<p>Atom is intended to <a id="_idIndexMarker176"/>be a fully <a id="_idIndexMarker177"/>editable and customizable text editor. The tool's official website uses the term <em class="italic">hackable</em> when describing their software. This editor allows you to install packages that help enhance your code-writing abilities. It has smart code auto-completion and code styling to let you type less and see more. This tool has a built-in file browser that allows you to find and replace code in the folders and files that you choose to search through. Atom also works on all three major operating systems, Windows, Mac, and Linux. It is free to use and also open source, allowing you to modify the editor's source code itself. To download Atom and start using it<a id="_idIndexMarker178"/> today, visit <a href="https://atom.io/">https://atom.io/</a>.</p>
			<h3>Notepad++</h3>
			<p>Notepad++ is <a id="_idIndexMarker179"/>another<a id="_idIndexMarker180"/> free and open source editor that comes with a stylish code syntax highlighter and provides code auto-completion suggestions. It was built to work with and run a vast number of different programming languages. It even lets you write macros and run custom scripts directly from the editor. Like Atom, it also has the capability of installing plugins. It's really lightweight and can be a nice editor to set as the default for your operating system. To download <a id="_idIndexMarker181"/>Notepad++, visit <a href="https://notepad-plus-plus.org/downloads/">https://notepad-plus-plus.org/downloads/</a>.</p>
			<h3>Sublime Text</h3>
			<p>Sublime <a id="_idIndexMarker182"/>Text is <a id="_idIndexMarker183"/>another popular choice. This editor allows you to create project files and includes features to build a wide variety of programming languages. One cool feature is how it will use your <strong class="bold">Graphical Processing Unit</strong> (<strong class="bold">GPU</strong>) to<a id="_idIndexMarker184"/> improve the performance of the editor's UI while you work. It uses what they call context-aware auto-completion, meaning the editor will intelligently offer code completion suggestions based on what code exists on the page, regardless of whether you are in a file that is of another language. For example, you can edit code contained in a <strong class="source-inline">&lt;script type="text/javascript"&gt;&lt;/script&gt;</strong> that lives inside of a <strong class="source-inline">.html</strong> document to be styled and displayed differently from the HTML found in that same file. </p>
			<p>Another application in the Sublime family is called Sublime Merge, which is a simple way to merge code and perform Git operations. My favorite feature is using it to view history states and commit logs. Sublime Text is free to evaluate for a certain amount of time but eventually, it will prompt you to purchase a license after the trial period is over. To get started with<a id="_idIndexMarker185"/> Sublime Text, visit <a href="https://www.sublimetext.com/">https://www.sublimetext.com/</a>.</p>
			<p>There are dozens, if not hundreds, of other text editors to choose from that were not mentioned in this chapter. Don't limit yourself to only the popular choices provided and feel free to explore many other tools. The number of features and capabilities that some text editors <a id="_idIndexMarker186"/>provide can sometimes be referred to as a lightweight IDE; let's discuss what an IDE is next.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor041"/>Integrated development environments</h2>
			<p>An IDE is <a id="_idIndexMarker187"/>what we call<a id="_idIndexMarker188"/> software that combines many different programming tools into one single desktop application that a developer can use to build other applications. It is a development tool that your team can use and benefit from to stay productive. IDEs primarily consist of a way to view and edit source code, automate local build processes, and provide ways to help you debug and analyze your code. The tool contains ways to style and format code, show you errors as you type, and provide code completion suggestions to reduce keystrokes as you work. These environments also provide ways to search other code files contained in your project and push or deploy your code to external repositories. For example, the Sourcetree app that was mentioned in <a href="B17243_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Undertaking a Colossal Project</em>, would no longer be needed if you are using an IDE that has Git features built into it. </p>
			<p>The same applies to a text editor choice that also has Git features included. Similar to some of the text editors with fancy features, IDEs will create common configuration files that can be shared with your team. Some of these files we don't want to share, such as files that store breakpoints and other local debugging settings specific to that developer and local instance only. However, sharing configuration settings with your team allows members to get their IDEs up and running on their machines much easier and quicker, with all of the tools ready or almost ready to use.</p>
			<p>A simple text editor is really all you need. A project could start out this way and then your team could introduce the use of an IDE later on. Sometimes, when using an IDE, you can structure your project files in subdirectories that would otherwise not exist. If you already know your team will need the productivity tools from the get-go, you can start out with an IDE and create a project through the IDE itself, letting the IDE structure your files in a way that is natural to that IDE. It's sometimes easier this way because some IDEs may configure your file structures slightly differently than what would otherwise be created by using just the Django <strong class="source-inline">startproject</strong> command from a terminal or command-line window. </p>
			<p>Let's discuss some of the popular IDE choices that developers use with Django today and then settle upon one of these choices to demonstrate the concept of using an IDE. This chapter will demonstrate working with Django management commands both in the IDE and the terminal to showcase the benefits of using one versus the other. For every action demonstrated using the IDE in this chapter, the command-line-driven command equivalent of that action will also be provided. This will also allow you to bypass the IDE altogether if you wish to do so. Moving forward, all future chapters will only provide the standard <a id="_idIndexMarker189"/>command-line-driven<a id="_idIndexMarker190"/> Django management commands and continuing to use the IDE will be optional.</p>
			<h3>PyDev with Eclipse</h3>
			<p><strong class="bold">PyDev</strong> is actually <a id="_idIndexMarker191"/>a <a id="_idIndexMarker192"/>plugin <a id="_idIndexMarker193"/>for the <strong class="bold">Eclipse IDE</strong> but it can <a id="_idIndexMarker194"/>also be used as a standalone IDE. PyDev can be downloaded and installed directly by itself because it will come preinstalled with <strong class="bold">LiClipse</strong>, a lightweight version of the Eclipse IDE. The Eclipse IDE is a fully integrated development experience. It allows the debugging of code in a variety of ways. Profiling is just one of those ways, which is a tool that helps the developer understand the timing of events, memory usage, disk usage, or any other diagnostics. The term CPU Profiler is often used to discuss tools that can help you find out what specific process is bogging down your system. It will tell you things such as how long it was hanging for and give you an idea as to how to fix it. All of the bells and whistles that come with all of the text editors I mentioned previously also come with Eclipse. PyDev has a vast library of packages to choose from for many different languages that exist today. Eclipse and PyDev both work on all standard operating systems today, such as Windows, Mac, and Linux. To download Eclipse, visit <a href="https://www.eclipseclp.org/download.html">https://www.eclipseclp.org/download.html</a>.</p>
			<p>Eclipse and PyDev are both free to use and are both open source licenses, allowing you to modify the IDE software itself. The Eclipse IDE is a bit more difficult to install than other desktop applications today. Its installers require a good deal of reading before you know how to get started with installing it. Eclipse also requires <strong class="bold">Java</strong> to be installed and running on your machine. Java is a high-level programming language and a computing platform that is usually not required to work with Django and Python unless you are working <a id="_idIndexMarker195"/>with <a id="_idIndexMarker196"/>Eclipse. For <a id="_idIndexMarker197"/>this reason, we will not be using this IDE in this chapter. To <a id="_idIndexMarker198"/>download PyDev, visit <a href="https://www.pydev.org/download.html">https://www.pydev.org/download.html</a>. </p>
			<h3>PyCharm</h3>
			<p><strong class="bold">PyCharm</strong> is likely<a id="_idIndexMarker199"/> the most<a id="_idIndexMarker200"/> popular choice among Python and Django developers today. It is easy to use and much easier to install than PyDev by using a simple executable file available for Windows, Mac, or Linux machines. It comes with a free community version as well as a paid professional version. The paid version offers many more features and provides more specialized scientific and web development tools, such as advanced database integration and database development, directly from within the IDE, as well as other debugging and profiling tools. The free community version is enough for most Django developers to get by on. This version allows developers to work with Django project integrations and run virtual environments while connecting to remote Git <a id="_idIndexMarker201"/>repositories. To download and install PyCharm, visit <a href="https://www.jetbrains.com/pycharm/download/">https://www.jetbrains.com/pycharm/download/</a>.</p>
			<p>While this is likely the most popular IDE among Django developers, Visual Studio is likely the most popular IDE among developers of any language or framework. For this reason, we will use Visual Studio to demonstrate the examples throughout this chapter.</p>
			<h3>Visual Studio</h3>
			<p><strong class="bold">Visual Studio</strong> has been<a id="_idIndexMarker202"/> a very <a id="_idIndexMarker203"/>popular tool of choice among many .NET, C#, C++, and other developers for over 20 years now. It's a very robust IDE that comes packed with all of the tools that you can think of and then more. It comes in many different varieties and flavors, and for years it was only available for a price. Then, around 2013, Microsoft started offering the Visual Studio Community Edition for free to the public. A drawback for some was that Visual Studio was only available on Windows platforms until the year 2017, when it became available on Mac platforms. Currently, Linux is not supported. However, Visual Studio Code, a lightweight IDE, is available on all three platforms, Windows, Mac, and Linux. </p>
			<p><strong class="bold">Visual Studio Code</strong> has likely become the most popular tool of all time among any type of <a id="_idIndexMarker204"/>developer. Both Visual Studio and Visual Studio Code support using Python and Django. Upon installing either of these tools, you will need to select related Python/Django packages that will be included in your installation or install them separately. For those of you working on a Linux machine, or if you just don't want to use an IDE, refer to the management commands provided after the IDE demonstration of each action involved in creating a project. If you are on a Windows or Mac system and wish to follow along using an IDE, download the <strong class="bold">Visual Studio 2019 – Community Edition</strong> installer found here: <a href="https://visualstudio.microsoft.com/downloads/">https://visualstudio.microsoft.com/downloads/</a>. Make sure, during your installation, that you select any Python development extensions that it offers, as <a id="_idIndexMarker205"/>shown in the<a id="_idIndexMarker206"/> following screenshot:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/Figure_2.01_B17243.jpg" alt="Figure 2.1 – Visual Studio – Python development extension&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – Visual Studio – Python development extension</p>
			<p>You might find other useful tools under the <strong class="bold">Individual components</strong> tab of this interface. Include any other tools that you would like to include before proceeding with your installation. Now that we have <strong class="bold">Visual Studio 2019 – Community Edition</strong> installed, let's build a solution file for a project that can be shared with other developers in a repository.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">While Visual Studio 2019 is the latest product available from Microsoft, Visual Studio 2022 will be released about the same time this book will be published. If you are using the newer version of Visual Studio, you should be able to perform all of the same actions as depicted in this chapter. The screenshots of the Visual Studio IDE may not appear exactly the same and some code adjustments might also be necessary.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor042"/>Starting a project</h1>
			<p>There are two ways to start a project and this chapter will allow you to choose which method you want to follow. We encourage you to use the IDE as becoming proficient with using this tool in your team will be beneficial in the long run. However, if your team is using an IDE other than Visual Studio or you are only using a text editor to work with your code, the command-line equivalent of performing each step is also provided to allow anyone to work through this chapter. All other chapters in this book will focus on code only, which can be used with or without an IDE.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor043"/>Using the IDE</h2>
			<p>Open the <a id="_idIndexMarker207"/>Visual Studio IDE and select <strong class="bold">Create New Project</strong>. When you are directed to the next screen, search for the <strong class="source-inline">django</strong> keyword and in the list of results, select <strong class="bold">Blank Django Web Project</strong>, as depicted here:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/Figure_2.02_B17243.jpg" alt="Figure 2.2 – Visual Studio – Create a new project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – Visual Studio – Create a new project</p>
			<p>On the next screen, enter <strong class="source-inline">becoming_a_django_entdev</strong> for <strong class="bold">Project Name</strong>. This will auto-populate your <strong class="bold">Solution Name</strong> field as you type. For the <strong class="bold">Location</strong> option, select the folder on your drive where you placed your local Git repository from <a href="B17243_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Undertaking a Colossal Project</em>, as your location. At the bottom, make sure the checkbox labeled <strong class="bold">Place solution and project in the same directory</strong> is checked as is done in the following screenshot. Enabling this checkbox will place a solution file in the same folder as the <strong class="source-inline">manage.py</strong> file, known as the root of a project. It will make using things such as the terminal that is provided within the IDE just a little easier:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/Figure_2.03_B17243.jpg" alt="Figure 2.3 – Visual Studio – Creating a Django project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – Visual Studio – Creating a Django project</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When using the Visual Studio IDE to create a project, the files found in the <strong class="source-inline">/becoming_a_django_entdev/becoming_a_django_entdev/</strong> folder, such as the <strong class="source-inline">settings.py</strong> and <strong class="source-inline">urls.py</strong> files, are automatically generated using Django 2.1.2. These<a id="_idIndexMarker208"/> files will still work when used with later versions of Django. Additionally, when we get to the <em class="italic">Creating a virtual environment</em> section of this chapter, we will actually be installing the Django 4.0 package, which is the version used throughout this book. Even though version 2.1.2 was used to initially create some of the project files, the project will always use version 4.0 and run successfully. When using the terminal or command-line window to create a project, this scenario will not occur. Later, in <a href="B17243_09_ePub.xhtml#_idTextAnchor272"><em class="italic">Chapter 9</em></a>, <em class="italic">Django Testing</em>, you will learn how to verify what version is actually installed and being used.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor044"/>Using the command line</h2>
			<p>The Django terminal or<a id="_idIndexMarker209"/> command-line window equivalent of starting a Django project is the <strong class="source-inline">startproject</strong> command. There are two ways to create a project using this command. The first method is to create your project using the version of Django that was installed on your machine globally and then build your virtual environment next. </p>
			<p>The other way is to create your virtual environment first and then activate your environment, install the version of Django that you desire, and then build your project using the version of Django that was installed in your virtual environment. What the IDE did for us was create a project first using a version of Django that the IDE provides, and then when we created the virtual environment, the version of Django was updated to the version specified in the <strong class="source-inline">requirements.txt</strong> file. </p>
			<p>When a package gets updated in the virtual environment, the old version gets uninstalled and the new version gets installed fresh. For this exercise, we will uninstall any version of Django that may exist globally, then install the latest version available when this book was written. Then, we will create the virtual environment using the command line in the next section, following along as close as we can to the examples provided using the IDE.</p>
			<p>Follow these steps to create your project files:</p>
			<ol>
				<li>Open your terminal or command-line window and navigate to your local repository folder created in <a href="B17243_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Undertaking a Colossal Project</em>. Make sure you are not in a virtual environment at this time. Then, execute the following commands to uninstall any existing versions of Django and then install the proper version of Django that we will be using globally on your machine:<p class="source-code"><strong class="bold">PS C:\Projects\Packt\Repo&gt; pip uninstall django</strong></p><p class="source-code"><strong class="bold">PS C:\Projects\Packt\Repo&gt; pip install django==4.0</strong></p></li>
				<li>Execute the Django command that will create a project and all of the core files necessary to work with Django, based on Django version 4.0. We will name this project the same as in the IDE example: <strong class="source-inline">becoming_a_django_entdev</strong>. The <strong class="source-inline">startproject</strong> command creates a <strong class="source-inline">manage.py</strong>, <strong class="source-inline">wsgi.py</strong>, and <strong class="source-inline">asgi.py</strong> file and several other boilerplate files that serve as the foundation of all Django projects. The <strong class="source-inline">becoming_a_django_entdev</strong> option is the name of the project and the folder that a project will be placed in. Execute the following command to create the project:<p class="source-code"><strong class="bold">PS C:\Projects\Packt\Repo&gt; python -m django startproject becoming_a_django_entdev</strong></p></li>
			</ol>
			<p>The preceding is a friendly command that has been tested and proven to work on a Windows machine. Traditionally, developers would use the following command to start a project; however, this command does not work on a Windows operating system:</p>
			<p class="source-code"><strong class="bold">PS C:\Projects\Packt\Repo&gt; django-admin startproject becoming_a_django_entdev</strong></p>
			<p>Next, let's create <a id="_idIndexMarker210"/>and configure a virtual environment, which is needed to work with any third-party packages included in a project.</p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor045"/>Creating a virtual environment</h1>
			<p>We should not<a id="_idIndexMarker211"/> have a virtual environment for our project at this time. If you do have one, go ahead and disregard it and create a new one for this next exercise. Whether you created a project using the Visual Studio IDE or by using the Django commands from a terminal or command-line window in the previous exercises, the file structure in your repository should look like the following tree structure:</p>
			<p><strong class="source-inline">├── .git</strong></p>
			<p><strong class="source-inline">├── readme.md</strong></p>
			<p><strong class="source-inline">├── requirements.txt</strong></p>
			<p><strong class="source-inline">├── becoming_a_django_entdev</strong></p>
			<p><strong class="source-inline">│   ├── .vs</strong></p>
			<p><strong class="source-inline">│   ├── becoming_a_django_entdev.sln</strong></p>
			<p><strong class="source-inline">│   ├── db.sqlite3</strong></p>
			<p><strong class="source-inline">│   ├── manage.py</strong></p>
			<p><strong class="source-inline">│   ├── obj</strong></p>
			<p><strong class="source-inline">│   ├── requirements.txt</strong></p>
			<p><strong class="source-inline">│   ├── staticfiles</strong></p>
			<p><strong class="source-inline">│   └── becoming_a_django_entdev</strong></p>
			<p><strong class="source-inline">│       ├── __init__.py</strong></p>
			<p><strong class="source-inline">│       ├── asgi.py</strong></p>
			<p><strong class="source-inline">│       ├── settings.py</strong></p>
			<p><strong class="source-inline">│       ├── urls.py</strong></p>
			<p><strong class="source-inline">│       └── wsgi.py</strong></p>
			<p>We now have two <strong class="source-inline">requirements.txt</strong> files and two folders called <strong class="source-inline">/becoming_a_django_entdev/becoming_a_django_entdev/</strong>, where various files reside. We will leave the folder structure the way it is now and configure additional settings later to allow Heroku to work with this folder structure. We are doing this because creating a project through the IDE will only produce this result, and note that other IDEs or even lightweight IDE text editors may create folder structures that even vary from the preceding tree. If you decide to use the Django commands to create a new project, you do have the option to specify an additional option to prevent creating your project in a subdirectory. This would put the <strong class="source-inline">manage.py</strong> file in the same directory as the root of a repository and result in only one <strong class="source-inline">requirements.txt</strong> file. Doing that<a id="_idIndexMarker212"/> would require using the following command example:</p>
			<p class="source-code">PS C:\Projects\Packt\Repo&gt; python -m django startproject becoming_a_django_entdev ./</p>
			<p>Here, we add the additional<strong class="source-inline">./</strong> option at the end of the preceding command, which states to put the project in the folder that we are located in now. Without this option, an additional subfolder would have been created by default, naming that folder the same as the name provided for the project name. However, doing this would result in no solution file and now no way to run the project through the Visual Studio IDE. Since the objective of this chapter is to demonstrate the use of an IDE, this is the reason we are keeping the preceding tree structure. There are alternative options to doing this, which would lead you down the path in Visual Studio of creating a new project using the <strong class="bold">from existing code</strong> option. This would allow you to create a project using the terminal or command-line window, structuring the folders how you desire and then creating your IDE solution files afterward. Due to the complexity involved in doing that, we will not discuss how to do that. Instead, we can write one line of code in the first <strong class="source-inline">requirements.txt</strong> file in the root of our repository to work with this configuration. </p>
			<p>We will discuss doing that next.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor046"/>Configuring the requirements.txt file(s)</h2>
			<p>In the same<a id="_idIndexMarker213"/> folder that the <strong class="source-inline">manage.py</strong> file is located in, Visual Studio created for us a <strong class="source-inline">requirements.txt</strong> file. In <a href="B17243_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Undertaking a Colossal Project</em>, we already created a blank <strong class="source-inline">requirements.txt</strong> file just so that we can satisfy the needs of Heroku during deployment to each environment that we created. If the <strong class="source-inline">requirements.txt</strong> file in the root of the repository does not exist, Heroku will fail to deploy. Heroku needs that copy in order to identify a project as a Python project; that's just how their test scripts have been written to work. This is why we now have two <strong class="source-inline">requirements.txt</strong> files to work with. The other file, nested one folder down in <strong class="source-inline">/becoming_a_django_entdev/</strong>, is needed to enable all of the features and services that the Visual Studio IDE offers us. This <strong class="source-inline">requirements.txt</strong> file is where we will write all of our required dependencies.</p>
			<p>In the <strong class="source-inline">requirements.txt</strong> file found in the root of your local repository, which is the same folder that your <strong class="source-inline">.git</strong> folder is located in, add the following code:</p>
			<pre class="source-code"><strong class="bold"># ././requirements.txt in Root Directory</strong></pre>
			<pre class="source-code"># Path to Visual Studio requirements.txt below</pre>
			<pre class="source-code">-r becoming_a_django_entdev/requirements.txt</pre>
			<p>The preceding code declares the path to the <strong class="source-inline">requirements.txt</strong> file nested in what we will call the root of our project from now on, <strong class="source-inline">/becoming_a_django_entdev/</strong>. Open the <strong class="source-inline">requirements.txt</strong> file in the root of your project, which is also the same folder that the <strong class="source-inline">manage.py</strong> file resides in, and then add the following items:</p>
			<pre class="source-code"><strong class="bold"># requirements.txt</strong></pre>
			<pre class="source-code">django<strong class="bold">~=</strong>4.0</pre>
			<pre class="source-code">django-extensions</pre>
			<pre class="source-code">django-heroku</pre>
			<pre class="source-code">dj-database-url</pre>
			<pre class="source-code">gunicorn</pre>
			<pre class="source-code">python-dotenv</pre>
			<pre class="source-code">pydotplus</pre>
			<pre class="source-code">psycopg2</pre>
			<pre class="source-code">psycopg2-binary<strong class="bold">==</strong>2.8.6</pre>
			<pre class="source-code">whitenoise</pre>
			<pre class="source-code">secret-key-generator</pre>
			<p>Make sure each item is located on its own line. Any packages that are required for your project will always be put in this file. You can get even more modular and add other imports to these files, for what is called <strong class="bold">cascading requirements files</strong>. This is done the same way, using <strong class="source-inline">-r becoming_a_django_entdev/requirements.txt</strong> to specify the path of the file.</p>
			<p>In the preceding example, the <strong class="source-inline">~=</strong> operator is used and indicates greater than or equal to the version number specified. For example, it will provide Django in the version 4.0 range, meaning it will go to 4.0.9 if that exists but it will not provide 4.1 or higher. It wil<a id="_idTextAnchor047"/>l only provide the highest version of the 4.0.X range. The <strong class="source-inline">==</strong> operator would mean to include the package that matches the exact version number specified. Not denoting any version at all means it will grab the latest version that exists for that package at the time of installation, re-installation, or when an upgrade is performed. Anything you would find in the PyPI package library can be placed in this file, requiring that it be installed in your virtual environment. </p>
			<p>The <strong class="source-inline">django</strong> package is the most important as it is the basis of the framework we are using. The <strong class="source-inline">django-heroku</strong> package is a package created by Heroku that includes a series of other packages that Heroku itself depends on. Those Heroku dependencies will be automatically installed for you when the parent package is installed. The other packages<a id="_idIndexMarker214"/> listed previously will be used in the next sections to help us configure a project properly for how we will be using Django throughout the rest of this book.</p>
			<p>Now that we have defined a number of packages to install into a virtual environment, let's create our virtual environment using the Visual Studio IDE.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor048"/>Using the IDE</h2>
			<p>For those <a id="_idIndexMarker215"/>of<a id="_idIndexMarker216"/> you who wish to use the command line instead, skip ahead to the subsection titled <em class="italic">Using the command line</em>. </p>
			<p>Within your Visual Studio IDE, navigate to the <strong class="bold">Solution Explorer</strong> section of your IDE, right-click where it says <strong class="bold">Python Environments</strong>, and then select <strong class="bold">Add Environment</strong>. The window that opens is shown here:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/Figure_2.04_B17243.jpg" alt="Figure 2.4 – Visual Studio – Add environment&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – Visual Studio – Add environment</p>
			<p>When the<a id="_idIndexMarker217"/> window pops up, enter <strong class="source-inline">virtual_env</strong> as the name of <a id="_idIndexMarker218"/>your virtual environment and choose your base interpreter. This name can be anything you choose but name it <strong class="source-inline">virtual_env</strong> to be consistent with the examples throughout this book. Python version 3.9 was chosen as the base interpreter at the time of creating this exercise. The location is very important, where it asks whether you want to <strong class="bold">Install packages from a file (optional)</strong>; this option refers to the location of your <strong class="source-inline">requirements.txt</strong> file that lives in the same folder as your <strong class="source-inline">manage.py</strong> file. Changing this location may break some of the features of using your IDE, such as operations that work with your virtual environment, and lead you to experience unresolved import issues. Unresolved imports may allow your project to still run, but code highlighting and formatting will often break. You should now see your virtual environment in your <strong class="bold">Solution Explorer</strong> and your <strong class="bold">Python Environments</strong> window within your IDE, as depicted here:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/Figure_2.05_B17243.jpg" alt="Figure 2.5 – Visual Studio – virtual environment a success&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – Visual Studio – virtual environment a success</p>
			<p>If you did want to install packages later, for instance, if someone added a package to the <strong class="source-inline">requirements.txt</strong> file 2 months from now, a developer could right-click on the virtual environment in the <strong class="bold">Solution Explorer</strong> and then select <strong class="bold">Install from requirements.txt</strong>. Visual Studio will then update any versions and install any missing packages. Visual <a id="_idIndexMarker219"/>Studio and pip do not usually remove unused <a id="_idIndexMarker220"/>packages; you may have to manually uninstall a package if you are experiencing conflicts.</p>
			<h3>Running/activating the project</h3>
			<p>By now, everything<a id="_idIndexMarker221"/> we did should allow us to run a project locally because Visual Studio did a lot of the heavy lifting for us. If you decided not to use the IDE, you cannot currently run your project and would have to work through most of this chapter before achieving this result. In either scenario, you will not currently be able to run your project on Heroku. Using the <strong class="bold">Play/Run Web Server</strong> button found at the top of the IDE, select your desired browser, if it provides a dropdown of choices, and then press play, as depicted in the following screenshot: </p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/Figure_2.06_B17243.jpg" alt="Figure 2.6 – Visual Studio – run project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.6 – Visual Studio – run project</p>
			<p>When play is pressed, a command window will open where you can watch any console messages being printed to the screen and a new tab in the browser chosen will also open. The address in the address bar will point to <strong class="source-inline">http://localhost:#####/</strong> and your project should now be running successfully. The port number will usually be a random number. Visual Studio uses a port that it determines is currently unused on your machine and that is also not a default or reserved port, such as <strong class="source-inline">8000</strong>. This is a built-in feature of Visual <a id="_idIndexMarker222"/>Studio for people who run multiple projects side by side, as I often find myself doing. </p>
			<p>If you do not see this button, you can add it to your toolbar by right-clicking a blank space in the toolbar area of Visual Studio. In the dropdown that appears, select <strong class="bold">Standard</strong> from the list of choices. If you select <strong class="bold">Python</strong> from this list, you can include tools that work with your virtual environment directly from your toolbar.</p>
			<p>Along with the command-line window that opens up, the browser you selected will also open with a new tab pointing to <strong class="source-inline">http://127.0.0.1:#####/</strong>, where <strong class="source-inline">#####</strong> is the random port that Visual Studio used. Here, you will see the iconic landing page for a successful Django installation, as depicted in the following screenshot:</p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/Figure_2.07_B17243.jpg" alt="Figure 2.7 – Django installation success&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.7 – Django installation success</p>
			<p>To use the <a id="_idIndexMarker223"/>standard port <strong class="source-inline">8000</strong> with the play button in Visual Studio, pointing to <strong class="source-inline">http://localhost:8000/</strong>, follow the steps in the next subsection.</p>
			<h3>Manually setting a port</h3>
			<p>We can specify <a id="_idIndexMarker224"/>the port number very easily in Visual Studio to control which port each project is using. On the <strong class="bold">Project</strong> tab at the top of your IDE, select <strong class="bold">becoming_a_django_entdev Properties</strong> from the dropdown that appears. On the tab that opens in your editor, click on the <strong class="bold">Debug</strong> tab inside and specify the port number in the field titled <strong class="bold">Port Number</strong>.</p>
			<p>Next, we'll see how to create a virtual environment using the command line.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor049"/>Using the command line</h2>
			<p>For many of you <a id="_idIndexMarker225"/>who prefer the terminal or command-line window, a popular module used to create virtual environments that is available for Windows, Mac, and Linux is called <strong class="source-inline">venv</strong>. </p>
			<p>Follow these steps to create your virtual environment: </p>
			<ol>
				<li value="1">Open up your terminal or command-line window and navigate to the local Git repository that we created in <a href="B17243_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Undertaking a Colossal Project</em>. </li>
				<li>Navigate into your first folder called <strong class="source-inline">becoming_a_django_entdev</strong>. This folder should already exist and be populated with files created when using the command line or IDE to start a project earlier in this chapter:<p class="source-code"><strong class="bold">PS C:\Projects\Packt\Repo&gt; cd becoming_a_django_entdev</strong></p></li>
				<li>In this directory, the same directory that the <strong class="source-inline">manage.py</strong> file lives in, run the following command to create a virtual environment called <strong class="source-inline">virtual_env</strong>:<p class="source-code"><strong class="bold">PS C:\Projects\Packt\Repo\becoming_a_django_entdev&gt; python -m venv virtual_env</strong></p></li>
			</ol>
			<p>The <strong class="source-inline">venv</strong> module should come standard with all Python installations, but if you have problems running this command on any of the three major platforms, visit the documentation found here to help you debug the issue: <a href="https://docs.python.org/3/library/venv.html">https://docs.python.org/3/library/venv.html</a>.</p>
			<ol>
				<li value="4">For Windows, activate your virtual environment:<p class="source-code"><strong class="bold">PS C:\Projects\Packt\Repo\becoming_a_django_entdev&gt; virtual_env/Scripts/activate</strong></p></li>
			</ol>
			<p>Mac and Linux users should jump to the <em class="italic">Activating the virtual environment</em> subsection to learn how to activate a virtual environment on those platforms.</p>
			<ol>
				<li value="5">Next, install the packages defined in the <strong class="source-inline">requirements.txt</strong> file found in the root of a project, where the <strong class="source-inline">manage.py</strong> file lives, by running the following command:<p class="source-code"><strong class="bold">PS C:\Projects\Packt\Repo\becoming_a_django_entdev&gt; pip install -r requirements.txt</strong></p></li>
			</ol>
			<p>An alternative method to creating a virtual environment on Windows, Mac, and Linux is using <strong class="source-inline">virtualenv</strong>, as shown:</p>
			<p class="source-code"><strong class="bold">PS C:\Projects\Packt\Repo\becoming_a_django_entdev&gt; pip install virtualenv</strong></p>
			<p class="source-code"><strong class="bold">PS C:\Projects\Packt\Repo\becoming_a_django_entdev&gt; virtualenv virtual_env</strong></p>
			<p>Now that <a id="_idIndexMarker226"/>we have created a virtual environment for our project, let's activate that virtual environment and run the project next.</p>
			<h3>Activating the virtual environment</h3>
			<p>Instead of using <a id="_idIndexMarker227"/>the IDE, we can activate a virtual environment and run a project directly from the command line. If you already activated your virtual environment in the previous subsection, you can skip this subsection. The following are examples that show how to activate your virtual environment for each major platform (Windows, Mac, and Linux). </p>
			<p>Follow these steps to activate your virtual environment:</p>
			<ol>
				<li value="1">For Windows users, navigate into the root of your project, where the <strong class="source-inline">manage.py</strong> file is located, and then activate your virtual environment by using the following command:<p class="source-code"><strong class="bold">PS C:\Projects\Packt\Repo\becoming_a_django_entdev&gt; virtual_env/Scripts/activate</strong></p></li>
				<li>Mac and Linux users will need to run the following command instead:<p class="source-code"><strong class="bold">PS C:\Projects\Packt\Repo\becoming_a_django_entdev&gt; source virtual_env/bin/activate</strong></p></li>
			</ol>
			<p>If successful, you will now see the following prompt in your terminal, waiting for the next command to be executed from within your virtual environment:</p>
			<p class="source-code">(virtual_env) PS C:\Projects\Packt\Repo\becoming_a_django_entdev&gt;</p>
			<p>You can only execute standard Django management commands when your virtual environment is activated.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">From now on, the preceding example will be depicted as the following in order to save space, remove clutter, and prevent confusion when providing terminal or command-line examples from within an active virtual environment:</p>
			<p class="callout"><strong class="source-inline">(virtual_env) PS &gt;</strong></p>
			<p>Now that the virtual environment is activated, let's run our project.</p>
			<h3>Running the project</h3>
			<p>If you decided to <a id="_idIndexMarker228"/>create your project using the command line and not the Visual Studio IDE, you will not currently be able to run your project. This is because Visual Studio created a local SQLite database, made any necessary migrations, and migrated them automatically for every package that we included in the <strong class="source-inline">requirements.txt</strong> file. For reference, the command to run your project is shown in the following code snippet. You will have to work through the exercises found in the <em class="italic">PostgreSQL</em> section of this chapter to configure your database before successfully executing the following command. You can come back to this section after having done that. </p>
			<p>Making sure you are still in the same folder as the <strong class="source-inline">manage.py</strong> file and that your virtual environment is a<a id="_idTextAnchor050"/>ctive, execute the <strong class="source-inline">runserver</strong> command shown here:</p>
			<p class="source-code">(virtual_env) PS &gt; python manage.py runserver</p>
			<p>If this was successful, you will then see the following information printed in your terminal. Whenever you load a page and your project is running, you will see all messages that get printed to the screen in this terminal:</p>
			<p class="source-code">Watching for file changes with StatReloader</p>
			<p class="source-code">Performing system checks...</p>
			<p class="source-code">System check identified no issues (0 silenced).</p>
			<p class="source-code">Django version 2.2.24, using settings 'becoming_a_django_entdev.settings'</p>
			<p class="source-code">Starting development server at http://127.0.0.1:8000/</p>
			<p class="source-code">Quit the server with CTRL-BREAK.</p>
			<h3>Manually setting a port</h3>
			<p>Manually specifying a<a id="_idIndexMarker229"/> port number is easy using the terminal or command-line window. However, this must be done every time we run the project, unlike in the IDE where we set it in the configuration of the project within the IDE. The following example adds a port number option to the same <strong class="source-inline">runserver</strong> command used in the previous section, stating to use port <strong class="source-inline">8000</strong> to<a id="_idIndexMarker230"/> run the project:</p>
			<p class="source-code">(virtual_env) PS &gt; python manage.py runserver 8000</p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor051"/>Project configuration</h1>
			<p>All projects need<a id="_idIndexMarker231"/> configuring in some way to work with all of the packages and hosts that are involved. We will take the project that we just created and configure files such as <strong class="source-inline">settings.py</strong>, <strong class="source-inline">.env</strong>, <strong class="source-inline">procfile</strong>, and <strong class="source-inline">.gitignore</strong>. Take the <strong class="source-inline">settings.py</strong> file—this file or files will store all of the global constants that are used throughout the code of your project. When packages are used, they usually provide a way to customize the behavior of that package from within the main settings file. Other files, such as <strong class="source-inline">.env</strong> and <strong class="source-inline">procfile</strong>, will be used to prevent deployment issues when working with Heroku as the host. Currently, we would not be able to deploy successfully to the Heroku environment as we have created the project files. Work through the following configuration sections before attempting a successful deployment.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor052"/>Django settings.py file</h2>
			<p>In the <strong class="source-inline">settings.py</strong> file <a id="_idIndexMarker232"/>that was automatically <a id="_idIndexMarker233"/>generated for us when we created a project, we need to add settings specific to our project. </p>
			<p>Follow these steps to configure your project settings:</p>
			<ol>
				<li value="1">At the top of the <strong class="source-inline">settings.py</strong> file, add <strong class="source-inline">import django_heroku</strong> just below the first two imports that exist. Also, add <strong class="source-inline">import dotenv</strong> and <strong class="source-inline">dj_database_url</strong>. These two packages will be used to establish a database connection. The top of your <strong class="source-inline">settings.py</strong> file should look as in the following example: <p class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></p><p class="source-code">import os</p><p class="source-code">import posixpath</p><p class="source-code"><strong class="bold">import django_heroku</strong></p><p class="source-code"><strong class="bold">import dj_database_url</strong></p><p class="source-code"><strong class="bold">import dotenv</strong></p></li>
			</ol>
			<p>Note, that some systems may display <strong class="source-inline">from pathlib import Path</strong> at the top of their files instead of <strong class="source-inline">import os</strong> and <strong class="source-inline">import posixpath</strong>. </p>
			<p>At the bottom of the <strong class="source-inline">settings.py</strong> file, add the following code: </p>
			<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></p>
			<p class="source-code"><strong class="bold">...</strong></p>
			<p class="source-code"><strong class="bold">django_heroku</strong>.settings(locals())</p>
			<p>This statement will import Heroku-specific settings from the <strong class="source-inline">django_heroku</strong> package. </p>
			<ol>
				<li value="2">In order<a id="_idIndexMarker234"/> for your DNS to work <a id="_idIndexMarker235"/>properly, you will need to tell Django that you are allowing a host to gain access to this site. This is a built-in security feature of Django that is intended to block <a id="_idIndexMarker236"/>common <strong class="bold">HTTP Host Header Attacks</strong>. We also need to add the URLs of each of the Heroku apps to make sure those databases will function properly. Your <strong class="source-inline">ALLOWED_HOSTS</strong> should look similar to the following example:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></p><p class="source-code">...</p><p class="source-code">ALLOWED_HOSTS = [</p><p class="source-code">    'your-domain.com',</p><p class="source-code">    'www.your-domain.com',</p><p class="source-code">    'dev.your-domain.com',</p><p class="source-code">    'staging.your-domain.com',</p><p class="source-code">    'becoming-an-entdev.herokuapp.com',</p><p class="source-code">    'mighty-sea-09431.herokuapp.com',</p><p class="source-code">    'pure-atoll-19670.herokuapp.com',</p><p class="source-code">]</p></li>
			</ol>
			<p>Some options that are available include a wildcard such as the asterisk character (<strong class="source-inline">*</strong>), which will allow anything. However, this is not considered a best practice and is extremely insecure. If a domain starts with a single period, like the second entry of the following example, it will also act as a wildcard, allowing all subdomains of the corresponding parent domain. Use these wildcard options with caution <a id="_idIndexMarker237"/>if you decide to use them at<a id="_idIndexMarker238"/> all:</p>
			<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></p>
			<p class="source-code">...</p>
			<p class="source-code">ALLOWED_HOSTS = [</p>
			<p class="source-code">    '<strong class="bold">*</strong>',</p>
			<p class="source-code">    '<strong class="bold">.</strong>your-domain.com',</p>
			<p class="source-code">]</p>
			<ol>
				<li value="3">Starting with Django 3.2, we have to add a variable to the settings file named <strong class="source-inline">DEFAULT_AUTO_FIELD</strong>. Prior to this version of Django, this was not necessary. This setting tells Django how to process and handle all primary keys of objects. Without this setting, we would otherwise have to add a field called <strong class="source-inline">id = models.AutoField(primary_key=True)</strong> to every model class that we created. Since this is a daunting task, we can avoid it altogether by using the following example, placed anywhere in our <strong class="source-inline">settings.py</strong> file:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></p><p class="source-code"><strong class="bold">...</strong></p><p class="source-code"><strong class="bold">DEFAULT_AUTO_FIELD = 'django.db.models.AutoField'</strong></p></li>
			</ol>
			<p>For now, let's just leave the default <strong class="source-inline">DATABASES = {...}</strong> setting as it is. In the <em class="italic">Preparing PostgreSQL for Heroku</em> section of this chapter, we will discuss changing this setting for our particular use case. Other examples will be provided for all the supported database types, providing a quick reference when working on a project that does not<a id="_idIndexMarker239"/> follow along with every example<a id="_idIndexMarker240"/> in this book.</p>
			<p>Let's create our environment files next.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor053"/>Creating an environment file</h2>
			<p>Heroku will use<a id="_idIndexMarker241"/> an environment file called <strong class="source-inline">.env</strong> to<a id="_idIndexMarker242"/> store environment-related variables that are used when running a project in each environment. We use this to tell Heroku things such as what database is being used for each environment or if debug should be turned on/off. Heroku recommends that we use SQLite locally for a Django/PostgreSQL setup but not in their environment apps. It can be configured to use PostgreSQL locally, which we will demonstrate near the end of this chapter. Even if you are using SQLite3 locally, you still need to install the PostgreSQL software suite on your machine in order for the drivers to work with all of your remote connections. We will need to walk through the rest of configuring a project before we can discuss setting up PostgreSQL for use locally.</p>
			<h3>Local variables</h3>
			<p>To create<a id="_idIndexMarker243"/> your local variables, follow these steps:</p>
			<ol>
				<li value="1">Run the following command from your project's root directory, where your <strong class="source-inline">manage.py</strong> file exists:<p class="source-code"><strong class="bold">(virtual_env) PS &gt; echo 'DATABASE_URL=sqlite:///db.sqlite3' &gt; .env</strong></p></li>
			</ol>
			<p>The <strong class="source-inline">echo</strong> statement is used to create a new file called <strong class="source-inline">.env</strong> with a single line of content, that content being <strong class="source-inline">DATABASE_URL=sqlite:///db.sqlite3</strong>. </p>
			<p>Windows users might experience an error message such as <strong class="source-inline">UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte</strong> when trying to run the preceding command. There is an encoding issue that often arises on Windows machines that triggers this kind of error. To overcome this, open your <strong class="source-inline">.env</strong> file in Notepad++, go to the <strong class="bold">Encoding</strong> dropdown, select <strong class="bold">UTF-8</strong> from the list of choices, and then save. If that fails, which is possible, just delete the file and recreate it from scratch using Notepad++ to create the file, using the proper encoding. </p>
			<ol>
				<li value="2">Whichever way this file was created, make sure the following line of code is in your local <strong class="source-inline">.env</strong> file:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/.env</strong></p><p class="source-code">DATABASE_URL = <strong class="bold">sqlite:///db.sqlite3</strong></p></li>
			</ol>
			<p>The code we placed in this file points to the location of your SQLite3 database file called <strong class="source-inline">db.spqlite3</strong>. If you didn't use the Visual Studio IDE to create your project, this<a id="_idIndexMarker244"/> file will not exist yet and your project will not currently run. </p>
			<ol>
				<li value="3">We can also add other variables to this file, and then access those variables using the <strong class="source-inline">python-dotenv</strong> package in the <strong class="source-inline">settings.py</strong> file. To access these variables, we have to load the <strong class="source-inline">.env</strong> file in the <strong class="source-inline">settings.py</strong> file using the following example:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></p><p class="source-code"><strong class="bold">...</strong></p><p class="source-code"><strong class="bold">import dotenv</strong></p><p class="source-code"><strong class="bold">BASE_DIR = os.path.dirname(</strong></p><p class="source-code"><strong class="bold">    os.path.dirname(os.path.abspath(__file__))</strong></p><p class="source-code"><strong class="bold">)</strong></p><p class="source-code"><strong class="bold">dotenv_file = os.path.join(BASE_DIR, ".env")</strong></p><p class="source-code"><strong class="bold">if os.path.isfile(dotenv_file):</strong></p><p class="source-code"><strong class="bold">    dotenv.load_dotenv(dotenv_file)</strong></p><p class="source-code">SECRET_KEY = <strong class="bold">os.getenv('SECRET_KEY')</strong></p></li>
			</ol>
			<p>Place the highlighted code somewhere near the top of the <strong class="source-inline">settings.py</strong> file, just below the existing <strong class="source-inline">BASE_DIR</strong> variable. In this example, we also replaced the string value of the <strong class="source-inline">SECRET_KEY</strong> variable with <strong class="source-inline">os.getenv('SECRET_KEY'), with</strong> <strong class="source-inline">os.getenv()</strong> we can access any variable found in the <strong class="source-inline">.env</strong> file. </p>
			<ol>
				<li value="4">We need to add the string value of the <strong class="source-inline">SECRET_KEY</strong> variable that was in the <strong class="source-inline">settings.py</strong> file to the <strong class="source-inline">.env</strong> file in order for our project to work locally. Write your variable using the following example, without quotation marks for any string values found in this file: <p class="source-code"><strong class="bold"># /becoming_a_django_entdev/.env</strong></p><p class="source-code"><strong class="bold">...</strong></p><p class="source-code"><strong class="bold">SECRET_KEY = my_randomly_generated_key</strong></p></li>
			</ol>
			<p>That's it, our local <a id="_idIndexMarker245"/>variables are now configured. Let's configure our remote variables next.</p>
			<h3>Remote variables</h3>
			<p>Remote variables<a id="_idIndexMarker246"/> are the same local <strong class="source-inline">.env</strong> variables that we created, now with values that pertain to each remote environment. Since we will be ignoring the <strong class="source-inline">.env</strong> file in our repository, which we will discuss in the subsection titled <em class="italic">Creating a .gitignore file</em>, we need to manually create the <strong class="source-inline">SECRET_KEY</strong> variable inside of the <strong class="source-inline">.env</strong> file for each Heroku environment that exists. Since Heroku already created these <strong class="source-inline">.env</strong> files for us, we will just use this as an opportunity to add the variables that are needed. These steps can also be used at any time during the SDLC to add variables as they are needed.</p>
			<p>To add your remote variables, use the Heroku <strong class="bold">Command-Line Interface</strong> (<strong class="bold">CLI</strong>) to log into your Heroku account and replace the app name provided in the following code block with your Heroku app name:</p>
			<p class="source-code">(virtual_env) PS &gt; heroku login</p>
			<p class="source-code">(virtual_env) PS &gt; heroku config:add SECRET_KEY=my_randomly_generated_key --app becoming-an-entdev</p>
			<p class="source-code">(virtual_env) PS &gt; heroku config:add SECRET_KEY=my_randomly_generated_key --app mighty-sea-09431</p>
			<p class="source-code">(virtual_env) PS &gt; heroku config:add SECRET_KEY=my_randomly_generated_key --app pure-atoll-19670</p>
			<p>In the preceding code, one example is provided for each of the three environments that exist. Execute them one at a time for each of your environments. </p>
			<p>It is best to provide a different <strong class="source-inline">SECRET_KEY</strong> value for each environment. In <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, after we discuss working with the Django shell in the subsection titled <em class="italic">Generating a SECRET_KEY variable</em>, we will explore how to generate a <strong class="source-inline">SECRET_KEY</strong> variable in a safer way. Adding that <strong class="source-inline">SECRET_KEY</strong> variable to each Heroku <a id="_idIndexMarker247"/>environment will still be done as in t<a id="_idTextAnchor054"/>his section.</p>
			<p>Next, let's create a <strong class="bold">Procfile</strong>, short for <strong class="bold">process file</strong>.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor055"/>Creating a Procfile</h2>
			<p>A <strong class="bold">Procfile</strong> is <a id="_idIndexMarker248"/>used to store additional project-related<a id="_idIndexMarker249"/> settings. Heroku uses the concept of containerization to host all of their apps for all of their clients. This is why we need to create a file with no file extension named <strong class="source-inline">procfile</strong> located in the root of a repository, where the <strong class="source-inline">.git</strong> folder is located. This file tells Heroku where the rest of your project's files live, specifically, the location of the <strong class="source-inline">wsgi.py</strong> or <strong class="source-inline">asgi.py</strong> file inside of the <strong class="source-inline">procfile</strong> file, using standard Python path syntax. The <strong class="source-inline">wsgi.py</strong> file is commonly found in the <strong class="source-inline">project_name</strong> folder of any Django project, upon creation; that folder is found in the same folder that the <strong class="source-inline">manage.py</strong> file resides in. If you wanted to use an asynchronous server gateway interface, you would specify the location of the <strong class="source-inline">asgi.py</strong> file instead.</p>
			<p>Hypothetically speaking, if the <strong class="source-inline">manage.py</strong> file and the Django project folder lived in the same folder as the root of a repository, we would include the following path inside of that procfile:</p>
			<pre class="source-code"><strong class="bold"># ./Procfile in Root of Repository</strong></pre>
			<pre class="source-code">web: gunicorn becoming_a_django_entdev.wsgi</pre>
			<p>Our project files are nested one level deep in the <strong class="source-inline">/becoming_a_django_entdev/</strong> folder, as was done using the IDE or when using the <strong class="source-inline">startproject</strong> command to create a project earlier in this chapter. If we tried to add this directory using standard Python path syntax, we would have problems during deployment to Heroku. Instead, in one line of code, tell Heroku to change directory first and then execute the preceding command, using the follo<a id="_idTextAnchor056"/>wing code example:</p>
			<pre class="source-code"><strong class="bold"># ./Procfile in Root of Repository</strong></pre>
			<pre class="source-code">web: <strong class="bold">sh -c 'cd ./becoming_a_django_entdev/ &amp;&amp; exec</strong> gunicorn becoming_a_django_entdev.wsgi --log-file -'</pre>
			<p>Please use the second example. Only use the first example if you have structured your project to live in the root of your repository and are likely not using Heroku as your host. Heroku will also fail to deploy without the <strong class="source-inline">--log-file –</strong> parameter shown previously. With the <strong class="source-inline">log</strong> parameter, you may read deployment errors from within your Heroku<a id="_idIndexMarker250"/> dashboard<a id="_idIndexMarker251"/> for each app.</p>
			<p>Next, we need to control how the static files are managed when Django is used with Heroku.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor057"/>Django static files</h2>
			<p>Traditionally, we <a id="_idIndexMarker252"/>do not need to modify the settings <a id="_idIndexMarker253"/>files to allow Django to work with static files in a project. In our case, we will need to add to the settings that exist in order for Heroku to work with them. Heroku uses a package called <strong class="source-inline">whitenoise</strong>, installed in the <strong class="source-inline">requirements.txt</strong> file, to work with your static files. These are files such as a <strong class="source-inline">.css</strong>, <strong class="source-inline">.js</strong>, image, or font files that are found in any Django app's <strong class="source-inline">static</strong> folder.</p>
			<p>Follow these steps to configure your project to work with the <strong class="source-inline">whitenoise</strong> package:</p>
			<ol>
				<li value="1">Add the following line to the <strong class="source-inline">MIDDLEWARE</strong> setting found in your <strong class="source-inline">settings.py</strong> file. Add it below any item that already exists in that list: <p class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></p><p class="source-code">...</p><p class="source-code">MIDDLEWARE = [</p><p class="source-code">    ...,</p><p class="source-code">    'whitenoise.middleware.WhiteNoiseMiddleware',</p><p class="source-code">]</p></li>
				<li>Heroku will also need us to add a variable called <strong class="source-inline">STATICFILES_STORAGE</strong>. Add this variable to your <strong class="source-inline">settings.py</strong> file just above your <strong class="source-inline">STATIC_URL</strong> and <strong class="source-inline">STATIC_ROOT</strong> variables, as shown:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></p><p class="source-code"><strong class="bold">...</strong></p><p class="source-code"><strong class="bold">STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'</strong></p><p class="source-code">STATIC_URL = '/staticfiles/'</p><p class="source-code">STATIC_ROOT = posixpath.join(</p><p class="source-code">    *(BASE_DIR.split(os.path.sep) + ['staticfiles'])</p><p class="source-code">)</p></li>
				<li>Change the value of your <strong class="source-inline">STATIC_URL</strong> and <strong class="source-inline">STATIC_ROOT</strong> variables to equal what is shown in the preceding code, if your value has not already changed.</li>
			</ol>
			<p>Our static<a id="_idIndexMarker254"/> files <a id="_idIndexMarker255"/>should now be wired up properly. At this point in time, we have configured everything locally in order to successfully deploy to any of our remote Heroku environments. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">In Django, when a project is run locally, with <strong class="source-inline">DEBUG = False</strong>, static files will fail to load even if they appear in your remote environments. The reason why this happens is that the server is usually configured to handle how it serves up your static files versus Django controlling that, similar to how Heroku uses the <strong class="source-inline">whitenoise</strong> package to serve up its static files. The <strong class="source-inline">whitenoise</strong> package is also used to serve up static files locally when <strong class="source-inline">DEBUG</strong> is set to <strong class="source-inline">False</strong>.</p>
			<p>Let's wire up our media files next.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor058"/>Django media files</h2>
			<p>Similar to the<a id="_idIndexMarker256"/> static <a id="_idIndexMarker257"/>files, media file paths need to be configured in order to work with the <strong class="source-inline">whitenoise</strong> package and Heroku. Media files are considered anything that the user uploads to your system, such as an image, audio file, or another document. The two variables, <strong class="source-inline">MEDIA_URL</strong> and <strong class="source-inline">MEDIA_ROOT</strong>, are defined in Django by default as empty strings; we just need to set their values to point to the media folder that we want to place them in. In addition to these settings, additional steps may also be necessary to work with Heroku and media files. Please refer to the detailed Python guide found here to learn more: <a href="https://devcenter.heroku.com/articles/s3-upload-python">https://devcenter.heroku.com/articles/s3-upload-python</a>. </p>
			<p>To define your media-related variables, in your <strong class="source-inline">settings.py</strong> file, just below your <strong class="source-inline">STATIC_URL</strong> and <strong class="source-inline">STATIC_ROOT</strong> variables, include the following two variables:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></pre>
			<pre class="source-code"><strong class="bold">…</strong></pre>
			<pre class="source-code"><strong class="bold">MEDIA_URL = '/media/'</strong></pre>
			<pre class="source-code"><strong class="bold">MEDIA_ROOT = posixpath.join(</strong></pre>
			<pre class="source-code"><strong class="bold">    *(BASE_DIR.split(os.path.sep) ['media'])</strong></pre>
			<pre class="source-code"><strong class="bold">)</strong></pre>
			<p>That's it, this is all that we need to configure in our <strong class="source-inline">settings.py</strong> file to wire up static and media files. In <a href="B17243_04_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 4</em></a>, <em class="italic">URLs, Views, and Templates</em>, in the subsection titled <em class="italic">Function – static()</em>, we will need to configure additional URL patterns before these are considered fully integrated into our project.</p>
			<p>Before we attempt to deploy, we need to create the <strong class="source-inline">.gitignore</strong> file, which was mentioned earlier, as well as working through the <em class="italic">Preparing PostgreSQL for Heroku</em> section of this chapter.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor059"/>Creating a .gitignore file</h2>
			<p>The last<a id="_idIndexMarker258"/> file <a id="_idIndexMarker259"/>that we want to create before we deploy is a <strong class="source-inline">.gitignore</strong> file so that we can share only what we want and leave out things like all of those bulky files that are now seen in the <strong class="source-inline">virtual_env</strong> and <strong class="source-inline">.vs</strong> folders. This file will be used to ensure we don't accidentally push any unwanted code to our remote repositories. Once a file has been pushed to a repository, it will always be tracked until it has been deleted; so, we want to make sure we do this first. It's a good idea to also ignore the <strong class="source-inline">.suo</strong> files created by Visual Studio. These files contain user-specific information, such as breakpoint and debugger watches. You will also want to ignore any <strong class="source-inline">build</strong>, <strong class="source-inline">bin</strong>, and <strong class="source-inline">log</strong> files that do not need to be shared with other developers. This is also where we will define a pattern to ignore the <strong class="source-inline">.env</strong> file, which defines the environment-specific variables. We will be creating the <strong class="source-inline">.env</strong> files in development, staging, and production soon when we get to the <em class="italic">PostgreSQL</em> subsection of this chapter, which will be needed to successfully deploy.</p>
			<p>Create a file called <strong class="source-inline">.gitignore</strong> in the root of your repository, where your <strong class="source-inline">.git</strong> folder resides. Then, add <a id="_idIndexMarker260"/>the items shown here. They <a id="_idIndexMarker261"/>will serve as your ignore patterns: </p>
			<pre class="source-code"><strong class="bold"># ./.gitignore in Root of Repository</strong></pre>
			<pre class="source-code"># Keep Rule</pre>
			<pre class="source-code">!gitkeep.txt</pre>
			<pre class="source-code"># Django #</pre>
			<pre class="source-code">db.sqlite3</pre>
			<pre class="source-code">*.log</pre>
			<pre class="source-code">*.pyc</pre>
			<pre class="source-code">__pycache__</pre>
			<pre class="source-code"># Media – User Generated Content #</pre>
			<pre class="source-code">media/</pre>
			<pre class="source-code"># Environments #</pre>
			<pre class="source-code">.env</pre>
			<pre class="source-code">virtual_env/</pre>
			<pre class="source-code"># Visual Studio and Visual Studio Code #</pre>
			<pre class="source-code">*.suo</pre>
			<pre class="source-code">*.pyproj</pre>
			<pre class="source-code">*.pyproj.user</pre>
			<pre class="source-code">*.history</pre>
			<pre class="source-code">.vs/</pre>
			<pre class="source-code">obj/</pre>
			<pre class="source-code"># Heroku</pre>
			<pre class="source-code">staticfiles/</pre>
			<p>These are just a few examples that relate to our specific Heroku/Django and Visual Studio configuration. Your <strong class="source-inline">.gitignore</strong> file can contain many more ignore patterns. In the source code provided with this book, many other ignore patterns have been provided as<a id="_idIndexMarker262"/> examples, broken down into categories <a id="_idIndexMarker263"/>that you are welcome to use if you need to.</p>
			<p>Ignore patterns accept wildcards such as the asterisk (<strong class="source-inline">*</strong>) that is used in the preceding examples. They also accept an exclude operator denoted by the exclamation mark (<strong class="source-inline">!</strong>) symbol. The<strong class="source-inline">!gitkeep.txt</strong> pattern is commonly used in situations where an empty folder is needed to live in a repository, such as the media folder. Git will automatically ignore a folder if nothing exists inside of it; if we place a <strong class="source-inline">gitkeep.txt</strong> file inside that media folder, we can get around this dilemma when ignoring everything within that folder. The media folder is used for user-generated content but we do not want to track files that get placed inside of it. Some of these empty folders are actually needed to prevent errors during runtime, such as when uploading an image to the system and the media folder does not exist yet. Sometimes, this can prevent a fresh clone of a repository from running properly for the first time altogether, depending on the existence of that folder.</p>
			<p>You may now push your code to development, staging, or production as you see fit. Just be aware of what remote environment and branch you are pushing to or pulling from, when you perform your Git operations. When this is done, you can visit your Heroku dashboard as was discussed in <a href="B17243_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Undertaking a Colossal Project</em>, to see whether a<a id="_idIndexMarker264"/> deployment was successful, and<a id="_idIndexMarker265"/> if not, read the logs to see why it failed. </p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor060"/>Creating a Django app</h2>
			<p>In Django, the<a id="_idIndexMarker266"/> entire set of files from the folder where your <strong class="source-inline">manage.py</strong> file is located is considered your project. Your project can contain many apps, where an <strong class="bold">app</strong> in Django is considered a process that does something within your project, such as logging, trivia, or record keeping, to name a few processes. They can also be something simple, such as a special form field or an event listener that comes from a PyPI package, where that particular package is essentially considered a Django app that we are installing. </p>
			<p>Apps are where we write models, views, test cases, forms, admin classes, HTML templates, and static files pertinent to that app. Apps are also where the bulk of the code in a project will exist. They are also designed to be modular where an app can be shared in many projects if we want to. Next, we will create an app for ourselves and call it <strong class="source-inline">chapter_2</strong>. Every upcoming chapter will follow the same app naming convention. We will attempt to organize apps by the content of each chapter in this book. Some chapters may involve every file of the project, which is the case for this chapter of this book. This is because, in this chapter, we are working with the global files of a project. Choose the route you would like to use to create your app, whether that is using the IDE or the command-line-driven approach.</p>
			<h3>Using the IDE</h3>
			<p>To create an app<a id="_idIndexMarker267"/> easily, right-click the name of your project in the <strong class="bold">Solution Explorer</strong>, called <strong class="bold">becoming_a_django_entdev</strong>, and then click <strong class="bold">Add</strong> | <strong class="bold">Django App…</strong>. When prompted to do so, enter the name <strong class="source-inline">chapter_2</strong>, as shown here:</p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/Figure_2.08_B17243.jpg" alt="Figure 2.8 – Visual Studio – adding app&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.8 – Visual Studio – adding app</p>
			<p>In Visual Studio, you can select any folder or subfolder within your project to create a Django app in. Just right-click the folder you want to create that app in instead of the one described previously if you wish to structure your project in a different way.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Visual Studio will install apps using the version of Django that was installed or updated in the virtual environment. There is no special version 2.1.2 use case like before when we created a project through the IDE; the version of the app files to be installed will be Django 4.0. Also note that you can create an app using the IDE in any directory found in your project root. You <a id="_idIndexMarker268"/>are not limited to installing them in the directory used in this exercise.</p>
			<p>Let's create a Django app using the command line next.</p>
			<h3>Using the command line</h3>
			<p>To create a<a id="_idIndexMarker269"/> Django app using the command line, you first need to create the folder structure for that new app. Here, we want it to mimic exactly how the IDE created its folder structure in the previous exercise, to make sure each approach produces the same results and works with the rest of the book. From the same folder that the <strong class="source-inline">manage.py</strong> file lives in, make sure your virtual environment is activated and run the following create folder command. Then, execute the traditional <strong class="source-inline">startapp</strong> command shown after, to create the app called <strong class="source-inline">chapter_2</strong>:</p>
			<p class="source-code">(virtual_env) PS &gt; mkdir becoming_a_django_entdev/chapter_2</p>
			<p class="source-code">(virtual_env) PS &gt; python manage.py startapp chapter_2 becoming_a_django_entdev/chapter_2</p>
			<p>In the preceding examples, we first created the <strong class="source-inline">chapter_2</strong> folder with the <strong class="source-inline">mkdir</strong> command and then executed the <strong class="source-inline">startapp</strong> command. We also provided a parameter that designates the folder that the app will be installed into, the same folder that Visual Studio placed it in for us. Again, you are not limited to installing apps in this directory— adjust where <a id="_idIndexMarker270"/>needed throughout this book if you created your folder structure in a different way. </p>
			<h3>Activating a new Django app</h3>
			<p>Once a Django <a id="_idIndexMarker271"/>app has been created, it will not automatically work in your project until you actually include it as an installed application within Django. </p>
			<p>To activate your app, follow these steps:</p>
			<ol>
				<li value="1">All Django apps must be included in the <strong class="source-inline">INSTALLED_APPS</strong> list. Add your chapter app, as shown:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></p><p class="source-code">...</p><p class="source-code">INSTALLED_APPS = [</p><p class="source-code">    ...</p><p class="source-code"> 'django_extensions',</p><p class="source-code">  <strong class="bold">'becoming_a_django_entdev.chapter_2',</strong></p><p class="source-code">]</p><p class="source-code"><strong class="bold">DEFAULT_AUTO_FIELD'= 'django.db.models.AutoField'</strong></p></li>
				<li>Sometimes, it is necessary to tell Django where to look for your app in your directory tree. In the <strong class="source-inline">apps.py</strong> file of the app you just created, you can specify the location of your app using standard Python path syntax. Modify the value of the <strong class="source-inline">name =</strong> variable in the following example:  <p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_2/apps.py</strong></p><p class="source-code">from django.apps import AppConfig</p><p class="source-code">class <strong class="bold">chapter_2Config</strong>(AppConfig):</p><p class="source-code">    name= '<strong class="bold">becoming_a_django_entdev.chapter_2</strong>'</p></li>
			</ol>
			<p>Note that you will have to do this for all future chapter apps that you create.</p>
			<p>The project's file structure should now look like the following tree, with the highlighted items being the<a id="_idIndexMarker272"/> additions that we have made since we began configuring the virtual environment:</p>
			<p><strong class="source-inline">├── .git</strong></p>
			<p><strong class="source-inline">├── .gitignore</strong></p>
			<p><strong class="source-inline">├── procfile</strong></p>
			<p><strong class="source-inline">├── requirements.txt</strong></p>
			<p><strong class="source-inline">├── readme.md</strong></p>
			<p><strong class="source-inline">├── becoming_a_django_entdev</strong></p>
			<p><strong class="source-inline">│   ├── .vs</strong></p>
			<p><strong class="source-inline">│   ├── becoming_a_django_entdev.sln</strong></p>
			<p><strong class="source-inline">│   ├── db.sqlite3</strong></p>
			<p><strong class="source-inline">│   ├── manage.py</strong></p>
			<p><strong class="source-inline">│   ├── media</strong></p>
			<p><strong class="source-inline">│   ├── obj</strong></p>
			<p><strong class="source-inline">│   ├── requirements.txt</strong></p>
			<p><strong class="source-inline">│   ├── virtual_env</strong></p>
			<p><strong class="source-inline">│   ├── staticfiles</strong></p>
			<p><strong class="source-inline">│   └── becoming_a_django_entdev</strong></p>
			<p><strong class="source-inline">│       ├── chapter_2</strong></p>
			<p><strong class="source-inline">│       ├── __init__.py</strong></p>
			<p><strong class="source-inline">│       ├── asgi.py</strong></p>
			<p><strong class="source-inline">│       ├── settings.py</strong></p>
			<p><strong class="source-inline">│       ├── urls.py</strong></p>
			<p><strong class="source-inline">│       └── wsgi.py</strong></p>
			<p>Next, let's discuss the different types of databases supported by Django.</p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor061"/>Using basic database settings</h1>
			<p>A website by itself is far <a id="_idIndexMarker273"/>from useful without a database to talk to; this is why the Visual Studio IDE comes with a lightweight and portable SQLite3 database. Visual Studio will create a file called <strong class="source-inline">db.sqlite3</strong> in the same folder as your <strong class="source-inline">manage.py</strong> file whenever the <strong class="source-inline">startproject</strong> command is executed. If you created your project using the terminal or command-line window, then you will not have a SQLite database that is used in the following configuration examples, and if you attempt to run your project without this database, it will fail. This is one of the five standard database types that Django directly supports. Database types other than the five types that Django directly supports can also be used. We will also provide an example of how to configure other types of databases, such as the Microsoft SQL Server database. Types that are not any of the five standard types will require using a different engine than the engines that Django provides, which means you will need to find a PyPI package to install or write your own for the database type that you are supporting.</p>
			<p>The five standard <a id="_idIndexMarker274"/>Django database types are as follows:</p>
			<ul>
				<li><strong class="bold">SQLite</strong></li>
				<li><strong class="bold">MySQL</strong></li>
				<li><strong class="bold">MariaDB</strong></li>
				<li><strong class="bold">Oracle</strong></li>
				<li><strong class="bold">PostgreSQL</strong></li>
			</ul>
			<p>The following examples will help you to configure an existing database of your choice. The last example, PostgreSQL, will be the type used when moving forward with the examples of this chapter. You may use any type for the remaining chapters of this book. There is more to using a database, such as creating tables and performing queries, that will be discussed in the chapters to come. These examples relate to settings written just to establish a working connection to your database, whether that connection is local or remote.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor062"/>SQLite</h2>
			<p>SQLite is <a id="_idIndexMarker275"/>a <strong class="bold">Relational Database Management System</strong> (<strong class="bold">RDBMS</strong>) based <a id="_idIndexMarker276"/>on the C language. It is <a id="_idIndexMarker277"/>extremely lightweight and portable and is sometimes referred to as the <em class="italic">on-disk</em> method of choice when it comes to database management. This is the method of choice to get a <em class="italic">proof-of-concept</em> project up and running in a very short amount of time. This database type can even be shared on drives and repositories for quick transportation and portability of the project and its data. This is not recommended if security is as important to you as it should be. </p>
			<p>There are a lot of problems with using this database type in real-world applications and in combination with Heroku like we are doing to host the app. You may find that you can get it to work in a remote Heroku environment momentarily. However, each deployment of your app throughout its life cycle will result in the complete loss of data. For this reason, we will have to deviate from the standard database that comes with Django and rely on a more robust database system for our environment instead.</p>
			<p>A standard SQLite3 database configuration will look like the following example:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">DATABASES = {</pre>
			<pre class="source-code">    'default': {</pre>
			<pre class="source-code">        'ENGINE': '<strong class="bold">django.db.backends.sqlite3</strong>',</pre>
			<pre class="source-code">        'NAME': <strong class="bold">os.path.join(BASE_DIR, 'db.sqlite3')</strong>,</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Add additional <strong class="source-inline">default</strong> parameters as needed.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor063"/>MySQL</h2>
			<p>MySQL is<a id="_idIndexMarker278"/> a more <a id="_idIndexMarker279"/>robust SQL RDBMS. It is open source and, just like SQLite, it is compatible with Windows, Mac, and Linux systems. It is made to work as a client-server model, meaning the software is installed on the client's machine in order to perform request operations that the server side will listen to and respond to. MySQL has become one of the most popular and most used database types of all time, especially if you consider all the other database choices that were built using a fork of MySQL. </p>
			<p>Follow these steps to configure your MySQL database connection:</p>
			<ol>
				<li value="1">A standard <a id="_idIndexMarker280"/>connection to a MySQL database <a id="_idIndexMarker281"/>would look like the following example:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></p><p class="source-code">...</p><p class="source-code">DATABASES = {</p><p class="source-code">    'default': {</p><p class="source-code">        'ENGINE': '<strong class="bold">django.db.backends.mysql</strong>', </p><p class="source-code">        'NAME': 'database_name',</p><p class="source-code">        'USER': 'database_user',</p><p class="source-code">        'PASSWORD': 'database_password',</p><p class="source-code">        'HOST': 'localhost',</p><p class="source-code">        'PORT': '<strong class="bold">3306</strong>',</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>In order for this database type to work, you also need to install the following package and include it in your <strong class="source-inline">requirements.txt</strong> file:<p class="source-code"><strong class="bold"># requirements.txt</strong></p><p class="source-code">...</p><p class="source-code">Mysqlclient</p></li>
			</ol>
			<p>Adjust your default parameters as needed for your project.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor064"/>MariaDB</h2>
			<p>MariaDB is <a id="_idIndexMarker282"/>actually a fork of MySQL; it is a community-developed<a id="_idIndexMarker283"/> version that evolved over time into what it is today. Technical support is available for both the MariaDB and MySQL database types. With both being open source, there is also a lot of information and resources available online for free. MariaDB is not used as much as MySQL but it is still very popular. Since MariaDB is essentially just another MySQL installation, the <strong class="source-inline">ENGINE</strong> in the <strong class="source-inline">DATABASES</strong> configuration of your <strong class="source-inline">settings.py</strong> file will be the same as the example in the previous subsection, titled <em class="italic">MySQL</em>. Both will also require that you install the same <strong class="source-inline">mysqlclient</strong> package and include it in your <strong class="source-inline">requirements.txt</strong> file.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor065"/>Oracle</h2>
			<p><strong class="bold">Oracle Database</strong> is a <a id="_idIndexMarker284"/>multimodel, object-relational <a id="_idIndexMarker285"/>database management system created by Oracle. It's primarily <a id="_idIndexMarker286"/>used for <strong class="bold">Online Transaction Processing</strong> (<strong class="bold">OLTP</strong>) and <strong class="bold">data warehousing</strong>. This <a id="_idIndexMarker287"/>database is a bit more complicated in terms of its use and capabilities compared to other web development databases. It is intended for enterprise grid computing, which is a method of grouping a series of network computers to act as one larger virtual super-computer. Oracle has developed a database specifically to be used in network cluster configurations such as these. It's considered one of the most complex and robust database systems that exist today and is beyond the scope of this book. Much of the code in this book can still be used with this database type but some alterations may be necessary.</p>
			<p>Follow these steps to configure your Oracle database connection:</p>
			<ol>
				<li value="1">A typical Oracle database connection can be established using the following example: <p class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></p><p class="source-code">...</p><p class="source-code">DATABASES = {</p><p class="source-code">    'default': {</p><p class="source-code">        'ENGINE': '<strong class="bold">django.db.backends.oracle</strong>',</p><p class="source-code">        'NAME': '<strong class="bold">xe</strong>',</p><p class="source-code">        'USER': 'database_user',</p><p class="source-code">        'PASSWORD': 'database_password,</p><p class="source-code">        'HOST': 'database_host',</p><p class="source-code">        'PORT': 'database_port_#',</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>The Oracle database type also requires installing the following package and including it in the <strong class="source-inline">requirements.txt</strong> file:<p class="source-code"><strong class="bold"># requirements.txt</strong></p><p class="source-code">...</p><p class="source-code">cx_Oracle</p></li>
			</ol>
			<p>Oracle<a id="_idIndexMarker288"/> also <a id="_idIndexMarker289"/>requires following additional setup and configuration steps and they provide directions on their website here: <a href="https://cx-oracle.readthedocs.io/en/latest/user_guide/installation.html">https://cx-oracle.readthedocs.io/en/latest/user_guide/installation.html</a>.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor066"/>SQL Server</h2>
			<p>This is the <a id="_idIndexMarker290"/>one<a id="_idIndexMarker291"/> database type that is not one of the five standard types supported by Django that we will provide an example of. Developed by Microsoft, the Microsoft SQL Server database type is also a fork of MySQL and is widely used in Microsoft enterprise database systems today. Many systems today rely on this database type, which is often used in combination with Azure-hosted apps.</p>
			<p>Follow these steps to configure your Microsoft SQL Server database connection:</p>
			<ol>
				<li value="1">A Microsoft SQL Server database type can be established using the following connection settings:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></p><p class="source-code">...</p><p class="source-code">DATABASES = {</p><p class="source-code">    'default': {</p><p class="source-code">        'ENGINE': '<strong class="bold">sql_server.pyodbc</strong>',</p><p class="source-code">        'NAME': 'database_name',</p><p class="source-code">        'USER': 'database_user',</p><p class="source-code">        'PASSWORD': 'database_password',</p><p class="source-code">        'HOST': 'database_host',</p><p class="source-code">        'PORT': '<strong class="bold">1433</strong>',</p><p class="source-code">        'OPTIONS': {</p><p class="source-code">            'driver': '<strong class="bold">ODBC Driver 17 for SQL Server</strong>',</p><p class="source-code">        },</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>This database<a id="_idIndexMarker292"/> type <a id="_idIndexMarker293"/>also requires installing the following packages and including them in your <strong class="source-inline">requirements.txt</strong> file. Depending on your setup, you may only need one or two of the following three packages; however, adding all three will not hurt either:<p class="source-code"><strong class="bold"># requirements.txt</strong></p><p class="source-code">...</p><p class="source-code">pyodbc</p><p class="source-code">django-pyodbc</p><p class="source-code">django-pyodbc-azure</p></li>
			</ol>
			<p>Next, we will be installing the type used throughout the rest of this book, PostgreSQL.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor067"/>PostgreSQL</h2>
			<p><strong class="bold">PostgreSQL</strong> has<a id="_idIndexMarker294"/> become the go-to database of <a id="_idIndexMarker295"/>choice for most Django developers when there is no specific reason to use any of the other choices. It is considered an RDBMS, which is a common tool for storing object-oriented data in tables that relate to other tables, known as objects. Its primary features<a id="_idIndexMarker296"/> includes <strong class="bold">ANSI SQL Compliance</strong> and extensibility, meaning it is a database type built with the idea of people being able to build onto it. It will run on every major operating<a id="_idIndexMarker297"/> system, such as Windows, Mac, and Linux, making it versatile. </p>
			<h3>Standard PostgreSQL settings.py</h3>
			<p>If you are<a id="_idIndexMarker298"/> working with a normal Django project outside of Heroku, configure your PostgreSQL database connection.</p>
			<p>Add the following settings to your <strong class="source-inline">settings.py</strong> file:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></pre>
			<pre class="source-code">…</pre>
			<pre class="source-code">DATABASES = {</pre>
			<pre class="source-code"> '  'defa'lt': {</pre>
			<pre class="source-code">     '  'ENG'NE': '<strong class="bold">django.db.backends.postgre'ql</strong>',</pre>
			<pre class="source-code">     '  'N'ME': 'database_n'me',</pre>
			<pre class="source-code">     '  'H'ST': '<strong class="bold">localh'st</strong>',</pre>
			<pre class="source-code">     '  'U'ER': 'database_u'er',</pre>
			<pre class="source-code">     '  'PASSW'RD': 'database_passw'rd',</pre>
			<pre class="source-code">     '  'P'RT': '<strong class="bold">5'32</strong>',</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Since we are working with Heroku, we cannot use the preceding settings even though we are still using PostgreSQL for each remote Heroku environment. The next section will provide us with the settings and tools specific to a Heroku environment, as well as providing the<a id="_idIndexMarker299"/> rest of the instructions on how to use PostgreSQL locally.</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor068"/>Preparing PostgreSQL for Heroku</h1>
			<p>This section is<a id="_idIndexMarker300"/> dedicated to actually configuring each of your environments, whether using an IDE or command-line window or terminal. To install and use PostgreSQL, we will need to install it locally and then again in each of our remote environments.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor069"/>Installing PostgreSQL</h2>
			<p>This section<a id="_idIndexMarker301"/> will guide you through installing the PostgreSQL software needed on your local and remote machines.</p>
			<h3>Local installation</h3>
			<p>To use PostgreSQL, we <a id="_idIndexMarker302"/>will need to install a suite of software and drivers on each of our machines. In the Heroku dashboards, we will need to include add-ons to get PostgreSQL installed in those environments. To install it on your development machine, you can choose to download the installer for your platform directly from the publisher's website, found here: <a href="https://www.postgresql.org/download/">https://www.postgresql.org/download/</a>. During installation, make note of the port that you set, the password that you create, and whether it asks you to add anything to your environment PATH variables, do so! It is always easier to check/enable these options during installation versus manually configuring them later.</p>
			<p>During installation, the installer will ask whether you want to install any development tools, such as database command-line tools or a database management tool. Select <strong class="bold">PgAdmin</strong> during the installation of your PostgreSQL drivers; we will be using this tool to demonstrate several examples in this chapter. The PgAdmin management tool is used to access and view the database table structures and the data within them. PgAdmin is also compatible with every major operating system, and it can be downloaded and installed separately from the PostgreSQL installation; it can be found on their website here: <a href="https://www.pgadmin.org/download/">https://www.pgadmin.org/download/</a>.</p>
			<p>In the <strong class="source-inline">.env</strong> file found in the local repository that we created earlier, replace <strong class="source-inline">DATABASE_URL=sqlite:///db.sqlite3</strong> with the following value:</p>
			<pre class="source-code"><strong class="bold"># .env</strong></pre>
			<pre class="source-code">DATABASE_URL=postgres://<strong class="bold">postgres</strong>:<strong class="bold">your_password</strong>@<strong class="bold">localhost</strong>:<strong class="bold">5432</strong>/<strong class="bold">local_postgresql</strong></pre>
			<p>Replace the <strong class="source-inline">your_password</strong> placeholder with the password that you entered during your installation of PostgreSQL and PgAdmin. Replace any other placeholders as needed. The username is usually <strong class="source-inline">postgres</strong> by default, but this can be changed to something else during installation. We will need to work with a database management tool, PgAdmin, to create a local database before we can actually run the project now. Even if you used the Visual Studio IDE earlier to create your project, it will now be broken.</p>
			<p>There is a file<a id="_idIndexMarker303"/> called <strong class="source-inline">example.env</strong> provided with the code of this book that you can use as a reference to make sure your file consists of the proper settings for our software stack.</p>
			<h3>Remote installation – Heroku dashboard</h3>
			<p>In Heroku, we<a id="_idIndexMarker304"/> have to add PostgreSQL<a id="_idIndexMarker305"/> one at a time to all three of our remote environments. There are two ways to do this: through the Heroku dashboard or the Heroku CLI. We will demonstrate both ways. Navigate to the Heroku dashboard, found here: <a href="https://dashboard.heroku.com/apps">https://dashboard.heroku.com/apps</a>. We should see all three environments, also known as Heroku apps. Click on each app and navigate to the <strong class="bold">Resources</strong> tab, scroll down that page, and under <strong class="bold">Add-ons</strong>, type <strong class="source-inline">Heroku Postgres</strong> into the search field provided. Next, it will ask you what plan to choose; you can use the free plan called <strong class="bold">Hobby-Dev</strong>, which is what will be used for the demonstrations in this book. Later, you can decide whether upgrading and paying for a new plan is what you need. For more technical needs, these plans include support for increased traffic, the number of connections at one time, the amount of RAM, encryption measures, added security, and so much more. Visit their plans page found here to learn more about what they offer: <a href="https://elements.heroku.com/addons/heroku-postgresql">https://elements.heroku.com/addons/heroku-postgresql</a>.</p>
			<p>If successful, you will see that Heroku automatically created a <strong class="bold">DATABASE_URL</strong> configuration variable for us. This variable can be found in your Heroku dashboard by going to the <strong class="bold">Settings</strong> tab, then scrolling down on the page, under <strong class="bold">Config Vars</strong>, and it can be found after clicking <strong class="bold">Reveal Config Vars</strong>. The following screenshot also shows us that the same <strong class="bold">SECRET_KEY</strong> variable that we created using the CLI earlier in this chapter can also be found here. Any other sensitive environment variables can be created the same way and found here. Clicking the <strong class="bold">Add</strong> button eliminates the need to use the CLI to create an environment variable operation:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/Figure_2.09_B17243.jpg" alt="Figure 2.9 – Heroku – DATABASE_URL&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.9 – Heroku – DATABASE_URL</p>
			<p>Let's walk through <a id="_idIndexMarker306"/>installing PostgreSQL with the Heroku CLI instead of the Heroku dashboard next.</p>
			<h3>Remote installation – Heroku CLI</h3>
			<p>Using the<a id="_idIndexMarker307"/> Heroku CLI, we first need to log into <a id="_idIndexMarker308"/>our account in the terminal or command-line window. The following examples show how to install PostgreSQL on each of our remote environments, starting with production: </p>
			<p class="source-code">(virtual_env) PS &gt; heroku login</p>
			<p class="source-code">(virtual_env) PS &gt; heroku addons:create heroku-postgresql:hobby-dev</p>
			<p class="source-code">(virtual_env) PS &gt; heroku addons:create heroku-postgresql:hobby-dev --app mighty-sea-09431</p>
			<p class="source-code">(virtual_env) PS &gt; heroku addons:create heroku-postgresql:hobby-dev --app pure-atoll-19670</p>
			<p>We have to specify the randomly generated app name that Heroku gave us when we created these environments. If we need to specify the version of PostgreSQL that we want to use, we can do that with the following example. Without specifying a version number, the latest version available will be used:</p>
			<p class="source-code">(virtual_env) PS &gt; heroku addons:create heroku-postgresql:hobby-dev --version=10</p>
			<p>Instead of going to your Heroku dashboard to view these variables, executing the following commands will also display a list of the variables that exist for each environment. Replace the app name for each of the following examples with your Heroku <a id="_idIndexMarker309"/>app<a id="_idIndexMarker310"/> name:</p>
			<p class="source-code">(virtual_env) PS &gt; heroku config --app becoming_an_entdev</p>
			<p class="source-code">(virtual_env) PS &gt; heroku config --app mighty-sea-09431</p>
			<p class="source-code">(virtual_env) PS &gt; heroku config --app pure-atoll-19670</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor070"/>Using the PgAdmin tool</h2>
			<p>PgAdmin is the<a id="_idIndexMarker311"/> database management tool that we are going to use to manage all local and remote databases, as well as creating the local database that we need to connect to. This tool should have been installed earlier in the <em class="italic">Installing PostgreSQL</em> subsection. If it has not been installed, please revisit that subsection for more information.</p>
			<h3>Creating a local database</h3>
			<p>Within<a id="_idIndexMarker312"/> the <strong class="bold">Browser</strong> tab, you should see an existing server connection, such as <strong class="bold">PostgreSQL 13</strong>. Other version numbers may be depicted if you installed another version and it's also possible that your system's installation did not create anything in this list. If so, follow the steps to establish a remote database connection in order to create your local server. For those of you for whom this already exists, right-click where it says <strong class="bold">Databases</strong> and select <strong class="bold">Create</strong> | <strong class="bold">Database...</strong>. When the next window opens, give it a database name of your choice and ensure the encoding is set to <strong class="bold">UTF-8</strong>, and the owner/user should be set to <strong class="source-inline">postgres</strong>. The database name I have given to my local database is <strong class="source-inline">local_postgresql</strong> when referenced in code examples later.</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/Figure_2.10_B17243.jpg" alt="Figure 2.10 – PgAdmin – creating a local database&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.10 – PgAdmin – creating a local database</p>
			<p>Next, we<a id="_idIndexMarker313"/> will connect to a remote database.</p>
			<h3>Connecting to a remote database</h3>
			<p>For each<a id="_idIndexMarker314"/> remote database, we need to add a new server connection inside of the PgAdmin tool. </p>
			<p>Follow these steps to connect to a remote database:</p>
			<ol>
				<li value="1">Start by gathering some information from your Heroku account first. In your Heroku dashboard, under each Heroku app, navigate to the <strong class="bold">Resources</strong> tab and, under <strong class="bold">Add-ons</strong>, click on the <strong class="bold">opens in a new tab</strong> icon, as depicted in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/Figure_2.11_B17243.jpg" alt="Figure 2.11 – Heroku – opening a database in a new tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.11 – Heroku – opening a database in a new tab</p>
			<ol>
				<li value="2">In the new browser tab that opens, navigate to the <strong class="bold">Settings</strong> tab and make note of the information that is provided. The highlighted fields in the followi<a id="_idTextAnchor071"/>ng screenshot are the important pieces that we will need to establish a connection inside the <a id="_idIndexMarker315"/>PgAdmin tool. Make note of them:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/Figure_2.12_B17243.jpg" alt="Figure 2.12 – Heroku – database information&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.12 – Heroku – database information</p>
			<ol>
				<li value="3">Open PgAdmin and from the top navigation bar of this app, under the <strong class="bold">Object</strong> tab, select <strong class="bold">Create</strong> | <strong class="bold">Server</strong>. In the window that opens, under the <strong class="bold">General</strong> tab, enter any name of your choice. This is to name your server connections for local reference only. Name them so that you know which environment is which, as shown in the following screenshot: </li>
			</ol>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/Figure_2.13_B17243.jpg" alt="Figure 2.13 – PgAdmin – Create - Server&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.13 – PgAdmin – Create - Server</p>
			<ol>
				<li value="4">This task only creates your server connection inside the PgAdmin tool; it is not creating the database server itself. Using the information that was found previously in <em class="italic">Figure 2.12</em>, under the <strong class="bold">Connection</strong> tab, fill in the corresponding fields, as highlighted in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/Figure_2.14_B17243.jpg" alt="Figure 2.14 – PgAdmin – creating a server connection&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.14 – PgAdmin – creating a server connection</p>
			<ol>
				<li value="5">Replace<a id="_idIndexMarker316"/> the value in the field labeled <strong class="bold">Maintenance database</strong> with the database name provided by Heroku; do the same for <strong class="bold">Username</strong>. </li>
				<li>If successful, you will now see your new server connection in the <strong class="bold">Browser</strong> panel of the <strong class="bold">PgAdmin</strong> app. The <strong class="bold">Browser</strong> panel is often found on the left-hand side of the PgAdmin program. Since we are using the free plan called <strong class="bold">Hobby-Dev</strong>, we will see dozens and dozens of other databases in this list. All but one will be grayed out, just like in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/Figure_2.15_B17243.jpg" alt="Figure 2.15 – PgAdmin – viewing tables&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.15 – PgAdmin – viewing tables</p>
			<p>The one database that is colored is your database name, displayed in <em class="italic">Figure 2.12</em>. Expand your database and you should be able to gain access; attempting to open any other database will result in <strong class="bold">permission denied</strong>. You can avoid a shared plan like this by purchasing a dedicated database hosting plan that Heroku does offer, which is much more secure. </p>
			<p>Now, push your file changes to your Git development repository and you should see a successful <a id="_idIndexMarker317"/>deployment to your Heroku app.</p>
			<p>Next, we will adjust our environment connection settings for use with PostgreSQL locally.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor072"/>Environment connection settings</h2>
			<p>For our Heroku<a id="_idIndexMarker318"/> configuration, we need to define a default database using the following example, in your <strong class="source-inline">settings.py</strong> file, instead of using a standard PostgreSQL connection setting.</p>
			<p>To configure PostgreSQL for use with Heroku and local use, follow these steps:</p>
			<ol>
				<li value="1">Change your <strong class="source-inline">DATABASES</strong> variable to use the code shown here:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></p><p class="source-code">...</p><p class="source-code">DATABASES = {</p><p class="source-code">    'default': <strong class="bold">dj_database_url.config(</strong></p><p class="source-code">        <strong class="bold">conn_max_age=600</strong></p><p class="source-code">    <strong class="bold">)</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>You can also increase the length of time allowed for established database connections to exist by adjusting the value of <strong class="source-inline">conn_max_age</strong>. The default value is <strong class="source-inline">600</strong> seconds, which equates to 10 minutes. Since the <strong class="source-inline">dj_database_url</strong> module will try to log into Heroku using a <strong class="bold">Secure Sockets Layer</strong> (<strong class="bold">SSL</strong>) connection, we<a id="_idIndexMarker319"/> will have issues running the project locally when connected to a remote database. To avoid those issues, we will have to <a id="_idIndexMarker320"/>add the following code to the bottom of the <strong class="source-inline">settings.py</strong> file. </p>
			<ol>
				<li value="2">Place the following code under the <strong class="source-inline">django_heroku.settings(locals())</strong> line that we placed at the bottom of this file earlier; it should look like the following example:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></p><p class="source-code">...</p><p class="source-code">django_heroku.settings(locals())</p><p class="source-code"><strong class="bold">options = DATABASES['default'].get('OPTIONS', {})</strong></p><p class="source-code"><strong class="bold">options.pop('sslmode', None)</strong></p></li>
			</ol>
			<p>That's it. Let's build our initial table structures locally next.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor073"/>Building initial table structures</h2>
			<p>Next, we need to<a id="_idIndexMarker321"/> create the table<a id="_idIndexMarker322"/> structures that relate to the models within a project and any third-party packages that we installed. These operations can be performed using the Visual Studio IDE or <a id="_idIndexMarker323"/>through<a id="_idIndexMarker324"/> a terminal or command-line window. Choose your method from the following.</p>
			<h3>Using the IDE</h3>
			<p>In your IDE, you<a id="_idIndexMarker325"/> need to perform three actions: make migrations, migrate, and create a superuser, in that order. Within the Visual Studio IDE, go to your <strong class="bold">Solution Explorer</strong> and right-click on your project name. In the menu that pops up, under <strong class="bold">Python</strong>, select <strong class="bold">Django Make Migrations</strong> and then <strong class="bold">Django Migrate…</strong>, as shown in the following screenshot. Then, select the <strong class="bold">Django Create Superuser</strong> operation:</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/Figure_2.16_B17243.jpg" alt="Figure 2.16 – Visual Studio – manage.py commands&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.16 – Visual Studio – manage.py commands</p>
			<p>Next, we will use the command-line-driven approach.</p>
			<h3>Commands – makemigrations and migrate</h3>
			<p>If you are not <a id="_idIndexMarker326"/>using an IDE or decide to run your project outside of the IDE, these commands are for you. Make sure you have activated your virtual environment and you are in the same directory as your <strong class="source-inline">manage.py</strong> file. Using the terminal or command-line window, create your table structures in your local database by using the following two examples: </p>
			<p class="source-code">(virtual_env) PS &gt; python manage.py makemigrations</p>
			<p class="source-code">(virtual_env) PS &gt; python manage.py migrate</p>
			<p>Since we have not created any models yet, these two commands will only create the default <strong class="source-inline">User</strong> <strong class="source-inline">Auth</strong> and <a id="_idIndexMarker327"/>other Django management models that come as standard with all Django installations.</p>
			<h3>Command – createsuperuser</h3>
			<p>The first time we<a id="_idIndexMarker328"/> create database tables, we are required to create a superuser so that we can access the admin panel successfully. Additional users can be created from within the Django admin panel itself or by executing the command again, as shown in the following code snippet. Run this command now to create a superuser:</p>
			<p class="source-code">(virtual_env) PS &gt; python manage.py createsuperuser</p>
			<p>Next, when you are prompted to do so, enter the username, email address, and password that it will ask you to provide. Remember this information as you will need it to access the Django admin site, introduced in <a href="B17243_06_ePub.xhtml#_idTextAnchor190"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring the Django Admin Site</em>.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor074"/>Remote data migrations</h2>
			<p>Performing <strong class="bold">remote data migrations</strong> means running the same migration commands that<a id="_idIndexMarker329"/> we <a id="_idIndexMarker330"/>executed for a local database except on each remote database. </p>
			<p>To run the migration commands manually for each of the remote environments that we created, we need to activate the <strong class="bold">Bash shell</strong> for each one first. Follow these steps to do that: </p>
			<ol>
				<li value="1">Log into your Heroku account and then execute each of the following commands, one at a time, for each environment that exists. Note that after each shell that is started, you should follow these steps before starting the next shell:<p class="source-code"><strong class="bold">(virtual_env) PS &gt; heroku login</strong></p><p class="source-code"><strong class="bold">(virtual_env) PS &gt; heroku run bash --app becoming-an-entdev</strong></p><p class="source-code"><strong class="bold">(virtual_env) PS &gt; heroku run bash --app mighty-sea-09431</strong></p><p class="source-code"><strong class="bold">(virtual_env) PS &gt; heroku run bash --app pure-atoll-19670</strong></p></li>
				<li>For each environment that you activated a Bash shell for, once it has finished loading, you will see your command line now starts with the dollar sign character (<strong class="source-inline">$</strong>). You will also notice that no matter what directory you were in before, it will put you in the same directory that your <strong class="source-inline">.git</strong> folder lives in now. Navigate to where your <strong class="source-inline">manage.py</strong> file is located using the <strong class="source-inline">cd</strong> command and then run the following migration commands just like we did for a local database: <p class="source-code"><strong class="bold">$ cd becoming_a_django_entdev</strong></p><p class="source-code"><strong class="bold">$ python manage.py makemigrations</strong></p><p class="source-code"><strong class="bold">$ python manage.py migrate</strong></p></li>
				<li>Type <strong class="source-inline">exit</strong> and wait for it to escape each shell and proceed to the next environment.</li>
			</ol>
			<p>Keep in mind that all these commands do is migrate your table structures; they don't actually migrate data found within those tables. </p>
			<p>Next, we will practice using the push/pull operations provided by Heroku to migrate data and <a id="_idIndexMarker331"/>table<a id="_idIndexMarker332"/> structures for us, eliminating the need to run these commands from within the Bash shell.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor075"/>Heroku database push/pull operations</h2>
			<p>Heroku has <a id="_idIndexMarker333"/>built-in functionality to push and pull data to and from the database indicated. These commands will allow us to merge data and table structures. With this, we can run the <strong class="source-inline">makemigrations</strong> and <strong class="source-inline">migrate</strong> commands locally, populate our database with sample data, and then push it to our other environments, eliminating the need to run these commands individually on each remote environment. You should be very cautious of performing these tasks as it is entirely possible to override or experience a complete loss of data when the wrong operation is executed. The good news is that whenever any of these commands are executed, Heroku will automatically generate a data backup of the current state of your database before any action is performed, allowing you to reverse any action that has been done.</p>
			<p>Follow these steps to perform your operations:</p>
			<ol>
				<li value="1">To visibly see the changes that are happening, navigate to the <strong class="bold">Overview</strong> tab of your database dashboard in Heroku. Here, we can see a numeric count of the tables that exist for the remote database we are viewing. We can watch this number to see how a database changes as we execute each <strong class="source-inline">push</strong> or <strong class="source-inline">pull</strong> operation that includes adding or removing tables. </li>
				<li>Using the information that we gathered from the page in <em class="italic">Figure 2.12</em>, execute the following command to push your database, including a parameter to indicate which environment we are pushing to:<p class="source-code"><strong class="bold">(virtual_env) PS &gt; heroku login</strong></p><p class="source-code"><strong class="bold">(virtual_env) PS &gt; PGUSER=postgres PGPASSWORD=password heroku pg:push local_postgresql postgresql-tetrahedral-62413 --app mighty-sea-09431</strong></p></li>
			</ol>
			<p>Make sure<a id="_idIndexMarker334"/> you use the username and password that were specified when creating your local PostgreSQL database. Replace <strong class="source-inline">postgresql-tetrahedral-62413</strong> with the contents of label number <strong class="bold">6</strong> in <em class="italic">Figure 2.12</em>. This is the database name that Heroku generated when we created our database in that environment. The database name can also be found at the top of your database dashboard. Number <strong class="bold">7</strong> of that same image is your app name, which is declared using the <strong class="source-inline">--app</strong> parameter. <strong class="source-inline">local_postgresql</strong> is the name I used for my local database.</p>
			<p>You should now be able to see a total of 10 tables in the <strong class="bold">Overview</strong> tab of your database dashboard. These 10 tables are the standard <strong class="source-inline">Auth</strong> and Django management tables that were created when we first ran the migration commands locally.</p>
			<h3>Note for Windows users</h3>
			<p>Windows users<a id="_idIndexMarker335"/> might have difficulty executing the preceding command. Make sure the path to your <strong class="source-inline">bin</strong> folder is included in your Windows environment variables settings. That folder is usually found at <strong class="source-inline">C:\Program Files\PostgreSQL\##\bin</strong> on a Windows 10 installation, where <strong class="source-inline">##</strong> is the numeric version number of PostgreSQL that is installed on your machine. This will get the <strong class="source-inline">heroku pg:</strong> command and the <strong class="source-inline">psql</strong> command to work from within your CLI. A restart of your CLI or operating system is usually recommended after making changes to your environment variables. The following commands will set variables that are used during the time that your CLI terminal window is open. Running them together on one line in Windows will usually give you errors. When these variables are set and your window remains <a id="_idIndexMarker336"/>open, you will be able to run your <strong class="source-inline">push</strong> or <strong class="source-inline">pull</strong> commands as you need them:</p>
			<p class="source-code">(virtual_env) PS &gt; heroku login</p>
			<p class="source-code">(virtual_env) PS &gt; set PGHOST=localhost</p>
			<p class="source-code">(virtual_env) PS &gt; set PGUSER=postgres</p>
			<p class="source-code">(virtual_env) PS &gt; set PGPASSWORD=password</p>
			<p class="source-code">(virtual_env) PS &gt; set PGPORT=5432</p>
			<p class="source-code">(virtual_env) PS &gt; heroku pg:push local_postgresql postgresql-tetrahedral-62413 --app mighty-sea-09431</p>
			<p>If we wanted to pull data instead of push data, that command is just as simple as changing <strong class="source-inline">push</strong> to <strong class="source-inline">pull</strong>, as depicted in the following example:</p>
			<p class="source-code">(virtual_env) PS &gt; heroku pg:pull local_postgresql postgresql-tetrahedral-62413 --app mighty-sea-09431</p>
			<p>For a complete guide on how to use Heroku command-line operations pertaining to PostgreSQL, view<a id="_idIndexMarker337"/> their knowledge base article here: <a href="https://devcenter.heroku.com/articles/heroku-postgresql">https://devcenter.heroku.com/articles/heroku-postgresql</a>. </p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor076"/>Summary</h1>
			<p>By now, we have done a lot of work but we still haven't really begun building any Django apps for a project yet. All of the work done up until now can be thought of as the preliminary work necessary before handing over a project to the development team. Two methods of creating a project have been provided: one method using a tool to help streamline production, called an IDE, and another method using commands in a terminal or command-line window. We are tracking a solution file in the repository so that we can share it within a team but we are not tracking personal settings and debug files that are automatically created when running a project. Developers who are not using an IDE can still work with the code base even when sharing project configuration files with those who are using an IDE. After we did that, we configured Django to work with the host provider Heroku on both the project level and the database level. Finally, we activated tools that allow developers to view and edit data inside of a local or remote database.</p>
			<p>You can now hand this solution over to your team and begin delegating tasks to each member within that team. In the next chapter, we will start creating models that build tables inside a database. These models can be thought of as the elements that construct the rest of the chapters after <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, in this book.</p>
		</div>
	</body></html>