- en: Chapter 9. Integration Testing and System Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*With all of the tools, techniques, and practices that we''ve discussed so
    far, we''ve still only been been thinking about testing units: the smallest meaningfully
    testable pieces of code. It''s time to expand the focus and start testing code
    that incorporates multiple units.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Describe integration testing and system testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to break up a program into testable multi-unit sections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use doctest, unittest, and Nose to automate multi-unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let's get on with it!
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests and system tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integration testing is the process of checking that the units making up your
    program work correctly in concert with each other, rather than in isolation. It's
    not practical to start the process with integration testing, because if the units
    don't work, the integration won't work either, and it will be harder to track
    down the cause of your problems. Once your units are solid though, it's necessary
    to test that the things you build out of them also work. The interactions between
    units can be surprising.
  prefs: []
  type: TYPE_NORMAL
- en: While you perform integration testing, you'll be putting the units together
    into bigger and bigger collections and testing those collections. When your integration
    tests expand to cover the entirety of your program, they have become system tests.
  prefs: []
  type: TYPE_NORMAL
- en: The trickiest part of integration testing is choosing which units to integrate
    into each test, so that you always have a solid base of code that you can believe
    in; a place to stand, while you pull in more code.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – figuring out the order of integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll walk through an exercise that can help with the process of deciding where
    to put the boundaries of integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Using a piece of paper or a graphics program, write out names or representations
    for each of the units in the time planner project from Chapter 7\. Group the methods
    of each class together. Being part of the same class is an obvious relationship
    between units, and we'll take advantage of that. (The `==` symbol here represents
    the Python `==` operator, which invokes the `__eq__` method on an object).![Time
    for action – figuring out the order of integration](img/8846_09_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, draw arrows between units that are supposed to directly interact with each
    other, from the caller to the callee. Laying everything out in an orderly fashion
    (like in step 1) can actually make this harder, so feel free to move the classes
    around to help the lines make sense.![Time for action – figuring out the order
    of integration](img/8846_09_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw circles around each class and each pair of classes that is connected by
    at least one line.![Time for action – figuring out the order of integration](img/8846_09_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue the process by drawing circles around overlapping pairs of circles,
    until there are only three circles left. Circle a pair of them and then put one
    more big circle around the whole mess.![Time for action – figuring out the order
    of integration](img/8846_09_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These circles tell us which order to write our integration tests in. The smaller
    the circle, the sooner the test should be written.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we just did is a way to visualize and concretize the process of building
    up integration tests. While it's not critical to actually draw the lines and circles,
    it's useful to follow the process in your head. For larger projects, a lot can
    be gained from actually drawing the diagrams. When you can see the diagram, the
    correct next step tends to jump right out at you—especially if you use multiple
    colors to render the diagram—where it might otherwise be hidden behind the complexity
    of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – diagramming integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What's the point of grouping units together into classes during the early part
    of this process?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we move classes around to help the arrows make sense, what effect does
    that have on the later process?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we always focus on grouping together pairs when we do this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have a go hero – diagram your own program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Take one of your own programs and build an integration diagram for it. If your
    program is large enough that the diagram begins to get clumsy, try putting different
    'levels' of the diagram on separate pages.
  prefs: []
  type: TYPE_NORMAL
- en: Automation with doctest, unittest, and Nose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only real difference between an integration test and a unit test, is that
    you could break the code being tested into smaller meaningful chunks, in an integration
    test. In a unit test, if you divided the code up any more it wouldn't be meaningful.
    For this reason, the same tools that help automate unit testing can be applied
    to integration testing. Since system testing is really the highest level of integration
    testing, the tools can be used for that as well.
  prefs: []
  type: TYPE_NORMAL
- en: The role of doctest in integration testing tends to be fairly limited. The real
    strengths of doctest are in the early part of the development process. It's easy
    for a testable specification to stray into integration testing—as mentioned before,
    that's fine as long as there are unit tests as well—but after that it's likely
    that you'll prefer unittest and Nose for writing your integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests need to be isolated from each other. Even though they contain
    multiple interacting units within themselves, you still benefit from knowing that
    nothing outside the test is affecting it. For this reason, unittest is a good
    choice for writing automated integration tests. Working together with unittest,
    Nose and Mocker complete the picture nicely.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – writing integration tests for the time planner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've got an integration diagram for the time planner code, we can
    move ahead with actually writing automated integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The integration diagram provides only a partial ordering of the integration
    tests, and there are several tests that could be the first one we write. Looking
    at the diagram, we see that the `statuses` and `activities` classes are at the
    ends of a lot of arrows, but not at the beginnings of any. This makes them particularly
    good places to start, because it means that they don''t call on anything outside
    of themselves to operate. Since there''s nothing to distinguish one of them as
    a better place to start than the other, we can choose between them arbitrarily.
    Let''s start with `statuses`, and then do `activities`. We''re going to write
    tests that exercise the whole class. At this low level, the integration tests
    will look a lot like the unit tests for the same class, but we''re not going to
    use mock objects to represent other instances of the same class: we''ll use real
    instances. We''re testing whether the class correctly interacts with itself.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the test code for `statuses`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the test code for `activities`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Looking at our diagram, we can see that the next level out from either `statuses`
    or `activities` represents the integration of those classes with the `schedules`
    class. Before we write that integration, we ought to write any tests that involve
    the schedules class interacting with itself, without mocking it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that interactions within the `schedules` class have been tested, we can
    write tests that integrate `schedules` and one of `statuses` or `activities`.
    Let''s start with `statuses`, then do `activities`. Here are the tests for `schedules`
    and `statuses`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here are the tests for `schedules` and `activities`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It's time to pull `schedules`, `statuses`, and `activities` all together into
    the same tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next thing that we need to pull in is the `file` class, but before we integrate
    it with the rest of the system, we need to integrate it with itself; checking
    its internal interactions without using mock objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we can write tests that integrate `schedules` and `file`. Notice that for
    this step, we still aren't involving `statuses` or `activities`, because they're
    outside the oval.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We've built our way up to the outermost circle now, which means that it's time
    to write tests that involve the whole system, with no mock objects anywhere.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've just tested our whole code base, always being careful to test one thing
    at a time. Because we took care to go step-by-step, we always knew where newly
    discovered bugs originated, and we were able to fix them easily.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a moment to examine each section of the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We're creating a status object here in our `setUp` method. Because it's a `setUp`
    method—part of the test fixture—each test will have its own unique version of
    `self.A`, and changes made in one test won't be visible to any other test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `test_equality` test checks that a status compares equal to itself, and
    that differences in name, start time or end time cause statuses to compare as
    unequal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This series of tests checks that statuses correctly recognize when they overlap,
    whether that overlap happens at the beginning, at the end, or because one status
    is within the other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As with statuses, activities are tested by creating a sample object in the `setUp`
    method, and performing operations on it in the tests. Equality checking is the
    same as in statuses; we want to make sure that a different name, begin time, or
    end time means that the two activities are not equal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This series of tests makes sure that activities correctly recognize when they
    overlap with each other, whether that overlapping happens at the beginning, the
    end, or in the middle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We'll test how `schedules` interacts with itself, but not yet how it interacts
    with `activities` and `statuses`. As such, we need some mock objects to represent
    those things. Here in the test fixture, we create three mock objects for just
    that purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The only interaction that `schedules` has with itself is equality comparison,
    so here we've tested that the comparison between two real schedules works the
    way it's supposed to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Where before we used mock objects to represent the statuses, now we can use
    the real thing. Since we're testing the interaction between `schedules` and `statuses`,
    we need to use the real thing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This test runs through the whole expected usage pattern between `schedules`
    and `statuses`, all in one test. This sort of thing isn't a good idea when we
    perform unit testing, because it naturally involves more than one unit. We're
    doing integration testing now, though, and all of the involved units have already
    been tested in isolation. We actually want to have them interact with each other
    to make sure it works, and this is a good way to achieve that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: These tests are a lot like the tests for `schedules` and `statuses` together.
    The differences are due to the fact that activities can exclude each other from
    participating in a schedule, so when we try to add an overlapping activity to
    the schedule, it should raise an exception, and then should not be added to the
    schedule.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We're not using any mocks at all here. These tests use `schedules`, `activities`,
    and `statuses` without any limits on their interactions. Our test fixture just
    creates a bunch of them, so we don't have to duplicate that code in each of the
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here again, we have a single test for a complete usage pattern. We're intentionally
    not limiting the interactions between the tested components; instead we're putting
    them together and making sure that they work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Our test fixture creates a persistence database, containing several objects
    before each test runs, and deletes that database after each test. As usual, that
    means we know what the environment looks like for each test, and they don't interact
    with each other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we create a new persistence file object, and tell it to load data
    from the database created in the `setUp` method. Then we make sure that the loaded
    data match our expectations.
  prefs: []
  type: TYPE_NORMAL
- en: When we run this test, it turns up an error which was not previously visible.
    The changes to the database aren't being committed to the file, and so they aren't
    visible outside of the transaction where they were stored. Not testing the persistence
    code in separate transactions was an oversight, but that's exactly the sort of
    mistake that we perform integration testing to catch.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fix the problem by altering the `store_object` method of the `file`
    class in `persistence.py` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `unpickle_mocked_task` function is necessary because one thing that mocks
    doesn't handle very well is being 'pickled' and 'unpickled'. We used tuples in
    the tests for `file` because of that, but we need mocks for this test, so we have
    to go to the extra trouble of telling Pickle how to handle them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This should be a fairly familiar sort of test fixture, by now. The new thing
    is that the `tearDown` method will delete a database file, ( if it exists) but
    won't complain if it doesn't. The database is expected to be created within the
    test itself, and we don't want to leave it lying around, but if it's not there,
    it's not a test fixture error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We're testing the interaction between schedules and persistence files, which
    means we've created and populated a schedule, created a persistence file, stored
    the schedule, and then created a new persistence file object using the same database
    file and loaded a new schedule from it. If the loaded schedule matches our expectations,
    all's well.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of the test code in this chapter might seem redundant to you. That's because,
    in some sense, it is. Some things are repeatedly checked in different tests. Why
    bother?
  prefs: []
  type: TYPE_NORMAL
- en: The main reason for the redundancy is that each test is supposed to stand alone.
    We're not supposed to care what order they run in, or whether any other tests
    even exist. Each test is self-contained, so if it fails, we know exactly what
    needs to be fixed. Because each test is self-contained, some foundational things
    end up getting tested multiple times. In the case of this simple project, that
    redundancy is even more pronounced than it would normally be.
  prefs: []
  type: TYPE_NORMAL
- en: Whether it's blatant or subtle, the redundancy isn't a problem. The so-called
    DRY (Don't Repeat Yourself) principle doesn't particularly apply to tests. There's
    not much downside to having something tested multiple times. This is not to say
    that it's a good idea to copy and paste tests, because it's most certainly not.
    Don't be surprised or alarmed to see similarity between your tests, but don't
    use that as an excuse.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – writing integration tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Which integration tests do you write first?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens when you have a large chunk of integrated code, but the next section
    you need to pull in doesn't have any integration tests at all?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the point of writing tests that check the integration of a chunk of code
    with itself?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a system test, and how do system tests relate to integration tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have a go hero – integrating your own program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, you wrote an integration diagram for one of your own programs. It's
    time now to follow up on that and write integration tests for that code, guided
    by the diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the process of building up from a foundation
    of unit tests, into a set of tests that cover the whole system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we covered:'
  prefs: []
  type: TYPE_NORMAL
- en: How to draw an integration diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to interpret an integration diagram to decide in what order to build the
    tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write integration tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've learned about integration testing, we're ready to introduce a
    number of other useful testing tools and strategies—which is the topic of the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
