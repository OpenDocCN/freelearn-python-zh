- en: Chapter 3. Forms and Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Passing HttpRequest to the form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing the save method of the form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating form layout with django-crispy-forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading authorized files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering object lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing paginated lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing class-based views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating PDF documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a multilingual search with Haystack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the database structure is defined in the models, we need some views to
    let the users enter data or show the data to the people. In this chapter, we will
    focus on the views managing forms, the list view, and views generating an alternative
    output than HTML. For the simplest examples, we will leave the creation of URL
    rules and templates up to you.
  prefs: []
  type: TYPE_NORMAL
- en: Passing HttpRequest to the form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first argument of every Django view is the `HttpRequest` object that is
    usually named `request`. It contains metadata about the request. For example,
    current language code, current user, current cookies, and current session. By
    default, the forms that are used in the views accept the `GET` or `POST` parameters,
    files, initial data, and other parameters; however, not the `HttpRequest` object.
    In some cases, it is useful to additionally pass `HttpRequest` to the form, especially
    when you want to filter out the choices of form fields using the request data
    or handle saving something such as the current user or IP in the form.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see an example of a form where a person can choose a
    user and write a message to them. We will pass the `HttpRequest` object to the
    form in order to exclude the current user from the recipient choices; we don't
    want anybody to write a message to themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a new app called `email_messages` and put it in `INSTALLED_APPS`
    in the settings. This app will have no models, just forms and views.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To complete this recipe, execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `forms.py` file with the message form containing two fields: the
    recipient selection and message text. Also, this form will have an initialization
    method, which will accept the request object and then, modify `QuerySet` for the
    recipient''s selection field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create `views.py` with the `message_to_user()` view in order to handle
    the form. As you can see, the request object is passed as the first parameter
    to the form, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the initialization method, we have the `self` variable that represents the
    instance of the form itself, we also have the newly added `request` variable,
    and then we have the rest of the positional arguments (`*args`) and named arguments
    (`**kwargs`). We call the `super()` initialization method passing all the positional
    and named arguments to it so that the form is properly initiated. We will then
    assign the `request` variable to a new `request` attribute of the form for later
    access in other methods of the form. Then, we modify the `queryset` attribute
    of the recipient's selection field, excluding the current user from the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the view, we will pass the `HttpRequest` object as the first argument in
    both situations: when the form is posted, as well as when it is loaded for the
    first time.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Utilizing the save method of the form* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing the save method of the form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make your views clean and simple, it is good practice to move the handling
    of the form data to the form itself whenever possible and makes sense. The common
    practice is to have a `save()` method that will save the data, perform search,
    or do some other smart actions. We will extend the form that is defined in the
    previous recipe with the `save()` method, which will send an e-mail to the selected
    recipient.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will build upon the example that is defined in the *Passing HttpRequest to
    the form* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To complete this recipe, execute the following two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From Django, import the function in order to send an e-mail. Then, add the
    `save()` method to `MessageForm`. It will try to send an e-mail to the selected
    recipient and will fail silently if any errors occur:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, call the `save()` method from the form in the view if the posted data
    is valid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a look at the form. The `save()` method uses the cleaned data from
    the form to read the recipient's e-mail address and the message. The sender of
    the e-mail is the current user from the request. If the e-mail cannot be sent
    due to an incorrect mail server configuration or another reason, it will fail
    silently; that is, no error will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the view. When the posted form is valid, the `save()` method
    of the form will be called and the user will be redirected to the success page.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Passing HttpRequest to the form* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Downloading authorized files* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will take a look at the easiest way to handle image uploads.
    You will see an example of an app, where the visitors can upload images with inspirational
    quotes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure to have Pillow or PIL installed in your virtual environment or globally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, let''s create a `quotes` app and put it in `INSTALLED_APPS` in the settings.
    Then, we will add an `InspirationalQuote` model with three fields: the `author`,
    `quote` text, and `picture`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In addition, we created an `upload_to()` function, which sets the path of the
    uploaded picture to be something similar to `quotes/2015/04/20150424140000.png`.
    As you can see, we use the date timestamp as the filename to ensure its uniqueness.
    We pass this function to the `picture` image field.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute these steps to complete the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `forms.py` file and put a simple model form there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `views.py` file, put a view that handles the form. Don''t forget to
    pass the `FILES` dictionary-like object to the form. When the form is valid, trigger
    the save method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, create a template for the view in `templates/quotes/change_quote.html`.
    It is very important to set the `enctype` attribute to `multipart/form-data` for
    the HTML form, otherwise the file upload won''t work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Django model forms are forms that are created from models. They provide all
    the fields from the model so you don't need to define them again. In the preceding
    example, we created a model form for the `InspirationalQuote` model. When we save
    the form, the form knows how to save each field in the database, as well as to
    upload the files and save them in the media directory.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a bonus, we will see an example of how to generate a thumbnail out of the
    uploaded image. Using this technique, you could also generate several other specific
    versions of the image, such as the list version, mobile version, and desktop computer
    version.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add three methods to the `InspirationalQuote` model (`quotes/models.py`).
    They are `save()`, `create_thumbnail()`, and `get_thumbnail_picture_url()`. When
    the model is being saved, we will trigger the creation of the thumbnail. When
    we need to show the thumbnail in a template, we can get its URL using `{{ quote.get_thumbnail_picture_url
    }}`. The method definitions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding methods, we are using the file storage API instead of directly
    juggling the filesystem, as we could then exchange the default storage with Amazon
    S3 buckets or other storage services and the methods will still work.
  prefs: []
  type: TYPE_NORMAL
- en: How does the creating the thumbnail work? If we had the original file saved
    as `quotes/2014/04/20140424140000.png`, we are checking whether the `quotes/2014/04/20140424140000_thumbnail.jpg`
    file doesn't exist and, in that case, we are opening the original image, cropping
    it from the center, resizing it to 50 x 50 pixels, and saving it to the storage.
  prefs: []
  type: TYPE_NORMAL
- en: The `get_thumbnail_picture_url()` method checks whether the thumbnail version
    exists in the storage and returns its URL. If the thumbnail version does not exist,
    the URL of the original image is returned as a fallback.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a form layout with django-crispy-forms* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a form layout with django-crispy-forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `django-crispy-forms` Django app allows you to build, customize, and reuse
    forms using one of the following CSS frameworks: Uni-Form, Bootstrap, or Foundation.
    The usage of `django-crispy-forms` is analogous to fieldsets in the Django contributed
    administration; however, it is more advanced and customizable. You define form
    layout in the Python code and you don''t need to worry about how each field is
    presented in HTML. However, if you need to add specific HTML attributes or wrapping,
    you can easily do that too. Moreover, all the markup used by `django-crispy-forms`
    is located in the templates that can be overwritten for specific needs.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see an example of how to use `django-crispy-forms` with
    Bootstrap 3, which is the most popular frontend framework to develop responsive,
    mobile-first web projects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start with, execute the following tasks one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the Bootstrap frontend framework from [http://getbootstrap.com/](http://getbootstrap.com/)
    and integrate CSS and JavaScript in the templates. Learn more about this in the
    *Arranging the base.html template* recipe in [Chapter 4](ch04.html "Chapter 4. Templates
    and JavaScript"), *Templates and JavaScript*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `django-crispy-forms` in your virtual environment using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that `crispy_forms` is added to `INSTALLED_APPS` and then set `bootstrap3`
    as the template pack to be used in this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a `bulletin_board` app to illustrate the usage of `django-crispy-forms`
    and put it in `INSTALLED_APPS` in the settings. We will have a `Bulletin` model
    there with these fields: `bulletin_type`, `title`, `description`, `contact_person`,
    `phone`, `email`, and `image` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a model form for the bulletin in the newly created app. We will
    attach a form helper to the form in the initialization method itself. The form
    helper will have the layout property that will define the layout for the form,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To render the form in the template, we just need to load the `crispy_forms_tags`
    template tag library and use the `{% crispy %}` template tag as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the `base.html` template. You can do this according to the example in
    the *Arranging the base.html template* recipe in [Chapter 4](ch04.html "Chapter 4. Templates
    and JavaScript"), *Templates and JavaScript*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The page with the bulletin form will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04912_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the fields are grouped by fieldsets. The first argument of the
    `Fieldset` object defines the legend, the other positional arguments define the
    fields. You can also pass named arguments to define the HTML attributes for the
    fieldset; for example, for the second fieldset, we are passing `title` and `css_id`
    to set the `title` and `id` HTML attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Fields can also have additional attributes passed by named arguments; for example,
    for the `description` field, we are passing `css_class` and `rows` to set the
    `class` and `rows` HTML attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the normal fields, you can pass HTML snippets as this is done with the
    help block for the image field. You can also have prepended text fields in the
    layout. For example, we added a phone icon to the **Phone** field and an `@` sign
    for the **Email** field. As you can see from the example with the contact fields,
    we can easily wrap fields in the HTML `<div>` elements using the `Div` objects.
    This is useful when specific JavaScript needs to be applied to some form fields.
  prefs: []
  type: TYPE_NORMAL
- en: The `action` attribute for the HTML form is defined by the `form_action` property
    of the form helper. If you use the empty string as an action, the form will be
    submitted to the same view, where the form is included. The `method` attribute
    of the HTML form is defined by the `form_method` property of the form helper.
    As you know, the HTML forms allow the GET and POST methods. Finally, there is
    a `Submit` object in order to render the submit button, which takes the name of
    the button as the first positional argument and the value of the button as the
    second argument.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the basic usage, the given example is more than necessary. However, if you
    need a specific markup for the forms in your project, you can still overwrite
    and modify templates of the `django-crispy-forms` app as there is no markup hardcoded
    in the Python files, rather all the generated markup is rendered through the templates.
    Just copy the templates from the `django-crispy-forms` app to your project's template
    directory and change them as required.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Filtering object lists* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Managing paginated lists* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Downloading authorized files* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading authorized files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you might need to allow only specific people to download intellectual
    property from your website. For example, music, videos, literature, or other artistic
    works should be accessible only to the paid members. In this recipe, you will
    learn how to restrict image downloads only to the authenticated users using the
    contributed Django auth app.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start, create the `quotes` app as in the *Uploading images* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute these steps one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the view that will require authentication to download a file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the view to the URL configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to set the login view in project URL configuration. Note how
    we are also adding `login_helper` for `django-crispy-forms`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s create a template for the login form, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `login.css` file to add some style to the login form. Lastly, you
    should restrict the users from bypassing Django and downloading restricted files
    directly. To do so on an Apache web server, you can put the `.htaccess` file in
    the `media/quotes` directory with the following content if you are using Apache
    2.2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can put the following content if you are using Apache 2.4:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `download_quote_picture()` view streams the picture from a specific inspirational
    quote. The `Content-Disposition` header that is set to `attachment` makes the
    file downloadable instead of being immediately shown in the browser. The filename
    for the file will be something similar to `walt-disney---if-you-can-dream-it-you-can-do-it.png`.
    The `@login_required` decorator will redirect the visitor to the login page if
    he or she tries to access the downloadable file without being logged in.
  prefs: []
  type: TYPE_NORMAL
- en: As we want to have a nice Bootstrap-style login form, we are using `django-crispy-forms`
    again and define a helper for the `login_helper` form. The helper is passed to
    the authorization form as an extra context variable and then used as the second
    parameter in the `{% crispy %}` template tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the CSS applied, the login form might look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04912_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Uploading images* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a form layout with django-crispy-forms* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering object lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In web development, besides views with forms, it is typical to have object-list
    views and detail views. List views can simply list objects that are ordered, for
    example, alphabetically or by creation date; however, that is not very user-friendly
    with huge amounts of data. For the best accessibility and convenience, you should
    be able to filter the content by all possible categories. In this recipe, we will
    see the pattern that is used to filter list views by any number of categories.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we''ll be creating is a list view of movies that can be filtered by genre,
    director, actor, or rating. It will look similar to the following with Bootstrap
    3 applied to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Filtering object lists](img/B04912_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the filtering example, we will use the `Movie` model with relations to
    genres, directors, and actors to filter by. It will also be possible to filter
    by ratings, which is `PositiveIntegerField` with choices. Let''s create the `movies`
    app, put it in `INSTALLED_APPS` in the settings, and define the mentioned models
    in the new app, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To complete the recipe, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we create `MovieFilterForm` with all the possible categories
    to filter by:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we create a `movie_list` view that will use `MovieFilterForm` to validate
    the request query parameters and perform the filtering for chosen categories.
    Note the `facets` dictionary that is used here to list the categories and also
    the currently selected choices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we create the template for the list view. We will use the `facets`
    dictionary here to list the categories and know which category is currently selected.
    To generate URLs for the filters, we will use the `{% modify_query %}` template
    tag, which will be described later in the *Creating a template tag to modify request
    query parameters* recipe in [Chapter 5](ch05.html "Chapter 5. Custom Template
    Filters and Tags"), *Custom Template Filters and Tags*. Copy the following code
    in the `templates/movies/movie_list.html` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a simple base template with two-column layout, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the `base.html` template. You can do that according to the example provided
    in the *Arranging the base.html template* recipe in [Chapter 4](ch04.html "Chapter 4. Templates
    and JavaScript"), *Templates and JavaScript*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are using the facets dictionary that is passed to the template context to
    know which filters we have and which filters are selected. To look deeper, the
    `facets` dictionary consists of two sections: the `categories` dictionary and
    the `selected` dictionary. The `categories` dictionary contains `QuerySets` or
    choices of all filterable categories. The `selected` dictionary contains the currently
    selected values for each category.'
  prefs: []
  type: TYPE_NORMAL
- en: In the view, we check whether the query parameters are valid in the form and
    then drill down `QuerySet` of objects from the selected categories. Additionally,
    we set the selected values to the `facets` dictionary, which will be passed to
    the template.
  prefs: []
  type: TYPE_NORMAL
- en: In the template, for each categorization from the `facets` dictionary, we list
    all the categories and mark the currently selected category as active.
  prefs: []
  type: TYPE_NORMAL
- en: It is as simple as that.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Managing paginated lists* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Composing class-based views* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template tag to modify request query parameters* recipe in [Chapter
    5](ch05.html "Chapter 5. Custom Template Filters and Tags"), *Custom Template
    Filters and Tags*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing paginated lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have dynamically changing lists of objects or the amount of them is greater
    than 30, you will surely need pagination for the list. With pagination, instead
    of the full `QuerySet`, you provide a fraction of the dataset that is limited
    to a specific amount per page and you will also show the links to get to the other
    pages of the list. Django has classes to manage the paginated data, and we will
    see how to do that in this recipe for the example provided in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with the forms and views of the `movies` app from the *Filtering
    object lists* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add pagination to the list view of the movies, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the necessary pagination classes from Django. We will add pagination
    management to the `movie_list` view just after filtering. Also, we will slightly
    modify the context dictionary by assigning `page` instead of the movie QuerySet
    to the object_list key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the template, we will add pagination controls after the list of movies,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you look at the results in the browser, you will see the pagination controls
    similar to the following, added after the list of movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04912_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How do we achieve this? When the `QuerySet` is filtered out, we will create
    a `paginator` object passing `QuerySet` and the maximal amount of items that we
    want to show per page, which is 15 here. Then, we will read the current page number
    from the query parameter, `page`. The next step is to retrieve the current page
    object from `paginator`. If the page number is not an integer, we get the first
    page. If the number exceeds the amount of possible pages, the last page is retrieved.
    The page object has methods and attributes necessary for the pagination widget
    shown in the preceding screenshot. Also, the page object acts like `QuerySet`
    so that we can iterate through it and get the items from the fraction of the page.
  prefs: []
  type: TYPE_NORMAL
- en: The snippet marked in the template creates a pagination widget with the markup
    for the Bootstrap 3 frontend framework. We show the pagination controls only if
    there are more pages than the current one. We have the links to the previous and
    next pages, and the list of all page numbers in the widget. The current page number
    is marked as active. To generate URLs for the links, we use the `{% modify_query
    %}` template tag, which will be described later in the *Creating a template tag
    to modify request query parameters* recipe in [Chapter 5](ch05.html "Chapter 5. Custom
    Template Filters and Tags"), *Custom Template Filters and Tags*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Filtering object lists* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Composing class-based views* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template tag to modify request query parameters* recipe in [Chapter
    5](ch05.html "Chapter 5. Custom Template Filters and Tags"), *Custom Template
    Filters and Tags*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing class-based views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django views are callables that take requests and return responses. In addition
    to the function-based views, Django provides an alternative way to define views
    as classes. This approach is useful when you want to create reusable modular views
    or combine views of the generic mixins. In this recipe, we will convert the previously
    shown function-based `movie_list` view to a class-based `MovieListView` view.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create the models, form, and template similar to the previous recipes, *Filtering
    object lists* and *Managing paginated lists*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will need to create a URL rule in the URL configuration and add a class-based
    view. To include a class-based view in the URL rules, the `as_view()` method is
    used, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our class-based view, `MovieListView`, will inherit the Django `View` class
    and override the `get()` and `post()` methods, which are used to distinguish between
    the requests by GET and POST. We will also add the `get_queryset_and_facets()`
    and `get_page()` methods to make the class more modular:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the things happening in the `get()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create the `form` object passing the `GET` dictionary-like object
    to it. The `GET` object contains all the query variables that are passed using
    the `GET` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the `form` is passed to the `get_queryset_and_facets()` method, which
    returns a tuple of the following two elements: the `QuerySet` and the `facets`
    dictionary respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, the current `request` object and `QuerySet` is passed to the `get_page()`
    method, which returns the current page object.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we create a context dictionary and render the response.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you see, the `get()`, `post()`, and `get_page()` methods are generic so that
    we could create a generic `FilterableListView` class with these methods in the
    `utils` app. Then, in any app that requires a filterable list, we could create
    a class-based view that extends `FilterableListView` and defines only the `form_class`
    and `template_name` attributes and the `get_queryset_and_facets()` method. This
    is how class-based views work.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Filtering object lists* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Managing paginated lists* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating PDF documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django views allow you to create much more than just HTML pages. You can generate
    files of any type. For example, you can create PDF documents for invoices, tickets,
    booking confirmations, and so on. In this recipe, we will show you how to generate
    resumes (curriculum vitae) in the PDF format out of the data from the database.
    We will be using the Pisa xhtml2pdf library, which is very practical as it allows
    you to use HTML templates to make PDF documents.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we need to install the xhtml2pdf Python library in your virtual
    environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s create a `cv` app containing a simple `CV` model with the `Experience`
    model that is attached to it through a foreign key. The `CV` model will have these
    fields: first name, last name, and e-mail. The `Experience` model will have these
    fields: the start date of a job, the end date of a job, company, position at that
    company, and the skills gained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following steps to complete the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the URL rules, let''s create a rule for the view that will download a PDF
    document of a resume by the ID of the `CV` model, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s create the `download_cv_pdf()` view. This view renders an HTML
    template and then passes the rendered string to the `pisaDocument` PDF creator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we will create the template with which the document will be rendered,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go to model administration and enter a CV document. Then, if you access the
    document''s URL at `http://127.0.0.1:8000/en/cv/1/pdf/`, you will be asked to
    download a PDF document that looks something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04912_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How does the view work? First, we load a curriculum vitae by its ID, if it exists,
    or raise the page not found error, if it doesn't. Then, we create the response
    object with the content type of the PDF document. We set the `Content-Disposition`
    header to `attachment` with the specified filename. This will force the browsers
    to open a dialog box prompting us to save the PDF document and suggesting the
    specified name for the file. Then, we render the HTML template as a string passing
    curriculum vitae object and the `MEDIA_ROOT` and `STATIC_ROOT` paths.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `src` attribute of the `<img>` tag that is used for the PDF creation
    needs to point to the file in the filesystem or the full URL of the online image.
    Pisa xhtml2pdf will download the image and include it in the PDF document.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create a `pisaDocument` file with the UTF-8-encoded HTML as source
    and response object as the destination. The response object is a file-like object
    and `pisaDocument` writes the content of the document to it. The response object
    is returned by the view as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the HTML template that is used to create this document.
    The template has some unusual markup tags and CSS rules. If we want to have some
    elements on each page of the document, we can create CSS frames for that. In the
    preceding example, the `<div>` tag with the `footerContent` ID is marked as a
    frame, which will be repeated at the bottom of each page. In a similar way, we
    can have a header or background image for each page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the specific markup tags used in this document:'
  prefs: []
  type: TYPE_NORMAL
- en: The `<pdf:nextpage>` tag sets a manual page break
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<pdf:pagenumber>` tag returns the number of the current page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<pdf:pagecount>` tag returns the total number of pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current version 0.0.6 of the Pisa xhtml2pdf library doesn't fully support
    all HTML tags and CSS rules. There are no publicly-accessible benchmarks to see
    what exactly is supported and at what level. Therefore, you would need to experiment
    in order to make a PDF document look like in the design requirements. However,
    this library is still mighty enough for customized layouts, which can be basically
    created just with the knowledge of HTML and CSS.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Managing paginated lists* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Downloading authorized files* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a multilingual search with Haystack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main functionalities of content-driven websites is a full-text search.
    Haystack is a modular search API that supports the Solr, Elasticsearch, Whoosh,
    and Xapian search engines. For each model in your project that has to be findable
    in the search, you need to define an index that will read out the textual information
    from the models and place it into the backend. In this recipe, you will learn
    how to set up a search with Haystack and the Python-based Whoosh search engine
    for a multilingual website.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the beginning, let''s create a couple of apps with models that will be indexed
    in the search. Let''s create an `ideas` app containing the `Category` and `Idea`
    models, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `Idea` model has multilingual fields, which means that there is supposed
    to be a translation of the content for each language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another app will be `quotes` from the *Uploading images* recipe with the `InspirationalQuote`
    model, where each quote can just be in any one language from the languages defined
    in `settings.LANGUAGES` and each quote doesn''t necessarily have a translation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Put these two apps in `INSTALLED_APPS` in the settings, create and apply database
    migrations, and create the model administration for these models to add some data.
    Also, create list and detail views for these models and plug them in the URL rules.
    If you are having any difficulty with any of these tasks, familiarize yourself
    with the concepts in the official Django tutorial once again: [https://docs.djangoproject.com/en/1.8/intro/tutorial01/](https://docs.djangoproject.com/en/1.8/intro/tutorial01/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you installed django-haystack, whoosh, and django-crispy-forms in
    your virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s set up the multilingual search with Haystack and Whoosh by executing
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `search` app that will contain the `MultilingualWhooshEngine` and
    search indexes for our ideas and quotes. The search engine will live in the `multilingual_whoosh_backend.py`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let''s create the search indexes, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Later, configure the settings to use our `MultilingualWhooshEngine`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to define the URL rules for the search view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, here comes the template for the search form and search results, as shown
    in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `rebuild_index` management command in order to index the database
    data and prepare the full-text search to be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `MultilingualWhooshEngine` specifies two custom properties: backend and
    query. The custom `MultilingualWhooshSearchBackend` backend ensures that, for
    each language, the items will be indexed just in that language and put under the
    specific `Haystack` index location that is defined in the `HAYSTACK_CONNECTIONS`
    setting. The `MultilingualWhooshSearchQuery` custom query ensures that when searching
    for keywords, the specific Haystack connection of the current language will be
    used.'
  prefs: []
  type: TYPE_NORMAL
- en: Each index has a field `text`, where full-text from a specific language of a
    model will be stored. The model for the index is defined by the `get_model()`
    method, `QuerySet` to index is defined by the `index_queryset()` method, and text
    to search in gets collected in the `prepare_text()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we want to have a nice Bootstrap 3 form, we will be passing `FormHelper`
    from `django-crispy-forms` to the search view. We can do that by overriding the
    `extra_context()` method of `SearchView`. The final search form will look similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04912_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The easiest way to regularly update the search index is to call the `rebuild_index`
    management command by a cron job every night. To learn about it, check the *Setting
    up cron jobs for regular tasks* recipe in [Chapter 11](ch11.html "Chapter 11. Testing
    and Deployment"), *Testing and Deployment*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating form layout with django-crispy-forms* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Downloading authorized file* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Setting up cron jobs for regular tasks* recipe in [Chapter 11](ch11.html
    "Chapter 11. Testing and Deployment"), *Testing and Deployment*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
