- en: Chapter 3. Forms and Views
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。表单和视图
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Passing HttpRequest to the form
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将HttpRequest传递给表单
- en: Utilizing the save method of the form
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用表单的save方法
- en: Uploading images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传图片
- en: Creating form layout with django-crispy-forms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用django-crispy-forms创建表单布局
- en: Downloading authorized files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载授权文件
- en: Filtering object lists
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤对象列表
- en: Managing paginated lists
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理分页列表
- en: Composing class-based views
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写基于类的视图
- en: Generating PDF documents
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成PDF文档
- en: Implementing a multilingual search with Haystack
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Haystack实现多语言搜索
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: When the database structure is defined in the models, we need some views to
    let the users enter data or show the data to the people. In this chapter, we will
    focus on the views managing forms, the list view, and views generating an alternative
    output than HTML. For the simplest examples, we will leave the creation of URL
    rules and templates up to you.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当在模型中定义数据库结构时，我们需要一些视图让用户输入数据或向他人展示数据。在本章中，我们将重点关注管理表单、列表视图以及生成HTML之外输出的视图。对于最简单的示例，我们将把URL规则和模板的创建留给你。
- en: Passing HttpRequest to the form
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将HttpRequest传递给表单
- en: The first argument of every Django view is the `HttpRequest` object that is
    usually named `request`. It contains metadata about the request. For example,
    current language code, current user, current cookies, and current session. By
    default, the forms that are used in the views accept the `GET` or `POST` parameters,
    files, initial data, and other parameters; however, not the `HttpRequest` object.
    In some cases, it is useful to additionally pass `HttpRequest` to the form, especially
    when you want to filter out the choices of form fields using the request data
    or handle saving something such as the current user or IP in the form.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Django视图的第一个参数是`HttpRequest`对象，通常命名为`request`。它包含有关请求的元数据。例如，当前语言代码、当前用户、当前cookie和当前会话。默认情况下，在视图中使用的表单接受`GET`或`POST`参数、文件、初始数据和其他参数；然而，不接受`HttpRequest`对象。在某些情况下，将`HttpRequest`传递给表单很有用，特别是当你想使用请求数据过滤表单字段的选项或处理保存某些内容，如当前用户或IP在表单中时。
- en: In this recipe, we will see an example of a form where a person can choose a
    user and write a message to them. We will pass the `HttpRequest` object to the
    form in order to exclude the current user from the recipient choices; we don't
    want anybody to write a message to themselves.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到一个示例表单，人们可以选择一个用户并向他们发送消息。我们将把`HttpRequest`对象传递给表单，以便排除当前用户从收件人选项中；我们不希望任何人给自己发消息。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's create a new app called `email_messages` and put it in `INSTALLED_APPS`
    in the settings. This app will have no models, just forms and views.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`email_messages`的新应用，并将其放入设置中的`INSTALLED_APPS`。此应用将没有模型，只有表单和视图。
- en: How to do it…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To complete this recipe, execute the following steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个菜谱，执行以下步骤：
- en: 'Add a new `forms.py` file with the message form containing two fields: the
    recipient selection and message text. Also, this form will have an initialization
    method, which will accept the request object and then, modify `QuerySet` for the
    recipient''s selection field:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`forms.py`文件中添加一个新的包含两个字段的表单：收件人选择和消息文本。此外，此表单将有一个初始化方法，该方法将接受请求对象，然后修改收件人选择字段的`QuerySet`：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, create `views.py` with the `message_to_user()` view in order to handle
    the form. As you can see, the request object is passed as the first parameter
    to the form, as follows:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建包含`message_to_user()`视图的`views.py`文件以处理表单。正如你所看到的，请求对象作为第一个参数传递给表单，如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the initialization method, we have the `self` variable that represents the
    instance of the form itself, we also have the newly added `request` variable,
    and then we have the rest of the positional arguments (`*args`) and named arguments
    (`**kwargs`). We call the `super()` initialization method passing all the positional
    and named arguments to it so that the form is properly initiated. We will then
    assign the `request` variable to a new `request` attribute of the form for later
    access in other methods of the form. Then, we modify the `queryset` attribute
    of the recipient's selection field, excluding the current user from the request.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化方法中，我们有`self`变量，它代表表单本身的实例，我们还有新添加的`request`变量，然后我们有剩余的位置参数（`*args`）和命名参数（`**kwargs`）。我们调用`super()`初始化方法，将所有位置和命名参数传递给它，以便正确初始化表单。然后，我们将`request`变量分配给表单的新`request`属性，以便在表单的其他方法中稍后访问。然后，我们修改收件人选择字段的`queryset`属性，排除请求中的当前用户。
- en: 'In the view, we will pass the `HttpRequest` object as the first argument in
    both situations: when the form is posted, as well as when it is loaded for the
    first time.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中，我们将在这两种情况下将`HttpRequest`对象作为第一个参数传递：当表单提交时，以及当它第一次加载时。
- en: See also
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Utilizing the save method of the form* recipe
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表单的保存方法
- en: Utilizing the save method of the form
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用表单的保存方法
- en: To make your views clean and simple, it is good practice to move the handling
    of the form data to the form itself whenever possible and makes sense. The common
    practice is to have a `save()` method that will save the data, perform search,
    or do some other smart actions. We will extend the form that is defined in the
    previous recipe with the `save()` method, which will send an e-mail to the selected
    recipient.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使视图简洁明了，在可能且合理的情况下，将表单数据的处理移动到表单本身是一个好的做法。常见的做法是有一个`save()`方法，它将保存数据，执行搜索或执行其他智能操作。我们将扩展之前菜谱中定义的表单，添加`save()`方法，这将向选定的收件人发送电子邮件。
- en: Getting ready
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will build upon the example that is defined in the *Passing HttpRequest to
    the form* recipe.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于*将HttpRequest传递给表单*菜谱中定义的示例进行构建。
- en: How to do it…
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To complete this recipe, execute the following two steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个菜谱，执行以下两个步骤：
- en: 'From Django, import the function in order to send an e-mail. Then, add the
    `save()` method to `MessageForm`. It will try to send an e-mail to the selected
    recipient and will fail silently if any errors occur:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Django导入函数以发送电子邮件。然后，将`save()`方法添加到`MessageForm`中。它将尝试向选定的收件人发送电子邮件，如果发生任何错误，它将静默失败：
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, call the `save()` method from the form in the view if the posted data
    is valid:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果提交的数据有效，从视图中调用表单的`save()`方法：
- en: '[PRE3]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Let's take a look at the form. The `save()` method uses the cleaned data from
    the form to read the recipient's e-mail address and the message. The sender of
    the e-mail is the current user from the request. If the e-mail cannot be sent
    due to an incorrect mail server configuration or another reason, it will fail
    silently; that is, no error will be raised.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看表单。`save()`方法使用表单的清理数据来读取收件人的电子邮件地址和消息。电子邮件的发送者是请求中的当前用户。如果由于邮件服务器配置错误或其他原因无法发送电子邮件，它将静默失败；也就是说，不会引发错误。
- en: Now, let's look at the view. When the posted form is valid, the `save()` method
    of the form will be called and the user will be redirected to the success page.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看视图。当提交的表单有效时，表单的`save()`方法将被调用，用户将被重定向到成功页面。
- en: See also
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Passing HttpRequest to the form* recipe
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将HttpRequest传递给表单
- en: The *Downloading authorized files* recipe
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载授权文件菜谱
- en: Uploading images
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传图片
- en: In this recipe, we will take a look at the easiest way to handle image uploads.
    You will see an example of an app, where the visitors can upload images with inspirational
    quotes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将查看处理图像上传的最简单方法。您将看到一个示例应用，访客可以上传带有励志名言的图片。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure to have Pillow or PIL installed in your virtual environment or globally.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在您的虚拟环境或全局范围内安装了Pillow或PIL。
- en: 'Then, let''s create a `quotes` app and put it in `INSTALLED_APPS` in the settings.
    Then, we will add an `InspirationalQuote` model with three fields: the `author`,
    `quote` text, and `picture`, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们创建一个`quotes`应用，并将其放入设置中的`INSTALLED_APPS`。然后，我们将添加一个具有三个字段（`author`、`quote`文本和`picture`）的`InspirationalQuote`模型，如下所示：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In addition, we created an `upload_to()` function, which sets the path of the
    uploaded picture to be something similar to `quotes/2015/04/20150424140000.png`.
    As you can see, we use the date timestamp as the filename to ensure its uniqueness.
    We pass this function to the `picture` image field.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们创建了一个 `upload_to()` 函数，它将上传图片的路径设置为类似于 `quotes/2015/04/20150424140000.png`
    的东西。如您所见，我们使用日期时间戳作为文件名以确保其唯一性。我们将此函数传递给 `picture` 图像字段。
- en: How to do it…
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Execute these steps to complete the recipe:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成配方：
- en: 'Create the `forms.py` file and put a simple model form there:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `forms.py` 文件并将一个简单的模型表单放在那里：
- en: '[PRE5]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `views.py` file, put a view that handles the form. Don''t forget to
    pass the `FILES` dictionary-like object to the form. When the form is valid, trigger
    the save method as follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `views.py` 文件中，放置一个处理表单的视图。别忘了将 `FILES` 字典对象传递给表单。当表单有效时，按照以下方式触发保存方法：
- en: '[PRE6]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Lastly, create a template for the view in `templates/quotes/change_quote.html`.
    It is very important to set the `enctype` attribute to `multipart/form-data` for
    the HTML form, otherwise the file upload won''t work:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `templates/quotes/change_quote.html` 中创建视图的模板。对于 HTML 表单，设置 `enctype` 属性为
    `multipart/form-data` 非常重要，否则文件上传将不会工作：
- en: '[PRE7]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works…
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Django model forms are forms that are created from models. They provide all
    the fields from the model so you don't need to define them again. In the preceding
    example, we created a model form for the `InspirationalQuote` model. When we save
    the form, the form knows how to save each field in the database, as well as to
    upload the files and save them in the media directory.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Django 模型表单是从模型创建的表单。它们提供了模型中的所有字段，因此您不需要再次定义它们。在前面的例子中，我们为 `InspirationalQuote`
    模型创建了一个模型表单。当我们保存表单时，表单知道如何将每个字段保存到数据库中，以及如何上传文件并将它们保存到媒体目录中。
- en: There's more
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: As a bonus, we will see an example of how to generate a thumbnail out of the
    uploaded image. Using this technique, you could also generate several other specific
    versions of the image, such as the list version, mobile version, and desktop computer
    version.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外奖励，我们将看到一个如何从上传的图像生成缩略图的例子。使用这种技术，您还可以生成图像的几个其他特定版本，例如列表版本、移动版本和桌面计算机版本。
- en: 'We will add three methods to the `InspirationalQuote` model (`quotes/models.py`).
    They are `save()`, `create_thumbnail()`, and `get_thumbnail_picture_url()`. When
    the model is being saved, we will trigger the creation of the thumbnail. When
    we need to show the thumbnail in a template, we can get its URL using `{{ quote.get_thumbnail_picture_url
    }}`. The method definitions are as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向 `InspirationalQuote` 模型（`quotes/models.py`）添加三个方法。它们是 `save()`、`create_thumbnail()`
    和 `get_thumbnail_picture_url()`。当模型正在保存时，我们将触发缩略图的创建。当我们需要在模板中显示缩略图时，我们可以使用 `{{
    quote.get_thumbnail_picture_url }}` 获取其 URL。方法定义如下：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding methods, we are using the file storage API instead of directly
    juggling the filesystem, as we could then exchange the default storage with Amazon
    S3 buckets or other storage services and the methods will still work.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们使用文件存储 API 而不是直接操作文件系统，这样我们就可以用 Amazon S3 存储桶或其他存储服务替换默认存储，而方法仍然有效。
- en: How does the creating the thumbnail work? If we had the original file saved
    as `quotes/2014/04/20140424140000.png`, we are checking whether the `quotes/2014/04/20140424140000_thumbnail.jpg`
    file doesn't exist and, in that case, we are opening the original image, cropping
    it from the center, resizing it to 50 x 50 pixels, and saving it to the storage.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 缩略图的创建是如何工作的？如果我们把原始文件保存为 `quotes/2014/04/20140424140000.png`，我们将检查 `quotes/2014/04/20140424140000_thumbnail.jpg`
    文件是否存在，如果不存在，我们将打开原始图像，从中裁剪出中心部分，将其调整到 50 x 50 像素，并将其保存到存储中。
- en: The `get_thumbnail_picture_url()` method checks whether the thumbnail version
    exists in the storage and returns its URL. If the thumbnail version does not exist,
    the URL of the original image is returned as a fallback.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_thumbnail_picture_url()` 方法检查缩略图版本是否存储中存在，并返回其 URL。如果缩略图版本不存在，则返回原始图像的
    URL 作为后备。'
- en: See also
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a form layout with django-crispy-forms* recipe
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 django-crispy-forms 创建表单布局* 的配方'
- en: Creating a form layout with django-crispy-forms
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 django-crispy-forms 创建表单布局
- en: 'The `django-crispy-forms` Django app allows you to build, customize, and reuse
    forms using one of the following CSS frameworks: Uni-Form, Bootstrap, or Foundation.
    The usage of `django-crispy-forms` is analogous to fieldsets in the Django contributed
    administration; however, it is more advanced and customizable. You define form
    layout in the Python code and you don''t need to worry about how each field is
    presented in HTML. However, if you need to add specific HTML attributes or wrapping,
    you can easily do that too. Moreover, all the markup used by `django-crispy-forms`
    is located in the templates that can be overwritten for specific needs.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`django-crispy-forms` Django应用允许你使用以下CSS框架之一：Uni-Form、Bootstrap或Foundation来构建、自定义和重用表单。`django-crispy-forms`的使用与Django贡献的行政中的字段集类似；然而，它更高级且可自定义。你在Python代码中定义表单布局，你不需要担心每个字段在HTML中的呈现方式。然而，如果你需要添加特定的HTML属性或包装，你也可以轻松做到。此外，`django-crispy-forms`使用的所有标记都位于模板中，可以根据特定需求进行覆盖。'
- en: In this recipe, we will see an example of how to use `django-crispy-forms` with
    Bootstrap 3, which is the most popular frontend framework to develop responsive,
    mobile-first web projects.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看到一个如何使用Bootstrap 3与`django-crispy-forms`结合的示例，Bootstrap 3是最受欢迎的前端框架，用于开发响应式、以移动端优先的Web项目。
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To start with, execute the following tasks one by one:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，依次执行以下任务：
- en: Download the Bootstrap frontend framework from [http://getbootstrap.com/](http://getbootstrap.com/)
    and integrate CSS and JavaScript in the templates. Learn more about this in the
    *Arranging the base.html template* recipe in [Chapter 4](ch04.html "Chapter 4. Templates
    and JavaScript"), *Templates and JavaScript*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从[http://getbootstrap.com/](http://getbootstrap.com/)下载Bootstrap前端框架，并在模板中集成CSS和JavaScript。更多关于这方面的内容，请参考[第4章](ch04.html
    "第4章. 模板和JavaScript")中的*安排base.html模板*配方，*模板和JavaScript*。
- en: 'Install `django-crispy-forms` in your virtual environment using the following
    command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令在你的虚拟环境中安装`django-crispy-forms`：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Make sure that `crispy_forms` is added to `INSTALLED_APPS` and then set `bootstrap3`
    as the template pack to be used in this project:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将`crispy_forms`添加到`INSTALLED_APPS`，然后设置`bootstrap3`为在此项目中使用的模板包：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s create a `bulletin_board` app to illustrate the usage of `django-crispy-forms`
    and put it in `INSTALLED_APPS` in the settings. We will have a `Bulletin` model
    there with these fields: `bulletin_type`, `title`, `description`, `contact_person`,
    `phone`, `email`, and `image` as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`bulletin_board`应用来展示`django-crispy-forms`的使用，并将其放入设置中的`INSTALLED_APPS`。我们将有一个`Bulletin`模型，包含以下字段：`bulletin_type`、`title`、`description`、`contact_person`、`phone`、`email`和`image`，如下所示：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How to do it…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow these steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: 'Let''s add a model form for the bulletin in the newly created app. We will
    attach a form helper to the form in the initialization method itself. The form
    helper will have the layout property that will define the layout for the form,
    as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在新创建的应用中添加一个公告的模型表单。我们将在初始化方法本身中附加一个表单助手。表单助手将具有布局属性，这将定义表单的布局，如下所示：
- en: '[PRE12]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To render the form in the template, we just need to load the `crispy_forms_tags`
    template tag library and use the `{% crispy %}` template tag as shown in the following:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在模板中渲染表单，我们只需要加载`crispy_forms_tags`模板标签库，并使用如下所示的`{% crispy %}`模板标签：
- en: '[PRE13]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Create the `base.html` template. You can do this according to the example in
    the *Arranging the base.html template* recipe in [Chapter 4](ch04.html "Chapter 4. Templates
    and JavaScript"), *Templates and JavaScript*.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`base.html`模板。你可以根据[第4章](ch04.html "第4章. 模板和JavaScript")中的*安排base.html模板*配方中的示例来做这件事，*模板和JavaScript*。
- en: How it works…
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: 'The page with the bulletin form will look similar to the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 包含公告表单的页面将类似于以下所示：
- en: '![How it works…](img/B04912_03_01.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/B04912_03_01.jpg)'
- en: As you can see, the fields are grouped by fieldsets. The first argument of the
    `Fieldset` object defines the legend, the other positional arguments define the
    fields. You can also pass named arguments to define the HTML attributes for the
    fieldset; for example, for the second fieldset, we are passing `title` and `css_id`
    to set the `title` and `id` HTML attributes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，字段是按字段集分组的。`Fieldset`对象的第一个参数定义了图例，其他位置参数定义了字段。你也可以传递命名参数来定义字段集的HTML属性；例如，对于第二个字段集，我们传递了`title`和`css_id`来设置`title`和`id`HTML属性。
- en: Fields can also have additional attributes passed by named arguments; for example,
    for the `description` field, we are passing `css_class` and `rows` to set the
    `class` and `rows` HTML attributes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 字段也可以通过命名参数传递额外的属性；例如，对于`description`字段，我们正在传递`css_class`和`rows`来设置HTML的`class`和`rows`属性。
- en: Besides the normal fields, you can pass HTML snippets as this is done with the
    help block for the image field. You can also have prepended text fields in the
    layout. For example, we added a phone icon to the **Phone** field and an `@` sign
    for the **Email** field. As you can see from the example with the contact fields,
    we can easily wrap fields in the HTML `<div>` elements using the `Div` objects.
    This is useful when specific JavaScript needs to be applied to some form fields.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 除了正常字段外，你还可以传递HTML片段，因为这是通过图像字段的帮助块完成的。你还可以在布局中添加前置文本字段。例如，我们在**电话**字段中添加了一个电话图标，在**电子邮件**字段中添加了一个`@`符号。正如你从联系字段的示例中看到的，我们可以很容易地使用`Div`对象将字段包裹在HTML
    `<div>`元素中。当需要将特定的JavaScript应用于某些表单字段时，这很有用。
- en: The `action` attribute for the HTML form is defined by the `form_action` property
    of the form helper. If you use the empty string as an action, the form will be
    submitted to the same view, where the form is included. The `method` attribute
    of the HTML form is defined by the `form_method` property of the form helper.
    As you know, the HTML forms allow the GET and POST methods. Finally, there is
    a `Submit` object in order to render the submit button, which takes the name of
    the button as the first positional argument and the value of the button as the
    second argument.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: HTML表单的`action`属性由表单辅助器的`form_action`属性定义。如果你使用空字符串作为action，表单将被提交到包含表单的同一视图。HTML表单的`method`属性由表单辅助器的`form_method`属性定义。正如你所知，HTML表单允许GET和POST方法。最后，有一个`Submit`对象用于渲染提交按钮，它将按钮的名称作为第一个位置参数，将按钮的值作为第二个参数。
- en: There's more…
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: For the basic usage, the given example is more than necessary. However, if you
    need a specific markup for the forms in your project, you can still overwrite
    and modify templates of the `django-crispy-forms` app as there is no markup hardcoded
    in the Python files, rather all the generated markup is rendered through the templates.
    Just copy the templates from the `django-crispy-forms` app to your project's template
    directory and change them as required.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基本用法，给定的示例已经足够了。然而，如果你需要为你的项目中的表单指定特定的标记，你仍然可以覆盖和修改`django-crispy-forms`应用的模板，因为这些标记不是硬编码在Python文件中的，而是通过模板渲染生成的。只需将`django-crispy-forms`应用的模板复制到你的项目模板目录，并按需更改它们。
- en: See also
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Filtering object lists* recipe
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*过滤对象列表*菜谱'
- en: The *Managing paginated lists* recipe
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管理分页列表*菜谱'
- en: The *Downloading authorized files* recipe
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*下载授权文件*菜谱'
- en: Downloading authorized files
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载授权文件
- en: Sometimes, you might need to allow only specific people to download intellectual
    property from your website. For example, music, videos, literature, or other artistic
    works should be accessible only to the paid members. In this recipe, you will
    learn how to restrict image downloads only to the authenticated users using the
    contributed Django auth app.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要只允许特定的人从你的网站上下载知识产权。例如，音乐、视频、文学或其他艺术作品应该只对付费会员开放。在这个菜谱中，你将学习如何仅通过贡献的Django认证应用限制认证用户下载图片。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To start, create the `quotes` app as in the *Uploading images* recipe.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建`quotes`应用，就像在*上传图片*菜谱中做的那样。
- en: How to do it…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Execute these steps one by one:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 依次执行以下步骤：
- en: 'Create the view that will require authentication to download a file, as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个需要认证才能下载文件的视图，如下所示：
- en: '[PRE14]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the view to the URL configuration:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将视图添加到URL配置中：
- en: '[PRE15]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we need to set the login view in project URL configuration. Note how
    we are also adding `login_helper` for `django-crispy-forms`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要在项目URL配置中设置登录视图。注意我们是如何也为`django-crispy-forms`添加`login_helper`的：
- en: '[PRE16]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s create a template for the login form, as shown in the following:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为登录表单创建一个模板，如下所示：
- en: '[PRE17]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create the `login.css` file to add some style to the login form. Lastly, you
    should restrict the users from bypassing Django and downloading restricted files
    directly. To do so on an Apache web server, you can put the `.htaccess` file in
    the `media/quotes` directory with the following content if you are using Apache
    2.2:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `login.css` 文件以给登录表单添加一些样式。最后，你应该限制用户绕过 Django 直接下载受限制的文件。如果你使用的是 Apache
    网络服务器，可以在使用 Apache 2.2 时，将 `.htaccess` 文件放在 `media/quotes` 目录中，并包含以下内容：
- en: '[PRE18]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can put the following content if you are using Apache 2.4:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用的是 Apache 2.4，可以放置以下内容：
- en: '[PRE19]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works…
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `download_quote_picture()` view streams the picture from a specific inspirational
    quote. The `Content-Disposition` header that is set to `attachment` makes the
    file downloadable instead of being immediately shown in the browser. The filename
    for the file will be something similar to `walt-disney---if-you-can-dream-it-you-can-do-it.png`.
    The `@login_required` decorator will redirect the visitor to the login page if
    he or she tries to access the downloadable file without being logged in.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`download_quote_picture()` 视图从特定的励志引语中流式传输图片。将 `Content-Disposition` 标头设置为
    `attachment` 使得文件可下载而不是立即在浏览器中显示。文件的名称将类似于 `walt-disney---if-you-can-dream-it-you-can-do-it.png`。如果访客未登录而尝试访问可下载文件，`@login_required`
    装饰器将重定向访客到登录页面。'
- en: As we want to have a nice Bootstrap-style login form, we are using `django-crispy-forms`
    again and define a helper for the `login_helper` form. The helper is passed to
    the authorization form as an extra context variable and then used as the second
    parameter in the `{% crispy %}` template tag.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要有一个漂亮的 Bootstrap 风格的登录表单，我们再次使用 `django-crispy-forms` 并为 `login_helper`
    表单定义一个辅助器。辅助器作为额外的上下文变量传递给授权表单，然后作为 `{% crispy %}` 模板标签的第二个参数使用。
- en: 'Depending on the CSS applied, the login form might look similar to the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用的 CSS，登录表单可能看起来类似于以下内容：
- en: '![How it works…](img/B04912_03_02.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B04912_03_02.jpg)'
- en: See also
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Uploading images* recipe
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*上传图片* 配方'
- en: The *Creating a form layout with django-crispy-forms* recipe
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 django-crispy-forms 创建表单布局* 配方'
- en: Filtering object lists
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤对象列表
- en: In web development, besides views with forms, it is typical to have object-list
    views and detail views. List views can simply list objects that are ordered, for
    example, alphabetically or by creation date; however, that is not very user-friendly
    with huge amounts of data. For the best accessibility and convenience, you should
    be able to filter the content by all possible categories. In this recipe, we will
    see the pattern that is used to filter list views by any number of categories.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络开发中，除了带有表单的视图外，通常还会有对象列表视图和详细视图。列表视图可以简单地列出按顺序排列的对象，例如按字母顺序或创建日期排序；然而，对于大量数据来说，这并不非常用户友好。为了最佳的可访问性和便利性，你应该能够通过所有可能的类别过滤内容。在这个配方中，我们将看到用于通过任意数量的类别过滤列表视图的模式。
- en: 'What we''ll be creating is a list view of movies that can be filtered by genre,
    director, actor, or rating. It will look similar to the following with Bootstrap
    3 applied to it:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的是一个可以按类型、导演、演员或评分过滤的电影列表视图。应用 Bootstrap 3 后，它看起来将类似于以下内容：
- en: '![Filtering object lists](img/B04912_03_03.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![过滤对象列表](img/B04912_03_03.jpg)'
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For the filtering example, we will use the `Movie` model with relations to
    genres, directors, and actors to filter by. It will also be possible to filter
    by ratings, which is `PositiveIntegerField` with choices. Let''s create the `movies`
    app, put it in `INSTALLED_APPS` in the settings, and define the mentioned models
    in the new app, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于过滤示例，我们将使用与类型、导演和演员有关系的 `Movie` 模型来过滤。也可以按评分过滤，这是一个带有选项的 `PositiveIntegerField`。让我们创建
    `movies` 应用程序，将其放入设置中的 `INSTALLED_APPS`，并在新应用中定义所提到的模型，如下所示：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How to do it…
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To complete the recipe, follow these steps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个配方，请按照以下步骤操作：
- en: 'First of all, we create `MovieFilterForm` with all the possible categories
    to filter by:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建包含所有可能的过滤类别的 `MovieFilterForm`：
- en: '[PRE21]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we create a `movie_list` view that will use `MovieFilterForm` to validate
    the request query parameters and perform the filtering for chosen categories.
    Note the `facets` dictionary that is used here to list the categories and also
    the currently selected choices:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个 `movie_list` 视图，它将使用 `MovieFilterForm` 验证请求查询参数并执行所选类别的过滤。注意这里使用的
    `facets` 字典，它用于列出类别和当前选定的选项：
- en: '[PRE22]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Lastly, we create the template for the list view. We will use the `facets`
    dictionary here to list the categories and know which category is currently selected.
    To generate URLs for the filters, we will use the `{% modify_query %}` template
    tag, which will be described later in the *Creating a template tag to modify request
    query parameters* recipe in [Chapter 5](ch05.html "Chapter 5. Custom Template
    Filters and Tags"), *Custom Template Filters and Tags*. Copy the following code
    in the `templates/movies/movie_list.html` directory:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建列表视图的模板。在这里，我们将使用`facets`字典来列出分类并知道哪个分类当前被选中。为了生成过滤器的URL，我们将使用`{% modify_query
    %}`模板标签，该标签将在[第5章](ch05.html "第5章。自定义模板过滤器和标签")的*创建一个用于修改请求查询参数的模板标签*食谱中进行描述，*自定义模板过滤器和标签*。请在`templates/movies/movie_list.html`目录中复制以下代码：
- en: '[PRE23]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add a simple base template with two-column layout, as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个简单的两列布局的基本模板，如下所示：
- en: '[PRE24]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Create the `base.html` template. You can do that according to the example provided
    in the *Arranging the base.html template* recipe in [Chapter 4](ch04.html "Chapter 4. Templates
    and JavaScript"), *Templates and JavaScript*.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`base.html`模板。你可以根据[第4章](ch04.html "第4章。模板和JavaScript")中提供的*安排base.html模板*食谱进行操作，*模板和JavaScript*。
- en: How it works…
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'We are using the facets dictionary that is passed to the template context to
    know which filters we have and which filters are selected. To look deeper, the
    `facets` dictionary consists of two sections: the `categories` dictionary and
    the `selected` dictionary. The `categories` dictionary contains `QuerySets` or
    choices of all filterable categories. The `selected` dictionary contains the currently
    selected values for each category.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用传递给模板上下文的`facets`字典来了解我们有哪些过滤器以及哪些过滤器被选中。为了深入了解，`facets`字典由两部分组成：`categories`字典和`selected`字典。`categories`字典包含所有可过滤分类的`QuerySets`或选择。`selected`字典包含每个分类当前选中的值。
- en: In the view, we check whether the query parameters are valid in the form and
    then drill down `QuerySet` of objects from the selected categories. Additionally,
    we set the selected values to the `facets` dictionary, which will be passed to
    the template.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中，我们检查查询参数是否以表单的形式有效，然后从选定的分类中钻取对象的`QuerySet`。此外，我们将选定的值设置到`facets`字典中，该字典将被传递到模板。
- en: In the template, for each categorization from the `facets` dictionary, we list
    all the categories and mark the currently selected category as active.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，对于`facets`字典中的每个分类，我们列出所有分类并将当前选中的分类标记为活动状态。
- en: It is as simple as that.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如此简单。
- en: See also
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Managing paginated lists* recipe
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管理分页列表*食谱'
- en: The *Composing class-based views* recipe
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组合基于类的视图*食谱'
- en: The *Creating a template tag to modify request query parameters* recipe in [Chapter
    5](ch05.html "Chapter 5. Custom Template Filters and Tags"), *Custom Template
    Filters and Tags*
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](ch05.html "第5章。自定义模板过滤器和标签")中的*创建一个用于修改请求查询参数的模板标签*食谱，*自定义模板过滤器和标签*'
- en: Managing paginated lists
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理分页列表
- en: If you have dynamically changing lists of objects or the amount of them is greater
    than 30, you will surely need pagination for the list. With pagination, instead
    of the full `QuerySet`, you provide a fraction of the dataset that is limited
    to a specific amount per page and you will also show the links to get to the other
    pages of the list. Django has classes to manage the paginated data, and we will
    see how to do that in this recipe for the example provided in the previous recipe.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个动态变化的对象列表或者它们的数量超过30，你肯定需要分页列表。有了分页，你提供的数据集的一部分而不是完整的`QuerySet`，限制每页的数量，你还会显示链接以访问列表的其他页面。Django有管理分页数据的类，我们将在本食谱中看到如何做到这一点，该食谱提供了上一个食谱中的示例。
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's start with the forms and views of the `movies` app from the *Filtering
    object lists* recipe.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从*过滤对象列表*食谱中的`movies`应用的表单和视图开始。
- en: How to do it…
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To add pagination to the list view of the movies, follow these steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要将分页添加到电影的列表视图，请按照以下步骤操作：
- en: 'First, import the necessary pagination classes from Django. We will add pagination
    management to the `movie_list` view just after filtering. Also, we will slightly
    modify the context dictionary by assigning `page` instead of the movie QuerySet
    to the object_list key:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从Django导入必要的分页类。我们将在过滤后立即将分页管理添加到`movie_list`视图。此外，我们将稍微修改上下文字典，将`page`对象而不是电影`QuerySet`分配给`object_list`键：
- en: '[PRE25]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the template, we will add pagination controls after the list of movies,
    as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板中，我们将在电影列表之后添加分页控件，如下所示：
- en: '[PRE26]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works…
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'When you look at the results in the browser, you will see the pagination controls
    similar to the following, added after the list of movies:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在浏览器中查看结果时，你会看到类似以下分页控件，添加在电影列表之后：
- en: '![How it works…](img/B04912_03_04.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B04912_03_04.jpg)'
- en: How do we achieve this? When the `QuerySet` is filtered out, we will create
    a `paginator` object passing `QuerySet` and the maximal amount of items that we
    want to show per page, which is 15 here. Then, we will read the current page number
    from the query parameter, `page`. The next step is to retrieve the current page
    object from `paginator`. If the page number is not an integer, we get the first
    page. If the number exceeds the amount of possible pages, the last page is retrieved.
    The page object has methods and attributes necessary for the pagination widget
    shown in the preceding screenshot. Also, the page object acts like `QuerySet`
    so that we can iterate through it and get the items from the fraction of the page.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是如何实现这一点的？当`QuerySet`被过滤时，我们将创建一个`paginator`对象，传递`QuerySet`和每页显示的最大项目数，这里为15。然后，我们将从查询参数`page`中读取当前页码。下一步是从`paginator`中检索当前页对象。如果页码不是整数，我们获取第一页。如果数字超过可能的页数，则检索最后一页。页对象具有显示在前面截图中的分页小部件所需的方法和属性。此外，页对象像`QuerySet`一样工作，这样我们就可以遍历它并从页面的部分中获取项目。
- en: The snippet marked in the template creates a pagination widget with the markup
    for the Bootstrap 3 frontend framework. We show the pagination controls only if
    there are more pages than the current one. We have the links to the previous and
    next pages, and the list of all page numbers in the widget. The current page number
    is marked as active. To generate URLs for the links, we use the `{% modify_query
    %}` template tag, which will be described later in the *Creating a template tag
    to modify request query parameters* recipe in [Chapter 5](ch05.html "Chapter 5. Custom
    Template Filters and Tags"), *Custom Template Filters and Tags*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 模板中标记的片段使用Bootstrap 3前端框架的标记创建分页小部件。我们仅在存在多于当前页面的页面时显示分页控件。小部件中包含上一页和下一页的链接，以及所有页码的列表。当前页码被标记为活动状态。为了生成链接的URL，我们使用`{%
    modify_query %}`模板标签，这将在[第5章](ch05.html "第5章。自定义模板过滤器和标签")的*创建用于修改请求查询参数的模板标签*配方中稍后描述，*自定义模板过滤器和标签*。
- en: See also
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Filtering object lists* recipe
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*过滤对象列表*配方'
- en: The *Composing class-based views* recipe
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写基于类的视图*配方'
- en: The *Creating a template tag to modify request query parameters* recipe in [Chapter
    5](ch05.html "Chapter 5. Custom Template Filters and Tags"), *Custom Template
    Filters and Tags*
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](ch05.html "第5章。自定义模板过滤器和标签")中的*创建用于修改请求查询参数的模板标签*配方，*自定义模板过滤器和标签*'
- en: Composing class-based views
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写基于类的视图
- en: Django views are callables that take requests and return responses. In addition
    to the function-based views, Django provides an alternative way to define views
    as classes. This approach is useful when you want to create reusable modular views
    or combine views of the generic mixins. In this recipe, we will convert the previously
    shown function-based `movie_list` view to a class-based `MovieListView` view.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Django视图是可调用的，它接受请求并返回响应。除了基于函数的视图外，Django还提供了一种将视图定义为类的方法。当您想要创建可重用的模块化视图或组合通用混合视图时，这种方法很有用。在这个配方中，我们将之前显示的基于函数的`movie_list`视图转换为基于类的`MovieListView`视图。
- en: Getting ready
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create the models, form, and template similar to the previous recipes, *Filtering
    object lists* and *Managing paginated lists*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模型、表单和模板，类似于之前的配方，*过滤对象列表*和*管理分页列表*。
- en: How to do it…
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We will need to create a URL rule in the URL configuration and add a class-based
    view. To include a class-based view in the URL rules, the `as_view()` method is
    used, as follows:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在URL配置中创建一个URL规则并添加一个基于类的视图。要将基于类的视图包含在URL规则中，使用`as_view()`方法，如下所示：
- en: '[PRE27]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Our class-based view, `MovieListView`, will inherit the Django `View` class
    and override the `get()` and `post()` methods, which are used to distinguish between
    the requests by GET and POST. We will also add the `get_queryset_and_facets()`
    and `get_page()` methods to make the class more modular:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的基于类的视图`MovieListView`将继承Django的`View`类并重写`get()`和`post()`方法，这些方法用于区分GET和POST请求。我们还将添加`get_queryset_and_facets()`和`get_page()`方法，使类更加模块化：
- en: '[PRE28]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works…
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The following are the things happening in the `get()` method:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 `get()` 方法中发生的事情：
- en: First, we create the `form` object passing the `GET` dictionary-like object
    to it. The `GET` object contains all the query variables that are passed using
    the `GET` method.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建 `form` 对象，将其传递给 `GET` 字典样式的对象。`GET` 对象包含所有使用 `GET` 方法传递的查询变量。
- en: 'Then, the `form` is passed to the `get_queryset_and_facets()` method, which
    returns a tuple of the following two elements: the `QuerySet` and the `facets`
    dictionary respectively.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将 `form` 传递给 `get_queryset_and_facets()` 方法，该方法返回一个包含以下两个元素的元组：`QuerySet`
    和 `facets` 字典。
- en: Then, the current `request` object and `QuerySet` is passed to the `get_page()`
    method, which returns the current page object.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当前 `request` 对象和 `QuerySet` 被传递给 `get_page()` 方法，该方法返回当前页面对象。
- en: Lastly, we create a context dictionary and render the response.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个上下文字典并渲染响应。
- en: There's more…
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: As you see, the `get()`, `post()`, and `get_page()` methods are generic so that
    we could create a generic `FilterableListView` class with these methods in the
    `utils` app. Then, in any app that requires a filterable list, we could create
    a class-based view that extends `FilterableListView` and defines only the `form_class`
    and `template_name` attributes and the `get_queryset_and_facets()` method. This
    is how class-based views work.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`get()`、`post()` 和 `get_page()` 方法是通用的，因此我们可以在 `utils` 应用程序中创建一个具有这些方法的通用
    `FilterableListView` 类。然后，在需要可过滤列表的任何应用程序中，我们可以创建一个基于类的视图，该视图扩展 `FilterableListView`
    并仅定义 `form_class` 和 `template_name` 属性以及 `get_queryset_and_facets()` 方法。这就是基于类的视图是如何工作的。
- en: See also
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Filtering object lists* recipe
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*过滤对象列表* 菜谱'
- en: The *Managing paginated lists* recipe
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管理分页列表* 菜谱'
- en: Generating PDF documents
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成 PDF 文档
- en: Django views allow you to create much more than just HTML pages. You can generate
    files of any type. For example, you can create PDF documents for invoices, tickets,
    booking confirmations, and so on. In this recipe, we will show you how to generate
    resumes (curriculum vitae) in the PDF format out of the data from the database.
    We will be using the Pisa xhtml2pdf library, which is very practical as it allows
    you to use HTML templates to make PDF documents.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Django 视图允许您创建不仅仅是 HTML 页面。您可以生成任何类型的文件。例如，您可以创建用于发票、票务、预订确认等的 PDF 文档。在这个菜谱中，我们将向您展示如何从数据库中的数据生成简历（履历）的
    PDF 格式。我们将使用 Pisa xhtml2pdf 库，它非常实用，因为它允许您使用 HTML 模板来制作 PDF 文档。
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First of all, we need to install the xhtml2pdf Python library in your virtual
    environment:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在您的虚拟环境中安装 xhtml2pdf Python 库：
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, let''s create a `cv` app containing a simple `CV` model with the `Experience`
    model that is attached to it through a foreign key. The `CV` model will have these
    fields: first name, last name, and e-mail. The `Experience` model will have these
    fields: the start date of a job, the end date of a job, company, position at that
    company, and the skills gained:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们创建一个包含一个简单的 `CV` 模型以及通过外键附加的 `Experience` 模型的 `cv` 应用程序。`CV` 模型将包含以下字段：名字、姓氏和电子邮件。`Experience`
    模型将包含以下字段：工作的开始日期、工作的结束日期、公司、在该公司的职位以及获得的技能：
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How to do it…
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Execute the following steps to complete the recipe:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成菜谱：
- en: 'In the URL rules, let''s create a rule for the view that will download a PDF
    document of a resume by the ID of the `CV` model, as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 URL 规则中，让我们为以下视图创建一个规则，该规则将根据 `CV` 模型的 ID 下载简历的 PDF 文档：
- en: '[PRE31]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let''s create the `download_cv_pdf()` view. This view renders an HTML
    template and then passes the rendered string to the `pisaDocument` PDF creator:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建 `download_cv_pdf()` 视图。这个视图渲染一个 HTML 模板，然后将渲染后的字符串传递给 `pisaDocument`
    PDF 创建器：
- en: '[PRE32]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Lastly, we will create the template with which the document will be rendered,
    as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将创建用于渲染文档的模板，如下所示：
- en: '[PRE33]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works…
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Go to model administration and enter a CV document. Then, if you access the
    document''s URL at `http://127.0.0.1:8000/en/cv/1/pdf/`, you will be asked to
    download a PDF document that looks something similar to the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 前往模型管理并输入一份 CV 文档。然后，如果您访问文档的 URL `http://127.0.0.1:8000/en/cv/1/pdf/`，您将被要求下载一个看起来类似于以下内容的
    PDF 文档：
- en: '![How it works…](img/B04912_03_05.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/B04912_03_05.jpg)'
- en: How does the view work? First, we load a curriculum vitae by its ID, if it exists,
    or raise the page not found error, if it doesn't. Then, we create the response
    object with the content type of the PDF document. We set the `Content-Disposition`
    header to `attachment` with the specified filename. This will force the browsers
    to open a dialog box prompting us to save the PDF document and suggesting the
    specified name for the file. Then, we render the HTML template as a string passing
    curriculum vitae object and the `MEDIA_ROOT` and `STATIC_ROOT` paths.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是如何工作的呢？首先，我们通过ID加载一份简历，如果存在，否则抛出页面未找到错误。然后，我们创建响应对象，并设置PDF文档的内容类型。我们将`Content-Disposition`头设置为`attachment`，并指定文件名。这将强制浏览器打开一个对话框，提示我们保存PDF文档，并建议指定文件名。然后，我们将HTML模板作为字符串渲染，传递简历对象和`MEDIA_ROOT`以及`STATIC_ROOT`路径。
- en: Note
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the `src` attribute of the `<img>` tag that is used for the PDF creation
    needs to point to the file in the filesystem or the full URL of the online image.
    Pisa xhtml2pdf will download the image and include it in the PDF document.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，用于PDF创建的`<img>`标签的`src`属性需要指向文件系统中的文件或在线图像的完整URL。Pisa xhtml2pdf将下载图像并将其包含在PDF文档中。
- en: Then, we create a `pisaDocument` file with the UTF-8-encoded HTML as source
    and response object as the destination. The response object is a file-like object
    and `pisaDocument` writes the content of the document to it. The response object
    is returned by the view as expected.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个`pisaDocument`文件，以UTF-8编码的HTML作为源文件，以文件对象作为目标。响应对象是一个类似文件的对象，`pisaDocument`将文档内容写入其中。响应对象按预期由视图返回。
- en: Let's take a look at the HTML template that is used to create this document.
    The template has some unusual markup tags and CSS rules. If we want to have some
    elements on each page of the document, we can create CSS frames for that. In the
    preceding example, the `<div>` tag with the `footerContent` ID is marked as a
    frame, which will be repeated at the bottom of each page. In a similar way, we
    can have a header or background image for each page.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看用于创建此文档的HTML模板。该模板包含一些不寻常的标记标签和CSS规则。如果我们想在文档的每一页上放置一些元素，我们可以为这些元素创建CSS框架。在前面的示例中，带有`footerContent`
    ID的`<div>`标签被标记为框架，它将在每一页的底部重复。以类似的方式，我们还可以为每一页设置页眉或背景图像。
- en: 'The following are the specific markup tags used in this document:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在此文档中使用的特定标记标签：
- en: The `<pdf:nextpage>` tag sets a manual page break
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<pdf:nextpage>`标签设置手动分页符'
- en: The `<pdf:pagenumber>` tag returns the number of the current page
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<pdf:pagenumber>`标签返回当前页码'
- en: The `<pdf:pagecount>` tag returns the total number of pages
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<pdf:pagecount>`标签返回总页数'
- en: The current version 0.0.6 of the Pisa xhtml2pdf library doesn't fully support
    all HTML tags and CSS rules. There are no publicly-accessible benchmarks to see
    what exactly is supported and at what level. Therefore, you would need to experiment
    in order to make a PDF document look like in the design requirements. However,
    this library is still mighty enough for customized layouts, which can be basically
    created just with the knowledge of HTML and CSS.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Pisa xhtml2pdf库的当前版本0.0.6并不完全支持所有HTML标签和CSS规则。没有公开可访问的基准来查看具体支持哪些标签和规则以及支持的水平。因此，您需要通过实验来使PDF文档看起来符合设计要求。然而，这个库仍然足够强大，可以用于自定义布局，这基本上只需要HTML和CSS的知识就可以创建。
- en: See also
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Managing paginated lists* recipe
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管理分页列表*配方'
- en: The *Downloading authorized files* recipe
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*下载授权文件*配方'
- en: Implementing a multilingual search with Haystack
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Haystack实现多语言搜索
- en: One of the main functionalities of content-driven websites is a full-text search.
    Haystack is a modular search API that supports the Solr, Elasticsearch, Whoosh,
    and Xapian search engines. For each model in your project that has to be findable
    in the search, you need to define an index that will read out the textual information
    from the models and place it into the backend. In this recipe, you will learn
    how to set up a search with Haystack and the Python-based Whoosh search engine
    for a multilingual website.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 内容驱动网站的主要功能之一是全文搜索。Haystack是一个模块化搜索API，支持Solr、Elasticsearch、Whoosh和Xapian搜索引擎。对于您项目中需要可搜索的每个模型，您需要定义一个索引，该索引将从模型中读取文本信息并将其放置到后端。在此配方中，您将学习如何使用基于Python的Whoosh搜索引擎和Haystack设置一个多语言网站的搜索。
- en: Getting ready
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In the beginning, let''s create a couple of apps with models that will be indexed
    in the search. Let''s create an `ideas` app containing the `Category` and `Idea`
    models, as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，让我们创建一些包含将被索引的模型的几个应用。让我们创建一个包含 `Category` 和 `Idea` 模型的 `ideas` 应用，如下所示：
- en: '[PRE34]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `Idea` model has multilingual fields, which means that there is supposed
    to be a translation of the content for each language.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`Idea` 模型具有多语言字段，这意味着应该为每种语言的内容提供翻译。'
- en: 'Another app will be `quotes` from the *Uploading images* recipe with the `InspirationalQuote`
    model, where each quote can just be in any one language from the languages defined
    in `settings.LANGUAGES` and each quote doesn''t necessarily have a translation:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个应用将是来自 *上传图片* 菜单的 `quotes`，其中包含 `InspirationalQuote` 模型，每个引言可以只使用在 `settings.LANGUAGES`
    中定义的任何一种语言，并且每个引言不一定有翻译：
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Put these two apps in `INSTALLED_APPS` in the settings, create and apply database
    migrations, and create the model administration for these models to add some data.
    Also, create list and detail views for these models and plug them in the URL rules.
    If you are having any difficulty with any of these tasks, familiarize yourself
    with the concepts in the official Django tutorial once again: [https://docs.djangoproject.com/en/1.8/intro/tutorial01/](https://docs.djangoproject.com/en/1.8/intro/tutorial01/).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个应用放入设置中的 `INSTALLED_APPS`，创建并应用数据库迁移，并为这些模型创建模型管理以添加一些数据。此外，为这些模型创建列表和详情视图，并将它们连接到
    URL 规则。如果你在这些任务中遇到任何困难，请再次熟悉官方 Django 教程中的概念：[https://docs.djangoproject.com/en/1.8/intro/tutorial01/](https://docs.djangoproject.com/en/1.8/intro/tutorial01/)。
- en: 'Make sure you installed django-haystack, whoosh, and django-crispy-forms in
    your virtual environment:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你在虚拟环境中安装了 django-haystack、whoosh 和 django-crispy-forms：
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How to do it…
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s set up the multilingual search with Haystack and Whoosh by executing
    the following steps:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤使用 Haystack 和 Whoosh 设置多语言搜索：
- en: 'Create a `search` app that will contain the `MultilingualWhooshEngine` and
    search indexes for our ideas and quotes. The search engine will live in the `multilingual_whoosh_backend.py`
    file:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含 `MultilingualWhooshEngine` 和我们想法和引言的搜索索引的 `search` 应用。搜索引擎将位于 `multilingual_whoosh_backend.py`
    文件中：
- en: '[PRE37]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, let''s create the search indexes, as follows:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们按照以下步骤创建搜索索引：
- en: '[PRE38]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Later, configure the settings to use our `MultilingualWhooshEngine`:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，配置设置以使用我们的 `MultilingualWhooshEngine`：
- en: '[PRE39]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we need to define the URL rules for the search view:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要定义搜索视图的 URL 规则：
- en: '[PRE40]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, here comes the template for the search form and search results, as shown
    in the following:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，以下是搜索表单和搜索结果的模板，如下所示：
- en: '[PRE41]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Call the `rebuild_index` management command in order to index the database
    data and prepare the full-text search to be used:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `rebuild_index` 管理命令以索引数据库数据并准备全文搜索：
- en: '[PRE42]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How it works…
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: 'The `MultilingualWhooshEngine` specifies two custom properties: backend and
    query. The custom `MultilingualWhooshSearchBackend` backend ensures that, for
    each language, the items will be indexed just in that language and put under the
    specific `Haystack` index location that is defined in the `HAYSTACK_CONNECTIONS`
    setting. The `MultilingualWhooshSearchQuery` custom query ensures that when searching
    for keywords, the specific Haystack connection of the current language will be
    used.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultilingualWhooshEngine` 指定了两个自定义属性：后端和查询。自定义的 `MultilingualWhooshSearchBackend`
    后端确保对于每种语言，项目将只在该语言中索引，并放置在 `HAYSTACK_CONNECTIONS` 设置中定义的特定 `Haystack` 索引位置下。自定义的
    `MultilingualWhooshSearchQuery` 查询确保在搜索关键字时，将使用当前语言的特定 Haystack 连接。'
- en: Each index has a field `text`, where full-text from a specific language of a
    model will be stored. The model for the index is defined by the `get_model()`
    method, `QuerySet` to index is defined by the `index_queryset()` method, and text
    to search in gets collected in the `prepare_text()` method.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 每个索引都有一个 `text` 字段，其中将存储模型特定语言的全文。索引的模型由 `get_model()` 方法定义，要索引的 `QuerySet`
    由 `index_queryset()` 方法定义，要搜索的文本在 `prepare_text()` 方法中收集。
- en: 'As we want to have a nice Bootstrap 3 form, we will be passing `FormHelper`
    from `django-crispy-forms` to the search view. We can do that by overriding the
    `extra_context()` method of `SearchView`. The final search form will look similar
    to the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要一个漂亮的 Bootstrap 3 表单，我们将通过覆盖 `SearchView` 的 `extra_context()` 方法将 `FormHelper`
    从 `django-crispy-forms` 传递给搜索视图。我们可以这样做，如下所示：
- en: '![How it works…](img/B04912_03_06.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/B04912_03_06.jpg)'
- en: The easiest way to regularly update the search index is to call the `rebuild_index`
    management command by a cron job every night. To learn about it, check the *Setting
    up cron jobs for regular tasks* recipe in [Chapter 11](ch11.html "Chapter 11. Testing
    and Deployment"), *Testing and Deployment*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 定期更新搜索索引的最简单方法是通过cron作业每晚调用 `rebuild_index` 管理命令。要了解相关信息，请查看[第11章](ch11.html
    "第11章。测试和部署")中的 *设置cron作业以执行常规任务* 菜谱，*测试和部署*。
- en: See also
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating form layout with django-crispy-forms* recipe
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 django-crispy-forms 创建表单布局* 菜谱'
- en: The *Downloading authorized file* recipe
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*下载授权文件* 菜谱'
- en: The *Setting up cron jobs for regular tasks* recipe in [Chapter 11](ch11.html
    "Chapter 11. Testing and Deployment"), *Testing and Deployment*
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第11章](ch11.html "第11章。测试和部署")中的 *设置cron作业以执行常规任务* 菜谱，*测试和部署*'
