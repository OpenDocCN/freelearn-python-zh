- en: Chapter 4. CherryPy in Depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 3](ch03.html "Chapter 3. Overview of CherryPy") introduced the common
    aspects of CherryPy without going into too much detail. In this chapter, we will
    dive into what makes CherryPy such a powerful library for the web developer by
    explaining key features, such as how to run multiple HTTP servers, use additional
    URI dispatchers, use the built-in tools and develop new ones, serve static contents,
    and finally how CherryPy and WSGI interact. This chapter will be dense but will
    be a good base to allow you to be more at ease and efficient with the product.'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Compliance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CherryPy has been evolving slowly but surely to comply as much as it can with
    the HTTP specifications—firstly by supporting the old HTTP/1.0 and then moving
    gradually towards fully supporting HTTP/1.1, as defined in RFC 2616\. CherryPy
    is said to be conditionally compliant with HTTP/1.1 as it implements all the *must*
    and *required* levels but not all the *should* levels of the specification. Therefore,
    CherryPy supports the following features of HTTP/1.1:'
  prefs: []
  type: TYPE_NORMAL
- en: If a client claims to support HTTP/1.1, it must send a `Host` header field in
    any request made with that protocol version. If it is not done, CherryPy will
    immediately stop the request processing with a `400` error code message (section
    14.23 of RFC 2616).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CherryPy generates a `Date` header field in all the configurations (section
    14.18 of RFC 2616).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CherryPy does handle the `Continue` response status code (`100`) on clients
    supporting it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CherryPy''s built-in HTTP server supports persistent connections that are the
    default in HTTP/1.1, through the use of the `Connection: Keep-Alive` header. Be
    aware that changing the HTTP server (for more details refer to[Chapter 10](ch10.html
    "Chapter 10. Deployment")) may break this compatibility, if the chosen server
    does not support such a feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CherryPy handles correctly chunked requests and responses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CherryPy supports requests set with `If-Modified-Since` and `If-Unmodified-Since`
    headers and responds accordingly to each of them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CherryPy allows any HTTP methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CherryPy handles all the combinations of HTTP versions between the client and
    the setting set for the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Request Protocol | Server Protocol | Written Response Protocol | Response
    Feature Set |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1.0 | 1.0 | 1.0 | 1.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1.0 | 1.1 | 1.1 | 1.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1.1 | 1.0 | 1.0 | 1.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1.1 | 1.1 | 1.1 | 1.1 |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The server protocol can be modified via the `server.protocol_version` key.
  prefs: []
  type: TYPE_NORMAL
- en: The written response protocol is the version returned in the HTTP response to
    inform the user-agent what protocol the server is supporting.
  prefs: []
  type: TYPE_NORMAL
- en: The response feature set protocol version is the one used internally by CherryPy
    during the response processing. In the second case, CherryPy only limits what
    it does to the response to HTTP/1.0.
  prefs: []
  type: TYPE_NORMAL
- en: All in all CherryPy 3 offers a wide range of capabilities, thanks to its good
    support of HTTP/1.1, and therefore can be safely used in a large set of scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple HTTP Servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, CherryPy starts a single instance of its own built-in HTTP server.
    However, it may happen that:'
  prefs: []
  type: TYPE_NORMAL
- en: You are required to have a different HTTP server. This will be covered extensively
    in[Chapter 10](ch10.html "Chapter 10. Deployment").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are required to run your application on different network interfaces in
    one single Python process. CherryPy provides an API to run different HTTP server
    instances in one single process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First let us see how the CherryPy server is usually started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we call the `quickstart()` method of the server object, which
    will instantiate the built-in HTTP server and start it in its own thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now imagine we have one application that we wish to run on different network
    interfaces; we should do as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we first create two instances of the built-in HTTP server and
    for each we set the binding address on which the socket should be listening for
    incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: Then we attach those servers to the CherryPy pool of HTTP servers and call the
    `start()` method, which will start each one on its interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we do not call `cherrypy.config.update`, because it would update
    the global configuration settings shared by all the servers. However, this is
    not really an issue because each instance of the built-in server has the attributes
    matching the configuration keys. Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you can directly set the server instance settings and avoid
    using the global configuration. This technique also allows for an application
    to be served via HTTP and HTTPS at the same time as we will see in[Chapter 10](ch10.html
    "Chapter 10. Deployment").
  prefs: []
  type: TYPE_NORMAL
- en: Multi-Threaded Application Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CherryPy is designed around the threaded pattern. Although it is transparent
    to the developer, each time the application gets or sets a value into the CherryPy
    namespace, (`cherrypy.request` and `cherrypy.response` objects mainly) it does
    so in a multi-threaded environment. Both `cherrypy.request` and `cherrypy.response`
    are thread-data containers, which imply that your application calls them independently
    by knowing which request is proxied through them at run time.
  prefs: []
  type: TYPE_NORMAL
- en: When using the built-in CherryPy server, a pool of threads is created to handle
    incoming requests. The size of the pool is configured via the `server.thread_pool`
    key, which defaults to `10`. Although it could sound like a good idea to create
    a larger pool of threads to improve the performance of the server, it is not always
    the case.
  prefs: []
  type: TYPE_NORMAL
- en: This value must be tuned as per application requirements. In fact if your application
    has a very short average request processing time, then it is likely that each
    thread will not be busy for a very long period of time. If you create a large
    pool of threads, it is more likely that most of them will just sit there, consuming
    your memory for very little benefit. It is therefore advisable to run performance
    testing against your application in different configurations in order to determine
    the best number of threads that should be created for your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Application servers using the threaded pattern are not always highly regarded
    because the use of threads is seen as increasing the likelihood of problems due
    to synchronization requirements. Alternatives exist, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Multi-processes pattern: In this case, each request is handled by its own Python
    process. It is arguable that synchronization is easier but in some specific cases
    the performance and stability of the server can be better.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Asynchronous pattern: In this configuration, the operation of accepting new
    connections and sending back data to the client is done asynchronously from the
    request processing itself. This can be achieved, thanks to the capabilities of
    underlying operating systems allowing it. This technique has proven to be very
    efficient speed-wise. However, it requires a fairly different application development
    approach that can perturb some developers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All in all, which solution is the best can be debated ad infinitum and such
    questions will never really be answered. In fact, each scenario requires a different
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: URI Dispatching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in the[Chapter 3](ch03.html "Chapter 3. Overview of CherryPy"),
    by default CherryPy maps URIs to Python callables that have an `exposed` attribute
    set to `True`. Over time, it has appeared that the CherryPy community wants to
    be more flexible and that other dispatchers' solutions would be appreciated. That's
    why CherryPy 3 provides three other built-in dispatchers and offers a simple way
    to write and use your own dispatchers.
  prefs: []
  type: TYPE_NORMAL
- en: One is set to allow applications to be developed per HTTP methods. (GET, POST,
    PUT, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is based on a popular third-party package named Routes and developed
    by Ben Bangert from the original Ruby implementation for Ruby on Rails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third dispatcher is a Virtual Host one, which allows dispatching based on
    the domain requested rather than the URI path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP Method Dispatcher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some applications, URIs are independent of the action to be performed by
    the server on the resource. For example, look at the following URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the URI contains the operation the client wishes to carry out.
    With the default CherryPy dispatcher this would map to something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Although it''s fine, you may wish to remove that operation from the URI itself
    and make it more independent, so that it would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You may wonder immediately how the server is supposed to know which operation
    to perform. This information is carried by the HTTP request itself, thanks to
    the HTTP method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The page handler handling such a request would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When using the HTTP method dispatcher, the page handler called would be `album.DELETE(12)`.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the previous class definition, you will see that the methods
    do not carry the `exposed` attribute but instead the class itself is set with
    that attribute. The reason for this comes from the way the dispatcher is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: When a request reaches the server, CherryPy looks for the best matching page
    handler. When using the HTTP method dispatcher, the handler is in fact the conceptual
    representation of the resource targeted by the URI, in our example the instance
    of the `album` class. Then the dispatcher checks if the class has a method matching
    the name of the HTTP method used for the request. If so, the dispatcher calls
    it with the remaining parameters. Otherwise, it sends back immediately an HTTP
    error code `405 Method Not Allowed` to inform the client that it cannot use the
    HTTP method and thus cannot perform that operation on that particular resource.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we did not have a definition for `DELETE` in the `Album` class,
    such an error code would be returned upon the request we have used so far.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, however, CherryPy will automatically add the `Allow` HTTP header
    to the response to inform the client which methods it can use against the resource.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that in this case CherryPy does not look for `index` or `default` page
    handlers as it would with the URI-to-object dispatcher. This comes from a fundamental
    difference between dispatching based on the URI solely as compared to the URI+HTPP
    method.[Chapter 6](ch06.html "Chapter 6. Web Services") will review this in more
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: To enable the HTTP method dispatcher, you must set the `request.dispatch` key
    to an instance of that dispatcher for the targeted path.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if our whole application was built using that technique, we would
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The HTTP method dispatcher is often used in applications following REST principles,
    as we will see in[Chapter 6.](ch06.html "Chapter 6. Web Services")
  prefs: []
  type: TYPE_NORMAL
- en: Routes Dispatcher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whether in the URI-to-object or HTTP-method dispatcher, we have not explicitly
    declared the URI associated with a page handler; instead we have left the responsibility
    of finding the best correspondence to the CherryPy engine. Many developers prefer
    the explicit approach and decide how URIs should map to page handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when using the Routes dispatcher you must connect a pattern that
    matches URIs and associates a specific page handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using the Routes dispatcher handlers, you need not have an `exposed` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `connect` method of the Routes dispatcher is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the parameters for the `connect` method:'
  prefs: []
  type: TYPE_NORMAL
- en: The `name` parameter is the unique name for the route to connect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `route` is the pattern to match URIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `controller` is the instance containing page handlers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**kwargs` allows you to pass on extra valid parameters for a route.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please refer to the official Routes documentation to understand how the package
    works.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the CherryPy Routes dispatcher does not pass on the `action` and
    `controller` values returned by the Routes mapper when matching a URI against
    any of the route. These are not necessarily useful in a CherryPy application.
    However, if you need them you can set the `fetch_result` parameter of the Routes
    dispatcher constructor to `True`. Then both values will be passed on to page handlers
    but in this case you will have to add `controller` and `action` parameters to
    all your page handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Host Dispatcher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It may happen that you need to host different web applications within one CherryPy
    server with each application serving one given domain name. CherryPy provides
    an easy way to do this, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First, as you can see, we simply create a tree of applications. Next, we define
    the `hostmap` dictionary, which will inform the `VirtualHost` dispatcher how to
    serve a request based on its domain. Thus the requests coming from [www.mymusic.com](http://www.mymusic.com)
    will be served by the application mounted at the `/music` prefix. Next, we tell
    CherryPy that we will be using the `VirtualHost` dispatcher and we finally mount
    the site application and start the server as usual.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this example will require that you edit your `hosts` file on your
    machine to add the following two domains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It will automatically redirect requests to those domains to your local server
    instead of looking for them on the Internet. Once you have finished with this
    example, you ought to remove these lines from the `hosts` file.
  prefs: []
  type: TYPE_NORMAL
- en: Hook into CherryPy's Core Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most powerful aspects of CherryPy is how its core lets you modify
    its normal behavior with a very fine granularity. Indeed, CherryPy offers a mechanism
    called hooking to customize the core engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **hook** is an entry point for Python callables to be applied at specific
    points during the request processing. CherryPy provides the following entry points:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Hook Point | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `on_start_resource` | Called at the beginning of the process. |'
  prefs: []
  type: TYPE_TB
- en: '| `before_request_body` | Called before CherryPy tries to read the request
    body. It allows a tool to inform CherryPy whether this action should be performed
    by setting the `process_request_body` attribute to `False` within the tool. |'
  prefs: []
  type: TYPE_TB
- en: '| `before_handler` | Called before the page handler is invoked. A tool could
    for instance set the handler to `None` to inform CherryPy that it should not process
    the page handler. |'
  prefs: []
  type: TYPE_TB
- en: '| `before_finalize` | Called whether or not the page handler has been called
    and before CherryPy starts processing the response. |'
  prefs: []
  type: TYPE_TB
- en: '| `on_end_resource` | Called when the resource processing is terminated. |'
  prefs: []
  type: TYPE_TB
- en: '| `before_error_response after_error_response` | Called when an error is trapped
    by the CherryPy engine to allow the application to recover and decide what to
    do next. |'
  prefs: []
  type: TYPE_TB
- en: '| `on_end_request` | Called at the end of the overall processing, right after
    the link with the client has been closed. This allows you to free resources. |'
  prefs: []
  type: TYPE_TB
- en: The following figure shows the global process followed by CherryPy when handling
    a request. The black lines and arrows show the normal flow while the gray ones
    indicate the path when an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '![Hook into CherryPy''s Core Engine](img/1848_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Attaching a callback at one of these hook points is done via a call to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is the name of the hook point as shown in the previous table.
    The second parameter is the Python callable that will be applied. The third parameter
    indicates to CherryPy that even if another callback may fail during the processing
    of this hook point, CherryPy must run this callable. The last parameter must be
    a value between 0 and 100 to indicate the weight of each callback and provide
    a way to order them. Lower values will be run first.
  prefs: []
  type: TYPE_NORMAL
- en: The `failsafe` argument is quite helpful as it offers a way for an application
    to be flexible and recover from problems that may occur. Indeed some callbacks
    may fail without impacting the whole chain of the request processing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that you can obviously attach as many callbacks as required at a given
    hook point. Callbacks can be hooked on the fly while the application is running
    as well. However, the more callbacks you attach, the slower the processing of
    that hook point will become.
  prefs: []
  type: TYPE_NORMAL
- en: The hooking mechanism is fairly close to what used to be called filters in CherryPy
    2\. However, it was observed over time that they were too low level and were making
    users uncomfortable most of the time. That's why it is still rare for developers
    to use them directly as is. Instead they are applied through a higher-level interface
    named tools.
  prefs: []
  type: TYPE_NORMAL
- en: CherryPy Toolbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tool interface has been designed by Robert Brewer while refactoring CherryPy.
    The goal was to offer ready-to-employ tools achieving common tasks with a friendly
    and flexible API. Within CherryPy, built-in tools offer a single interface to
    call the CherryPy library that we have reviewed in[Chapter 3](ch03.html "Chapter 3. Overview
    of CherryPy") using the hooking mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen in[Chapter 3](ch03.html "Chapter 3. Overview of CherryPy")
    tools can be used in three different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: From the configuration settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a Python decorator or via the special `_cp_config` attribute of a page handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a Python callable that can be applied from within any function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to this flexibility, a tool can be set either globally to a path and
    its subset or to a particular page handler. Let's now review the built-in tools
    provided by CherryPy.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Authentication Tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Purpose:** The purpose of this tool is to provide basic authentication (RFC
    2617) to your application.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arguments:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Default | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `realm` | N/A ( N/A in this case means the parameter must be provided by
    the developer as it has no default.) | String defining the realm value. |'
  prefs: []
  type: TYPE_TB
- en: '| `users` | N/A | Dictionary of the form username:password or a Python callable
    returning such a dictionary. |'
  prefs: []
  type: TYPE_TB
- en: '| `encrypt` | None | Python callable used to encrypt the password returned
    by the client and compare it with the encrypted password provided in the users
    dictionary. If None it uses an MD5 hash. |'
  prefs: []
  type: TYPE_TB
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `get_users` function returns a hard-coded dictionary but it could also fetch
    the values from a database or anywhere else. Keep in mind that the basic authentication
    scheme is not really secure as the password is only encoded and can be decoded
    on the fly if someone captures it. This scheme is, however, often used over SSL
    because it is the easiest to put in place while the Secure Socket Layer encrypts
    the enclosed data.
  prefs: []
  type: TYPE_NORMAL
- en: Caching Tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Purpose:** The purpose of this tool is to provide basic in-memory caching
    of CherryPy generated content.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arguments:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Default | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `invalid_methods` | ("POST", "PUT", "DELETE") | Tuples of strings of HTTP
    methods not to be cached. These methods will also invalidate (delete) any cached
    copy of the resource. |'
  prefs: []
  type: TYPE_TB
- en: '| `cache_class` | MemoryCache | Class object to be used for caching. |'
  prefs: []
  type: TYPE_TB
- en: A comprehensive example would be out of the scope of this book but if you are
    interested in this tool you should first look at the CherryPy test suite as well
    as visit the CherryPy users' mailing-list.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding Tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Purpose:** The purpose of this tool is to decode the incoming request parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arguments:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Default | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `encoding` | None | What encoding is to be used to decode the incoming content?
    If None it looks for the `Content-Type` header and if it cannot find a suitable
    charset it uses `default_encoding`. |'
  prefs: []
  type: TYPE_TB
- en: '| `default_encoding` | "UTF-8" | Default encoding to be used when none is provided
    or found. |'
  prefs: []
  type: TYPE_TB
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this case when the HTML form is sent to the server, CherryPy tries to decode
    the incoming data using the encoding we have set. If you look at the type of the
    `name` parameter you will see that when using the decoding tool it is *Unicode*
    whereas without the tool it is a *string*.
  prefs: []
  type: TYPE_NORMAL
- en: Digest Authentication Tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Purpose:** The purpose of this tool is to provide digest authentication as
    defined in RFC 2617.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arguments:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Default | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `realm` | N/A | String defining the realm value. |'
  prefs: []
  type: TYPE_TB
- en: '| `users` | N/A | Dictionary of the form—username:password or a Python callable
    returning such a dictionary. |'
  prefs: []
  type: TYPE_TB
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the digest tool does not provide a way to pass an encrypted password.
    The reason for this is that the digest scheme is defined not to send the password
    across the wire as clear text. The way it works is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. The client requests to access the resource. The server returns a `401` error
    code indicating it uses the digest scheme. The server provides a token for this
    exchange.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. The client creates a new message based on the token, the username, and the
    password and generates a hash via the MD5 algorithm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. Upon receiving the new message from the client, the server tries to generate
    the same values. If they all match, the authentication is allowed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, the password never transits as clear text on the wire. Discussions
    have taken place to decide how the digest tool can be evolved in order to avoid
    the need to store passwords as clear text. One way would be to store one of the
    intermediate steps of the digest token (step 1) and compare this value with what
    has been sent by the client. This is beyond the scope of this book but you can
    get more information from the CherryPy mailing lists.
  prefs: []
  type: TYPE_NORMAL
- en: Encode Tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Purpose:** The purpose of this tool is to encode the response content in
    a defined encoding.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arguments:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Default | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `encoding` | None | What encoding is to be used to encode the response? If
    None, it looks for the `Content-Type` header and sets a suitable charset if it
    can. |'
  prefs: []
  type: TYPE_TB
- en: '| `errors` | "strict" | Defines how the tool must react when it fails to encode
    a character. |'
  prefs: []
  type: TYPE_TB
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Error Redirect Tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Purpose:** The purpose of this tool is to modify the default CherryPy error
    handler.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arguments:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Default | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `url` | '''' | The URL to which it should be redirected. |'
  prefs: []
  type: TYPE_TB
- en: '| `internal` | `True` | When `True`, the redirection is hidden from the client
    and happens only within the context of this request. If `False`, CherryPy informs
    the client that a redirection should be issued by the client itself to the URL
    provided. |'
  prefs: []
  type: TYPE_TB
- en: Etag Tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Purpose:** The purpose of this tool is to validate an **Entity Tag** (**Etag**)
    sent by a user agent and generate the response accordingly as defined by RFC 2616
    section 14.24\. Etags are one of the ways to cache HTTP responses and thus diminish
    the burden on any parties involved.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Argument:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Default | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `autotags` | False | When `True` the tool will generate an `etag` value based
    on the response body set. |'
  prefs: []
  type: TYPE_TB
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we set the `etags` tool for the whole application.
    On the first request to the `index` page handler, the tool will generate an `etag`
    value and insert it in the response headers. On the next request to that URI,
    the client will include the last received `etag`. The tool will compare it with
    the current one and if they match the response will be `304 Not Modified` informing
    the client that it can safely use its copy of the resource.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you need the `etag` value to be computed in a different fashion,
    the best way is to set the `autotags` parameter to `False`, the default, and then
    from within your page handler add the `Etag` header yourself to the response headers.
  prefs: []
  type: TYPE_NORMAL
- en: Gzip Tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Purpose:** The purpose of this tool is to perform content encoding on the
    response body.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arguments:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Default | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `compress_level` | `10` | Level of compression to be achieved. The lower
    it is, the faster it will be. |'
  prefs: []
  type: TYPE_TB
- en: '| `mime_types` | `[''text/html'', ''text/plain'']` | List of MIME types that
    can be compressed. |'
  prefs: []
  type: TYPE_TB
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `gzip` tool should not be used when the response is streamed via
    its `stream` attribute. Indeed in this case CherryPy starts sending the body as
    soon as it has something to send, for instance when the page handler yields the
    content, instead of returning it.
  prefs: []
  type: TYPE_NORMAL
- en: Ignore Headers Tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Purpose:** The purpose of this tool is to remove the specified headers from
    the HTTP request before they are processed by CherryPy.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Argument:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Default | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ignore_headers` | `headers=(''Range'',)` | Tuple of header names to be disregarded.
    |'
  prefs: []
  type: TYPE_TB
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you access [http://localhost:8080/](http://localhost:8080/), you will get
    the following message whether or not the client has indeed set that header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you navigate to [http://localhost:8080/other](http://localhost:8080/other)
    you will get the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Log Headers Tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Purpose:** The purpose of this tool is to dump request headers into the error
    log file when an error occurs on the server. This tool is disabled by default.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Argument:** None'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When you access [http://localhost:8080](http://localhost:8080), the error will
    be raised and the error log will show the request headers. Note that in this case
    this tool is set at the web-server level via the `cherrypy.config.update()` method
    but it can be applied on a per path basis as well.
  prefs: []
  type: TYPE_NORMAL
- en: Log Tracebacks Tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Purpose:** The purpose of this tool is to dump the error''s traceback into
    the error log file when an exception is raised. This tool is enabled by default.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Argument:** None'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Proxy Tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Purpose:** The purpose of this tool is to change the base URL of the requests.
    This is especially helpful when running the application behind another server
    such as Apache.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arguments:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Default | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `base` | None | If set and `local` is none, this will be the new base URL
    available from `cherrypy.request.base`. |'
  prefs: []
  type: TYPE_TB
- en: '| `local` | ''X-Forwarded-Host'' | Which header to look at for the local hosts
    set for instance by the front-end web server. |'
  prefs: []
  type: TYPE_TB
- en: '| `remote` | ''X-Forwarded-For'' | Header to look for the IP address of the
    originating client. |'
  prefs: []
  type: TYPE_TB
- en: '| `scheme` | ''X-Forwarded-Proto'' | Header to look for the original scheme
    used: *http* or *https* for instance. |'
  prefs: []
  type: TYPE_TB
- en: When the base is not set, the tool will build the new base URI from the values
    fetched from the request headers based on the other parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When navigating to [http://localhost:8080](http://localhost:8080) you will
    see the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you navigate to [http://localhost:8080/other](http://localhost:8080/other),
    you will be redirected to [http://someapp.net/blog/](http://someapp.net/blog/),
    which shows that the proxy tools ensure in a transparent manner that the CherryPy
    library stays coherent in behavior in accordance with the settings you provide.
  prefs: []
  type: TYPE_NORMAL
- en: For more examples on using this tool behind another server please see[Chapter
    10](ch10.html "Chapter 10. Deployment").
  prefs: []
  type: TYPE_NORMAL
- en: Referer Tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Purpose:** The purpose of this tool is to allow the filtering of requests
    based on a pattern. Requests can be rejected or accepted after matching the pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arguments:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Default | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `pattern` | N/A | Regular expression pattern. |'
  prefs: []
  type: TYPE_TB
- en: '| `accept` | True | If `True` any matching referer will allow the request to
    proceed. Otherwise, any matching referer will cause the request to be rejected.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `accept_missing` | False | Whether requests with no referer can be allowed
    or not. |'
  prefs: []
  type: TYPE_TB
- en: '| `error` | 403 | HTTP error code to be returned to the user agent upon refusal.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `message` | ''Forbidden Referer header.'' | Message to be returned to the
    user agent upon refusal. |'
  prefs: []
  type: TYPE_TB
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we will reject all requests coming from the `dodgy.com` domain
    and sub-domains.
  prefs: []
  type: TYPE_NORMAL
- en: Response Headers Tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Purpose:** The purpose of this tool is to allow some common headers to be
    set for all or many page handlers at once.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Argument:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Default | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `headers` | None | List of tuples: header, value |'
  prefs: []
  type: TYPE_TB
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the tool sets `Content-Type` to `text/plain` for all page handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Trailing Slash Tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Purpose:** The purpose of this tool is to provide a flexible way to deal
    with the trailing slash of requests. This tool is enabled by default.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arguments:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Default | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `missing` | True | If the page handler is the index, if the `missing` parameter
    is `True`, and if the request missed a trailing slash, CherryPy will automatically
    issue a redirection towards the URI with the additional slash at the end. |'
  prefs: []
  type: TYPE_TB
- en: '| `extra` | False | If the page handler is not the index, if the `extra` parameter
    is set to `True`, and if the URI has a trailing slash, CherryPy will issue a redirection
    towards the URI without the trailing slash. |'
  prefs: []
  type: TYPE_TB
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand this tool, navigate to the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://localhost:8080](http://localhost:8080)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://localhost:8080/nothing](http://localhost:8080/nothing)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://localhost:8080/nothing/](http://localhost:8080/nothing/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://localhost:8080/extra/](http://localhost:8080/extra/)'
  prefs: []
  type: TYPE_NORMAL
- en: XML-RPC Tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Purpose:** The purpose of this tool is to transform CherryPy into an XML-RPC
    server and make page handlers XML-RPC callables.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Argument:** None'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `XMLRPCController` is a helper class that should be used instead of the
    XML-RPC tool directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then test your XML-RPC handler as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Toolbox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CherryPy tools must belong to a toolbox that is to be managed by the CherryPy
    engine. Toolboxes have their own namespace to avoid name collision. Although nothing
    prevents you from using the default toolbox you can create one of your own as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Creating a Tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have reviewed the toolbox shipped with CherryPy, we will explain
    how to write a tool. Before deciding to create a tool you should ask yourself
    a few questions such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Should the added feature be handled at the CherryPy level?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At which level of the request processing should this be applied?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will you modify CherryPy's default behavior?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These questions simply allow you to make sure that the feature you want to add
    is at the right level. Tools can sometimes look like a pattern on their own, upon
    which you can design your application.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a tool that will read and parse XML contained in a request body
    into a page handler parameter. To do so, we will be using the ElementTree library.
    (ElementTree is maintained by Fredrik Lundh and Amara by Uche Ogbuji.)
  prefs: []
  type: TYPE_NORMAL
- en: A tool is created either by sub-classing the `Tool` class or via an instance
    of that class as shown in the following example. Instantiating the `Tool` class
    is the most common case to consider and it is the one we will be discussing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class constructor declaration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `point` parameter is a string indicating to which hook point this tool should
    be attached.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `callable` parameter is a Python callable that will be applied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `name` parameter defines what the name of the tool will be within the toolbox.
    When it is not provided, it uses the name of the attribute holding the instance
    of the tool within the toolbox (refer to our example).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `priority` sets the order of the tools when several tools are attached at
    the same hook point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once an instance of the tool is created, you can attach it to the built-in
    toolbox as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This tool will be available like any other built-in tools to your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating a tool, you can provide two attributes to your callable that
    will be used when initializing the tool. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`failsafe:` If `True`, it means the tool will run even when an error is raised
    before the tool''s turn. It defaults to `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`priority:` Relative order of this tool in regards to others at the same hook
    point. It defaults to `50`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus you could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: CherryPy provides a shortcut for tools that will be applied at the `before_handler`
    hook point, in other words just before the page handler is called. This should
    be one of the most common cases for non-built-in tools.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HandlerTool` class provides one additional feature as it allows your callable
    to be applied as a page handler itself through the `handler(*args, **kwargs)`
    method of the `HandlerTool` class. Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This can be useful to provide the same handler in different areas of your application
    without duplicating code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see a more elaborate example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to test the tool, you will need ElementTree or Amara or both. You can
    install both via the `easy_install` command.
  prefs: []
  type: TYPE_NORMAL
- en: Our XML tool will read the HTTP body content and parse it via the specified
    XML toolkit. Then it will inject back the parsed document into the request parameters
    so that the new document instance is passed on to the page handler as a regular
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch the previous example and then run in a Python interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see the tool interface provided by CherryPy 3 is powerful, flexible,
    and yet quite intuitive and easy to reuse. However, always be careful to ponder
    over your requirements before using tools. They should be used for low-level operations
    that fit into the HTTP request/response model.
  prefs: []
  type: TYPE_NORMAL
- en: Static Resource Serving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CherryPy provides two simple tools to serve either a single file or an entire
    directory. In either case CherryPy takes care of the HTTP caching aspect of your
    static resource by automatically checking the presence of the `If-Modified-Since`
    and `If-Unmodified-Since` headers in the request and returning directly the `304
    Not Modified` response, if that's the case.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Staticfile Tool to Serve a Single File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `staticfile` tool can be used to serve a single file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Arguments:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Default | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `filename` | N/A | Absolute or relative path to the physical file. |'
  prefs: []
  type: TYPE_TB
- en: '| `root` | None | If filename is relative you must provide the root directory
    of the file. |'
  prefs: []
  type: TYPE_TB
- en: '| `match` | "" | Regular expression to check that the URI path matches a certain
    pattern. |'
  prefs: []
  type: TYPE_TB
- en: '| `content_types` | None | Dictionary of the form `ext: mime type`. |'
  prefs: []
  type: TYPE_TB
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose let''s imagine we have the following directory layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`design1.css` is set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `myapp.py` module will be defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Several points must be taken into consideration:'
  prefs: []
  type: TYPE_NORMAL
- en: The root directory can be set globally for the entire application so that you
    don't have to define it for each URI path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using the `staticfile` tool the URI and the physical resource need not
    have the same name. In fact they can be entirely unrelated in their naming as
    in the previous example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note also that even though the application is mounted on the `/my` prefix,
    meaning that requests to the CSS file will be `/my/css/style.css` (note that this
    is the case because the path provided in the `href` attribute of the link element
    is relative and not absolute: it does not start with a `/)`, our configuration
    settings do not include the prefix. As we have seen in Chapter 3, this is because
    the configuration settings are independent from where the application is mounted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Staticdir Tool to Serve a Complete Directory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `staticdir` tool can be used to serve a complete directory.
  prefs: []
  type: TYPE_NORMAL
- en: '**Arguments:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Default | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `dir` | N/A | Absolute or relative path to the physical directory. |'
  prefs: []
  type: TYPE_TB
- en: '| `root` | None | If `dir` is relative you must provide the root directory
    of the file. |'
  prefs: []
  type: TYPE_TB
- en: '| `match` | "" | Regular expression pattern to match files. |'
  prefs: []
  type: TYPE_TB
- en: '| `content_types` | None | Dictionary of the form ext: mime type. |'
  prefs: []
  type: TYPE_TB
- en: '| `index` | "" | If the URI is not directed at a file but at a directory, you
    can specify the name of the physical index file to be served. |'
  prefs: []
  type: TYPE_TB
- en: '**Example:**'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the new directory layout.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Handling that structure via the static directory tool would be similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you will note that the URI paths for the CSS and the JavaScript
    files match exactly their physical counterparts. Also take a close look at how
    we define the appropriate `Content-Type` for the resource based on the file extension.
    This is useful when CherryPy cannot determine the proper MIME type to be used
    on its own. Finally, see how we mix the static directory tool with the `gzip`
    one so that our static content is compressed before being served.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may find it limitating that CherryPy requires absolute paths to work with
    the different static tools. But consider the fact that CherryPy cannot control
    how an application will be deployed and where it will live. Therefore, it is up
    to the deployers to provide that information. Remember, however, that the absolute
    path can be provided via the `root` attribute or directly within the `filename`
    or `dir` ones.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing Static Tools to Serve Static Content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes you may want to reuse CherryPy''s internal functionalities for serving
    content but without using the static tools directly. This is possible by calling
    the `serve_file` function from your page handler. This function is actually the
    one called by the built-in tools as well. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here we define a feed page handler that, when called, will check what is the
    preferred representation of the feed of the user-agent—it maybe RSS or Atom.
  prefs: []
  type: TYPE_NORMAL
- en: WSGI Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Web Server Gateway Interface** (**WSGI**) is defined in a **Python Enhancement
    Proposal** (**PEP-333**) written by Phillip J. Eby to provide a loosely-coupled
    bridge between the web server and web applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'WSGI defines the following three components:'
  prefs: []
  type: TYPE_NORMAL
- en: Server or gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application or framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows WSGI along with its layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![WSGI Support](img/1848_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The goal of WSGI is to allow components to be plugged and played at will, with
    the minimum API overhead possible. This allows code reuse of common functionalities
    such as session, authentication, URL dispatching, logging, etc. In fact, because
    the API is minimal and unobtrusive, frameworks or libraries supporting the WSGI
    specification will be able to handle these components.
  prefs: []
  type: TYPE_NORMAL
- en: Until CherryPy 3.0, the support of WSGI within CherryPy was not welcome due
    to the internal design of CherryPy and also the belief that WSGI would not necessarily
    make the product a better one. When Robert Brewer undertook the refactoring of
    the project, he improved the WSGI support based on the work achieved by Christian
    Wyglendowski to the point of making it a first class citizen within CherryPy and
    therefore fulfilling expectations from the community.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that CherryPy tools and WSGI middlewares are different by design but not
    by capability. They aim at providing the same functionalities in a distinct way.
    CherryPy tools are mainly meaningful within CherryPy and are therefore optimized
    in that context. CherryPy tools and WSGI middlewares can coexist in a single application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hosting a WSGI Application within the CherryPy WSGI Server**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see an example on how to use CherryPy in a WSGI environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain what we have done:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. First we create a WSGI application respecting the WSGI specification, hence
    a Python callable respecting the WSGI application signature. The `environ` parameter
    contains values to be propagated orthogonally across the processing from the server
    to the application. Middlewares can alter this dictionary by adding new values
    or transforming existing values. The `start_response` parameter is a Python callable
    provided by the outer layer (a middleware or ultimately the WSGI server) to perform
    the response processing. Our WSGI application then returns an iterable, which
    will be consumed by the outer layers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. Then, we encapsulate the application into a middleware provided by the paste
    package. Paste is a suite of common WSGI middlewares created and maintained by
    Ian Bicking. In our example, we use the `TransLogger` middleware to enable logging
    of incoming requests. WSGI defines middlewares to act like a server for encapsulated
    WSGI applications and as an application for the hosting WSGI server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. Finally, we graft the WSGI application into the CherryPy tree through the
    `cherrypy.tree.graft()` method and we start the CherryPy server and engine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As the built-in CherryPy server is a WSGI server, it can handle the WSGI application
    without any trouble. Bear in mind, however, that many aspects of CherryPy such
    as tools and configuration settings will not be applied to the hosted WSGI application.
    You will need to use middlewares to perform operations such as the `paste.transLogger`.
    Alternatively, you can use the `wsgiapp` tool as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we wrap the WSGI application using the `wsgiapp` tool. Notice
    that we can apply tools on the WSGI application as if it was a regular page handler.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hosting a CherryPy WSGI Application within a Third-Party WSGI Server**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we will write a CherryPy application as we traditionally do
    and host it in a WSGI server different from the built-in one. Indeed, we will
    be using the default WSGI server provided by the `wsgiref` package.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `wsgiref` package is a set of WSGI helpers that has become part of the Python
    standard library as of Python 2.5\. Otherwise, you can get it via `easy_install
    wsgiref`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. First we create a regular CherryPy application. Note how we can still safely
    use CherryPy tools in this context.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. Then we make a WSGI application from it through the `cherrypy.Application`
    helper. This returns a WSGI-valid callable made of the CherryPy application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. Next we start the CherryPy engine in a non-blocking mode as we still need
    CherryPy to handle the request and dispatch to the correct page handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4\. Then we create a WSGI server instance hosting our WSGI application, which
    is encapsulated in the gzip middleware, which compresses the response body. This
    middleware is provided by the `flup` package, which is another WSGI set of middlewares.
    (Flup is maintained by Allan Saddi.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To conclude, the level of support for WSGI within CherryPy 3 is excellent, while
    being flexible enough so that you can use the best of both designs when need be.
    CherryPy can be seen as a comprehensive and coherent WSGI implementation. Moreover,
    CherryPy has the most comprehensive and fastest WSGI server currently available
    and you have no reason to believe you should drop the library if you want WSGI
    support. You can get more information about WSGI at [http://wsgi.org](http://wsgi.org).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have reviewed key points of the CherryPy library, which
    will hopefully open your mind on how to make the most of its capabilities. While
    being a small package CherryPy offers an extended and yet coherent set of features
    all geared towards making your life easier. Some aspects of CherryPy have been
    left out, however, as they go beyond the scope of this book and the best place
    to gather more detailed information is by visiting the user and developer public
    mailing lists.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have acquired a good background with the library, we will move
    on to using it by developing a simple photoblog application.
  prefs: []
  type: TYPE_NORMAL
