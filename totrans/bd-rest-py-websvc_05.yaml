- en: Chapter 5.  Developing RESTful APIs with Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will start working with Flask and its Flask-RESTful extension;
    we will also create a RESTful Web API that performs CRUD operations on a simple
    list. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Design a RESTful API that performs CRUD operations in Flask with the Flask-RESTful
    extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the tasks performed by each HTTP method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up the virtual environment with Flask and its Flask-RESTful extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare status codes for the responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the model to represent a resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a dictionary as a repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure output fields for serialized responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with resourceful routing on top of Flask pluggable views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure resource routing and endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make HTTP requests to the Flask API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with command-line tools to interact with the Flask API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with GUI tools to interact with the Flask API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a RESTful API to interact with a simple data source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that we have to configure the messages to be displayed in an OLED display
    wired to an **IoT** (**Internet of Things**) device, the IoT device is capable
    of running Python 3.5, Flask, and other Python packages. There is a team that
    is writing code that retrieves string messages from a dictionary and displays
    them in the OLED display wired to the IoT device. We have to start working on
    a mobile app and a website that has to interact with a RESTful API to perform
    CRUD operations with string messages.
  prefs: []
  type: TYPE_NORMAL
- en: We don't need an ORM because we won't persist the string messages on a database.
    We will just work with an in-memory dictionary as our data source. It is one of
    the requirements for this RESTful API. In this case, the RESTful web service will
    be running on the IoT device, that is, we will run the Flask development server
    on the IoT device.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will definitely lose scalability for our RESTful API because we have the
    in-memory data source in the server, and therefore, we cannot run the RESTful
    API in another IoT device. However, we will work with another example related
    to a more complex data source that will be able to scale in the RESTful way later.
    The first example is going to allow us to understand how Flask and Flask-RESTful
    work together with a very simple in-memory data source.
  prefs: []
  type: TYPE_NORMAL
- en: We have chosen Flask because it is more lightweight than Django, we don't need
    to configure an ORM and we want to start running the RESTful API on the IoT device,
    as soon as possible, to allow all the teams to interact with it. We will code
    the website with Flask too, and therefore, we want to use the same web micro-framework
    to power the website and the RESTful web service.
  prefs: []
  type: TYPE_NORMAL
- en: There are many extensions available for Flask that makes it easier to perform
    specific tasks with the Flask micro-framework. We will take advantage of Flask-RESTful,
    an extension that will allow us to encourage best practices while building our
    RESTful API. In this case, we will work with a Python dictionary as the data source.
    As previously explained, we will work with more complex data sources in the forthcoming
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must specify the requirements for our main resource: a message. We
    need the following attributes or fields for a message:'
  prefs: []
  type: TYPE_NORMAL
- en: An integer identifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A string message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A duration in seconds that indicates the time the message has to be printed
    on the OLED display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A creation date and time-the timestamp will be added automatically when adding
    a new message to the collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A message category description, such as "Warning" and "Information"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integer counter that indicates the times the message has been printed in
    the OLED display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `bool` value indicating whether the message was printed at least once on the
    OLED display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following table shows the HTTP verbs, the scope, and the semantics for the
    methods that our first version of the API must support. Each method is composed
    by an HTTP verb and a scope and all the methods have a well-defined meaning for
    all the messages and collections. In our API, each message has its own unique
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP verb** | **Scope** | **Semantics** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Collection of messages | Retrieve all the stored messages in the
    collection, sorted by their name in ascending order |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Message | Retrieve a single message |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Collection of messages | Create a new message in the collection
    |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Message | Update a field for an existing message |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Message | Delete an existing message |'
  prefs: []
  type: TYPE_TB
- en: Understanding the tasks performed by each HTTP method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's consider that `http://localhost:5000/api/messages/` is the URL for the
    collection of messages. If we add a number to the preceding URL, we identify a
    specific message whose id is equal to the specified numeric value. For example,
    `http://localhost:5000/api/messsages/6` identifies the message whose id is equal
    to `6`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We want our API to be able to differentiate collections from a single resource
    of the collection in the URLs. When we refer a collection, we will use a slash
    (`/`) as the last character for the URL, as in `http://localhost:5000/api/messages/`.
    When we refer to a single resource of the collection we won't use a slash (`/`)
    as the last character for the URL, as in `http://localhost:5000/api/messages/6`.
  prefs: []
  type: TYPE_NORMAL
- en: We have to compose and send an HTTP request with the `POST` HTTP verb and the
    `http://localhost:5000/api/messages/` request URL to create a new message. In
    addition, we have to provide the JSON key-value pairs with the field names and
    the values to create the new message. As a result of the request, the server will
    validate the provided values for the fields, make sure that it is a valid message,
    and persist it in the messages dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server will return a `201 Created` status code and a JSON body with the
    recently added message serialized to JSON, including the assigned id that was
    automatically generated by the server to the message object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We have to compose and send an HTTP request with the `GET` HTTP verb and the
    `http://localhost:5000/api/messages/{id}` request URL to retrieve the message
    whose id matches the specified numeric value in the place where `{id}` is written.
    For example, if we use the request URL `http://localhost:5000/api/messages/82`,
    the server will retrieve the game whose id matches 82\. As a result of the request,
    the server will retrieve a message with the specified id from the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a message is found, the server will serialize the message object into JSON
    and return a `200 OK` status code and a JSON body with the serialized message
    object. If no message matches the specified id or primary key, the server will
    return a `404 Not Found` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have to compose and send an HTTP request with the `PATCH` HTTP verb and the
    `http://localhost:5000/api/messages/{id}` request URL to update one or more fields
    for the message whose id matches the specified numeric value in the place where
    `{id}` is written. In addition, we have to provide the JSON key-value pairs with
    the field names to be updated and their new values. As a result of the request,
    the server will validate the provided values for the fields, update these fields
    on the message that matches the specified id, and update the message in the dictionary,
    if it is a valid message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server will return a `200 OK` status code and a JSON body with the recently
    updated game serialized to JSON. If we provide invalid data for the fields to
    be updated, the server will return a `400 Bad Request` status code. If the server
    doesn''t find a message with the specified id, the server will return just a `404
    Not Found` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The PATCH method will allow us to easily update two fields for a message: the
    integer counter, that indicates the times the message has been printed and the
    bool value, that specifies whether the message was printed at least once.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to compose and send an HTTP request with the `DELETE` HTTP verb and
    the `http://localhost:5000/api/messages/{id}` request URL to remove the message
    whose id matches the specified numeric value in the place where `{id}` is written.
    For example, if we use the request URL `http://localhost:5000/api/messages/15`,
    the server will delete the message whose `id` matches `15`. As a result of the
    request, the server will retrieve a message with the specified id from the dictionary.
    If a message is found, the server will request the dictionary to delete the entry
    associated with this message object and return a `204 No Content` status code.
    If no message matches the specified id, the server will return a `404 Not Found`
    status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Setting up a virtual environment with Flask and Flask-RESTful
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Developing RESTful APIs with Django") *,*
    *Developing RESTful APIs with Django*, we learned that, throughout this book,
    we were going to work with the lightweight virtual environments introduced in
    Python 3.4 and improved in Python 3.4\. Now, we will follow the steps to create
    a new lightweight virtual environment to work with Flask and Flask-RESTful. It
    is highly recommended to read *[Chapter 1](ch01.html "Chapter 1. Developing RESTful
    APIs with Django"),* *Developing RESTful APIs with Django*, in case you don't
    have experience with lightweight virtual environments in Python. The chapter includes
    all the detailed explanations of the effects of the steps we are going to follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to select the target folder or directory for our virtual environment.
    We will use the following path in the example for macOS and Linux. The target
    folder for the virtual environment will be the `PythonREST/Flask01` folder within
    our home directory. For example, if our home directory in macOS or Linux is `/Users/gaston`,
    the virtual environment will be created within `/Users/gaston/PythonREST/Flask01`.
    You can replace the specified path with your desired path in each command, as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the following path in the example for Windows. The target folder
    for the virtual environment will be the `PythonREST\Flask01` folder within our
    user profile folder. For example, if our user profile folder is `C:\Users\Gaston`,
    the virtual environment will be created within `C:\Users\gaston\PythonREST\Flask01`.
    You can replace the specified path with your desired path in each command, as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a Terminal in macOS or Linux and execute the following command to create
    a virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, execute the following command to create a virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command doesn't produce any output. Now that we have created a
    virtual environment, we will run a platform-specific script to activate it. After
    we activate the virtual environment, we will install packages that will only be
    available in this virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your Terminal is configured to use the `bash` shell in macOS or Linux, run
    the following command to activate the virtual environment. The command also works
    for the `zsh` shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If your Terminal is configured to use either the `csh` or `tcsh` shell, run
    the following command to activate the virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If your Terminal is configured to use either the `fish` shell, run the following
    command to activate the virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, you can run either a batch file in the Command Prompt or a Windows
    PowerShell script to activate the virtual environment. If you prefer the Command
    Prompt, run the following command in the Windows command line to activate the
    virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you prefer the Windows PowerShell, launch it and run the following commands
    to activate the virtual environment. However, note that you should have the scripts
    execution enabled in Windows PowerShell to be able to run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After you activate the virtual environment, the Command Prompt will display
    the virtual environment root folder name, enclosed in parenthesis, as a prefix
    for the default prompt, to remind us that we are working in the virtual environment.
    In this case, we will see (`Flask01`) as a prefix for the Command Prompt because
    the root folder for the activated virtual environment is `Flask01`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created and activated a virtual environment. Now it is time to run
    the commands that will be the same for macOS, Linux, or Windows; we must run the
    following command to install Flask-RESTful with pip. Flask is a dependency for
    Flask-RESTful, and therefore, pip will install it automatically, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines for the output will indicate all the packages that have been
    successfully installed, including `flask-restful` and `Flask`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Declaring status codes for the responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Neither Flask nor Flask-RESTful includes the declaration of variables for the
    different HTTP status codes. We don't want to return numbers as status codes.
    We want our code to be easy to read and understand, and therefore, we will use
    descriptive HTTP status codes. We will borrow the code that declares useful functions
    and variables related to HTTP status codes from the `status.py` file included
    in Django REST Framework, that is, the framework we have been using in the preceding
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a folder named `api` within the root folder for the recently
    created virtual environment, and then create a new `status.py` file within the
    `api` folder. The following lines show the code that declares functions and variables
    with descriptive HTTP status codes in the `api/models.py` file borrowed from the
    `rest_framework.status` module. We don''t want to reinvent the wheel, and the
    module provides everything we need to work with HTTP status codes in our Flask-based
    API. The code file for the sample is included in the `restful_python_chapter_05_01`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The code declares five functions that receive the HTTP status code in the code
    argument and determine which of the following categories the status code belongs
    to: informational, success, redirect, client error, or server error categories.
    We will use the previous variables when we have to return a specific status code.
    For example, in case we have to return a `404 Not Found` status code, we will
    return `status.HTTP_404_NOT_FOUND`, instead of just `404`.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will create a simple `MessageModel` class that we will use to represent
    messages. Remember that we won''t be persisting the model in the database, and
    therefore, in this case, our class will just provide the required attributes and
    no mapping information. Create a new `models.py` file in the `api` folder. The
    following lines show the code that creates a `MessageModel` class in the `api/models.py`
    file. The code file for the sample is included in the `restful_python_chapter_05_01`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MessageModel` class just declares a constructor, that is, the `__init__`
    method. This method receives many arguments and then uses them to initialize the
    attributes with the same names: `message`, `duration`, `creation_date`, and `message_category`.
    The `id` attribute is set to 0, `printed_times` is set to `0`, and `printed_once`
    is set to `False`. We will automatically increment the identifier for each new
    message generated with API calls.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a dictionary as a repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will create a `MessageManager` class that we will use to persist the
    `MessageModel` instances in an in-memory dictionary. Our API methods will call
    methods for the `MessageManager` class to retrieve, insert, update, and delete
    `MessageModel` instances. Create a new `api.py` file in the `api` folder. The
    following lines show the code that creates a `MessageManager` class in the `api/api.py`
    file. In addition, the following lines declare all the `imports` we will need
    for all the code we will write in this file. The code file for the sample is included
    in the `restful_python_chapter_05_01` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `MessageManager` class declares a `last_id` class attribute and initializes
    it to 0\. This class attribute stores the last id that has been generated and
    assigned to a `MessageModel` instance stored in a dictionary. The constructor,
    that is, the `__init__` method, creates and initializes the `messages` attribute
    as an empty dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code declares the following three methods for the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`insert_message`: This method receives a recently created `MessageModel` instance
    in the `message` argument. The code increases the value for the `last_id` class
    attribute and then assigns the resulting value to the id for the received message.
    The code uses `self.__class__` to reference the type of the current instance.
    Finally, the code adds the `message` as a value to the key identified with the
    generated id, `last_id`, in the `self.messages` dictionary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_message`: This method receives the `id` of the message that has to be
    retrieved from the `self.messages` dictionary. The code returns the value related
    to the key that matches the received `id` in the `self.messages` dictionary that
    we are using as our data source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete_message`: This method receives the `id` of the message that has to
    be removed from the `self.messages` dictionary. The code deletes the key-value
    pair whose key matches the received id in the `self.messages` dictionary that
    we are using as our data source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't need a method to update a message because we will just make changes
    to the attributes of the `MessageModel` instance that is already stored in the
    `self.messages` dictionary. The value stored in the dictionary is a reference
    to the `MessageModel` instance that we are updating, and therefore, we don't need
    to call a specific method to update the instance in the dictionary. However, in
    case we were working with a database, we would need to call an update method for
    our ORM or data repository.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring output fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will create a `message_fields` dictionary that we will use to control
    the data that we want Flask-RESTful to render in our response, when we return
    `MessageModel` instances. Open the previously created `api/api.py` file and add
    the following lines. The code file for the sample is included in the `restful_python_chapter_05_01`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We declared the `message_fields` dictionary (`dict`) with key-value pairs of
    strings and classes declared in the `flask_restful.fields` module. The keys are
    the names of the attributes we want to render from the `MessageModel` class and
    the values are the classes that format and return the value for the field. In
    the previous code, we worked with the following classes, that format and return
    the value for the specified field in the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '`field.Integer`: Outputs an integer value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.Url`: Generates a string representation of a URL. By default, this
    class generates a relative URI for the resource that is being requested. The code
    specifies `''message_endpoint''` for the `endpoint` argument. This way, the class
    will use the specified endpoint name. We will declare this endpoint later in the
    `api.py` file. We don''t want to include the hostname in the generated URI, and
    therefore, we use the default value for the `absolute` bool attribute, which is
    `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.DateTime`: Outputs a formatted `datetime` string in UTC, in the default
    RFC 822 format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields.Boolean`: Generates a string representation of a bool value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `'uri'` field uses `fields.Url` and it is related to the specified endpoint
    instead of being associated to an attribute of the `MessageModel` class. It is
    the only case in which the specified field name doesn't have an attribute in the
    `MessageModel` class. The other strings specified as keys indicate all the attributes
    we want to be rendered in the output when we use the `message_fields` dictionary
    to make up the final serialized response output.
  prefs: []
  type: TYPE_NORMAL
- en: After we declared the `message_fields` dictionary, the next line of code creates
    an instance of the previously created `MessageManager` class named `message_manager`.
    We will use this instance to create, retrieve, and delete `MessageModel` instances.
  prefs: []
  type: TYPE_NORMAL
- en: Working with resourceful routing on top of Flask pluggable views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask-RESTful uses resources built on top of Flask pluggable views as the main
    building block for a RESTful API. We just need to create a subclass of the `flask_restful.Resource`
    class and declare the methods for each supported HTTP verb. A subclass of `flask_restful.Resource`
    represents a RESTful resource and therefore, we will have to declare one class
    to represent the collection of messages and another one to represent the message
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a `Message` class that we will use to represent the message
    resource. Open the previously created `api/api.py` file and add the following
    lines. The code file for the sample is included in the `restful_python_chapter_05_01`
    folder, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Message` class is a subclass of `flask_restful.Resource` and declares
    the following three methods, that will be called when the HTTP method with the
    same name arrives as a request on the represented resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get`: This method receives the id of the message that has to be retrieved
    in the `id` argument. The code calls the `self.abort_if_message_doesnt_exist`
    method to abort in case there is no message with the requested id. In case the
    message exists, the code returns the `MessageModel` instance whose `id` that matches
    the specified `id` returned by the `message_manager.get_message` method. The `get`
    method uses the `@marshal_with` decorator with `message_fields` as an argument.
    The decorator will take the `MessageModel` instance and apply the field filtering
    and output formatting specified in `message_fields`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete`: This method receives the id of the message that has to be deleted
    in the `id` argument. The code calls the `self.abort_if_message_doesnt_exist`
    method to abort, in case there is no message with the requested id. In case the
    [PRE20] [PRE21]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: return message
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: return marshal(message, resource_fields), status.HTTP_200_OK
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'class MessageList(Resource):'
  prefs: []
  type: TYPE_NORMAL
- en: '@marshal_with(message_fields)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'def get(self):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return [v for v in message_manager.messages.values()]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '@marshal_with(message_fields)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'def post(self):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: parser = reqparse.RequestParser()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: parser.add_argument('message', type=str, required=True, help='Message cannot
    be blank!')
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: parser.add_argument('duration', type=int, required=True, help='Duration cannot
    be blank!')
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: parser.add_argument('message_category', type=str, required=True, help='Message
    category cannot be blank!')
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: args = parser.parse_args()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: message = MessageModel(
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: message=args['message'],
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: duration=args['duration'],
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: creation_date=datetime.now(utc),
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: message_category=args['message_category']
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: message_manager.insert_message(message)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return message, status.HTTP_201_CREATED
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: app = Flask(__name__)
  prefs: []
  type: TYPE_NORMAL
- en: api = Api(app)
  prefs: []
  type: TYPE_NORMAL
- en: api.add_resource(MessageList, '/api/messages/')
  prefs: []
  type: TYPE_NORMAL
- en: api.add_resource(Message, '/api/messages/<int:id>', endpoint='message_endpoint')
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: app.run(debug=True)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: api.add_resource(MessageList, '/api/messages/')
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: api.add_resource(Message, '/api/messages/<int:id>', endpoint='message_endpoint')
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: python api/api.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '* Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)'
  prefs: []
  type: TYPE_NORMAL
- en: '* Restarting with stat'
  prefs: []
  type: TYPE_NORMAL
- en: '* Debugger is active!'
  prefs: []
  type: TYPE_NORMAL
- en: '* Debugger pin code: 294-714-594'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: app.run(host='0.0.0.0', debug=True)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: pip install --upgrade httpie
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: http POST :5000/api/messages/ message='Welcome to IoT' duration=10 message_category='Information'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'curl -iX POST -H "Content-Type: application/json" -d ''{"message":"Welcome
    to IoT", "duration":10, "message_category": "Information"}'' :5000/api/messages/'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"message": "Welcome to IoT",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"duration": 10,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"message_category": "Information"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: HTTP/1.0 201 CREATED
  prefs: []
  type: TYPE_NORMAL
- en: 'Content-Length: 245'
  prefs: []
  type: TYPE_NORMAL
- en: 'Content-Type: application/json'
  prefs: []
  type: TYPE_NORMAL
- en: 'Date: Wed, 20 Jul 2016 04:43:24 GMT'
  prefs: []
  type: TYPE_NORMAL
- en: 'Server: Werkzeug/0.11.10 Python/3.5.1'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"creation_date": "Wed, 20 Jul 2016 04:43:24 -0000",'
  prefs: []
  type: TYPE_NORMAL
- en: '"duration": 10,'
  prefs: []
  type: TYPE_NORMAL
- en: '"id": 1,'
  prefs: []
  type: TYPE_NORMAL
- en: '"message": "Welcome to IoT",'
  prefs: []
  type: TYPE_NORMAL
- en: '"message_category": "Information",'
  prefs: []
  type: TYPE_NORMAL
- en: '"printed_once": false,'
  prefs: []
  type: TYPE_NORMAL
- en: '"printed_times": 0,'
  prefs: []
  type: TYPE_NORMAL
- en: '"uri": "/api/messages/1"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: http POST :5000/api/messages/ message='Measuring ambient temperature' duration=5
    message_category='Information'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'curl -iX POST -H "Content-Type: application/json" -d ''{"message":"Measuring
    ambient temperature", "duration":5, "message_category": "Information"}'' :5000/api/messages/'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"message": "Measuring ambient temperature",'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"duration": 5,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"message_category": "Information"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: HTTP/1.0 201 CREATED
  prefs: []
  type: TYPE_NORMAL
- en: 'Content-Length: 259'
  prefs: []
  type: TYPE_NORMAL
- en: 'Content-Type: application/json'
  prefs: []
  type: TYPE_NORMAL
- en: 'Date: Wed, 20 Jul 2016 18:27:05 GMT'
  prefs: []
  type: TYPE_NORMAL
- en: 'Server: Werkzeug/0.11.10 Python/3.5.1'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"creation_date": "Wed, 20 Jul 2016 18:27:05 -0000",'
  prefs: []
  type: TYPE_NORMAL
- en: '"duration": 5,'
  prefs: []
  type: TYPE_NORMAL
- en: '"id": 2,'
  prefs: []
  type: TYPE_NORMAL
- en: '"message": "Measuring ambient temperature",'
  prefs: []
  type: TYPE_NORMAL
- en: '"message_category": "Information",'
  prefs: []
  type: TYPE_NORMAL
- en: '"printed_once": false,'
  prefs: []
  type: TYPE_NORMAL
- en: '"printed_times": 0,'
  prefs: []
  type: TYPE_NORMAL
- en: '"uri": "/api/messages/2"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: http :5000/api/messages/
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: curl -iX GET -H :5000/api/messages/
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: HTTP/1.0 200 OK
  prefs: []
  type: TYPE_NORMAL
- en: 'Content-Length: 589'
  prefs: []
  type: TYPE_NORMAL
- en: 'Content-Type: application/json'
  prefs: []
  type: TYPE_NORMAL
- en: 'Date: Wed, 20 Jul 2016 05:32:28 GMT'
  prefs: []
  type: TYPE_NORMAL
- en: 'Server: Werkzeug/0.11.10 Python/3.5.1'
  prefs: []
  type: TYPE_NORMAL
- en: '['
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"creation_date": "Wed, 20 Jul 2016 05:32:06 -0000",'
  prefs: []
  type: TYPE_NORMAL
- en: '"duration": 10,'
  prefs: []
  type: TYPE_NORMAL
- en: '"id": 1,'
  prefs: []
  type: TYPE_NORMAL
- en: '"message": "Welcome to IoT",'
  prefs: []
  type: TYPE_NORMAL
- en: '"message_category": "Information",'
  prefs: []
  type: TYPE_NORMAL
- en: '"printed_once": false,'
  prefs: []
  type: TYPE_NORMAL
- en: '"printed_times": 0,'
  prefs: []
  type: TYPE_NORMAL
- en: '"uri": "/api/messages/1"'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"creation_date": "Wed, 20 Jul 2016 05:32:18 -0000",'
  prefs: []
  type: TYPE_NORMAL
- en: '"duration": 5,'
  prefs: []
  type: TYPE_NORMAL
- en: '"id": 2,'
  prefs: []
  type: TYPE_NORMAL
- en: '"message": "Measuring ambient temperature",'
  prefs: []
  type: TYPE_NORMAL
- en: '"message_category": "Information",'
  prefs: []
  type: TYPE_NORMAL
- en: '"printed_once": false,'
  prefs: []
  type: TYPE_NORMAL
- en: '"printed_times": 0,'
  prefs: []
  type: TYPE_NORMAL
- en: '"uri": "/api/messages/2"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 127.0.0.1 - - [20/Jul/2016 02:32:06] "POST /api/messages/ HTTP/1.1" 201 -
  prefs: []
  type: TYPE_NORMAL
- en: 127.0.0.1 - - [20/Jul/2016 02:32:18] "POST /api/messages/ HTTP/1.1" 201 -
  prefs: []
  type: TYPE_NORMAL
- en: 127.0.0.1 - - [20/Jul/2016 02:32:28] "GET /api/messages/ HTTP/1.1" 200 -
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: http :5000/api/messages/800
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: curl -iX GET :5000/api/messages/800
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: HTTP/1.0 404 NOT FOUND
  prefs: []
  type: TYPE_NORMAL
- en: 'Content-Length: 138'
  prefs: []
  type: TYPE_NORMAL
- en: 'Content-Type: application/json'
  prefs: []
  type: TYPE_NORMAL
- en: 'Date: Wed, 20 Jul 2016 18:08:04 GMT'
  prefs: []
  type: TYPE_NORMAL
- en: 'Server: Werkzeug/0.11.10 Python/3.5.1'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"message": "Message 800 doesn''t exist. You have requested this URI [/api/messages/800]
    but did you mean /api/messages/<int:id> ?"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: http PATCH :5000/api/messages/2 printed_once=true printed_times=1
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'curl -iX PATCH -H "Content-Type: application/json" -d ''{"printed_once":"true",
    "printed_times":1}'' :5000/api/messages/2'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: HTTP/1.0 200 OK
  prefs: []
  type: TYPE_NORMAL
- en: 'Content-Length: 231'
  prefs: []
  type: TYPE_NORMAL
- en: 'Content-Type: application/json'
  prefs: []
  type: TYPE_NORMAL
- en: 'Date: Wed, 20 Jul 2016 18:28:01 GMT'
  prefs: []
  type: TYPE_NORMAL
- en: 'Server: Werkzeug/0.11.10 Python/3.5.1'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"creation_date": "Wed, 20 Jul 2016 18:27:05 -0000",'
  prefs: []
  type: TYPE_NORMAL
- en: '"duration": 0,'
  prefs: []
  type: TYPE_NORMAL
- en: '"id": 2,'
  prefs: []
  type: TYPE_NORMAL
- en: '"message": "Measuring ambient temperature",'
  prefs: []
  type: TYPE_NORMAL
- en: '"message_category": "Information",'
  prefs: []
  type: TYPE_NORMAL
- en: '"printed_once": true,'
  prefs: []
  type: TYPE_NORMAL
- en: '"printed_times": 1,'
  prefs: []
  type: TYPE_NORMAL
- en: '"uri": "/api/messages/2"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: http DELETE :5000/api/messages/2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: curl -iX DELETE :5000/api/messages/2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: HTTP/1.0 204 NO CONTENT
  prefs: []
  type: TYPE_NORMAL
- en: 'Content-Length: 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'Content-Type: application/json'
  prefs: []
  type: TYPE_NORMAL
- en: 'Date: Wed, 20 Jul 2016 18:50:12 GMT'
  prefs: []
  type: TYPE_NORMAL
- en: 'Server: Werkzeug/0.11.10 Python/3.5.1'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"message": "Measuring distance",'
  prefs: []
  type: TYPE_NORMAL
- en: '"duration": 5,'
  prefs: []
  type: TYPE_NORMAL
- en: '"message_category": "Information"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the request body in Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with GUI tools - Postman and others](img/image_05_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We followed the necessary steps to create an HTTP POST request with a JSON
    body that specifies the necessary key-value pairs to create a new game. Click
    **Send** and Postman will display the Status (**201 Created**), the time it took
    for the request to be processed and the response body with the recently added
    game formatted as JSON with syntax highlighting (**Pretty** view). The following
    screenshot shows the JSON response body in Postman for the HTTP POST request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with GUI tools - Postman and others](img/image_05_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we want to compose and send an HTTP PATCH request for our API with Postman,
    it is necessary to follow the previously explained steps to provide JSON data
    within the request body.
  prefs: []
  type: TYPE_NORMAL
- en: Click or tap on the value for the url field in the JSON response body-`/api/messages/2`.
    You will notice that the value will be underlined when you hover the mouse pointer
    over it. Postman will automatically generate a `GET` request to `localhost:5000/api/messages/2`.
    Click **Send** to run it and retrieve the recently added message. The field is
    useful to browse the API with a tool such as Postman.
  prefs: []
  type: TYPE_NORMAL
- en: Because we made the necessary changes to generate an externally visible Flask
    development server, we can also use apps that can compose and send HTTP requests
    from mobile devices to work with the RESTful API. For example, we can work with
    the iCurlHTTP App on iOS devices such as iPad Pro and iPhone. In Android devices,
    we can work with the previously introduced HTTP Request App.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the results of composing and sending the following
    HTTP request with the iCurlHTTP App: `GET http://192.168.2.3:5000/api/messages/`.
    Remember that you have to perform the previously explained configurations in your
    LAN and router to be able to access the Flask development server from other devices
    connected to your LAN. In this case, the IP assigned to the computer running the
    Flask Web server is `192.168.2.3`, and therefore, you must replace this IP with
    the IP assigned to your development computer.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with GUI tools - Postman and others](img/image_05_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask-RESTful uses which of the following as the main building block for a RESTful
    API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resources built on top of Flask pluggable views
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Statuses built on top of Flask resource views.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Resources built on top of Flask pluggable controllers.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to be able to process an HTTP POST request on a resource, we must declare
    a method with the following name in a subclass of `flask_restful.Resource`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`post_restful`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`post_method`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`post`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to be able to process an HTTP `GET` request on a resource, we must
    declare a method with the following name in a subclass of `flask_restful.Resource`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`get_restful`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`get_method`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`get`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A subclass of `flask_restful.Resource` represents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`A controller resource.`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`A RESTful resource.`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '` A single RESTful HTTP verb.`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we use the `@marshal_with` decorator with `message_fields` as an argument,
    the decorator will:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the field filtering and output formatting specified in `message_fields`
    to the appropriate instance.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the field filtering specified in `message_fields` to the appropriate instance,
    without considering output formatting.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the output formatting specified in `message_fields` to the appropriate
    instance, without considering field filtering.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we designed a RESTful API to interact with a simple dictionary
    that acted as a data repository and perform CRUD operations with messages. We
    defined the requirements for our API and we understood the tasks performed by
    each HTTP method. We set up a virtual environment with Flask and Flask-RESTful.
  prefs: []
  type: TYPE_NORMAL
- en: We created a model to represent and persist messages. We learned to configure
    serialization of messages into JSON representations with the features included
    in Flask-RESTful. We wrote classes that represent resources and process the different
    HTTP requests and we configured the URL patterns to route URLs to classes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we started Flask development server and we used command-line tools
    to compose and send HTTP requests to our RESTful API and analyzed how each HTTP
    request was processed in our code. We also worked with GUI tools to compose and
    send HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the basics of the combination of Flask and Flask-RESTful
    to create RESTful APIs, we will expand the capabilities of the RESTful Web API
    by taking advantage of advanced features included in Flask-RESTful and related
    ORMs, which is what we are going to discuss in the next chapter.
  prefs: []
  type: TYPE_NORMAL
