- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging, Error Handling, and Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we have concentrated on developing applications and adding
    features to them one at a time. It is very important to know how robust our application
    is and to keep track of how it has been working and performing. This, in turn,
    gives rise to the need to be informed when something goes wrong in the application.
    It is normal to miss out on certain edge cases while developing the application,
    and usually, even the test cases miss them out. It would be great to know about
    these edge cases whenever they occur so that they can be handled accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Effective logging and the ability to debug quickly are a couple of the deciding
    factors when choosing a framework for application development. The better the
    logging and debugging support from the framework, the quicker the process of application
    development and maintenance is. A better level of logging and debugging support
    helps developers quickly find out the issues in the application, and on many occasions,
    logging points out issues even before they are identified by end users. Effective
    error handling plays an important role in end user satisfaction and eases the
    pain of debugging at the developer’s end. Even if its code is perfect, the application
    is bound to throw errors at times. Why? The answer is simple – the code might
    be perfect, but the world in which it works is not. There can be innumerable issues
    that can occur, and as developers, we always want to know the reason behind any
    anomaly. Writing test cases along with the application is one of the most important
    pillars of software writing.
  prefs: []
  type: TYPE_NORMAL
- en: Python’s built-in logging system works pretty well with Flask. We will work
    with this logging system in this chapter before moving on to an awesome service
    called **Sentry**, which eases the pain of debugging and error logging to a huge
    extent.
  prefs: []
  type: TYPE_NORMAL
- en: As we have already talked about the importance of testing for application development,
    we will now see how to write test cases for a Flask application. We will also
    see how we can measure code coverage and profile our application to tackle any
    bottlenecks.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in itself is a huge topic and has several books attributed to it. Here,
    we will try to understand the basics of testing with Flask.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up basic file logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending emails on the occurrence of errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Sentry to monitor exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging with `pdb`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating application factories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the first simple test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing more tests for views and logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating the nose2 library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using mocking to avoid external API access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining test coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using profiling to find bottlenecks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up basic file logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Flask will not log anything for us anywhere, except for the errors
    with the stack traces, which are sent to the logger (we will see more of this
    in the rest of the chapter). It does create a lot of stack traces while we run
    the application in the development mode using `run.py`, but in production systems,
    we don’t have this luxury. Thankfully, the logging library provides a whole lot
    of log handlers, which can be used as per requirements. In this recipe, we will
    understand how the `logging` library can be leveraged to ensure that effective
    logs are being captured from Flask applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start with our catalog application from the previous chapter and add
    some basic logging to it using `FileHandler`, which logs messages to a specified
    file on the filesystem. We will start with a basic log format and then see how
    to format the log messages to be more informative.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to configure and set up the `logging` library to use with
    our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first change is made to the `my_app/__init__.py` file, which serves as
    the application’s configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we added a configuration parameter to specify the log file’s location.
    This takes the relative path from the application folder unless an absolute path
    is explicitly specified. Next, we will check whether the application is already
    in debug mode, and then we will add a handler logging to a file with the logging
    level as `INFO`. Now, `DEBUG` is the lowest logging level and will log everything
    at any level. For more details, refer to the `logging` library documentation (in
    the *See also* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, add loggers to the application wherever they are needed, and the
    application will start logging to the deputed file. Now, let’s add a couple of
    loggers to `my_app/catalog/views.py` for demonstration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we have added loggers for a couple of our view handlers.
    Note that the first of the loggers in `home()` is at the `info` level, and the
    other in `product()` is `warning`. If we set our log level in `__init__.py` as
    `INFO`, then both will be logged, and if we set the level as `WARNING`, then only
    the warning logger will be logged.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to import `abort` from `Flask` if this has not already been done –
    `from flask` `import abort`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The preceding steps will create a file called `application.log` in the root
    application folder. The logger statements as specified will be logged to `application.log`
    and will look something like the following snippet, depending on the handler called;
    the first one is from the home page, and the second is from requesting a product
    that does not exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: To enable logging, either run your application with a WSGI server (refer to
    [*Chapter 11*](B19111_11.xhtml#_idTextAnchor610)) or run using `flask run` on
    your terminal prompt (refer to [*Chapter 1*](B19111_01.xhtml#_idTextAnchor016)).
  prefs: []
  type: TYPE_NORMAL
- en: Running the application using `run.py` will always make it run with the `debug`
    flag as `True`, which will not allow logging to work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The information logged does not help much. It would be great to know when the
    issue was logged, with what level, which file caused the issue at what line number,
    and so on. This can be achieved using advanced logging formats. For this, we need
    to add a couple of statements to the configuration file – that is, `my_app/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we added a formatter to `file_handler`, which will log
    the time, log level, message, file path, and line number. After this, the logged
    message will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We might also want to log all the errors when a page is not found (the `404`
    error). For this, we can just tweak the `errorhandler` method a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go to Python’s `logging` library documentation about handlers at [https://docs.python.org/dev/library/logging.handlers.html](https://docs.python.org/dev/library/logging.handlers.html)
    to learn more about logging handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Sending emails on the occurrence of errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a good idea to receive notifications when something unexpected happens
    with the application. Setting this up is pretty easy and adds a lot of convenience
    to the process of error handling.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will take the application from the last recipe and add `mail_handler` to
    it to make our application send emails when an error occurs. Also, we will demonstrate
    the email setup using Gmail as the SMTP server.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, add the handler to the configuration in `my_app/__init__.py`. This is
    similar to how we added `file_handler` in the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a list of email addresses to which the error notification email
    will be sent. Also, note that we have set the log level to `ERROR` in the case
    of `mail_handler`. This is because emails will be necessary only in the case of
    crucial matters.
  prefs: []
  type: TYPE_NORMAL
- en: For more details on the configuration of `SMTPHandler`, refer to the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: Always make sure that you run your application with the `debug` flag set to
    `off` to enable the application to log and send emails for internal application
    errors (the `500` error).
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To cause an internal application error, just misspell some keyword in any of
    your handlers. You will receive an email in your mailbox, with the formatting
    as set in the configuration and a complete stack trace for your reference.
  prefs: []
  type: TYPE_NORMAL
- en: Using Sentry to monitor exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sentry is a tool that eases the process of monitoring exceptions and also provides
    insights into the errors that users of the application face while using it. It
    is highly possible that there are errors in log files that get overlooked by the
    human eye. Sentry categorizes the errors under different categories and keeps
    a count of the recurrence of errors. This helps us to understand the severity
    of the errors on multiple criteria and how to handle them accordingly. It has
    a nice GUI that facilitates all of these features. In this recipe, we will set
    up Sentry and use it as an effective error-monitoring tool.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sentry is available as a cloud service, which is available free for developers
    and basic users. For the purposes of this recipe, this freely available cloud
    service will be enough. Head over to [https://sentry.io/signup/](https://sentry.io/signup/)
    and get started with the registration process. This being said, we need to install
    the Python SDK for Sentry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the Sentry registration is complete, a screen will be shown that will
    ask about the type of project that needs to be integrated with Sentry. See the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – The Sentry project creation screen](img/B19111_10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – The Sentry project creation screen
  prefs: []
  type: TYPE_NORMAL
- en: 'This will be followed by another screen that shows the steps on how to configure
    your Flask application to send events to the newly created and configured Sentry
    instance. This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – The Sentry project configuration steps](img/B19111_10_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – The Sentry project configuration steps
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Sentry can also be downloaded for free and installed as an on-premises application.
    There are multiple ways of installing and configuring Sentry as per your needs.
    You are free to try this approach on your own, as it goes beyond the scope of
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the previous setup is complete, add the following code to your Flask
    application in `my_app/__init__.py`, replacing `https://1234:5678@fake-sentry-server/1`
    with the Sentry project URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An error logged in Sentry will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – The Sentry error log screen](img/B19111_10_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – The Sentry error log screen
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to log messages and user-defined exceptions in Sentry. I
    will leave this to you to figure out by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with pdb
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the Python developers reading this book might already be aware of the
    usage of `pdb` is an interactive source code debugger for Python programs. We
    can set breakpoints wherever needed, debug using single stepping at the source
    line level, and inspect the stack frames.
  prefs: []
  type: TYPE_NORMAL
- en: Many new developers might be of the opinion that the job of a debugger can be
    handled using a logger, but debuggers provide a much deeper insight into the flow
    of control, preserve the state at each step, and hence, potentially save a lot
    of development time. In this recipe, let’s have a look at what `pdb` brings to
    the table.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use Python’s built-in `pdb` module for this recipe and use it in our
    application from the last recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using `pdb` is pretty simple in most cases. We just need to insert the following
    statement wherever we want to insert a breakpoint to inspect a certain block of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This will trigger the application to break execution at this point, and then
    we can step through the stack frames one by one using the debugger commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s insert this statement in one of our methods – say, the handler for
    products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whenever the control comes to this line, the debugger prompt will fire up;
    this will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note `u` written against `(Pdb)`. This signifies that I am moving the current
    frame one level up in the stack trace. All the variables, parameters, and properties
    used in that statement will be available in the same context to help figure out
    the issue, or just understand the flow of code. There are other debugger commands
    that could prove helpful in your navigation of the debug logs. Check the following
    *See also* section for these.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go to the `pdb` module documentation at [https://docs.python.org/3/library/pdb.html#debugger-commands](https://docs.python.org/3/library/pdb.html#debugger-commands)
    to get hold of the various debugger commands.
  prefs: []
  type: TYPE_NORMAL
- en: Creating application factories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Leveraging a factory pattern is a great way of organizing your application object,
    allowing for multiple application objects with different settings. As discussed
    in [*Chapter 1*](B19111_01.xhtml#_idTextAnchor016), it is always possible to create
    multiple application instances by using different configurations, but application
    factories allow you to have multiple application objects inside the same application
    process. It also aids in testing, as you can choose to have a fresh or different
    application object with different settings for each test case.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use our application from the previous recipe and modify it to use the
    application factory pattern.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the changes that need to be made:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by creating a function named `create_app()` in our `my_app/__init__.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this function, we have just rearranged all the application configurations
    inside a function named `create_app()`. This will allow us to create as many application
    objects as needed by simply calling this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a method named `create_db()`, which initializes the database
    and then creates tables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again in this function, we have just moved the database-specific code to a function.
    This method has been kept separate because you might want to use different database
    configs with different application instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step in `my_app/__init__.py` would be to call/execute these methods
    and register the blueprints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have created the objects for `app`, `db`, and `babel` by calling relevant
    methods and initializing the extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'A downside of the application factory pattern is that you cannot use the application
    object in blueprints during import time. However, you can always utilize the `current_app`
    proxy to access the current application object. Let’s see how this is done in
    `my_app/catalog/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The application will continue to work in the same way as it did in the last
    recipe. It’s just that the code has been rearranged to implement the application
    factory pattern.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next couple of recipes will help you understand how the factory pattern
    is used while writing test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the first simple test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is one of the strongest pillars of any software during development and,
    later, during maintenance and expansion. Especially in the case of web applications,
    where the application will handle high traffic and be scrutinized by a large number
    of end users at all times, testing becomes pretty important, as the user feedback
    determines the fate of the application. In this recipe, we will see how to start
    with test writing and also see more complex tests in the recipes to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start with the creation of a new test file named `app_tests.py` at the
    root application level – that is, alongside the `my_app` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s write our first test case:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, the content of the `app_tests.py` test file will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code describes the imports needed for this test suite. We will
    use `unittest` to write our tests. A `tempfile` instance is needed to create SQLite
    databases on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the test cases need to subclass from `unittest.TestCase`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding method is run before each test is run and creates a new test client.
    A test is represented by the methods in this class that start with the `test_`
    prefix. Here, we set a database name in the app configuration, which is a timestamp-based
    value that will always be unique. We also set the `TESTING` flag to `True`, which
    disables error catching to enable better testing. Do pay special attention to
    how the application factory is used to create an application object before initializing
    `db` and `babel`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we run the `create_all()` method on `db` to create all the tables from
    our application in the test database created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the temporary database created in the previous step after the test has
    executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding method is called after each test is run. Here, we will remove
    the current database file and use a fresh database file for each test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, write the test case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code is our first test, where we sent an HTTP `GET` request to
    our application at the `/` URL and tested the response for the status code, which
    should be `200`, representing a successful `GET` response.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run the test file, just execute the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output that signifies the outcome of the
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 10.4 –\uFEFF The first test result](img/B19111_10_4.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – The first test result
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the next recipe, *Writing more tests for views and logic*, to see more
    on how to write complex tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing more tests for views and logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last recipe, we got started with writing tests for our Flask application.
    In this recipe, we will build upon the same test file and add more tests for our
    application; these tests will cover testing the views for behavior and logic.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will build upon the test file named `app_tests.py` created in the last recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we write any tests, we need to add a small bit of configuration to `setUp()`
    to disable the CSRF tokens, as they are not generated by default for test environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are some tests that are created as a part of this recipe. Each
    test will be described as we go further:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, write a test to make a `GET` request to the products list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding test sends a `GET` request to the `/products` endpoint and asserts
    that the status code of the response is `200`. It also asserts that there is no
    previous page and no next page (rendered as a part of the template logic).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a category and verify that it has been created correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding test creates a category and asserts for corresponding status messages.
    When a category is successfully created, we will be redirected to the newly created
    category page, and hence, the status code will be `302`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, similar to category creation, create a product and then verify its creation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding test creates a product and asserts for corresponding status messages
    on each call/request.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: As a part of this test, we identified a small improvement in our `create_product()`
    method. We had not initiated the `filename` variable before the `if` condition
    to check for the allowed file type. The earlier code would work fine only when
    the `if` condition passed. Now, we have just adjusted the code to initiate `filename`
    as `filename = secure_filename(image.filename)` before the `if` condition, instead
    of doing it inside the condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, create multiple products and search for the products that were just
    created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE206]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE207]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE208]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE209]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE211]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE212]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE213]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE214]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding test first creates a category and two products. Then, it searches
    for one product and makes sure that only the searched product is returned in the
    result.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run the test file, just execute the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: What follows the command is the output that shows the outcome of the tests.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another interesting and popular library that can be used for unit testing is
    **pytest**. It is similar to Python’s in-built **unittest** library but with more
    out-of-the-box features. Feel free to explore it: [https://docs.pytest.org/en/stable/](https://docs.pytest.org/en/stable/).'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the nose2 library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`nose2` can be used for multiple purposes, the most important usage remains
    that of a test collector and runner. `nose2` automatically collects tests from
    Python source files, directories, and packages found in the current working directory.
    In this recipe, we will focus on how to run individual tests using `nose2` rather
    than the whole bunch of tests every time.'
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: In earlier editions of this book, we used the `nose` library. It has since not
    been under active maintenance and can be deemed deprecated. A replacement for
    it has been created, with the name `nose2`. This library behaves similarly to
    `nose` but is not exactly the same. However, for the purpose of our demonstration,
    the major functionality remains similar.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to install the `nose2` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '`nose2` has a mechanism for test file discovery that mandates that a file should
    start with `test`. Since, in our case, the test file is named `app_tests.py`,
    we should now rename it `test_app.py`. On a terminal, you can simply run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can execute all the tests in our application using `nose2` by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: This will pick out all the tests in our application and run them, even if we
    have multiple test files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run a single test file, simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you want to run a single test, simply run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: This becomes important when we have a memory-intensive application and a large
    number of test cases. In that instance, the tests themselves can take a long time
    to run, and doing so every time can be very frustrating for a developer. Instead,
    we will prefer to run only those tests that concern the change made, or the test
    that broke following a certain change.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many other ways to configure `nose2` for optimal and effective usage
    as per requirements. Refer to the `nose2` documentation at [https://docs.nose2.io/en/latest/index.html](https://docs.nose2.io/en/latest/index.html)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Using mocking to avoid external API access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are aware of how testing works, but now, let’s imagine we have a third-party
    application/service integrated via API calls with our application. It would not
    be a great idea to make calls to this application/service every time tests are
    run. Sometimes, these can be paid, too, and making calls during tests can not
    only be expensive but also affect the statistics of that service. `geoip2` library
    and then test it via mocking.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Python 3, `mock` has been included as a standard package in the `unittest`
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purpose of this recipe, we first need to install the `geoip2` library
    and the corresponding database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: You also need to download the free `geoip` database from the MaxMind ([https://dev.maxmind.com/geoip/geolite2-free-geolocation-data](https://dev.maxmind.com/geoip/geolite2-free-geolocation-data))
    website to a location of your preference, and then unzip the file. For the sake
    of simplicity, I have downloaded it to the project folder itself. You will need
    to create a free account before you can download the `geoip` city database.
  prefs: []
  type: TYPE_NORMAL
- en: After downloading the city database, you should have a folder with the `Geolite2-
    City-` prefix. This folder contains the `geoip` database with the `.mmdb` extension
    that we will use in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s say we want to store the location of a user who creates a product
    (imagine a scenario where the application is administered at multiple global locations).
  prefs: []
  type: TYPE_NORMAL
- en: We need to make some small changes to `my_app/catalog/models.py`, `my_app/catalog/views.py`,
    and `templates/product.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `my_app/catalog/models.py`, we will add a new field named `user_timezone`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: 'For `my_app/catalog/views.py`, we will modify the `create_product()` method
    to include the time zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: Here, we fetched the geolocation data using an IP lookup and passed this during
    product creation. If no match is found, then the call is made from `localhost`,
    `127.0.0.1`, or `0.0.0.0`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we will add this new field in our product template so that it becomes
    easy to verify in the test. For this, just add `{{ product.user_timezone }}` somewhere
    in the `product.html` template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start by modifying `test_app.py` to accommodate the mocking of the `geoip`
    lookup:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, configure the mocking of the `geoip` lookup by creating patchers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE226]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE227]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE228]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE229]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE230]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE231]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE232]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE233]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE234]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE235]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE236]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE237]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE238]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE239]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE240]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE241]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE242]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE243]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE244]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE245]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE246]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE247]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we imported `records` from `geoip2`, which we will use to create the
    mocked return value that we need to use for testing. Then, we patched `geoip2.models.City`
    with the `location` attribute on the `City` model preset to `geoip2.records.Location(time_zone
    = 'America/Los_Angeles')` and started the patcher. This means that whenever an
    instance of `geoip2.models.City` is created, it will be patched with the time
    zone on the `location` attribute set to `'America/Los_Angeles'`.
  prefs: []
  type: TYPE_NORMAL
- en: This is followed by the patching of `geoip2.database.Reader`, where we mock
    the return value of its `city()` method to the `PatchedGeoipCity` class that we
    created previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop the patchers that were started in the `setUp` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE249]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE250]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE251]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We stopped the mock patchers in `tearDown` so that the actual calls are not
    affected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, modify the product test case created to assert the location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE253]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE254]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE255]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE256]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE257]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE258]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE259]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE260]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE261]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE262]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE263]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE264]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE265]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE266]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE267]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE268]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE269]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, after the creation of the product, we asserted that the `America/Los_Angeles`
    value is present somewhere in the product template that is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the test and see whether it passes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are multiple ways in which mocking can be done. I demonstrated just one
    of them. You can choose any method from the ones available. Refer to the documentation
    available at [https://docs.python.org/3/library/unittest.mock.html](https://docs.python.org/3/library/unittest.mock.html).
  prefs: []
  type: TYPE_NORMAL
- en: Determining test coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, test case writing was covered, but there is an important
    aspect to measure the extent of testing, called coverage. Coverage refers to how
    much of our code has been covered by the tests. The higher the percentage of coverage,
    the better the testing (although high coverage is not the only criterion for good
    tests). In this recipe, we will check the code coverage of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Remember that 100% test coverage does not mean that code is flawless. However,
    in any case, it is better than having no tests or lower coverage. Remember that
    “*if it’s not tested,* *it’s broken.*”
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use a library called `coverage` for this recipe. The following is the
    installation command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest way of measuring code coverage is to use the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `--source` indicates the directories that are to be considered in coverage,
    and `--omit` indicates the files that need to be omitted in the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to print the report on the terminal itself, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot shows the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – The test coverage report](img/B19111_10_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – The test coverage report
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a nice HTML output of the coverage report, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will create a new folder named `htmlcov` in your current working directory.
    Inside this, just open up `index.html` in a browser, and the full detailed view
    will be available.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – The test coverage report web view](img/B19111_10_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – The test coverage report web view
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can include a piece of code in our test file and get the
    coverage report every time the tests are run. We just add the following code snippets
    to `test_app.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before anything else, add the following code to start the coverage assessment
    process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE276]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE277]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE278]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE279]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE280]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE281]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE282]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE283]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we imported the `coverage` library and created an object for it. This
    tells the library to omit all `site-packages` instances (because we do not want
    to evaluate the code that we did not write) and the test file itself. Then, we
    started the process to determine the coverage.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the code, modify the last block to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE285]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE286]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE287]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE288]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE289]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE290]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE291]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE292]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we first put `unittest.main()` inside a `try..finally`
    block. This is because `unittest.main()` exits after all the tests are executed.
    Now, the coverage-specific code is forced to run after this method completes.
    We stopped the coverage report, saved it, printed the report on the console, and
    then generated the HTML version of it before deleting the temporary `.coverage`
    file (this is created automatically as part of the process).
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we run our tests after including the coverage-specific code, then we can
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: The output will be very similar to the one in *Figure 10**.5*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is also possible to determine coverage using the `nose2` library, which we
    discussed in the *Integrating the nose2 library* recipe. I will leave it to you
    to explore this by yourself. Refer to [https://docs.nose2.io/en/latest/plugins/coverage.html](https://docs.nose2.io/en/latest/plugins/coverage.html)
    for a head start.
  prefs: []
  type: TYPE_NORMAL
- en: Using profiling to find bottlenecks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Profiling is an important and handy tool to measure performance when we decide
    to scale an application. Before scaling, we want to know whether any process is
    a bottleneck and affects the overall performance. Python has a built-in profiler,
    `cProfile`, that can do the job for us, but to make life easier, `werkzeug` has
    `ProfilerMiddleware`, which is written over `cProfile`. In this recipe, we will
    use `ProfilerMiddleware` to determine whether there is anything that affects performance.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the application from the previous recipe and add `ProfilerMiddleware`
    to a new file named `generate_profile.py`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file, `generate_profile.py`, alongside `run.py`, which works like
    `run.py` itself but with `ProfilerMiddleware`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: Here, we imported `ProfilerMiddleware` from `werkzeug` and then modified `wsgi_app`
    on our Flask app to use it, with a restriction of the top 10 calls to be printed
    in the output.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we can run our application using `generate_profile.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then create a new product. Then, the output for that specific call will
    be like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – The profiler output](img/B19111_10_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – The profiler output
  prefs: []
  type: TYPE_NORMAL
- en: It is evident from the preceding screenshot that the most intensive call in
    this process is the call made to the `geoip` database. Even though it is a single
    call, it takes the most amount of time. So, if we decide to improve performance
    sometime down the line, this is something that needs to be looked at first.
  prefs: []
  type: TYPE_NORMAL
