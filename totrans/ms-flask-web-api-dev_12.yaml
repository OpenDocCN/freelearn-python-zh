- en: <st c="0">12</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="3">Integrating Flask with Other Tools and Frameworks</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="53">Flask’s flexibility, seamlessness, and pluggability provide ease
    for building various applications, from simple form-based counseling systems to
    Docker-based applications.</st> *<st c="226">Chapters 1</st>* <st c="236">to</st>
    *<st c="240">10</st>* <st c="242">have showcased its minimalistic but powerful
    framework with several extension modules and libraries providing support, fast
    solutions, and clean coding for web and</st> <st c="407">API applications.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="424">Although Flask is not favored to handle large enterprise solutions
    like Django can, it can serve as a middleware or component to many enterprise-grade
    systems and can even be a good solution for building microservices.</st> <st c="644">The
    superb flexibility of Flask makes it an ideal inclusion to the recipes of many
    software infrastructures of many</st> <st c="760">business processes.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="779">To give a clear picture as to where to place Flask in the list of
    popular Python frameworks, the goal of this last chapter is to highlight the feasibility
    of having a backend Flask implementation for mobile and frontend applications,
    a solution to a microservice architecture, and an implementation to many modern
    requirements such as creating and running queries and CRUD transactions</st> <st
    c="1166">through GraphQL.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1182">These are the topics covered in</st> <st c="1215">this chapter:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1228">Implementing microservice applications involving FastAPI, Django,</st>
    <st c="1295">and Tornado</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1306">Implementing</st> <st c="1320">Flask instrumentation</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1341">Applying OpenAPI 3.x specification</st> <st c="1377">with Swagger</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1389">Providing REST services to a Flutter</st> <st c="1427">mobile application</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1445">Consuming REST endpoints with a</st> <st c="1478">React application</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1495">Building a</st> <st c="1507">GraphQL application</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1526">Technical requirements</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1549">This chapter uses an</st> *<st c="1571">Online Library Management
    System</st>* <st c="1603">to expound on building a microservice application that
    incorporates</st> <st c="1672">FastAPI, Django, and Flask sub-applications with
    Tornado as the facade application and the server.</st> <st c="1771">The sub-applications
    are mounted using different URL prefixes.</st> <st c="1834">Here are the services
    offered by each of the</st> <st c="1879">mounted applications:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1900">Django sub-module – managing student</st> <st c="1938">book borrowers</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1952">Flask sub-module – managing faculty</st> <st c="1989">book browsers</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2002">FastAPI sub-module – managing feedback and complaints</st> <st
    c="2057">from borrowers</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2071">Flask main application – the</st> <st c="2101">core transactions</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2118">Tornado application – the</st> <st c="2145">facade application</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="2163">Figure 12</st>**<st c="2173">.1</st>* <st c="2175">shows the
    flow of transactions of these</st> <st c="2216">mounted applications.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Combined Django, Flask, FastAPI, and Tornado applications](img/B19383_12_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="2346">Figure 12.1 – Combined Django, Flask, FastAPI, and Tornado applications</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2417">The sub-modules</st> <st c="2433">use</st> **<st c="2438">SQLAlchemy</st>**
    <st c="2448">as the ORM, while the Flask main application uses the</st> <st c="2502">standard</st>
    **<st c="2512">Peewee</st>** <st c="2518">ORM.</st> <st c="2524">All the projects
    of this chapter are uploaded</st> <st c="2570">at</st> [<st c="2573">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch12</st>](https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch12)<st
    c="2654">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2655">Implementing microservice applications involving FastAPI, Django,
    and Tornado</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2733">Flask 3.x provides a</st> `<st c="2755">DispatcherMiddleware</st>`
    <st c="2775">class from</st> *<st c="2787">Werkzeug</st>* <st c="2795">that combines
    isolated and</st> <st c="2823">valid WSGI-based applications to form a complete
    and larger system.</st> <st c="2891">These combined applications can be all Flask
    or different WSGI-based applications such as Django, each with a unique URL prefix.</st>
    *<st c="3020">Figure 12</st>**<st c="3029">.2</st>* <st c="3031">shows the directory
    structure of our</st> <st c="3069">combined projects:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Django, FastAPI, Flask, and Tornado in one project structure](img/B19383_12_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="3313">Figure 12.2 – Django, FastAPI, Flask, and Tornado in one project
    structure</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3387">All views, repositories, services, models, and configuration files
    of the main Flask application are in the</st> `<st c="3496">modules</st>` <st
    c="3503">folder.</st> <st c="3512">On the other hand, all the application files
    of the FastAPI app are in the</st> `<st c="3587">modules_fastapi</st>` <st c="3602">folder,
    all components of the Django app are in the</st> `<st c="3655">modules_django</st>`
    <st c="3669">folder, all Tornado API handlers are in</st> `<st c="3710">modules_tornado</st>`<st
    c="3725">, and all GraphQL components are in the</st> `<st c="3765">modules_sub_flask</st>`
    <st c="3782">directory.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3793">When it</st> <st c="3802">comes to their respective module scripts,
    the FastAPI</st> `<st c="3856">app</st>` <st c="3859">instance is in</st> `<st
    c="3875">main_fastapi.py</st>`<st c="3890">, the Flask sub-module’s</st> `<st
    c="3915">app</st>` <st c="3918">instance is in</st> `<st c="3934">main_sub_flask.py</st>`<st
    c="3951">, and the Flask main module’s</st> `<st c="3981">app</st>` <st c="3984">instance
    together with the Tornado server is</st> <st c="4030">in</st> `<st c="4033">main.py</st>`<st
    c="4040">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4041">Now, let us discuss how all these sub-applications can run together
    using one</st> <st c="4120">Tornado server.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4135">Adding the Flask sub-application</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`<st c="4168">DispatcherMiddleware</st>` <st c="4189">requires</st> <st c="4198">a
    Flask</st> `<st c="4207">app</st>` <st c="4210">instance to its first parameter
    and a dictionary containing the mounts of sub-applications, where the</st> *<st
    c="4313">key</st>* <st c="4316">is the URL pattern mapped to their corresponding
    WSGI</st> `<st c="4371">app</st>` <st c="4374">instance.</st> <st c="4385">Mounting
    Flask sub-applications to a main Flask application is straightforward.</st> <st
    c="4465">The following snippets show how to mount the</st> `<st c="4510">flask_sub_app</st>`
    <st c="4523">instance of the Flask sub-application to the core Flask</st> `<st
    c="4580">app</st>` <st c="4583">instance:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="5112">The Flask sub-application</st> <st c="5138">must have its dedicated
    module script (e.g.,</st> `<st c="5184">main_flask_sub.py</st>`<st c="5201">)
    for its</st> `<st c="5212">flask_sub_app</st>` <st c="5225">instantiation.</st>
    `<st c="5241">main.py</st>` <st c="5248">must import the</st> `<st c="5265">flask_sub_app</st>`
    <st c="5278">instance from a dedicated module rather than creating it in</st>
    `<st c="5339">main.py</st>` <st c="5346">for traceability, easy debugging, and
    code-clean reasons.</st> <st c="5405">Combining Flask apps to form a larger unit
    does not need additional configurations, unlike adding a FastAPI application to
    the main context.</st> <st c="5546">How do we register FastAPI applications</st>
    <st c="5586">to</st> `<st c="5589">DispatcherMiddleware</st>`<st c="5609">?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5610">Adding the FastAPI sub-application</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="5644">Not all ASGI-based applications are</st> <st c="5681">compatible
    with Flask’s context and can be part of the</st> `<st c="5736">DispatcherMiddleware</st>`
    <st c="5756">mounts.</st> <st c="5765">For FastAPI, the workaround is to convert
    the</st> `<st c="5811">app</st>` <st c="5814">instance to WSGI at runtime using</st>
    `<st c="5849">ASGIMiddleware</st>` <st c="5863">from the</st> `<st c="5873">a2wsgi</st>`
    <st c="5879">module.</st> <st c="5888">To utilize the ASGI-to-WSGI converter,
    first install</st> `<st c="5941">a2wsgi</st>` <st c="5947">using the following</st>
    `<st c="5968">pip</st>` <st c="5971">command:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`<st c="5999">ASGIMiddleware</st>` <st c="6014">does not depend on many external
    modules, so the conversion is straightforward from its built-in mechanisms.</st>
    <st c="6124">It will not consume more memory for its conversion.</st> <st c="6176">But,
    if the FastAPI application has several background tasks to perform, the utility
    class has a constructor parameter,</st> `<st c="6296">wait_time</st>`<st c="6305">,
    to set an allowable time duration for every background task to finish running
    before finishing a request.</st> <st c="6413">Moreover, its constructor has a</st>
    `<st c="6445">loop</st>` <st c="6449">parameter to allow setting another event
    loop in case the core platform needs a different type of event loop.</st> <st
    c="6560">Now, the following</st> `<st c="6579">main.py</st>` <st c="6586">snippet
    shows how to add our FastAPI</st> `<st c="6624">app</st>` <st c="6627">instance
    to the</st> <st c="6644">mounted applications:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: <st c="7225">The</st> `<st c="7230">a2wsgi</st>` <st c="7236">module</st> <st
    c="7244">works perfectly with FastAPI applications.</st> <st c="7287">Not all
    ASGI-based applications can undergo seamless conversions with</st> `<st c="7357">a2wsgi</st>`
    <st c="7363">like</st> <st c="7369">FastAPI apps.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7382">Let us now add our Django sub-module to our</st> <st c="7427">mounted
    applications.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7448">Adding the Django sub-application</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="7482">Django</st> <st c="7489">is a pure WSGI framework but can run on
    ASGI servers with additional configurations.</st> <st c="7575">Unlike in FastAPI,
    adding a Django application to the mounts requires several steps, which include
    the</st> <st c="7678">following procedures in the</st> `<st c="7706">main.py</st>`
    <st c="7713">module and Django</st> <st c="7732">admin’s</st> `<st c="7740">settings.py</st>`<st
    c="7751">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7753">Since</st> `<st c="7759">module_django</st>` <st c="7772">is not
    the main project folder, import the</st> `<st c="7816">os</st>` <st c="7818">module
    and set the default value of the</st> `<st c="7859">DJANGO_SETTINGS_MODULE</st>`
    <st c="7881">environment variable</st> <st c="7903">to</st> `<st c="7906">modules_django.modules_django.settings</st>`<st
    c="7944">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="8036">This setting defines the location of</st> `<st c="8074">settings.py</st>`
    <st c="8085">of the Django admin folder.</st> <st c="8114">Failure to adjust this
    setting will lead to the following</st> <st c="8172">runtime error:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="8556">Registering a Django application to the</st> `<st c="8597">INSTALLED_APPS</st>`
    <st c="8611">settings must include the Django</st> <st c="8645">project name:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="8896">Also, include the Django project folder in defining the Django
    application object</st> <st c="8978">in</st> `<st c="8981">settings.py</st>`<st
    c="8992">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="9317">(views.py)</st> from rest_framework.response import Response
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from rest_framework.decorators import api_view
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from <st c="9426">modules_django</st>.olms.serializer import BorrowedHistSerializer,
    StudentBorrowerSerializer
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from <st c="9519">modules_django</st>.olms.models import StudentBorrower, BorrowedHist
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@api_view([''GET''])'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'def getData(request):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app = StudentBorrower.objects.all()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: serializer = StudentBorrowerSerializer(app, many=True)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return Response(serializer.data)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '@api_view([''POST''])'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'def postData(request):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: serializer = StudentBorrowerSerializer(data=request.data)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if serializer.is_valid():'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: serializer.save()
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return Response(serializer.data)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: return Response({"message:error"})
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="9966">Since we are</st> <st c="9980">mounting our Django application
    as a WSGI sub-application, set</st> `<st c="10043">DJANGO_ALLOW_ASYNC_UNSAFE</st>`
    <st c="10068">to</st> `<st c="10072">false</st>` <st c="10077">using the</st>
    `<st c="10088">os</st>` <st c="10090">module:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="10147">Failure to set this setting to</st> `<st c="10179">true</st>`
    <st c="10183">will cause this</st> <st c="10200">runtime exception:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="10343">Lastly, import</st> `<st c="10359">get_wsgi_application</st>`
    <st c="10379">from the</st> `<st c="10389">django.core.wsgi</st>` <st c="10405">module
    and register it to</st> `<st c="10432">DispatcherMiddleware</st>`<st c="10452">.
    For Django web applications, import</st> `<st c="10490">StaticFilesHandler</st>`
    <st c="10508">from the</st> `<st c="10518">django.contrib.staticfiles.handlers</st>`
    <st c="10553">module and wrap the</st> `<st c="10574">get_wsgi_application()</st>`<st
    c="10596">’s returned object to access the static web files (e.g., CSS,</st> <st
    c="10659">JS, images):</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="10995">Now, it is time to mount the main Flask app to the Tornado server
    after mounting the FastAPI, Django, and</st> <st c="11102">Flask sub-applications.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11125">Putting it all together with Tornado</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="11162">Although it is ideal to use Gunicorn to run Flask applications
    in the production server, sometimes using the non-blocking Tornado server is a
    perfect choice for a Flask project that focuses more on event-driven transactions,
    WebSocket, and</st> **<st c="11403">Server-Sent Events</st>** <st c="11421">(</st>**<st
    c="11423">SSE</st>**<st c="11426">).</st> <st c="11430">For this chapter, our</st>
    <st c="11452">design is to mount the main Flask application, which implements
    the core</st> *<st c="11525">Online Library Management System’s</st>* <st c="11559">transactions,
    to a Tornado application.</st> <st c="11600">By the way, Tornado is a Python framework
    and asynchronous networking library whose strength is more on event-driven, non-blocking,
    and long polling transactions that require a long-live connection to a user.</st>
    <st c="11809">It has a bundled non-blocking HTTP server,</st> <st c="11852">unlike
    FastAPI.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11867">To run a</st> <st c="11876">compatible WSGI application on Tornado’s
    HTTP server, it</st> <st c="11934">has a</st> `<st c="11940">WSGIContainer</st>`
    <st c="11953">utility class that wraps a core Flask</st> `<st c="11992">app</st>`
    <st c="11995">instance and runs the application on the non-blocking or asynchronous</st>
    <st c="12066">server mode.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12078">Important note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12093">At the moment of writing this book,</st> `<st c="12130">Flask[async]</st>`
    <st c="12142">with async HTTP requests mounted on the Tornado server throws a</st>
    `<st c="12207">SynchronousOnlyOperation</st>` <st c="12231">error.</st> <st c="12239">Thus,
    this chapter focuses on the standard Flask request</st> <st c="12296">transactions
    only.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12314">The</st> <st c="12319">following</st> `<st c="12329">main.py</st>`
    <st c="12336">snippet shows the integration of our core</st> <st c="12378">Flask
    app with the</st> <st c="12398">Tornado server:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: <st c="13109">Tornado is</st> <st c="13121">not a WSGI application and is not
    thread-safe.</st> <st c="13168">It uses one</st> <st c="13180">thread to manage
    one process at a time.</st> <st c="13220">It is a framework designed for event-driven
    applications with a built-in server created for running non-blocking I/O sockets.</st>
    <st c="13346">But, it can now directly use</st> `<st c="13375">asyncio</st>` <st
    c="13382">to run our mounted applications asynchronously in replacement of</st>
    `<st c="13448">IOLoop</st>` <st c="13455">for events.</st> <st c="13467">In the
    given snippet, our Tornado and main Flask applications run on the</st> `<st c="13540">asyncio</st>`
    <st c="13547">platform using the main event loop retrieved by</st> `<st c="13596">get_event_loop()</st>`<st
    c="13612">. By the way, our complete system has a Tornado handler,</st> `<st c="13669">MainHandler</st>`<st
    c="13680">, in</st> `<st c="13685">modules_tornado</st>` <st c="13700">that renders
    a welcome message in</st> <st c="13735">JSON format.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13747">At this point, our application has become complex because of the
    mounting of different WSGI and ASGI applications, so it needs a microservice mechanism
    called</st> **<st c="13907">instrumentation</st>** <st c="13922">to</st> <st c="13926">monitor
    the low-level behavior of each mounted application and capture low-level metrics
    such as database-related logs, memory usage, and library-specific logs</st> <st
    c="14086">and issues.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14097">Implementing Flask instrumentation</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="14132">Instrumentation is a</st> <st c="14154">mechanism that generates,
    collects, and exports data about the runtime diagnostics of an application, microservice,
    or distributed setup.</st> <st c="14292">Usually, this observable data includes
    traces, logs, and metrics that can provide an understanding of the system.</st>
    <st c="14406">Among the many ways to implement instrumentation,</st> `<st c="14669">pip</st>`
    <st c="14672">command:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: <st c="14804">The following</st> <st c="14819">snippet added to the</st> `<st
    c="14840">create_app()</st>` <st c="14852">factory in the</st> `<st c="14868">__init__.py</st>`
    <st c="14879">of the main Flask application provides the</st> <st c="14923">console-based
    instrumentation:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: <st c="15793">OpenTelemetry</st> <st c="15807">requires the Flask application
    to set up the Tracing API consisting of</st> `<st c="15879">TracerProvider</st>`<st
    c="15893">,</st> `<st c="15895">Tracer</st>`<st c="15901">, and</st> `<st c="15907">Span</st>`<st
    c="15911">(s).</st> <st c="15917">The first component,</st> `<st c="15938">TracerProvider</st>`<st
    c="15952">, is the entry point of the API and the registry for creating the tracers.</st>
    <st c="16027">A tracer is responsible for creating spans.</st> <st c="16071">On
    the other hand, a span is an API that can monitor any part of</st> <st c="16136">the
    application.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16152">After instantiating</st> `<st c="16173">TracerProvider</st>`<st
    c="16187">, part of the setup to create a tracer is to</st> <st c="16232">apply</st>
    `<st c="16238">Batch</st>` **<st c="16243">SpanProcessor</st>**<st c="16257">,
    which preprocesses the spans per batch before exporting them to another system,
    tool, or backend.</st> <st c="16357">It requires a specific exporter class in
    its constructor parameter, such as</st> `<st c="16433">ConsoleSpanExporter</st>`<st
    c="16452">, which sends the span to the console.</st> <st c="16491">To complete
    the</st> `<st c="16507">TracerProvider</st>` <st c="16521">setup, add the processor
    to the</st> `<st c="16554">TracerProvider</st>` <st c="16568">object using its</st>
    `<st c="16586">add_span_processor()</st>` <st c="16606">method.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16614">Finally, import the trace API object from the</st> `<st c="16661">opentelemetry</st>`
    <st c="16674">module and invoke its</st> `<st c="16697">set_tracer_provider()</st>`
    <st c="16718">class method to set the created</st> `<st c="16751">TracerProvider</st>`
    <st c="16765">instance.</st> <st c="16776">To extract the</st> `<st c="16791">tracer</st>`
    <st c="16797">object, invoke its</st> `<st c="16817">get_tracer()</st>` <st c="16829">method
    and specify its name, such</st> <st c="16864">as</st> `<st c="16867">packt-flask-tracer</st>`<st
    c="16885">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16886">Now, import the</st> `<st c="16903">tracer</st>` <st c="16909">object
    anywhere inside the application.</st> <st c="16950">The following module script
    imports the</st> `<st c="16990">tracer</st>` <st c="16996">object to monitor the</st>
    `<st c="17019">add_login()</st>` <st c="17030">endpoint:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: <st c="17357">Invoking the</st> `<st c="17371">start_as_current_span()</st>`
    <st c="17394">method of a</st> `<st c="17407">tracer</st>` <st c="17413">object
    creates a span, a single operation within a trace.</st> <st c="17472">For larger
    systems, spans can be nested to form a trace tree for detailed monitoring.</st>
    <st c="17558">A nested trace contains a root span, which typically describes the</st>
    <st c="17625">upper-level operation, and one or more child spans for its lower-level
    operations.</st> *<st c="17708">Figure 12</st>**<st c="17717">.3</st>* <st c="17719">shows
    the console log after running the</st> `<st c="17760">add_login()</st>` <st c="17771">endpoint:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – A tracer log exported to the console](img/B19383_12_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="18272">Figure 12.3 – A tracer log exported to the console</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18322">Additionally, Jaeger, a distributed tracing</st> <st c="18367">platform,
    can visualize</st> <st c="18391">all the logs from the trace in graphical views.</st>
    <st c="18439">OpenTelemetry has an exporter class that can export the spans to
    the Jaeger platform after preprocessing.</st> <st c="18545">But first, install
    Jaeger either through its Docker image or binaries.</st> <st c="18616">In this
    chapter, we start the Jaeger server through the</st> `<st c="18672">jaeger-all-in-one.exe</st>`
    <st c="18693">command from</st> <st c="18707">its binaries.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18720">Then, install the OpenTelemetry module for Jaeger support using
    the following</st> `<st c="18799">pip</st>` <st c="18802">command:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: <st c="18853">After the installation, add the following snippet to the previous
    OpenTelemetry setup in the</st> `<st c="18947">create_app()</st>` <st c="18959">factory:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`<st c="19319">JaegerExporter</st>` <st c="19334">sends the traces to a thrift
    server running through the HTTP protocol.</st> <st c="19406">The constructor parameters
    of the exporter class are all about the server details of the thrift server.</st>
    <st c="19510">In our case,</st> `<st c="19523">agent_host_name</st>` <st c="19538">is</st>
    `<st c="19542">localhost</st>` <st c="19551">and</st> `<st c="19556">agent_port</st>`
    <st c="19566">is</st> `<st c="19570">6831</st>`<st c="19574">.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19575">Restart the Tornado</st> <st c="19595">server, run the monitored
    APIs, and open the Jaeger dashboard at</st> `<st c="19661">http://localhost:16686/</st>`
    <st c="19684">using the browser to check the traces.</st> *<st c="19724">Figure
    12</st>**<st c="19733">.4</st>* <st c="19735">shows the</st> **<st c="19746">Search</st>**
    <st c="19752">page of the Jaeger dashboard after searching</st> <st c="19798">four
    traces:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Jaeger search result for span traces](img/B19383_12_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="20346">Figure 12.4 – Jaeger search result for span traces</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20396">The left portion of Jaeger’s</st> `<st c="20515">packt-flask-service</st>`<st
    c="20534">, which gave four searches at the time of its search.</st> <st c="20588">On
    the right portion of the dashboard is the search result listing the traces produced
    by the spans that monitored the transaction performed.</st> <st c="20730">Clicking
    each row leads to trace details in a graphical format.</st> <st c="20794">On the
    other hand, the graph in the header portion</st> <st c="20845">summarizes all
    the traces at a</st> <st c="20876">specified duration.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20895">Let us now explore how to add OpenAPI 3.x documentation to the
    API endpoints of our</st> <st c="20980">Flask application.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20998">Applying OpenAPI 3.x specification with Swagger</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="21046">Aside</st> <st c="21052">from instrumentation, some</st> <st c="21079">solutions
    provide well-formatted API documentation, as in FastAPI.</st> <st c="21147">One
    of these solutions is to use</st> `<st c="21180">flask_openapi3</st>`<st c="21194">,
    which applies OpenAPI 3.x specification to implement Flask components and document
    the API endpoints with Swagger, ReDoc,</st> <st c="21318">and RapiDoc.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="21330">flask_openapi3</st>` <st c="21345">is not a library or dependency
    module of Flask but a separate framework based on the current Flask 3.x with the</st>
    `<st c="21458">pydantic</st>` <st c="21466">module to support OpenAPI documentation.</st>
    <st c="21508">It also supports</st> `<st c="21525">Flask[async]</st>` <st c="21537">components.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21549">After installing</st> `<st c="21567">flask_openapi3</st>` <st
    c="21581">using the</st> `<st c="21592">pip</st>` <st c="21595">command, replace
    the</st> `<st c="21617">Flask</st>` <st c="21622">class with</st> `<st c="21634">OpenAPI</st>`
    <st c="21641">and</st> `<st c="21646">Blueprint</st>` <st c="21655">with</st>
    `<st c="21661">APIBlueprint</st>`<st c="21673">. These are still the original
    Flask classes but with the feature of adding API documentation.</st> <st c="21768">The
    following is the</st> `<st c="21789">create_app()</st>` <st c="21801">factory</st>
    <st c="21809">method of our main Flask</st> <st c="21834">application that uses</st>
    `<st c="21857">OpenAPI</st>` <st c="21864">to create the application object with
    the added</st> <st c="21913">documentation components:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: <st c="22299">The</st> `<st c="22304">Info</st>` <st c="22308">utility class
    provides the project title of the OpenAPI documentation.</st> <st c="22380">Its
    instance is part of the constructor parameter values</st> <st c="22437">of OpenAPI.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22448">To document an API, add a summary of the endpoint, a complete
    description of the API transaction, tags, request field descriptions, and response
    details.</st> <st c="22603">The following snippet shows a simple documentation
    of the</st> `<st c="22661">list_login()</st>` <st c="22673">endpoint:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: <st c="23139">The HTTP</st> <st c="23149">method decorators of OpenAPI allow
    additional</st> <st c="23195">arguments such as a summary and tags describing
    the API endpoint.</st> <st c="23261">The</st> `<st c="23265">Tags</st>` <st c="23269">class
    is a</st> `<st c="23281">flask_openapi3</st>` <st c="23295">utility that enables
    the creation of tags for an endpoint.</st> <st c="23355">An endpoint can be associated
    with a list of tag objects.</st> <st c="23413">On the other hand, the documentation
    comment placed in the first lines of the API function becomes the complete and
    detailed description of the</st> <st c="23557">API implementation.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23576">Now, an application using the</st> `<st c="23607">flask_openapi3</st>`
    <st c="23621">framework has an additional endpoint,</st> `<st c="23660">/openapi/swagger</st>`<st
    c="23676">, which, when run on a web browser, will render a Swagger documentation,
    as illustrated in</st> *<st c="23767">Figure 12</st>**<st c="23776">.5</st>*<st
    c="23778">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – An OpenAPI/Swagger documentation in Flask](img/B19383_12_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="24388">Figure 12.5 – An OpenAPI/Swagger documentation in Flask</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24443">As long as</st> `<st c="24455">flask-openapi3</st>` <st c="24469">is
    always up to date and synchronized with the Flask releases, it is a helpful and
    feasible solution to build Flask applications with documentation implemented using
    OpenAPI/Swagger.</st> <st c="24653">The framework can provide acceptable and standard
    API</st> <st c="24707">documentation with less additional YAML or JSON configuration</st>
    <st c="24768">in</st> `<st c="24772">main.py</st>`<st c="24779">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24780">In the next section, let us discuss other ways our Flask application
    can provide services outside the Python platform, starting with</st> <st c="24914">mobile
    development.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24933">Providing REST services to a Flutter mobile application</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="24989">Flask applications can be a potential backend API service provider
    for many popular mobile platforms, such as Flutter.</st> <st c="25109">Flutter</st>
    <st c="25116">is an open source mobile toolkit created by Google to provide commercially
    accepted and natively compiled applications for mobile platforms.</st> <st c="25258">It
    can serve as a frontend framework for our</st> <st c="25303">microservice applications.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25329">To start Flutter, download the latest Flutter SDK release – in
    my case, for Windows, from</st> <st c="25419">the</st> [<st c="25424">https://docs.flutter.dev/release/archive?tab=windows</st>](https://docs.flutter.dev/release/archive?tab=windows)
    <st c="25476">download site.</st> <st c="25492">Unzip the file to your development
    directory and register</st> `<st c="25550">%FLUTTER_HOME%\bin</st>` <st c="25568">in
    the Windows</st> <st c="25584">global classpath.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25601">Afterward, download the latest Android Studio</st> <st c="25647">from</st>
    [<st c="25653">https://developer.android.com/studio</st>](https://developer.android.com/studio)<st
    c="25689">. Then, open the newly installed Android Studio and go to</st> **<st
    c="25747">Tools</st>** <st c="25752">|</st> **<st c="25755">SDK Manager</st>**
    <st c="25766">to install the</st> <st c="25782">following components:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25803">Android SDK platform, the latest</st> <st c="25837">API version</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="25848">Android SDK</st> <st c="25861">command-line tools</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="25879">Android SDK</st> <st c="25892">build tools</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="25903">Android SDK</st> <st c="25916">platform tools</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="25930">Android Emulator</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="25947">After a</st> <st c="25956">successful Android SDK update and</st>
    <st c="25990">installation of SDK components, open a terminal and perform the
    following procedures for</st> <st c="26079">Flutter diagnostics:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26099">Run the</st> `<st c="26108">flutter doctor</st>` <st c="26122">command
    on</st> <st c="26134">the terminal.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="26147">All settings and tools must be satisfied before the development.</st>
    <st c="26213">There should be no issues at this point of</st> <st c="26256">the
    installation.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="26273">Using the VS Code editor with the Flutter extension, create a
    Flutter project; it should have the project structure presented in</st> *<st c="26403">Figure
    12</st>**<st c="26412">.6</st>*<st c="26414">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Our ch12-flutter-flask project](img/B19383_12_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="26629">Figure 12.6 – Our ch12-flutter-flask project</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26673">Inside</st> `<st c="26681">/lib/olms/provider</st>`<st c="26699">,</st>
    `<st c="26701">providers.dart</st>` <st c="26715">implements the transactions
    that consume</st> <st c="26756">the HTTP</st> `<st c="26766">GET</st>` <st c="26769">and</st>
    `<st c="26774">POST</st>` <st c="26778">of our</st> <st c="26785">APIs for user
    management.</st> <st c="26812">Here are the</st> `<st c="26825">dart</st>` <st
    c="26829">codes for our</st> <st c="26844">service providers:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: <st c="27849">The given</st> `<st c="27860">addLogin()</st>` <st c="27870">consumes</st>
    <st c="27879">the</st> `<st c="27884">add_login()</st>` <st c="27895">API</st>
    <st c="27900">from our Flask</st> <st c="27915">microservice app:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: <st c="28376">The</st> `<st c="28381">Login</st>` <st c="28386">model class</st>
    <st c="28399">mentioned in the code is a</st> <st c="28426">Flutter class that
    the</st> `<st c="28449">addLogin()</st>` <st c="28459">and</st> `<st c="28464">getLogin()</st>`
    <st c="28474">provider transactions will map to the JSON records from the Flask
    API endpoints.</st> <st c="28556">The following is Flutter’s</st> `<st c="28583">Login</st>`
    <st c="28588">model class derived from the</st> `<st c="28618">ch12-microservices-interop</st>`<st
    c="28644">’s SQLAlchemy</st> <st c="28659">model layer:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: <st c="28857">Now, the given</st> `<st c="28873">getLogin()</st>` <st c="28883">retrieves
    the</st> `<st c="28898">Login</st>` <st c="28903">records in JSON format from
    our</st> `<st c="28936">list_login()</st>` <st c="28948">endpoint function.</st>
    <st c="28968">Notice that Flutter requires the</st> *<st c="29001">actual IP address</st>*
    <st c="29018">of the host server for its services to access the API</st> <st c="29073">endpoint
    resources.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29092">The</st> `<st c="29097">/lib/olms/tasks/task.dart</st>` <st c="29122">file
    implements the form widgets and the corresponding events that invoke these two
    service methods.</st> <st c="29224">The following part of the implementation shows
    the</st> `<st c="29275">Login</st>` <st c="29280">form:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: <st c="30130">In general,</st> `<st c="30143">LoginViewWidget</st>` <st c="30158">component</st>
    <st c="30168">returns a</st> `<st c="30179">Padding</st>` <st c="30186">widget
    composed of two sub-widgets.</st> <st c="30223">The preceding code renders a</st>
    <st c="30252">horizontal form of three</st> `<st c="30277">TextFormField</st>`
    <st c="30290">widgets that will accept login details from the user and an</st>
    `<st c="30351">ElevatedButton</st>` <st c="30365">that will trigger the</st> `<st
    c="30388">add_login()</st>` <st c="30399">provider transaction to invoke our Flask</st>
    `<st c="30441">/login/add</st>` <st c="30451">endpoint.</st> <st c="30462">The
    following code shows the next part of</st> `<st c="30504">LoginViewWidget</st>`
    <st c="30519">that renders the list of</st> `<st c="30545">Login</st>` <st c="30550">records
    from</st> <st c="30564">our database:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: <st c="31408">The preceding code</st> <st c="31427">renders a</st> `<st c="31438">FutureWidget</st>`
    <st c="31450">component</st> <st c="31460">composed of</st> `<st c="31473">ListView</st>`
    <st c="31481">of</st> `<st c="31485">DataColumn</st>` <st c="31495">and</st> `<st
    c="31500">DataRow</st>` <st c="31507">widgets to showcase the</st> `<st c="31532">Login</st>`
    <st c="31537">records from our Flask</st> `<st c="31561">/login/list/all</st>`
    <st c="31576">endpoint.</st> <st c="31587">It has a vertical scrollbar rendered
    by its</st> `<st c="31631">SingleChildScrollView</st>` <st c="31653">widget.</st>
    *<st c="31661">Figure 12</st>**<st c="31670">.7</st>* <st c="31672">shows the
    resulting</st> `<st c="31693">LoginViewWidget</st>` <st c="31708">form after running
    our</st> `<st c="31732">ch12-flask-flutter</st>` <st c="31750">application using
    the</st> `<st c="31773">flutter run</st>` <st c="31784">command inside the</st>
    `<st c="31804">/</st>``<st c="31805">library_app</st>` <st c="31816">directory.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – A Flutter form for login transactions](img/B19383_12_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="31921">Figure 12.7 – A Flutter form for login transactions</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31972">In addition to</st> <st c="31987">mobile development, Flask APIs</st>
    <st c="32019">can also provide data services to popular frontend frameworks, such
    as React.</st> <st c="32097">Let us see how in the</st> <st c="32119">next section.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32132">Consuming REST endpoints with a React application</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="32182">React</st> <st c="32188">is a popular frontend server-side JavaScript
    library used to build scalable user interfaces for websites, mostly</st> **<st
    c="32302">single-page applications</st>** <st c="32326">(</st>**<st c="32328">SPAs</st>**<st
    c="32332">).</st> <st c="32336">It is a popular library in rendering pages that</st>
    <st c="32383">changes its state without reloading</st> <st c="32420">the page.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32429">After creating a</st> <st c="32447">React project using the</st>
    `<st c="32471">create-react-app</st>` <st c="32487">command, our</st> `<st c="32501">ch12-react-flask</st>`
    <st c="32517">application has implemented the following functional component to
    build the form page and the table listing all the faculty borrowers of the</st>
    *<st c="32659">Online Library</st>* *<st c="32674">Management System</st>*<st
    c="32691">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: <st c="32969">The given</st> `<st c="32980">useState()</st>` <st c="32990">hook
    methods define the state variables that the form components will use to capture
    form data before submitting the details to the</st> `<st c="33123">add_faculty_borrower()</st>`
    <st c="33145">API endpoint of our</st> <st c="33166">FastAPI sub-application:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: <st c="34072">The</st> `<st c="34077">addRecord()</st>` <st c="34088">event</st>
    <st c="34095">method forms the JSON data from the state variables before submitting
    it to the</st> `<st c="34175">add_faculty_borrower()</st>` <st c="34197">API endpoint.</st>
    <st c="34212">Likewise, it retrieves all the faculty borrowers from the microservice
    through the</st> `<st c="34295">list_all_faculty_borrowers()</st>` <st c="34323">endpoint
    of the same</st> <st c="34345">FastAPI sub-application:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: <st c="35047">The</st> `<st c="35052">records.map()</st>` <st c="35065">function
    builds the table of records after adding a new faculty borrower record to the
    database.</st> `<st c="35163">addRecord()</st>`<st c="35174">, with the help of
    the</st> `<st c="35197">useEffect()</st>` <st c="35208">hook method, captures
    all the records from the</st> `<st c="35256">list_all_faculty_borrowers()</st>`
    <st c="35284">API and stores the list of JSON-formatted data to the state</st>
    <st c="35344">variable,</st> `<st c="35355">records</st>`<st c="35362">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35363">Aside from building service providers for other platforms, Flask
    can also build GraphQL applications for easy CRUD operations.</st> <st c="35491">Let’s
    learn about it in the</st> <st c="35519">next discussion.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35535">Building a GraphQL application</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="35566">GraphQL is</st> <st c="35578">a mechanism that provides a platform-agnostic
    CRUD transaction across the applications without specifying the actual database
    connectivity details and database dialects.</st> <st c="35748">This mechanism
    is model-centric or data-centric and focuses on the data the users want to fetch
    through the backend</st> <st c="35864">API implementations.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35884">Our microservice designed</st> <st c="35910">the Flask sub-application
    to be a GraphQL application with the following HTTP GET endpoint that creates
    the GraphQL</st> <st c="36027">UI explorer:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: <st c="36319">Our solution</st> <st c="36333">used the</st> `<st c="36342">Ariadne</st>`
    <st c="36349">module because it is updated and can integrate with Flask 3.x components.</st>
    *<st c="36424">Figure 12</st>**<st c="36433">.8</st>* <st c="36435">shows the
    actual GraphQL Explorer after accessing the given</st> `<st c="36496">/</st>``<st
    c="36497">flask/graphql</st>` <st c="36510">endpoint.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – The Ariadne GraphQL Explorer](img/B19383_12_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="36641">Figure 12.8 – The Ariadne GraphQL Explorer</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36683">Next, build the crucial GraphQL schema configuration, the</st>
    `<st c="36742">schema.graphql</st>` <st c="36756">file, which creates all the
    GraphQL model classes derived from the ORM models, request data, and response
    objects of the supposed API endpoints.</st> <st c="36902">The following is a snapshot
    of the</st> `<st c="36937">schema.graphql</st>` <st c="36951">file used by our</st>
    <st c="36969">Flask sub-application:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '# The GraphQL operations'
  prefs: []
  type: TYPE_NORMAL
- en: type Query {
  prefs: []
  type: TYPE_NORMAL
- en: 'listAllComplainants: <st c="38504">ComplainantListResult</st>!'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'listAllComplaints: <st c="38546">ComplaintListResult</st>!'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'listAllCategories: <st c="38586">CategoryListResult</st>!'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'listAllComplaintTypes: <st c="38629">ComplaintTypeListResult</st>!'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: type Mutation {
  prefs: []
  type: TYPE_NORMAL
- en: 'createCategory(<st c="38687">name: String</st>!): CategoryInsertResult! createComplaintType(<st
    c="38746">name: String</st>!): ComplaintTypeInsertResult! createComplainant(<st
    c="38808">input: ComplainantInput</st>!): ComplainantInsertResult! createComplaint(<st
    c="38877">input: ComplaintInput</st>!): ComplaintInsertResult! }'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '# These are the input types <st c="39764">input</st> ComplainantInput {'
  prefs: []
  type: TYPE_NORMAL
- en: 'firstname: String! lastname: String! middlename: String! email: String! date_registered:
    String! } <st c="39888">input</st> ComplaintInput {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ticketId: String! complainantId: Int! catid: Int! ctype: Int! }'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '# These are the result types'
  prefs: []
  type: TYPE_NORMAL
- en: type ComplainantInsertResult {
  prefs: []
  type: TYPE_NORMAL
- en: 'success: Boolean! errors: [String]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'model: Complainant! }'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: type ComplaintInsertResult {
  prefs: []
  type: TYPE_NORMAL
- en: 'success: Boolean! errors: [String]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'model: Complaint! }'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: … … … … … …
  prefs: []
  type: TYPE_NORMAL
- en: type ComplainantListResult {
  prefs: []
  type: TYPE_NORMAL
- en: 'success: Boolean! errors: [String]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'complainants: [Complainant]! }'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: type ComplaintListResult {
  prefs: []
  type: TYPE_NORMAL
- en: 'success: Boolean! errors: [String]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'complaints: [Complaint]! }'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: from ariadne import QueryType, MutationType
  prefs: []
  type: TYPE_NORMAL
- en: from typing import List, Any, Dict
  prefs: []
  type: TYPE_NORMAL
- en: from modules_sub_flask.models.db import Complainant
  prefs: []
  type: TYPE_NORMAL
- en: from sqlalchemy.orm import Session <st c="41377">query = QueryType()</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="41396">mutation = MutationType()</st> class ComplainantResolver:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, sess:Session):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: self.sess = sess <st c="41501">@mutation.field('complainant')</st>
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="41531">def insert_complainant(self, obj, info, input) -> bool:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41587">try:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41592">complainant = Complainant(**input)</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41627">self.sess.add(complainant)</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41654">self.sess.commit()</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41673">payload = {</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="41685">"success": True,</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="41702">"model": complainant</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41723">}</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41725">except Exception as e:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41748">print(e)</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41757">payload = {</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="41769">"success": False,</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="41787">"errors": [f"Complainant … not found"]</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41826">}</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41828">return payload</st> … … … … … …
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'def select_all_complainant(self, obj, info) -> List[Any]:'
  prefs: []
  type: TYPE_NORMAL
- en: complainants = self.sess.query(Complainant).all()
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'try:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: records = [todo.to_json() for todo in complainants]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'print(records) <st c="42318">payload = {</st><st c="42329">"success": True,</st><st
    c="42346">"complainants": records</st><st c="42370">}</st> except Exception as
    e:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'print(e) <st c="42405">payload = {</st><st c="42416">"success": False,</st><st
    c="42434">"errors": [str("Empty records")]</st><st c="42467">}</st> … … … … …
    …'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: … … … … … …
  prefs: []
  type: TYPE_NORMAL
- en: from ariadne import load_schema_from_path, make_executable_schema, \
  prefs: []
  type: TYPE_NORMAL
- en: graphql_sync, snake_case_fallback_resolvers, ObjectType
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from ariadne.explorer import ExplorerGraphiQL <st c="43318">from modules_sub_flask.resolvers.complainant_repo
    import ComplainantResolver</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43394">from modules_sub_flask.resolvers.complaint_repo import ComplaintResolver</st>
    from modules_sub_flask.models.config import db_session
  prefs: []
  type: TYPE_NORMAL
- en: … … … … … … <st c="43535">complainant_repo = ComplainantResolver(db_session)</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43585">category_repo = CategoryResolver(db_session)</st> … … … … … …
    <st c="43642">query = ObjectType("Query")</st> query.set_field("listAllComplainants",
    complainant_repo.select_all_complainant)
  prefs: []
  type: TYPE_NORMAL
- en: query.set_field("listAllComplaints", complaint_repo.select_all_complaint)
  prefs: []
  type: TYPE_NORMAL
- en: … … … … … … <st c="43836">mutation = ObjectType("Mutation")</st> mutation.set_field("createComplainant",
    complainant_repo.insert_complainant)
  prefs: []
  type: TYPE_NORMAL
- en: mutation.set_field("createComplaint", complaint_repo.insert_complaint)
  prefs: []
  type: TYPE_NORMAL
- en: … … … … … … <st c="44030">type_defs = load_schema_from_path("./schema.graphql")</st>
    schema = make_executable_schema(
  prefs: []
  type: TYPE_NORMAL
- en: type_defs, <st c="44128">query</st>, <st c="44135">mutation</st>,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: … … … … … …
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
