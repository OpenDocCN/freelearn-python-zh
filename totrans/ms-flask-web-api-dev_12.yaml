- en: <st c="0">12</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">12</st>
- en: <st c="3">Integrating Flask with Other Tools and Frameworks</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3">将 Flask 与其他工具和框架集成</st>
- en: <st c="53">Flask’s flexibility, seamlessness, and pluggability provide ease
    for building various applications, from simple form-based counseling systems to
    Docker-based applications.</st> *<st c="226">Chapters 1</st>* <st c="236">to</st>
    *<st c="240">10</st>* <st c="242">have showcased its minimalistic but powerful
    framework with several extension modules and libraries providing support, fast
    solutions, and clean coding for web and</st> <st c="407">API applications.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53">Flask 的灵活性、无缝性和可插拔性为构建各种应用程序提供了便利，从简单的基于表单的咨询系统到基于 Docker 的应用程序。</st>
    *<st c="226">第 1</st> * <st c="236">章到</st> * <st c="240">第 10</st> * <st c="242">章展示了其简约但强大的框架，以及提供支持、快速解决方案和清洁编码的几个扩展模块和库，适用于
    Web 和</st> <st c="407">API 应用程序。</st>
- en: <st c="424">Although Flask is not favored to handle large enterprise solutions
    like Django can, it can serve as a middleware or component to many enterprise-grade
    systems and can even be a good solution for building microservices.</st> <st c="644">The
    superb flexibility of Flask makes it an ideal inclusion to the recipes of many
    software infrastructures of many</st> <st c="760">business processes.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="424">尽管 Flask 不像 Django 那样适合处理大型企业解决方案，但它可以作为许多企业级系统的中间件或组件，甚至可以成为构建微服务的良好解决方案。</st>
    <st c="644">Flask 的卓越灵活性使其成为许多软件基础设施和许多</st> <st c="760">业务流程的理想选择。</st>
- en: <st c="779">To give a clear picture as to where to place Flask in the list of
    popular Python frameworks, the goal of this last chapter is to highlight the feasibility
    of having a backend Flask implementation for mobile and frontend applications,
    a solution to a microservice architecture, and an implementation to many modern
    requirements such as creating and running queries and CRUD transactions</st> <st
    c="1166">through GraphQL.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="779">为了清楚地说明 Flask 在流行 Python 框架列表中的位置，本章的目标是强调为移动和前端应用提供后端 Flask 实现的可行性，为微服务架构提供解决方案，以及通过
    GraphQL 实现创建和运行查询以及 CRUD 事务的实施方案</st> <st c="1166">通过 GraphQL。</st>
- en: <st c="1182">These are the topics covered in</st> <st c="1215">this chapter:</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1182">本章涵盖了以下主题：</st> <st c="1215">本章内容：</st>
- en: <st c="1228">Implementing microservice applications involving FastAPI, Django,</st>
    <st c="1295">and Tornado</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1228">实现涉及 FastAPI、Django 和 Tornado 的微服务应用</st>
- en: <st c="1306">Implementing</st> <st c="1320">Flask instrumentation</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1306">实现</st> <st c="1320">Flask 仪表盘</st>
- en: <st c="1341">Applying OpenAPI 3.x specification</st> <st c="1377">with Swagger</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1341">使用 Swagger 应用 OpenAPI 3.x 规范</st> <st c="1377">与 Swagger</st>
- en: <st c="1389">Providing REST services to a Flutter</st> <st c="1427">mobile application</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1389">为 Flutter</st> <st c="1427">移动应用程序</st> 提供REST服务
- en: <st c="1445">Consuming REST endpoints with a</st> <st c="1478">React application</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1445">使用 React 应用程序消费 REST 端点</st> <st c="1478">React 应用程序</st>
- en: <st c="1495">Building a</st> <st c="1507">GraphQL application</st>
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1495">构建一个</st> <st c="1507">GraphQL 应用程序</st>
- en: <st c="1526">Technical requirements</st>
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1526">技术要求</st>
- en: <st c="1549">This chapter uses an</st> *<st c="1571">Online Library Management
    System</st>* <st c="1603">to expound on building a microservice application that
    incorporates</st> <st c="1672">FastAPI, Django, and Flask sub-applications with
    Tornado as the facade application and the server.</st> <st c="1771">The sub-applications
    are mounted using different URL prefixes.</st> <st c="1834">Here are the services
    offered by each of the</st> <st c="1879">mounted applications:</st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1549">本章使用一个</st> *<st c="1571">在线图书馆管理系统</st>* <st c="1603">来阐述构建一个微服务应用，该应用集成了</st>
    <st c="1672">FastAPI、Django 和 Flask 子应用程序，以 Tornado 作为前端应用程序和服务器。</st> <st c="1771">子应用程序使用不同的
    URL 前缀进行挂载。</st> <st c="1834">以下是挂载的每个应用程序提供的服务：</st>
- en: <st c="1900">Django sub-module – managing student</st> <st c="1938">book borrowers</st>
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1900">Django 子模块 – 管理学生</st> <st c="1938">图书借阅者</st>
- en: <st c="1952">Flask sub-module – managing faculty</st> <st c="1989">book browsers</st>
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1952">Flask 子模块 – 管理教师</st> <st c="1989">图书浏览器</st>
- en: <st c="2002">FastAPI sub-module – managing feedback and complaints</st> <st
    c="2057">from borrowers</st>
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="2002">FastAPI 子模块 – 管理借阅者的反馈和投诉</st> <st c="2057">借阅者</st>
- en: <st c="2071">Flask main application – the</st> <st c="2101">core transactions</st>
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="2071">Flask 主应用程序 – 核心事务</st> <st c="2101">核心事务</st>
- en: <st c="2118">Tornado application – the</st> <st c="2145">facade application</st>
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="2118">Tornado 应用程序 – 前端应用程序</st>
- en: '*<st c="2163">Figure 12</st>**<st c="2173">.1</st>* <st c="2175">shows the
    flow of transactions of these</st> <st c="2216">mounted applications.</st>'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="2163">图12</st>**<st c="2173">.1</st>* 展示了这些已安装应用程序的交易流程。'
- en: '![Figure 12.1 – Combined Django, Flask, FastAPI, and Tornado applications](img/B19383_12_001.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 结合Django、Flask、FastAPI和Tornado的应用程序](img/B19383_12_001.jpg)'
- en: <st c="2346">Figure 12.1 – Combined Django, Flask, FastAPI, and Tornado applications</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2346">图12.1 – 结合Django、Flask、FastAPI和Tornado的应用程序</st>
- en: <st c="2417">The sub-modules</st> <st c="2433">use</st> **<st c="2438">SQLAlchemy</st>**
    <st c="2448">as the ORM, while the Flask main application uses the</st> <st c="2502">standard</st>
    **<st c="2512">Peewee</st>** <st c="2518">ORM.</st> <st c="2524">All the projects
    of this chapter are uploaded</st> <st c="2570">at</st> [<st c="2573">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch12</st>](https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch12)<st
    c="2654">.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2417">子模块</st> <st c="2433">使用**<st c="2438">SQLAlchemy</st>** <st c="2448">作为ORM，而Flask主应用程序使用的是</st>
    <st c="2502">标准</st> **<st c="2512">Peewee</st>** <st c="2518">ORM。</st> <st c="2524">本章的所有项目都已上传至</st>
    [<st c="2573">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch12</st>](https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch12)<st
    c="2654">。</st>
- en: <st c="2655">Implementing microservice applications involving FastAPI, Django,
    and Tornado</st>
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2655">实现涉及FastAPI、Django和Tornado的微服务应用程序</st>
- en: <st c="2733">Flask 3.x provides a</st> `<st c="2755">DispatcherMiddleware</st>`
    <st c="2775">class from</st> *<st c="2787">Werkzeug</st>* <st c="2795">that combines
    isolated and</st> <st c="2823">valid WSGI-based applications to form a complete
    and larger system.</st> <st c="2891">These combined applications can be all Flask
    or different WSGI-based applications such as Django, each with a unique URL prefix.</st>
    *<st c="3020">Figure 12</st>**<st c="3029">.2</st>* <st c="3031">shows the directory
    structure of our</st> <st c="3069">combined projects:</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2733">Flask 3.x提供了一个来自</st> *<st c="2787">Werkzeug</st>* <st c="2795">的</st>
    `<st c="2755">DispatcherMiddleware</st>` <st c="2775">类，它将隔离的和有效的基于WSGI的应用程序组合成一个完整且更大的系统。</st>
    <st c="2891">这些组合应用程序可以是所有Flask或不同的基于WSGI的应用程序，如Django，每个都有独特的URL前缀。</st> *<st
    c="3020">图12</st>**<st c="3029">.2</st>* <st c="3031">展示了我们</st> <st c="3069">组合项目</st>
    的目录结构：
- en: '![Figure 12.2 – Django, FastAPI, Flask, and Tornado in one project structure](img/B19383_12_002.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – Django、FastAPI、Flask和Tornado在一个项目结构中](img/B19383_12_002.jpg)'
- en: <st c="3313">Figure 12.2 – Django, FastAPI, Flask, and Tornado in one project
    structure</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3313">图12.2 – Django、FastAPI、Flask和Tornado在一个项目结构中</st>
- en: <st c="3387">All views, repositories, services, models, and configuration files
    of the main Flask application are in the</st> `<st c="3496">modules</st>` <st
    c="3503">folder.</st> <st c="3512">On the other hand, all the application files
    of the FastAPI app are in the</st> `<st c="3587">modules_fastapi</st>` <st c="3602">folder,
    all components of the Django app are in the</st> `<st c="3655">modules_django</st>`
    <st c="3669">folder, all Tornado API handlers are in</st> `<st c="3710">modules_tornado</st>`<st
    c="3725">, and all GraphQL components are in the</st> `<st c="3765">modules_sub_flask</st>`
    <st c="3782">directory.</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3387">主Flask应用程序的所有视图、存储库、服务、模型和配置文件都在</st> `<st c="3496">modules</st>`
    <st c="3503">文件夹中。</st> <st c="3512">另一方面，FastAPI应用程序的所有应用程序文件都在</st> `<st c="3587">modules_fastapi</st>`
    <st c="3602">文件夹中，Django应用程序的所有组件都在</st> `<st c="3655">modules_django</st>` <st
    c="3669">文件夹中，所有Tornado API处理程序都在</st> `<st c="3710">modules_tornado</st>`<st
    c="3725">，所有GraphQL组件都在</st> `<st c="3765">modules_sub_flask</st>` <st c="3782">目录中。</st>
- en: <st c="3793">When it</st> <st c="3802">comes to their respective module scripts,
    the FastAPI</st> `<st c="3856">app</st>` <st c="3859">instance is in</st> `<st
    c="3875">main_fastapi.py</st>`<st c="3890">, the Flask sub-module’s</st> `<st
    c="3915">app</st>` <st c="3918">instance is in</st> `<st c="3934">main_sub_flask.py</st>`<st
    c="3951">, and the Flask main module’s</st> `<st c="3981">app</st>` <st c="3984">instance
    together with the Tornado server is</st> <st c="4030">in</st> `<st c="4033">main.py</st>`<st
    c="4040">.</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3793">当涉及到它们各自的模块脚本时，FastAPI的<st c="3856">app</st> <st c="3859">实例位于</st>
    `<st c="3875">main_fastapi.py</st>`<st c="3890">，Flask子模块的<st c="3915">app</st>
    <st c="3918">实例位于</st> `<st c="3934">main_sub_flask.py</st>`<st c="3951">，而Flask主模块的<st
    c="3981">app</st> <st c="3984">实例以及Tornado服务器位于</st> `<st c="4033">main.py</st>`<st
    c="4040">。</st>
- en: <st c="4041">Now, let us discuss how all these sub-applications can run together
    using one</st> <st c="4120">Tornado server.</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4041">现在，让我们讨论如何使用一个</st> <st c="4120">Tornado 服务器</st> <st c="4120">来运行所有这些子应用程序。</st>
- en: <st c="4135">Adding the Flask sub-application</st>
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Flask 子应用程序
- en: '`<st c="4168">DispatcherMiddleware</st>` <st c="4189">requires</st> <st c="4198">a
    Flask</st> `<st c="4207">app</st>` <st c="4210">instance to its first parameter
    and a dictionary containing the mounts of sub-applications, where the</st> *<st
    c="4313">key</st>* <st c="4316">is the URL pattern mapped to their corresponding
    WSGI</st> `<st c="4371">app</st>` <st c="4374">instance.</st> <st c="4385">Mounting
    Flask sub-applications to a main Flask application is straightforward.</st> <st
    c="4465">The following snippets show how to mount the</st> `<st c="4510">flask_sub_app</st>`
    <st c="4523">instance of the Flask sub-application to the core Flask</st> `<st
    c="4580">app</st>` <st c="4583">instance:</st>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="4168">DispatcherMiddleware</st>` <st c="4189">需要</st> <st c="4198">一个
    Flask</st> `<st c="4207">app</st>` <st c="4210">实例作为其第一个参数，以及一个包含子应用程序挂载点的字典，其中</st>
    *<st c="4313">键</st>* <st c="4316">是映射到相应 WSGI</st> `<st c="4371">app</st>` <st
    c="4374">实例的 URL 模式。</st> <st c="4385">将 Flask 子应用程序挂载到主 Flask 应用程序是直接的。</st>
    <st c="4465">以下代码片段展示了如何将</st> `<st c="4510">flask_sub_app</st>` <st c="4523">实例的
    Flask 子应用程序挂载到核心 Flask</st> `<st c="4580">app</st>` <st c="4583">实例：</st>'
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="5112">The Flask sub-application</st> <st c="5138">must have its dedicated
    module script (e.g.,</st> `<st c="5184">main_flask_sub.py</st>`<st c="5201">)
    for its</st> `<st c="5212">flask_sub_app</st>` <st c="5225">instantiation.</st>
    `<st c="5241">main.py</st>` <st c="5248">must import the</st> `<st c="5265">flask_sub_app</st>`
    <st c="5278">instance from a dedicated module rather than creating it in</st>
    `<st c="5339">main.py</st>` <st c="5346">for traceability, easy debugging, and
    code-clean reasons.</st> <st c="5405">Combining Flask apps to form a larger unit
    does not need additional configurations, unlike adding a FastAPI application to
    the main context.</st> <st c="5546">How do we register FastAPI applications</st>
    <st c="5586">to</st> `<st c="5589">DispatcherMiddleware</st>`<st c="5609">?</st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5112">Flask 子应用程序</st> <st c="5138">必须有一个为其</st> `<st c="5212">flask_sub_app</st>`
    <st c="5225">实例化</st> <st c="5212">专用的模块脚本（例如，</st> `<st c="5184">main_flask_sub.py</st>`<st
    c="5201">）。</st> `<st c="5241">main.py</st>` <st c="5248">必须从专用模块导入</st> `<st
    c="5265">flask_sub_app</st>` <st c="5278">实例，而不是在</st> `<st c="5339">main.py</st>`
    <st c="5346">中创建它，以便于追踪、易于调试和代码整洁。</st> <st c="5405">将 Flask 应用程序组合成更大的单元不需要额外的配置，这与向主上下文添加
    FastAPI 应用程序不同。</st> <st c="5546">我们如何将 FastAPI 应用程序注册到</st> `<st c="5589">DispatcherMiddleware</st>`<st
    c="5609">中呢？</st>
- en: <st c="5610">Adding the FastAPI sub-application</st>
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 FastAPI 子应用程序
- en: <st c="5644">Not all ASGI-based applications are</st> <st c="5681">compatible
    with Flask’s context and can be part of the</st> `<st c="5736">DispatcherMiddleware</st>`
    <st c="5756">mounts.</st> <st c="5765">For FastAPI, the workaround is to convert
    the</st> `<st c="5811">app</st>` <st c="5814">instance to WSGI at runtime using</st>
    `<st c="5849">ASGIMiddleware</st>` <st c="5863">from the</st> `<st c="5873">a2wsgi</st>`
    <st c="5879">module.</st> <st c="5888">To utilize the ASGI-to-WSGI converter,
    first install</st> `<st c="5941">a2wsgi</st>` <st c="5947">using the following</st>
    `<st c="5968">pip</st>` <st c="5971">command:</st>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5644">并非所有基于 ASGI 的应用程序都与 Flask 的上下文兼容，并且可以成为</st> `<st c="5736">DispatcherMiddleware</st>`
    <st c="5756">挂载点的一部分。</st> <st c="5765">对于 FastAPI，解决方案是在运行时使用来自</st> `<st c="5873">a2wsgi</st>`
    <st c="5879">模块的</st> `<st c="5849">ASGIMiddleware</st>` <st c="5863">将</st> `<st
    c="5811">app</st>` <st c="5814">实例转换为 WSGI。</st> <st c="5888">要使用 ASGI 到 WSGI
    转换器，首先使用以下</st> `<st c="5968">pip</st>` <st c="5971">命令安装</st> `<st c="5941">a2wsgi</st>`
    <st c="5947">：</st>
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`<st c="5999">ASGIMiddleware</st>` <st c="6014">does not depend on many external
    modules, so the conversion is straightforward from its built-in mechanisms.</st>
    <st c="6124">It will not consume more memory for its conversion.</st> <st c="6176">But,
    if the FastAPI application has several background tasks to perform, the utility
    class has a constructor parameter,</st> `<st c="6296">wait_time</st>`<st c="6305">,
    to set an allowable time duration for every background task to finish running
    before finishing a request.</st> <st c="6413">Moreover, its constructor has a</st>
    `<st c="6445">loop</st>` <st c="6449">parameter to allow setting another event
    loop in case the core platform needs a different type of event loop.</st> <st
    c="6560">Now, the following</st> `<st c="6579">main.py</st>` <st c="6586">snippet
    shows how to add our FastAPI</st> `<st c="6624">app</st>` <st c="6627">instance
    to the</st> <st c="6644">mounted applications:</st>'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="5999">ASGIMiddleware</st>` <st c="6014">不依赖于许多外部模块，因此从其内置机制转换是直接的。</st>
    <st c="6124">它不会因为转换而消耗更多内存。</st> <st c="6176">但是，如果 FastAPI 应用程序有多个后台任务要执行，实用类有一个构造函数参数，</st>
    `<st c="6296">wait_time</st>`<st c="6305">，用于设置每个后台任务在请求完成之前允许运行的时间长度。</st> <st
    c="6413">此外，它的构造函数有一个</st> `<st c="6445">loop</st>` <st c="6449">参数，允许设置另一个事件循环，以防核心平台需要不同类型的事件循环。</st>
    <st c="6560">现在，以下</st> `<st c="6579">main.py</st>` <st c="6586">代码片段显示了如何将我们的
    FastAPI</st> `<st c="6624">app</st>` <st c="6627">实例添加到</st> <st c="6644">挂载的应用程序：</st>'
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="7225">The</st> `<st c="7230">a2wsgi</st>` <st c="7236">module</st> <st
    c="7244">works perfectly with FastAPI applications.</st> <st c="7287">Not all
    ASGI-based applications can undergo seamless conversions with</st> `<st c="7357">a2wsgi</st>`
    <st c="7363">like</st> <st c="7369">FastAPI apps.</st>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7225">`a2wsgi`</st> <st c="7236">模块</st> <st c="7244">与 FastAPI 应用程序配合得很好。</st>
    <st c="7287">并非所有基于 ASGI 的应用程序都可以像 FastAPI 应用程序一样与</st> `<st c="7357">a2wsgi</st>`
    <st c="7363">无缝转换。</st>
- en: <st c="7382">Let us now add our Django sub-module to our</st> <st c="7427">mounted
    applications.</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7382">现在让我们将我们的 Django 子模块添加到我们的</st> <st c="7427">挂载的应用程序。</st>
- en: <st c="7448">Adding the Django sub-application</st>
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="7448">添加 Django 子应用程序</st>
- en: <st c="7482">Django</st> <st c="7489">is a pure WSGI framework but can run on
    ASGI servers with additional configurations.</st> <st c="7575">Unlike in FastAPI,
    adding a Django application to the mounts requires several steps, which include
    the</st> <st c="7678">following procedures in the</st> `<st c="7706">main.py</st>`
    <st c="7713">module and Django</st> <st c="7732">admin’s</st> `<st c="7740">settings.py</st>`<st
    c="7751">:</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7482">Django</st> <st c="7489">是一个纯 WSGI 框架，但可以通过额外的配置在 ASGI 服务器上运行。</st>
    <st c="7575">与 FastAPI 不同，将 Django 应用程序添加到挂载需要几个步骤，包括在</st> <st c="7706">main.py</st>
    <st c="7713">模块和 Django</st> <st c="7732">管理员的</st> `<st c="7740">settings.py</st>`<st
    c="7751">中的以下程序：</st>
- en: <st c="7753">Since</st> `<st c="7759">module_django</st>` <st c="7772">is not
    the main project folder, import the</st> `<st c="7816">os</st>` <st c="7818">module
    and set the default value of the</st> `<st c="7859">DJANGO_SETTINGS_MODULE</st>`
    <st c="7881">environment variable</st> <st c="7903">to</st> `<st c="7906">modules_django.modules_django.settings</st>`<st
    c="7944">:</st>
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="7753">由于</st> `<st c="7759">module_django</st>` <st c="7772">不是主项目文件夹，导入</st>
    `<st c="7816">os</st>` <st c="7818">模块并将</st> `<st c="7859">DJANGO_SETTINGS_MODULE</st>`
    <st c="7881">环境变量</st> <st c="7903">设置为</st> `<st c="7906">modules_django.modules_django.settings</st>`<st
    c="7944">：</st>
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="8036">This setting defines the location of</st> `<st c="8074">settings.py</st>`
    <st c="8085">of the Django admin folder.</st> <st c="8114">Failure to adjust this
    setting will lead to the following</st> <st c="8172">runtime error:</st>
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="8036">此设置定义了 Django 管理文件夹中</st> `<st c="8074">settings.py</st>` <st c="8085">的位置。</st>
    <st c="8114">未能调整此设置将导致以下</st> <st c="8172">运行时错误：</st>
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="8556">Registering a Django application to the</st> `<st c="8597">INSTALLED_APPS</st>`
    <st c="8611">settings must include the Django</st> <st c="8645">project name:</st>
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="8556">将 Django 应用程序注册到</st> `<st c="8597">INSTALLED_APPS</st>` <st c="8611">设置中必须包含
    Django</st> <st c="8645">项目名称：</st>
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="8896">Also, include the Django project folder in defining the Django
    application object</st> <st c="8978">in</st> `<st c="8981">settings.py</st>`<st
    c="8992">:</st>
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="8896">此外，在定义 Django 应用程序对象时，包括 Django 项目文件夹</st> <st c="8978">在</st>
    `<st c="8981">settings.py</st>`<st c="8992">中：</st>
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="9317">(views.py)</st> from rest_framework.response import Response
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="9317">(views.py)</st> from rest_framework.response import Response
- en: from rest_framework.decorators import api_view
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: from rest_framework.decorators import api_view
- en: from <st c="9426">modules_django</st>.olms.serializer import BorrowedHistSerializer,
    StudentBorrowerSerializer
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从 `<st c="9426">modules_django</st>.olms.serializer` 导入 BorrowedHistSerializer,
    StudentBorrowerSerializer
- en: from <st c="9519">modules_django</st>.olms.models import StudentBorrower, BorrowedHist
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从 `<st c="9519">modules_django</st>.olms.models` 导入 StudentBorrower, BorrowedHist
- en: '@api_view([''GET''])'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@api_view([''GET''])'
- en: 'def getData(request):'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def getData(request):'
- en: app = StudentBorrower.objects.all()
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: app = StudentBorrower.objects.all()
- en: serializer = StudentBorrowerSerializer(app, many=True)
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: serializer = StudentBorrowerSerializer(app, many=True)
- en: return Response(serializer.data)
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return Response(serializer.data)
- en: '@api_view([''POST''])'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@api_view([''POST''])'
- en: 'def postData(request):'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def postData(request):'
- en: serializer = StudentBorrowerSerializer(data=request.data)
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: serializer = StudentBorrowerSerializer(data=request.data)
- en: 'if serializer.is_valid():'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if serializer.is_valid():'
- en: serializer.save()
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: serializer.save()
- en: return Response(serializer.data)
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return Response(serializer.data)
- en: 'else:'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'else:'
- en: return Response({"message:error"})
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return Response({"message:error"})
- en: '[PRE7]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="9966">Since we are</st> <st c="9980">mounting our Django application
    as a WSGI sub-application, set</st> `<st c="10043">DJANGO_ALLOW_ASYNC_UNSAFE</st>`
    <st c="10068">to</st> `<st c="10072">false</st>` <st c="10077">using the</st>
    `<st c="10088">os</st>` <st c="10090">module:</st>
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在将 Django 应用程序作为 WSGI 子应用程序进行挂载，请使用 `<st c="10088">os</st>` <st c="10090">模块将
    `<st c="10043">DJANGO_ALLOW_ASYNC_UNSAFE</st>` <st c="10068">设置为`<st c="10072">false</st>`
    <st c="10077">：</st>
- en: '[PRE8]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="10147">Failure to set this setting to</st> `<st c="10179">true</st>`
    <st c="10183">will cause this</st> <st c="10200">runtime exception:</st>
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 设置此设置为 `<st c="10179">true</st>` <st c="10183">将导致此</st> <st c="10200">运行时异常：</st>
- en: '[PRE9]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="10343">Lastly, import</st> `<st c="10359">get_wsgi_application</st>`
    <st c="10379">from the</st> `<st c="10389">django.core.wsgi</st>` <st c="10405">module
    and register it to</st> `<st c="10432">DispatcherMiddleware</st>`<st c="10452">.
    For Django web applications, import</st> `<st c="10490">StaticFilesHandler</st>`
    <st c="10508">from the</st> `<st c="10518">django.contrib.staticfiles.handlers</st>`
    <st c="10553">module and wrap the</st> `<st c="10574">get_wsgi_application()</st>`<st
    c="10596">’s returned object to access the static web files (e.g., CSS,</st> <st
    c="10659">JS, images):</st>
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从 `<st c="10389">django.core.wsgi</st>` <st c="10405">模块导入 `<st c="10359">get_wsgi_application</st>`
    <st c="10379">并将其注册到 `<st c="10432">DispatcherMiddleware</st>`<st c="10452">。对于
    Django 网络应用程序，从 `<st c="10518">django.contrib.staticfiles.handlers</st>` <st c="10553">模块导入
    `<st c="10490">StaticFilesHandler</st>` <st c="10508">并将 `<st c="10574">get_wsgi_application()</st>`<st
    c="10596"> 返回的对象包装起来以访问静态网络文件（例如 CSS、<st c="10659">JS、图像）：</st>
- en: '[PRE10]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="10995">Now, it is time to mount the main Flask app to the Tornado server
    after mounting the FastAPI, Django, and</st> <st c="11102">Flask sub-applications.</st>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在挂载 FastAPI、Django 和 Flask 子应用程序之后，是时候将主 Flask 应用程序挂载到 Tornado 服务器上了。
- en: <st c="11125">Putting it all together with Tornado</st>
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有内容与 Tornado 结合起来
- en: <st c="11162">Although it is ideal to use Gunicorn to run Flask applications
    in the production server, sometimes using the non-blocking Tornado server is a
    perfect choice for a Flask project that focuses more on event-driven transactions,
    WebSocket, and</st> **<st c="11403">Server-Sent Events</st>** <st c="11421">(</st>**<st
    c="11423">SSE</st>**<st c="11426">).</st> <st c="11430">For this chapter, our</st>
    <st c="11452">design is to mount the main Flask application, which implements
    the core</st> *<st c="11525">Online Library Management System’s</st>* <st c="11559">transactions,
    to a Tornado application.</st> <st c="11600">By the way, Tornado is a Python framework
    and asynchronous networking library whose strength is more on event-driven, non-blocking,
    and long polling transactions that require a long-live connection to a user.</st>
    <st c="11809">It has a bundled non-blocking HTTP server,</st> <st c="11852">unlike
    FastAPI.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在生产服务器上使用 Gunicorn 运行 Flask 应用程序是理想的，但有时对于更注重事件驱动事务、WebSocket 和 **<st c="11403">服务器端事件</st>**
    <st c="11421">(**<st c="11423">SSE</st>**<st c="11426">) 的 Flask 项目，使用非阻塞的 Tornado
    服务器是一个完美的选择。对于本章，我们的设计是将实现核心 *<st c="11525">在线图书馆管理系统</st>* <st c="11559">事务的主
    Flask 应用程序挂载到 Tornado 应用程序上。顺便说一下，Tornado 是一个 Python 框架和异步网络库，其优势在于事件驱动、非阻塞和需要长时间连接到用户的长时间轮询事务。它包含一个内置的非阻塞
    HTTP 服务器，与 FastAPI 不同。
- en: <st c="11867">To run a</st> <st c="11876">compatible WSGI application on Tornado’s
    HTTP server, it</st> <st c="11934">has a</st> `<st c="11940">WSGIContainer</st>`
    <st c="11953">utility class that wraps a core Flask</st> `<st c="11992">app</st>`
    <st c="11995">instance and runs the application on the non-blocking or asynchronous</st>
    <st c="12066">server mode.</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11867">要在 Tornado 的 HTTP 服务器上运行一个</st> <st c="11876">兼容的 WSGI 应用程序，它</st>
    <st c="11934">有一个</st> `<st c="11940">WSGIContainer</st>` <st c="11953">实用类，该类封装了一个核心
    Flask</st> `<st c="11992">app</st>` <st c="11995">实例并在非阻塞或异步</st> <st c="12066">服务器模式下运行应用程序。</st>
- en: <st c="12078">Important note</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12078">重要提示</st>
- en: <st c="12093">At the moment of writing this book,</st> `<st c="12130">Flask[async]</st>`
    <st c="12142">with async HTTP requests mounted on the Tornado server throws a</st>
    `<st c="12207">SynchronousOnlyOperation</st>` <st c="12231">error.</st> <st c="12239">Thus,
    this chapter focuses on the standard Flask request</st> <st c="12296">transactions
    only.</st>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12093">在撰写本书时，</st> `<st c="12130">Flask[async]</st>` <st c="12142">在
    Tornado 服务器上挂载异步 HTTP 请求会抛出</st> `<st c="12207">SynchronousOnlyOperation</st>`
    <st c="12231">错误。</st> <st c="12239">因此，本章仅关注标准的 Flask 请求</st> <st c="12296">事务。</st>
- en: <st c="12314">The</st> <st c="12319">following</st> `<st c="12329">main.py</st>`
    <st c="12336">snippet shows the integration of our core</st> <st c="12378">Flask
    app with the</st> <st c="12398">Tornado server:</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12314">以下</st> <st c="12319">的</st> `<st c="12329">main.py</st>` <st
    c="12336">代码片段显示了我们的核心</st> `<st c="12378">Flask app</st>` <st c="12398">与 Tornado
    服务器的集成：</st>
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="13109">Tornado is</st> <st c="13121">not a WSGI application and is not
    thread-safe.</st> <st c="13168">It uses one</st> <st c="13180">thread to manage
    one process at a time.</st> <st c="13220">It is a framework designed for event-driven
    applications with a built-in server created for running non-blocking I/O sockets.</st>
    <st c="13346">But, it can now directly use</st> `<st c="13375">asyncio</st>` <st
    c="13382">to run our mounted applications asynchronously in replacement of</st>
    `<st c="13448">IOLoop</st>` <st c="13455">for events.</st> <st c="13467">In the
    given snippet, our Tornado and main Flask applications run on the</st> `<st c="13540">asyncio</st>`
    <st c="13547">platform using the main event loop retrieved by</st> `<st c="13596">get_event_loop()</st>`<st
    c="13612">. By the way, our complete system has a Tornado handler,</st> `<st c="13669">MainHandler</st>`<st
    c="13680">, in</st> `<st c="13685">modules_tornado</st>` <st c="13700">that renders
    a welcome message in</st> <st c="13735">JSON format.</st>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13109">Tornado</st> <st c="13121">不是一个 WSGI 应用程序，也不是线程安全的。</st> <st c="13168">它使用一个</st>
    <st c="13180">线程来管理一次一个进程。</st> <st c="13220">它是一个为事件驱动应用程序设计的框架，内置的服务器用于运行非阻塞
    I/O 套接字。</st> <st c="13346">但是，现在它可以直接使用</st> `<st c="13375">asyncio</st>` <st
    c="13382">来异步运行我们的挂载应用程序，以替代</st> `<st c="13448">IOLoop</st>` <st c="13455">用于事件。</st>
    <st c="13467">在给定的代码片段中，我们的 Tornado 和主 Flask 应用程序使用通过</st> `<st c="13540">asyncio</st>`
    <st c="13547">平台获取的主事件循环</st> `<st c="13596">get_event_loop()</st>`<st c="13612">运行。</st>
    <st c="13669">顺便说一下，我们的完整系统有一个 Tornado 处理程序，</st> `<st c="13669">MainHandler</st>`<st
    c="13680">，位于</st> `<st c="13685">modules_tornado</st>` <st c="13700">中，用于以</st>
    <st c="13735">JSON</st> 格式显示欢迎信息。</st>
- en: <st c="13747">At this point, our application has become complex because of the
    mounting of different WSGI and ASGI applications, so it needs a microservice mechanism
    called</st> **<st c="13907">instrumentation</st>** <st c="13922">to</st> <st c="13926">monitor
    the low-level behavior of each mounted application and capture low-level metrics
    such as database-related logs, memory usage, and library-specific logs</st> <st
    c="14086">and issues.</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13747">此时，由于挂载了不同的 WSGI 和 ASGI 应用程序，我们的应用程序已经变得复杂，因此它需要一个名为</st> **<st
    c="13907">仪表化</st>** <st c="13922">的微服务机制来</st> <st c="13926">监控每个挂载应用程序的低级行为并捕获低级指标，例如数据库相关的日志、内存使用情况以及特定库的日志和问题。</st>
- en: <st c="14097">Implementing Flask instrumentation</st>
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="14097">实现 Flask 仪表化</st>
- en: <st c="14132">Instrumentation is a</st> <st c="14154">mechanism that generates,
    collects, and exports data about the runtime diagnostics of an application, microservice,
    or distributed setup.</st> <st c="14292">Usually, this observable data includes
    traces, logs, and metrics that can provide an understanding of the system.</st>
    <st c="14406">Among the many ways to implement instrumentation,</st> `<st c="14669">pip</st>`
    <st c="14672">command:</st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14132">仪表化是一种</st> <st c="14154">机制，用于生成、收集和导出有关应用程序、微服务或分布式设置的运行时诊断数据。</st>
    <st c="14292">通常，这些可观察数据包括跟踪、日志和指标，可以提供对系统的理解。</st> <st c="14406">在实现仪表化的许多方法中，</st>
    `<st c="14669">pip</st>` <st c="14672">命令：</st>
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="14804">The following</st> <st c="14819">snippet added to the</st> `<st
    c="14840">create_app()</st>` <st c="14852">factory in the</st> `<st c="14868">__init__.py</st>`
    <st c="14879">of the main Flask application provides the</st> <st c="14923">console-based
    instrumentation:</st>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="14804">以下</st>` `<st c="14819">片段添加到` `<st c="14840">create_app()</st>`
    `<st c="14852">工厂函数中，位于` `<st c="14868">__init__.py</st>` `<st c="14879">的主Flask应用程序中，提供了基于控制台的监控：</st>`'
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="15793">OpenTelemetry</st> <st c="15807">requires the Flask application
    to set up the Tracing API consisting of</st> `<st c="15879">TracerProvider</st>`<st
    c="15893">,</st> `<st c="15895">Tracer</st>`<st c="15901">, and</st> `<st c="15907">Span</st>`<st
    c="15911">(s).</st> <st c="15917">The first component,</st> `<st c="15938">TracerProvider</st>`<st
    c="15952">, is the entry point of the API and the registry for creating the tracers.</st>
    <st c="16027">A tracer is responsible for creating spans.</st> <st c="16071">On
    the other hand, a span is an API that can monitor any part of</st> <st c="16136">the
    application.</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="15793">OpenTelemetry</st>` `<st c="15807">要求Flask应用程序设置由` `<st c="15879">TracerProvider</st>`
    `<st c="15893">`、` `<st c="15895">Tracer</st>` `<st c="15901">`和` `<st c="15907">Span</st>`
    `<st c="15911">(s)</st>` `<st c="15917">组成的追踪API。</st> `<st c="15938">TracerProvider</st>`
    `<st c="15952">是API的入口点和创建追踪器的注册表。</st> `<st c="16027">追踪器负责创建跨度。</st> `<st c="16071">另一方面，跨度是一个API，可以监控应用程序的任何部分。</st>'
- en: <st c="16152">After instantiating</st> `<st c="16173">TracerProvider</st>`<st
    c="16187">, part of the setup to create a tracer is to</st> <st c="16232">apply</st>
    `<st c="16238">Batch</st>` **<st c="16243">SpanProcessor</st>**<st c="16257">,
    which preprocesses the spans per batch before exporting them to another system,
    tool, or backend.</st> <st c="16357">It requires a specific exporter class in
    its constructor parameter, such as</st> `<st c="16433">ConsoleSpanExporter</st>`<st
    c="16452">, which sends the span to the console.</st> <st c="16491">To complete
    the</st> `<st c="16507">TracerProvider</st>` <st c="16521">setup, add the processor
    to the</st> `<st c="16554">TracerProvider</st>` <st c="16568">object using its</st>
    `<st c="16586">add_span_processor()</st>` <st c="16606">method.</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化`<st c="16152">TracerProvider</st>`之后，创建追踪器的一部分设置是应用`<st c="16238">Batch</st>`
    **<st c="16243">SpanProcessor</st>**，它将批处理跨度在导出到另一个系统、工具或后端之前进行预处理。</st> <st c="16357">它在其构造函数参数中需要一个特定的导出器类，例如`<st
    c="16433">ConsoleSpanExporter</st>`<st c="16452">，它将跨度发送到控制台。</st> <st c="16491">为了完成`<st
    c="16507">TracerProvider</st>`的设置，使用其`<st c="16586">add_span_processor()</st>`
    <st c="16606">方法将处理器添加到`<st c="16554">TracerProvider</st>` <st c="16568">对象中。</st>
- en: <st c="16614">Finally, import the trace API object from the</st> `<st c="16661">opentelemetry</st>`
    <st c="16674">module and invoke its</st> `<st c="16697">set_tracer_provider()</st>`
    <st c="16718">class method to set the created</st> `<st c="16751">TracerProvider</st>`
    <st c="16765">instance.</st> <st c="16776">To extract the</st> `<st c="16791">tracer</st>`
    <st c="16797">object, invoke its</st> `<st c="16817">get_tracer()</st>` <st c="16829">method
    and specify its name, such</st> <st c="16864">as</st> `<st c="16867">packt-flask-tracer</st>`<st
    c="16885">.</st>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="16614">最后，从` `<st c="16661">opentelemetry</st>` `<st c="16674">模块导入跟踪API对象，并调用其`
    `<st c="16697">set_tracer_provider()</st>` `<st c="16718">类方法来设置创建的` `<st c="16751">TracerProvider</st>`
    `<st c="16765">实例。</st> `<st c="16776">要提取` `<st c="16791">tracer</st>` `<st c="16797">对象，调用其`
    `<st c="16817">get_tracer()</st>` `<st c="16829">方法并指定其名称，例如` `<st c="16864">`
    `<st c="16867">packt-flask-tracer</st>` `<st c="16885">`。</st>'
- en: <st c="16886">Now, import the</st> `<st c="16903">tracer</st>` <st c="16909">object
    anywhere inside the application.</st> <st c="16950">The following module script
    imports the</st> `<st c="16990">tracer</st>` <st c="16996">object to monitor the</st>
    `<st c="17019">add_login()</st>` <st c="17030">endpoint:</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="16886">现在，在任何地方导入</st>` `<st c="16903">tracer</st>` `<st c="16909">对象。</st>
    `<st c="16950">以下模块脚本导入` `<st c="16990">tracer</st>` `<st c="16996">对象以监控` `<st
    c="17019">add_login()</st>` `<st c="17030">端点：</st>`'
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="17357">Invoking the</st> `<st c="17371">start_as_current_span()</st>`
    <st c="17394">method of a</st> `<st c="17407">tracer</st>` <st c="17413">object
    creates a span, a single operation within a trace.</st> <st c="17472">For larger
    systems, spans can be nested to form a trace tree for detailed monitoring.</st>
    <st c="17558">A nested trace contains a root span, which typically describes the</st>
    <st c="17625">upper-level operation, and one or more child spans for its lower-level
    operations.</st> *<st c="17708">Figure 12</st>**<st c="17717">.3</st>* <st c="17719">shows
    the console log after running the</st> `<st c="17760">add_login()</st>` <st c="17771">endpoint:</st>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17357">调用</st> `<st c="17371">start_as_current_span()</st>` <st c="17394">方法创建一个</st>
    `<st c="17407">tracer</st>` <st c="17413">对象，创建一个跟踪内的单个操作，即跨度。</st> <st c="17472">对于更大的系统，跨度可以嵌套以形成一个跟踪树，以便进行详细的监控。</st>
    <st c="17558">嵌套跟踪包含一个根跨度，通常描述了</st> <st c="17625">上层操作，以及一个或多个子跨度来描述其下层操作。</st>
    *<st c="17708">图12</st>**<st c="17717">.3</st>* <st c="17719">显示了运行</st> `<st
    c="17760">add_login()</st>` <st c="17771">端点后的控制台日志：</st>
- en: '![Figure 12.3 – A tracer log exported to the console](img/B19383_12_003.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – 导出至控制台的tracer日志](img/B19383_12_003.jpg)'
- en: <st c="18272">Figure 12.3 – A tracer log exported to the console</st>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18272">图12.3 – 导出至控制台的tracer日志</st>
- en: <st c="18322">Additionally, Jaeger, a distributed tracing</st> <st c="18367">platform,
    can visualize</st> <st c="18391">all the logs from the trace in graphical views.</st>
    <st c="18439">OpenTelemetry has an exporter class that can export the spans to
    the Jaeger platform after preprocessing.</st> <st c="18545">But first, install
    Jaeger either through its Docker image or binaries.</st> <st c="18616">In this
    chapter, we start the Jaeger server through the</st> `<st c="18672">jaeger-all-in-one.exe</st>`
    <st c="18693">command from</st> <st c="18707">its binaries.</st>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18322">此外，Jaeger，一个分布式跟踪</st> <st c="18367">平台，可以将跟踪中的所有日志以图形视图进行可视化。</st>
    <st c="18391">OpenTelemetry有一个导出类，可以在预处理后将跨度导出到Jaeger平台。</st> <st c="18439">但是首先，通过其Docker镜像或二进制文件安装Jaeger。</st>
    <st c="18545">在本章中，我们通过其二进制文件中的</st> `<st c="18672">jaeger-all-in-one.exe</st>`
    <st c="18693">命令启动Jaeger服务器。</st>
- en: <st c="18720">Then, install the OpenTelemetry module for Jaeger support using
    the following</st> `<st c="18799">pip</st>` <st c="18802">command:</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18720">然后，使用以下</st> `<st c="18799">pip</st>` <st c="18802">命令安装Jaeger支持的OpenTelemetry模块：</st>
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <st c="18853">After the installation, add the following snippet to the previous
    OpenTelemetry setup in the</st> `<st c="18947">create_app()</st>` <st c="18959">factory:</st>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18853">安装完成后，将以下片段添加到</st> `<st c="18947">create_app()</st>` <st c="18959">工厂中的先前OpenTelemetry设置：</st>
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`<st c="19319">JaegerExporter</st>` <st c="19334">sends the traces to a thrift
    server running through the HTTP protocol.</st> <st c="19406">The constructor parameters
    of the exporter class are all about the server details of the thrift server.</st>
    <st c="19510">In our case,</st> `<st c="19523">agent_host_name</st>` <st c="19538">is</st>
    `<st c="19542">localhost</st>` <st c="19551">and</st> `<st c="19556">agent_port</st>`
    <st c="19566">is</st> `<st c="19570">6831</st>`<st c="19574">.</st>'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="19319">JaegerExporter</st>` <st c="19334">将跟踪发送到通过HTTP协议运行的Thrift服务器。</st>
    <st c="19406">导出类的构造函数参数都是关于Thrift服务器服务器细节的。</st> <st c="19510">在我们的案例中，</st>
    `<st c="19523">agent_host_name</st>` <st c="19538">是</st> `<st c="19542">localhost</st>`
    <st c="19551">，而</st> `<st c="19556">agent_port</st>` <st c="19566">是</st> `<st
    c="19570">6831</st>`<st c="19574">。</st>'
- en: <st c="19575">Restart the Tornado</st> <st c="19595">server, run the monitored
    APIs, and open the Jaeger dashboard at</st> `<st c="19661">http://localhost:16686/</st>`
    <st c="19684">using the browser to check the traces.</st> *<st c="19724">Figure
    12</st>**<st c="19733">.4</st>* <st c="19735">shows the</st> **<st c="19746">Search</st>**
    <st c="19752">page of the Jaeger dashboard after searching</st> <st c="19798">four
    traces:</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19575">重启Tornado</st> <st c="19595">服务器，运行监控的API，并使用浏览器打开</st> `<st c="19661">http://localhost:16686/</st>`
    <st c="19684">以检查跟踪。</st> *<st c="19724">图12</st>**<st c="19733">.4</st>* <st
    c="19735">显示了搜索</st> **<st c="19746">搜索</st>** <st c="19752">四个跟踪后的Jaeger仪表板的</st>
    **<st c="19798">搜索</st>** <st c="19752">页面：</st>
- en: '![Figure 12.4 – Jaeger search result for span traces](img/B19383_12_004.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – Jaeger对跨度跟踪的搜索结果](img/B19383_12_004.jpg)'
- en: <st c="20346">Figure 12.4 – Jaeger search result for span traces</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20346">图12.4 – Jaeger对跨度跟踪的搜索结果</st>
- en: <st c="20396">The left portion of Jaeger’s</st> `<st c="20515">packt-flask-service</st>`<st
    c="20534">, which gave four searches at the time of its search.</st> <st c="20588">On
    the right portion of the dashboard is the search result listing the traces produced
    by the spans that monitored the transaction performed.</st> <st c="20730">Clicking
    each row leads to trace details in a graphical format.</st> <st c="20794">On the
    other hand, the graph in the header portion</st> <st c="20845">summarizes all
    the traces at a</st> <st c="20876">specified duration.</st>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20895">Let us now explore how to add OpenAPI 3.x documentation to the
    API endpoints of our</st> <st c="20980">Flask application.</st>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20998">Applying OpenAPI 3.x specification with Swagger</st>
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="21046">Aside</st> <st c="21052">from instrumentation, some</st> <st c="21079">solutions
    provide well-formatted API documentation, as in FastAPI.</st> <st c="21147">One
    of these solutions is to use</st> `<st c="21180">flask_openapi3</st>`<st c="21194">,
    which applies OpenAPI 3.x specification to implement Flask components and document
    the API endpoints with Swagger, ReDoc,</st> <st c="21318">and RapiDoc.</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="21330">flask_openapi3</st>` <st c="21345">is not a library or dependency
    module of Flask but a separate framework based on the current Flask 3.x with the</st>
    `<st c="21458">pydantic</st>` <st c="21466">module to support OpenAPI documentation.</st>
    <st c="21508">It also supports</st> `<st c="21525">Flask[async]</st>` <st c="21537">components.</st>'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21549">After installing</st> `<st c="21567">flask_openapi3</st>` <st
    c="21581">using the</st> `<st c="21592">pip</st>` <st c="21595">command, replace
    the</st> `<st c="21617">Flask</st>` <st c="21622">class with</st> `<st c="21634">OpenAPI</st>`
    <st c="21641">and</st> `<st c="21646">Blueprint</st>` <st c="21655">with</st>
    `<st c="21661">APIBlueprint</st>`<st c="21673">. These are still the original
    Flask classes but with the feature of adding API documentation.</st> <st c="21768">The
    following is the</st> `<st c="21789">create_app()</st>` <st c="21801">factory</st>
    <st c="21809">method of our main Flask</st> <st c="21834">application that uses</st>
    `<st c="21857">OpenAPI</st>` <st c="21864">to create the application object with
    the added</st> <st c="21913">documentation components:</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <st c="22299">The</st> `<st c="22304">Info</st>` <st c="22308">utility class
    provides the project title of the OpenAPI documentation.</st> <st c="22380">Its
    instance is part of the constructor parameter values</st> <st c="22437">of OpenAPI.</st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22448">To document an API, add a summary of the endpoint, a complete
    description of the API transaction, tags, request field descriptions, and response
    details.</st> <st c="22603">The following snippet shows a simple documentation
    of the</st> `<st c="22661">list_login()</st>` <st c="22673">endpoint:</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <st c="23139">The HTTP</st> <st c="23149">method decorators of OpenAPI allow
    additional</st> <st c="23195">arguments such as a summary and tags describing
    the API endpoint.</st> <st c="23261">The</st> `<st c="23265">Tags</st>` <st c="23269">class
    is a</st> `<st c="23281">flask_openapi3</st>` <st c="23295">utility that enables
    the creation of tags for an endpoint.</st> <st c="23355">An endpoint can be associated
    with a list of tag objects.</st> <st c="23413">On the other hand, the documentation
    comment placed in the first lines of the API function becomes the complete and
    detailed description of the</st> <st c="23557">API implementation.</st>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23139">OpenAPI的HTTP方法装饰器允许额外的</st> <st c="23149">参数，例如描述API端点的摘要和标签。</st>
    <st c="23195">`Tags` <st c="23261">类是一个</st> `<st c="23265">flask_openapi3</st>`
    <st c="23269">实用工具，它能够为端点创建标签。</st> <st c="23281">端点可以与一系列标签对象相关联。</st> <st c="23355">另一方面，放置在API函数第一行的文档注释成为API实现的完整和详细描述。</st>
    <st c="23557">API实现。</st>
- en: <st c="23576">Now, an application using the</st> `<st c="23607">flask_openapi3</st>`
    <st c="23621">framework has an additional endpoint,</st> `<st c="23660">/openapi/swagger</st>`<st
    c="23676">, which, when run on a web browser, will render a Swagger documentation,
    as illustrated in</st> *<st c="23767">Figure 12</st>**<st c="23776">.5</st>*<st
    c="23778">:</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23576">现在，使用</st> `<st c="23607">flask_openapi3</st>` <st c="23621">框架的应用程序有一个额外的端点，</st>
    `<st c="23660">/openapi/swagger</st>`<st c="23676">，当在网页浏览器上运行时，将渲染Swagger文档，如图</st>
    *<st c="23767">图12</st>**<st c="23776">.5</st>*<st c="23778">所示：</st>
- en: '![Figure 12.5 – An OpenAPI/Swagger documentation in Flask](img/B19383_12_005.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5 – Flask中的OpenAPI/Swagger文档](img/B19383_12_005.jpg)'
- en: <st c="24388">Figure 12.5 – An OpenAPI/Swagger documentation in Flask</st>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24388">图12.5 – Flask中的OpenAPI/Swagger文档</st>
- en: <st c="24443">As long as</st> `<st c="24455">flask-openapi3</st>` <st c="24469">is
    always up to date and synchronized with the Flask releases, it is a helpful and
    feasible solution to build Flask applications with documentation implemented using
    OpenAPI/Swagger.</st> <st c="24653">The framework can provide acceptable and standard
    API</st> <st c="24707">documentation with less additional YAML or JSON configuration</st>
    <st c="24768">in</st> `<st c="24772">main.py</st>`<st c="24779">.</st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24443">只要</st> `<st c="24455">flask-openapi3</st>` <st c="24469">保持最新并与Flask版本同步，它就是一个有用且可行的解决方案，用于使用OpenAPI/Swagger实现文档的Flask应用程序。</st>
    <st c="24653">该框架可以提供可接受和标准的API</st> <st c="24707">文档，而无需在</st> `<st c="24772">main.py</st>`<st
    c="24779">中进行额外的YAML或JSON配置。</st>
- en: <st c="24780">In the next section, let us discuss other ways our Flask application
    can provide services outside the Python platform, starting with</st> <st c="24914">mobile
    development.</st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24780">在下一节中，让我们讨论我们的Flask应用程序如何以Python平台之外的方式提供服务，从</st> <st c="24914">移动开发</st>
    <st c="24914">开始。</st>
- en: <st c="24933">Providing REST services to a Flutter mobile application</st>
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="24933">为Flutter移动应用程序提供REST服务</st>
- en: <st c="24989">Flask applications can be a potential backend API service provider
    for many popular mobile platforms, such as Flutter.</st> <st c="25109">Flutter</st>
    <st c="25116">is an open source mobile toolkit created by Google to provide commercially
    accepted and natively compiled applications for mobile platforms.</st> <st c="25258">It
    can serve as a frontend framework for our</st> <st c="25303">microservice applications.</st>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24989">Flask应用程序可以成为许多流行移动平台（如Flutter）的潜在后端API服务提供商。</st> <st c="25109">Flutter</st>
    <st c="25116">是由Google创建的开源移动工具包，旨在为移动平台提供商业上可接受的本地编译应用程序。</st> <st c="25258">它可以作为我们</st>
    <st c="25303">微服务应用程序的前端框架。</st>
- en: <st c="25329">To start Flutter, download the latest Flutter SDK release – in
    my case, for Windows, from</st> <st c="25419">the</st> [<st c="25424">https://docs.flutter.dev/release/archive?tab=windows</st>](https://docs.flutter.dev/release/archive?tab=windows)
    <st c="25476">download site.</st> <st c="25492">Unzip the file to your development
    directory and register</st> `<st c="25550">%FLUTTER_HOME%\bin</st>` <st c="25568">in
    the Windows</st> <st c="25584">global classpath.</st>
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25329">要启动Flutter，下载最新的Flutter SDK版本 – 在我的案例中，对于Windows，从</st> <st c="25419">以下</st>
    [<st c="25424">https://docs.flutter.dev/release/archive?tab=windows</st>](https://docs.flutter.dev/release/archive?tab=windows)
    <st c="25476">下载站点。</st> <st c="25492">将文件解压到您的开发目录，并在Windows</st> <st c="25584">全局类路径中注册</st>
    `<st c="25550">%FLUTTER_HOME%\bin</st>` <st c="25568">。</st>
- en: <st c="25601">Afterward, download the latest Android Studio</st> <st c="25647">from</st>
    [<st c="25653">https://developer.android.com/studio</st>](https://developer.android.com/studio)<st
    c="25689">. Then, open the newly installed Android Studio and go to</st> **<st
    c="25747">Tools</st>** <st c="25752">|</st> **<st c="25755">SDK Manager</st>**
    <st c="25766">to install the</st> <st c="25782">following components:</st>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25601">之后，从[<st c="25653">https://developer.android.com/studio</st>](https://developer.android.com/studio)<st
    c="25689">下载最新的Android Studio。然后，打开新安装的Android Studio并转到</st> **<st c="25747">工具</st>**
    <st c="25752">|</st> **<st c="25755">SDK管理器</st>** <st c="25766">以安装以下组件：</st>
- en: <st c="25803">Android SDK platform, the latest</st> <st c="25837">API version</st>
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="25803">Android SDK平台，最新的</st> <st c="25837">API版本</st>
- en: <st c="25848">Android SDK</st> <st c="25861">command-line tools</st>
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="25848">Android SDK</st> <st c="25861">命令行工具</st>
- en: <st c="25879">Android SDK</st> <st c="25892">build tools</st>
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="25879">Android SDK</st> <st c="25892">构建工具</st>
- en: <st c="25903">Android SDK</st> <st c="25916">platform tools</st>
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="25903">Android SDK</st> <st c="25916">平台工具</st>
- en: <st c="25930">Android Emulator</st>
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="25930">Android模拟器</st>
- en: <st c="25947">After a</st> <st c="25956">successful Android SDK update and</st>
    <st c="25990">installation of SDK components, open a terminal and perform the
    following procedures for</st> <st c="26079">Flutter diagnostics:</st>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25947">在成功更新Android SDK和安装SDK组件后，打开终端并执行以下步骤进行</st> <st c="26079">Flutter诊断：</st>
- en: <st c="26099">Run the</st> `<st c="26108">flutter doctor</st>` <st c="26122">command
    on</st> <st c="26134">the terminal.</st>
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="26099">在终端上运行</st> `<st c="26108">flutter doctor</st>` <st c="26122">命令。</st>
- en: <st c="26147">All settings and tools must be satisfied before the development.</st>
    <st c="26213">There should be no issues at this point of</st> <st c="26256">the
    installation.</st>
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="26147">在开发之前，所有设置和工具都必须满足。</st> <st c="26213">在这个安装阶段不应该有任何问题。</st>
- en: <st c="26273">Using the VS Code editor with the Flutter extension, create a
    Flutter project; it should have the project structure presented in</st> *<st c="26403">Figure
    12</st>**<st c="26412">.6</st>*<st c="26414">:</st>
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="26273">使用带有Flutter扩展的VS Code编辑器创建一个Flutter项目；它应该具有</st> *<st c="26403">图12</st>**<st
    c="26412">.6</st>*<st c="26414">中展示的项目结构：</st>
- en: '![Figure 12.6 – Our ch12-flutter-flask project](img/B19383_12_006.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6 – 我们的ch12-flutter-flask项目](img/B19383_12_006.jpg)'
- en: <st c="26629">Figure 12.6 – Our ch12-flutter-flask project</st>
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26629">图12.6 – 我们的ch12-flutter-flask项目</st>
- en: <st c="26673">Inside</st> `<st c="26681">/lib/olms/provider</st>`<st c="26699">,</st>
    `<st c="26701">providers.dart</st>` <st c="26715">implements the transactions
    that consume</st> <st c="26756">the HTTP</st> `<st c="26766">GET</st>` <st c="26769">and</st>
    `<st c="26774">POST</st>` <st c="26778">of our</st> <st c="26785">APIs for user
    management.</st> <st c="26812">Here are the</st> `<st c="26825">dart</st>` <st
    c="26829">codes for our</st> <st c="26844">service providers:</st>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26673">在</st> `<st c="26681">/lib/olms/provider</st>`<st c="26699">中，</st>
    `<st c="26701">providers.dart</st>` <st c="26715">实现了消耗</st> <st c="26756">HTTP</st>
    `<st c="26766">GET</st>` <st c="26769">和</st> `<st c="26774">POST</st>` <st c="26778">的我们的</st>
    `<st c="26785">APIs</st> <st c="26789">用户管理的事务。</st> <st c="26812">以下是我们的</st>
    `<st c="26825">dart</st>` <st c="26829">服务提供者的代码：</st>
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <st c="27849">The given</st> `<st c="27860">addLogin()</st>` <st c="27870">consumes</st>
    <st c="27879">the</st> `<st c="27884">add_login()</st>` <st c="27895">API</st>
    <st c="27900">from our Flask</st> <st c="27915">microservice app:</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27849">给定的</st> `<st c="27860">addLogin()</st>` <st c="27870">消耗了</st>
    `<st c="27879">的</st> `<st c="27884">add_login()</st>` <st c="27895">API</st>
    <st c="27900">从我们的Flask</st> `<st c="27915">微服务应用：</st>
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <st c="28376">The</st> `<st c="28381">Login</st>` <st c="28386">model class</st>
    <st c="28399">mentioned in the code is a</st> <st c="28426">Flutter class that
    the</st> `<st c="28449">addLogin()</st>` <st c="28459">and</st> `<st c="28464">getLogin()</st>`
    <st c="28474">provider transactions will map to the JSON records from the Flask
    API endpoints.</st> <st c="28556">The following is Flutter’s</st> `<st c="28583">Login</st>`
    <st c="28588">model class derived from the</st> `<st c="28618">ch12-microservices-interop</st>`<st
    c="28644">’s SQLAlchemy</st> <st c="28659">model layer:</st>
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28376">在</st> `<st c="28381">登录</st>` <st c="28386">模型类</st> <st c="28399">中提到的代码是一个</st>
    <st c="28426">Flutter类，该类将</st> `<st c="28449">addLogin()</st>` <st c="28459">和</st>
    `<st c="28464">getLogin()</st>` <st c="28474">提供者事务映射到Flask API端点的JSON记录。</st>
    <st c="28556">以下是从</st> `<st c="28583">Login</st>` <st c="28588">模型类派生出的Flutter的</st>
    `<st c="28618">ch12-microservices-interop</st>`<st c="28644">的SQLAlchemy</st>
    `<st c="28659">模型层：</st>
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <st c="28857">Now, the given</st> `<st c="28873">getLogin()</st>` <st c="28883">retrieves
    the</st> `<st c="28898">Login</st>` <st c="28903">records in JSON format from
    our</st> `<st c="28936">list_login()</st>` <st c="28948">endpoint function.</st>
    <st c="28968">Notice that Flutter requires the</st> *<st c="29001">actual IP address</st>*
    <st c="29018">of the host server for its services to access the API</st> <st c="29073">endpoint
    resources.</st>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28857">现在，给定的</st> `<st c="28873">getLogin()</st>` <st c="28883">从我们的</st>
    `<st c="28898">登录</st>` <st c="28903">记录中检索JSON格式的记录，这些记录来自我们的</st> `<st c="28936">list_login()</st>`
    <st c="28948">端点函数。</st> <st c="28968">请注意，Flutter需要主服务器的实际IP地址来访问API</st> *<st
    c="29001">端点资源</st>* <st c="29018">。</st>
- en: <st c="29092">The</st> `<st c="29097">/lib/olms/tasks/task.dart</st>` <st c="29122">file
    implements the form widgets and the corresponding events that invoke these two
    service methods.</st> <st c="29224">The following part of the implementation shows
    the</st> `<st c="29275">Login</st>` <st c="29280">form:</st>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29092">以下</st> `<st c="29097">/lib/olms/tasks/task.dart</st>` <st c="29122">文件实现了表单小部件及其对应的事件，这些事件调用这两个服务方法。</st>
    <st c="29224">实现的部分展示了</st> `<st c="29275">登录</st>` <st c="29280">表单：</st>
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <st c="30130">In general,</st> `<st c="30143">LoginViewWidget</st>` <st c="30158">component</st>
    <st c="30168">returns a</st> `<st c="30179">Padding</st>` <st c="30186">widget
    composed of two sub-widgets.</st> <st c="30223">The preceding code renders a</st>
    <st c="30252">horizontal form of three</st> `<st c="30277">TextFormField</st>`
    <st c="30290">widgets that will accept login details from the user and an</st>
    `<st c="30351">ElevatedButton</st>` <st c="30365">that will trigger the</st> `<st
    c="30388">add_login()</st>` <st c="30399">provider transaction to invoke our Flask</st>
    `<st c="30441">/login/add</st>` <st c="30451">endpoint.</st> <st c="30462">The
    following code shows the next part of</st> `<st c="30504">LoginViewWidget</st>`
    <st c="30519">that renders the list of</st> `<st c="30545">Login</st>` <st c="30550">records
    from</st> <st c="30564">our database:</st>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30130">一般来说，</st> `<st c="30143">LoginViewWidget</st>` <st c="30158">组件</st>
    <st c="30168">返回一个由两个子小部件组成的`<st c="30179">Padding</st>` <st c="30186">小部件。</st>
    <st c="30223">前面的代码渲染了一个包含三个`<st c="30277">TextFormField</st>` <st c="30290">小部件的水平表单，这些小部件将接受用户的登录详情，以及一个`<st
    c="30351">ElevatedButton</st>` <st c="30365">小部件，该小部件将触发`<st c="30388">add_login()</st>`
    <st c="30399">提供者事务以调用我们的Flask</st> `<st c="30441">/login/add</st>` <st c="30451">端点。</st>
    <st c="30462">以下代码显示了`<st c="30504">LoginViewWidget</st>` <st c="30519">的下一部分，该部分渲染了从我们的数据库中获取的`<st
    c="30545">登录</st>` <st c="30550">记录列表：</st>
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <st c="31408">The preceding code</st> <st c="31427">renders a</st> `<st c="31438">FutureWidget</st>`
    <st c="31450">component</st> <st c="31460">composed of</st> `<st c="31473">ListView</st>`
    <st c="31481">of</st> `<st c="31485">DataColumn</st>` <st c="31495">and</st> `<st
    c="31500">DataRow</st>` <st c="31507">widgets to showcase the</st> `<st c="31532">Login</st>`
    <st c="31537">records from our Flask</st> `<st c="31561">/login/list/all</st>`
    <st c="31576">endpoint.</st> <st c="31587">It has a vertical scrollbar rendered
    by its</st> `<st c="31631">SingleChildScrollView</st>` <st c="31653">widget.</st>
    *<st c="31661">Figure 12</st>**<st c="31670">.7</st>* <st c="31672">shows the
    resulting</st> `<st c="31693">LoginViewWidget</st>` <st c="31708">form after running
    our</st> `<st c="31732">ch12-flask-flutter</st>` <st c="31750">application using
    the</st> `<st c="31773">flutter run</st>` <st c="31784">command inside the</st>
    `<st c="31804">/</st>``<st c="31805">library_app</st>` <st c="31816">directory.</st>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31408">前面的代码</st> <st c="31427">渲染了一个</st> `<st c="31438">FutureWidget</st>`
    <st c="31450">组件</st>，该组件由`<st c="31473">ListView</st>` <st c="31481">中的`<st c="31485">DataColumn</st>`
    <st c="31495">和`<st c="31500">DataRow</st>` <st c="31507">小部件组成，用于展示从我们的Flask</st>
    `<st c="31561">/login/list/all</st>` <st c="31576">端点获取的</st> `<st c="31532">登录</st>`
    <st c="31537">记录。</st> <st c="31587">它有一个由其`<st c="31631">SingleChildScrollView</st>`
    <st c="31653">小部件渲染的垂直滚动条。</st> *<st c="31661">图12</st>**<st c="31670">.7</st>*
    <st c="31672">显示了运行我们的</st> `<st c="31732">ch12-flask-flutter</st>` <st c="31750">应用程序后得到的</st>
    `<st c="31693">LoginViewWidget</st>` <st c="31708">表单，使用的是在`<st c="31804">/</st>``<st
    c="31805">library_app</st>` <st c="31816">目录内执行的`<st c="31773">flutter run</st>`
    <st c="31784">命令。</st>
- en: '![Figure 12.7 – A Flutter form for login transactions](img/B19383_12_007.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图12.7 – 用于登录事务的Flutter表单](img/B19383_12_007.jpg)'
- en: <st c="31921">Figure 12.7 – A Flutter form for login transactions</st>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31921">图12.7 – 用于登录事务的Flutter表单</st>
- en: <st c="31972">In addition to</st> <st c="31987">mobile development, Flask APIs</st>
    <st c="32019">can also provide data services to popular frontend frameworks, such
    as React.</st> <st c="32097">Let us see how in the</st> <st c="32119">next section.</st>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31972">除了移动开发之外，Flask API</st> <st c="31987">还可以为流行的前端框架，如React提供数据服务。</st>
    <st c="32097">让我们在下一节中看看如何实现。</st>
- en: <st c="32132">Consuming REST endpoints with a React application</st>
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="32132">使用React应用程序消费REST端点</st>
- en: <st c="32182">React</st> <st c="32188">is a popular frontend server-side JavaScript
    library used to build scalable user interfaces for websites, mostly</st> **<st
    c="32302">single-page applications</st>** <st c="32326">(</st>**<st c="32328">SPAs</st>**<st
    c="32332">).</st> <st c="32336">It is a popular library in rendering pages that</st>
    <st c="32383">changes its state without reloading</st> <st c="32420">the page.</st>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32182">React</st> <st c="32188">是一个流行的前端服务器端JavaScript库，用于构建网站的可扩展用户界面，主要用于</st>
    **<st c="32302">单页应用程序</st>** <st c="32326">(</st>**<st c="32328">SPAs</st>**<st
    c="32332">)。</st> <st c="32336">它是一个流行的库，用于渲染页面，该页面在</st> <st c="32383">不重新加载</st>
    <st c="32420">页面的情况下改变其状态。</st>
- en: <st c="32429">After creating a</st> <st c="32447">React project using the</st>
    `<st c="32471">create-react-app</st>` <st c="32487">command, our</st> `<st c="32501">ch12-react-flask</st>`
    <st c="32517">application has implemented the following functional component to
    build the form page and the table listing all the faculty borrowers of the</st>
    *<st c="32659">Online Library</st>* *<st c="32674">Management System</st>*<st
    c="32691">:</st>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32429">使用</st> `<st c="32447">create-react-app</st>` <st c="32471">命令创建React项目后，我们的</st>
    `<st c="32501">ch12-react-flask</st>` <st c="32517">应用程序实现了以下功能组件来构建表单页面和列出所有在线图书馆管理系统教员借阅者的表格：</st>
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: <st c="32969">The given</st> `<st c="32980">useState()</st>` <st c="32990">hook
    methods define the state variables that the form components will use to capture
    form data before submitting the details to the</st> `<st c="33123">add_faculty_borrower()</st>`
    <st c="33145">API endpoint of our</st> <st c="33166">FastAPI sub-application:</st>
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32969">给定的</st> `<st c="32980">useState()</st>` <st c="32990">钩子方法定义了表单组件在提交详细信息到</st>
    `<st c="33123">add_faculty_borrower()</st>` <st c="33145">API端点之前将使用的状态变量：</st>
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: <st c="34072">The</st> `<st c="34077">addRecord()</st>` <st c="34088">event</st>
    <st c="34095">method forms the JSON data from the state variables before submitting
    it to the</st> `<st c="34175">add_faculty_borrower()</st>` <st c="34197">API endpoint.</st>
    <st c="34212">Likewise, it retrieves all the faculty borrowers from the microservice
    through the</st> `<st c="34295">list_all_faculty_borrowers()</st>` <st c="34323">endpoint
    of the same</st> <st c="34345">FastAPI sub-application:</st>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34072">在将JSON数据提交到</st> `<st c="34175">add_faculty_borrower()</st>` <st
    c="34197">API端点之前，</st> `<st c="34077">addRecord()</st>` <st c="34088">事件</st>
    <st c="34095">方法会从状态变量中形成JSON数据。</st> <st c="34212">同样，它通过同一</st> `<st c="34295">list_all_faculty_borrowers()</st>`
    <st c="34323">端点从微服务中检索所有教员借阅者。</st>
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <st c="35047">The</st> `<st c="35052">records.map()</st>` <st c="35065">function
    builds the table of records after adding a new faculty borrower record to the
    database.</st> `<st c="35163">addRecord()</st>`<st c="35174">, with the help of
    the</st> `<st c="35197">useEffect()</st>` <st c="35208">hook method, captures
    all the records from the</st> `<st c="35256">list_all_faculty_borrowers()</st>`
    <st c="35284">API and stores the list of JSON-formatted data to the state</st>
    <st c="35344">variable,</st> `<st c="35355">records</st>`<st c="35362">.</st>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35047">在数据库中添加一个新的教员借阅记录后，</st> `<st c="35052">records.map()</st>` <st
    c="35065">函数构建了记录表。</st> `<st c="35163">addRecord()</st>`<st c="35174">，借助</st>
    `<st c="35197">useEffect()</st>` <st c="35208">钩子方法，从</st> `<st c="35256">list_all_faculty_borrowers()</st>`
    <st c="35284">API中捕获所有记录，并将JSON格式的数据列表存储到状态</st> <st c="35344">变量</st> `<st c="35355">records</st>`<st
    c="35362">中。</st>
- en: <st c="35363">Aside from building service providers for other platforms, Flask
    can also build GraphQL applications for easy CRUD operations.</st> <st c="35491">Let’s
    learn about it in the</st> <st c="35519">next discussion.</st>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35363">除了为其他平台构建服务提供商之外，Flask还可以构建用于轻松CRUD操作的GraphQL应用。</st> <st c="35491">让我们在下一讨论中了解它。</st>
- en: <st c="35535">Building a GraphQL application</st>
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="35535">构建GraphQL应用</st>
- en: <st c="35566">GraphQL is</st> <st c="35578">a mechanism that provides a platform-agnostic
    CRUD transaction across the applications without specifying the actual database
    connectivity details and database dialects.</st> <st c="35748">This mechanism
    is model-centric or data-centric and focuses on the data the users want to fetch
    through the backend</st> <st c="35864">API implementations.</st>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35566">GraphQL是一种</st> <st c="35578">机制，它提供了一个平台无关的CRUD事务，无需指定实际的数据库连接细节和数据库方言。</st>
    <st c="35748">此机制以模型为中心或以数据为中心，并关注用户通过后端</st> <st c="35864">API实现想要获取的数据。</st>
- en: <st c="35884">Our microservice designed</st> <st c="35910">the Flask sub-application
    to be a GraphQL application with the following HTTP GET endpoint that creates
    the GraphQL</st> <st c="36027">UI explorer:</st>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35884">我们设计的</st> <st c="35910">Flask子应用程序</st> <st c="36027">是一个GraphQL应用程序，具有以下HTTP
    GET端点，用于创建GraphQL</st> <st c="36027">UI探索器：</st>
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: <st c="36319">Our solution</st> <st c="36333">used the</st> `<st c="36342">Ariadne</st>`
    <st c="36349">module because it is updated and can integrate with Flask 3.x components.</st>
    *<st c="36424">Figure 12</st>**<st c="36433">.8</st>* <st c="36435">shows the
    actual GraphQL Explorer after accessing the given</st> `<st c="36496">/</st>``<st
    c="36497">flask/graphql</st>` <st c="36510">endpoint.</st>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36319">我们的解决方案</st> <st c="36333">使用了</st> `<st c="36342">Ariadne</st>`
    <st c="36349">模块，因为它更新且可以与Flask 3.x组件集成。</st> *<st c="36424">图12</st>**<st c="36433">.8</st>*
    <st c="36435">显示了访问给定的</st> `<st c="36496">/</st>``<st c="36497">flask/graphql</st>`
    <st c="36510">端点后的实际GraphQL探索器。</st>
- en: '![Figure 12.8 – The Ariadne GraphQL Explorer](img/B19383_12_008.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图12.8 – Ariadne GraphQL探索器](img/B19383_12_008.jpg)'
- en: <st c="36641">Figure 12.8 – The Ariadne GraphQL Explorer</st>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36641">图12.8 – Ariadne GraphQL探索器</st>
- en: <st c="36683">Next, build the crucial GraphQL schema configuration, the</st>
    `<st c="36742">schema.graphql</st>` <st c="36756">file, which creates all the
    GraphQL model classes derived from the ORM models, request data, and response
    objects of the supposed API endpoints.</st> <st c="36902">The following is a snapshot
    of the</st> `<st c="36937">schema.graphql</st>` <st c="36951">file used by our</st>
    <st c="36969">Flask sub-application:</st>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36683">接下来，构建关键的GraphQL模式配置，即</st> `<st c="36742">schema.graphql</st>`
    <st c="36756">文件，该文件创建所有从ORM模型派生的GraphQL模型类、请求数据和响应对象，这些对象是假设的API端点。</st> <st
    c="36902">以下是我们Flask子应用程序使用的</st> `<st c="36937">schema.graphql</st>` <st c="36951">文件的快照：</st>
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '# The GraphQL operations'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '# The GraphQL operations'
- en: type Query {
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: type Query {
- en: 'listAllComplainants: <st c="38504">ComplainantListResult</st>!'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'listAllComplainants: <st c="38504">ComplainantListResult</st>!'
- en: 'listAllComplaints: <st c="38546">ComplaintListResult</st>!'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'listAllComplaints: <st c="38546">ComplaintListResult</st>!'
- en: 'listAllCategories: <st c="38586">CategoryListResult</st>!'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'listAllCategories: <st c="38586">CategoryListResult</st>!'
- en: 'listAllComplaintTypes: <st c="38629">ComplaintTypeListResult</st>!'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'listAllComplaintTypes: <st c="38629">ComplaintTypeListResult</st>!'
- en: '}'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: type Mutation {
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: type Mutation {
- en: 'createCategory(<st c="38687">name: String</st>!): CategoryInsertResult! createComplaintType(<st
    c="38746">name: String</st>!): ComplaintTypeInsertResult! createComplainant(<st
    c="38808">input: ComplainantInput</st>!): ComplainantInsertResult! createComplaint(<st
    c="38877">input: ComplaintInput</st>!): ComplaintInsertResult! }'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'createCategory(<st c="38687">name: String</st>!): CategoryInsertResult! createComplaintType(<st
    c="38746">name: String</st>!): ComplaintTypeInsertResult! createComplainant(<st
    c="38808">input: ComplainantInput</st>!): ComplainantInsertResult! createComplaint(<st
    c="38877">input: ComplaintInput</st>!): ComplaintInsertResult! }'
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '# These are the input types <st c="39764">input</st> ComplainantInput {'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '# These are the input types <st c="39764">input</st> ComplainantInput {'
- en: 'firstname: String! lastname: String! middlename: String! email: String! date_registered:
    String! } <st c="39888">input</st> ComplaintInput {'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'firstname: String! lastname: String! middlename: String! email: String! date_registered:
    String! } <st c="39888">input</st> ComplaintInput {'
- en: 'ticketId: String! complainantId: Int! catid: Int! ctype: Int! }'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 'ticketId: String! complainantId: Int! catid: Int! ctype: Int! }'
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '# These are the result types'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '# These are the result types'
- en: type ComplainantInsertResult {
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: type ComplainantInsertResult {
- en: 'success: Boolean! errors: [String]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'success: Boolean! errors: [String]'
- en: 'model: Complainant! }'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'model: Complainant! }'
- en: type ComplaintInsertResult {
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: type ComplaintInsertResult {
- en: 'success: Boolean! errors: [String]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'success: Boolean! errors: [String]'
- en: 'model: Complaint! }'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'model: Complaint! }'
- en: … … … … … …
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: … … … … … …
- en: type ComplainantListResult {
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: type ComplainantListResult {
- en: 'success: Boolean! errors: [String]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'success: Boolean! errors: [String]'
- en: 'complainants: [Complainant]! }'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'complainants: [Complainant]! }'
- en: type ComplaintListResult {
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: type ComplaintListResult {
- en: 'success: Boolean! errors: [String]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'success: Boolean! errors: [String]'
- en: 'complaints: [Complaint]! }'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'complaints: [Complaint]! }'
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: from ariadne import QueryType, MutationType
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: from ariadne import QueryType, MutationType
- en: from typing import List, Any, Dict
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: from typing import List, Any, Dict
- en: from modules_sub_flask.models.db import Complainant
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从 modules_sub_flask.models.db 导入 Complainant
- en: from sqlalchemy.orm import Session <st c="41377">query = QueryType()</st>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 从 sqlalchemy.orm 导入 Session <st c="41377">query = QueryType()</st>
- en: '<st c="41396">mutation = MutationType()</st> class ComplainantResolver:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="41396">mutation = MutationType()</st> class ComplainantResolver:'
- en: 'def __init__(self, sess:Session):'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def __init__(self, sess:Session):'
- en: self.sess = sess <st c="41501">@mutation.field('complainant')</st>
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: self.sess = sess <st c="41501">@mutation.field('complainant')</st>
- en: <st c="41531">def insert_complainant(self, obj, info, input) -> bool:</st>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41531">def insert_complainant(self, obj, info, input) -> bool:</st>
- en: <st c="41587">try:</st>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41587">try:</st>
- en: <st c="41592">complainant = Complainant(**input)</st>
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41592">complainant = Complainant(**input)</st>
- en: <st c="41627">self.sess.add(complainant)</st>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41627">self.sess.add(complainant)</st>
- en: <st c="41654">self.sess.commit()</st>
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41654">self.sess.commit()</st>
- en: <st c="41673">payload = {</st>
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41673">payload = {</st>
- en: '<st c="41685">"success": True,</st>'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="41685">"success": True,</st>'
- en: '<st c="41702">"model": complainant</st>'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="41702">"model": complainant</st>'
- en: <st c="41723">}</st>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41723">}</st>
- en: <st c="41725">except Exception as e:</st>
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41725">except Exception as e:</st>
- en: <st c="41748">print(e)</st>
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41748">print(e)</st>
- en: <st c="41757">payload = {</st>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41757">payload = {</st>
- en: '<st c="41769">"success": False,</st>'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="41769">"success": False,</st>'
- en: '<st c="41787">"errors": [f"Complainant … not found"]</st>'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="41787">"errors": [f"Complainant … not found"]</st>'
- en: <st c="41826">}</st>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41826">}</st>
- en: <st c="41828">return payload</st> … … … … … …
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41828">return payload</st> … … … … … …
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'def select_all_complainant(self, obj, info) -> List[Any]:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 'def select_all_complainant(self, obj, info) -> List[Any]:'
- en: complainants = self.sess.query(Complainant).all()
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: complainants = self.sess.query(Complainant).all()
- en: 'try:'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try:'
- en: records = [todo.to_json() for todo in complainants]
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: records = [todo.to_json() for todo in complainants]
- en: 'print(records) <st c="42318">payload = {</st><st c="42329">"success": True,</st><st
    c="42346">"complainants": records</st><st c="42370">}</st> except Exception as
    e:'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'print(records) <st c="42318">payload = {</st><st c="42329">"success": True,</st><st
    c="42346">"complainants": records</st><st c="42370">}</st> except Exception as
    e:'
- en: 'print(e) <st c="42405">payload = {</st><st c="42416">"success": False,</st><st
    c="42434">"errors": [str("Empty records")]</st><st c="42467">}</st> … … … … …
    …'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'print(e) <st c="42405">payload = {</st><st c="42416">"success": False,</st><st
    c="42434">"errors": [str("Empty records")]</st><st c="42467">}</st> … … … … …
    …'
- en: '[PRE33]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: … … … … … …
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: … … … … … …
- en: from ariadne import load_schema_from_path, make_executable_schema, \
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ariadne 导入 load_schema_from_path, make_executable_schema, \
- en: graphql_sync, snake_case_fallback_resolvers, ObjectType
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: graphql_sync, snake_case_fallback_resolvers, ObjectType
- en: from ariadne.explorer import ExplorerGraphiQL <st c="43318">from modules_sub_flask.resolvers.complainant_repo
    import ComplainantResolver</st>
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ariadne.explorer 导入 ExplorerGraphiQL <st c="43318">从 modules_sub_flask.resolvers.complainant_repo
    导入 ComplainantResolver</st>
- en: <st c="43394">from modules_sub_flask.resolvers.complaint_repo import ComplaintResolver</st>
    from modules_sub_flask.models.config import db_session
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43394">从 modules_sub_flask.resolvers.complaint_repo 导入 ComplaintResolver</st>
    从 modules_sub_flask.models.config 导入 db_session
- en: … … … … … … <st c="43535">complainant_repo = ComplainantResolver(db_session)</st>
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: … … … … … … <st c="43535">complainant_repo = ComplainantResolver(db_session)</st>
- en: <st c="43585">category_repo = CategoryResolver(db_session)</st> … … … … … …
    <st c="43642">query = ObjectType("Query")</st> query.set_field("listAllComplainants",
    complainant_repo.select_all_complainant)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43585">category_repo = CategoryResolver(db_session)</st> … … … … … …
    <st c="43642">query = ObjectType("Query")</st> query.set_field("listAllComplainants",
    complainant_repo.select_all_complainant)
- en: query.set_field("listAllComplaints", complaint_repo.select_all_complaint)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: query.set_field("listAllComplaints", complaint_repo.select_all_complaint)
- en: … … … … … … <st c="43836">mutation = ObjectType("Mutation")</st> mutation.set_field("createComplainant",
    complainant_repo.insert_complainant)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: … … … … … … <st c="43836">mutation = ObjectType("Mutation")</st> mutation.set_field("createComplainant",
    complainant_repo.insert_complainant)
- en: mutation.set_field("createComplaint", complaint_repo.insert_complaint)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: mutation.set_field("createComplaint", complaint_repo.insert_complaint)
- en: … … … … … … <st c="44030">type_defs = load_schema_from_path("./schema.graphql")</st>
    schema = make_executable_schema(
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: … … … … … … <st c="44030">type_defs = load_schema_from_path("./schema.graphql")</st>
    schema = make_executable_schema(
- en: type_defs, <st c="44128">query</st>, <st c="44135">mutation</st>,
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: type_defs, <st c="44128">query</st>, <st c="44135">mutation</st>,
- en: )
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: … … … … … …
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: … … … … … …
- en: '[PRE34]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
