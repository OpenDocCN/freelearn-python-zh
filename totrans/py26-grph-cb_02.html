<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 2. Drawing Fundamental Shapes"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Drawing Fundamental Shapes</h1></div></div></div><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A straight line and the coordinate system</li><li class="listitem" style="list-style-type: disc">Drawing a dashed line</li><li class="listitem" style="list-style-type: disc">Lines of varying styles with arrows and endcaps</li><li class="listitem" style="list-style-type: disc">A two-segment line with a sharp bend</li><li class="listitem" style="list-style-type: disc">A line with a curved bend</li><li class="listitem" style="list-style-type: disc">Drawing intricate stored shapes - the curly vine</li><li class="listitem" style="list-style-type: disc">Drawing a rectangle</li><li class="listitem" style="list-style-type: disc">Drawing overlapping rectangles</li><li class="listitem" style="list-style-type: disc">Drawing concentric squares</li><li class="listitem" style="list-style-type: disc">A circle from an oval</li><li class="listitem" style="list-style-type: disc">A circle from an arc</li><li class="listitem" style="list-style-type: disc">Three ellipses</li><li class="listitem" style="list-style-type: disc">The simplest polygon</li><li class="listitem" style="list-style-type: disc">A star polygon</li><li class="listitem" style="list-style-type: disc">The art of cloning stars</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec01"/>Introduction</h1></div></div></div><p>Graphics are all about pictures and drawings. In computer programs, a line is not drawn by a hand, holding a pencil, but by the manipulation of numbers on a screen. This chapter provides the fine-grained detail or atomic structure for the rest of the book. Here we lay down the most basic graphic building blocks in their simplest form. The most useful options are presented inside self-contained programs. You can if you want, use the code without understanding in detail how it works. You can learn by doing. You can learn by playing and play is the serious work that unskilled animals do in order to learn almost everything they need for survival.<a id="id18" class="indexterm"/>
</p><p>You can cut and paste the code and it should just work without modification. The code is easily modified and you are encouraged to tinker with it and tweak the parameters inside the drawing methods. The more you tinker with it, the more you will understand.</p><p>The area of screen where lines and shapes are drawn is the canvas in Python. It is created when the Tkinter method<code class="literal"> canvas()</code> is executed.<a id="id19" class="indexterm"/>
</p><p>Central to using numbers to describe lines and shapes is a coordinate system that says where a line or shape starts and where it ends. In Tkinter, as in most computer graphic systems, the top-left is the start of the screen or canvas and bottom-right is the end where the largest numbers describe location. This system is shown in the next figure, which is the universal computer screen coordinate system.</p><div class="mediaobject"><img src="images/3845OS_02_01.jpg" width="342" alt="Introduction"/></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="A straight line and the coordinate system"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec02"/>A straight line and the coordinate system</h1></div></div></div><p>Draw a straight line on a canvas. It is important to understand that the start of the coordinate system is always at the top left-hand corner of the canvas as shown in the previous figure.<a id="id20" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec01"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem">In a text editor type the lines below that appear between the two<code class="literal"> #&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> divider/separators.<a id="id21" class="indexterm"/></li><li class="listitem">Save this as a file named<code class="literal"> line_1.py</code>, inside the directory called<code class="literal"> constr</code> again.</li><li class="listitem">As before, open up an X terminal or DOS window if you are using MS Windows.</li><li class="listitem">Change directory (command<code class="literal"> cd /constr)</code> into the directory<code class="literal"> constr</code> - where<code class="literal"> line_1.py</code> is located.</li><li class="listitem">Type<code class="literal"> python line_1.py</code> and your program will execute. The result should look like the following screenshot:<div class="mediaobject"><img src="images/3845_02_02.jpg" height="110" alt="How to do it..."/></div><div class="informalexample"><pre class="programlisting"># line_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title('Basic Tkinter straight line')
cw = 800 # canvas width, in pixels
ch = 200 # canvas height, in pixels
canvas_1 = Canvas(root, width=cw, height=ch)
canvas_1.grid(row=0, column=1) # placement of the canvas
x_start = 10 # bottom left
y_start = 10
x_end = 50 # top right
y_end = 30
canvas_1.create_line(x_start, y_start, x_end,y_end)
root.mainloop()
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec02"/>How it works...</h2></div></div></div><p>We have written the coordinates for our line differently from the way we did in the previous chapter because we want to introduce symbolic assignments into the<code class="literal"> create_line()</code> method. This is a preliminary step to making our code re-usable. There is more than one way to specify the points that define the location of line. The neatest way is to define a Python list or tuple by name and then just insert this name of the list as the argument of the<code class="literal"> create_line()</code> method.<a id="id22" class="indexterm"/>
</p><p>For example, if we wanted to draw two lines, one from (x=50, y=25) to (x= 220, y=44) and the second line between(x=11, y=22) and (x=44, y=33) then we could write the following lines in our program:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">line_1 = 50, 25, 220, 44 #</code> this is a tuple and can NEVER change</li><li class="listitem" style="list-style-type: disc"><code class="literal">line_2 = [11, 22, 44, 33] #</code> this is a list and can be changed anytime.</li><li class="listitem" style="list-style-type: disc"><code class="literal">canvas_1.create_line(line_1)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">canvas_1.create_line(line_2)</code></li></ul></div><p>Note that although<code class="literal"> line_1 = 50, 25, 220, 44</code> is syntactically correct Python, it is considered to be poor Python grammar. It is better to write<code class="literal"> line_1 = ( 50, 25, 220, 44)</code> because this is more explicit and therefore clearer to someone reading the code. Another point to note is that<code class="literal"> canvas_1</code> is an arbitrary name I have given to the particular instance of a canvas of a certain size. You can give it any name you like.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec03"/>There's more...</h2></div></div></div><p>Most shapes can be made up of pieces of lines joined together in a multitude of ways. An extremely useful attribute that Tkinter offers is the ability to transform sequences of straight lines into smooth curves. This attribute of lines can be used in surprising ways and is illustrated in recipe 6.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Draw a dashed line"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec03"/>Draw a dashed line</h1></div></div></div><p>A straight dashed line, three pixels thick is drawn.<a id="id23" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec04"/>How to do it...</h2></div></div></div><p>The instructions used in the previous example are used. The only change is in the name of the Python program. This time you should use the name<code class="literal"> dashed_line.py</code> instead of<code class="literal"> line_1.py</code>.</p><div class="informalexample"><pre class="programlisting"># dashed_line.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title('Dashed line')
cw = 800 # canvas width
ch = 200 # canvas height
canvas_1 = Canvas(root, width=cw, height=ch)
canvas_1.grid(row=0, column=1)
x_start = 10
y_start = 10
x_end = 500
y_end = 20
canvas_1.create_line(x_start, y_start, x_end,y_end, dash=(3,5), width = 3)
root.mainloop()#
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec05"/>How it works...</h2></div></div></div><p>The new things here are the addition of some style specifications for the line.<a id="id24" class="indexterm"/>
</p><p>
<code class="literal">dash=( 3,5)</code> says that there should be three solid pixels followed by five blank pixels and<code class="literal"> width = 3</code> specifies that the line should be 3 pixels thick.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec06"/>There's more...</h2></div></div></div><p>You can specify a limitless variety of dash-space patterns. A dash-space pattern specified as<code class="literal"> dash = (5, 3, 24, 2, 3, 11)</code> would result in a line with three patterns repeated over and over throughout the length of the line. The pattern would consist of five solid pixels followed by three blank pixels. Then there would be 24 solid pixels followed by only two blank pixels. The third variation would be three solid followed by 11 blank pixels and then the whole set of three patterns would begin again. The list of dash-blank pairs can go on as long as you like. The even-numbered length specifications will specify the length of solid pixels.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note02"/>Note</h3><p>The dash attribute is quirky on different operating systems. For instance on a Linux operating system it behaves as it should by obeying the directives for line and space distances but on MS Windows there is no respect for solid-dash directives if they exceed ten pixels in size</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Lines of varying styles with arrows and endcaps"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec04"/>Lines of varying styles with arrows and endcaps</h1></div></div></div><p>Four lines are drawn in different styles. We see how attributes like color and end shape can be obtained. A Python<code class="literal"> for loop</code> is used to make an interesting pattern using the specifications of the dash attribute. In addition the color of the canvas background has been made green.<a id="id25" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec07"/>How to do it...</h2></div></div></div><p>The instructions used in recipe 1 should be used again.<a id="id26" class="indexterm"/>
</p><p>Just use the name<code class="literal"> 4lines.py</code> when you write, save, and execute this program.</p><p>Arrows and endcaps have been introduced into the line specifications.</p><div class="informalexample"><pre class="programlisting">#4lines.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title('Different line styles')
cw = 280 # canvas width
ch = 120 # canvas height
canvas_1 = Canvas(root, width=cw, height=ch, background="spring \ green")
canvas_1.grid(row=0, column=1)
x_start, y_start = 20, 20
x_end, y_end = 180, 20
canvas_1.create_line(x_start, y_start, x_end,y_end,\
dash=(3,5), arrow="first", width = 3)
x_start, y_start = x_end, y_end
x_end, y_end = 50, 70
canvas_1.create_line(x_start, y_start, x_end,y_end,\
dash=(9,5), width = 5, fill= "red")
x_start, y_start = x_end, y_end
x_end, y_end = 150, 70
canvas_1.create_line(x_start, y_start, x_end,y_end, \
dash=(19,5),width= 15, caps="round", \ fill= "dark blue")
x_start, y_start = x_end, y_end
x_end, y_end = 80, 100
canvas_1.create_line(x_start, y_start, x_end,y_end, fill="purple")
#width reverts to default= 1 in absence of explicit spec.
root.mainloop()
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec08"/>How it works...</h2></div></div></div><p>To draw a line you only need to give the start point and the end point.</p><div class="mediaobject"><img src="images/3845_02_03.jpg" height="97" alt="How it works..."/></div><p>The preceding screenshot shows the result of execution on Ubuntu Linux</p><p>In this example we have saved a bit of work by re-using previous line position specifications. See the next two screenshots.</p><div class="mediaobject"><img src="images/3845_02_04.jpg" height="96" alt="How it works..."/></div><p>The preceding screenshot shows the result of execution on MS Windows XP.<a id="id27" class="indexterm"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec09"/>There's more...</h2></div></div></div><p>Here is where you may see the difference between Linux's and MS Windows's ability to draw dashed lines using Tkinter. The solid portion of the dash was specified as 19 pixels long. On the Linux (Ubuntu9.10) platform this specification was respected but Windows disregarded the instruction.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="A two segment line with a sharp bend"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec05"/>A two segment line with a sharp bend</h1></div></div></div><p>Lines do not have to be straight. A more general type of line can be made up of many straight segments joined together. You simply decide where you want the points that join sections of the multi-segment line and the order in which they should be joined.<a id="id28" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec10"/>How to do it...</h2></div></div></div><p>The instructions are the same as for recipe 1. Just use the name<code class="literal"> sharp_bend.py</code> when you write, save, and execute this program.</p><p>Just make a list of the<code class="literal"> x,y</code> pairs defining each point and place them in the sequence that you want them connected in. The list can be as long as you like.</p><div class="informalexample"><pre class="programlisting">#sharp_bend.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title('Sharp bend')
cw = 300 # canvas width
ch = 200 # canvas height
canvas_1 = Canvas(root, width=cw, height=ch, background="white")
canvas_1.grid(row=0, column=1)
x1 = 50
y1 = 10
x2 = 20
y2 = 80
x3 = 150
y3 = 60
canvas_1.create_line(x1,y1, x2,y2, x3,y3)
root.mainloop()
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec11"/>How it works...</h2></div></div></div><p>For clarity only three points have been defined: first =(x1,y1), second =(x2,y2) and third = (x3, y3). However, there is no limit to the number of sequential points that could be specified.<a id="id29" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3845_02_05.jpg" height="68" alt="How it works..."/></div><p>The preceding screenshot shows the line with a sharp bend.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>There's more...</h2></div></div></div><p>Ultimately you could have complicated figures stored as long sequences of points in files on some storage device. For example, you might want to produce something like a cartoon strip.</p><p>You could construct a library of body parts and face features seen from different angles. There could be a selection of different mouth and eye shapes. The daily chore of assembling your comic strip could be partially automated. One of the things you would need to think about would be how to scale the component parts to be larger or smaller and also how to position them in different places and even rotate them to different angles. All these ideas are developed in this book.</p><p>In particular see the next examples of how complex shapes can be stored and manipulated in a relatively compact form. The<span class="strong"><strong> SVG</strong></span> (<span class="strong"><strong>Scaled Vector Graphics</strong></span>) standard for drawing manipulation, particularly on web pages, uses a similar but different convention for representing shapes. Because both SVG and Tkinter are well defined it means that you can construct code for converting from one form to the other.<a id="id30" class="indexterm"/>
</p><p>Examples of this are shown in<a class="link" href="ch06.html" title="Chapter 6. Working with Pictures"> Chapter 6</a>,</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="A line with a curved bend"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec06"/>A line with a curved bend</h1></div></div></div><p>The most interesting lines are curved. Change the straight, two-segment line of the previous example into a smooth curve that fits parallel to the ends of each segment. Tkinter makes the curve out of 12 straight segments. 12 segments is the default number. However, you can change it to any other sensible number.<a id="id31" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>How to do it...</h2></div></div></div><p>Substitute the line<code class="literal"> canvas_1.create_line(x1,y1, x2,y2, x3,y3)</code> with the line<code class="literal"> canvas_1.create_line(x1,y1, x2,y2, x3,y3, smooth="true")</code>.</p><p>The line is now curved. This is immensely useful when making drawings we only need to specify a minimal number of points and Tkinter fits a curved shape to it.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>How it works...</h2></div></div></div><p>The program output for<code class="literal"> smooth="true"</code> attribute is shown in the next screenshot. The<code class="literal"> smooth='true'</code> attribute hides a large amount of serious mathematical curve manufacture taking place under the hood.</p><p>To fit a curve to a pair of intersecting lines requires the curve and the lines to run parallel at the beginning and end but in the middle an entirely different process known as<span class="strong"><strong> spline fitting</strong></span> is used. The consequence of this is that this kind of curvaceous smoothing is computationally expensive and if you do too much of it your program execution slows down. This has implications for what kinds of action can be successfully animated.<a id="id32" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3845_02_06.jpg" height="86" alt="How it works..."/></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>There's more...</h2></div></div></div><p>What we do later is to use the curve attribute to make more pleasing and exciting shapes. Ultimately you could accumulate for yourself a library of shapes. If you did this you would be re-creating some vector graphics that are freely available from the web. Look at<a class="ulink" href="http://www.openclipart.org"> www.openclipart.org</a>. The pictures which are freely downloadable from this site are in SVG (Scaled Vector Graphics) format. If you look at the code of these pictures in a text editor you will see lines of code that are vaguely similar to the way these Tkinter programs specify the points. Some techniques for extracting useful shapes from existing SVG pictures will be demonstrated in<a class="link" href="ch06.html" title="Chapter 6. Working with Pictures"> Chapter 6</a>,</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Drawing intricate shapes the curly vine"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec07"/>Drawing intricate shapes the curly vine</h1></div></div></div><p>The task here is to draw a complicated shape in such a way that you can use it as a framework to produce unlimited variety and beauty.<a id="id33" class="indexterm"/>
</p><p>We start out with a pencil and paper and draw a curly growing vine shape and transfer it in the simplest and most direct way into some code that will draw it.</p><p>This is a very important example because it reveals the essential elegance of both Python and Tkinter. The central inspiring design philosophy of Python is captured in two words: simplicity and clarity. This is what makes Python one of the best computer coding languages ever conceived.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Getting ready</h2></div></div></div><p>When they want to create a fresh design, most graphic artists start with a pencil and paper sketch because of the uncluttered subconscious freedom it gives. For this example, a complex curve was needed the kind of organic design used in framing pictures in antique books.</p><p>The smooth line was drawn with a pencil on paper and marked off at roughly, evenly spaced intervals with X's. Using a millimeter marked ruler the distance from each x to the left edge and the bottom of the paper was measured approximately. High accuracy is not needed because the curved nature of the line compensates for small imperfections.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>How to do it…</h2></div></div></div><p>These measurements, 32 each in the x and y directions for a Tkinter canvas were typed into separate lists. One called<code class="literal"> x_vine</code> for the x coordinates and<code class="literal"> y_vine</code> for the y coordinates.</p><p>Besides this hand-crafted way of creating the raw shape, the rest of the procedure is identical for all the previous examples.<a id="id34" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"># vine_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title('Curley vine ')
cw = 180 # canvas width.
ch = 160 # canvas height.
canvas_1 = Canvas(root, width=cw, height=ch, background="white")
canvas_1.grid(row=0, column=1)
# The curly vine coordinates as measured from a paper sketch.
vine_x = [23, 20, 11, 9, 29, 52, 56, 39, 24, 32, 53, 69, 63, 47, 35, 35, 51,\
82, 116, 130, 95, 67, 95, 114, 95, 78, 95, 103, 95, 85, 95, 94.5]
vine_y = [36, 44, 39, 22, 16, 32, 56, 72, 91, 117,125, 138, 150, 151, 140, 123, 107,\
92, 70, 41, 5, 41, 66, 41, 24, 41, 53, 41, 33, 41, 41, 39]
#=======================================
# The merging of the separate x and y lists into a single sequence.
#=======================================
Q = [ ]
# Reference copies of the original vine lists - keep the originals # intact
X = vine_x[0:]
Y = vine_y[0:]
# Name the compact, merged x &amp; y list Q
# Merge (alternate interleaves of x and y) into a single polygon of # points.
for i in range(0,len(X)):
Q.append(X[i]) # append the x coordinate
Q.append(Y[i]) # then the y - so they alternate and you end # with a Tkinter polygon.
canvas_1.create_line(Q, smooth='true')
root.mainloop()
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>How it works...</h2></div></div></div><p>The result is shown in the next screenshot which is a smoothed line of 32 straight segments.<a id="id35" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3845_02_07.jpg" width="110" alt="How it works..."/></div><p>The essential trick in this task is to create a list of numbers that is in precisely the correct form to place into a<code class="literal"> create_line()</code> method. It has to be an unbroken sequence, comma-separated, of pairs of matched x and y position coordinates of the complex curve we want to draw.</p><p>So first we create an empty list<code class="literal"> Q[]</code> to which we are going to append alternate values of the x and y coordinates.</p><p>Because we want to leave the original lists<code class="literal"> x_vine</code> and<code class="literal"> y_vine</code> intact (for re-use elsewhere perhaps) we create working copies using:</p><div class="informalexample"><pre class="programlisting">X = vine_x[0:]
Y = vine_y[0:]
</pre></div><p>And finally the magic interleaved merging into one list with:</p><div class="informalexample"><pre class="programlisting">for i in range(0,len(X)):
Q.append(X[i]) # append the x coordinate
Q.append(Y[i]) # then the y
</pre></div><p>The<code class="literal"> for in range()</code> combination and the block of code following it work cyclically through the code starting at<code class="literal"> i=0</code>, increasing one by one each until the last value<code class="literal"> len(X)</code> is reached. Then the block of code is exited and execution continues below the block.<code class="literal"> Len(X)</code> is a function that gives back ('returns' in programmers' parlance) the number of elements in<code class="literal"> X. Q</code> emerges from this perfect for immediate drawing in<code class="literal"> create_line(Q)</code>.</p><p>If you leave out the<code class="literal"> smooth='true'</code> attribute you will see the original join points that came from the original paper draw and measure process.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>There's more...</h2></div></div></div><p>Some interesting effects like curling smoke, charcoal, and glowing neon are produced by copying and transforming the curly vine in various ways in<a class="link" href="ch06.html" title="Chapter 6. Working with Pictures"> Chapter 6</a>,</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Draw a rectangle"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec08"/>Draw a rectangle</h1></div></div></div><p>Draw a basic rectangle by specifying its position, shape, and color attributes as named variables.<a id="id36" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>How to do it...</h2></div></div></div><p>The instructions used in recipe 1 should be used.</p><p>Just use the name<code class="literal"> rectangle.py</code> when you write, save, and execute this program.</p><div class="informalexample"><pre class="programlisting"># rectangle.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title('Basic Rectangle')
cw = 200 # canvas width
ch =130 # canvas height
canvas_1 = Canvas(root, width=cw, height=200, background="white")
canvas_1.grid(row=0, column=1)
x_start = 10
y_start = 30
x_width =70
y_height = 90
kula ="darkblue"
canvas_1.create_rectangle( x_start, y_start,\
x_start + x_width, y_start + y_height, fill=kula)
root.mainloop()
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>How it works...</h2></div></div></div><p>The results are given in the next screenshot showing a basic rectangle.</p><div class="mediaobject"><img src="images/3845_02_08.jpg" width="105" alt="How it works..."/></div><p>When drawing rectangles, circles, ellipses and arcs you specify the start point (the bottom-left corner) and then the end point (top-right corner) of the bounding box surrounding the figure being drawn. In the case of rectangles and squares, the bounding box coincides with the figure. But in the case of circles, ellipses, and arcs the bounding box is of course larger.</p><p>With this recipe we have tried a new way of defining the shape of the rectangle. We give the start point as<code class="literal"> [x_start, y_start]</code> and then we just state the width and height that we want as<code class="literal"> [x_width, y_height]</code>. This way the end point is<code class="literal"> [x_start + x_width, y_start + y_height]</code>. This way you only need to state what the new start point is if you want to create a multiplicity of rectangles having the same height and width.<a id="id37" class="indexterm"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>There's more...</h2></div></div></div><p>In the next example, we use a common shape to draw a series of similar but different rectangles.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Draw overlapping rectangles"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec09"/>Draw overlapping rectangles</h1></div></div></div><p>Draw three overlapping rectangles by changing the numerical values defining their position, shape, and color variables.<a id="id38" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>How to do it...</h2></div></div></div><p>As before the instructions used in recipe 1 should be used.</p><p>Just use the name<code class="literal"> 3rectangles.py</code> when you write, save, and execute this program.</p><div class="informalexample"><pre class="programlisting"># 3rectangles.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title('Overlapping rectangles')
cw = 240 # canvas width
ch = 180 # canvas height
canvas_1 = Canvas(root, width=cw, height=200, background="green")
canvas_1.grid(row=0, column=1)
# dark blue rectangle - painted first therefore at the bottom
x_start = 10
y_start = 30
x_width =70
y_height = 90
kula ="darkblue"
canvas_1.create_rectangle( x_start, y_start,\
x_start + x_width, y_start + y_height, fill=kula)
# dark red rectangle - second therefore in the middle
x_start = 30
y_start = 50
kula ="darkred"
canvas_1.create_rectangle( x_start, y_start,\
x_start + x_width, y_start + y_height, fill=kula)
# dark green rectangle - painted last therefore on top of previous # ones.
x_start = 50
y_start = 70
kula ="darkgreen"
canvas_1.create_rectangle( x_start, y_start,\
x_start + x_width, y_start + y_height, fill=kula)
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>How it works...</h2></div></div></div><p>The results are given in the next screenshot, which shows overlapping rectangles drawn in sequence.<a id="id39" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3845_02_09.jpg" width="143" alt="How it works..."/></div><p>The height and width of the rectangles have been kept the same but their start positions have been shifted to different positions. In addition a common-named variable called<code class="literal"> kula</code> has been used as a common attribute in each<code class="literal"> create-rectangle()</code> method. In between drawing each rectangle a new value is assigned to<code class="literal"> kula</code> to give each successive rectangle a different color.<a id="id40" class="indexterm"/>
</p><p>Just a short comment on color here. Ultimately colors used in Tkinter code are number values with each numerical value specifying how much red, green, and blue to mix together. However, inside the Tkinter libraries are collections of romantically named colors like 'rose pink', 'lime green', and 'cornflower blue'. Each named color is assigned a specific numerical value that creates the color suggested by the name. Sometimes you will see some of these referred to as web colors. Sometimes you assign a name to a color only to have the Python interpreter reject it as unrecognized or use only shades of grey. This tricky topic is sorted out in<a class="link" href="ch05.html" title="Chapter 5. The Magic of Color"> Chapter 5</a>,</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>There's more...</h2></div></div></div><p>The way the attributes of drawn shapes have been specified may appear to be long winded. The programs would be shorter and neater if we just put the absolute numerical values of the parameters inside the methods that draw the functions. In the preceding example, we could have expressed the rectangles as:<a id="id41" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">canvas_1.create_rectangle( 10, 30, 70 ,90, , fill='darkblue')
canvas_1.create_rectangle( 30, 50, 70 ,90, , fill='darkred')
canvas_1.create_rectangle( 50, 70, 70 ,90, , fill='darkgreen')
</pre></div><p>There are good reasons for specifying attribute values outside of the methods.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It allows you to make reusable code that can be used repeatedly regardless of specific values of variables.</li><li class="listitem" style="list-style-type: disc">It makes the code self-explanatory when you use<code class="literal"> x_start</code> instead of a number.</li><li class="listitem" style="list-style-type: disc">It lets you change the values of attributes in a controlled systematic manner. There are many examples of this later.</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Draw concentric squares"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec10"/>Draw concentric squares</h1></div></div></div><p>Draw three concentric squares by changing the numerical values defining its position, shape, and color variables.<a id="id42" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>How to do it...</h2></div></div></div><p>The instructions used in recipe 1 should be used.</p><p>Just use the name<code class="literal"> 3concentric_squares.py</code> when you write, save, and execute this program.</p><div class="informalexample"><pre class="programlisting"># 3concentric_squares.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title('Concentric squares')
cw = 200 # canvas width
ch = 400 # canvas height
canvas_1 = Canvas(root, width=cw, height=200, background="green")
canvas_1.grid(row=0, column=1)
# dark blue
x_center= 100
y_center= 100
x_width= 100
y_height= 100
kula= "darkblue"
canvas_1.create_rectangle( x_center - x_width/2, \
y_center - y_height/2,\
x_center + x_width/2, y_center + y_height/2, fill=kula)
#dark red
x_width= 80
y_height= 80
kula ="darkred"
canvas_1.create_rectangle( x_center - x_width/2, \
y_center - y_height/2,\
x_center + x_width/2, y_center + y_height/2, fill=kula)
#dark green
x_width= 60
y_height= 60
kula ="darkgreen"
canvas_1.create_rectangle( x_center - x_width/2, \
y_center - y_height/2,\
x_center + x_width/2, y_center + y_height/2, fill=kula)
root.mainloop()
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>How it works...</h2></div></div></div><p>The results are given in the next screenshot.<a id="id43" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3845_02_9A.jpg" width="114" alt="How it works..."/></div><p>In this recipe, we have specified where we want the geometric center of the rectangles located. This is at the position<code class="literal"> [x_center, y_center]</code> in each instance. You need to do this whenever you want to draw shapes that are concentric. Generally it is always awkward to try and position the center of some drawn figure by manipulating the bottom-right corner. It does of course mean that there is a small amount of arithmetic in calculating where the bottom-left and top-right corners of the bounding box are but this is a small price to pay for the artistic freedom you gain. You only have to use this technique once and it is at your beck and call forever.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="A circle from an oval"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec11"/>A circle from an oval</h1></div></div></div><p>The best way to draw a circle is to use the Tkinter's<code class="literal"> create_oval()</code> method from the canvas widget.<a id="id44" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>How to do it...</h2></div></div></div><p>The instructions used in the first recipe should be used.</p><p>Just use the name<code class="literal"> circle_1.py</code> when you write, save, and execute this program.</p><div class="informalexample"><pre class="programlisting">#circle_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title('A circle')
cw = 150 # canvas width
ch = 140 # canvas height
canvas_1 = Canvas(root, width=cw, height=ch, background="white")
canvas_1.grid(row=0, column=1)
# specify bottom-left and top-right as a set of four numbers named # 'xy'
xy = 20, 20, 120, 120
canvas_1.create_oval(xy)
root.mainloop()
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>How it works...</h2></div></div></div><p>The results are given in the next screenshot, showing a basic circle.</p><div class="mediaobject"><img src="images/3845_02_10.jpg" width="91" alt="How it works..."/></div><p>A circle is just an ellipse whose height and width are equal. In the example here, we have created a circle with the a very compact-looking statement:<code class="literal"> canvas_1.create_oval(xy)</code>.<a id="id45" class="indexterm"/>
</p><p>The compactness comes from the trick of specifying the dimension attributes as a Python tuple<code class="literal"> xy = 20, 20, 420, 420</code> . It actually would be better in other instances to use a list such as<code class="literal"> xy = [ 20, 20, 420, 420 ]</code> because a list allows you to alter the value of the individual member variables, whereas a tuple is an unchangeable sequence of constant values. Tuples are referred to as immutable.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>There's more...</h2></div></div></div><p>Drawing a circle as a special case of an oval is definitely the best way to draw circles. An inexperienced user of Tkinter may be tempted into using an arc to do the job. This is a mistake because as shown in the next recipe the behavior of the<code class="literal"> create_arc()</code> method does not allow an unblemished circle to be drawn.<a id="id46" class="indexterm"/>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="A circle from an arc"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>A circle from an arc</h1></div></div></div><p>Another way to make a circle is to use the<code class="literal"> create_arc()</code> method. This method may appear to be a more natural way to make circles but it does not allow you to quite complete the circle. If you do try to the circle disappears.<a id="id47" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>How to do it...</h2></div></div></div><p>The instructions used in the first example should be used.</p><p>Just use the name<code class="literal"> arc_circle.py</code> when you write, save and execute this program.</p><div class="informalexample"><pre class="programlisting"># arc_circle.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title('Should be a circle')
cw = 210 # canvas width
ch = 130 # canvas height
canvas_1 = Canvas(root, width=cw, height=ch, background="white")
canvas_1.grid(row=0, column=1)
xy = 20, 20, 320, 320 # bounding box from x0,y0 to x1, y1
# The Arc is drawn from start_angle, in degrees to finish_angle.
# but if you try to complete the circle at 360 degrees it evaporates.
canvas_1.create_arc(xy, start=0, extent=359.999999999, fill="cyan")
root.mainloop()
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec32"/>How it works...</h2></div></div></div><p>The results are given in the next screenshot, showing a failed circle resulting from<code class="literal"> create_arc()</code>.</p><div class="mediaobject"><img src="images/3845_02_11.jpg" width="127" alt="How it works..."/></div><p>Generally the<code class="literal"> create_arc()</code> method is not the best method of making complete circles because an attempt to go from 0 to 360 degrees results in the disappearance of the circle from view. Rather use the<code class="literal"> create_oval()</code> method. However, there are occasions when you need the properties of the<code class="literal"> create_arc()</code> method to be able to create a particular distribution of color. See the color wheel in the later chapters for a good example of this.<a id="id48" class="indexterm"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec33"/>There's more...</h2></div></div></div><p>The<code class="literal"> create_arc()</code> method is well suited to the production of the pie charts favored in corporate presentations. The<code class="literal"> create_arc()</code> method draws a segment of a circle with the ends of the arc joined to the center by radial lines. But if we just want to draw a circle those radial lines are unwanted.<a id="id49" class="indexterm"/>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Three arc ellipses"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Three arc ellipses</h1></div></div></div><p>Three elliptic arcs are drawn.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec34"/>How to do it...</h2></div></div></div><p>The instructions used in recipe 1 should be used.<a id="id50" class="indexterm"/>
</p><p>Just use the name<code class="literal"> 3arc_ellipses.py</code> when you write, save, and execute this program.</p><div class="informalexample"><pre class="programlisting"># 3arc_ellipses.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title('3arc ellipses')
cw = 180 # canvas width
ch = 180 # canvas height
canvas_1 = Canvas(root, width=cw, height=ch)
canvas_1.grid(row=0, column=1)
xy_1 = 20, 80, 80, 20
xy_2 = 20, 130, 80, 100
xy_3 = 100, 130, 140, 20
canvas_1.create_arc(xy_1, start=20, extent=270, fill="red")
canvas_1.create_arc(xy_2, start=-50, extent=290, fill="cyan")
canvas_1.create_arc(xy_3, start=150, extent=-290, fill="blue")
root.mainloop()
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec35"/>How it works...</h2></div></div></div><p>The results are given in the next screenshot, showing well-behaved<code class="literal"> create_arc()</code> ellipses.<a id="id51" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3845_02_12.jpg" width="94" alt="How it works..."/></div><p>The point to note here is that just like rectangles and ovals; the overall shape of the drawn object is governed by the shape of the bounding box. Start and finish (that is extent) angles are expressed in conventional degrees. Note that if trigonometry functions are going to be used then the circular measure has to be radians and not degrees.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec36"/>There's more...</h2></div></div></div><p>The<code class="literal"> create_arc()</code> method has been made user-friendly by requiring angular measurements in degrees rather than radians because most people can visualize degree amounts more easily than radians. But you need to know this is NOT the case with angular measurement in any function used by the math module. All the trigonometric functions like sine, cosine, and tangent use radian angular measurement which are only a minor convenience. The math module provides easy to use conversion functions.<a id="id52" class="indexterm"/>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Polygons"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Polygons</h1></div></div></div><p>Draw a polygon. A polygon is a closed, multi-sided figure. These sides are made up of straight line segments. The specification of points is identical to that of multi-segment lines.<a id="id53" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec37"/>How to do it...</h2></div></div></div><p>The instructions used in recipe 1 should be used.</p><p>Just use the name<code class="literal"> triangle_polygon.py</code> when you write, save, and execute this program.</p><div class="informalexample"><pre class="programlisting"># triangle_polygon.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title('triangle')
cw = 160 # canvas width
ch = 80 # canvas height
canvas_1 = Canvas(root, width=cw, height=ch, background="white")
canvas_1.grid(row=0, column=1)
# point 1 point 2 point 3
canvas_1.create_polygon(140,30, 130,70, 10,50, fill="red")
root.mainloop()
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec38"/>How it works...</h2></div></div></div><p>The results are given in the next screenshot, showing a polygon triangle.</p><div class="mediaobject"><img src="images/3845_02_13.jpg" width="117" alt="How it works..."/></div><p>The<code class="literal"> create_polygon()</code> method draws a sequence of straight line segments between the points specified as the arguments of the method. The final point is automatically joined to the first point to close the figure. As the figure is closed you can fill the interior with color.<a id="id54" class="indexterm"/>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="A star polygon"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>A star polygon</h1></div></div></div><p>Draw a five-pointed star using named variables to specify the polygon attributes so that all the points or vertexes or tips of the star are defined with reference to a single start position. We refer to this position as the anchor position.<a id="id55" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec39"/>How to do it...</h2></div></div></div><p>The instructions used in recipe 1 should be used.</p><p>Just use the name<code class="literal"> star_polygon.py</code> when you write, save, and execute this program.</p><div class="informalexample"><pre class="programlisting"># star_polygon.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title(Polygon')
cw = 140 # canvas width
ch = 80 # canvas height
canvas_1 = Canvas(root, width=cw, height=ch, background="white")
canvas_1.grid(row=0, column=1)
# blue star, anchored to an anchor point.
x_anchor = 15
y_anchor = 50
canvas_1.create_polygon(x_anchor, y_anchor,\
x_anchor + 20, y_anchor - 40,\
x_anchor + 30, y_anchor + 10,\
x_anchor, y_anchor - 30,\
x_anchor + 40, y_anchor - 20,\
fill="blue")
root.mainloop()
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec40"/>How it works...</h2></div></div></div><p>The results are given in the next screenshot, a polygon star.<a id="id56" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3845_02_14.jpg" width="92" alt="How it works..."/></div><p>The first position of the star is the point<code class="literal"> [x_anchor, y_anchor]</code>. All the other points are positive or negative additions to the position of the anchor point. This concept was introduced in the recipes for the three superimposed rectangles. This idea of drawing complicated shapes with reference to a point defined as a pair of named variables is very useful and is used extensively in the second half of this book.</p><p>To improve code readability, the pairs of x and y variables defining each point are laid out vertically making use of the line continuation character \ (backslash).</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Cloning and resizing stars"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Cloning and resizing stars</h1></div></div></div><p>A technique of simultaneous re-positioning and resizing a set of stars is shown.<a id="id57" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec41"/>How to do it...</h2></div></div></div><p>The instructions used in recipe 1 should be used.</p><p>Just use the name<code class="literal"> clone_stars.py</code> when you write, save, and execute this program.</p><div class="informalexample"><pre class="programlisting"># clone_stars.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title('Re-sized and re-positioned polygon stars')
cw = 200 # canvas width
ch = 100 # canvas height
canvas_1 = Canvas(root, width=cw, height=ch, background="white")
canvas_1.grid(row=0, column=1)
# blue star, anchored to an anchor point.
x_anchor = 15
y_anchor = 150
size_scaling = 1
canvas_1.create_polygon(x_anchor, y_anchor,\
x_anchor + 20 * size_scaling, y_anchor - \ 40* size_scaling,\
x_anchor + 30 * size_scaling, y_anchor + \ 10* size_scaling,\
x_anchor, y_anchor - 30* size_scaling,\
x_anchor + 40 * size_scaling, y_anchor - \ 20* size_scaling,\
fill="green")
size_scaling = 2
x_anchor = 80
y_anchor = 120
canvas_1.create_polygon(x_anchor, y_anchor,\
x_anchor + 20 * size_scaling, y_anchor - \ 40* size_scaling,\
x_anchor + 30 * size_scaling, y_anchor + \ 10* size_scaling,\
x_anchor, y_anchor - 30* size_scaling,\
x_anchor + 40 * size_scaling, y_anchor - \ 20* size_scaling,\
starsresizingfill="darkgreen")
size_scaling = 3
x_anchor = 160
y_anchor = 110
canvas_1.create_polygon(x_anchor, y_anchor,\
x_anchor + 20 * size_scaling, y_anchor - \ 40* size_scaling,\
x_anchor + 30 * size_scaling, y_anchor + \ 10* size_scaling,\
x_anchor, y_anchor - 30* size_scaling,\
x_anchor + 40 * size_scaling, y_anchor - \ 20* size_scaling,\
fill="lightgreen")
size_scaling = 3
x_anchor = 160
y_anchor = 110
canvas_1.create_polygon(x_anchor, y_anchor,\
x_anchor + 20 * size_scaling, y_anchor - \ 40* size_scaling,\
x_anchor + 30 * size_scaling, y_anchor + \ 10* size_scaling,\
x_anchor, y_anchor - 30* size_scaling,\
x_anchor + 40 * size_scaling, y_anchor - \ 20* size_scaling,\
fill="forestgreen")
root.mainloop()
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec42"/>How it works...</h2></div></div></div><p>The results are given in the next screenshot, showing a string of stars with changing size.<a id="id59" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3845_02_15.jpg" height="116" alt="How it works..."/></div><p>In addition to the variable and conveniently re-assigned anchor point of the polygon star we have now introduced an amplification factor that can change the size of any particular star without distorting it.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec43"/>There's more...</h2></div></div></div><p>The last three examples have illustrated some important and fundamental ideas used to draw pre-defined shapes in any size and in any position. It was important to separate these effects in different examples at this stage so that the separate actions are easy to understand. Later on, where the effects are used in combination, it becomes difficult to wrap your head around what is happening, particularly if extra transformations like rotation are involved. If we animate code that generates images it can be much easier to understand geometric relationships. By animate, I mean the display of successive images separated by short-time intervals similar to the way images in movies are manipulated. Such time-regulated animation, surprisingly, offers methods of examining the behavior of image-generating code in a way that is much more intuitive and clear to the human brain. This idea is developed in the later chapters.</p></div></div></div>
</body></html>