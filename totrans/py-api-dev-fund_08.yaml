- en: 8\. Pagination, Searching, and Ordering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the pagination function using Flask-SQLAlchemy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serialize the paginated result using marshmallow for the frontend display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build the API with search function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sort and order the returned records in your own way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test all these features using Postman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter covers pagination and how to change the order in which recipes
    are listed, as well as how to add search functionality for recipes and ingredients.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we implemented the `user avatar` and `recipe cover
    image upload` functions. We worked on the image compression function to improve
    the performance of image loading speed. Once an image has been uploaded, users
    can retrieve the URL of the image through an API.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will work on paginating recipe data. We will explain why
    we need to perform pagination. This is an important step in optimizing our API.
    We will also discuss some more important functions, including searching and ordering,
    which I am sure you have come across in other online applications.
  prefs: []
  type: TYPE_NORMAL
- en: Pagination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the testing environment, we may only have a few developers putting recipes
    on the Smilecook platform. There are only a handful of recipes there and performance
    is never a concern. However, in the production environment, that is, after the
    platform has been launched for public use, there could be thousands of users sharing
    recipes on the platform. If you consider social media platforms such as Facebook,
    then the volume will be even bigger.
  prefs: []
  type: TYPE_NORMAL
- en: That's why we need to introduce pagination. Pagination means instead of querying
    the whole population of records from the database, we just query a handful of
    them. When the user wants to see more, they can always go to the next page. For
    example, when you're browsing a shopping site, usually, you will view the items
    for sale a page at a time. Each page may display 40 items, and you have to navigate
    to subsequent pages to view all the items that are available. This is the nature
    of pagination.
  prefs: []
  type: TYPE_NORMAL
- en: The number of records that are shown per page is limited by the page's size.
    This way, there will be a huge saving in server loading time and data transfer
    time, and, most importantly, it will enhance the user's navigation experience.
  prefs: []
  type: TYPE_NORMAL
- en: The good thing here is that we are using a web framework to build our API. This
    kind of common function has already been thought of. We just need to use Flask-SQLAlchemy
    to help us build a paginated API.
  prefs: []
  type: TYPE_NORMAL
- en: Paginated APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A paginated API means that when you query the API, only the data records on
    the current page will be returned. It also includes other information, such as
    the total number of records, the total number of pages, links to other pages,
    and so on. The following is a sample response from a paginated API. It is a serialized
    pagination object, so it is in JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see the following attributes in the HTTP response:'
  prefs: []
  type: TYPE_NORMAL
- en: '`first`: The link to the first page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`last`: The link to the last page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prev`: The link to the previous page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`next`: The link to the next page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page`: The current page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pages`: The total number of pages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`per_page`: The number of records per page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`total`: The total number of records'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data`: The actual data records on this page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These attributes are automatically generated by the pagination object in Flask-SQLAlchemy.
    We just need to serialize the pagination object using marshmallow so that we can
    return the result in JSON format to the frontend client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 50: Implementing Pagination on the Published Recipes Retrieval Function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we''ve discussed the importance of pagination, we want to add this
    functionality to our Smilecook platform. We''ll begin to work on that in this
    exercise. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `pagination.py` in the `schema` folder and import the necessary modules
    and functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `PaginationSchema` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this step, we can see that `PaginationSchema` inherits from `marshmallow.Schema`.
    `PaginationSchema` is used to serialize the pagination object from Flask-SQLAlchemy.
    The `links` attribute is a custom field, which means that we can specify how we
    are going to serialize it. The `get_pagination_links` function will be created
    in *step 4*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: We've explained the other attributes here already. These attributes are required
    in the HTTP response, and so we need to add them to the schema.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can have a different key name in the final JSON response. For example, if
    we want to show `total_count` as the key name instead of `total`, we can use the
    `attribute` parameter like this: `total_count = fields.Integer(dump_only=True,
    attribute=''total'')`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following `get_url` method to `PaginationSchema`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `PaginationSchema.get_url` method is used to generate the URL of the page
    based on the page number. It is taking in the page number parameter and adding
    that to the `request` argument's dictionary. Finally, it encodes and returns the
    new URL, including the page number, as an argument.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: An example of this is if `request.base_url` is `http://localhost:5000/recipes`,
    and `urlencode (query_args)` is giving us `per_page=2&page=1`. The format function
    will stitch them together and return the new URL, that is, `http://localhost:5000/recipes?per_page=2&page=1`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the `get_pagination_links` method to `PaginationSchema`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `PaginationSchema.get_pagination_links` method is used to generate URL links
    to different pages. It gets the page's information from `paginated_objects` and
    relies on the `get_url` method we built in *step 3* to generate the links.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, import `PaginationSchema` in `schemas/recipe.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Delete the following code in `schemas/recipe.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This part of the code has been removed because we are building a pagination
    function. We no longer need to wrap multiple data records with the `data` key.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define `RecipePaginationSchema`, which inherits from `PaginationSchema` in
    `schema/pagination.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you may recall, the attribute name in the final JSON response will be `data`
    here, because that is how it has been defined in `RecipePaginationSchema`. `attribute
    = 'items'` means that it is getting the source data from the `items` to attribute
    in `the pagination` objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, import `acs` and `desc` from `sqlalchemy` into `model/recipe.py` and modify
    the `get_all_published` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `get_all_published` method we built here is used to leverage the `paginate`
    method from Flask-SQLAlchemy. We will filter and order the records, then the paginate
    method takes the `page` and `per_page` parameters and generates a pagination object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import `fields, use_kwargs` and `RecipePaginationSchema` into `resources/recipe.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the `recipe_pagination_schema` attribute in `resources/recipe.py` in
    order to serialize the paginated recipes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `RecipeListResource.get` method in `resources/recipe.py` in order
    to return the paginated recipes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have added the `@user_kwargs` decorator to the `RecipeListResource.get`
    method. The default value for the `page` parameter is 1, while the default value
    for the `per_page` parameter is 20\. This means that if nothing is passed in,
    we will be getting the first page with the first 20 recipe records.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, we pass these two parameters into the `get_all_published` method to get
    the pagination object back. Finally, the paginated recipes will be serialized
    and returned to the frontend client.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have successfully implemented the pagination function and displayed
    the result. In the next exercise, we will test the pagination functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 51: Testing the Pagination Functions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will test the pagination functions that we have just built.
    We will be creating eight recipes in our Smilecook application, and we will publish
    all of them. Then, we will simulate a user scenario in which we will get back
    all the recipes, page by page. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Collections** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, select the **POST Token** request and **Send** a request. This is to
    login to a user account. The result is shown in the following screenshot:![Figure
    8.1: Sending the POST Token request'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_08_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.1: Sending the POST Token request'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Create eight recipes by running the following `httpie` command in the PyCham
    console. The `{token}` placeholder should be replaced with the access token we
    obtained in *step 2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also create the recipes one by one using Postman. We are using the `httpie`
    command here because it's faster.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Publish all eight recipes using the following `httpie` command. Replace the
    `{token}` placeholder with the access token. Make sure that the recipe IDs in
    the URLs are referring to the recipes we created in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we have created and published eight recipes. Next, we will get the recipes
    back page by page with a page size of two recipes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on `per_page`, `2`) into `first`, `last`, and `next` pages. We can't see
    `prev` here because we are on the first page. There is a total of five pages,
    and we have two records per page. You can also see the **sorted** recipe details
    in the HTTP response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, let''s test whether the links in the recipes are working properly. We
    just need to click on the `next` URL link, which will open a new tab in Postman
    with the request URL populated (`http://localhost:5000/recipes?per_page=2&page=2`).
    Then, we just need to click on **Send** to send the request. The result is shown
    in the following screenshot:![Figure 8.3: Testing the links in the recipes'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_08_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.3: Testing the links in the recipes'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Here, we can see that there are links to the `first`, `last`, `next`, and `prev`
    pages. We can also see that we are currently on page 2\. All the recipe data is
    there as well.
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully created our pagination function. Now, I will leave it to
    your capable hands to test it.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of pagination is that you are able to segregate thousands of records
    into pages. Data is retrieved in a page by page manner, and that will reduce the
    server's workload. But what if the user is setting a page size of, say, 100,000?
    How can we prevent a user from exploiting the system loophole? What we can do
    is pass the `max_per_page` parameter for pagination. That will limit the maximum
    page size the user can set. If the user is setting a page size bigger than the
    maximum page size, then the maximum page size will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 13: Implementing Pagination on the User-Specific Recipe Retrieval
    API'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We implemented and tested the pagination function on our all published recipe
    retrieval APIs in the previous exercise. In this activity, we will work on the
    pagination function in the user-specific recipe retrieval API. The corresponding
    API can be found in `UserRecipeListResource`, which is used to get the recipes
    from a specific author. Follow these steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify the `get_all_by_user` method in `model/recipe.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `RecipePaginationSchema` into `resources/user.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare the `recipe_pagination_schema` attribute in `resources/user.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `UserRecipeListResource.get` method in `resources/user.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `@user_kwargs` decorator for `UserRecipeListResource.get`. It takes
    a few parameters, including `page`, `per_page`, and `visibility`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 332.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, you should have completed the pagination function for the user recipe.
    Let's follow the same routine and test the function in the next activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 14: Testing Pagination on the User-Specific Recipe Retrieval API'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will test the user recipe pagination function that we
    just built. We published eight recipes in the previous exercise. We will use them
    here as our test subjects. We are going to create a request in Postman and test
    whether we can get them back, page by page. Follow these steps to complete this
    activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Get all the recipes by the author from the previous exercise using Postman,
    page by page, with a page size of two.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the next URL in the `links` to query for the next two records.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 334.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Recipe Searching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous exercises, we implemented the `pagination` function and also
    saw the benefits of using it. This can greatly reduce the number of recipes that
    are going back to users in one go. From the user's perspective, they can browse
    through different pages to look for the recipe they want.
  prefs: []
  type: TYPE_NORMAL
- en: A better way for the user to look for a recipe is by searching. The search function
    is an essential function on the internet. Look at the search giant Google; their
    search engine brings in huge amounts of revenue. Of course, we are not going to
    implement anything of the scale of Google in our Smilecook application. We will
    be just doing a simple text matching search here.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will implement the search function in our Smilecook
    platform. We will build a recipe searching API that allows the client to provide
    a `q` parameter to search for specific recipes by name or recipe description.
    This can be done by using the `LIKE` comparison operator. The `LIKE` operator
    works by matching the search string with the target string. We can use `%` in
    the search string as a wildcard. If it's not a exact match here it is more like
    a `SIMILAR TO` matching. So, the `%Chicken%` search string will match with the
    `Hainanese Chicken Rice` string.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps a better choice of comparison operator would be `ILIKE`. `LIKE` is case-sensitive,
    while `ILIKE` is case-insensitive. For example, we can't match `Thai Red Curry`
    with `%curry%` using the `LIKE` operator. You can see that `C` is uppercase here.
    However, if we use `ILIKE`, it will match perfectly fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following table to see how the comparison operator works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4: Comparison operators'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C15309_08_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.4: Comparison operators'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In our Smilecook platform, we don't want our search to be that strict. The search
    should be case-insensitive. Now, let's see how we can add this function to our
    Smilecook platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 52: Implementing the Search Function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Having learned about the recipe searching concept, we want to implement this
    as a function in our Smilecook platform. To do this, we will be adding a `q` parameter
    that will pass the search string into the API. Then, we will use the search string
    to look for the recipes we require. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `or_` from `sqlalchemy` into `models/recipe.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `Recipe.get_all_published` method in `models/recipe.py` so that
    it gets all the published recipes that satisfy the search criteria:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code is used to assign the search pattern to the variable `keyword`.
    Then, it searches the `name` and `description` fields by this keyword.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify `RecipeListResource` in `resources/recipe.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We added the `q` parameter to the `user_kwargs` decorator and the `get` function.
    The default for this `q` value is an empty string. The `q` parameter will also
    be passed into the `get_all_published` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now we are done with the search function. Next, we are going to test this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 53: Testing the Search Function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will be testing the search function that we have just
    built. We will test by searching for recipes that contain the `fried rice` string
    in the name or description. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the `RecipeList` request and select the **Params** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the first key-value pair (`q`, `fried rice`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the second key-value pair (`per_page`, `2`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Send the request. The result is shown in the following screenshot:![Figure
    8.5: Searching for recipes that contain the "fried rice" string in the name or
    description'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_08_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.5: Searching for recipes that contain the "fried rice" string in the
    name or description'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Here, we can see four fried rice recipe records, divided into two pages.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, test whether the links in the recipes are still working properly. We
    just need to click on the next URL link, which will open a new tab in Postman
    with the request URL populated (`http://localhost:5000/recipes?q=fried+rice&per_page=2&page=2`).
    Then, we just need to click on **Send** to send the request. The result is shown
    in the following screenshot:![Figure 8.6: Testing whether the links in the recipes
    are working'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_08_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.6: Testing whether the links in the recipes are working'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From the result, we can that we are now on `page 2`. The recipe records are
    also sorted by creation time. The latest recipe is placed on the top.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have created the pagination and searching functions. This is a great
    achievement, but we are not done yet. We need to continue enhancing our Smilecook
    application. Without further ado, let's move on.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and Ordering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sorting is another important feature that helps user navigation. Again, when
    we build any application, we need to keep the user experience in mind. Our application
    could eventually store millions of recipes, so we need to provide an easy way
    for our users to navigate the recipes and find the recipe they want.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, the recipes that we sent back were sorted by time by default. Let's
    implement some other sorting criteria in our Smilecook application. We can still
    keep the default sorting criteria such as time, but we want to allow the user
    to define the searching criteria they want; for example, they can specify that
    they want the recipes to be sorted by cooking time. This is a possibility as the
    user may want to cook a quick meal, which means they will only be interested in
    recipes with short cooking times.
  prefs: []
  type: TYPE_NORMAL
- en: For our Smilecook application, sorting and ordering can be done by adding the
    `sort` and `order` parameters. We can put the sorting criteria (for example, `created_at`,
    `cook_time`, or `num_of_servings`) into the `sort` parameter, and we can use `created_at`
    as the default. The `order` parameter is used to specify whether it is `asc` (ascending
    order) or `desc` (descending order). We can put `desc` as the default.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of the syntax, if we want our SQLAlchemy query result to be sorted
    in ascending order, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want it to be sorted in descending order, we can just use `desc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Instead of `cls.is_published=True`, you can also use the SQLAlchemy column operator,
    that is, `cls.is_published.is_(True)`. You will get the same result.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will implement the sorting and ordering functions in
    our Smilecook platform. This will make our application more user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 54: Implementing Sorting and Ordering'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will implement the sorting and ordering functions in our
    Smilecook platform. We will be adding the `sort` and `order` parameters to the
    get all published recipes API so that users can perform sorting and ordering on
    the published recipes. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `resources/recipe.py`, use the `use_kwargs` `method` in the decorator to
    add two parameters (`sort`, `order`) to the `RecipeListResource.get` method. Set
    the default values for these two parameters to `created_at` and `desc`, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Restrict the `sort` parameter to accept only the `created_at`, `cook_time`,
    and `num_of_servings` values. If other values are passed in, then we''ll default
    to `created_at`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Restrict the `order` parameter to accept only the `asc` and `desc` values.
    If other values are passed in, then we''ll default to `desc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pass the `sort` and `order` parameters into the `get_all_published` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `get_all_published` method in `models/recipe.py` so that it looks
    as follows. It takes in two additional parameters, that is, `sort` and `order`,
    to define the logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have created the sorting and ordering functions. Not many changes were
    made to the code. Next, we are going to test our implementation using Postman.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 55: Testing the Sorting and Ordering Feature'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous exercise, we created customized ordering functions. Users should
    be able to order the recipe records in our Smilecook platform by their specified
    column, and in either ascending or descending order. In this exercise, we will
    test whether that is really the case. We will pass the `sort` and `order` parameters
    into Postman and verify them. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: We will send a request to get all the recipe records back. Then, sort the data
    by `cook_time` in ascending order. First, click on the `RecipeList` request and
    select the **Params** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the first key-value pair (`sort`, `cook_time`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the second key-value pair (`order`, `desc`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Send the request. The result is shown in the following screenshot:![Figure
    8.7: Sending a request to get all the recipe records back'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_08_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.7: Sending a request to get all the recipe records back'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: From the preceding search result, we can see that the recipe's `cook_time` is
    sorted in ascending order. The first recipe's `cook_time` is 20 minutes, whereas
    the second one is 30 minutes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Send a request to get all the recipe records back. Then, sort the data by `num_of_servings`
    in descending order. Click on `RecipeList` and select the **Params** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the first key-value pair (`sort`, `num_of_servings`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the second key-value pair (`order`, `desc`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Send the request. The result is shown in the following screenshot:![Figure
    8.8: Sending a request and sorting the data by num_of_servings in descending order'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_08_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 8.8: Sending a request and sorting the data by num_of_servings in descending
    order'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: From the preceding search result, we can see that the recipe's `num_of_servings`
    has been sorted in descending order. The first recipe's `num_of_servings` is for
    five people, whereas the second one is for four people.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you have finished developing and testing all the functions you have learned
    about in this chapter. Next, we will complete an activity to ensure you have the
    flexibility to use what we have learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 15: Searching for Recipes with Specific Ingredients'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will search the recipes using a specific attribute. We
    will add a new `ingredients` attribute and then pass in parameters to search through
    the recipe. Follow these steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the ingredients attribute to the `Recipe` model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run Flask-Migrate to update the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `ingredients` attribute to `RecipeSchema`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `RecipeResource.patch` method to support the `ingredients` attribute
    update.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `Recipe.get_all_published` method so that you can search through
    the ingredients.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two recipes with the `ingredients` attribute and publish them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for the recipes using the `ingredients` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 336.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Congratulations! You have completed this activity. Now, please work on the assessments
    to test your understanding of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have implemented a lot of great features in this chapter that allows users
    to find the recipe information they want in a simple and efficient manner. The
    pagination function we implemented allows the user to quickly find out how many
    recipes there are in total and navigate them page by page. It also saves the server's
    resources as it doesn't need to render thousands of recipes in one go.
  prefs: []
  type: TYPE_NORMAL
- en: The search function is another time-saving feature. Users can now look for the
    recipes they want by performing a simple search. We have also completed the sorting
    and ordering functions in the Smilecook application, which provide a better browsing
    experience for users.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have created almost all of the user functions we need. Our Smilecook
    platform development is nearing its end. In the next chapter, we will work on
    internal system optimization, such as HTTP caching and rate-limiting.
  prefs: []
  type: TYPE_NORMAL
