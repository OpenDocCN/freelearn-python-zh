["```py\nclass User:\n    def __init__(self, user_id: str, username: str, email: str):\n        self.user_id = user_id\n        self.username = username\n        self.email = email\n        self.posts = []\n    def create_post(self, content: str) -> dict:\n        post = {\n            \"id\": len(self.posts) + 1,\n            \"content\": content,\n            \"likes\": 0         }\n        self.posts.append(post)\n        return post\n    def get_timeline(self) -> list:\n        # Fetch and return the user's timeline\n        # This might involve complex logic to fetch and\n        # sort posts from followed users\n        pass\n    def update_profile(self, new_username: str = None,\n                       new_email: str = None):\n        if new_username:\n            self.username = new_username\n        if new_email:\n            self.email = new_email \n```", "```py\nclass User:\n    def __init__(self, user_id: str, username: str, email: str):\n        self.user_id = user_id\n        self.username = username\n        self.email = email\nclass PostManager:\n    def create_post(self, user: User, content: str):\n        post = {\n            \"id\": self.generate_post_id(),\n            \"user_id\": user.user_id,\n            \"content\": content,\n            \"likes\": 0\n        }\n        # Logic to save the post\n        return post\n    def generate_post_id(self):\n        # Logic to generate a unique post ID\n        pass\nclass TimelineService:\n    def get_timeline(self, user: User) -> list:\n        # Fetch and return the user's timeline\n        # This might involve complex logic to fetch and\n        # sort posts from followed users\n        pass\nclass ProfileManager:\n    def update_profile(self, user: User, new_username: str = None,\n                       new_email: str = None):\n        if new_username:\n            user.username = new_username\n        if new_email:\n            user.email = new_email\n        # Additional logic for profile updates,\n        # like triggering email verification \n```", "```py\nimport unittest\nfrom post_manager import PostManager\nfrom user import User\nclass TestPostManager(unittest.TestCase):\n    def test_create_post(self):\n        user = User(\"123\", \"testuser\", \"test@example.com\")\n        post_manager = PostManager()\n        post = post_manager.create_post(user, \"Hello, world!\")\n\n        self.assertEqual(post[\"user_id\"], \"123\")\n        self.assertEqual(post[\"content\"], \"Hello, world!\")\n        self.assertEqual(post[\"likes\"], 0)\n        self.assertIn(\"id\", post) \n```", "```py\nclass Rectangle:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\nclass Circle:\n    def __init__(self, radius):\n        self.radius = radius\nclass AreaCalculator:\n    def calculate_area(self, shape):\n        if isinstance(shape, Rectangle):\n            return shape.width * shape.height\n        elif isinstance(shape, Circle):\n            return 3.14 * shape.radius ** 2\n        else:\n            raise ValueError(\"Unsupported shape\")\n# Usage\nrectangle = Rectangle(5, 4)\ncircle = Circle(3)\ncalculator = AreaCalculator()\nprint(f\"Rectangle area: {calculator.calculate_area(rectangle)}\")\nprint(f\"Circle area: {calculator.calculate_area(circle)}\") \n```", "```py\nfrom abc import ABC, abstractmethod\nimport math\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        pass\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n\n    def area(self):\n        return self.width * self.height\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n\n    def area(self):\n        return math.pi * self.radius ** 2\nclass AreaCalculator:\n    def calculate_area(self, shape: Shape):\n        return shape.area()\n# Usage\nrectangle = Rectangle(5, 4)\ncircle = Circle(3)\ncalculator = AreaCalculator()\nprint(f\"Rectangle area: {calculator.calculate_area(rectangle)}\")\nprint(f\"Circle area: {calculator.calculate_area(circle)}\")\n# Adding a new shape without modifying AreaCalculator\nclass Triangle(Shape):\n    def __init__(self, base, height):\n        self.base = base\n        self.height = height\n\n    def area(self):\n        return 0.5 * self.base * self.height\ntriangle = Triangle(6, 4)\nprint(f\"Triangle area: {calculator.calculate_area(triangle)}\") \n```", "```py\nfrom abc import ABC, abstractmethod\nclass MultimediaPlayer(ABC):\n    @abstractmethod\n    def play_media(self, file: str) -> None:\n        pass\n    @abstractmethod\n    def stop_media(self) -> None:\n        pass\n    @abstractmethod\n    def display_lyrics(self, file: str) -> None:\n        pass\n    @abstractmethod\n    def apply_video_filter(self, filter: str) -> None:\n        pass\nclass MusicPlayer(MultimediaPlayer):\n    def play_media(self, file: str) -> None:\n        # Implementation for playing music\n        print(f\"Playing music: {file}\")\n    def stop_media(self) -> None:\n        # Implementation for stopping music\n        print(\"Stopping music\")\n    def display_lyrics(self, file: str) -> None:\n        # Implementation for displaying lyrics\n        print(f\"Displaying lyrics for: {file}\")\n    def apply_video_filter(self, filter: str) -> None:\n        # This method doesn't make sense for a MusicPlayer\n        raise NotImplementedError(\n            \"MusicPlayer does not support video filters\")\nclass VideoPlayer(MultimediaPlayer):\n    # Implementation for video player\n    ... \n```", "```py\nfrom abc import ABC, abstractmethod\nclass MediaPlayable(ABC):\n    @abstractmethod\n    def play_media(self, file: str) -> None:\n        pass\n    @abstractmethod\n    def stop_media(self) -> None:\n        pass\nclass LyricsDisplayable(ABC):\n    @abstractmethod\n    def display_lyrics(self, file: str) -> None:\n        pass\nclass VideoFilterable(ABC):\n    @abstractmethod\n    def apply_video_filter(self, filter: str) -> None:\n        pass\nclass MusicPlayer(MediaPlayable, LyricsDisplayable):\n    def play_media(self, file: str) -> None:\n        print(f\"Playing music: {file}\")\n    def stop_media(self) -> None:\n        print(\"Stopping music\")\n    def display_lyrics(self, file: str) -> None:\n        print(f\"Displaying lyrics for: {file}\")\nclass VideoPlayer(MediaPlayable, VideoFilterable):\n    def play_media(self, file: str) -> None:\n        print(f\"Playing video: {file}\")\n    def stop_media(self) -> None:\n        print(\"Stopping video\")\n    def apply_video_filter(self, filter: str) -> None:\n        print(f\"Applying video filter: {filter}\")\nclass BasicAudioPlayer(MediaPlayable):\n    def play_media(self, file: str) -> None:\n        print(f\"Playing audio: {file}\")\n    def stop_media(self) -> None:\n        print(\"Stopping audio\") \n```", "```py\nclass Vehicle:\n    def __init__(self, fuel_capacity: float):\n        self._fuel_capacity = fuel_capacity\n        self._fuel_level = fuel_capacity\n    def fuel_level(self) -> float:\n        return self._fuel_level\n    def consume_fuel(self, distance: float) -> None:\n        # Assume 10 km per liter for simplicity:\n        fuel_consumed = distance / 10\n        if self._fuel_level - fuel_consumed < 0:\n            raise ValueError(\"Not enough fuel to cover the distance\")\n        self._fuel_level -= fuel_consumed \n```", "```py\nclass ElectricCar(Vehicle):\n    def __init__(self, battery_capacity: float):\n        super().__init__(battery_capacity)\n    def consume_fuel(self, distance: float) -> None:\n        # Assume 5 km per kWh for simplicity:\n        energy_consumed = distance / 5\n        if self._fuel_level - energy_consumed < 0:\n            raise ValueError(\"Not enough charge to cover the distance\")\n        self._fuel_level -= energy_consumed \n```", "```py\ndef drive_vehicle(vehicle: Vehicle, distance: float) -> None:\n    initial_fuel = vehicle.fuel_level()\n    vehicle.consume_fuel(distance)\n    fuel_consumed = initial_fuel - vehicle.fuel_level()\n    print(f\"Fuel consumed: {fuel_consumed:.2f} liters\")\n# Usage\ncar = Vehicle(50)  # 50 liter tank\ndrive_vehicle(car, 100)  # Works fine\nelectric_car = ElectricCar(50)  # 50 kWh battery\ndrive_vehicle(electric_car, 100) # This prints incorrect fuel consumption \n```", "```py\nfrom abc import ABC, abstractmethod\nclass PowerSource(ABC):\n    def __init__(self, capacity: float):\n        self._capacity = capacity\n        self._level = capacity\n    def level(self) -> float:\n        return self._level\n    @abstractmethod\n    def consume(self, distance: float) -> float:\n        pass \n```", "```py\nclass FuelTank(PowerSource):\n    def consume(self, distance: float) -> float:\n        # Assume 10 km per liter for simplicity:\n        fuel_consumed = distance / 10\n        if self._level - fuel_consumed < 0:\n            raise ValueError(\"Not enough fuel to cover the distance\")\n        self._level -= fuel_consumed\n        return fuel_consumed\nclass Battery(PowerSource):\n    def consume(self, distance: float) -> float:\n        # Assume 5 km per kWh for simplicity:\n        energy_consumed = distance / 5\n        if self._level – energy_consumed < 0:\n            raise ValueError(\"Not enough charge to cover the distance\")\n        self._level -= energy_consumed\n        return energy_consumed \n```", "```py\nclass Vehicle:\n    def __init__(self, power_source: PowerSource):\n        self._power_source = power_source\n    def power_level(self) -> float:\n        return self._power_source.level()\n    def drive(self, distance: float) -> float:\n        return self._power_source.consume(distance) \n```", "```py\ndef drive_vehicle(vehicle: Vehicle, distance: float) -> None:\n    try:\n        energy_consumed = vehicle.drive(distance)\n        print(f\"Energy consumed: {energy_consumed:.2f} units\")\n    except ValueError as e:\n        print(f\"Unable to complete journey: {e}\")\n# Usage\nfuel_car = Vehicle(FuelTank(50))  # 50 liter tank\ndrive_vehicle(fuel_car, 100)  # Prints: Energy consumed: 10.00 units\nelectric_car = Vehicle(Battery(50))  # 50 kWh battery\ndrive_vehicle(electric_car, 100)  # Prints: Energy consumed: 20.00 units \n```", "```py\nclass A:\n    def __init__(self):\n        self.b = B()\nclass B:\n    def __init__(self):\n        pass \n```", "```py\nclass UserEntity:\n    def __init__(self, user_id: str):\n        self.user_id = user_id\n        # Direct dependency on a low-level module:\n        self.database = MySQLDatabase()\n    def save(self):\n        self.database.insert(\"users\", {\"id\": self.user_id})\nclass MySQLDatabase:\n    def insert(self, table: str, data: dict):\n        print(f\"Inserting {data} into {table} table in MySQL\") \n```", "```py\nfrom abc import ABC, abstractmethod\nclass DatabaseInterface(ABC):\n    @abstractmethod\n    def insert(self, table: str, data: dict):\n        pass\nclass UserEntity:\n    def __init__(self, user_id: str, database: DatabaseInterface):\n        self.user_id = user_id\n        self.database = database\n    def save(self):\n        self.database.insert(\"users\", {\"id\": self.user_id})\nclass MySQLDatabase(DatabaseInterface):\n    def insert(self, table: str, data: dict):\n        print(f\"Inserting {data} into {table} table in MySQL\")\nclass PostgreSQLDatabase(DatabaseInterface):\n    def insert(self, table: str, data: dict):\n        print(f\"Inserting {data} into {table} table in PostgreSQL\")\n# Usage\nmysql_db = MySQLDatabase()\nuser = UserEntity(\"123\", mysql_db)\nuser.save()\npostgres_db = PostgreSQLDatabase()\nanother_user = UserEntity(\"456\", postgres_db)\nanother_user.save() \n```", "```py\nclass MockDatabase(DatabaseInterface):\n    def __init__(self):\n        self.inserted_data = []\n    def insert(self, table: str, data: dict):\n        self.inserted_data.append((table, data))\n# In a test\nmock_db = MockDatabase()\nuser = UserEntity(\"test_user\", mock_db)\nuser.save()\nassert mock_db.inserted_data == [(\"users\", {\"id\": \"test_user\"})] \n```"]