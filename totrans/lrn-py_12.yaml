- en: Chapter 12. Summing Up – A Complete Example
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章. 总结 – 一个完整的示例
- en: '|   | *"Do not dwell in the past, do not dream of the future, concentrate the
    mind on the present moment."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"不要沉溺于过去，不要梦想未来，专注于当下。" |   |'
- en: '|   | --*The Shakyamuni Buddha* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*释迦牟尼佛* |'
- en: In this chapter, I will show you one last project. If you've worked well in
    the rest of the book, this example should be easy. I tried my best to craft it
    in a way that it will neither be too hard for those who have only read the book,
    nor too simple for those who also took the time to work on the examples, and maybe
    have read up on the links and topics I suggested.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向你展示最后一个项目。如果你在本书的其他部分工作得很好，这个例子应该很容易。我尽力让它既不会对只读过书的人太难，也不会对那些也花时间做例子、也许还阅读了我建议的链接和主题的人太简单。
- en: The challenge
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战
- en: 'One problem that we all have these days is remembering passwords. We have passwords
    for everything: websites, phones, cards, bank accounts, and so on. The amount
    of information we have to memorize is just too much, so many people end up using
    the same password over and over again. This is very bad, of course, so at some
    point, tools were invented to alleviate this problem. One of these tools is called
    **KeepassX**, and basically it works like this: you start the software by setting
    up a special password called **master password**. Once inside, you store a record
    for each password you need to memorize, for example, your e-mail account, the
    bank website, credit card information, and so on. When you close the software,
    it encrypts the database used to store all that information, so that the data
    can only be accessed by the owner of the master password. Therefore, kind of in
    a *Lord of The Rings* fashion, by just owning one password, you rule them all.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在都面临的一个问题是记住密码。我们为每件事都有密码：网站、手机、卡片、银行账户等等。我们必须记住的信息量实在太多，所以很多人最终反复使用相同的密码。当然，这非常不好，因此，在某个时候，发明了工具来减轻这个问题。其中之一叫做**KeepassX**，基本上它的工作方式是这样的：你通过设置一个特殊的密码，即**主密码**来启动软件。一旦进入，你将为你需要记住的每个密码存储一个记录，例如，你的电子邮件账户、银行网站、信用卡信息等等。当你关闭软件时，它将加密用于存储所有这些信息的数据库，这样数据就只能由主密码的所有者访问。因此，有点像《指环王》的风格，只需拥有一个密码，就能统治一切。
- en: Our implementation
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的实现
- en: Our goal in this chapter is to create something similar but web-based, and the
    way I want to implement it is by writing two applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的目标是创建一个类似但基于Web的东西，我想要实现它的方式是编写两个应用程序。
- en: One will be an API written in Falcon. Its purpose will be twofold, it will be
    able to both generate and validate passwords. It will provide the caller with
    information about the validity and a score which should indicate how strong the
    password is.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个将是一个用Falcon编写的API。它的目的是双重的，它既能生成也能验证密码。它将为调用者提供有关有效性和评分的信息，评分应表明密码有多强大。
- en: The second application is a Django website, which will provide the interface
    to handle records. Each record will retain information such as the username, e-mail,
    password, URL, and so on. It will show a list of all the records, and it will
    allow the user to create, update and delete them. Passwords will be encrypted
    before being stored in the database.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个应用是一个Django网站，它将提供处理记录的界面。每个记录将保留诸如用户名、电子邮件、密码、URL等信息。它将显示所有记录的列表，并允许用户创建、更新和删除它们。密码在存储到数据库之前将被加密。
- en: The purpose of the whole project is, therefore, to mimic the way KeepassX works,
    even though it is in a much simpler fashion. It will be up to you, if you like
    this idea, to develop it further in order to add other features and make it more
    secure. I will make sure to give you some suggestions on how to extend it, towards
    the end.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 整个项目的目的因此是模仿KeepassX的工作方式，尽管它要简单得多。如果你喜欢这个想法，你可以进一步开发它，以添加其他功能并使其更安全。我保证在最后给你一些如何扩展它的建议。
- en: This chapter will therefore be quite dense, code-wise. It's the price I have
    to pay for giving you an interesting example in a restricted amount of space.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章在代码方面将会相当密集。这是我为了在有限的空间内给你提供一个有趣的例子而必须付出的代价。
- en: 'Before we start, please make sure you are comfortable with the projects presented
    in [Chapter 10](ch10.html "Chapter 10. Web Development Done Right"), *Web Development
    Done Right* so that you''re familiar with the basics of web development. Make
    sure also that you have installed all the `pip` packages needed for this project:
    `django`, `falcon`, `cryptography`, and `nose-parameterized`. If you download
    the source code for the book, you''ll find everything you need to install in the
    `requirements` folder, while the code for this chapter will be in `ch12`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请确保您熟悉[第10章](ch10.html "第10章。正确的Web开发")中介绍的项目，即《正确的Web开发》，以便您熟悉Web开发的基础知识。请确保您已安装此项目所需的全部`pip`包：`django`、`falcon`、`cryptography`和`nose-parameterized`。如果您下载了本书的源代码，您将在`requirements`文件夹中找到所有需要安装的内容，而本章的代码将在`ch12`中。
- en: Implementing the Django interface
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Django接口
- en: I hope you're comfortable with the concepts presented in [Chapter 10](ch10.html
    "Chapter 10. Web Development Done Right"), *Web Development Done Right* which
    was mostly about Django. If you haven't read it, this is probably a good time,
    before reading on here.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您熟悉[第10章](ch10.html "第10章。正确的Web开发")中介绍的概念，该章节主要关于Django。如果您还没有阅读，这可能是在这里继续阅读之前的好时机。
- en: The setup
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置
- en: 'In your root folder (`ch12`, for me), which will contain the root for the interface
    and the root for the API, start by running this command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的根目录（对我来说是`ch12`），其中将包含接口的根目录和API的根目录，首先运行以下命令：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will create the structure for a Django project, which we know well by
    now. I''ll show you the final structure of the interface project here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个Django项目的结构，我们现在非常熟悉。我将在这里向您展示接口项目的最终结构：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As usual, don''t worry if you don''t have all the files, we''ll add them gradually.
    Change to the `pwdweb` folder, and make sure Django is correctly set up: `$ python
    manage.py runserver` (ignore the warning about unapplied migrations).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，如果您没有所有文件，请不要担心，我们会逐步添加。切换到`pwdweb`文件夹，并确保Django已正确设置：`$ python manage.py
    runserver`（忽略关于未应用迁移的警告）。
- en: 'Shut down the server and create an app: `$ python manage.py startapp records`.
    That is excellent, now we can start coding. First things first, let''s open `pwdweb/settings.py`
    and start by adding `''records''`, at the end of the `INSTALLED_APP` tuple (note
    that the comma is included in the code). Then, go ahead and fix the `LANGUAGE_CODE`
    and `TIME_ZONE` settings according to your preference and finally, add the following
    line at the bottom:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭服务器并创建一个应用：`$ python manage.py startapp records`。太棒了，现在我们可以开始编码了。首先，让我们打开`pwdweb/settings.py`，并在`INSTALLED_APP`元组的末尾添加`'records'`（注意代码中包含逗号）。然后，继续根据您的偏好修复`LANGUAGE_CODE`和`TIME_ZONE`设置，最后在底部添加以下行：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a custom encryption key that has nothing to do with Django settings,
    but we will need it later on, and this is the best place for it to be. Don't worry
    for now, we'll get back to it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个自定义加密密钥，它与Django设置无关，但稍后我们将需要它，这是放置它的最佳位置。现在不用担心，我们很快就会回到它。
- en: The model layer
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型层
- en: 'We need to add just one model for the records application: `Record`. This model
    will represent each record we want to store in the database:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要为记录应用添加一个模型：`Record`。该模型将代表我们想要存储在数据库中的每个记录：
- en: '`records/models.py`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`records/models.py`'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Firstly, we set the `DEFAULT_ENCODING` class attribute to `'utf-8'`, which is
    the most popular type of encoding for the web (and not only the web). We set this
    attribute on the class to avoid hardcoding a string in more than one place.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`DEFAULT_ENCODING`类属性设置为`'utf-8'`，这是网络（以及不仅仅是网络）中最流行的编码类型。我们将此属性设置在类上，以避免在多个地方硬编码字符串。
- en: Then, we proceed to set up all the model's fields. As you can see, Django allows
    you to specify very specific fields, such as `EmailField` and `URLField`. The
    reason why it's better to use these specific fields instead of a plain and simple
    `CharField` is we'll get e-mail and URL validation for free when we create a form
    for this model, which is brilliant.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续设置所有模型的字段。正如您所看到的，Django允许您指定非常具体的字段，例如`EmailField`和`URLField`。之所以建议使用这些特定字段而不是简单的`CharField`，是因为当我们为该模型创建表单时，我们将免费获得电子邮件和URL验证，这是非常棒的。
- en: All the options are quite standard, and we saw them in [Chapter 10](ch10.html
    "Chapter 10. Web Development Done Right"), *Web Development Done Right* but I
    want to point out a few things anyway. Firstly, `title` needs to be unique so
    that each `Record` object has a unique title and we don't want to risk having
    doubles. Each database treats strings a little bit differently, according to how
    it is set up, which engine it runs, and so on, so I haven't made the `title` field
    the primary key for this model, which would have been the natural thing to do.
    I prefer to avoid the pain of having to deal with weird string errors and I am
    happy with letting Django add a primary key to the model automatically.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有选项都非常标准，我们在[第10章](ch10.html "第10章。正确进行Web开发")，*正确进行Web开发*中看到了它们，但我还是想指出几点。首先，`title`需要是唯一的，这样每个`Record`对象都有一个唯一的标题，我们不希望有重复。每个数据库根据其设置、运行的引擎等因素，对字符串的处理方式都略有不同，因此我没有将`title`字段作为此模型的**主键**，这本来是自然的事情。我更喜欢避免处理奇怪字符串错误的痛苦，并且我很高兴让Django自动为模型添加主键。
- en: Another option you should understand is the `null=True, blank=True` couple.
    The former allows the field to be `NULL`, which makes it non-mandatory, while
    the second allows it to be *blank* (that is to say, an empty string). Their use
    is quite peculiar in Django, so I suggest you to take a look at the official documentation
    to understand exactly how to use them.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你应该理解的选择是`null=True, blank=True`这对。前者允许字段为`NULL`，这使得它不是强制的，而第二个允许它为*空白*（也就是说，一个空字符串）。在Django中，它们的使用相当特殊，所以我建议你查看官方文档以了解如何正确使用它们。
- en: 'Finally, the dates: `created` needs to have `auto_add_now=True`, which will
    set the current moment in time on the object when it''s created. On the other
    hand, `last_modified` needs to be updated every time we save the model, hence
    we set `auto_now=True`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关于日期：`created` 需要设置 `auto_add_now=True`，这样在对象创建时就会设置当前时间。另一方面，`last_modified`
    需要在每次保存模型时更新，因此我们将其设置为 `auto_now=True`。
- en: After the field definitions, there are a few methods for encrypting and decrypting
    the password. It is always a very bad idea to save passwords as they are in a
    database, therefore you should always encrypt them before saving them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在字段定义之后，有一些用于加密和解密密码的方法。将密码以原样保存在数据库中总是一个非常糟糕的主意，因此你总是在保存之前加密它们。
- en: Normally, when saving a password, you encrypt it using a **one way encryption**
    algorithm (also known as a **one way hash function**). This means that, once you
    have created the hash, there is no way for you to revert it back to the original
    password.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在保存密码时，你会使用**单向加密**算法（也称为**单向哈希函数**）来加密它。这意味着一旦你创建了哈希值，就没有办法将其还原为原始密码。
- en: 'This kind of encryption is normally used for authentication: the user puts
    their username and password in a form and, on submission, the code fetches the
    hash from the user record in the database and compares it with the hash of the
    password the user has just put in the form. If the two hashes match, it means
    that they were produced by the same password, therefore authentication is granted.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种加密通常用于身份验证：用户将他们的用户名和密码输入到一个表单中，在提交时，代码会从数据库中的用户记录中获取哈希值，并将其与用户刚刚在表单中输入的密码的哈希值进行比较。如果两个哈希值匹配，这意味着它们是由相同的密码产生的，因此认证被授权。
- en: 'In this case though, we need to be able to recover the passwords, otherwise
    this whole application wouldn''t be very useful. Therefore, we will use a so-called
    **symmetric encryption** algorithm to encrypt them. The way this works is very
    simple: the password (called **plaintext**) is passed to an *encrypt* function,
    along with a *secret key*. The algorithm produces an encrypted string (called
    **cyphertext**) out of them, which is what you store in the database. When you
    want to recover the password, you will need the cyphertext and the secret key.
    You feed them to a *decrypt* function, and you get back your original password.
    This is exactly what we need.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，我们需要能够恢复密码，否则整个应用程序将不会非常有用。因此，我们将使用所谓的**对称加密**算法来加密它们。这种方式非常简单：密码（称为**明文**）被传递给一个**加密**函数，以及一个**密钥**。算法将产生一个加密字符串（称为**密文**），这就是你在数据库中存储的内容。当你想要恢复密码时，你需要密文和密钥。你将它们输入到一个**解密**函数中，就能得到原始密码。这正是我们所需要的。
- en: In order to perform symmetric encryption, we need the `cryptography` package,
    which is why I instructed you to install it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行对称加密，我们需要`cryptography`包，这就是为什么我指示你安装它的原因。
- en: All the methods in the `Record` class are very simple. `encrypt_password` and
    `decrypt_password` are shortcuts to `encrypt` and `decrypt` the `password` field
    and reassign the result to itself.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Record`类中的所有方法都非常简单。`encrypt_password`和`decrypt_password`是`encrypt`和`decrypt`对`password`字段的快捷方式，并将结果重新分配给自己。'
- en: The `encrypt` and `decrypt` methods are dispatchers for the `cypher` method,
    and `_to_str` and `_to_bytes` are just a couple of helpers. The `cryptography`
    library works with *bytes* objects, so we need those helpers to go back and forth
    between bytes and strings, using a common encoding.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`encrypt`和`decrypt`方法是对`cypher`方法的分发器，而`_to_str`和`_to_bytes`只是几个辅助函数。`cryptography`库与*字节*对象一起工作，因此我们需要这些辅助函数在字节和字符串之间来回转换，使用一个常见的编码。'
- en: The only interesting logic is in the `cypher` method. I could have coded it
    directly in the `encrypt` and `decrypt` ones, but that would have resulted in
    a bit of redundancy, and I wouldn't have had the chance to show you a different
    way of accessing an object's attribute, so let's analyze the body of `cypher`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一有趣的逻辑在`cypher`方法中。我可以在`encrypt`和`decrypt`中直接编写代码，但那样会导致一些冗余，而且我没有机会向你展示访问对象属性的不同方式，所以让我们分析`cypher`方法的主体。
- en: We start by creating an instance of the `Fernet` class, which provides us with
    the symmetric encryption functionality we need. We set the instance up by passing
    the secret key in the settings (`ENCRYPTION_KEY`). After creating `fernet`, we
    need to use it. We can use it to either encrypt or decrypt, according to what
    value is given to the `cypher_func` parameter. We use `getattr` to get an attribute
    from an object given the object itself and the name of the attribute. This technique
    allows us to fetch any attribute from an object dynamically.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建`Fernet`类的一个实例，它为我们提供了所需的对称加密功能。我们通过在设置（`ENCRYPTION_KEY`）中传递密钥来设置实例。创建`fernet`后，我们需要使用它。我们可以根据`cypher_func`参数的值来加密或解密。我们使用`getattr`根据对象本身和属性名称从对象中获取属性。这种技术允许我们动态地获取对象的任何属性。
- en: The result of `getattr(fernet, cypher_func)`, with `cyper_func` being `'encrypt'`,
    for example, is the same as `fernet.encrypt`. The `getattr` function returns a
    method, which we then call with the bytes representation of the text argument.
    We then return the result, in string format.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`getattr(fernet, cypher_func)`的结果，例如`cyper_func`为`''encrypt''`时，等同于`fernet.encrypt`。`getattr`函数返回一个方法，然后我们使用文本参数的字节表示调用该方法。然后我们以字符串格式返回结果。'
- en: 'Here''s what this function is equivalent to when it''s called by the encrypt
    dispatcher:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过加密分发器调用此函数时，这个函数相当于以下内容：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When you take the time to understand it properly, you'll see it's not as difficult
    as it sounds.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当你花时间正确理解它时，你会发现它并没有听起来那么困难。
- en: 'So, we have our model, hence it''s time to migrate (I hope you remember that
    this will create the tables in the database for your application):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有了我们的模型，所以现在是时候迁移了（我希望你记得这将为您应用程序创建数据库中的表）：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now you should have a nice database with all the tables you need to run the
    interface application. Go ahead and create a superuser (`$ python manage.py createsuperuser`).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该有一个很好的数据库，其中包含运行界面应用程序所需的所有表。继续创建超级用户（`$ python manage.py createsuperuser`）。
- en: 'By the way, if you want to generate your own encryption key, it is as easy
    as this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果你想生成自己的加密密钥，就像这样一样简单：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A simple form
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的表单
- en: We need a form for the `Record` model, so we'll use the `ModelForm` technique
    we saw in [Chapter 10](ch10.html "Chapter 10. Web Development Done Right"), *Web
    Development Done Right*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个`Record`模型的表单，所以我们将使用我们在[第10章](ch10.html "第10章。正确进行Web开发")中看到的`ModelForm`技术，即《正确进行Web开发》。
- en: '`records/forms.py`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`records/forms.py`'
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We create a `RecordForm` class that inherits from `ModelForm`, so that the form
    is created automatically thanks to the introspection capabilities of Django. We
    only specify which model to use, which fields to display (we exclude the dates,
    which are handled automatically) and we provide minimal styling for the dimensions
    of the notes field, which will be displayed using a `Textarea` (which is a multiline
    text field in HTML).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个继承自`ModelForm`的`RecordForm`类，这样表单就会自动创建，这是由于Django的反射能力。我们只指定要使用哪个模型，显示哪些字段（我们排除了日期，这些由系统自动处理），并为笔记字段的尺寸提供最小样式，该字段将使用`Textarea`（在HTML中是一个多行文本字段）显示。
- en: The view layer
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图层
- en: 'There are a total of five pages in the interface application: home, record
    list, record creation, record update, and record delete confirmation. Hence, there
    are five views that we have to write. As you''ll see in a moment, Django helps
    us a lot by giving us views we can reuse with minimum customization. All the code
    that follows belongs to the `records/views.py` file.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 界面应用总共有五个页面：主页、记录列表、记录创建、记录更新和记录删除确认。因此，我们必须编写五个视图。正如你马上就会看到的，Django通过给我们提供可以最小化定制的可重用视图，在很大程度上帮助我们。接下来的所有代码都属于`records/views.py`文件。
- en: Imports and home view
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入和主页视图
- en: 'Just to break the ice, here are the imports and the view for the home page:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打破僵局，这里有一些导入和主页视图的代码：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We import a few tools from Django. There are a couple of messaging-related objects,
    a URL lazy reverser, and four different types of view. We also import our `Record`
    model and `RecordForm`. As you can see, the `HomeView` class consists of only
    two lines since we only need to specify which template we want to use, the rest
    just reuses the code from `TemplateView`, as it is. It's so easy, it almost feels
    like cheating.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从Django导入了一些工具。有几个与消息相关的对象，一个URL懒加载反转器，以及四种不同类型的视图。我们还导入了我们的`Record`模型和`RecordForm`。正如你所见，`HomeView`类只由两行组成，因为我们只需要指定我们想要使用的模板，其余的只是重用了`TemplateView`的代码，就像这样。这真是太简单了，几乎感觉像是在作弊。
- en: Listing all records
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出所有记录
- en: After the home view, we can write a view to list all the `Record` instances
    that we have in the database.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在主页视图之后，我们可以编写一个视图来列出数据库中所有的`Record`实例。
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'All we need to do is sub-class `TemplateView` again, and override the `get`
    method. We need to do a couple of things: we fetch all the records from the database
    and sort them by `title` (`#1`) and then parse all the records in order to add
    the attribute `plaintext` (`#2`) onto each of them, to show the original password
    on the page. Another way of doing this would be to add a read-only property to
    the `Record` model, to do the decryption on the fly. I''ll leave it to you, as
    a fun exercise, to amend the code to do it.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要再次子类化`TemplateView`，并重写`get`方法。我们需要做几件事情：我们从数据库中检索所有记录，并按`title`排序（`#1`），然后按顺序解析所有记录，以便为每个记录添加属性`plaintext`（`#2`），以在页面上显示原始密码。另一种做法是在`Record`模型中添加一个只读属性，以动态进行解密。我将把它留给你，作为一个有趣的练习，来修改代码以实现这一点。
- en: After recovering and augmenting the records, we put them in the `context` dict
    and finish as usual by invoking `render_to_response`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在恢复和增强记录后，我们将它们放入`context`字典中，并通过调用`render_to_response`按常规完成。
- en: Creating records
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建记录
- en: 'Here''s the code for the creation view:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是创建视图的代码：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A part of its logic has been factored out in order to be reused later on in
    the update view. Let''s start with `EncryptionMixin`. All it does is override
    the `form_valid` method so that, prior to saving a new `Record` instance to the
    database, we make sure we call `encrypt_password` on the object that results from
    saving the form. In other words, when the user submits the form to create a new
    `Record`, if the form validates successfully, then the `form_valid` method is
    invoked. Within this method what usually happens is that an object is created
    out of the `ModelForm` instance, like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 其逻辑的一部分已被提取出来，以便稍后在更新视图中重用。让我们从`EncryptionMixin`开始。它所做的只是重写`form_valid`方法，这样在将新的`Record`实例保存到数据库之前，我们确保在保存表单的结果对象上调用`encrypt_password`。换句话说，当用户提交表单以创建新的`Record`时，如果表单验证成功，则调用`form_valid`方法。在这个方法中，通常会发生的是，从`ModelForm`实例创建一个对象，如下所示：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We need to interfere with this behavior because running this code as it is would
    save the record with the original password, which isn't encrypted. So we change
    this to call `save` on the `form` passing `commit=False`, which creates the `Record`
    instance out of the `form`, but doesn't attempt to save it in the database. Immediately
    afterwards, we encrypt the password on that instance and then we can finally call
    save on it, actually committing it to the database.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要干预这种行为，因为按照原样运行此代码将保存带有原始密码的记录，而这并没有加密。所以我们将其更改为调用`form`上的`save`并传递`commit=False`，这将从`form`创建`Record`实例，但不会尝试将其保存到数据库中。紧接着，我们在该实例上加密密码，然后我们最终可以调用`save`，实际上将其提交到数据库。
- en: Since we need this behavior both for creating and updating records, I have factored
    it out in a mixin.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们既需要在创建记录时也需要在更新记录时实现这种行为，所以我将其提取为一个mixin。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Perhaps, a better solution for this password encryption logic is to create a
    custom `Field` (inheriting from `CharField` is the easiest way to do it) and add
    the necessary logic to it, so that when we handle `Record` instances from and
    to the database, the encryption and decryption logic is performed automatically
    for us. Though more elegant, this solution needs me to digress and explain a lot
    more about Django internals, which is too much for the extent of this example.
    As usual, you can try to do it yourself, if you feel like a challenge.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，对于这个密码加密逻辑的更好解决方案是创建一个自定义的`Field`（从`CharField`继承是最简单的方式）并添加必要的逻辑，这样当我们处理从数据库到`Record`实例的转换时，加密和解密逻辑会自动为我们执行。虽然这种方法更优雅，但需要我更多地偏离主题来解释Django的内部机制，这对于本例的范围来说太多了。像往常一样，如果你觉得这是一个挑战，你可以尝试自己来做。
- en: 'After creating the `EncryptionMixin` class, we can use it in the `RecordCreateView`
    class. We also inherit from two other classes: `SuccessMessageMixin` and `CreateView`.
    The message mixin provides us with the logic to quickly set up a message when
    creation is successful, and the `CreateView` gives us the necessary logic to create
    an object from a form.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`EncryptionMixin`类之后，我们可以在`RecordCreateView`类中使用它。我们还继承了另外两个类：`SuccessMessageMixin`和`CreateView`。消息混合类为我们提供了在创建成功时快速设置消息的逻辑，而`CreateView`则为我们提供了从表单创建对象的必要逻辑。
- en: 'You can see that all we have to code is some customization: the template name,
    the form class, and the success message and URL. Everything else is gracefully
    handled for us by Django.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们唯一需要编写的是一些定制化：模板名称、表单类、成功消息和URL。其他所有事情都由Django优雅地为我们处理。
- en: Updating records
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新记录
- en: The code to update a `Record` instance is only a tiny bit more complicated.
    We just need to add some logic to decrypt the password before we populate the
    form with the record data.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`Record`实例的代码仅稍微复杂一些。我们只需要在将记录数据填充到表单之前，添加一些解密密码的逻辑。
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this view, we still inherit from both `EncryptionMixin` and `SuccessMessageMixin`,
    but the view class we use is `UpdateView`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个视图中，我们仍然继承了`EncryptionMixin`和`SuccessMessageMixin`，但我们使用的视图类是`UpdateView`。
- en: The first four lines are customization as before, we set the template name,
    the form class, the `Record` model, and the success message. We cannot set the
    `success_url` as a class attribute because we want to redirect a successful edit
    to the same edit page for that record and, in order to do this, we need the ID
    of the instance we're editing. No worries, we'll do it another way.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前四行与之前一样是定制化，我们设置了模板名称、表单类、`Record`模型和成功消息。我们不能将`success_url`设置为类属性，因为我们想要将成功的编辑重定向到该记录的相同编辑页面，为了做到这一点，我们需要编辑实例的ID。不用担心，我们会用另一种方式来做。
- en: First, we override `get_context_data` in order to set `'update'` to `True` in
    the `kwargs` argument, which means that a key `'update'` will end up in the `context`
    dict that is passed to the template for rendering the page. We do this because
    we want to use the same template for creating and updating a record, therefore
    we will use this variable in the context to be able to understand in which situation
    we are. There are other ways to do this but this one is quick and easy and I like
    it because it's explicit.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们重写`get_context_data`以在`kwargs`参数中将`'update'`设置为`True`，这意味着一个键`'update'`最终会出现在传递给模板以渲染页面的`context`字典中。我们这样做是因为我们想要使用相同的模板来创建和更新记录，因此我们将在上下文中使用这个变量来理解我们处于哪种情况。还有其他方法可以做到这一点，但这个方法既快又简单，我喜欢它是因为它很明确。
- en: After overriding `get_context_data,` we need to take care of the URL redirection.
    We do this in the `form_valid` method since we know that, if we get there, it
    means the `Record` instance has been successfully updated. We reverse the `'records:edit'`
    view, which is exactly the view we're working on, passing the primary key of the
    object in question. We take that information from `self.object.pk`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在重写`get_context_data`之后，我们需要处理URL重定向。我们在`form_valid`方法中这样做，因为我们知道，如果我们到达那里，这意味着`Record`实例已经成功更新。我们反转了`'records:edit'`视图，这正是我们正在工作的视图，传递了所涉及对象的键。我们从这个`self.object.pk`中获取这个信息。
- en: One of the reasons it's helpful to have the object saved on the view instance
    is that we can use it when needed without having to alter the signature of the
    many methods in the view in order to pass the object around. This design is very
    helpful and allows us to achieve a lot with very few lines of code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个原因使得在视图实例上保存对象很有帮助，那就是我们可以在需要时使用它，而无需修改视图中的许多方法的签名以便传递对象。这种设计非常有帮助，并允许我们用很少的代码实现很多功能。
- en: The last thing we need to do is to decrypt the password on the instance before
    populating the form for the user. It's simple enough to do it in the `get_form_kwargs`
    method, where you can access the `Record` instance in the `kwargs` dict, and call
    `decrypt_password` on it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是在填充用户表单之前解密实例上的密码。在`get_form_kwargs`方法中做这件事很简单，在那里你可以访问`kwargs`字典中的`Record`实例，并对其调用`decrypt_password`。
- en: This is all we need to do to update a record. If you think about it, the amount
    of code we had to write is really very little, thanks to Django class-based views.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们更新记录所需做的全部工作。如果你想想，我们不得不写的代码量真的很少，多亏了Django基于类的视图。
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A good way of understanding which is the best method to override, is to take
    a look at the Django official documentation or, even better in this case, check
    out the source code and look at the class-based views section. You'll be able
    to appreciate how much work has been done there by Django developers so that you
    only have to touch the smallest amounts of code to customize your views.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 了解哪个方法是最好的重写方法的一个好方法是查看Django官方文档，或者在这个情况下，查看源代码并查看基于类的视图部分。你将能够欣赏到Django开发者在这里做了多少工作，这样你只需要触摸最少的代码来定制你的视图。
- en: Deleting records
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除记录
- en: 'Of the three actions, deleting a record is definitely the easiest one. All
    we need is the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三个动作中，删除记录无疑是其中最简单的一个。我们只需要以下代码：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We only need to inherit from `SuccessMessageMixin` and `DeleteView`, which gives
    us all we need. We set up the model and the success URL as class attributes, and
    then we override the `delete` method only to add a nice message that will be displayed
    in the list view (which is where we redirect to after deletion).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要继承`SuccessMessageMixin`和`DeleteView`，这给了我们所有需要的东西。我们设置模型和成功URL作为类属性，然后只重写`delete`方法，以便添加一个将在列表视图中显示的漂亮消息（这是删除后我们重定向到的位置）。
- en: 'We don''t need to specify the template name, since we''ll use a name that Django
    infers by default: `record_confirm_delete.html`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要指定模板名称，因为我们将使用Django默认推断的名称：`record_confirm_delete.html`。
- en: With this final view, we're all set to have a nice interface that we can use
    to handle `Record` instances.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个最终视图，我们就可以拥有一个很好的界面，我们可以用它来处理`Record`实例。
- en: Setting up the URLs
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置URL
- en: Before we move on to the template layer, let's set up the URLs. This time, I
    want to show you the inclusion technique I talked about in [Chapter 10](ch10.html
    "Chapter 10. Web Development Done Right"), *Web Development Done Right*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们转向模板层之前，让我们设置URL。这次，我想向你展示我在第10章中提到的包含技术，*Web Development Done Right*。
- en: '`pwdweb/urls.py`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`pwdweb/urls.py`'
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'These are the URLs for the main project. We have the usual admin, a home page,
    and then for the records section, we include another `urls.py` file, which we
    define in the `records` application. This technique allows for apps to be reusable
    and self-contained. Note that, when including another `urls.py` file, you can
    pass namespace information, which you can then use in functions such as `reverse`,
    or the `url` template tag. For example, we''ve seen that the path to the `RecordUpdateView`
    was `''records:edit''`. The first part of that string is the namespace, and the
    second is the name that we have given to the view, as you can see in the following
    code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是主要项目的URL。我们通常有管理员、主页，然后在记录部分，我们包括另一个`urls.py`文件，我们在`records`应用中定义这个文件。这种技术使得应用可以重用且自包含。请注意，在包含另一个`urls.py`文件时，你可以传递命名空间信息，然后你可以在`reverse`函数或`url`模板标签中使用这些信息。例如，我们已经看到`RecordUpdateView`的路径是`'records:edit'`。这个字符串的第一部分是命名空间，第二部分是我们为视图给出的名称，正如你在以下代码中看到的那样：
- en: '`records/urls.py`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`records/urls.py`'
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We define four different `url` instances. There is one for adding a record,
    which doesn't need primary key information since the object doesn't exist yet.
    Then we have two `url` instances for updating and deleting a record, and for those
    we need to also specify primary key information to be passed to the view. Since
    `Record` instances have integer IDs, we can safely pass them on the URL, following
    good URL design practice. Finally, we define one `url` instance for the list of
    records.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了四个不同的 `url` 实例。有一个用于添加记录，由于对象尚未存在，因此不需要主键信息。然后我们有两个 `url` 实例用于更新和删除记录，对于这些，我们还需要指定要传递给视图的主键信息。由于
    `Record` 实例具有整数 ID，我们可以安全地将它们传递到 URL 上，遵循良好的 URL 设计实践。最后，我们定义了一个 `url` 实例用于记录列表。
- en: All `url` instances have `name` information which is used in views and templates.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `url` 实例都有 `name` 信息，这些信息在视图和模板中使用。
- en: The template layer
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板层
- en: 'Let''s start with the template we''ll use as the basis for the rest:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们将用作其余部分的模板开始：
- en: '`records/templates/records/base.html`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`records/templates/records/base.html`'
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It's very similar to the one I used in [Chapter 10](ch10.html "Chapter 10. Web
    Development Done Right"), *Web Development Done Right* although it is a bit more
    compressed and with one major difference. We will import jQuery in every page.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 它与我用于 [第 10 章](ch10.html "第 10 章。正确进行 Web 开发")，*正确进行 Web 开发* 的模板非常相似，尽管它稍微更紧凑，并且有一个主要的不同之处。我们将在每个页面上导入
    jQuery。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: jQuery is the most popular JavaScript library out there. It allows you to write
    code that works on all the main browsers and it gives you many extra tools such
    as the ability to perform asynchronous calls (**AJAX**) from the browser itself.
    We'll use this library to perform the calls to the API, both to generate and validate
    our passwords. You can download it at [https://jquery.com/](https://jquery.com/),
    and put it in the `pwdweb/records/static/records/js/` folder (you may have to
    amend the import in the template).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 是最受欢迎的 JavaScript 库。它允许你编写在所有主要浏览器上都能工作的代码，并为你提供了许多额外的工具，例如从浏览器本身执行异步调用（**AJAX**）的能力。我们将使用这个库来执行对
    API 的调用，无论是生成还是验证我们的密码。你可以在 [https://jquery.com/](https://jquery.com/) 下载它，并将其放入
    `pwdweb/records/static/records/js/` 文件夹（你可能需要修改模板中的导入）。
- en: I highlighted the only interesting part of this template for you. Note that
    we load the JavaScript library at the end. This is common practice, as JavaScript
    is used to manipulate the page, so loading libraries at the end helps in avoiding
    situations such as JavaScript code failing because the element needed hadn't been
    rendered on the page yet.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我为您突出显示了模板中唯一有趣的部分。请注意，我们是在模板的末尾加载 JavaScript 库。这是一个常见的做法，因为 JavaScript 用于操作页面，所以将库放在末尾有助于避免由于页面上的元素尚未渲染而导致
    JavaScript 代码失败的情况。
- en: Home and footer templates
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主页和页脚模板
- en: 'The home template is very simple:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 主模板非常简单：
- en: '`records/templates/records/home.html`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`records/templates/records/home.html`'
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There is nothing new here when compared to the `home.html` template we saw
    in [Chapter 10](ch10.html "Chapter 10. Web Development Done Right"), *Web Development
    Done Right*. The footer template is actually exactly the same:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在 [第 10 章](ch10.html "第 10 章。正确进行 Web 开发")，*正确进行 Web 开发* 中看到的 `home.html`
    模板相比，这里没有什么新的内容。页脚模板实际上是完全相同的：
- en: '`records/templates/records/footer.html`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`records/templates/records/footer.html`'
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Listing all records
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出所有记录
- en: 'This template to list all records is fairly simple:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用于列出所有记录的模板相当简单：
- en: '`records/templates/records/list.html`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`records/templates/records/list.html`'
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For this template as well, I have highlighted the parts I'd like you to focus
    on. Firstly, I load a custom tags module, `record_extras`, which we'll need later.
    I have also added an anchor at the top, so that we'll be able to put a link to
    it at the bottom of the page, to avoid having to scroll all the way up.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个模板，我也已经突出显示了我希望您关注的部分。首先，我加载了一个自定义标签模块，`record_extras`，我们稍后会用到。我还添加了一个锚点在顶部，这样我们就可以在页面底部放置一个链接到它，以避免需要滚动到顶部。
- en: Then, I included a template to provide me with the HTML code to display Django
    messages. It's a very simple template which I'll show you shortly.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我包含了一个模板，为我提供显示 Django 消息的 HTML 代码。这是一个非常简单的模板，我很快就会向您展示。
- en: 'Then, we define a list of `div` elements. Each `Record` instance has a container
    `div`, in which there are two other main `div` elements: `record-left` and `record-right`.
    In order to display them side by side, I have set this class in the `main.css`
    file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义了一个 `div` 元素的列表。每个 `Record` 实例都有一个容器 `div`，其中包含另外两个主要的 `div` 元素：`record-left`
    和 `record-right`。为了使它们并排显示，我在 `main.css` 文件中设置了此类：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The outermost `div` container (the one with class `record`), has an `id` attribute,
    which I have used as an anchor. This allows us to click on **cancel** on the record
    delete page, so that if we change our minds and don't want to delete the record,
    we can get back to the list page, and at the right position.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最外层的`div`容器（具有`record`类的那个），有一个`id`属性，我已将其用作锚点。这允许我们在记录删除页面上点击**取消**，这样如果我们改变主意，不想删除记录，我们可以回到列表页面，并定位到正确的位置。
- en: Each attribute of the record is then displayed in `div` elements whose class
    is `record-list`. Most of these classes are just there to allow me to set a bit
    of padding and dimensions on the HTML elements.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后记录的每个属性都在具有`record-list`类的`div`元素中显示。这些类中的大多数只是为了让我能够为HTML元素设置一些填充和尺寸。
- en: 'The next interesting bit is the `hide_password` tag, which takes the plaintext,
    which is the unencrypted password. The purpose of this custom tag is to display
    a sequence of `''*''` characters, as long as the original password, so that if
    someone is passing by while you''re on the page, they won''t see your passwords.
    However, hovering on that sequence of `''*''` characters will show you the original
    password in the tooltip. Here''s the code for the `hide_password` tag:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个有趣的部分是`hide_password`标签，它接受明文，即未加密的密码。此自定义标签的目的是显示与原始密码一样多的`'*'`字符，这样如果有人在你浏览页面时经过，他们就不会看到你的密码。然而，将鼠标悬停在该序列的`'*'`字符上会显示原始密码的提示。以下是`hide_password`标签的代码：
- en: '`records/templatetags/record_extras.py`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`records/templatetags/record_extras.py`'
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There is nothing fancy here. We just register this function as a simple tag
    and then we can use it wherever we want. It takes a `password` and puts it as
    a `tooltip` of a `span` element, whose main content is a sequence of `''*''` characters.
    Just note one thing: we need to escape the password, so that we''re sure it won''t
    break our HTML (think of what might happen if the password contained a double-quote
    `` `"` ``, for example).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '这里没有什么特别之处。我们只是将此函数注册为简单的标签，然后我们就可以在需要的地方使用它。它接受一个`password`并将其作为`span`元素的`tooltip`，其主要内容是一系列`''*''`字符。只需注意一点：我们需要转义密码，以确保它不会破坏我们的HTML（想想如果密码包含一个双引号`"`，会发生什么）。 '
- en: As far as the `list.html` template is concerned, the next interesting bit is
    that we set the `readonly` attribute to the `textarea` element, so as not to give
    the impression to the user that they can modify notes on the fly.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 就`list.html`模板而言，下一个有趣的部分是我们将`readonly`属性设置到`textarea`元素上，这样就不会给用户留下他们可以即时修改笔记的印象。
- en: Then, we set a couple of links for each `Record` instance, right at the bottom
    of the container `div`. There is one for the edit page, and another for the delete
    page. Note that we need to pass the `url` tag not only the `namespace:name` string,
    but also the primary key information, as required by the URL setup we made in
    the `urls.py` module for those views.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在容器`div`的底部为每个`Record`实例设置几个链接。有一个用于编辑页面，另一个用于删除页面。请注意，我们需要传递`url`标签不仅包含`namespace:name`字符串，还要传递主键信息，这是我们在`urls.py`模块中为这些视图设置的URL设置所要求的。
- en: Finally, we import the footer and set the link to the anchor on top of the page.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们导入页脚并设置链接到页面顶部的锚点。
- en: 'Now, as promised, here is the code for the messages:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如承诺的那样，这是消息的代码：
- en: '`records/templates/records/messages.html`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`records/templates/records/messages.html`'
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This code takes care of displaying messages only when there is at least one
    to display. We give the `p` tag `class` information to display success messages
    in green and error messages in red.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码确保只有当至少有一条消息需要显示时才会显示消息。我们给`p`标签赋予`class`信息，以便在绿色中显示成功消息，在红色中显示错误消息。
- en: 'If you grab the `main.css` file from the source code for the book, you will
    now be able to visualize the list page (yours will be blank, you still need to
    insert data into it), and it should look something like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从书籍的源代码中获取`main.css`文件，你现在将能够可视化列表页面（你的将是空的，你仍然需要将其插入数据），它应该看起来像这样：
- en: '![Listing all records](img/4715_12_01.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![列出所有记录](img/4715_12_01.jpg)'
- en: As you can see, I have two records in the database at the moment. I'm hovering
    on the password of the first one, which is my platform account at my sister's
    school, and the password is displayed in the tooltip. The division in two `div`
    elements, *left* and *right*, helps in making rows smaller so that the overall
    result is more pleasing to the eye. The important information is on the left and
    the ancillary information is on the right. The row color alternates between a
    very light shade of blue and white.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，目前数据库中有两个记录。我正悬停在第一个的密码上，这是我妹妹学校的平台账户密码，密码在工具提示中显示。将两个`div`元素分成左右两部分，有助于使行更小，从而使整体结果更悦目。重要信息在左侧，辅助信息在右侧。行颜色在非常浅的蓝色和白色之间交替。
- en: Each row has an **edit** and **delete** link, at its bottom left. We'll show
    the pages for those two links right after we see the code for the templates that
    create them.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行底部左侧都有一个**编辑**和**删除**链接。在我们看到创建这些链接的模板代码之后，我们将展示这两个链接的页面。
- en: 'The CSS code that holds all the information for this interface is the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 维护这个界面所有信息的CSS代码如下：
- en: '`records/static/records/css/main.css`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`records/static/records/css/main.css`'
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Please remember, I'm not a CSS guru so just take this file as it is, a fairly
    naive way to provide styling to our interface.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我不是CSS大师，所以请把这个文件当作它本来的样子，一种相当天真地为我们的界面提供样式的方法。
- en: Creating and editing records
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和编辑记录
- en: Now for the interesting part. Creating and updating a record. We'll use the
    same template for both, so we expect some decisional logic to be there that will
    tell us in which of the two situations we are. As it turns out, it will not be
    that much code. The most exciting part of this template, however, is its associated
    JavaScript file which we'll examine right afterwards.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是有趣的部分。创建和更新记录。我们将使用相同的模板，所以我们期望有一些决策逻辑在那里，它会告诉我们我们处于两种情况中的哪一种。实际上，代码不会太多。然而，这个模板最激动人心的部分是其相关的JavaScript文件，我们将在之后立即检查它。
- en: '`records/templates/records/record_add_edit.html`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`records/templates/records/record_add_edit.html`'
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As usual, I have highlighted the important parts, so let's go through this code
    together.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我已经突出显示了重要部分，让我们一起来分析这段代码。
- en: You can see the first bit of decision logic in the `title` block. Similar decision
    logic is also displayed later on, in the header of the page (the `h1` HTML tag),
    and in the `submit` button at the end of the form.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到在`title`块中的第一个决策逻辑。类似的决策逻辑也显示在页面的页眉（`h1` HTML标签）和表单末尾的`submit`按钮上。
- en: Apart from this logic, what I'd like you to focus on is the form and what's
    inside it. We set the action attribute to a dot, which means *this page*, so that
    we don't need to customize it according to which view is serving the page. Also,
    we immediately take care of the *cross-site request forgery* token, as explained
    in [Chapter 10](ch10.html "Chapter 10. Web Development Done Right"), *Web Development
    Done Right*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个逻辑之外，我还想让您关注的是表单及其内容。我们将action属性设置为点，这意味着*这个页面*，这样我们就不需要根据哪个视图在服务页面来定制它。此外，我们立即处理了*跨站请求伪造*令牌，如[第10章](ch10.html
    "第10章。正确进行Web开发")中所述，*正确进行Web开发*。
- en: Note that, this time, we cannot leave the whole form rendering up to Django
    since we want to add in a couple of extra things, so we go down one level of granularity
    and ask Django to render each individual field for us, along with any errors,
    along with its label. This way we still save a lot of effort, and at the same
    time, we can also customize the form as we like. In situations like this, it's
    not uncommon to write a small template to render a field, in order to avoid repeating
    those three lines for each field. In this case though, the form is so small I
    decided to avoid raising the complexity level up any further.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这次我们不能将整个表单的渲染完全交给Django，因为我们想添加一些额外的东西，所以我们需要降低一个粒度级别，并要求Django为我们渲染每个单独的字段，包括任何错误和其标签。这样我们仍然可以节省很多精力，同时我们也可以按我们的喜好自定义表单。在这种情况下，编写一个小模板来渲染字段以避免为每个字段重复那三行代码是很常见的。然而，由于这个表单很小，我决定避免进一步提高复杂性级别。
- en: The `span` element, `pwd-info`, contains the information about the password
    that we get from the API. The two buttons after that, `validate-btn` and `generate-btn`,
    are hooked up with the AJAX calls to the API.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`span`元素`pwd-info`包含我们从API获取的密码信息。之后的两个按钮`validate-btn`和`generate-btn`与API的AJAX调用相关联。'
- en: At the end of the template, in the `scripts` block, we need to load the `api.js`
    JavaScript file which contains the code to work with the API. We also need to
    use `block.super`, which will load whatever code is in the same block in the parent
    template (for example, jQuery). `block.super` is basically the template equivalent
    of a call to `super(ClassName, self)` in Python. It's important to load jQuery
    before our library, since the latter is based on the former.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板的末尾，在`scripts`块中，我们需要加载包含与API交互代码的`api.js`JavaScript文件。我们还需要使用`block.super`，这将加载父模板中同一块中的任何代码（例如，jQuery）。`block.super`基本上是模板中调用`super(ClassName,
    self)`在Python中的等效。在加载我们的库之前，加载jQuery非常重要，因为后者基于前者。
- en: Talking to the API
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与API通信
- en: 'Let''s now take a look at that JavaScript. I don''t expect you to understand
    everything. Firstly, this is a Python book and secondly, you''re supposed to be
    a beginner (though by now, *ninja trained*), so fear not. However, as JavaScript
    has, by now, become essential if you''re dealing with a web environment, having
    a working knowledge of it is extremely important even for a Python developer,
    so try and get the most out of what I''m about to show you. We''ll see the password
    generation first:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看那个JavaScript。我不期望你理解一切。首先，这是一本Python书，其次，你被认为是一个初学者（尽管到现在，*忍者训练*），所以不要害怕。然而，由于JavaScript现在已经变得在处理网络环境时至关重要，即使对于Python开发者来说，掌握它的工作知识也非常重要，所以尽量从我将要展示的内容中获取最大收益。我们首先看看密码生成：
- en: '`records/static/records/js/api.js`'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`records/static/records/js/api.js`'
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Firstly, we set a variable for the base API URL: `baseURL`. Then, we define
    the `getRandomPassword` function, which is very simple. At the beginning, it defines
    the `apiURL` extending `baseURL` with a replacement technique. Even if the syntax
    is different from that of Python, you shouldn''t have any issues understanding
    this line.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为基本API URL设置一个变量：`baseURL`。然后，我们定义`getRandomPassword`函数，它非常简单。一开始，它定义了`apiURL`，通过替换技术扩展`baseURL`。即使语法与Python不同，你也不应该有任何问题理解这一行。
- en: 'After defining the `apiURL`, the interesting bit comes up. We call `$.ajax`,
    which is the jQuery function that performs the AJAX calls. That `$` is a shortcut
    for jQuery. As you can see in the body of the call, it''s a `GET` request to `apiURL`.
    If it succeeds (`success`: ...), an anonymous function is run, which sets the
    value of the `id_password` text field to the second element of the returned data.
    We''ll see the structure of the data when we examine the API code, so don''t worry
    about that now. If an error occurs, we simply alert the user that there was an
    unexpected error.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '在定义了`apiURL`之后，有趣的部分出现了。我们调用`$.ajax`，这是执行AJAX调用的jQuery函数。那个`$`是jQuery的快捷方式。正如你在调用体中看到的，它是对`apiURL`的`GET`请求。如果成功（`success`:
    ...），将运行一个匿名函数，将`id_password`文本字段的值设置为返回数据的第二个元素。当我们检查API代码时，我们将看到数据的结构，所以现在不用担心。如果发生错误，我们只需向用户提醒出现了意外的错误。'
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The reason why the password field in the HTML has `id_password` as the ID is
    due to the way Django renders forms. You can customize this behavior using a custom
    prefix, for example. In this case, I'm happy with the Django defaults.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: HTML中的密码字段为什么有`id_password`作为ID，是因为Django渲染表单的方式。你可以使用自定义前缀来定制这种行为，例如。在这种情况下，我对Django的默认设置感到满意。
- en: After the function definition, we run a couple of lines of code to bind the
    `click` event on the `generate-btn` button to the `getRandomPassword` function.
    This means that, after this code has been run by the browser engine, every time
    we click the `generate-btn` button, the `getRandomPassword` function is called.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数定义之后，我们运行几行代码将`generate-btn`按钮的`click`事件绑定到`getRandomPassword`函数。这意味着在浏览器引擎运行此代码之后，每次我们点击`generate-btn`按钮，都会调用`getRandomPassword`函数。
- en: That wasn't so scary, was it? So let's see what we need for the validation part.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不那么可怕，对吧？所以让我们看看验证部分需要什么。
- en: 'Now there is a value in the **password** field and we want to validate it.
    We need to call the API and inspect its response. Since passwords can have weird
    characters, I don''t want to pass them on the URL, therefore I will use a `POST`
    request, which allows me to put the password in its body. To do this, I need the
    following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在密码字段中有一个值，我们想要验证它。我们需要调用API并检查其响应。由于密码可能包含奇怪的字符，我不想通过URL传递它们，因此我将使用`POST`请求，这允许我将密码放在其主体中。为此，我需要以下代码：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The concept is the same as before, only this time it''s for the `validate-btn`
    button. The body of the AJAX call is similar. We use a `POST` instead of a `GET`
    request, and we define the data as a JSON object, which is the equivalent of using
    `json.dumps({''password'': ''some_pwd''})` in Python.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '这个概念与之前相同，只是这次是为`validate-btn`按钮。AJAX调用的主体类似。我们使用`POST`请求而不是`GET`请求，并将数据定义为JSON对象，这在Python中相当于使用`json.dumps({''password'':
    ''some_pwd''})`。'
- en: The `contentType` line is a quick hack to avoid problems with the CORS preflight
    behavior of the browser. **Cross-origin resource sharing** (**CORS**) is a mechanism
    that allows restricted resources on a web page to be requested from another domain
    outside of the domain from which the request originated. In a nutshell, since
    the API is located at `127.0.0.1:5555` and the interface is running at `127.0.0.1:8000`,
    without this hack, the browser wouldn't allow us to perform the calls. In a production
    environment, you may want to check the documentation for JSONP, which is a much
    better (albeit more complex) solution to this issue.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`contentType`行是一个快速修复，以避免浏览器CORS预检行为的问题。**跨源资源共享**（**CORS**）是一种机制，允许网页上的受限资源从请求源域之外的另一个域请求。简而言之，由于API位于`127.0.0.1:5555`，而接口运行在`127.0.0.1:8000`，没有这个修复，浏览器不会允许我们执行调用。在生产环境中，你可能想检查JSONP的文档，这是一个更好的（尽管更复杂）解决方案。'
- en: The body of the anonymous function which is run if the call succeeds is apparently
    only a bit complicated. All we need to do is understand if the password is valid
    (from `data['valid']`), and assign it a grade and a CSS class based on its score.
    Validity and score information come from the API response.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用成功，匿名函数的主体显然只是稍微复杂一些。我们只需要理解密码是否有效（从`data['valid']`），然后根据其分数分配一个等级和CSS类。有效性和分数信息来自API响应。
- en: 'The only tricky bit in this code is the JavaScript ternary operator, so let''s
    see a comparative example for it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中唯一棘手的部分是JavaScript三元运算符，所以让我们看看一个比较示例：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With this example, you shouldn't have any issue reading the rest of the logic
    in the function. I know, I could have just used a regular `if (...)`, but JavaScript
    coders use the ternary operator all the time, so you should get used to it. It's
    good training to scratch our heads a bit harder in order to understand code.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个示例，你应该没有问题阅读函数中其余的逻辑。我知道，我本可以使用普通的`if (...)`，但JavaScript程序员经常使用三元运算符，所以你应该习惯它。稍微更努力地思考以理解代码是一种很好的训练。
- en: Lastly, I'd like you to take a look at the end of that function. We set the
    `html` of the `pwd-info` span element to the message we assembled (`msg`), and
    then we style it. In one line, we remove all the CSS classes from that element
    (`removeClass()` with no parameters does that), and we add the `infoClass` to
    it. `infoClass` is either `'red'`, `'orange'`, or `'green'`. If you go back to
    the `main.css` file, you'll see them at the bottom.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想让你看看那个函数的末尾。我们将`pwd-info`span元素的`html`设置为组装的消息（`msg`），然后对其进行样式化。在一行中，我们从这个元素中移除所有CSS类（没有参数的`removeClass()`会这样做），并添加`infoClass`。`infoClass`是`'red'`、`'orange'`或`'green'`之一。如果你回到`main.css`文件，你会在底部看到它们。
- en: Now that we've seen both the template code and the JavaScript to make the calls,
    let's see a screenshot of the page. We're going to edit the first record, the
    one about my sister's school.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了模板代码和用于调用的JavaScript，让我们看看页面的截图。我们将编辑第一条记录，关于我妹妹学校的记录。
- en: '![Talking to the API](img/4715_12_02.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![与API对话](img/4715_12_02.jpg)'
- en: In the picture, you can see that I updated the password by clicking on the **Generate**
    **Password** button. Then, I saved the record (so you could see the nice message
    on top), and, finally, I clicked on the **Validate** **Password** button.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在图片中，你可以看到我通过点击**生成** **密码**按钮更新了密码。然后，我保存了记录（所以你能够看到顶部的消息），最后，我点击了**验证** **密码**按钮。
- en: The result is shown in green on the right-hand side of the **Password** field.
    It's strong (23 is actually the maximum score we can get) so the message is displayed
    in a nice shade of green.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 结果在**密码**字段的右侧以绿色显示。它很强（实际上我们能够得到的最高分数是23），所以消息以漂亮的绿色显示。
- en: Deleting records
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除记录
- en: 'To delete a record, go to the list and click on the **delete** link. You''ll
    be redirected to a page that asks you for confirmation; you can then choose to
    proceed and delete the poor record, or to cancel the request and go back to the
    list page. The template code is the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除记录，转到列表并点击**删除**链接。你将被重定向到一个请求你确认的页面；然后你可以选择继续并删除那个可怜的记录，或者取消请求并返回到列表页面。模板代码如下：
- en: '`records/templates/records/record_confirm_delete.html`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`records/templates/records/record_confirm_delete.html`'
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Since this is a template for a standard Django view, we need to use the naming
    conventions adopted by Django. Therefore, the record in question is called **object**
    in the template. The `{{ object }}` tag displays a string representation for the
    object, which is not exactly beautiful at the moment, since the whole line will
    read: **Are you sure you want to delete "Record object"?**.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个标准的Django视图模板，我们需要使用Django采用的命名约定。因此，相关的记录在模板中被称为**object**。`{{ object
    }}`标签显示对象的字符串表示形式，目前并不十分美观，因为整行将读作：**你确定要删除"Record object"吗**？
- en: 'This is because we haven''t added a `__str__` method to our `Model` class yet,
    which means that Python has no idea of what to show us when we ask for a string
    representation of an instance. Let''s change this by completing our model, adding
    the `__str__` method at the bottom of the class body:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们还没有在我们的`Model`类中添加`__str__`方法，这意味着当请求实例的字符串表示形式时，Python并不知道要显示什么。让我们通过完成我们的模型，在类体底部添加`__str__`方法来解决这个问题：
- en: '`records/models.py`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`records/models.py`'
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Restart the server and now the page will read: **Are you sure you want to delete
    "Some Bank"?** where *Some Bank* is the `title` of the record whose **delete**
    link I clicked on.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动服务器，现在页面将显示：**你确定要删除"某些银行"吗**，其中*某些银行*是我点击的**删除**链接的记录的`title`。
- en: We could have just used `{{ object.title }}`, but I prefer to fix the root of
    the problem, not just the effect. Adding a `__str__` method is in fact something
    that you ought to do for all of your models.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用`{{ object.title }}`，但我更喜欢从根本上解决问题，而不仅仅是解决效果。添加`__str__`方法实际上是你应该为所有模型做的事情。
- en: 'The interesting bit in this last template is actually the link for canceling
    the operation. We use the `url` tag to go back to the list view (`records:list`),
    but we add anchor information to it so that it will eventually read something
    like this (this is for `pk=2`):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的模板中，有趣的部分实际上是取消操作的链接。我们使用`url`标签回到列表视图（`records:list`），但我们向其中添加了锚信息，使其最终看起来像这样（这是针对`pk=2`）：
- en: '`http://127.0.0.1:8000/records/#record-2`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://127.0.0.1:8000/records/#record-2`'
- en: This will go back to the list page and scroll down to the container `div` that
    has ID record 2, which is nice.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回到列表页面，并滚动到具有ID记录2的容器`div`，这很好。
- en: This concludes the interface. Even though this section was similar to what we
    saw in [Chapter 10](ch10.html "Chapter 10. Web Development Done Right"), *Web
    Development Done Right*, we've been able to concentrate more on the code in this
    chapter. We've seen how useful Django class-based views are, and we even touched
    on some cool JavaScript. Run `$ python manage.py runserver` and your interface
    should be up and running at `http://127.0.0.1:8000`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了接口。尽管这一节与我们在[第10章](ch10.html "第10章。正确进行Web开发")中看到的内容相似，即《正确进行Web开发》，但我们在这章中更多地关注了代码。我们看到了Django基于类的视图是多么有用，甚至触及了一些酷的JavaScript。运行`$
    python manage.py runserver`，你的界面应该会在`http://127.0.0.1:8000`上启动并运行。
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are wondering, `127.0.0.1` means the `localhost`—your computer—while
    `8000` is the port to which the server is bound, to listen for incoming requests.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有所疑问，`127.0.0.1`意味着`localhost`——你的电脑——而`8000`是服务器绑定的端口，用于监听传入的请求。
- en: Now it's time to spice things up a bit with the second part of this project.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候用这个项目的第二部分来增加一些趣味性了。
- en: Implementing the Falcon API
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Falcon API
- en: 'The structure of the Falcon project we''re about to code is nowhere near as
    extended as the interface one. We''ll code five files altogether. In your `ch12`
    folder, create a new one called `pwdapi`. This is its final structure:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将编写的Falcon项目的结构远不如接口那么复杂。我们将总共编写五个文件。在你的`ch12`文件夹中，创建一个新的名为`pwdapi`的文件。这是它的最终结构：
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The API was all coded using TDD, so we're also going to explore the tests. However,
    I think it's going to be easier for you to understand the tests if you first see
    the code, so we're going to start with that.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 该API全部使用TDD进行编码，因此我们也将探索测试。然而，我认为如果你先看到代码，你将更容易理解测试，所以我们将从代码开始。
- en: The main application
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要应用程序
- en: 'This is the code for the Falcon application:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Falcon应用程序的代码：
- en: '`main.py`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.py`'
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As in the example in [Chapter 10](ch10.html "Chapter 10. Web Development Done
    Right"), *Web Development Done Right*, we start by creating one instance for each
    of the handlers we need, then we create a `falcon.API` object and, by calling
    its `add_route` method, we set up the routing to the URLs of our API. We'll get
    to the definitions of the handlers in a moment. Firstly, we need a couple of helpers.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在[第10章](ch10.html "第10章。正确进行Web开发")的例子中一样，*正确进行Web开发*，我们首先为每个需要的处理程序创建一个实例，然后创建一个`falcon.API`对象，通过调用它的`add_route`方法，我们将设置路由到我们的API的URL。我们稍后会看到处理程序的定义。首先，我们需要一些辅助函数。
- en: Writing the helpers
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写辅助函数
- en: In this section, we will take a look at a couple of classes that we'll use in
    our handlers. It's always good to factor out some logic following the **Single
    Responsibility Principle**.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看我们将用于处理程序的一两个类。按照**单一职责原则**进行逻辑分离总是好的。
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In OOP, the **Single Responsibility Principle** (**SRP**) states that every
    class should have responsibility for a single part of the functionality provided
    by the software, and that responsibility should be entirely encapsulated by the
    class. All of its services should be narrowly aligned with that responsibility.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程（OOP）中，**单一职责原则**（SRP）指出，每个类都应该对其提供的软件功能的一部分负责，并且这种责任应该完全封装在类中。它的所有服务都应该与这种责任紧密一致。
- en: The Single Responsibility Principle is the *S* in **S.O.L.I.D.**, an acronym
    for the first five OOP and software design principles introduced by Robert Martin.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则是**S.O.L.I.D.**中的**S**，这是由罗伯特·马丁（Robert Martin）提出的面向对象和软件设计的前五个原则的首字母缩写。
- en: I heartily suggest you to open a browser and read up on this subject, it is
    very important.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你打开浏览器并阅读这个主题，它非常重要。
- en: 'All the code in the helpers section belongs to the `core/passwords.py` module.
    Here''s how it begins:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数部分的所有代码都属于`core/passwords.py`模块。以下是它的开始部分：
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We'll need to handle some randomized calculations but the most important part
    here is the allowed characters. We will allow letters, digits, and a set of punctuation
    characters. To ease writing the code, we will merge those parts into the `allchars`
    string.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要处理一些随机计算，但这里最重要的部分是允许的字符。我们将允许字母、数字和一组标点符号。为了简化代码编写，我们将这些部分合并到`allchars`字符串中。
- en: Coding the password validator
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写密码验证器
- en: 'The `PasswordValidator` class is my favorite bit of logic in the whole API.
    It exposes an `is_valid` and a `score` method. The latter runs all defined validators
    ("private" methods in the same class), and collects the scores into a single dict
    which is returned as a result. I''ll write this class method by method so that
    it does not get too complicated:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`PasswordValidator`类是整个API中我最喜欢的逻辑部分。它公开了一个`is_valid`和`score`方法。后者运行所有定义的验证器（同一类中的“私有”方法），并将分数收集到一个单一的字典中，作为结果返回。我将按方法逐一编写这个类，以免它变得过于复杂：'
- en: '[PRE33]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It begins by setting `password` (with no leading or trailing spaces) as an instance
    attribute. This way we won't then have to pass it around from method to method.
    All the methods that will follow belong to this class.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先将`password`（没有前导或尾随空格）设置为实例属性。这样我们就不必在方法之间传递它。所有后续的方法都属于这个类。
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A password is valid when its length is greater than 0 and all of its characters
    belong to the `allchars` string. When you read the `is_valid` method, it's practically
    English (that's how amazing Python is). `all` is a built-in function that tells
    you if all the elements of the iterable you feed to it are `True`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当密码的长度大于0且所有字符都属于`allchars`字符串时，密码是有效的。当你阅读`is_valid`方法时，它几乎就是英语（这就是Python的神奇之处）。`all`是一个内置函数，它告诉你你提供给它的可迭代元素是否都是`True`。
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is the other main method. It's very simple, it just prepares a dict with
    all the results from the validators. The only independent bit of logic happens
    at the end, when we sum the grades from each validator and assign it to a `'total'`
    key in the dict, just for convenience.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个主要方法。它非常简单，只是准备一个包含所有验证器结果的字典。唯一独立的逻辑部分发生在最后，当我们从每个验证器中汇总分数并将其分配给字典中的`'total'`键时，只是为了方便。
- en: As you can see, we score a password by length, by letter case, by the presence
    of numbers, and special characters, and, finally, by the ratio between letters
    and numbers. Letters allow a character to be between *26 * 2 = 52* different possible
    choices, while digits allow only 10\. Therefore, passwords whose letters to digits
    ratio is higher are more difficult to crack.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们通过长度、字母大小写、数字和特殊字符的存在以及最后字母和数字之间的比例来评分密码。字母允许字符在 *26 * 2 = 52* 种可能的选择之间，而数字只允许10种。因此，字母与数字比例更高的密码更难破解。
- en: 'Let''s see the length validator:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看长度验证器：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We assign 0 points to passwords whose length is less than four characters, 1
    point for those whose length is less than 8, 3 for a length less than 12, 5 for
    a length less than 16, and 7 for a length of 16 or more.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将0分分配给长度小于4个字符的密码，1分分配给长度小于8个字符的密码，3分分配给长度小于12个字符的密码，5分分配给长度小于16个字符的密码，以及16个或更多长度的密码得7分。
- en: 'In order to avoid a waterfall of `if`/`elif` clauses, I have adopted a functional
    style here. I prepared a `score_list,` which is basically `[0, 0, 0, 0, 1, 1,
    1, 1, 3, ...]`. Then, by enumerating it, I got a (*length, score*) pair for each
    length less than 16\. I put those pairs into a dict, which gives me the equivalent
    in dict form, so it should look like this: `{0:0, 1:0, 2:0, 3:0, 4:1, 5:1, ...}`.
    I then perform a `get` on this dict with the length of the password, setting a
    value of 7 as the default (which will be returned for lengths of 16 or more, which
    are not in the dict).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免一系列的 `if`/`elif` 子句，我在这里采用了函数式风格。我准备了一个 `score_list`，它基本上是 `[0, 0, 0, 0,
    1, 1, 1, 1, 3, ...]`。然后，通过枚举它，我为每个长度小于16的长度得到了一个 (*length, score*) 对。我把这些对放入一个字典中，这给了我字典形式的等效，所以它应该看起来像这样：`{0:0,
    1:0, 2:0, 3:0, 4:1, 5:1, ...}`。然后，我使用密码的长度对这个字典进行 `get` 操作，将默认值设置为7（这将返回长度为16或更多的值，这些值不在字典中）。
- en: I have nothing against `if`/`elif` clauses, of course, but I wanted to take
    the opportunity to show you different coding styles in this final chapter, to
    help you get used to reading code which deviates from what you would normally
    expect. It's only beneficial.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我并不反对 `if`/`elif` 子句，但我想要抓住这个机会在这个最后一章中展示不同的编码风格，帮助你习惯阅读偏离你通常预期的代码。这只会带来好处。
- en: '[PRE37]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The way we validate the case is again with a nice trick. `lower` is `True` when
    the intersection between the password and all lowercase characters is non-empty,
    otherwise it's `False`. `upper` behaves in the same way, only with uppercase characters.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们验证案例的方式再次使用了一个巧妙的技巧。当密码与所有小写字母的交集非空时，`lower` 为 `True`，否则为 `False`。`upper`
    的行为方式相同，只是针对大写字母。
- en: 'To understand the evaluation that happens on the last line, let''s use the
    inside-out technique once more: `lower or upper` is `True` when at least one of
    the two is `True`. When it''s `True`, it will be converted to a `1` by the `int`
    class. This equates to saying, if there is at least one character, regardless
    of the casing, the score gets 1 point, otherwise it stays at 0.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解最后一行的评估，让我们再次使用内部-外部技术：当至少有一个为 `True` 时，`lower or upper` 为 `True`。当它是 `True`
    时，它将被 `int` 类转换为 `1`。这相当于说，如果至少有一个字符，无论大小写，得分增加1分，否则保持在0分。
- en: 'Now for the second part: `lower and upper` is `True` when both of them are
    `True`, which means that we have at least one lowercase and one uppercase character.
    This means that, to crack the password, a brute-force algorithm would have to
    loop through 52 letters instead of just 26\. Therefore, when that''s `True`, we
    get an extra two points.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看第二部分：当两个都为 `True` 时，`lower and upper` 为 `True`，这意味着我们至少有一个小写和一个大写字母。这意味着，为了破解密码，暴力算法必须遍历52个字母而不是仅仅26个。因此，当它是
    `True` 时，我们得到额外的2分。
- en: This validator therefore produces a result in the range (0, 1, 3), depending
    on what the password is.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个验证器根据密码产生一个在（0，1，3）范围内的结果。
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Scoring on the numbers is simpler. If we have at least one number, we get two
    points, otherwise we get 0\. In this case, I used a ternary operator to return
    the result.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对数字的评分更简单。如果我们至少有一个数字，我们得到2分，否则得到0分。在这种情况下，我使用三元运算符来返回结果。
- en: '[PRE39]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The special characters validator has the same logic as the previous one but,
    since special characters add quite a bit of complexity when it comes to cracking
    a password, we have scored four points instead of just two.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊字符验证器与之前的逻辑相同，但由于特殊字符在破解密码时增加了相当多的复杂性，我们得到了4分而不是2分。
- en: The last one validates the ratio between the letters and the digits.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个是验证字母和数字之间的比例。
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: I highlighted the conditional logic in the expressions in the `sum` calls. In
    the first case, we get a 1 for each character whose lowercase version is in `ascii_lowercase`.
    This means that summing all those 1's up gives us exactly the count of all the
    letters. Then, we do the same for the digits, only we use the digits string for
    reference, and we don't need to lowercase the character. When `digits_count` is
    0, `alpha_count / digits_count` would cause a `ZeroDivisionError`, therefore we
    check on `digits_count` and when it's 0 we return 0\. If we have digits, we calculate
    the ceiling of the *letters:digits* ratio, and return it, capped at 7.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 `sum` 调用的表达式中突出了条件逻辑。在第一种情况下，对于每个小写形式在 `ascii_lowercase` 中的字符，我们得到一个 1。这意味着将所有这些
    1 相加，我们就能得到所有字母的确切数量。然后，我们对数字做同样的处理，只是我们使用数字字符串作为参考，并且我们不需要将字符转换为小写。当 `digits_count`
    为 0 时，`alpha_count / digits_count` 会引发 `ZeroDivisionError`，因此我们检查 `digits_count`，当它为
    0 时返回 0。如果我们有数字，我们计算 *letters:digits* 比率的上限，并返回它，上限为 7。
- en: Of course, there are many different ways to calculate a score for a password.
    My aim here is not to give you the finest algorithm to do that, but to show you
    how you could go about implementing it.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有许多不同的方法可以计算密码的分数。我的目标不是给你提供最优秀的算法来做这件事，而是展示你如何着手实现它。
- en: Coding the password generator
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写密码生成器
- en: The password generator is a much simpler class than the validator. However,
    I have coded it so that we won't need to create an instance to use it, just to
    show you yet again a different coding style.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 密码生成器是一个比验证器更简单的类。然而，我这样编写代码是为了我们不需要创建一个实例来使用它，只是为了再次展示不同的编码风格。
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Of the three methods, only the first one is meant to be used. Let''s start
    our analysis with the last one: `_generate_password`.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三种方法中，只有第一种是打算使用的。让我们从最后一种方法开始分析：`_generate_password`。
- en: This method simply takes a length, which is the desired length for the password
    we want, and calls the sample function to get a population of length elements
    out of the `chars` string. The return value of the sample function is a list of
    length elements, and we need to make it a string using `join`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法简单地接受一个长度，这是我们想要的密码的期望长度，然后调用 sample 函数从 `chars` 字符串中获取长度为元素的人口。sample 函数的返回值是一个长度为元素的列表，我们需要使用
    `join` 将其转换为字符串。
- en: 'Before we can call `sample`, think about this, what if the desired length exceeds
    the length of `allchars`? The call would result in `ValueError: Sample larger
    than the population`.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们调用 `sample` 之前，先考虑一下，如果所需的长度超过了 `allchars` 的长度会怎样？这次调用将导致 `ValueError: Sample
    larger than the population`。'
- en: Because of this, we create the `chars` string in a way that it is made by concatenating
    the `allchars` string to itself just enough times to cover the desired length.
    To give you an example, let's say we need a password of 27 characters, and let's
    pretend `allchars` is 10 characters long. `length / len(allchars)` gives 2.7,
    which, when passed to the `ceil` function, becomes 3\. This means that we're going
    to assign `chars` to a triple concatenation of the `allchars` string, hence `chars`
    will be *10 * 3 = 30* characters long, which is enough to cover our requirements.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们以这种方式创建 `chars` 字符串，使其通过将 `allchars` 字符串连接足够多次来覆盖所需的长度。为了给你一个例子，假设我们需要一个
    27 个字符的密码，并且假设 `allchars` 是 10 个字符长。`length / len(allchars)` 得到 2.7，当传递给 `ceil`
    函数时，变为 3。这意味着我们将 `chars` 分配给 `allchars` 字符串的三重连接，因此 `chars` 将是 *10 * 3 = 30* 个字符长，这足以满足我们的要求。
- en: Note that, in order for these methods to be called without creating an instance
    of this class, we need to decorate them with the `classmethod` decorator. The
    convention is then to call the first argument, `cls`, instead of `self`, because
    Python, behind the scenes, will pass the class object to the call.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了能够在不创建这个类的实例的情况下调用这些方法，我们需要用 `classmethod` 装饰器来装饰它们。然后，约定使用第一个参数 `cls`
    而不是 `self`，因为 Python 在幕后会将类对象传递给调用。
- en: The code for `_generate_candidate` is also very simple. We just generate a password
    and, given the length, we calculate its score, and return a tuple (*score, password*).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`_generate_candidate` 的代码也非常简单。我们只是生成一个密码，给定长度，我们计算其分数，并返回一个元组 (*score, password*)。'
- en: We do this so that in the `generate` method we can generate 10 (by default)
    passwords each time the method is called and return the one that has the highest
    score. Since our generation logic is based on a random function, it's always a
    good way to employ a technique like this to avoid worst case scenarios.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是为了在 `generate` 方法中，每次调用该方法时都能生成 10 个（默认）密码，并返回得分最高的那个。由于我们的生成逻辑基于随机函数，因此采用这种技术来避免最坏情况总是好的。
- en: This concludes the code for the helpers.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了辅助代码。
- en: Writing the handlers
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写处理程序
- en: 'As you may have noticed, the code for the helpers isn''t related to Falcon
    at all. It is just pure Python that we can reuse when we need it. On the other
    hand, the code for the handlers is of course based on Falcon. The code that follows
    belongs to the `core/handlers.py` module so, as we did before, let''s start with
    the first few lines:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，辅助代码的代码与 Falcon 完全无关。它只是我们可以重用的纯 Python 代码。另一方面，处理程序的代码当然基于 Falcon。下面的代码属于
    `core/handlers.py` 模块，所以，就像我们之前做的那样，让我们从前面几行开始：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: That was very simple. We import `json`, `falcon`, and our helpers, and then
    we set up a mixin which we'll need in both handlers. The need for this mixin is
    to allow the API to serve requests that come from somewhere else. This is the
    other side of the CORS coin to what we saw in the JavaScript code for the interface.
    In this case, we boldly go where no security expert would ever dare, and allow
    requests to come from any domain (`'*'`). We do this because this is an exercise
    and, in this context, it is fine, but don't do it in production, okay?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单。我们导入 `json`、`falcon` 和我们的辅助工具，然后设置一个混合类，我们将在两个处理程序中使用它。这个混合类的需求是允许 API
    服务来自其他地方的请求。这是我们在接口的 JavaScript 代码中看到的 CORS 问题的另一面。在这种情况下，我们大胆地走向了没有安全专家敢去的地方，允许来自任何域的请求（`'*'`）。我们这样做是因为这是一个练习，在这个上下文中，这是可以的，但请不要在生产环境中这样做，好吗？
- en: Coding the password validator handler
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写密码验证处理程序
- en: This handler will have to respond to a `POST` request, therefore I have coded
    an `on_post` method, which is the way you react to a `POST` request in Falcon.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这个处理程序必须响应一个 `POST` 请求，因此我编写了一个 `on_post` 方法，这是在 Falcon 中响应 `POST` 请求的方式。
- en: '[PRE43]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Let's start with the `on_post` method. First of all, we call the `process_request`
    method, which does a sanity check on the request body. I won't go into finest
    detail because it's taken from the Falcon documentation, and it's a standard way
    of processing a request. Let's just say that, if everything goes well (the highlighted
    part), we get the body of the request (already decoded from JSON) in `req.context['_body']`.
    If things go badly for any reason, we return an appropriate error response.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `on_post` 方法开始。首先，我们调用 `process_request` 方法，它对请求正文进行合理性检查。我不会深入细节，因为它是从
    Falcon 文档中取出的，并且是处理请求的标准方式。让我们简单地说，如果一切顺利（高亮部分），我们会在 `req.context['_body']` 中得到请求的正文（已经从
    JSON 解码）。如果由于任何原因出了问题，我们会返回适当的错误响应。
- en: 'Let''s go back to `on_post`. We fetch the password from the request context.
    At this point, `process_request` has succeeded, but we still don''t know if the
    body was in the correct format. We''re expecting something like: `{''password'':
    ''my_password''}`.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们回到 `on_post`。我们从请求上下文中获取密码。在这个阶段，`process_request` 已经成功，但我们仍然不知道正文是否格式正确。我们期望的是：`{''password'':
    ''my_password''}`。'
- en: So we proceed with caution. We get the value for the `'_body'` key and, if that
    is not present, we return an empty dict. We get the value for `'password'` from
    that. We use `get` instead of direct access to avoid `KeyError` issues.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们小心翼翼地进行。我们获取 `'_body'` 键的值，如果该值不存在，我们返回一个空字典。然后我们从那里获取 `'password'` 的值。我们使用
    `get` 而不是直接访问，以避免 `KeyError` 问题。
- en: If the password is `None,` we simply return a 400 error (bad request). Otherwise,
    we validate it and calculate its score, and then set the result as the body of
    our response.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果密码是 `None`，我们简单地返回一个 400 错误（错误请求）。否则，我们验证它并计算其得分，然后将结果设置为响应的正文。
- en: You can see how easy it is to validate and calculate the score of the password
    in the `parse_password` method, by using our helpers.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `parse_password` 方法看到验证和计算密码得分的简单性，通过使用我们的辅助工具。
- en: 'We return a dict with three pieces of information: `password`, `valid`, and
    `score`. The password information is technically redundant because whoever made
    the request would know the password but, in this case, I think it''s a good way
    of providing enough information for things such as logging, so I added it.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回一个包含三条信息的字典：`password`、`valid`和`score`。密码信息在技术上可能是多余的，因为发起请求的人会知道密码，但在这个情况下，我认为这是一种提供足够信息的好方法，比如用于日志记录，所以我添加了它。
- en: What happens if the JSON-decoded body is not a dict? I will leave it up to you
    to fix the code, adding some logic to cater for that edge case.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果JSON解码后的主体不是一个字典会发生什么？我将把它留给你来修复代码，添加一些逻辑来处理这种情况。
- en: Coding the password generator handler
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写密码生成器处理程序
- en: 'The generator handler has to handle a `GET` request with one query parameter:
    the desired password length.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器处理程序必须处理一个带有单个查询参数的`GET`请求：所需的密码长度。
- en: '[PRE44]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We have a similar `process_request` method. It does a sanity check on the request,
    even though a bit differently from the previous handler. This time, we need to
    make sure that if the length is provided on the query string (which means, for
    example, `http://our-api-url/?length=23`), it's in the correct format. This means
    that `length` needs to be a positive integer.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个类似的`process_request`方法。它对请求进行合理性检查，尽管与前面的处理程序略有不同。这次，我们需要确保如果长度在查询字符串中提供（例如，`http://our-api-url/?length=23`），它应该处于正确的格式。这意味着`length`需要是一个正整数。
- en: So, to validate that, we do an `int` conversion (`req.get_param('length')` returns
    a string), then we assert that `length` is greater than zero and, finally, we
    put it in `context` under the `'_length'` key.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了验证这一点，我们进行`int`转换（`req.get_param('length')`返回一个字符串），然后断言`length`大于零，最后将其放在`context`下的`'_length'`键下。
- en: Doing the `int` conversion of a string which is not a suitable representation
    for an integer raises `ValueError`, while a conversion from a type that is not
    a string raises `TypeError`, therefore we catch those two in the `except` clause.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个字符串不是整数的合适表示时，进行`int`转换会引发`ValueError`，而从不是字符串的类型转换会引发`TypeError`，因此我们在`except`子句中捕获这两个错误。
- en: We also catch `AssertionError`, which is raised by the `assert length > 0` line
    when `length` is not a positive integer. We can then safely guarantee that the
    length is as desired with one single `try`/`except` block.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还捕获由`assert length > 0`行引发的`AssertionError`，当`length`不是一个正整数时。然后我们可以安全地保证长度符合要求，使用一个单独的`try`/`except`块。
- en: Tip
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that, when coding a `try`/`except` block, you should usually try and be
    as specific as possible, separating instructions that would raise different exceptions
    if a problem arose. This would allow you more control over the issue, and easier
    debugging. In this case though, since this is a simple API, it's fine to have
    code which only reacts to a request for which `length` is not in the right format.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在编写`try`/`except`块时，你应该尽量具体，区分在出现问题时可能引发不同异常的指令。这将使你能够更好地控制问题，并更容易进行调试。然而，由于这是一个简单的API，代码只对`length`格式不正确的请求做出反应是可以的。
- en: The code for the `on_get` method is quite straightforward. It starts by processing
    the request, then the length is fetched, falling back to 16 (the default value)
    when it's not passed, and then a password is generated and dumped to JSON, and
    then set to be the body of the response.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_get`方法的代码相当简单。它首先处理请求，然后获取长度，如果没有传递，则回退到默认值16，然后生成一个密码并将其写入JSON，最后将其设置为响应的主体。'
- en: Running the API
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行API
- en: 'In order to run this application, you need to remember that we set the base
    URL in the interface to `http://127.0.0.1:5555`. Therefore, we need the following
    command to start the API:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行这个应用程序，你需要记住我们在界面中设置了基本URL为`http://127.0.0.1:5555`。因此，我们需要以下命令来启动API：
- en: '[PRE45]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Running that will start the app defined in the main module, binding the server
    instance to port `5555` on `localhost`. For more information about Gunicorn, please
    refer to either [Chapter 10](ch10.html "Chapter 10. Web Development Done Right"),
    *Web Development Done Right* or directly to the project's home page ([http://gunicorn.org/](http://gunicorn.org/)).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它将启动主模块中定义的应用程序，将服务器实例绑定到`localhost`上的`5555`端口。有关Gunicorn的更多信息，请参阅第10章[Web
    Development Done Right](ch10.html "第10章。正确进行Web开发")，*Web Development Done Right*或直接访问项目的首页([http://gunicorn.org/](http://gunicorn.org/))。
- en: The code for the API is now complete so if you have both the interface and the
    API running, you can try them out together. See if everything works as expected.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: API的代码现在已经完成，所以如果您同时运行了接口和API，您可以一起尝试它们。看看是否一切如预期工作。
- en: Testing the API
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试API
- en: In this section, let's take a look at the tests I wrote for the helpers and
    for the handlers. Tests for the helpers are heavily based on the `nose_parameterized`
    library, as my favorite testing style is interface testing, with as little patching
    as possible. Using `nose_parameterized` allows me to write tests that are easier
    to read because the test cases are very visible.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们看看我为辅助工具和处理器编写的测试。辅助工具的测试在很大程度上基于`nose_parameterized`库，因为我的最喜欢的测试风格是接口测试，尽可能少地进行修补。使用`nose_parameterized`允许我编写更容易阅读的测试，因为测试用例非常明显。
- en: On the other hand, tests for the handlers have to follow the testing conventions
    for the Falcon library, so they will be a bit different. This is, of course, ideal
    since it allows me to show you even more.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对于处理器的测试必须遵循Falcon库的测试约定，所以它们会有所不同。这当然是理想的，因为它允许我向您展示更多内容。
- en: Due to the limited amount of pages I have left, I'll show you only a part of
    the tests, so make sure you check them out in full in the source code.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我剩余的页面有限，我将只展示部分测试，所以请确保您在源代码中查看完整内容。
- en: Testing the helpers
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试辅助工具
- en: 'Let''s see the tests for the `PasswordGenerator` class:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`PasswordGenerator`类的测试：
- en: '`tests/test_core/test_passwords.py`'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`tests/test_core/test_passwords.py`'
- en: '[PRE46]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Within `test__generate_password_length` we make sure the `_generate_password`
    method handles the length parameter correctly. We generate a password for each
    length in the range [0, 300), and verify that it has the correct length.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在`test__generate_password_length`中，我们确保`_generate_password`方法正确处理长度参数。我们为[0,
    300)范围内的每个长度生成一个密码，并验证其长度是否正确。
- en: In the `test__generate_password_validity` test, we do something similar but,
    this time, we make sure that whatever length we ask for, the generated password
    is valid. We use the `PasswordValidator` class to check for validity.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在`test__generate_password_validity`测试中，我们做类似的事情，但这次我们确保无论我们要求什么长度，生成的密码都是有效的。我们使用`PasswordValidator`类来检查有效性。
- en: Finally, we need to test the `generate` method. The password generation is random,
    therefore, in order to test this function, we need to mock `_generate_candidate`,
    thus controlling its output. We set the `side_effect` argument on its mock to
    be a list of 10 candidates, from which we expect the `generate` method to choose
    the one with the highest score. Setting `side_effect` on a mock to a list causes
    that mock to return the elements of that list, one at a time, each time it's called.
    To avoid ambiguity, the highest score is 21, and only one candidate has scored
    that high. We call the method and make sure that that particular one is the candidate
    which is returned.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要测试`generate`方法。密码生成是随机的，因此，为了测试这个函数，我们需要模拟`_generate_candidate`，从而控制其输出。我们将其模拟的`side_effect`参数设置为包含10个候选者的列表，我们期望`generate`方法选择得分最高的一个。将模拟的`side_effect`设置为列表会导致该模拟每次被调用时逐个返回列表中的元素。为了避免歧义，最高分数是21，只有一个候选者得分这么高。我们调用该方法并确保返回的是那个特定的候选者。
- en: Note
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are wondering why I used those double underscores in the test names,
    it''s very simple: the first one is a separator and the second one is the leading
    underscore that is part of the name of the method under test.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道为什么我在测试名称中使用了双下划线，那很简单：第一个是一个分隔符，第二个是测试方法名称的一部分。
- en: 'Testing the `PasswordValidator` class requires many more lines of code, so
    I''ll show only a portion of these tests:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 测试`PasswordValidator`类需要更多的代码行，所以我只会展示其中的一部分测试：
- en: '`pwdapi/tests/test_core/test_passwords.py`'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`pwdapi/tests/test_core/test_passwords.py`'
- en: '[PRE47]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We start by testing the `is_valid` method. We test whether or not it returns
    `False` when it's fed an empty string, as well as a string made up of only spaces,
    which makes sure we're testing whether we're calling `.strip()` when we assign
    the password.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先测试`is_valid`方法。我们测试当传入一个空字符串，以及仅由空格组成的字符串时，它是否返回`False`，这确保我们在分配密码时调用`.strip()`。
- en: Then, we use all the characters that we want to be accepted to make sure the
    function accepts them.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用所有我们希望被接受的字符来确保函数能够接受它们。
- en: 'I understand the syntax behind the `parameterize.expand` decorator can be challenging
    at first but really, all there is to it is that each tuple consists of an independent
    test case which, in turn, means that the `test_is_valid` test is run individually
    for each tuple, and that the two tuple elements are passed to the method as arguments:
    `valid` and `password`.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我理解`parameterize.expand`装饰器背后的语法一开始可能有点挑战，但事实上，每个元组都包含一个独立的测试用例，这意味着`test_is_valid`测试会为每个元组单独运行，并且两个元组元素作为参数传递给方法：`valid`和`password`。
- en: We then test for invalid characters. We expect them all to fail so we use `param.explicit`,
    which runs the test for each of the characters in that weird string.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们测试无效字符。我们预期它们都会失败，所以我们使用`param.explicit`，它为那个奇怪字符串中的每个字符运行测试。
- en: '[PRE48]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: They all evaluate to `False`, so we're good.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都评估为`False`，所以我们没问题。
- en: '[PRE49]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: To test the `_score_length` method, I created 16 test cases for the lengths
    from 0 to 15\. The body of the test simply makes sure that the score is assigned
    appropriately.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试`_score_length`方法，我创建了从0到15长度的16个测试用例。测试的主体只是确保分数被适当地分配。
- en: '[PRE50]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The preceding test is for lengths from 16 to 254\. We only need to make sure
    that any length after 15 gets 7 as a score.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试是为了长度从16到254的情况。我们只需要确保任何超过15的长度都能得到7分。
- en: 'I will skip over the tests for the other internal methods and jump directly
    to the one for the score method. In order to test it, I want to control exactly
    what is returned by each of the `_score_*` methods so I mock them out and in the
    test, I set a return value for each of them. Note that to mock methods of a class,
    we use a variant of `patch`: `patch.object`. When you set return values on mocks,
    it''s never good to have repetitions because you may not be sure which method
    returned what, and the test wouldn''t fail in the case of a swap. So, always return
    different values. In my case, I am using the first few prime numbers to be sure
    there is no possibility of confusion.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我将跳过其他内部方法的测试，直接跳到对得分方法的测试。为了测试它，我想精确控制每个`_score_*`方法返回的内容，所以我模拟了它们，并在测试中为每个方法设置一个返回值。请注意，为了模拟类的成员方法，我们使用`patch.object`的变体。当你设置模拟的返回值时，重复是不好的，因为你可能不确定哪个方法返回了什么，如果发生交换，测试可能不会失败。所以，总是返回不同的值。在我的情况下，我使用前几个素数来确保没有混淆的可能性。
- en: '[PRE51]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: I want to point out explicitly that the `_score_*` methods are mocked, so I
    set up my `validator` instance by passing an empty string to the class constructor.
    This makes it even more evident to the reader that the internals of the class
    have been mocked out. Then, I just check if the result is the same as what I was
    expecting.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我要明确指出，`_score_*`方法都是模拟的，所以我通过将空字符串传递给类构造函数来设置我的`validator`实例。这使得读者更加明显地意识到类的内部已经被模拟。然后，我只是检查结果是否与我预期的相同。
- en: This last test is the only one in this class in which I used mocks. All the
    other tests for the `_score_*` methods are in an interface style, which reads
    better and usually produces better results.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这个测试是这个类别中唯一一个我使用了模拟的测试。其他所有针对`_score_*`方法的测试都是接口风格，这种风格读起来更好，通常也能产生更好的结果。
- en: Testing the handlers
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试处理器
- en: 'Let''s briefly see one example of a test for a handler:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要看看一个处理器测试的例子：
- en: '`pwdapi/tests/test_core/test_handlers.py`'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`pwdapi/tests/test_core/test_handlers.py`'
- en: '[PRE52]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Because of the tools Falcon gives you to test your handlers, I created a child
    for each of the classes I wanted to test. The only thing I changed (by overriding
    a method) is that in the `process_request` method, which is called by both classes,
    before processing the request I make sure I set the `req` and `resp` arguments
    on the instance. The normal behavior of the `process_request` method is thus not
    altered in any other way. By doing this, whatever happens over the course of the
    test, I'll be able to check against those objects.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Falcon为你提供了测试处理器的工具，我为我想测试的每个类创建了一个子类。我唯一改变的是（通过覆盖一个方法），在`process_request`方法（由两个类调用）在处理请求之前，我确保我设置了实例上的`req`和`resp`参数。因此，`process_request`方法的正常行为在以其他方式没有被改变。通过这样做，无论测试过程中发生什么，我都能检查这些对象。
- en: It's quite common to use tricks like this when testing. We never change the
    code to adapt for a test, it would be bad practice. We find a way of adapting
    our tests to suit our needs.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试时使用这样的技巧是很常见的。我们从不更改代码以适应测试，这会是一种不良的做法。我们找到一种方法来调整我们的测试以适应我们的需求。
- en: '[PRE53]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `before` method is called by the Falcon `TestBase` logic, and it allows
    us to set up the resource we want to test (the handler) and a route for it (which
    is not necessarily the same as the one we use in production).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`before`方法是由Falcon的`TestBase`逻辑调用的，它允许我们设置我们想要测试的资源（处理器）及其路由（这不一定是我们生产中使用的那个）。'
- en: '[PRE54]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This is the test for the happy path. All it does is simulate a `POST` request
    with a JSON payload as body. Then, we inspect the response object. In particular,
    we inspect its status and its body. We make sure that the handler has correctly
    called the validator and returned its results.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这是测试成功的路径。它所做的只是模拟一个带有JSON负载体的`POST`请求。然后，我们检查响应对象。特别是，我们检查其状态和其体。我们确保处理器已正确调用验证器并返回了其结果。
- en: 'We also test the generator handler:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还测试了生成器处理器：
- en: '[PRE55]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: For this one as well, I will only show you the test for the happy path. We mock
    out the `PasswordGenerator` class because we need to control which password it
    will generate and, unless we mock, we won't be able to do it, as it is a random
    process.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个，我也只会展示测试成功的路径。我们模拟了`PasswordGenerator`类，因为我们需要控制它将生成哪种密码，除非我们进行模拟，否则我们无法做到，因为它是一个随机过程。
- en: Once we have correctly set up its return value, we can simulate the request
    again. In this case, it's a `GET` request, with a desired length of 7\. We use
    a technique similar to the one we used for the other handler, and check the response
    status and body.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们正确设置了其返回值，我们就可以再次模拟请求。在这种情况下，它是一个带有7个期望长度的`GET`请求。我们使用与另一个处理器类似的技术，并检查响应状态和体。
- en: These are not the only tests you could write against the API, and the style
    could be different as well. Some people mock often, I tend to mock only when I
    really have to. Just try to see if you can make some sense out of them. I know
    they're not really easy but they'll be good training for you. Tests are extremely
    important so give it your best shot.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不是你针对API可以编写的唯一测试，其风格也可能不同。有些人经常模拟，我倾向于只有在真正需要时才模拟。试着看看你是否能从中找到一些有意义的见解。我知道它们并不容易，但这对你的训练会有好处。测试非常重要，所以请尽力而为。
- en: Where do you go from here?
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你接下来要做什么？
- en: 'If you liked this project and you feel like expanding it, here are a few suggestions:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢这个项目并且想要扩展它，这里有一些建议：
- en: Implement the encryption in the mechanism of a custom Django field.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在自定义Django字段机制中实现加密。
- en: Amend the template for the record list so that you can search for a particular
    record.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改记录列表的模板，以便你可以搜索特定的记录。
- en: Amend the JavaScript to use JSONP with a callback to overcome the CORS issue.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改JavaScript以使用带有回调的JSONP来克服CORS问题。
- en: Amend the JavaScript to fire the validation call when the password field changes.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改JavaScript，以便在密码字段更改时触发验证调用。
- en: Write a Django command that allows you to encrypt and decrypt the database file.
    When you do it from the command line, incorporate that behavior into the website,
    possibly on the home page, so that you don't have access to the records unless
    you are authenticated. This is definitely a hard challenge as it requires either
    another database with an authentication password stored properly with a one way
    hash, or some serious reworking of the data structure used to hold the record
    model data. Even if you don't have the means to do it now, try and think about
    how you would solve this problem.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个Django命令，允许你加密和解密数据库文件。当你从命令行执行时，将这种行为集成到网站中，可能是在主页上，这样除非你经过身份验证，否则你无法访问记录。这绝对是一个挑战，因为它需要另一个数据库，其中存储有正确的单向散列的认证密码，或者对用于存储记录模型数据的结构进行重大修改。即使你现在没有做这件事的手段，也试着想想你会如何解决这个问题。
- en: Set up PostgreSQL on your machine and switch to using it instead of the SQLite
    file that is the default.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的机器上设置PostgreSQL，并切换到使用它而不是默认的SQLite文件。
- en: Add the ability to attach a file to a record.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加将文件附加到记录的能力。
- en: Play with the application, try to find out which features you want to add or
    change, and then do it.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩转这个应用程序，尝试找出你想要添加或更改的功能，然后去做。
- en: Summary
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we''ve worked on a final project that involves an interface
    and an API. We have used two different frameworks to accomplish our goal: Django
    and Falcon. They are very different and have allowed us to explore different concepts
    and techniques to craft our software and make this fun application come alive.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们完成了一个涉及界面和API的最终项目。我们使用了两个不同的框架来实现我们的目标：Django和Falcon。它们非常不同，使我们能够探索不同的概念和技术来构建我们的软件，使这个有趣的应用程序变得生动。
- en: We have seen an example of symmetric encryption and explored code that was written
    in a more functional style, as opposed to a more classic control flow-oriented
    approach. We have reused and extended the Django class-based views, reducing to
    a minimum the amount of code we had to write.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一个对称加密的例子，并探索了以更功能性的风格编写的代码，而不是更经典的以控制流为导向的方法。我们重用了Django基于类的视图，并将需要编写的代码量减少到最小。
- en: When coding the API, we decoupled handling requests from password management.
    This way it's much easier to see which part of the code depends on the Falcon
    framework and which is independent from it.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写API时，我们将处理请求与密码管理解耦。这样，更容易看到代码的哪一部分依赖于Falcon框架，哪一部分与之独立。
- en: Finally, we saw a few tests for the helpers and handlers of the API. We have
    briefly touched on a technique that I use to expand classes under test in order
    to be able to test against those parts of the code which would not normally be
    available.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了一些针对API的辅助程序和处理程序的测试。我们简要地介绍了一种技术，我使用它来扩展测试中的类，以便能够测试那些通常不可用的代码部分。
- en: My aim in this chapter was to provide you with an interesting example that could
    be expanded and improved in different ways. I also wanted to give you a few examples
    of different coding styles and techniques, which is why I chose to spread things
    apart and use different frameworks.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章中的目标是提供一个有趣且可以以不同方式扩展和改进的例子。我还想给你一些不同编码风格和技术的例子，这就是为什么我选择将它们分开，并使用不同的框架。
- en: A word of farewell
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一句告别的话
- en: I hope that you are still thirsty and that this book will be just the first
    of many steps you take towards Python. It's a truly wonderful language, well worth
    learning deeply.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你仍然渴望学习，这本书只是你迈向Python的许多步骤中的第一步。它是一门真正美好的语言，值得深入学习。
- en: I hope that you enjoyed this journey with me, I did my best to make it interesting
    for you. It sure was for me, I had such a great time writing these pages.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你喜欢与我一起的这段旅程，我尽力让它对你来说有趣。对我来说，写作这些页面确实是一次愉快的经历。
- en: Python is open source, so please keep sharing it and consider supporting the
    wonderful community around it.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Python是开源的，所以请继续分享它，并考虑支持围绕它的美好社区。
- en: Till next time, my friend, farewell!
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 到下次见面时，我的朋友，再见！
