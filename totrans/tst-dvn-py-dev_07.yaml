- en: Chapter 7. Executable Documentation with doctest
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 使用doctest的可执行文档
- en: Throughout this book, we have emphasized the need for code to be self-documenting
    as far as possible. We have mentioned how the cool docstring feature of Python
    helps us in this objective. There is one problem with documentation in general—it
    can easily go out of sync with the code. Many times we have seen changes to the
    code, but the corresponding change is not made to the documentation, leaving a
    new developer confused about how the code actually works. Enter the `doctest`
    module to our rescue.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们强调了代码尽可能自文档化的必要性。我们提到了Python的酷炫docstring特性如何帮助我们实现这一目标。一般来说，文档存在一个问题——它很容易与代码不同步。很多时候我们看到代码有所改变，但相应的文档更改并未进行，导致新开发者对代码的实际工作方式感到困惑。现在，`doctest`模块来拯救我们。
- en: The `doctest` module allows us to specify examples inside our docstrings. The
    module then extracts the examples, runs them, and verifies that they still work.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`模块允许我们在docstrings中指定示例。然后模块提取示例，运行它们，并验证它们是否仍然有效。'
- en: Our first doctest
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一份doctest
- en: 'The following is the current version of the `price` method in the `Stock` class:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`Stock`类中`price`方法的当前版本：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, in the docstring, we add an example of how this method might be used.
    The examples are basically a copy-paste of a Python interactive shell. Hence,
    the lines containing input to be executed are prefixed with `>>>` prompt, and
    the lines without the prompt indicate output, as shown in the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在docstring中，我们添加了如何使用此方法的示例。这些示例基本上是Python交互式shell的复制粘贴。因此，包含要执行的输入的行以`>>>`提示符开头，而没有提示符的行表示输出，如下所示：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we have the docstring, we need a way to execute it. Add the following
    lines to the bottom of the file:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了docstring，我们需要一种执行它的方法。将以下行添加到文件底部：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Running the doctest
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行doctest
- en: 'Now we can run the tests by executing the file as a module. We need to execute
    the file as a module so that the relative imports work. If this was a standalone
    script, or we used absolute imports instead of relative imports, then we could
    have just directly executed the file. Since the code above is in the `stock.py`
    file, we have to execute the `stock_alerter.stock` module. The following is the
    command to execute it:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过将文件作为模块执行来运行测试。我们需要将文件作为模块执行，以便相对导入工作。如果这是一个独立的脚本，或者我们使用了绝对导入而不是相对导入，那么我们就可以直接执行该文件。由于上面的代码位于`stock.py`文件中，我们必须执行`stock_alerter.stock`模块。以下是要执行的命令：
- en: 'Windows: `python.exe -m stock_alerter.stock`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Windows: `python.exe -m stock_alerter.stock`'
- en: 'Linux/Mac: `python3 -m stock_alerter.stock`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux/Mac: `python3 -m stock_alerter.stock`'
- en: 'When we run the above command, we''ll get the output as nothing. Yes, nothing.
    If there is no output, then it means that all the doctests passed. We can pass
    the `-v` command line parameter (for verbose output) to see that the test indeed
    passed as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行上述命令时，我们会得到没有任何输出的输出。是的，什么都没有。如果没有输出，那么这意味着所有的doctests都通过了。我们可以传递`-v`命令行参数（用于详细输出）来查看测试确实通过了，如下所示：
- en: 'Windows: `python.exe -m stock_alerter.stock -v`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Windows: `python.exe -m stock_alerter.stock -v`'
- en: 'Linux/Mac: `python3 -m stock_alerter.stock -v`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux/Mac: `python3 -m stock_alerter.stock -v`'
- en: 'When we do this, we get the following output:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，我们会得到以下输出：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let us look at that output in a little more detail.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这个输出。
- en: 'If we look at the first line of our example, it contains the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看我们的示例的第一行，它包含以下内容：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`doctest` picks up this line and evaluates the output:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`会提取这一行并评估输出：'
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The next line of the example is another input line starting with the `>>>` prompt,
    so doctest figures that executing the first line should not have any output, hence
    the statement *Expecting nothing*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的下一行是另一个以`>>>`提示符开始的输入行，因此doctest认为执行第一行不应有任何输出，因此有语句*Expecting nothing*。
- en: 'When this first line of the test is executed, indeed nothing is printed, so
    `doctest` gives the output *ok*, meaning that the line executed as expected. `doctest`
    then goes on to the next line and follows the same procedure until the following
    line is encountered:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试的第一行执行时，确实没有打印任何内容，所以`doctest`给出输出*ok*，这意味着该行按预期执行。然后`doctest`继续到下一行，并遵循相同的程序，直到遇到以下行：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our test says that, when this line is executed, the output of `10` should be
    printed. That is exactly what doctest checks for as well, as shown in the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试表明，当这一行执行时，应该打印出`10`。这正是doctest所检查的，如下所示：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we don't explicitly call `print(stock.price)`. We just put `stock.price`
    and expect the output of `10`. This is exactly the behavior we see in the Python
    interactive shell; `doctest` uses the same behavior.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有明确调用`print(stock.price)`。我们只是放置了`stock.price`并期望输出为`10`。这正是我们在Python交互式外壳中看到的行为；`doctest`使用相同的行为。
- en: 'After this line, our example ends and `doctest` continues on to the next method,
    as shown in the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行之后，我们的示例结束，`doctest`继续到下一个方法，如下所示：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It tells us that the remaining methods didn't have tests, and that all the tests
    passed. Note that `doctest` counts each line of the example as a separate test,
    hence the reason why it identified four tests. Since Python supports module-level
    and class-level docstrings, we could have put some examples in those as well,
    perhaps examples on how to use the module or the class as a whole. This is why
    `doctest` also tells us that `__main__` and `__main__.Stock` do not have any tests.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉我们剩余的方法没有测试，并且所有的测试都通过了。请注意，`doctest`将示例的每一行都视为一个单独的测试，这就是为什么它识别出四个测试的原因。由于Python支持模块级和类级文档字符串，我们也可以在那些地方放置一些示例，比如如何使用整个模块或类的示例。这就是为什么`doctest`也告诉我们`__main__`和`__main__.Stock`没有任何测试。
- en: 'The beauty of doctests is that it allows us to mix documentation between the
    examples. This allows us to expand the docstring for the `price` method like the
    following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: doctests的美丽之处在于它允许我们在示例之间混合文档。这允许我们像以下这样扩展`price`方法的文档字符串：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the above and it should pass with the following new output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上面的代码，它应该通过以下新的输出：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see, `doctest` goes through the documentation and identifies the exact
    lines that need to be executed. This allows us to put explanations and documentation
    in between the code snippets. The result? Well-explained documentation plus testable
    code. A great combination!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`doctest`遍历文档并识别出需要执行的确切行。这允许我们在代码片段之间放置解释和文档。结果？良好的解释文档加上可测试的代码。这是一个绝佳的组合！
- en: 'Let us take one quick look at the last example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下最后一个例子：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you notice, we explicitly print the output. The reason is that the Python
    interactive shell usually does not give any output when the value is `None`. Since
    doctest mimics the behavior of the interactive shell, we could have just had an
    empty line and the test would have passed, but it is not really clear what is
    happening. So, we call print to make it explicit that we are expecting `None`
    as the output.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到，我们明确地打印了输出。原因是Python交互式外壳通常在值是`None`时不会给出任何输出。由于doctest模仿了交互式外壳的行为，我们本可以只留一个空行，测试就会通过，但这并不清楚发生了什么。所以，我们调用print来明确表示我们期望输出为`None`。
- en: Test failures
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试失败
- en: 'Let us now see what a test failure looks like. The following is a doctest for
    the `is_increasing_trend` method:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下测试失败的样子。以下是对`is_increasing_trend`方法的doctest：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following is what we get when we run the test:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试时，我们得到以下结果：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`doctest` tells us which line caused the failure. It also tells us which command
    was executed, and what happened. We can see that an unexpected exception has failed
    the test.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`告诉我们导致失败的是哪一行。它还告诉我们执行了哪个命令，以及发生了什么。我们可以看到，一个意外的异常导致测试失败。'
- en: 'We can now fix the code as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以像以下这样修复代码：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The exception is now gone, but we have a bug in the fix because it has been
    replaced with a failure, as shown in the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 异常现在已经消失了，但我们在修复中有一个bug，因为它已经被替换为失败，如下所示：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s fix it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修复它：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With this fix, all the tests are passing again.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次修复，所有的测试又都通过了。
- en: Testing for exceptions
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试异常
- en: 'The `update` method should also raise a `ValueError` when the price is less
    than zero. The following is how we verify this in the doctest:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`方法应该在价格小于零时也引发`ValueError`。以下是在doctest中验证这一点的方法：'
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The next section shows the expectation that `doctest` looks at:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分展示了`doctest`期望查看的内容：
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The expected output starts with the regular traceback output. This line tells
    `doctest` that an exception is expected. After that comes the actual traceback.
    Since the output often contains file paths that might change, it is very hard
    to match it exactly. Fortunately, we don't need to. `doctest` allows us to put
    three indented dots to signify the middle part of the traceback. Finally, the
    last line shows the expected exception and the exception message. This is the
    line that is matched to see whether the test passed or failed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出以常规的traceback输出开始。这一行告诉`doctest`期望一个异常。之后是实际的traceback。由于输出通常包含可能会改变的文件路径，因此很难完全匹配。幸运的是，我们不需要这样做。`doctest`允许我们使用三个缩进的点来表示traceback的中间部分。最后，最后一行显示了预期的异常和异常信息。这是匹配的行，用来查看测试是否通过。
- en: Package-level doctests
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包级别doctests
- en: 'As we have seen so far, doctests can be written for methods, classes, and modules.
    However, they can also be written for whole packages. Typically, these would be
    put in the `__init__.py` file of the package and would show how the package as
    a whole should work, including multiple interacting classes. Here is one such
    set of doctests from our `__init__.py` file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，doctests可以针对方法、类和模块编写。然而，它们也可以针对整个包编写。通常，这些会放在包的`__init__.py`文件中，并展示整个包应该如何工作，包括多个相互作用的类。以下是从我们的`__init__.py`文件中的一个这样的doctests集：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can run it like the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像下面这样运行它：
- en: '**Windows**: `python.exe -m stock_alerter.__init__`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows**: `python.exe -m stock_alerter.__init__`'
- en: '**Linux/Mac**: `python3 -m stock_alerter.__init__`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux/Mac**: `python3 -m stock_alerter.__init__`'
- en: When we do this, the tests pass.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，测试会通过。
- en: 'There are a few things to note about this test:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个测试，有几个需要注意的事项：
- en: 'We are using absolute imports instead of relative imports in the doctest. For
    example, we say `from stock_alerter.stock import Stock` instead of `from .stock
    import Stock`. This allows us to easily run doctests from the command line. An
    alternate way to run this doctest is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在doctests中，我们使用绝对导入而不是相对导入。例如，我们说`from stock_alerter.stock import Stock`而不是`from
    .stock import Stock`。这使我们能够轻松地从命令行运行doctests。运行此doctests的另一种方法是：
- en: '**Windows**: `python.exe -m doctest stock_alerter\__init__.py`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows**: `python.exe -m doctest stock_alerter\__init__.py`'
- en: '**Linux/Mac**: `python3 -m doctest stock_alerter\__init__.py`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux/Mac**: `python3 -m doctest stock_alerter\__init__.py`'
- en: 'This syntax only works if the file is using absolute imports. Otherwise, we''ll
    get the error `SystemError: Parent module '''' not loaded, cannot perform relative
    import`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '这种语法仅在文件使用绝对导入时才有效。否则，我们会得到错误`SystemError: Parent module '''' not loaded, cannot
    perform relative import`。'
- en: Generally, when doing package level doctests, using absolute imports is recommended.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在进行包级别的doctests时，建议使用绝对导入。
- en: 'Apart from that, some of the examples also continue across multiple lines.
    The following is one such example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，一些示例也跨越了多行。以下是一个这样的示例：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The way to support multiple lines is just the same as in the interactive shell.
    End the line with a backslash `\` and start the next line with three dots `...`.
    This is interpreted by `doctest` as a line continuation and it will combine both
    lines into a single input.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 支持多行的方法与交互式shell中的方法相同。在行尾使用反斜杠`\`，并在下一行开头使用三个点`...`。这被`doctest`解释为行续行，并将这两行合并为单个输入。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**An important gotcha**: Notice that the docstring starts with the `r` prefix,
    like this `r"""`. This indicates a raw string. As mentioned above, we have used
    the backslash in a few places to indicate continuation of input. When Python finds
    a backslash in a string, it interprets it as an escape character instead of a
    literal backslash. The solution is to either escape the backslash by putting a
    double backslash `\\` or to use a raw string in which no backslash interpretation
    is done. Rather than putting double backslashes everywhere, it is preferable to
    use a raw string by marking the start of the docstring with the `r` prefix.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个重要的注意事项**：注意，文档字符串以`r`前缀开始，如下所示`r"""`。这表示原始字符串。如上所述，我们在几个地方使用了反斜杠来表示输入的续行。当Python在字符串中找到一个反斜杠时，它将其解释为转义字符而不是字面反斜杠。解决方案是使用双反斜杠`\\`来转义反斜杠，或者使用不进行反斜杠解释的原始字符串。与其在所有地方都使用双反斜杠，不如使用带有`r`前缀标记的原始字符串来标记文档字符串的开始，这样更可取。'
- en: Maintaining doctests
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护doctests
- en: Doctests can be quite verbose, often containing a lot of explanation mixed in
    with the examples. These doctests can easily run into multiple pages. Sometimes,
    there could be many lines of doctests followed by just a few lines of code. We
    can see this happening in our `update` method. This can make navigating the code
    more difficult.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Doctests可能会非常冗长，通常包含大量的解释和示例混合在一起。这些doctests很容易扩展到多页。有时，可能会有很多行doctests后面只跟着几行代码。我们可以在`update`方法中看到这种情况。这可能会使代码导航变得更加困难。
- en: 'We can solve this problem by putting the doctests into a separate file. Suppose,
    we put the contents of the docstring into a file called `readme.txt`. We then
    change our `__init__.py` file like the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将doctests放入单独的文件来解决这个问题。假设，我们将文档字符串的内容放入一个名为`readme.txt`的文件中。然后我们像下面这样更改我们的`__init__.py`文件：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will now load the contents of `readme.txt` and run it as doctests.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将加载`readme.txt`的内容并将其作为doctests运行。
- en: When writing tests in an external file, there is no need to put quotes around
    the contents as we would in a Python file. The entire file content is considered
    as doctests. Similarly, we also do not need to escape backslashes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当在外部文件中编写测试时，没有必要像在Python文件中那样在内容周围放置引号。整个文件内容都被视为doctests。同样，我们也不需要转义反斜杠。
- en: This feature makes it practical to just put all doctests into separate files.
    These files should double up as user documentation and contain the doctests in
    them. This way, we avoid cluttering up the actual code with pages and pages of
    doctrings.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性使得将所有doctests放入单独的文件变得实用。这些文件应该作为用户文档使用，并包含其中的doctests。这样，我们就可以避免在代码中添加大量doctrings而造成混乱。
- en: Running a suite of doctests
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行一系列doctests
- en: One of the missing features of the `doctest` module is an effective autodiscovery
    mechanism. Unlike `unittest` that searches all files for tests and runs them,
    with doctest we have to execute each file explicitly on the command line. This
    is a big pain for large projects.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`模块缺失的一个特性是有效的自动发现机制。与`unittest`模块不同，后者会搜索所有文件以查找测试并运行它们，而doctest则需要我们显式地在命令行上执行每个文件。这对大型项目来说是一个大麻烦。'
- en: 'There are some ways to accomplish this, though. The most straightforward is
    to wrap the doctest into a `unittest.TestCase` class, like the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一些方法可以实现这一点。最直接的方法是将doctests包装在`unittest.TestCase`类中，如下所示：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These doctests can then be run along with the rest of the unit tests as usual.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些doctests可以像通常一样与单元测试一起运行。
- en: This works, but the problem is that the test doesn't fail if there is a failure
    in the doctest. The error is printed out, but it doesn't record a failure. This
    is okay if the tests are run manually, but causes a problem when the tests are
    run in an automated fashion, for example, as a part of a build or deploy process.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实可行，但问题是如果doctests中发生失败，测试不会失败。错误会被打印出来，但不会记录失败。如果手动运行测试，这没问题，但如果以自动化的方式运行测试，例如作为构建或部署过程的一部分，就会造成问题。
- en: '`doctest` has another feature by which it can be wrapped inside a `unittest`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`还有一个特性，可以通过它将doctests包装在`unittest`中：'
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We haven't looked at `load_tests` before, so let us take a quick look now. `load_tests`
    is used by the `unittest` module to load the unit tests suites from the current
    module. When this function is not present, `unittest` uses its default method
    of loading tests by looking for classes that inherit from `unittest.TestCase`.
    However, when this function is present, it is called and it can return a different
    suite of tests from the default. The returned suite is then run.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前没有看过`load_tests`，现在让我们快速看一下。`load_tests`是由`unittest`模块用来从当前模块加载单元测试套件的。当这个函数不存在时，`unittest`会使用其默认方法通过查找继承自`unittest.TestCase`的类来加载测试。然而，当这个函数存在时，它会被调用，并且可以返回一个与默认不同的测试套件。然后返回的套件会被运行。
- en: Since doctests aren't part of `unittest.TestCase`, they are not run by default
    when we execute the unit tests. What we do instead is implement the `load_tests`
    function and add the doctests to the test suite in that function. We use the `doctest.DocTestSuite`
    and `doctest.DocFileSuite` methods to create `unittest`-compatible test suites
    from the doctests. We then append these test suites to the overall tests to be
    executed in the `load_tests` function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于doctests不是`unittest.TestCase`的一部分，因此默认情况下不会在执行单元测试时运行。我们做的是实现`load_tests`函数，并在该函数中将doctests添加到测试套件中。我们使用`doctest.DocTestSuite`和`doctest.DocFileSuite`方法从doctests创建与`unittest`兼容的测试套件。然后我们将这些测试套件追加到`load_tests`函数中要执行的总体测试中。
- en: '`doctest.DocTestSuite` takes the module containing the tests as a parameter.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest.DocTestSuite` 接收包含测试的模块作为参数。'
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we have to pass in the actual module object, and not just a string.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须传入实际的模块对象，而不仅仅是字符串。
- en: '`doctest.DocFileSuite` takes a filename containing the doctests. The filename
    is relative to the current test module''s directory. So, for example, if our directory
    structure is like the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest.DocFileSuite` 接收包含doctests的文件名。文件名相对于当前测试模块的目录。例如，如果我们的目录结构如下所示：'
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Then we would use the path `../readme.txt` in `test_doctest.py` to reference
    this file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在 `test_doctest.py` 中使用路径 `../readme.txt` 来引用此文件。
- en: 'Alternatively, we can specify a package name and the path can be relative to
    that package like the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以指定一个包名，路径可以相对于该包，如下所示：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Setup and teardown
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置和拆卸
- en: 'One of the problems with doctests is that we have to explicitly set up everything
    inside the docstring. For example, the following is the doctest for the `update`
    method that we wrote earlier:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: doctests的一个问题是我们必须显式设置docstring内部的所有内容。例如，以下是我们之前编写的 `update` 方法的doctest：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the first line, we import the `datetime` module. This is incidental to the
    example and clutters it up, but we have to add it, otherwise we will get the following
    error:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们导入 `datetime` 模块。这与示例无关，会使示例变得杂乱，但我们必须添加它，否则我们将得到以下错误：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Is there a way to avoid repetition of these lines? Yes, there is.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有避免这些行重复的方法？是的，有。
- en: 'Both `DocFileSuite` and `DocTestSuite` take a `globs` parameter. This parameter
    takes a dictionary of items that are used for the globals of the doctests, from
    where they can be accessed by the examples. The following is how we would do this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`DocFileSuite` 和 `DocTestSuite` 都接受一个 `globs` 参数。此参数接受一个字典，其中包含用于doctests的全局变量项，它们可以通过示例访问。以下是我们如何做到这一点：'
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we have to pass in not only the datetime module, but also the `Stock`
    class. By default, `doctest` uses the module's own globals in the execution context.
    This is why we were able to use the `Stock` class in our doctests so far. When
    we replace the execution context via the `globs` parameter, then we have to explicitly
    set the `Stock` object to be a part of the execution context.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须传入的不仅是 `datetime` 模块，还有 `Stock` 类。默认情况下，`doctest` 使用模块自己的全局变量在执行上下文中。这就是为什么我们之前能够在doctests中使用
    `Stock` 类。当我们通过 `globs` 参数替换执行上下文时，我们必须显式设置 `Stock` 对象为执行上下文的一部分。
- en: '`DocFileSuite` and `DocTestSuite` also take the `setUp` and `tearDown` parameters.
    These parameters take a function that will be called before and after each doctest.
    This is a good place to perform any setup or teardown of the environment that
    is needed by the test. The function has also passed a `DocTest` object, which
    can be used during setup and teardown. The `DocTest` object has many attributes,
    but the one most commonly used is the `globs` attribute. This is the dictionary
    of the execution context and it can be added to in the setup to instantiate objects
    that will be reused between objects. The following is an example of such a use:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`DocFileSuite` 和 `DocTestSuite` 也接受 `setUp` 和 `tearDown` 参数。这些参数接受一个函数，该函数将在每个doctest之前和之后被调用。这是一个执行任何测试所需的环境设置或拆卸的好地方。该函数还传递了一个
    `DocTest` 对象，可以在设置和拆卸过程中使用。`DocTest` 对象有许多属性，但最常用的是 `globs` 属性。这是执行上下文的字典，可以在设置中添加以实例化将在对象之间重用的对象。以下是一个这样的使用示例：'
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'By instantiating and passing in the stock to the doctests, we can remove the
    need to instantiate it in the individual tests, so the test was initially like
    the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实例化和将股票传递给doctests，我们可以消除在单个测试中实例化它的需要，因此测试最初如下所示：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now the test becomes the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试变为以下内容：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Why do we instantiate and pass in `stock` via the `setUp` function instead of
    using the `glob` parameter? The reason is because we want a new instance of `Stock`
    for each of the tests. Since `setUp` and `tearDown` are called before each test,
    a new instance of stock is added to `doctest.glob` each time.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们通过 `setUp` 函数实例化和传递 `stock` 而不是使用 `glob` 参数？原因是我们想要为每个测试创建一个新的 `Stock`
    实例。由于 `setUp` 和 `tearDown` 在每个测试之前被调用，因此每次都会将一个新的 `stock` 实例添加到 `doctest.glob`
    中。
- en: Limitations of doctest
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: doctest的限制
- en: 'The biggest limitation of `doctest` is that it only compares printed output.
    This means that any output that could be variable will lead to test failures.
    The following is an example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest` 的最大限制是它只比较打印的输出。这意味着任何可能变化的输出都会导致测试失败。以下是一个示例：'
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This doctest has the potential to fail for two reasons:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此 doctest 有可能因为两个原因而失败：
- en: The order in which a dictionary object is printed out is not guaranteed by Python,
    which means it could be printed out in the opposite order, sometimes leading to
    failure
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 不保证字典对象打印的顺序，这意味着它可能以相反的顺序打印出来，有时会导致失败
- en: The `Stock` object might be at a different address each time, so that part will
    fail to match the next time the test is run
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stock` 对象的地址每次可能都不同，因此这部分在下次测试运行时将无法匹配'
- en: 'The solution to the first problem is to ensure that the output is deterministic.
    For example, the following approach will work:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题的解决方案是确保输出是确定的。例如，以下方法将有效：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There is still the issue of the object address, though. To solve this, we need
    to use doctest directives.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，仍然存在对象地址的问题。为了解决这个问题，我们需要使用 doctest 指令。
- en: Doctest directives
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Doctest 指令
- en: '`doctest` supports a number of directives that change the behavior of the module.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest` 支持许多指令，这些指令会改变模块的行为。'
- en: 'The first directive that we will look at is `ELLIPSIS`. This directive allows
    us to use three dots `...` to match any text. We can use this to match the object
    address, as in the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个指令是 `ELLIPSIS`。此指令允许我们使用三个点 `...` 来匹配任何文本。我们可以使用它来匹配对象地址，如下所示：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The example will now pass.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在示例将通过。
- en: '`...` will match whatever address is printed at runtime. We enable the directive
    by adding the comment `#doctest: +ELLIPSIS` to the example. This will turn on
    the directive for this example only. Subsequent examples in the same doctest will
    have it off unless it is specifically turned on for them.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`...` 将匹配运行时打印的任何地址。我们通过在示例中添加注释 `#doctest: +ELLIPSIS` 来启用此指令。这将仅为此示例启用指令。同一
    doctest 中的后续示例将关闭，除非它们被特别启用。'
- en: 'Some other commonly used directives are:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常用的指令包括：
- en: '`NORMALIZE_WHITESPACE`: By default, doctest matches whitespace exactly. A space
    will not match with a tab, and newlines will not match unless they are at the
    exact same places. Sometimes, we might want to prettify the expected output by
    wrapping lines or indenting them so that they are easier to read. In such cases,
    the `NORMALIZE_WHITESPACE` directive can be set so that doctest will treat all
    counts of whitespace as equal.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NORMALIZE_WHITESPACE`: 默认情况下，doctest 会精确匹配空白。一个空格不会与制表符匹配，并且换行符不会匹配，除非它们位于完全相同的位置。有时，我们可能想要通过换行或缩进来美化预期的输出，使其更容易阅读。在这种情况下，可以将
    `NORMALIZE_WHITESPACE` 指令设置为 doctest 将所有空白视为相等。'
- en: '`IGNORE_EXCEPTION_DETAIL`: When matching exceptions, `doctest` looks at both
    the type of exception as well as the exception message. When this directive is
    enabled, only the type is checked for a match.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IGNORE_EXCEPTION_DETAIL`: 当匹配异常时，`doctest` 会查看异常的类型以及异常消息。当此指令启用时，仅检查类型是否匹配。'
- en: '`SKIP`: An example with this directive is skipped completely. This may be because
    the documentation is intentionally showing an example that doesn''t work or one
    whose output is random. It can also be used to comment out doctests that aren''t
    working.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SKIP`: 带有此指令的示例将被完全跳过。这可能是因为文档有意显示一个不工作或输出随机的示例。它也可以用来注释掉不工作的 doctests。'
- en: '`REPORT_ONLY_FIRST_FAILURE`: `doctest` by default continues to execute subsequent
    examples after a failure, and will report failures in those as well. Many times,
    failure in one of the examples causes subsequent failures in following examples
    and can cause many error reports, making it harder to identify the first example
    to fail that caused all the other failures. This directive will only report the
    first failure.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REPORT_ONLY_FIRST_FAILURE`: 默认情况下，`doctest` 在失败后将继续执行后续示例，并将报告这些示例的失败。很多时候，一个示例的失败会导致后续示例的失败，并可能导致许多错误报告，这使得很难识别导致所有其他失败的第一个失败的示例。此指令将仅报告第一个失败。'
- en: This is not a comprehensive list of directives, but they cover the most commonly
    used ones.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是指令的完整列表，但它们涵盖了最常用的指令。
- en: 'Multiple directives can be given on separate lines or separated by commas.
    The following will work:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在单独的行上给出多个指令，或者用逗号分隔。以下将有效：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Or, the following can also work:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，以下也可以工作：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Directives can also be passed via the `optionflags` parameter to `DocFileSuite`
    and `DocTestSuite`. The directives take effect for the entire file or module when
    passed in the following way:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 指令也可以通过 `optionflags` 参数传递给 `DocFileSuite` 和 `DocTestSuite`。当以以下方式传递时，指令对整个文件或模块生效：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the doctest, we can then turn off certain directives as needed, as shown
    in the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 doctest 中，我们可以根据需要关闭某些指令，如下所示：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Using directives is a good way to selectively enable or disable specific behavior
    on doctests.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指令是选择性地启用或禁用 doctests 中特定行为的好方法。
- en: How do doctests fit into the TDD process?
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: doctests 如何与 TDD 流程相结合？
- en: 'Now that we have a pretty good idea of doctests, the next question is: how
    does this fit into the TDD process? Remember, in the TDD process, we write the
    test first, and then the implementation later. Do doctests fit in with this process?'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 doctests 有了一个相当好的了解，接下来的问题是：这如何与 TDD 流程相结合？记住，在 TDD 流程中，我们首先编写测试，然后编写实现。doctests
    是否适合这个流程？
- en: In a way, yes. Doctests are not a particularly good fit for doing TDD for single
    methods. The `unittest` module is a better choice for those. Where `doctest` shines
    is at package-level interaction. Explanations interspersed with examples really
    bring out interaction between different modules and classes within the package.
    Such doctests can be written out at the beginning, giving a high-level overview
    of how we want the package as a whole to work. These tests will fail. As individual
    classes and methods are written, the tests will start to pass.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，是的。doctests 并不适合用于单个方法的 TDD。对于这些，`unittest` 模块是更好的选择。`doctest` 发挥作用的地方在于包级别的交互。穿插着示例的解释真正展示了包内不同模块和类之间的交互。这样的
    doctests 可以在开始时编写出来，为我们想要整个包如何工作提供一个高级概述。这些测试将会失败。随着单个类和方法被编写，测试将开始通过。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you took a look at Python's `doctest` module. You saw how it
    helps you embed examples within docstrings. You looked at different ways to write
    doctests including method and package docstrings. You also looked at moving package
    level doctests into a separate file and running them. Maintaining doctests is
    important, and you looked at ways to maintain doctests better, using setup and
    teardown and including them in the regular test suite. Finally, you looked at
    some limitations and how you can use directives to overcome some of the limitations.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了 Python 的 `doctest` 模块。你看到了它是如何帮助你将示例嵌入到文档字符串中的。你查看了几种编写 doctests 的方法，包括方法和包文档字符串。你还看到了如何将包级别的
    doctests 移动到单独的文件中并运行它们。维护 doctests 很重要，你查看了一些更好的维护 doctests 的方法，包括使用设置和清理以及将它们包含在常规测试套件中。最后，你查看了一些限制以及如何使用指令来克服一些限制。
- en: In the next chapter, you will get your first introduction to third-party tools
    with a look at the `nose2` package.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将通过查看 `nose2` 包来首次了解第三方工具。
