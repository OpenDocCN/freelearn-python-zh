- en: Chapter 7. Executable Documentation with doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we have emphasized the need for code to be self-documenting
    as far as possible. We have mentioned how the cool docstring feature of Python
    helps us in this objective. There is one problem with documentation in general—it
    can easily go out of sync with the code. Many times we have seen changes to the
    code, but the corresponding change is not made to the documentation, leaving a
    new developer confused about how the code actually works. Enter the `doctest`
    module to our rescue.
  prefs: []
  type: TYPE_NORMAL
- en: The `doctest` module allows us to specify examples inside our docstrings. The
    module then extracts the examples, runs them, and verifies that they still work.
  prefs: []
  type: TYPE_NORMAL
- en: Our first doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the current version of the `price` method in the `Stock` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the docstring, we add an example of how this method might be used.
    The examples are basically a copy-paste of a Python interactive shell. Hence,
    the lines containing input to be executed are prefixed with `>>>` prompt, and
    the lines without the prompt indicate output, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the docstring, we need a way to execute it. Add the following
    lines to the bottom of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Running the doctest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can run the tests by executing the file as a module. We need to execute
    the file as a module so that the relative imports work. If this was a standalone
    script, or we used absolute imports instead of relative imports, then we could
    have just directly executed the file. Since the code above is in the `stock.py`
    file, we have to execute the `stock_alerter.stock` module. The following is the
    command to execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows: `python.exe -m stock_alerter.stock`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux/Mac: `python3 -m stock_alerter.stock`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we run the above command, we''ll get the output as nothing. Yes, nothing.
    If there is no output, then it means that all the doctests passed. We can pass
    the `-v` command line parameter (for verbose output) to see that the test indeed
    passed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows: `python.exe -m stock_alerter.stock -v`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux/Mac: `python3 -m stock_alerter.stock -v`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we do this, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let us look at that output in a little more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the first line of our example, it contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`doctest` picks up this line and evaluates the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The next line of the example is another input line starting with the `>>>` prompt,
    so doctest figures that executing the first line should not have any output, hence
    the statement *Expecting nothing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When this first line of the test is executed, indeed nothing is printed, so
    `doctest` gives the output *ok*, meaning that the line executed as expected. `doctest`
    then goes on to the next line and follows the same procedure until the following
    line is encountered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Our test says that, when this line is executed, the output of `10` should be
    printed. That is exactly what doctest checks for as well, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we don't explicitly call `print(stock.price)`. We just put `stock.price`
    and expect the output of `10`. This is exactly the behavior we see in the Python
    interactive shell; `doctest` uses the same behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this line, our example ends and `doctest` continues on to the next method,
    as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It tells us that the remaining methods didn't have tests, and that all the tests
    passed. Note that `doctest` counts each line of the example as a separate test,
    hence the reason why it identified four tests. Since Python supports module-level
    and class-level docstrings, we could have put some examples in those as well,
    perhaps examples on how to use the module or the class as a whole. This is why
    `doctest` also tells us that `__main__` and `__main__.Stock` do not have any tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The beauty of doctests is that it allows us to mix documentation between the
    examples. This allows us to expand the docstring for the `price` method like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the above and it should pass with the following new output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, `doctest` goes through the documentation and identifies the exact
    lines that need to be executed. This allows us to put explanations and documentation
    in between the code snippets. The result? Well-explained documentation plus testable
    code. A great combination!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take one quick look at the last example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you notice, we explicitly print the output. The reason is that the Python
    interactive shell usually does not give any output when the value is `None`. Since
    doctest mimics the behavior of the interactive shell, we could have just had an
    empty line and the test would have passed, but it is not really clear what is
    happening. So, we call print to make it explicit that we are expecting `None`
    as the output.
  prefs: []
  type: TYPE_NORMAL
- en: Test failures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us now see what a test failure looks like. The following is a doctest for
    the `is_increasing_trend` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is what we get when we run the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`doctest` tells us which line caused the failure. It also tells us which command
    was executed, and what happened. We can see that an unexpected exception has failed
    the test.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now fix the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The exception is now gone, but we have a bug in the fix because it has been
    replaced with a failure, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s fix it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With this fix, all the tests are passing again.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `update` method should also raise a `ValueError` when the price is less
    than zero. The following is how we verify this in the doctest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The next section shows the expectation that `doctest` looks at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The expected output starts with the regular traceback output. This line tells
    `doctest` that an exception is expected. After that comes the actual traceback.
    Since the output often contains file paths that might change, it is very hard
    to match it exactly. Fortunately, we don't need to. `doctest` allows us to put
    three indented dots to signify the middle part of the traceback. Finally, the
    last line shows the expected exception and the exception message. This is the
    line that is matched to see whether the test passed or failed.
  prefs: []
  type: TYPE_NORMAL
- en: Package-level doctests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have seen so far, doctests can be written for methods, classes, and modules.
    However, they can also be written for whole packages. Typically, these would be
    put in the `__init__.py` file of the package and would show how the package as
    a whole should work, including multiple interacting classes. Here is one such
    set of doctests from our `__init__.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run it like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows**: `python.exe -m stock_alerter.__init__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linux/Mac**: `python3 -m stock_alerter.__init__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we do this, the tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few things to note about this test:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using absolute imports instead of relative imports in the doctest. For
    example, we say `from stock_alerter.stock import Stock` instead of `from .stock
    import Stock`. This allows us to easily run doctests from the command line. An
    alternate way to run this doctest is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows**: `python.exe -m doctest stock_alerter\__init__.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linux/Mac**: `python3 -m doctest stock_alerter\__init__.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This syntax only works if the file is using absolute imports. Otherwise, we''ll
    get the error `SystemError: Parent module '''' not loaded, cannot perform relative
    import`.'
  prefs: []
  type: TYPE_NORMAL
- en: Generally, when doing package level doctests, using absolute imports is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from that, some of the examples also continue across multiple lines.
    The following is one such example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The way to support multiple lines is just the same as in the interactive shell.
    End the line with a backslash `\` and start the next line with three dots `...`.
    This is interpreted by `doctest` as a line continuation and it will combine both
    lines into a single input.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**An important gotcha**: Notice that the docstring starts with the `r` prefix,
    like this `r"""`. This indicates a raw string. As mentioned above, we have used
    the backslash in a few places to indicate continuation of input. When Python finds
    a backslash in a string, it interprets it as an escape character instead of a
    literal backslash. The solution is to either escape the backslash by putting a
    double backslash `\\` or to use a raw string in which no backslash interpretation
    is done. Rather than putting double backslashes everywhere, it is preferable to
    use a raw string by marking the start of the docstring with the `r` prefix.'
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining doctests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Doctests can be quite verbose, often containing a lot of explanation mixed in
    with the examples. These doctests can easily run into multiple pages. Sometimes,
    there could be many lines of doctests followed by just a few lines of code. We
    can see this happening in our `update` method. This can make navigating the code
    more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can solve this problem by putting the doctests into a separate file. Suppose,
    we put the contents of the docstring into a file called `readme.txt`. We then
    change our `__init__.py` file like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will now load the contents of `readme.txt` and run it as doctests.
  prefs: []
  type: TYPE_NORMAL
- en: When writing tests in an external file, there is no need to put quotes around
    the contents as we would in a Python file. The entire file content is considered
    as doctests. Similarly, we also do not need to escape backslashes.
  prefs: []
  type: TYPE_NORMAL
- en: This feature makes it practical to just put all doctests into separate files.
    These files should double up as user documentation and contain the doctests in
    them. This way, we avoid cluttering up the actual code with pages and pages of
    doctrings.
  prefs: []
  type: TYPE_NORMAL
- en: Running a suite of doctests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the missing features of the `doctest` module is an effective autodiscovery
    mechanism. Unlike `unittest` that searches all files for tests and runs them,
    with doctest we have to execute each file explicitly on the command line. This
    is a big pain for large projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some ways to accomplish this, though. The most straightforward is
    to wrap the doctest into a `unittest.TestCase` class, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: These doctests can then be run along with the rest of the unit tests as usual.
  prefs: []
  type: TYPE_NORMAL
- en: This works, but the problem is that the test doesn't fail if there is a failure
    in the doctest. The error is printed out, but it doesn't record a failure. This
    is okay if the tests are run manually, but causes a problem when the tests are
    run in an automated fashion, for example, as a part of a build or deploy process.
  prefs: []
  type: TYPE_NORMAL
- en: '`doctest` has another feature by which it can be wrapped inside a `unittest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We haven't looked at `load_tests` before, so let us take a quick look now. `load_tests`
    is used by the `unittest` module to load the unit tests suites from the current
    module. When this function is not present, `unittest` uses its default method
    of loading tests by looking for classes that inherit from `unittest.TestCase`.
    However, when this function is present, it is called and it can return a different
    suite of tests from the default. The returned suite is then run.
  prefs: []
  type: TYPE_NORMAL
- en: Since doctests aren't part of `unittest.TestCase`, they are not run by default
    when we execute the unit tests. What we do instead is implement the `load_tests`
    function and add the doctests to the test suite in that function. We use the `doctest.DocTestSuite`
    and `doctest.DocFileSuite` methods to create `unittest`-compatible test suites
    from the doctests. We then append these test suites to the overall tests to be
    executed in the `load_tests` function.
  prefs: []
  type: TYPE_NORMAL
- en: '`doctest.DocTestSuite` takes the module containing the tests as a parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we have to pass in the actual module object, and not just a string.
  prefs: []
  type: TYPE_NORMAL
- en: '`doctest.DocFileSuite` takes a filename containing the doctests. The filename
    is relative to the current test module''s directory. So, for example, if our directory
    structure is like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Then we would use the path `../readme.txt` in `test_doctest.py` to reference
    this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can specify a package name and the path can be relative to
    that package like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Setup and teardown
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the problems with doctests is that we have to explicitly set up everything
    inside the docstring. For example, the following is the doctest for the `update`
    method that we wrote earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first line, we import the `datetime` module. This is incidental to the
    example and clutters it up, but we have to add it, otherwise we will get the following
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Is there a way to avoid repetition of these lines? Yes, there is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both `DocFileSuite` and `DocTestSuite` take a `globs` parameter. This parameter
    takes a dictionary of items that are used for the globals of the doctests, from
    where they can be accessed by the examples. The following is how we would do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we have to pass in not only the datetime module, but also the `Stock`
    class. By default, `doctest` uses the module's own globals in the execution context.
    This is why we were able to use the `Stock` class in our doctests so far. When
    we replace the execution context via the `globs` parameter, then we have to explicitly
    set the `Stock` object to be a part of the execution context.
  prefs: []
  type: TYPE_NORMAL
- en: '`DocFileSuite` and `DocTestSuite` also take the `setUp` and `tearDown` parameters.
    These parameters take a function that will be called before and after each doctest.
    This is a good place to perform any setup or teardown of the environment that
    is needed by the test. The function has also passed a `DocTest` object, which
    can be used during setup and teardown. The `DocTest` object has many attributes,
    but the one most commonly used is the `globs` attribute. This is the dictionary
    of the execution context and it can be added to in the setup to instantiate objects
    that will be reused between objects. The following is an example of such a use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'By instantiating and passing in the stock to the doctests, we can remove the
    need to instantiate it in the individual tests, so the test was initially like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the test becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Why do we instantiate and pass in `stock` via the `setUp` function instead of
    using the `glob` parameter? The reason is because we want a new instance of `Stock`
    for each of the tests. Since `setUp` and `tearDown` are called before each test,
    a new instance of stock is added to `doctest.glob` each time.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The biggest limitation of `doctest` is that it only compares printed output.
    This means that any output that could be variable will lead to test failures.
    The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This doctest has the potential to fail for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The order in which a dictionary object is printed out is not guaranteed by Python,
    which means it could be printed out in the opposite order, sometimes leading to
    failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Stock` object might be at a different address each time, so that part will
    fail to match the next time the test is run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The solution to the first problem is to ensure that the output is deterministic.
    For example, the following approach will work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There is still the issue of the object address, though. To solve this, we need
    to use doctest directives.
  prefs: []
  type: TYPE_NORMAL
- en: Doctest directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`doctest` supports a number of directives that change the behavior of the module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first directive that we will look at is `ELLIPSIS`. This directive allows
    us to use three dots `...` to match any text. We can use this to match the object
    address, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The example will now pass.
  prefs: []
  type: TYPE_NORMAL
- en: '`...` will match whatever address is printed at runtime. We enable the directive
    by adding the comment `#doctest: +ELLIPSIS` to the example. This will turn on
    the directive for this example only. Subsequent examples in the same doctest will
    have it off unless it is specifically turned on for them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other commonly used directives are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NORMALIZE_WHITESPACE`: By default, doctest matches whitespace exactly. A space
    will not match with a tab, and newlines will not match unless they are at the
    exact same places. Sometimes, we might want to prettify the expected output by
    wrapping lines or indenting them so that they are easier to read. In such cases,
    the `NORMALIZE_WHITESPACE` directive can be set so that doctest will treat all
    counts of whitespace as equal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IGNORE_EXCEPTION_DETAIL`: When matching exceptions, `doctest` looks at both
    the type of exception as well as the exception message. When this directive is
    enabled, only the type is checked for a match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SKIP`: An example with this directive is skipped completely. This may be because
    the documentation is intentionally showing an example that doesn''t work or one
    whose output is random. It can also be used to comment out doctests that aren''t
    working.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REPORT_ONLY_FIRST_FAILURE`: `doctest` by default continues to execute subsequent
    examples after a failure, and will report failures in those as well. Many times,
    failure in one of the examples causes subsequent failures in following examples
    and can cause many error reports, making it harder to identify the first example
    to fail that caused all the other failures. This directive will only report the
    first failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is not a comprehensive list of directives, but they cover the most commonly
    used ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple directives can be given on separate lines or separated by commas.
    The following will work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, the following can also work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Directives can also be passed via the `optionflags` parameter to `DocFileSuite`
    and `DocTestSuite`. The directives take effect for the entire file or module when
    passed in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the doctest, we can then turn off certain directives as needed, as shown
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Using directives is a good way to selectively enable or disable specific behavior
    on doctests.
  prefs: []
  type: TYPE_NORMAL
- en: How do doctests fit into the TDD process?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a pretty good idea of doctests, the next question is: how
    does this fit into the TDD process? Remember, in the TDD process, we write the
    test first, and then the implementation later. Do doctests fit in with this process?'
  prefs: []
  type: TYPE_NORMAL
- en: In a way, yes. Doctests are not a particularly good fit for doing TDD for single
    methods. The `unittest` module is a better choice for those. Where `doctest` shines
    is at package-level interaction. Explanations interspersed with examples really
    bring out interaction between different modules and classes within the package.
    Such doctests can be written out at the beginning, giving a high-level overview
    of how we want the package as a whole to work. These tests will fail. As individual
    classes and methods are written, the tests will start to pass.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you took a look at Python's `doctest` module. You saw how it
    helps you embed examples within docstrings. You looked at different ways to write
    doctests including method and package docstrings. You also looked at moving package
    level doctests into a separate file and running them. Maintaining doctests is
    important, and you looked at ways to maintain doctests better, using setup and
    teardown and including them in the regular test suite. Finally, you looked at
    some limitations and how you can use directives to overcome some of the limitations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will get your first introduction to third-party tools
    with a look at the `nose2` package.
  prefs: []
  type: TYPE_NORMAL
