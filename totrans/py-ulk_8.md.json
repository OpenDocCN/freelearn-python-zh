["```py\nURL = \"http://localhost:8080/%s\"\ndef cputask(num,gil=True):\n    if gil:\n        return taskg(num)\n    else:\n        return taskng(num)     \ndef iotask(num):\n    req = urllib.request.urlopen(URL%str(num))\n    text = req.read()\n    return text\n```", "```py\nimport time\nfrom tasker import cputask, iotask\nfrom random import randint\ndef process(rep, case=None):\n        inputs = [[randint(1, 1000), None] for i in range(rep) ]\n    st = time.time()\n\n    if 'cpu' == case:\n        for i in inputs:\n            i[1] = cputask(i[0])\n    elif 'io' == case:\n        for i in inputs:\n            i[1] = iotask(i[0])\n    tot = time.time() - st\n    for i in inputs:\n        assert i[0] == int(i[1]), \"not same %s\" % (i)\nreturn tot\n```", "```py\nimport time\nfrom tasker import cputask, iotask\nfrom random import randint\nimport threading,random,string\n\ndef threaded_iotask(i):\n    i[1] = iotask(i[0])\n\ndef threaded_cputask(i):\n    i[1] = cputask(i[0])\n\nstats = {}\n\ndef process(rep, cases=()):\n    stats.clear()\n    inputs = [[randint(1, 1000), None] for i in range(rep) ]\n    threads = []\n    if 'cpu' in cases:\n        threads.extend([ \n            threading.Thread(target=threaded_cputask, args=(i,)) \n                for i in inputs])\n    elif 'io' in cases:\n        threads.extend([\n            threading.Thread(target=threaded_iotask, args=(i,)) \n                for i in inputs])            \n    stats['st'] = stats.get('st',time.time())\n    for t in threads:\n        t.start()\n    for t in threads:\n        t.join()\n    stats['et'] = stats.get('et',time.time())\n    tot = stats['et']  - stats['st']\n    for i in inputs:\n        assert i[0] == int(i[1])\n    return tot\n```", "```py\nimport time\nfrom tasker import cputask, iotask\nfrom random import randint\nimport multiprocessing,random,string\n\ndef proc_iotask(i,outq):\n    i[1] = iotask(i[0])\n    outq.put(i)\n\ndef proc_cputask(i,outq):\n    res = cputask(i[0])\n    outq.put((i[0],res))\n\nstats = {}\n\ndef process(rep, case=None):\n    stats.clear()\n    inputs = [[randint(1, 1000), None] for i in range(rep) ]\n    outq = multiprocessing.Queue()\n    processes = []\n    if 'cpu' == case:\n        processes.extend([ \n            multiprocessing.Process(target=proc_cputask, args=(i,outq)) \n                for i in inputs])\n    elif 'io' == case:\n        processes.extend([\n            multiprocessing.Process(target=proc_iotask, args=(i,outq)) \n                for i in inputs])            \n    stats['st'] = stats.get('st',time.time())\n    for t in processes:\n        t.start()\n    for t in processes:\n        t.join()\n    stats['et'] = stats.get('et',time.time())\n    tot = stats['et']  - stats['st']\n    while not outq.empty():\n        item = outq.get()\n        assert item[0] == int(item[1])\n    return tot\n```", "```py\nimport time, asyncio\nfrom tasker import cputask, async_iotask\nfrom random import randint\nimport aiopg, string, random, aiohttp\nfrom asyncio import futures, ensure_future, gather\nfrom functools import partial\n\nURL = \"http://localhost:8080/%s\"\n\nasync def async_iotask(num, loop=None):\n    res = await aiohttp.get(URL % str(num[0]), loop=loop)\n    text = await res.text()\n    num[1] = int(text)\n    return text\n\nstats = {}\n\nasync def main(rep, case=None, loop=None, inputs=None):\n    stats.clear()\n    stats['st'] = time.time()\n    if 'cpu' == case:\n        for i in inputs:\n            i[1] = cputask(i[0])\n    if 'io' == case:\n        deferreds = []\n        for i in inputs:\n            deferreds.append(async_iotask(i, loop=loop))\n        await gather(*deferreds, return_exceptions=True, loop=loop)\n    stats['et'] = time.time()\n\ndef process(rep, case=None):\n    loop = asyncio.new_event_loop()\n    inputs = [[randint(1, 1000), None] for i in range(rep) ]\n    loop.run_until_complete(main(rep, case=case, loop=loop, inputs=inputs))\n    loop.close()\n    tot = stats['et'] - stats['st']â€©    # print(inputs)\n    for i in inputs:\n        assert i[0] == int(i[1])\n    return tot\n```", "```py\nasync def main(rep,case=None,loop=None,inputs=[]):\n    if case == 'cpu':\n        tp = ThreadPoolExecutor()\n        futures = []\n        for i in inputs:\n            task = partial(threaded_cputask,i)\n            future = loop.run_in_executor(tp,task)\n            futures.append(future)\n        res = await asyncio.gather(*futures,return_exceptions=True,loop=loop)\n```", "```py\ndef threaded_cputask(i,outq):\n    res = cputask(i[0])\n    outq.put((i[0],res))\n\nasync def main(rep,case=None,loop=None,outq=None,inputs=[]):\n    if case == 'cpu':\n        pp = ProcessPoolExecutor()\n        futures = []\n        for i in inputs:\n            task = partial(threaded_cputask,i,outq)\n            future = loop.run_in_executor(pp,task)\n            futures.append(future)\n        res = await asyncio.gather(*futures,return_exceptions=True,loop=loop)\n\ndef process(rep,case=None):\n    loop = asyncio.new_event_loop()\n    inputs = [[randint(1, 1000), None] for i in range(rep) ]\n    st = time.time()\n    m = multiprocessing.Manager()\n    outq = m.Queue()\n    loop.run_until_complete(main(rep,case=case,loop=loop,outq=outq,inputs=inputs))\n    tot =  time.time() - st\n    while not outq.empty():\n        item = outq.get()\n        assert item[0] == int(item[1])\n    loop.close()\n    return tot\n```", "```py\nimport sys\nimport zmq\nfrom zmq.eventloop import ioloop\nfrom zmq.eventloop.ioloop import IOLoop\nfrom zmq.eventloop.zmqstream import ZMQStream\nioloop.install()\n\nclass Cli():\n\n    def __init__(self, name, addresses):\n        self.addresses = addresses\n        self.loop = IOLoop.current()\n        self.ctx = zmq.Context.instance()\n        self.skt = None\n        self.stream = None\n        self.name = bytes(name, encoding='ascii')\n        self.req_no = 0\n        self.run()\n\n    def run(self):\n        self.skt = self.ctx.socket(zmq.DEALER)\n        for address in self.addresses:\n            self.skt.connect(address)\n        self.stream = ZMQStream(self.skt)\n        self.stream.on_recv(self.handle_request)\n        self.loop.call_later(1, self.send_request)\n\n    def send_request(self):\n        msg = [self.req_no.to_bytes(1, 'little'), b\"hello\"]\n        print(\"sending\", msg)\n        self.stream.send_multipart(msg)\n        self.req_no += 1\n        if self.req_no < 10:\n            self.loop.call_later(1, self.send_request)\n\n    def handle_request(self, msg):\n        print(\"received\", int.from_bytes(msg[0], 'little'), msg[1])\n\nif __name__ == '__main__':\n    print(\"starting  client\")\n    loop = IOLoop.current()\n    serv = Cli(sys.argv[1], sys.argv[2:])\n    loop.start()\n```", "```py\nimport sys\n\nimport zmq\nfrom zmq.eventloop import ioloop\nfrom zmq.eventloop.ioloop import IOLoop\nfrom zmq.eventloop.zmqstream import ZMQStream\n\nioloop.install()\n\nclass Serv():\n\n    def __init__(self, name, address):\n        self.address = address\n        self.loop = IOLoop.current()\n        self.ctx = zmq.Context.instance()\n        self.skt = None\n        self.stream = None\n        self.name = bytes(name, encoding='ascii')\n        self.run()\n\n    def run(self):\n        self.skt = self.ctx.socket(zmq.ROUTER)\n        self.skt.bind(self.address)\n        self.stream = ZMQStream(self.skt)\n\n        self.stream.on_recv(self.handle_request)\n\n    def handle_request(self, msg):\n        print(\"received\", msg)\n        self.stream.send_multipart(msg)\n\nif __name__ == '__main__':\n    print(\"starting server\")\n    serv = Serv(sys.argv[1], sys.argv[2])\n    loop = IOLoop.current()\n    loop.start()\n```", "```py\nFor client\n(py35) [ scale_zmq ] $ python client.py \"cli\" \"tcp://127.0.0.1:8004\" \"tcp://127.0.0.1:8005\"\nstarting  client\nsending [b'\\x00', b'hello']\nsending [b'\\x01', b'hello']\nreceived 1 b'hello'\nsending [b'\\x02', b'hello']\nsending [b'\\x03', b'hello']\nreceived 3 b'hello'\nsending [b'\\x04', b'hello']\nsending [b'\\x05', b'hello']\nreceived 5 b'hello'\nsending [b'\\x06', b'hello']\nsending [b'\\x07', b'hello']\nreceived 7 b'hello'\nsending [b'\\x08', b'hello']\nsending [b'\\t', b'hello']\nreceived 9 b'hello'\nreceived 0 b'hello'\nreceived 2 b'hello'\nreceived 4 b'hello'\nreceived 6 b'hello'\nreceived 8 b'hello'\n\nOutputs server/workers:\n(py35) [ scale_zmq ] $ python server.py \"serv\" \"tcp://127.0.0.1:8004\"\nstarting server\nreceived [b'\\x00k\\x8bEg', b'\\x00', b'hello']\nreceived [b'\\x00k\\x8bEg', b'\\x02', b'hello']\nreceived [b'\\x00k\\x8bEg', b'\\x04', b'hello']\nreceived [b'\\x00k\\x8bEg', b'\\x06', b'hello']\nreceived [b'\\x00k\\x8bEg', b'\\x08', b'hello']\n(py35) [ scale_zmq ] $ python server.py \"serv\" \"tcp://127.0.0.1:8005\"\nstarting server\nreceived [b'\\x00k\\x8bEg', b'\\x01', b'hello']\nreceived [b'\\x00k\\x8bEg', b'\\x03', b'hello']\nreceived [b'\\x00k\\x8bEg', b'\\x05', b'hello']\nreceived [b'\\x00k\\x8bEg', b'\\x07', b'hello']\nreceived [b'\\x00k\\x8bEg', b'\\t', b'hello']\n```"]