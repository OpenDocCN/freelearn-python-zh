- en: Chapter 6. Test-Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss some good concepts that are to be applied
    during testing. First, we will take a look at how we can create mock or stubs
    easily to test functionalities that are not present in the system. Then, we will
    cover how to write test cases with parameterization. Custom test runners can be
    of great help to write test utilities for a specific project. Then, we will cover
    how to test threaded applications, and utilize concurrent execution to decrease
    the overall time spent on test suite runs. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Mock for tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameterization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom test runners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing threaded applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running test cases in parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mock for tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 1: Mock what you do not have.**'
  prefs: []
  type: TYPE_NORMAL
- en: When we are using test driven development, we have to write test cases for the
    components that rely on other components that are not written yet or take a lot
    of time to execute. This is close to impossible until we create mocks and stubs.
    In this scenario, stubs or mocks are very useful. We use a fake object instead
    of a real one to write the test case. This can be made very easy if we use tools
    that are provided by the language. For example, in the following code, we only
    have the interface for the worker class, and no real implementation of it. We
    want to test the `assign_if_free` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing any stub ourselves, we use the `create_autospec` function
    to create a mock object from the definition of the Worker abstract class. We also
    set up a return value for the function call of checking whether worker was busy
    or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To set up return values, we can also use functions to return conditional responses,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also set methods to raise exceptions using the `side_effect` attribute
    of mock, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Another use is to check whether a method was called and with what arguments,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Parameterization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 2: Manageable inputs to tests.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the tests where we have to test various inputs for the same functionality
    or transformations, we have to write test cases to cover test different inputs.
    We can use parameterization here. In this way, we invoke the same test case with
    different inputs, hence, decreasing time and errors that are associated with it.
    Newer Python versions 3.4 or higher include a very useful method, `subTest` in
    `unittest.TestCase`, which makes it very easy to add parameterized tests. In the
    test output, please note that the parameterized values are also available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This also means that if we needed the *currying* that is running tests for
    all combinations of inputs, then this can be done very easily. We have to write
    a function that returns curried arguments, and then we can use `subTest` to have
    mini tests run with curried arguments. This way it is very easy to explain to
    new people on the team how to write test cases with minimum language jargon, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'But, this works only for new versions of Python. For the older versions, we
    can perform similar work using dynamism of language. We can implement this feature
    ourselves, as shown in the following code snippet. We use a decorator to stick
    the parameterize value to test case, and then in `metaclass`, we create a new
    wrapper function that calls the original function with the required parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Creating custom test runners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 3: Getting information from test system.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The flow of unit test is like this: `unittest TestProgram` in `unittest.main`
    is the primary object that runs everything. Test cases are collected by test discovery
    or by loading modules that were passed via command line. If no test runner is
    specified to the main function, by default, `TextTestRunner` is used. Test suite
    is passed to the runner''s run function to give back a `TestResult` object.'
  prefs: []
  type: TYPE_NORMAL
- en: The custom test runners are a great way to get information in a specific output
    format, from the test system, manage run sequence, store results in a database,
    or create new features for project needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now take a look at an example to create an XML output of test cases,
    you may need something like this to integrate with continuous integration systems,
    which are only able to work with some XML format. As in the following code snippet
    `XMLTestResult` is the class that gives the test result in the XML format. The
    `TsRunner` class test runner then puts the same information on the `stdout` stream.
    We also add the time taken for the test case as well. The `XMLify` class is sending
    information to test the `TsRunner` runner class in an XML format. The `XMLRunner`
    class is putting this information in the XML format on `stdout`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s assume that we use this `XMLRunner` on the test cases, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Testing threaded applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 4: Make threaded application tests like nonthreaded ones.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'My experience with testing on threaded application is to perform the following
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Try to make the threaded application as nonthreaded as possible for tests. By
    this, I mean that group logic that is nonthreaded in one code segment. Do not
    try to test business logic with thread logic. Try to keep them separate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with as little global state as possible. Functions should pass around objects
    that are needed to work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to make queues of tasks to synchronize them. Instead of creating producer
    consumer chains yourself, first try to use queues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also note that sleep statements make test cases run slower. If you add up sleeps
    in the code for more than 20 places, the whole test suite starts to become slow.
    Threaded code should pass on information with events and notifications rather
    than a while loop checking some condition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `_thread` module in Python 2 and the `_thread` module in Python 3 are a
    big help as you can start functions as threads, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Running test cases in parallel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key 5: Faster test suite execution**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we have accumulated a lot of test cases in the project, it takes a lot
    of time to execute all of the test cases. We have to make the test run in parallel
    to decrease the time that is taken overall. In this case, the `py.test` testing
    framework does a fantastic job of simplifying the ability to run tests in parallel.
    To make this work, we have to first install the `py.test` library, and then use
    its runner to run the test cases. The `py.test` library has an `xdist` plugin,
    which adds the capability to run tests in parallel, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you want to dive deeper into this topic, you can refer to [https://pypi.python.org/pypi/pytest-xdist](https://pypi.python.org/pypi/pytest-xdist).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is very important in creating a stable application. In this chapter,
    we discussed how we mock the objects to create an easy separation on concerns
    to test different components. Parameterization is very useful to test various
    transformation logics. The most important take away is to try to create functionalities
    that are needed by your project as test utilities. Try to stick with the `unittest`
    module. Use other libraries for parallel execution as they support the `unittest`
    tests as well.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover optimization techniques for Python.
  prefs: []
  type: TYPE_NORMAL
