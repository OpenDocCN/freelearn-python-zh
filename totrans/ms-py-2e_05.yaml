- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Functional Programming – Readability Versus Brevity
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程 – 可读性与简洁性的权衡
- en: This chapter will show you some of the cool tricks that functional programming
    in Python gives you, and it will explain some of the limitations of Python’s implementation.
    For learning and entertainment, we will also briefly discuss the mathematical
    equivalent using lambda calculus, using the **Y combinator** as an example.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您展示Python中函数式编程的一些酷技巧，并解释Python实现的一些局限性。为了学习和娱乐，我们还将简要讨论使用lambda演算的数学等价物，以**Y组合子**为例。
- en: The last few paragraphs will list and explain the usage of the `functools` and
    `itertools` libraries. If you are familiar with these libraries, feel free to
    skip them, but note that some of these will be used heavily in the later chapters
    about decorators (*Chapter 6*), generators (*Chapter 7*), and performance (*Chapter
    12*).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后几段将列出并解释`functools`和`itertools`库的用法。如果您熟悉这些库，请随意跳过，但请注意，其中一些将在后续章节（*第6章*装饰器）、生成器（*第7章*）和性能（*第12章*）中大量使用。
- en: 'These are the topics covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The theory behind functional programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程背后的理论
- en: '`list`, `dict`, and `set` comprehensions'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`、`dict`和`set`推导式'
- en: '`lambda` functions'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lambda`函数'
- en: '`functools` (`partial` and `reduce`)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`functools`（`partial`和`reduce`）'
- en: '`itertools` (`accumulate`, `chain`, `dropwhile`, `starmap`, and so on)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`itertools`（`accumulate`、`chain`、`dropwhile`、`starmap`等）'
- en: First, we will begin with a bit of history about functional programming in Python
    and what functional programming actually means.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从Python中函数式编程的历史以及函数式编程的实际含义开始。
- en: Functional programming
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程
- en: Functional programming is a paradigm that originates from the lambda calculus
    (λ-calculus), a formal system in mathematics that can be used to simulate any
    Turing machine. Without diving too much into the λ-calculus, this means that computation
    is performed using only the function arguments as input and that the output consists
    of a new variable without mutating the input variables. With a strictly functional
    programming language this behavior would be enforced, but since Python is not
    a strictly functional language, this doesn’t necessarily hold true.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是一种起源于lambda演算（λ-calculus）的范式，这是一种可以用来模拟任何图灵机的数学形式系统。不深入探讨λ-calculus，这意味着计算仅使用函数参数作为输入，输出由一个新变量组成，而不修改输入变量。在严格函数式编程语言中，这种行为将被强制执行，但鉴于Python不是严格函数式语言，这并不一定成立。
- en: It is still a good idea to adhere to this paradigm since mixing paradigms can
    cause unforeseen bugs, as discussed in *Chapter 3*, *Pythonic Syntax and Common
    Pitfalls*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于混合范式可能会导致未预见的错误，正如在*第3章*，*Pythonic语法和常见错误*中讨论的那样，坚持这种范式仍然是一个好主意。
- en: Purely functional
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数式
- en: 'Purely functional programming expects functions to have no side effects. That
    means that arguments given to the function should not be mutated, and neither
    should any other external states. Let’s illustrate this with a simple example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数式编程期望函数没有副作用。这意味着传递给函数的参数不应被修改，任何其他外部状态也不应被修改。让我们用一个简单的例子来说明这一点：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That essentially shows the difference between a regular function and a purely
    functional one. The first function returns a *new* value purely based on the input,
    without any other side effects. This is in comparison to the second function,
    which modifies the given input or even variables outside of its scope.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上显示了常规函数和纯函数之间的区别。第一个函数仅基于输入返回一个*新*值，没有任何其他副作用。这与第二个函数形成对比，该函数修改了给定的输入或其作用域之外的变量。
- en: Even outside of functional programming, limiting your changes to local variables
    only is a good idea. Keeping functions purely functional (relying only on the
    given input) makes code clearer, easier to understand, and better to test as there
    are fewer dependencies. Well-known examples can be found within the `math` module.
    These functions (`sin`, `cos`, `pow`, `sqrt`, and so on) have an input and an
    output that is strictly dependent on the input.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在函数式编程之外，仅将更改限制在局部变量上也是一个好主意。保持函数的纯函数性（仅依赖于给定的输入）可以使代码更清晰、更容易理解，并且更容易测试，因为依赖项更少。在`math`模块中可以找到一些著名的例子。这些函数（`sin`、`cos`、`pow`、`sqrt`等）的输入和输出严格依赖于输入。
- en: Functional programming and Python
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式编程和Python
- en: Python is one of the few, or at least earliest, non-functional programming languages
    to add functional programming features. The initial few functional programming
    functions were introduced around 1993, and these were `lambda`, `reduce`, `filter`,
    and `map`. Since that time, Guido van Rossum has been less than happy with their
    existence because they often make readability suffer. Additionally, functions
    such as `map` and `filter` can easily be replicated using `list` comprehensions.
    Because of this, Guido wanted to remove these functions with the Python 3 release,
    but after a lot of resistance he opted for moving at least the `reduce` function
    to `functools.reduce`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python是少数几种，或者至少是最早的非函数式编程语言之一，它添加了函数式编程特性。最初的几个函数式编程函数大约在1993年引入，它们是`lambda`、`reduce`、`filter`和`map`。从那时起，Guido
    van Rossum对它们的存在一直不太满意，因为它们常常使可读性受损。此外，`map`和`filter`这样的函数很容易用`list`推导式来复制。因此，Guido希望在Python
    3版本中删除这些函数，但经过很多反对意见后，他选择了至少将`reduce`函数移动到`functools.reduce`。
- en: 'Since then, several other functional programming features have been added to
    Python:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，Python已经添加了几个其他函数式编程特性：
- en: '`list`/`dict`/`set` comprehensions'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`/`dict`/`set`推导式'
- en: Generator expressions
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器表达式
- en: Generator functions
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器函数
- en: Coroutines
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程
- en: There are also a host of useful functions in the `functools` and `itertools`
    modules.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`functools`和`itertools`模块中也有许多有用的函数。'
- en: Advantages of functional programming
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式编程的优点
- en: 'The big question is, of course, why would you want to use functional programming
    instead of regular/procedural programming? There are multiple advantages to writing
    code in a functional style:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最大的问题是，你为什么要选择函数式编程而不是常规/过程式编程呢？以函数式风格编写代码有多个优点：
- en: One major advantage of writing purely functional code is that it becomes trivially
    easy to run in parallel. Because there are no external variables needed and no
    external variables changed, you can easily parallelize the code to run on multiple
    processors or even on multiple machines. Assuming you can easily transfer the
    input variables and output results, of course.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写纯函数式代码的一个主要优点是它变得非常容易并行运行。因为没有外部变量需要，也没有外部变量被改变，你可以轻松地将代码并行化，以便在多个处理器或甚至多台机器上运行。当然，假设你可以轻松地传输输入变量和输出结果。
- en: Because the functions are self-contained and don’t have any side effects, they
    mitigate several kinds of bugs. Mutating function arguments in-place, for example,
    is a great source of bugs. Additionally, a seemingly useless function call that
    modifies a variable in the parent scope couldn’t exist in a purely functional
    codebase.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为函数是自包含的，并且没有副作用，所以它们减轻了几种类型的错误。例如，就地修改函数参数是一个很好的错误来源。此外，一个看似无用的函数调用，它修改父作用域中的变量，在纯函数式代码库中是不可能存在的。
- en: It makes testing much easier. If a function only has a given input and output
    and does not touch anything outside of those, you can test without having to set
    up an entire environment for that function. It also omits the need for sandboxing
    functions while testing them.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得测试变得容易得多。如果一个函数只有给定的输入和输出，并且不触及那些之外的任何东西，你就可以测试而无需为该函数设置整个环境。它也省略了在测试函数时进行沙箱化的需要。
- en: Naturally, functional programming also comes with a few drawbacks, several of
    which are caused by the same advantages.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，函数式编程也有一些缺点，其中一些是由相同的优点引起的。
- en: In some cases it can be a hassle to pass along all useful arguments all of the
    time. When modifying a database for example, you need to get the database connection
    somehow. If you decide to pass the database connection as an argument and did
    not prepare for that, you will need to modify not just that function but all the
    calling functions as well to pass along that argument. In those cases a globally
    accessible variable containing the database connection could save you a lot of
    work.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，始终传递所有有用的参数可能会很麻烦。例如，在修改数据库时，你需要以某种方式获取数据库连接。如果你决定将数据库连接作为参数传递，并且没有为此做好准备，那么你不仅需要修改那个函数，还需要修改所有调用该函数的函数来传递那个参数。在这些情况下，一个包含数据库连接的全局可访问变量可以节省你很多工作。
- en: Another often-touted downside of functional programming is recursion. While
    recursion is a very useful tool, it can make it much harder to trace the code
    execution path, which can be a problem when solving bugs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程经常被提到的另一个缺点是递归。虽然递归是一个非常有用的工具，但它可以使追踪代码执行路径变得非常困难，这在解决错误时可能是一个问题。
- en: Functional programming has its place and its time. It’s not suited for every
    situation but when applied correctly it is a very useful tool for your toolbox.
    Now let’s continue with some examples of functional programming.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程有其位置和时机。它并不适合每一种情况，但正确应用时，它是非常有用的工具之一。现在让我们继续看看一些函数式编程的例子。
- en: list, set, and dict comprehensions
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表、集合和字典推导式
- en: The Python `list`, `set`, and `dict` comprehensions are a very easy way to apply
    a function or filter to a list of items.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `list`、`set` 和 `dict` 推导式是应用函数或过滤器到项目列表的一个非常简单的方法。
- en: When used correctly, `list`/`set`/`dict` comprehensions can be really useful
    for quick filtering or transforming of lists, sets, and dicts. The same results
    can be achieved using the “functional” functions `map` and `filter`, but `list`/`set`/`dict`
    comprehensions are often easier to use and also easier to read.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确使用时，`list`/`set`/`dict` 推导式可以非常方便地对列表、集合和字典进行快速过滤或转换。同样可以使用“函数式”函数 `map`
    和 `filter` 来实现相同的结果，但 `list`/`set`/`dict` 推导式通常更容易使用和阅读。
- en: Basic list comprehensions
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本列表推导式
- en: 'Let’s dive right into a few examples. The basic premise of a `list` comprehension
    looks like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入几个例子。`list` 推导式的基本前提看起来是这样的：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can easily expand this with a filter:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地通过一个过滤器来扩展这个功能：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This brings us to the version that is common in most functional languages using
    `map` and `filter`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这带我们来到了大多数函数式语言中常见的使用 `map` 和 `filter` 的版本：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After seeing this it becomes slightly more obvious why Guido van Rossum wanted
    to remove these from the language. In particular, the version using both `filter`
    and `map` isn’t all that readable given the number of parentheses, unless you’re
    used to the Lisp programming language, that is.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这个之后，就稍微明显一些为什么吉多·范罗苏姆想要从语言中移除这些功能。特别是，使用 `filter` 和 `map` 的版本，考虑到括号的数量，并不是那么易于阅读，除非你习惯于
    Lisp 编程语言。
- en: The most important application of `map` is actually not using `map` itself,
    but using one of the `map`-like functions such as `multiprocessing.pool.Pool.map`
    and variants such as `map_async`, `imap`, `starmap`, `starmap_async`, and `imap_unordered`,
    which automatically execute the functions in parallel on multiple processors.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 的最重要应用实际上不是使用 `map` 本身，而是使用类似 `multiprocessing.pool.Pool.map` 的 `map`-like
    函数以及 `map_async`、`imap`、`starmap`、`starmap_async` 和 `imap_unordered` 等变体，这些函数可以在多个处理器上自动并行执行函数。'
- en: 'While I am personally not against `map` or `filter`, I think their usage should
    be reserved for cases where you have an existing function available to use in
    the `map` or `filter` call. A somewhat more useful example would be:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我个人并不反对 `map` 或 `filter`，但我认为它们的用法应该保留在那些你有现成函数可用以在 `map` 或 `filter` 调用中使用的场合。一个更有用的例子可能是：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, the `filter` version might be slightly more readable than the
    `list` comprehension.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`filter` 版本可能比 `list` 推导式稍微容易阅读一些。
- en: 'As for the `list` comprehensions, the syntax is pretty close to regular Python
    for loops, but the `if` statement and automatic storing of results make it quite
    useful to condense code slightly. The regular Python equivalent is not much longer:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `list` 推导式来说，语法与常规 Python 循环非常相似，但 `if` 语句和自动存储结果使其能够稍微压缩代码。常规 Python 的等效代码并不长：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: set comprehensions
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合推导式
- en: 'In addition to `list` comprehensions, we can also use a `set` comprehension,
    which has the same syntax but returns a unique and unordered (all sets are unordered)
    set instead:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `list` 推导式之外，我们还可以使用 `set` 推导式，它具有相同的语法，但返回一个唯一的无序集合（所有集合都是无序的）：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: dict comprehensions
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典推导式
- en: Lastly, we have `dict` comprehensions, which return a `dict` instead of a `list`
    or `set`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有 `dict` 推导式，它返回一个 `dict` 而不是 `list` 或 `set`。
- en: 'Beyond the return type, the only real difference is that you need to return
    both a key and a value. The following is a basic example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了返回类型之外，唯一的真正区别是你需要返回一个键和一个值。以下是一个基本示例：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Since the output is a dictionary, the key needs to be hashable for the `dict`
    comprehension to work. We covered hashing in *Chapter 4*, but the short version
    is that `hash(key)` needs to return a consistent value for your object. That means
    that hashing mutable objects such as lists is not possible.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于输出是一个字典，键需要是可哈希的，`dict` 推导式才能工作。我们在 *第4章* 中介绍了哈希，但简而言之，`hash(key)` 需要为你对象返回一个一致的价值。这意味着无法对可变对象（如列表）进行哈希。
- en: 'The funny thing is that you can mix these two, of course, for even more unreadable
    magic:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，当然你可以混合这两种，以获得更多难以阅读的魔法：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Obviously, you need to be careful with these. They can be very useful if used
    correctly, but the output quickly becomes unreadable, even with proper whitespace.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你需要小心使用这些。如果使用得当，它们非常有用，但输出很快就会变得难以阅读，即使有适当的空白。
- en: Comprehension pitfalls
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表推导陷阱
- en: 'When using comprehensions, some care must be taken. Some types of operations
    are not as obvious as you might expect. This time, we are looking for random numbers
    greater than `0.5`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用列表推导时，必须小心。某些类型的操作可能不像你想象的那么明显。这次，我们正在寻找大于`0.5`的随机数：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See that last number? It’s actually less than `0.5`. This happens because the
    first and the last random calls are actually separate calls and return different
    results.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 看看那个最后的数字？它实际上小于`0.5`。这是因为第一个和最后一个随机调用实际上是单独的调用，并返回不同的结果。
- en: 'One way to counter this is by creating the list separately from the filter:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一种对抗这种情况的方法是单独创建列表和过滤器：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That obviously works, but it’s not all that pretty. So what other options are
    there? Well, there are a few but the readability is a bit questionable, so these
    are not the solutions that I would recommend. It’s good to see them at least once,
    however.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是有效的，但并不那么美观。那么还有其他什么选择呢？好吧，有几个，但可读性有点可疑，所以这些不是我会推荐的方法。然而，至少看到它们一次是好的。
- en: 'Here is a `list` comprehension within a `list` comprehension:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个嵌套在列表推导中的列表推导：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And here’s one that quickly becomes an incomprehensible `list` comprehension:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个很快就会变得难以理解的列表推导：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Caution is needed with these options as the double list comprehension actually
    works like a nested `for` loop would, so it quickly generates a lot of results.
    To elaborate on this, consider:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些选项时需要小心，因为双重列表推导实际上像嵌套的`for`循环一样工作，所以它会快速生成大量结果。为了详细说明这一点，请考虑：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This effectively does the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上执行以下操作：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'These can be useful for some cases, but I would strongly recommend against
    nesting comprehensions as this quickly results in unreadable code. Understanding
    what is happening is still useful, however, so let’s look at one more example.
    The following `list` comprehension swaps the column and row counts, so a 3 x 4
    matrix becomes 4 x 3:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在某些情况下可能很有用，但我强烈建议不要嵌套列表推导，因为这很快会导致代码难以阅读。然而，理解正在发生的事情仍然是有用的，所以让我们再看一个例子。下面的列表推导将列数和行数互换，因此一个3
    x 4的矩阵变成了4 x 3：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Even with the extra indentation, the `list` comprehension just isn’t all that
    readable. With four nested loops, that is expectedly so, of course. There are
    rare cases where nested list comprehensions might be justified, such as very basic
    matrix manipulation. In the general case, however, I would not recommend using
    nested comprehensions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有额外的缩进，列表推导仍然不是那么易于阅读。当然，有四个嵌套循环时，这是预料之中的。在极少数情况下，嵌套列表推导可能是合理的，例如非常基本的矩阵操作。然而，在一般情况下，我不会推荐使用嵌套列表推导。
- en: Next up, we will look at `lambda` functions, which can be combined with `map`
    and `filter` for short convenient functions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨`lambda`函数，它可以与`map`和`filter`结合使用，以创建简短方便的函数。
- en: lambda functions
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`lambda`函数'
- en: 'The `lambda` statement in Python is simply an anonymous function. Due to the
    syntax, it is slightly more limited than regular functions, but a lot can be done
    through it. As always though, readability counts, so generally it is a good idea
    to keep it as simple as possible. One of the more common use cases is as the `sort`
    key for the `sorted` function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的`lambda`语句只是一个匿名函数。由于语法限制，它比常规函数稍微有限一些，但可以通过它做很多事情。然而，如往常一样，可读性很重要，所以通常最好尽可能保持简单。其中一个更常见的用例是作为`sorted`函数的`sort`键：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first version sorts by key and the second sorts by the value. The last one
    shows an alternative option using `operator.itemgetter` to generate a function
    that gets a specific item.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个版本按键排序，第二个版本按值排序。最后一个示例展示了使用`operator.itemgetter`生成一个获取特定项的函数的替代选项。
- en: 'The regular (non-lambda) function wouldn’t be much more verbose but in these
    cases, a lambda function is a very useful shorthand. For completeness, let’s look
    at both identical functions:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正规（非`lambda`）函数不会更加冗长，但在这些情况下，`lambda`函数是一个非常有用的简写。为了完整性，让我们看看两个相同的函数：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Do note that `PEP8` dictates that assigning a lambda to a variable is a bad
    idea ([https://peps.python.org/pep-0008/#programming-recommendations](https://peps.python.org/pep-0008/#programming-recommendations)).
    And logically, it is. The idea of an anonymous function is that it is just that—anonymous
    and without a name. If you are giving it an identity, you should define it as
    a normal function.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`PEP8` 规定将 `lambda` 赋值给变量是一个坏主意（[https://peps.python.org/pep-0008/#programming-recommendations](https://peps.python.org/pep-0008/#programming-recommendations)）。从逻辑上讲，这是正确的。匿名函数的想法就是它是匿名的，没有名字。如果你给它一个身份，你应该将其定义为普通函数。
- en: In my opinion, the only valid use case for a `lambda` function is as an anonymous
    one-line argument to a function such as `sorted()`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，`lambda` 函数的唯一有效用途是作为 `sorted()` 等函数的匿名一行参数。
- en: The Y combinator
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Y 演算子
- en: This section can easily be skipped. It is mostly an example of the mathematical
    value of the lambda statement.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节可以很容易地跳过。它主要是一个 λ 表达式数学价值的例子。
- en: 'The Y combinator is probably the most famous example of the λ-calculus:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Y 演算子可能是 λ 演算最著名的例子：
- en: '![](img/B15882_05_001.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15882_05_001.png)'
- en: All this looks very complicated, but that’s mostly because it uses the lambda
    calculus notation, which is not all that difficult if you look beyond the special
    characters.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都看起来非常复杂，但这主要是因为它使用了λ演算的符号，如果你超越了这些特殊字符，其实并不那么困难。
- en: 'To illustrate, you should read this syntax, ![](img/B15882_05_002.png), as
    an anonymous (lambda) function that takes *x* as an input and returns ![](img/B15882_05_003.png).
    In Python, this would be expressed almost exactly as it is in the original lambda
    calculus, except for replacing ![](img/B15882_05_004.png) with `lambda` and `.`
    with `:`, so it results in `lambda x: x**2`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '为了说明，你应该将这个语法，![](img/B15882_05_002.png)，读作一个匿名（lambda）函数，它接受 *x* 作为输入并返回 ![](img/B15882_05_003.png)。在
    Python 中，这几乎可以完全按照原始的 λ 演算来表示，除了将 ![](img/B15882_05_004.png) 替换为 `lambda` 和 `.`
    替换为 `:`，因此结果是 `lambda x: x**2`。'
- en: 'With some algebra ([https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed-point_combinators_in_lambda_calculus](https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed-point_combinators_in_lambda_calculus)),
    the Y combinator can be reduced to ![](img/B15882_05_005.png), or a function that
    takes the ![](img/B15882_05_006.png) function and applies it to itself. The λ-calculus
    notation of this function is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些代数（[https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed-point_combinators_in_lambda_calculus](https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed-point_combinators_in_lambda_calculus)），Y
    演算子可以简化为 ![](img/B15882_05_005.png)，或者是一个接受 ![](img/B15882_05_006.png) 函数并将其应用于自身的函数。该函数的
    λ 演算表示法如下：
- en: '![](img/B15882_05_007.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15882_05_007.png)'
- en: 'Here is the Python notation for the `lambda` functions:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `lambda` 函数的 Python 表示法：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Or the regular function version:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 或者是常规函数版本：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This all comes down to a function that accepts a function `f` which gets called
    with that function as an argument using the `Y` combinator.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切归结为一个接受函数 `f` 作为参数的函数，该函数使用 `Y` 演算子以该函数作为参数进行调用。
- en: 'This might still be a bit unclear, so let’s look at an example that actually
    uses it:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能仍然有点不清楚，所以让我们看看一个实际使用它的例子：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following is the short version, where the power of the Y combinator becomes
    more apparent, with a recursive anonymous function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是其简短版本，其中 Y 演算子的力量更为明显，使用递归匿名函数：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that the `n and n * c(n – 1) or 1` part is short for the `if` statement
    used in the longer version of the function. Alternatively, this can be written
    using the Python ternary operator:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`n and n * c(n – 1) or 1` 这部分是函数较长版本中使用的 `if` 语句的简写。或者，这也可以使用 Python 的三元运算符来写：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You might be wondering about the point of this entire exercise. You could easily
    write a factorial function in regular Python that is shorter, easier and more
    idiomatic. So what is the point of the Y combinator? The Y combinator allows us
    to make a non-recursive function execute in a recursive way.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道这个练习的目的是什么。你完全可以写一个更短、更简单、更符合 Python 习惯的阶乘函数。那么 Y 演算子的意义在哪里？Y 演算子允许我们以递归的方式执行非递归函数。
- en: More importantly, however, I think it is an interesting demonstration of the
    power of Python — how you can implement something as fundamental as the lambda-calculus
    in a few lines of Python. I think it has a certain kind of beauty in its implementation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更重要的是，我认为这是一个有趣的 Python 力量的展示——如何在几行 Python 中实现像 λ 演算这样基本的东西。我认为它的实现具有一定的美感。
- en: 'One final example of the `Y` combinator will be given by the definition of
    `quicksort` in a few lines:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过几行代码中`quicksort`的定义给出`Y`组合子的一个最终示例：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: While the Y combinator most likely doesn’t have much practical use in Python,
    it does show the power of the `lambda` statement and how close Python is to the
    fundamental mathematics behind it. Essentially, the difference is only in the
    notation and not in the functionality.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Y组合子在Python中可能没有太多实际用途，但它确实展示了`lambda`语句的力量以及Python与它背后的基本数学的接近程度。本质上，区别只在于符号，而不是功能。
- en: Now that we know how to write our own `lambda` and functional functions, we
    will take a look at the bundled functional functions in Python.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何编写自己的`lambda`和函数式函数，我们将看看Python中捆绑的函数式函数。
- en: functools
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: functools
- en: In addition to the `list/dict/set` comprehensions, Python also has a few (more
    advanced) functions that can be really convenient when coding functionally. The
    `functools` library is a collection of functions that return callable objects.
    Some of these functions are used as decorators (we’ll cover more about that in
    *Chapter 6*, *Decorators – Enabling Code Reuse by Decorating*), but the ones that
    we are going to talk about are used as straight-up functions to make your life
    easier.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`list/dict/set`推导式之外，Python还有一些（更高级的）函数，在函数式编程时非常方便。`functools`库是一组返回可调用对象的函数。其中一些函数用作装饰器（我们将在第6章*装饰器
    – 通过装饰实现代码重用*中详细介绍），但我们将要讨论的是用作直接函数来简化你的生活。
- en: partial – Prefill function arguments
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: partial – 预填充函数参数
- en: 'The `partial` function is really convenient for adding some default arguments
    to a function that you use often but can’t (or don’t want to) redefine. With object-oriented
    code, you can usually work around cases similar to these, but with procedural
    code, you will often have to repeat your arguments. Let’s take the `heapq` functions
    from *Chapter 4*, *Pythonic Design Patterns*, as an example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`partial`函数对于向常用但无法（或不想）重新定义的函数添加一些默认参数来说非常方便。在面向对象的代码中，通常可以绕过类似的情况，但在过程式代码中，你通常会不得不重复你的参数。让我们以第4章中*Pythonic设计模式*的`heapq`函数为例：'
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Almost all of the `heapq` functions require a `heap` argument, so we are going
    to make a shortcut that automatically fills the `heap` variable for us. This could
    easily be done with a regular function of course:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的`heapq`函数都需要一个`heap`参数，因此我们将创建一个快捷方式来自动填充`heap`变量。当然，这可以通过一个常规函数轻松完成：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'There is an easier method, however. Python comes bundled with a function called
    `functools.partial` that generates a function with pre-filled arguments:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个更简单的方法。Python附带了一个名为`functools.partial`的函数，它可以生成一个带有预填充参数的函数：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With `functools.partial` we can automatically fill in positional and/or keyword
    arguments for us. So a call to `push(...)` is automatically expanded to `heapq.heappush(heap,
    ...)`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`functools.partial`，我们可以自动为我们填充位置参数和/或关键字参数。因此，对`push(...)`的调用会自动展开为`heapq.heappush(heap,
    ...)`。
- en: Why should we use `partial` instead of writing a `lambda` argument? Well, it’s
    mostly about convenience, but it also helps solve the late binding problem discussed
    in *Chapter 3*, *Pythonic Syntax and Common Pitfalls*. Additionally, partial functions
    still behave somewhat similarly to the original function, which means they still
    have the documentation available and can be pickled, whereas `lambda` statements
    cannot.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要使用`partial`而不是编写一个`lambda`参数呢？嗯，这主要是因为方便，但它也有助于解决在第3章中讨论的晚期绑定问题，即*Pythonic语法和常见陷阱*。此外，偏函数仍然与原始函数有某种相似的行为，这意味着它们仍然有可用的文档，并且可以被序列化，而`lambda`表达式则不能。
- en: The `pickle` module in Python allows serialization of many complex Python objects,
    but not all by default. The `lambda` functions have no defined `pickle` method
    by default, but this can be worked around by defining your own lambda-pickle method
    in `copy_reg.dispatch_table`. An easy way to achieve this is by using the `dill`
    library, which contains a whole range of `pickle` helpers.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的`pickle`模块允许序列化许多复杂的Python对象，但默认情况下并非所有对象。`lambda`函数默认没有定义`pickle`方法，但可以通过在`copy_reg.dispatch_table`中定义自己的lambda-pickle方法来解决这个问题。实现这一点的一个简单方法是使用`dill`库，它包含了一系列`pickle`辅助函数。
- en: 'To illustrate the difference between `lambda` and `functools.partial`, look
    at the following example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明`lambda`和`functools.partial`之间的区别，请看以下示例：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note how the `lambda_push.__doc__` doesn’t return anything and the `lambda`
    only has a very unhelpful `<function <lambda> ...>` representation string. This
    is one of the reasons that `functools.partial` is far more convenient to use in
    practice. It shows the documentation from the reference function; the representation
    string shows exactly what it is doing and it can be pickled with no modification.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`lambda_push.__doc__`不返回任何内容，而`lambda`只有一个非常不实用的`<function <lambda> ...>`表示字符串。这是`functools.partial`在实际使用中远比它方便的一个原因。它显示了参考函数的文档；表示字符串显示了它确切在做什么，并且它可以不经过修改地进行序列化。
- en: In *Chapter 6*, *Decorators – Enabling Code Reuse by Decorating* (specifically,
    in the section about `functools.wraps`), we will see how we can make functions
    copy attributes from other functions in a similar fashion to how `functools.partial`
    copies the documentation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第6章*，*装饰器 – 通过装饰实现代码重用*（特别是关于`functools.wraps`的部分），我们将看到我们如何使函数以类似`functools.partial`复制文档的方式从其他函数复制属性。
- en: reduce – Combining pairs into a single result
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`reduce` – 将成对元素合并成一个结果'
- en: The `reduce` function implements a mathematical technique called folding. It
    applies a pair of the previous result and the next item in the given list to the
    function that is passed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce`函数实现了一种称为折叠的数学技术。它将给定列表中前一个结果和下一个元素配对，并应用于传递给函数。'
- en: The `reduce` function is supported by many languages but in most cases using
    different names such as `curry`, `fold`, `accumulate`, or `aggregate`. Python
    has actually supported `reduce` for a very long time, but since Python 3, it has
    been moved from the global scope to the `functools` library. Some code can be
    simplified beautifully using the `reduce` statement; whether it’s readable or
    not is debatable, however.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce`函数被许多语言支持，但在大多数情况下使用不同的名称，如`curry`、`fold`、`accumulate`或`aggregate`。Python实际上已经支持`reduce`很长时间了，但自从Python
    3以来，它已经被从全局作用域移动到`functools`库中。一些代码可以使用`reduce`语句进行非常漂亮的简化；然而，它是否可读是值得商榷的。'
- en: Implementing a factorial function
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现阶乘函数
- en: 'One of the most used examples of `reduce` is for calculating factorials, which
    is indeed quite simple:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce`最常用的例子之一是计算阶乘，这确实很简单：'
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding code uses `operator.mul` instead of `lambda a, b: a * b`. While
    they produce the same results, the former can be much faster.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '前面的代码使用`operator.mul`而不是`lambda a, b: a * b`。虽然它们产生相同的结果，但前者可能要快得多。'
- en: 'Internally, the `reduce` function will do the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，`reduce`函数将执行以下操作：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Or, creating a reduce function that automatically loops would look like:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，创建一个自动循环的`reduce`函数看起来像这样：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Using the form `a, *b = c`, we can split an iterable between the first item
    and the remaining ones. Which means that `a, *b = [1, 2, 3]` will result in `a=1,
    b=[2, 3]`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用形式`a, *b = c`，我们可以将可迭代对象在第一个项和其余项之间分割。这意味着`a, *b = [1, 2, 3]`将得到`a=1, b=[2,
    3]`。
- en: In this example, this means that we start by priming the `result` variable so
    it contains the initial value and continue to call the function with the current
    result and the next item until the iterable is exhausted.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，这意味着我们首先初始化`result`变量，使其包含初始值，然后继续使用当前结果和下一个项调用函数，直到`iterable`耗尽。
- en: 'Effectively, this comes down to:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这归结为：
- en: '`iterable = [1, 2, 3, 4]`'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`iterable = [1, 2, 3, 4]`'
- en: '`result, *iterable = iterable`'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`result, *iterable = iterable`'
- en: This gives us `result=1` and `iterable = [2, 3, 4]`.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这给我们`result=1`和`iterable = [2, 3, 4]`。
- en: Next up is the first call to operator.mul with the arguments result and item,
    which is stored in result. This is the big difference between reduce and map.
    Whereas map applies the function only to the given item, reduce applies both the
    previous result and the item to the function. So effectively, it runs result =
    operator.mul(result, item). Filling in the variables gives us `result` `=` `1`
    `*` `2` `=` `2`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是第一次调用`operator.mul`，参数是`result`和`item`，这个值存储在`result`中。这是`reduce`和`map`之间的一个重大区别。而`map`只将函数应用于给定的项，`reduce`则将前一个结果和当前项都应用于函数。因此，它实际上执行的是`result
    = operator.mul(result, item)`。填充变量后，我们得到`result` `=` `1` `*` `2` `=` `2`。
- en: 'The next call effectively repeats the process, but because of the previous
    call our initial `result` value is now `2` and the next `item` is `3`: `result
    = 2 * 3 = 6`.'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个调用实际上重复了同样的过程，但由于前一个调用，我们的初始`result`值现在是`2`，下一个`item`是`3`：`result = 2 * 3
    = 6`。
- en: We repeat this one more time because our `iterable` is now exhausted. The last
    call will run `result = 6 * 4 = 24`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们再次重复这个过程，因为我们的`iterable`现在已经耗尽了。最后的调用将执行`result = 6 * 4 = 24`。
- en: Processing trees
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理树
- en: 'Trees are a case where the `reduce` function really shines. Remember the one-line
    tree definition using a `defaultdict` from *Chapter 4*, *Pythonic Design Patterns*.
    What would be a good way to access the keys inside of that object? Given a path
    of a tree item, we can use `reduce` to easily access the items inside. First,
    let’s build a tree:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 树是`reduce`函数真正大放异彩的例子。还记得*第4章*，*Pythonic设计模式*中用`defaultdict`定义的一行树吗？如何访问该对象内部的键呢？给定一个树项的路径，我们可以使用`reduce`轻松访问内部项。首先，让我们构建一个树：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: First, we created a `tree` structure by using a recursive definition with `collections.defaultdict`.
    This allows us to nest the `tree` many levels deep without the need for explicit
    definitions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过使用`collections.defaultdict`的递归定义创建了一个`tree`结构。这允许我们不需要显式定义就可以将`tree`嵌套多层。
- en: To provide somewhat readable output, we use the `json` module to export the
    `tree` (which is effectively a list of nested dicts).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供可读性较好的输出，我们使用`json`模块导出`tree`（实际上是一个嵌套字典的列表）。
- en: 'Now it’s time for the lookup:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是查找的时候了：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now we have a very simple way of walking through the `tree` structure recursively
    in just a few short lines of code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个非常简单的方法，只需几行代码就可以递归地遍历`树`结构。
- en: Reducing in the other direction
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反向减少
- en: People that are familiar with functional programming might wonder why Python
    only has the equivalent of `fold_left` and no `fold_right`. You honestly don’t
    really need both of them as you can easily reverse the operation. To be fair,
    however, the same can be said of `reduce` as well since it is trivial to implement,
    as we have seen in the previous paragraph.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉函数式编程的人可能会想知道为什么Python只有`fold_left`的等价物而没有`fold_right`。实际上，你并不真的需要两者，因为你可以轻松地反转操作。公平地说，同样的话也可以说关于`reduce`，因为我们已经在上一段中看到，它很容易实现。
- en: 'The regular `reduce`—the `fold left` operation:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的`reduce`——`fold left`操作：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The reverse—the `fold right` operation:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 反之——`fold right`操作：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There may not be too many useful cases for `reduce`, but there are definitely
    a few. In particular, traversing recursive data structures is far more easily
    done using `reduce`, since it would otherwise involve more complicated loops or
    recursive functions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`reduce`可能没有太多有用的用例，但确实有一些。特别是，使用`reduce`遍历递归数据结构要容易得多，因为否则将涉及更复杂的循环或递归函数。
- en: Now that we have seen a few of the functional functions in Python, it is time
    to take a look at a few methods that focus on iterables instead.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了Python中的一些函数式函数，现在是时候看看一些专注于可迭代对象的函数了。
- en: itertools
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: itertools
- en: 'The `itertools` library contains iterable functions inspired by those available
    in functional languages. All of these are iterable and have been constructed in
    such a way that only a minimal amount of memory is required to process even the
    largest of datasets. While you can easily write most of these functions yourself,
    I would still recommend using the ones available in the `itertools` library. These
    are all fast, memory efficient, and—perhaps more importantly—tested. We’re going
    to explore a few now: `accumulate`, `chain`, `compress`, `dropwhile/takewhile`,
    `count`, and `groupby`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools`库包含受函数式语言中可用函数启发的可迭代函数。所有这些都是可迭代的，并且被构建成只需要最小的内存即可处理甚至最大的数据集。虽然你可以轻松地自己编写这些函数中的大多数，但我仍然建议使用`itertools`库中提供的函数。这些函数都是快速的、内存高效的，也许更重要的是——经过测试。我们现在要探索几个：`accumulate`、`chain`、`compress`、`dropwhile/takewhile`、`count`和`groupby`。'
- en: accumulate – reduce with intermediate results
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: accumulate – 带中间结果的reduce
- en: The `accumulate` function is very similar to the `reduce` function, which is
    why some languages actually have `accumulate` instead of `reduce` as the folding
    operator.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`accumulate`函数与`reduce`函数非常相似，这就是为什么一些语言实际上有`accumulate`而不是`reduce`作为折叠操作符。'
- en: 'The major difference between the two is that the `accumulate` function returns
    the immediate results. This can be useful when summing the results of a company’s
    sales, for example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数的主要区别在于`accumulate`函数返回即时结果。例如，在汇总一家公司的销售额时，这可能很有用：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It should be noted that the `operator.add` function is actually optional in
    this case as the default behavior of `accumulate` is to sum the results. In some
    other languages and libraries, this function is sometimes called `cumsum` (cumulative
    sum).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，在这个情况下，`operator.add`函数实际上是可选的，因为`accumulate`的默认行为是求和结果。在某些其他语言和库中，这个函数有时被称为`cumsum`（累积和）。
- en: chain – Combining multiple results
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: chain – 结合多个结果
- en: 'The `chain` function is a simple but useful function that combines the results
    of multiple iterators. Very simple but also very useful if you have multiple lists,
    iterators, and so on—just combine them with a simple chain:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`chain` 函数是一个简单但很有用的函数，它将多个迭代器的结果组合起来。如果你有多个列表、迭代器等，这个函数非常简单且非常有用——只需用简单的链将它们组合起来：'
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It should be noted that there is a small variant of `chain` that accepts an
    iterable containing iterables, namely `chain.from_iterable`. This works nearly
    identically, except for the fact that you need to pass along an iterable item
    instead of passing a list of arguments.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，存在一个名为 `chain` 的函数的微小变体，它接受一个包含可迭代的可迭代对象，即 `chain.from_iterable`。这个函数几乎与原函数完全相同，唯一的区别在于你需要传递一个可迭代对象项，而不是传递一个参数列表。
- en: 'Your initial response might be that this can be achieved simply by unpacking
    the (`*args`) tuple, as we will see in *Chapter 7*, *Generators and Coroutines
    – Infinity, One Step at a Time*. However, this is not always the case. For now,
    just remember that if you have an iterable containing iterables, the easiest method
    is to use `itertools.chain.from_iterable`. The usage is as you would expect:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你的初始反应可能是，这可以通过解包 (`*args`) 元组来实现，正如我们将在 *第7章* 中看到的，即生成器和协程——无限，一次一步。然而，情况并不总是如此。现在，只需记住，如果你有一个包含可迭代的可迭代对象，最简单的方法是使用
    `itertools.chain.from_iterable`。用法正如你所预期的那样：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: compress – Selecting items using a list of Booleans
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: compress – 使用布尔列表选择项目
- en: 'The `compress` function is one of those that you won’t need too often, but
    it can be very useful when you do need it. It applies a Boolean filter to your
    iterable, making it return only the elements you actually need. The most important
    thing to note here is that `compress` executes lazy and that `compress` will stop
    if either the data is exhausted, or no elements are being fetched anymore. So,
    even with infinite ranges, it works without a hitch:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`compress` 函数是你不太经常需要使用的函数之一，但在你需要的时候它可能非常有用。它对你的可迭代对象应用布尔过滤器，使其只返回你实际需要的元素。在这里需要注意的最重要的事情是
    `compress` 执行的是惰性操作，并且 `compress` 会在数据耗尽或不再获取任何元素时停止。因此，即使对于无限范围，它也能顺利工作：'
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `compress` function can be useful if you want to make a filtered view of
    a larger iterable without modifying the original iterable. If calculating the
    filter is a heavy operation and the actual values inside the iterable can change,
    this can be very useful. To build on the example above:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在不修改原始可迭代对象的情况下创建一个较大可迭代对象的过滤视图，`compress` 函数可能很有用。如果计算过滤器是一个耗时的操作，并且可迭代对象中的实际值可能会改变，这可能会非常有用。基于上面的示例：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this case, both the filters and the iterable are predefined and very small.
    But if you have a large set that takes a lot of time to compute (or fetch from
    an external resource), this method can be useful to quickly filter without having
    to recalculate everything, especially since the filters can be combined easily
    using a combination of `map`, `all`, and `zip`. You can use `any` instead of `all`
    if you want to see the results from both.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，过滤器和可迭代对象都是预定义的，并且非常小。但是，如果你有一个需要花费大量时间计算（或从外部资源获取）的大集合，这个方法可以用来快速过滤，而无需重新计算一切，特别是由于过滤器可以很容易地使用
    `map`、`all` 和 `zip` 的组合来结合。如果你想看到两个的结果，可以使用 `any` 代替 `all`。
- en: dropwhile/takewhile – Selecting items using a function
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: dropwhile/takewhile – 使用函数选择项目
- en: 'The `dropwhile` function will drop all results until a given predicate evaluates
    to true. This can be useful if you are waiting for a device to finally return
    an expected result. That’s a bit difficult to demonstrate in a book, so we only
    have an example with the basic usage—waiting for a number greater than `3`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`dropwhile` 函数将跳过所有结果，直到给定的谓词评估为真。如果你正在等待一个设备最终返回预期的结果，这可能会很有用。这在书中可能有点难以演示，所以我们只提供了一个基本用法示例——等待一个大于
    `3` 的数字：'
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As you might expect, the `takewhile` function is the reverse of this. It will
    simply return all rows until the predicate turns false:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，`takewhile` 函数是这个的逆过程。它将简单地返回所有行，直到谓词变为假：
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Adding the results from `dropwhile` and `takewhile` will give you all the elements
    again as they are each other’s opposites.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `dropwhile` 和 `takewhile` 的结果相加将再次给出所有元素，因为它们是对方的对立面。
- en: count – Infinite range with decimal steps
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: count – 带小数步长的无限范围
- en: 'The `count` function is quite similar to the `range` function, but there are
    two significant differences:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`count` 函数与 `range` 函数非常相似，但有两个显著的区别：'
- en: The first is that this range is infinite, so don’t even try to do `list(itertools.count())`.
    You’ll definitely run out of memory immediately and it might even freeze your
    system.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一点是，这个范围是无限的，所以甚至不要尝试执行`list(itertools.count())`。您肯定会立即耗尽内存，甚至可能冻结您的系统。
- en: The second difference is that, unlike the `range` function, you can actually
    use floating-point numbers here, so there is no need for whole/integer numbers.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个区别是，与`range`函数不同，您实际上可以在这里使用浮点数，因此不需要整数。
- en: Since listing the entire range will kill our Python interpreter, we’ll limit
    the results using the `itertools.islice` function, which is similar to regular
    slicing (e.g. `some_list[10:20]`) but works on infinitely large inputs as well.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列出整个范围会杀死我们的Python解释器，我们将使用`itertools.islice`函数限制结果，该函数与常规切片类似（例如`some_list[10:20]`），但也可以处理无限大的输入。
- en: The infinitely large functions such as `count` are not sliceable because they
    are infinite generators, a topic we will discuss in *Chapter 7*, *Generators and
    Coroutines – Infinity, One Step at a Time*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如`count`这样的无限大函数不可切片，因为它们是无限生成器，这是我们将在*第7章*，*生成器和协程 – 一步一步的无限*中讨论的主题。
- en: 'The `count` function takes two optional parameters: a `start` parameter, which
    defaults to `0`, and a `step` parameter, which defaults to `1`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`函数有两个可选参数：一个`start`参数，默认为`0`，以及一个`step`参数，默认为`1`：'
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: groupby – Grouping your sorted iterable
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: groupby – 对排序的可迭代对象进行分组
- en: The `groupby` function is a really convenient function for grouping results.
    It allows you to convert a list of objects into a list of groups given a specific
    grouping function.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupby`函数是一个非常方便的函数，用于分组结果。它允许您根据特定的分组函数将对象列表转换为分组列表。'
- en: 'A basic example of `groupby` usage:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupby`使用的基本示例：'
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We can see here how the words are grouped by the first character with very little
    effort. This can be a really convenient utility for grouping employees by department
    in a user interface, for example.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里看到，通过非常少的努力，单词可以根据第一个字符进行分组。例如，这可以是一个非常方便的实用工具，用于在用户界面中按部门分组员工。
- en: 'There are some important things to keep in mind when using this function, however:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用此函数时，有一些重要的事情需要记住：
- en: The input needs to be sorted by the `group` parameter. Otherwise, every repeated
    group will be added as a separate group.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入需要按`group`参数进行排序。否则，每个重复的组都将作为一个单独的组添加。
- en: The results are available for use only once. So, after processing a group, it
    will not be available anymore. If you wish to iterate the results twice, wrap
    the results in `list()` or `tuple()`.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果只能使用一次。因此，处理完一组数据后，它将不再可用。如果您希望迭代结果两次，请将结果包裹在`list()`或`tuple()`中。
- en: 'Here is an example of `groupby` including the side effects of not sorting:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个包含未排序副作用`groupby`的例子：
- en: '[PRE44]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `groupby` function is definitely a very useful one that you can use in a
    wide variety of scenarios. Grouping output for a user, for example, can make results
    much easier to read.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupby`函数绝对是一个非常有用的函数，您可以在各种场景中使用它。例如，对用户输出进行分组可以使结果更容易阅读。'
- en: Exercises
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Now that you know how to use some of the functional programming features in
    Python, perhaps you can try writing the quicksort algorithm as (a collection of)
    regular functions instead of the hard-to-read Y-combinator version.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何在Python中使用一些函数式编程特性，也许您可以尝试将快速排序算法作为（一系列）常规函数来编写，而不是难以阅读的Y-combinator版本。
- en: You can also try and write a `groupby` function yourself that isn’t affected
    by sorting and returns lists of results that can be used multiple times rather
    than just once.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以尝试自己编写一个`groupby`函数，该函数不受排序影响，并返回可以多次使用的而不是仅使用一次的结果列表。
- en: 'Example answers for these exercises can be found on GitHub: [https://github.com/mastering-python/exercises](Chapter_5.xhtml).
    You are encouraged to submit your own solutions and learn about alternative solutions
    from others.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习的示例答案可以在GitHub上找到：[https://github.com/mastering-python/exercises](Chapter_5.xhtml)。您被鼓励提交自己的解决方案，并从他人的替代方案中学习。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Functional programming is a paradigm that scares many people initially, but
    really it shouldn’t. The most important difference between functional and procedural
    programming (within Python) is the mindset. Everything is executed using simple
    functions that depend only on their input variables and don’t produce any side
    effects outside of the local scope.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程最初可能会让很多人感到害怕，但实际上它不应该这样。函数式编程与过程式编程（在 Python 中）之间最重要的区别是思维方式。所有操作都是通过只依赖于输入变量的简单函数来执行的，并且不会在局部作用域之外产生任何副作用。
- en: 'The main advantages are:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 主要优势包括：
- en: Because there are fewer side-effects and code influencing each other, you will
    get fewer bugs.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于副作用较少，代码之间相互影响较少，因此你会遇到更少的错误。
- en: Because the functions always have a predictable input and output, they can be
    easily parallelized across multiple processors or even multiple machines.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于函数始终具有可预测的输入和输出，它们可以轻松地在多个处理器或甚至多台机器之间并行化。
- en: This chapter covered the basics of functional programming within Python and
    a tiny portion of the mathematics behind it. In addition to this, some of the
    many useful libraries that can be used in a very convenient way by using functional
    programming were covered.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了 Python 中函数式编程的基础以及其背后的少量数学知识。此外，还介绍了一些可以通过函数式编程非常方便地使用的许多有用库。
- en: 'The most important takeaways should be the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是以下要点：
- en: Lambda statements are not inherently bad, but it would be best to make them
    use variables from the local scope only, and they should not be longer than a
    single line.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式本身并不坏，但最好只让它们使用局部作用域中的变量，并且它们不应该超过一行。
- en: Functional programming can be very powerful, but has a tendency to become unreadable.
    Care must be taken.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程可能非常强大，但容易变得难以阅读。必须小心使用。
- en: '`list/dict/set` comprehensions are very useful but have a tendency to quickly
    become unreadable. In particular, nested comprehensions are hard to read in nearly
    all cases and should mostly be avoided.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list/dict/set` 推导式非常有用，但容易迅速变得难以阅读。特别是，嵌套推导式在几乎所有情况下都难以阅读，应该尽量避免。'
- en: Ultimately, it is a matter of preference. For the sake of readability, I recommend
    limiting the usage of the functional paradigm when there is no obvious benefit.
    Having said that, when executed correctly, it can be a thing of beauty.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这是一个个人偏好的问题。为了可读性，我建议在没有明显好处的情况下限制函数式范式的使用。话虽如此，如果正确执行，它可以是一件美丽的事情。
- en: Next up are decorators – methods to wrap your functions and classes in other
    functions and/or classes to modify their behavior and extend their functionality.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是装饰器——一种将函数和类包装在其他函数和/或类中的方法，以修改其行为并扩展其功能。
- en: Join our community on Discord
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：[https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)
- en: '![](img/QR_Code156081100001293319171.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code156081100001293319171.png)'
