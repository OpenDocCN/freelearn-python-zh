- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional Programming – Readability Versus Brevity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will show you some of the cool tricks that functional programming
    in Python gives you, and it will explain some of the limitations of Python’s implementation.
    For learning and entertainment, we will also briefly discuss the mathematical
    equivalent using lambda calculus, using the **Y combinator** as an example.
  prefs: []
  type: TYPE_NORMAL
- en: The last few paragraphs will list and explain the usage of the `functools` and
    `itertools` libraries. If you are familiar with these libraries, feel free to
    skip them, but note that some of these will be used heavily in the later chapters
    about decorators (*Chapter 6*), generators (*Chapter 7*), and performance (*Chapter
    12*).
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The theory behind functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list`, `dict`, and `set` comprehensions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lambda` functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`functools` (`partial` and `reduce`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`itertools` (`accumulate`, `chain`, `dropwhile`, `starmap`, and so on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, we will begin with a bit of history about functional programming in Python
    and what functional programming actually means.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming is a paradigm that originates from the lambda calculus
    (λ-calculus), a formal system in mathematics that can be used to simulate any
    Turing machine. Without diving too much into the λ-calculus, this means that computation
    is performed using only the function arguments as input and that the output consists
    of a new variable without mutating the input variables. With a strictly functional
    programming language this behavior would be enforced, but since Python is not
    a strictly functional language, this doesn’t necessarily hold true.
  prefs: []
  type: TYPE_NORMAL
- en: It is still a good idea to adhere to this paradigm since mixing paradigms can
    cause unforeseen bugs, as discussed in *Chapter 3*, *Pythonic Syntax and Common
    Pitfalls*.
  prefs: []
  type: TYPE_NORMAL
- en: Purely functional
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Purely functional programming expects functions to have no side effects. That
    means that arguments given to the function should not be mutated, and neither
    should any other external states. Let’s illustrate this with a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That essentially shows the difference between a regular function and a purely
    functional one. The first function returns a *new* value purely based on the input,
    without any other side effects. This is in comparison to the second function,
    which modifies the given input or even variables outside of its scope.
  prefs: []
  type: TYPE_NORMAL
- en: Even outside of functional programming, limiting your changes to local variables
    only is a good idea. Keeping functions purely functional (relying only on the
    given input) makes code clearer, easier to understand, and better to test as there
    are fewer dependencies. Well-known examples can be found within the `math` module.
    These functions (`sin`, `cos`, `pow`, `sqrt`, and so on) have an input and an
    output that is strictly dependent on the input.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming and Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python is one of the few, or at least earliest, non-functional programming languages
    to add functional programming features. The initial few functional programming
    functions were introduced around 1993, and these were `lambda`, `reduce`, `filter`,
    and `map`. Since that time, Guido van Rossum has been less than happy with their
    existence because they often make readability suffer. Additionally, functions
    such as `map` and `filter` can easily be replicated using `list` comprehensions.
    Because of this, Guido wanted to remove these functions with the Python 3 release,
    but after a lot of resistance he opted for moving at least the `reduce` function
    to `functools.reduce`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since then, several other functional programming features have been added to
    Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '`list`/`dict`/`set` comprehensions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generator expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generator functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also a host of useful functions in the `functools` and `itertools`
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of functional programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The big question is, of course, why would you want to use functional programming
    instead of regular/procedural programming? There are multiple advantages to writing
    code in a functional style:'
  prefs: []
  type: TYPE_NORMAL
- en: One major advantage of writing purely functional code is that it becomes trivially
    easy to run in parallel. Because there are no external variables needed and no
    external variables changed, you can easily parallelize the code to run on multiple
    processors or even on multiple machines. Assuming you can easily transfer the
    input variables and output results, of course.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the functions are self-contained and don’t have any side effects, they
    mitigate several kinds of bugs. Mutating function arguments in-place, for example,
    is a great source of bugs. Additionally, a seemingly useless function call that
    modifies a variable in the parent scope couldn’t exist in a purely functional
    codebase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes testing much easier. If a function only has a given input and output
    and does not touch anything outside of those, you can test without having to set
    up an entire environment for that function. It also omits the need for sandboxing
    functions while testing them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naturally, functional programming also comes with a few drawbacks, several of
    which are caused by the same advantages.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases it can be a hassle to pass along all useful arguments all of the
    time. When modifying a database for example, you need to get the database connection
    somehow. If you decide to pass the database connection as an argument and did
    not prepare for that, you will need to modify not just that function but all the
    calling functions as well to pass along that argument. In those cases a globally
    accessible variable containing the database connection could save you a lot of
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Another often-touted downside of functional programming is recursion. While
    recursion is a very useful tool, it can make it much harder to trace the code
    execution path, which can be a problem when solving bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming has its place and its time. It’s not suited for every
    situation but when applied correctly it is a very useful tool for your toolbox.
    Now let’s continue with some examples of functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: list, set, and dict comprehensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python `list`, `set`, and `dict` comprehensions are a very easy way to apply
    a function or filter to a list of items.
  prefs: []
  type: TYPE_NORMAL
- en: When used correctly, `list`/`set`/`dict` comprehensions can be really useful
    for quick filtering or transforming of lists, sets, and dicts. The same results
    can be achieved using the “functional” functions `map` and `filter`, but `list`/`set`/`dict`
    comprehensions are often easier to use and also easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Basic list comprehensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s dive right into a few examples. The basic premise of a `list` comprehension
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily expand this with a filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This brings us to the version that is common in most functional languages using
    `map` and `filter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After seeing this it becomes slightly more obvious why Guido van Rossum wanted
    to remove these from the language. In particular, the version using both `filter`
    and `map` isn’t all that readable given the number of parentheses, unless you’re
    used to the Lisp programming language, that is.
  prefs: []
  type: TYPE_NORMAL
- en: The most important application of `map` is actually not using `map` itself,
    but using one of the `map`-like functions such as `multiprocessing.pool.Pool.map`
    and variants such as `map_async`, `imap`, `starmap`, `starmap_async`, and `imap_unordered`,
    which automatically execute the functions in parallel on multiple processors.
  prefs: []
  type: TYPE_NORMAL
- en: 'While I am personally not against `map` or `filter`, I think their usage should
    be reserved for cases where you have an existing function available to use in
    the `map` or `filter` call. A somewhat more useful example would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `filter` version might be slightly more readable than the
    `list` comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the `list` comprehensions, the syntax is pretty close to regular Python
    for loops, but the `if` statement and automatic storing of results make it quite
    useful to condense code slightly. The regular Python equivalent is not much longer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: set comprehensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to `list` comprehensions, we can also use a `set` comprehension,
    which has the same syntax but returns a unique and unordered (all sets are unordered)
    set instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: dict comprehensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lastly, we have `dict` comprehensions, which return a `dict` instead of a `list`
    or `set`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond the return type, the only real difference is that you need to return
    both a key and a value. The following is a basic example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Since the output is a dictionary, the key needs to be hashable for the `dict`
    comprehension to work. We covered hashing in *Chapter 4*, but the short version
    is that `hash(key)` needs to return a consistent value for your object. That means
    that hashing mutable objects such as lists is not possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The funny thing is that you can mix these two, of course, for even more unreadable
    magic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, you need to be careful with these. They can be very useful if used
    correctly, but the output quickly becomes unreadable, even with proper whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: Comprehension pitfalls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using comprehensions, some care must be taken. Some types of operations
    are not as obvious as you might expect. This time, we are looking for random numbers
    greater than `0.5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: See that last number? It’s actually less than `0.5`. This happens because the
    first and the last random calls are actually separate calls and return different
    results.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to counter this is by creating the list separately from the filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: That obviously works, but it’s not all that pretty. So what other options are
    there? Well, there are a few but the readability is a bit questionable, so these
    are not the solutions that I would recommend. It’s good to see them at least once,
    however.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a `list` comprehension within a `list` comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s one that quickly becomes an incomprehensible `list` comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Caution is needed with these options as the double list comprehension actually
    works like a nested `for` loop would, so it quickly generates a lot of results.
    To elaborate on this, consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This effectively does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'These can be useful for some cases, but I would strongly recommend against
    nesting comprehensions as this quickly results in unreadable code. Understanding
    what is happening is still useful, however, so let’s look at one more example.
    The following `list` comprehension swaps the column and row counts, so a 3 x 4
    matrix becomes 4 x 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Even with the extra indentation, the `list` comprehension just isn’t all that
    readable. With four nested loops, that is expectedly so, of course. There are
    rare cases where nested list comprehensions might be justified, such as very basic
    matrix manipulation. In the general case, however, I would not recommend using
    nested comprehensions.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we will look at `lambda` functions, which can be combined with `map`
    and `filter` for short convenient functions.
  prefs: []
  type: TYPE_NORMAL
- en: lambda functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `lambda` statement in Python is simply an anonymous function. Due to the
    syntax, it is slightly more limited than regular functions, but a lot can be done
    through it. As always though, readability counts, so generally it is a good idea
    to keep it as simple as possible. One of the more common use cases is as the `sort`
    key for the `sorted` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first version sorts by key and the second sorts by the value. The last one
    shows an alternative option using `operator.itemgetter` to generate a function
    that gets a specific item.
  prefs: []
  type: TYPE_NORMAL
- en: 'The regular (non-lambda) function wouldn’t be much more verbose but in these
    cases, a lambda function is a very useful shorthand. For completeness, let’s look
    at both identical functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Do note that `PEP8` dictates that assigning a lambda to a variable is a bad
    idea ([https://peps.python.org/pep-0008/#programming-recommendations](https://peps.python.org/pep-0008/#programming-recommendations)).
    And logically, it is. The idea of an anonymous function is that it is just that—anonymous
    and without a name. If you are giving it an identity, you should define it as
    a normal function.
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, the only valid use case for a `lambda` function is as an anonymous
    one-line argument to a function such as `sorted()`.
  prefs: []
  type: TYPE_NORMAL
- en: The Y combinator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section can easily be skipped. It is mostly an example of the mathematical
    value of the lambda statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Y combinator is probably the most famous example of the λ-calculus:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_05_001.png)'
  prefs: []
  type: TYPE_IMG
- en: All this looks very complicated, but that’s mostly because it uses the lambda
    calculus notation, which is not all that difficult if you look beyond the special
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, you should read this syntax, ![](img/B15882_05_002.png), as
    an anonymous (lambda) function that takes *x* as an input and returns ![](img/B15882_05_003.png).
    In Python, this would be expressed almost exactly as it is in the original lambda
    calculus, except for replacing ![](img/B15882_05_004.png) with `lambda` and `.`
    with `:`, so it results in `lambda x: x**2`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With some algebra ([https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed-point_combinators_in_lambda_calculus](https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed-point_combinators_in_lambda_calculus)),
    the Y combinator can be reduced to ![](img/B15882_05_005.png), or a function that
    takes the ![](img/B15882_05_006.png) function and applies it to itself. The λ-calculus
    notation of this function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_05_007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the Python notation for the `lambda` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Or the regular function version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This all comes down to a function that accepts a function `f` which gets called
    with that function as an argument using the `Y` combinator.
  prefs: []
  type: TYPE_NORMAL
- en: 'This might still be a bit unclear, so let’s look at an example that actually
    uses it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the short version, where the power of the Y combinator becomes
    more apparent, with a recursive anonymous function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `n and n * c(n – 1) or 1` part is short for the `if` statement
    used in the longer version of the function. Alternatively, this can be written
    using the Python ternary operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You might be wondering about the point of this entire exercise. You could easily
    write a factorial function in regular Python that is shorter, easier and more
    idiomatic. So what is the point of the Y combinator? The Y combinator allows us
    to make a non-recursive function execute in a recursive way.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, however, I think it is an interesting demonstration of the
    power of Python — how you can implement something as fundamental as the lambda-calculus
    in a few lines of Python. I think it has a certain kind of beauty in its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'One final example of the `Y` combinator will be given by the definition of
    `quicksort` in a few lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: While the Y combinator most likely doesn’t have much practical use in Python,
    it does show the power of the `lambda` statement and how close Python is to the
    fundamental mathematics behind it. Essentially, the difference is only in the
    notation and not in the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to write our own `lambda` and functional functions, we
    will take a look at the bundled functional functions in Python.
  prefs: []
  type: TYPE_NORMAL
- en: functools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the `list/dict/set` comprehensions, Python also has a few (more
    advanced) functions that can be really convenient when coding functionally. The
    `functools` library is a collection of functions that return callable objects.
    Some of these functions are used as decorators (we’ll cover more about that in
    *Chapter 6*, *Decorators – Enabling Code Reuse by Decorating*), but the ones that
    we are going to talk about are used as straight-up functions to make your life
    easier.
  prefs: []
  type: TYPE_NORMAL
- en: partial – Prefill function arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `partial` function is really convenient for adding some default arguments
    to a function that you use often but can’t (or don’t want to) redefine. With object-oriented
    code, you can usually work around cases similar to these, but with procedural
    code, you will often have to repeat your arguments. Let’s take the `heapq` functions
    from *Chapter 4*, *Pythonic Design Patterns*, as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Almost all of the `heapq` functions require a `heap` argument, so we are going
    to make a shortcut that automatically fills the `heap` variable for us. This could
    easily be done with a regular function of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an easier method, however. Python comes bundled with a function called
    `functools.partial` that generates a function with pre-filled arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With `functools.partial` we can automatically fill in positional and/or keyword
    arguments for us. So a call to `push(...)` is automatically expanded to `heapq.heappush(heap,
    ...)`.
  prefs: []
  type: TYPE_NORMAL
- en: Why should we use `partial` instead of writing a `lambda` argument? Well, it’s
    mostly about convenience, but it also helps solve the late binding problem discussed
    in *Chapter 3*, *Pythonic Syntax and Common Pitfalls*. Additionally, partial functions
    still behave somewhat similarly to the original function, which means they still
    have the documentation available and can be pickled, whereas `lambda` statements
    cannot.
  prefs: []
  type: TYPE_NORMAL
- en: The `pickle` module in Python allows serialization of many complex Python objects,
    but not all by default. The `lambda` functions have no defined `pickle` method
    by default, but this can be worked around by defining your own lambda-pickle method
    in `copy_reg.dispatch_table`. An easy way to achieve this is by using the `dill`
    library, which contains a whole range of `pickle` helpers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the difference between `lambda` and `functools.partial`, look
    at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note how the `lambda_push.__doc__` doesn’t return anything and the `lambda`
    only has a very unhelpful `<function <lambda> ...>` representation string. This
    is one of the reasons that `functools.partial` is far more convenient to use in
    practice. It shows the documentation from the reference function; the representation
    string shows exactly what it is doing and it can be pickled with no modification.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 6*, *Decorators – Enabling Code Reuse by Decorating* (specifically,
    in the section about `functools.wraps`), we will see how we can make functions
    copy attributes from other functions in a similar fashion to how `functools.partial`
    copies the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: reduce – Combining pairs into a single result
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `reduce` function implements a mathematical technique called folding. It
    applies a pair of the previous result and the next item in the given list to the
    function that is passed.
  prefs: []
  type: TYPE_NORMAL
- en: The `reduce` function is supported by many languages but in most cases using
    different names such as `curry`, `fold`, `accumulate`, or `aggregate`. Python
    has actually supported `reduce` for a very long time, but since Python 3, it has
    been moved from the global scope to the `functools` library. Some code can be
    simplified beautifully using the `reduce` statement; whether it’s readable or
    not is debatable, however.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a factorial function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most used examples of `reduce` is for calculating factorials, which
    is indeed quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code uses `operator.mul` instead of `lambda a, b: a * b`. While
    they produce the same results, the former can be much faster.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Internally, the `reduce` function will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, creating a reduce function that automatically loops would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Using the form `a, *b = c`, we can split an iterable between the first item
    and the remaining ones. Which means that `a, *b = [1, 2, 3]` will result in `a=1,
    b=[2, 3]`.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, this means that we start by priming the `result` variable so
    it contains the initial value and continue to call the function with the current
    result and the next item until the iterable is exhausted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Effectively, this comes down to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`iterable = [1, 2, 3, 4]`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`result, *iterable = iterable`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This gives us `result=1` and `iterable = [2, 3, 4]`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next up is the first call to operator.mul with the arguments result and item,
    which is stored in result. This is the big difference between reduce and map.
    Whereas map applies the function only to the given item, reduce applies both the
    previous result and the item to the function. So effectively, it runs result =
    operator.mul(result, item). Filling in the variables gives us `result` `=` `1`
    `*` `2` `=` `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next call effectively repeats the process, but because of the previous
    call our initial `result` value is now `2` and the next `item` is `3`: `result
    = 2 * 3 = 6`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We repeat this one more time because our `iterable` is now exhausted. The last
    call will run `result = 6 * 4 = 24`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Processing trees
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Trees are a case where the `reduce` function really shines. Remember the one-line
    tree definition using a `defaultdict` from *Chapter 4*, *Pythonic Design Patterns*.
    What would be a good way to access the keys inside of that object? Given a path
    of a tree item, we can use `reduce` to easily access the items inside. First,
    let’s build a tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: First, we created a `tree` structure by using a recursive definition with `collections.defaultdict`.
    This allows us to nest the `tree` many levels deep without the need for explicit
    definitions.
  prefs: []
  type: TYPE_NORMAL
- en: To provide somewhat readable output, we use the `json` module to export the
    `tree` (which is effectively a list of nested dicts).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it’s time for the lookup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a very simple way of walking through the `tree` structure recursively
    in just a few short lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing in the other direction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: People that are familiar with functional programming might wonder why Python
    only has the equivalent of `fold_left` and no `fold_right`. You honestly don’t
    really need both of them as you can easily reverse the operation. To be fair,
    however, the same can be said of `reduce` as well since it is trivial to implement,
    as we have seen in the previous paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: 'The regular `reduce`—the `fold left` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The reverse—the `fold right` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There may not be too many useful cases for `reduce`, but there are definitely
    a few. In particular, traversing recursive data structures is far more easily
    done using `reduce`, since it would otherwise involve more complicated loops or
    recursive functions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen a few of the functional functions in Python, it is time
    to take a look at a few methods that focus on iterables instead.
  prefs: []
  type: TYPE_NORMAL
- en: itertools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `itertools` library contains iterable functions inspired by those available
    in functional languages. All of these are iterable and have been constructed in
    such a way that only a minimal amount of memory is required to process even the
    largest of datasets. While you can easily write most of these functions yourself,
    I would still recommend using the ones available in the `itertools` library. These
    are all fast, memory efficient, and—perhaps more importantly—tested. We’re going
    to explore a few now: `accumulate`, `chain`, `compress`, `dropwhile/takewhile`,
    `count`, and `groupby`.'
  prefs: []
  type: TYPE_NORMAL
- en: accumulate – reduce with intermediate results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `accumulate` function is very similar to the `reduce` function, which is
    why some languages actually have `accumulate` instead of `reduce` as the folding
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The major difference between the two is that the `accumulate` function returns
    the immediate results. This can be useful when summing the results of a company’s
    sales, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It should be noted that the `operator.add` function is actually optional in
    this case as the default behavior of `accumulate` is to sum the results. In some
    other languages and libraries, this function is sometimes called `cumsum` (cumulative
    sum).
  prefs: []
  type: TYPE_NORMAL
- en: chain – Combining multiple results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `chain` function is a simple but useful function that combines the results
    of multiple iterators. Very simple but also very useful if you have multiple lists,
    iterators, and so on—just combine them with a simple chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: It should be noted that there is a small variant of `chain` that accepts an
    iterable containing iterables, namely `chain.from_iterable`. This works nearly
    identically, except for the fact that you need to pass along an iterable item
    instead of passing a list of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your initial response might be that this can be achieved simply by unpacking
    the (`*args`) tuple, as we will see in *Chapter 7*, *Generators and Coroutines
    – Infinity, One Step at a Time*. However, this is not always the case. For now,
    just remember that if you have an iterable containing iterables, the easiest method
    is to use `itertools.chain.from_iterable`. The usage is as you would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: compress – Selecting items using a list of Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `compress` function is one of those that you won’t need too often, but
    it can be very useful when you do need it. It applies a Boolean filter to your
    iterable, making it return only the elements you actually need. The most important
    thing to note here is that `compress` executes lazy and that `compress` will stop
    if either the data is exhausted, or no elements are being fetched anymore. So,
    even with infinite ranges, it works without a hitch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `compress` function can be useful if you want to make a filtered view of
    a larger iterable without modifying the original iterable. If calculating the
    filter is a heavy operation and the actual values inside the iterable can change,
    this can be very useful. To build on the example above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this case, both the filters and the iterable are predefined and very small.
    But if you have a large set that takes a lot of time to compute (or fetch from
    an external resource), this method can be useful to quickly filter without having
    to recalculate everything, especially since the filters can be combined easily
    using a combination of `map`, `all`, and `zip`. You can use `any` instead of `all`
    if you want to see the results from both.
  prefs: []
  type: TYPE_NORMAL
- en: dropwhile/takewhile – Selecting items using a function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `dropwhile` function will drop all results until a given predicate evaluates
    to true. This can be useful if you are waiting for a device to finally return
    an expected result. That’s a bit difficult to demonstrate in a book, so we only
    have an example with the basic usage—waiting for a number greater than `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As you might expect, the `takewhile` function is the reverse of this. It will
    simply return all rows until the predicate turns false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Adding the results from `dropwhile` and `takewhile` will give you all the elements
    again as they are each other’s opposites.
  prefs: []
  type: TYPE_NORMAL
- en: count – Infinite range with decimal steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `count` function is quite similar to the `range` function, but there are
    two significant differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is that this range is infinite, so don’t even try to do `list(itertools.count())`.
    You’ll definitely run out of memory immediately and it might even freeze your
    system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second difference is that, unlike the `range` function, you can actually
    use floating-point numbers here, so there is no need for whole/integer numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since listing the entire range will kill our Python interpreter, we’ll limit
    the results using the `itertools.islice` function, which is similar to regular
    slicing (e.g. `some_list[10:20]`) but works on infinitely large inputs as well.
  prefs: []
  type: TYPE_NORMAL
- en: The infinitely large functions such as `count` are not sliceable because they
    are infinite generators, a topic we will discuss in *Chapter 7*, *Generators and
    Coroutines – Infinity, One Step at a Time*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `count` function takes two optional parameters: a `start` parameter, which
    defaults to `0`, and a `step` parameter, which defaults to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: groupby – Grouping your sorted iterable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `groupby` function is a really convenient function for grouping results.
    It allows you to convert a list of objects into a list of groups given a specific
    grouping function.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic example of `groupby` usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We can see here how the words are grouped by the first character with very little
    effort. This can be a really convenient utility for grouping employees by department
    in a user interface, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some important things to keep in mind when using this function, however:'
  prefs: []
  type: TYPE_NORMAL
- en: The input needs to be sorted by the `group` parameter. Otherwise, every repeated
    group will be added as a separate group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The results are available for use only once. So, after processing a group, it
    will not be available anymore. If you wish to iterate the results twice, wrap
    the results in `list()` or `tuple()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of `groupby` including the side effects of not sorting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `groupby` function is definitely a very useful one that you can use in a
    wide variety of scenarios. Grouping output for a user, for example, can make results
    much easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know how to use some of the functional programming features in
    Python, perhaps you can try writing the quicksort algorithm as (a collection of)
    regular functions instead of the hard-to-read Y-combinator version.
  prefs: []
  type: TYPE_NORMAL
- en: You can also try and write a `groupby` function yourself that isn’t affected
    by sorting and returns lists of results that can be used multiple times rather
    than just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example answers for these exercises can be found on GitHub: [https://github.com/mastering-python/exercises](Chapter_5.xhtml).
    You are encouraged to submit your own solutions and learn about alternative solutions
    from others.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming is a paradigm that scares many people initially, but
    really it shouldn’t. The most important difference between functional and procedural
    programming (within Python) is the mindset. Everything is executed using simple
    functions that depend only on their input variables and don’t produce any side
    effects outside of the local scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main advantages are:'
  prefs: []
  type: TYPE_NORMAL
- en: Because there are fewer side-effects and code influencing each other, you will
    get fewer bugs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the functions always have a predictable input and output, they can be
    easily parallelized across multiple processors or even multiple machines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter covered the basics of functional programming within Python and
    a tiny portion of the mathematics behind it. In addition to this, some of the
    many useful libraries that can be used in a very convenient way by using functional
    programming were covered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important takeaways should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Lambda statements are not inherently bad, but it would be best to make them
    use variables from the local scope only, and they should not be longer than a
    single line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programming can be very powerful, but has a tendency to become unreadable.
    Care must be taken.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list/dict/set` comprehensions are very useful but have a tendency to quickly
    become unreadable. In particular, nested comprehensions are hard to read in nearly
    all cases and should mostly be avoided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ultimately, it is a matter of preference. For the sake of readability, I recommend
    limiting the usage of the functional paradigm when there is no obvious benefit.
    Having said that, when executed correctly, it can be a thing of beauty.
  prefs: []
  type: TYPE_NORMAL
- en: Next up are decorators – methods to wrap your functions and classes in other
    functions and/or classes to modify their behavior and extend their functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code156081100001293319171.png)'
  prefs: []
  type: TYPE_IMG
