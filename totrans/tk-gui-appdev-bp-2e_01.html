<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Meet Tkinter</h1>
                </header>
            
            <article>
                
<p class="mce-root">Welcome to the exciting world of GUI programming with<span> </span>Tkinter. This chapter aims to get you acquainted with Tkinter, the built-in<span> </span><strong>Graphical User Interface</strong> (<strong>GUI</strong>)<strong> </strong>library for all standard Python distributions.</p>
<p>Tkinter<span> </span>(pronounced tea-kay-inter) is the Python interface to Tk, the GUI toolkit for<span> </span>Tcl/Tk.</p>
<p><strong>Tcl</strong><span> </span>(<strong>Tool command language</strong><span>), which is </span>pronounced as tickle, is a popular scripting language in the domains of embedded applications, testing, prototyping, and GUI development. On the other hand, Tk is an open source, multiplatform widget toolkit that is used by many different languages to build GUI programs.</p>
<p>The Tkinter interface is implemented as a Python module—<span> </span><kbd>Tkinter.py</kbd><span> </span>in Python 2.x Versions and<span> </span><kbd>tkinter/__init__.py</kbd><span> </span>in Python 3.x Versions. If you look at the source code, Tkinter is just a wrapper around a C extension that uses the Tcl/Tk libraries.</p>
<p>Tkinter is suitable for a wide variety of areas, ranging from small desktop applications to scientific modeling and research endeavors across various disciplines.</p>
<p>When a person learning Python needs to graduate to GUI programming, Tkinter seems to be the easiest and fastest way to get the work done.</p>
<p>Tkinter is a great tool for the programming of GUI applications in Python. The features that make Tkinter a great choice for GUI programming include the following:</p>
<ul>
<li>It is simple to learn (simpler than any other GUI package for Python)</li>
<li>Relatively little code can produce powerful GUI applications</li>
<li>Layered design ensures that it is easy to grasp</li>
<li>It is portable across all operating systems</li>
<li>It is easily accessible, as it comes pre-installed with the standard Python distribution</li>
</ul>
<p>None of the other Python GUI toolkits have all of these features at the same time.</p>
<p>The purpose of this chapter is to make you comfortable with Tkinter. It aims to introduce you to the various components of GUI programming with Tkinter.</p>
<p>We believe that the concepts that you will develop in this chapter will enable you to apply and develop GUI applications in your area of interest.</p>
<p>The key aspects that we want you to learn from this chapter include the following:</p>
<ul>
<li>Understanding the concept of a root window and the main loop</li>
<li>Understanding widgets—the building blocks of programs</li>
<li>Getting acquainted with a list of available widgets</li>
<li>Developing layouts by using different geometry managers</li>
<li>Applying events and callbacks to make a program functional</li>
<li>Styling widgets by using styling options and configuring the root widget</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>We assume a basic working knowledge of Python. You must know how to write and run basic programs in Python. </p>
<p><span>We will develop our application on the Linux Mint platform. However, since Tkinter is multiplatform, you can follow along with the instructions in this book on Windows, Mac, or any other Linux distribution, without making any modifications to the code.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project overview</h1>
                </header>
            
            <article>
                
<p>By the end of this chapter, you will have developed several partly functional dummy applications, such as the one shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3f78ea3b-9479-4dcc-bdfa-ddd657a00e16.png"/></div>
<p>We call these dummy applications because they are neither fully functional nor do they serve any practical purpose other than to show a particular feature of Tkinter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article>
                
<p>We will write all our projects using Python Version 3.6.3, which is the latest <em>stable</em> release of Python at the time of writing. </p>
<p>The Python download package and instructions for downloading for different platforms are available at<span> </span><a href="https://www.python.org/downloads/release/python-363/">https://www.python.org/downloads/release/python-363/</a>.</p>
<p>The installer binaries for macOS X and the Windows platform are available at the aforementioned link.<span> </span></p>
<p>If you are following along on <span>Unix, Linux, or BSD, t</span>he following procedure will install Python<span> </span><span>from the source.</span></p>
<p>First, install<span> </span><kbd>tk8.6-dev</kbd><span> </span>and<span> </span><kbd>python3-tk</kbd> packages on your computer using your applicable package manager. For instance, on Debian-based systems such as Ubuntu and Mint, run the following two commands from the Terminal:</p>
<pre><strong>sudo apt install tk8.6-dev</strong><br/><strong>sudo apt install python3-tk</strong></pre>
<p>Download Python 3.6.3 from the preceding link and extract it to any location of your choice. Open a Terminal in the location where you extracted Python and type in the following commands:</p>
<pre class="mce-root"><strong>./configure<br/> make<br/> make test<br/> sudo make altinstall</strong></pre>
<p>This should install Python 3.6.3 on your computer. Now open a command line and enter the following command:</p>
<pre><strong>$ python3.6</strong></pre>
<p>This will open the Python 3.6 interactive shell. Type in the following command:</p>
<pre><strong>&gt;&gt;&gt; import tkinter</strong></pre>
<p>This command should execute without any errors. If there are no error messages, the Tkinter module is installed on your Python distribution.</p>
<p>When working with examples from this book, we do not support any Python Version except for Python 3.6.3, which comes bundled with Tkinter Tcl/Tk Version 8.6. However, most of the examples should work out-of-the-box on other minor Python 3 Versions.</p>
<p>To check whether you have the correct Tkinter Version on your Python installation, type the following commands in your IDLE or interactive shell:</p>
<pre><strong>&gt;&gt;&gt; import tkinter</strong><br/><strong>&gt;&gt;&gt; tkinter._test()</strong></pre>
<p>This should confirm the Tcl/Tk Version as 8.6. We are now ready to build our GUI programs!</p>
<p>The next steps are optional and you may skip them at your discretion. While the preceding steps are sufficient for us to develop our programs, I highly recommend that you use a virtual environment for developing your programs.</p>
<p>Virtual environments provide a secluded environment with no conflicts with system programs, and they can be easily reproduced on any other system.</p>
<p>So now let's set up a virtual environment. First, create a folder where you will keep all projects from this book. Let's call it<span> </span><kbd>myTkinterProjects</kbd><span> </span>or whatever suits you.</p>
<p>Next, find the location of the Python 3.6 installation on your computer. On my computer, I can find the location of the Python installation by running the following command:</p>
<pre><strong>$ which python3.6</strong></pre>
<p>Take a note of the location. For me it is <kbd>/usr/local/bin/python3.6</kbd><em>. </em>Now open a Terminal in your <kbd>myTkinterProjects</kbd><span> </span>folder and run the following command:</p>
<pre><strong>$ virtualenv -p /location/of /python3.6   myvenv/</strong></pre>
<p>This will create a new virtual environment in a folder named<span> </span><kbd>myvenv</kbd><span> </span>inside your project folder. </p>
<p>Lastly, we need to activate this virtual environment. This is done by running the following command:</p>
<pre><strong>$ source myenv/bin/activate</strong></pre>
<p>Now if you type the command<span> </span><kbd>python</kbd>, it should pick up Python 3.6.3 from within your virtual environment. </p>
<p>From now onward, every time we have to run a Python script or install a new module, we will first<span> </span>activate<strong> </strong>the virtual environment using the preceding command and run or install the module within this new virtual environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GUI programming – the big picture</h1>
                </header>
            
            <article>
                
<p>As a GUI programmer, you will generally be responsible for deciding the following three aspects<span> </span>of your program:</p>
<ul>
<li>Which components should appear on the screen?</li>
</ul>
<p style="padding-left: 60px">This involves choosing the components that make the user interface. Typical components include things such as buttons, entry fields, checkboxes, radio buttons, and scrollbars. In Tkinter, the components that you add to your GUI are called<span> </span><strong>widgets</strong><span>. Widgets (short for window gadgets) are the graphical components that make up your application's frontend.</span></p>
<ul>
<li>Where should the components go?</li>
</ul>
<p style="padding-left: 60px">This includes deciding the position and the structural layout of various components. In Tkinter, this is referred to as <strong>geometry management</strong>.</p>
<ul>
<li>How do components interact and behave?</li>
</ul>
<p style="padding-left: 60px">This involves adding functionality to each component. Each component or widget does something. For example, a button, when clicked on, does something in response. A scrollbar handles scrolling, and checkboxes and radio buttons enable users to make some choices. In Tkinter, the functionality of various widgets is managed by command binding or<span> </span><strong>event binding</strong><span> </span>using<span> </span><strong>callbacks</strong>.</p>
<p>The following diagram shows the three components of GUI programming:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7542b4be-76af-4fb3-ace5-2748a17594fd.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The root window – your drawing board</h1>
                </header>
            
            <article>
                
<p>GUI programming is an art, and like all art you need a drawing board to capture your ideas. The drawing board that you will use is called the<span> </span><strong>root window</strong>. Our first goal is to get the root window ready.</p>
<p>The following screenshot depicts the root window that we are going to create:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ad6c9d55-193d-4989-8805-266a5c71321c.png"/></div>
<p>Drawing the root window is easy. You just need the following three lines of code:</p>
<pre>import tkinter as tk<br/>root = tk.Tk() #line 2<br/>root.mainloop()</pre>
<p>Save this with the <kbd>.py</kbd> file extension or check out the code present in the <kbd>1.01.py</kbd> file. Open it in the IDLE window or run it from within your activated virtual environment using the following command:</p>
<pre><strong>$ python 1.01.py</strong></pre>
<p>Running this program should generate a blank root window, as shown in the preceding screenshot. This window is equipped with functional minimize, maximize, and close buttons, and a blank frame.</p>
<div class="packt_tip"><span class="packt_screen">Downloading the example code</span><br/>
You can download the example code files for all Packt books you have purchased from your account at <a href="http://www.packtpub.com">http://www.packtpub.com</a>. Apart from going to Packt's official website, you can also find the code files for this book at <a href="https://github.com/PacktPublishing/Tkinter-GUI-Application-Development-Blueprints-Second-Edition">https://github.com/PacktPublishing/Tkinter-GUI-Application-Development-Blueprints-Second-Edition</a>. If you purchased this book elsewhere, you can visit <a href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files emailed directly to you.</div>
<p>The following is a description of the preceding code:</p>
<ul>
<li>The first line imported the <kbd>tkinter</kbd> module into the namespace with <kbd>tk</kbd> as its alias. Now we can access all definitions of <span>the classes, attributes, and methods of Tkinter </span>by appending the alias tk to the name as in <kbd>tk.Tk()</kbd>.</li>
<li>The second line created an instance of the <kbd>tkinter.Tk</kbd> class. This created what is called the <strong>root window</strong>, which is shown in the preceding screenshot. According to the conventions, the root window in Tkinter is usually called <strong>root</strong>, but you are free to call it by any other name.</li>
<li>The third line executed the<span> </span><kbd>mainloop</kbd><span> </span>(that is, the event loop) method of the root object. The <kbd>mainloop</kbd> method is what keeps the root window visible. If you remove the third line, the window created in line 2 will disappear immediately as soon as the script stops running. This will happen so fast that you will not even see the window appearing on your screen. Keeping the <kbd>mainloop</kbd> method running also lets you keep the program running until you press the <span class="packt_screen">Close</span> button, which exits <kbd>mainloop</kbd>.</li>
<li>Tkinter also exposed the <kbd>mainloop</kbd> method as<span> </span><kbd>tkinter.mainloop()</kbd>. So, you can even call <kbd>mainloop()</kbd> directly instead of calling<span> </span><kbd>root.mainloop()</kbd>.</li>
</ul>
<p>Congratulations! You have completed your first objective, which was to draw the root window. You have now prepared your drawing board (root window). Now, get ready to paint it with your imagination!</p>
<div class="packt_infobox">Commit the three lines of code (shown in code <kbd>1.01.py</kbd>) to memory. These three lines generate your root window, which will accommodate all the other graphical components. These lines form the skeleton of any GUI application that you will develop in Tkinter. The entire code that will make your GUI application functional will go between line 2 (new object creation) and line 3 (<kbd>mainloop</kbd>) of this code.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Widgets – the building blocks of GUI programs</h1>
                </header>
            
            <article>
                
<p>Now that we have our top level or the root window ready, it is time to think over the question: which components should appear in the window? In Tkinter jargon, these components are called <strong>widgets</strong>.</p>
<p>The syntax that is used to add a widget is as follows:</p>
<pre>my_widget = tk.Widget-name (its container window, ** its configuration options)</pre>
<p>In the following example ( <kbd>1.02.py</kbd> ), we will add two widgets, a<span> </span>label and a<span> </span>button, to the root container. Also, note how all the widgets are added between the skeleton code that we defined in the first example:</p>
<pre>import tkinter as tk<br/>root = tk.Tk()<br/>label = tk.Label(root, text="I am a label widget")<br/>button = tk.Button(root, text="I am a button")<br/>label.pack()<br/>button.pack()<br/>root.mainloop()</pre>
<p><span>Running the preceding code(<kbd>1.02.py</kbd>) will generate a window with a label and a button </span><span>widget, as shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="86" src="assets/bb8d5d9f-c921-4675-91f6-822f9f7a7f67.png" width="142"/></div>
<p>The following is a description of the preceding code:</p>
<ul>
<li>This code added a new instance named <kbd>label</kbd> for the label widget. The first parameter defined root as its parent or container. The second parameter configured its text option to read  <kbd>I am a label widget</kbd>.</li>
<li>Similarly, we defined an instance of a Button<span> </span>widget. This is also bound to the root window as its parent.</li>
<li>We used the <kbd>pack()</kbd> method, which is essentially required to position the label and button widgets within the window. We will discuss the <kbd>pack()</kbd> method and several other related concepts when exploring the geometry management task. However, you must note that some sort of geometry specification is essential for the widgets to be displayed.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Some important widget features</h1>
                </header>
            
            <article>
                
<p>Note the following few important features that are common to all widgets:</p>
<ul>
<li>All widgets are actually objects derived from their respective widget classes. So, a statement such as <kbd>button = Button(its_parent)</kbd> actually creates a button instance from the <kbd>Button</kbd> class.</li>
<li>Each widget has a set of options that decides its behavior and appearance. This includes attributes such as text labels, colors, and font size. For example, the Button widget has attributes to manage its label, control its size, change its foreground and background colors, change the size of the border, and more.</li>
<li>To set these attributes, you can set the values directly at the time of creating the widget, as demonstrated in the preceding example. Alternatively, you can later set or change the options of the widget by using the <kbd>.config()</kbd> or <kbd>.configure()</kbd> method. Note that the <kbd>.config()</kbd> or <kbd>.configure()</kbd> methods are interchangeable and provide the same functionality. In fact, the <kbd>.config()</kbd> method is simply an alias of the <kbd>.configure()</kbd> method.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ways to create widgets</h1>
                </header>
            
            <article>
                
<p>There are two ways to create widgets in Tkinter.</p>
<p>The first way involves creating a widget in one line and then adding the <kbd>pack()</kbd> method (or other geometry managers) in the next line, as follows:</p>
<pre>my_label = tk.Label(root, text="I am a label widget")<br/>my_label.pack()</pre>
<p>Alternatively, you can write both the lines together, as follows:</p>
<pre>tk.Label(root, text="I am a label widget").pack()</pre>
<p>You can either save a reference to the widget created (<span> </span><kbd>my_label</kbd>, as in the first example), or create a widget without keeping any reference to it (as demonstrated in the second example).</p>
<p>You should ideally keep a reference to the widget in case the widget has to be accessed later on in the program. For instance, this is useful in case you need to call one of its internal methods or for its content modification. If the widget state is supposed to remain static after its creation, you need not keep a reference to the widget.</p>
<div class="packt_tip">Note that calls to <kbd>pack()</kbd> (or other geometry managers) always return <kbd>None</kbd>. So, consider a situation where you create a widget, and add a geometry manager (say, <kbd>pack()</kbd>) on the same line, as follows: <kbd>my_label = tk.Label(...).pack()</kbd>. In this case, you are not creating a reference to the widget. Instead, you are creating a <kbd>None</kbd> type object for the <kbd>my_label</kbd> variable. So, when you later try to modify the widget through the reference, you get an error because you are actually trying to work on a <kbd>None</kbd> type object. If you need a reference to a widget, you must create it on one line and then specify its geometry (like <kbd>pack()</kbd>) on the second line, as follows:<br/>
<kbd>my_label = tk.Label(...)</kbd><br/>
<kbd>my_label.pack()</kbd><br/>
This is one of the most common mistakes committed by beginners.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting to know the core Tkinter widgets</h1>
                </header>
            
            <article>
                
<p>Now you will get to know all the core Tkinter widgets. You have already seen two of them in the previous example—the Label<span> </span>and Button<span> </span>widgets. Now, let's explore all the other core Tkinter widgets.</p>
<p>Tkinter includes 21 core widgets, which are as follows:</p>
<table>
<tbody>
<tr>
<td><strong>Top-level</strong></td>
<td><strong>Label</strong></td>
<td><strong>Button</strong></td>
</tr>
<tr>
<td>Canvas</td>
<td>Checkbutton</td>
<td>Entry</td>
</tr>
<tr>
<td>Frame</td>
<td>LabelFrame</td>
<td>Listbox</td>
</tr>
<tr>
<td>Menu</td>
<td>Menubutton</td>
<td>Message</td>
</tr>
<tr>
<td>OptionMenu</td>
<td>PanedWindow</td>
<td>Radiobutton</td>
</tr>
<tr>
<td>Scale</td>
<td>Scrollbar</td>
<td>Spinbox</td>
</tr>
<tr>
<td>Text</td>
<td>Bitmap</td>
<td>Image</td>
</tr>
</tbody>
</table>
<p>Let's write a program to display all of these widgets in the root window.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding widgets to a parent window</h1>
                </header>
            
            <article>
                
<p>The format used to add widgets is the same as the one that we discussed in the previous task. To give you an idea about how it's done, here's some sample code that adds some common widgets:</p>
<pre>Label(parent, text="Enter your Password:")<br/>Button(parent, text="Search")<br/>Checkbutton(parent, text="Remember Me", variable=v, value=True)<br/>Entry(parent, width=30)<br/>Radiobutton(parent, text="Male", variable=v, value=1)<br/>Radiobutton(parent, text="Female", variable=v, value=2)<br/>OptionMenu(parent, var, "Select Country", "USA", "UK", "India","Others")<br/>Scrollbar(parent, orient=VERTICAL, command= text.yview)</pre>
<p>Can you spot the pattern that is common to each widget? Can you spot the differences?</p>
<p>As a reminder, the syntax for adding a widget is as follows:</p>
<pre>Widget-name(its_parent, **its_configuration_options)</pre>
<p>Using the same pattern, let's add all the 21 core Tkinter widgets into a dummy application (<kbd>1.03.py</kbd>). We do not reproduce the entire code here. A summarized code description for<span> </span><kbd>1.03.py</kbd><span> </span>is as follows:</p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="1">
<li>We create a top-level window and a <kbd>mainloop</kbd>, as shown in the earlier examples. </li>
<li>We add a frame widget and name it<span> </span><kbd>menu_bar</kbd>. Note that<span> f</span>rame widgets are just holder widgets that hold other widgets.<span> </span>Frame<span> </span>widgets are great for grouping widgets together. The syntax for adding a frame is the same as that for all the other widgets:</li>
</ol>
<pre class="mce-root">        frame = Frame(root)<br/><span>        frame.pack()</span></pre>
<ol start="3">
<li>Keeping the <kbd>menu_bar</kbd> frame as the container, we add two widgets to it:
<ul>
<li>Menubutton</li>
<li>Menu</li>
</ul>
</li>
<li>We create another frame widget and name it <kbd>frame</kbd>. Keeping <kbd>frame</kbd> as the container/parent widget, we add the following seven widgets to it:
<ul>
<li>Label</li>
<li>Entry</li>
<li>Button</li>
<li>Checkbutton</li>
<li>Radiobutton</li>
<li>OptionMenu</li>
<li><kbd>Bitmap</kbd> Class</li>
</ul>
</li>
<li>We then proceed to create another frame widget. We add six more widgets to the frame:
<ul>
<li><kbd>Image</kbd> Class</li>
<li>Listbox</li>
<li>Spinbox</li>
<li>Scale</li>
<li>LabelFrame</li>
<li>Message</li>
</ul>
</li>
<li>We then create another frame widget. We add two more widgets to the frame:
<ul>
<li>Text</li>
<li>Scrollbar</li>
</ul>
</li>
</ol>
<ol start="7">
<li>We create another frame widget and add two more widgets to it:
<ul>
<li>Canvas</li>
<li>PanedWindow</li>
</ul>
</li>
</ol>
<p>These constitute the 21 core widgets of Tkinter. Now that you have had a glimpse of all the widgets, let's discuss how to specify the location of these widgets using geometry managers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Tkinter geometry manager</h1>
                </header>
            
            <article>
                
<p>You may recall that we used the <kbd>pack()</kbd> method to add widgets to the dummy application that we developed in the previous section. The <kbd>pack()</kbd> method is an example of geometry management in Tkinter.</p>
<p>The <kbd>pack()</kbd> method is not the only way of managing the geometry in your interface. In fact, there are three geometry managers in Tkinter that let you specify the position of widgets inside a top-level or parent window.</p>
<p>The<span> </span>three geometry managers<span> </span>are as follows:</p>
<ul>
<li><strong>pack</strong>: This is the one that we have used so far. It is simple to use for simpler layouts, but it may get very complex for slightly complex layouts.</li>
<li><strong>grid</strong>: This is the most commonly used geometry manager, and provides a table-like layout of management features for easy layout management.</li>
<li><strong>place</strong>: This is the least popular, but it provides the best control for the absolute positioning of widgets.</li>
</ul>
<p>Now, let's have a look at some examples of all the three geometry managers in action.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The pack geometry manager</h1>
                </header>
            
            <article>
                
<p>The pack manager can be a bit tricky to explain in words, and it can best be understood by playing with the code base. Fredrik Lundh, the author of Tkinter, asks us to imagine the root as an elastic sheet with a small opening at the center. The pack geometry manager makes a hole in the elastic sheet that is just large enough to hold the widget. The widget is placed along a given inner edge of the gap (the default is the top edge). It then repeats the process till all the widgets are accommodated.</p>
<p>Finally, when all the widgets have been packed in the elastic sheet, the geometry manager calculates the bounding box for all the widgets. It then makes the parent widget large enough to hold all the child widgets.</p>
<p>When packing child widgets, the pack manager distinguishes between the following three kinds of space:</p>
<ul>
<li>Unclaimed space</li>
<li>Claimed but unused space</li>
<li>Claimed and used space</li>
</ul>
<p>The most commonly used options in pack include the following:</p>
<ul>
<li><kbd>side</kbd>: <kbd>LEFT</kbd>, <kbd>TOP</kbd>, <kbd>RIGHT</kbd>, and BOTTOM (these decide the alignment of the widget)</li>
<li><kbd>fill</kbd>: X, Y, BOTH, and NONE (these decide whether the widget can grow in size)</li>
<li><kbd>expand</kbd>: Boolean values such as <kbd>tkinter.YES</kbd>/<kbd>tkinter.NO</kbd>, <kbd>1</kbd> / <kbd>0</kbd>, and <kbd>True</kbd>/<kbd>False</kbd></li>
<li><kbd>anchor</kbd>: NW, N, <kbd>NE</kbd>, <kbd>E</kbd>, <kbd>SE</kbd>, S, SW, <kbd>W</kbd>, and CENTER (corresponding to the cardinal directions)</li>
<li>Internal padding ( <kbd>ipadx</kbd> and <kbd>ipady</kbd> ) for the padding inside widgets and external padding ( <kbd>padx</kbd> and <kbd>pady</kbd> ), which all default to a value of zero </li>
</ul>
<p>Let's take a look at demo code that illustrates some of the pack features.</p>
<p>Two of the most commonly used pack options are <kbd>fill</kbd> and <kbd>expand</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img height="208" src="assets/f7e36bba-503c-4e0b-9826-8f82f51f42a3.png" width="189"/></div>
<div>
<p>The following code<span> </span><em>(</em><kbd>1.04.py</kbd><em>)</em><span> </span>generates a GUI like the one shown in the preceding screenshot:</p>
</div>
<pre><span>import </span>tkinter as tk<br/>root = tk.Tk()<br/>frame = tk.Frame(root)<br/># demo of side and fill options<br/>tk.Label(frame, text="Pack Demo of side and fill").pack()<br/>tk.Button(frame, text="A").pack(side=tk.LEFT, fill=tk.Y)<br/>tk.Button(frame, text="B").pack(side=tk.TOP, fill=tk.X)<br/>tk.Button(frame, text="C").pack(side=tk.RIGHT, fill=tk.NONE)<br/>tk.Button(frame, text="D").pack(side=tk.TOP, fill=tk.BOTH)<br/>frame.pack()<br/># note the top frame does not expand or fill in X or Y directions<br/># demo of expand options - best understood by expanding the root<br/>#vwidget and seeing the effect on all the three buttons below.<br/>tk.Label (root, text="Pack Demo of expand").pack()<br/>tk.Button(root, text="I do not expand").pack()<br/>tk.Button(root, text="I do not fill x but I expand").pack(expand = 1)<br/>tk.Button(root, text="I fill x and expand").pack(fill=tk.X, expand=1)<br/>root.mainloop()</pre>
<p><span>The following is a description of the preceding code:</span></p>
<ul>
<li>When you insert the <kbd>A</kbd> button in the root frame, it captures the leftmost area of the frame, expands, and fills the <kbd>Y</kbd> dimension. Because the fill option is specified as <kbd>fill=tk.Y</kbd>, it claims all the area that it wants and fills the <kbd>Y</kbd> dimension of its container frame.</li>
<li>Because frame is itself packed with a plain <kbd>pack()</kbd> method with no mention of a pack option, it takes the minimum space required to accommodate all of its child widgets.</li>
<li>If you increase the size of the root window by pulling it down or sideways, you will see that all the buttons within the frame do not fill or expand with the root window.</li>
<li>The positioning of the <kbd>B</kbd>, <kbd>C</kbd>, and <kbd>D</kbd> buttons occurs on the basis of the side and fill options specified for each of them. </li>
<li>The next three buttons (after <kbd>B</kbd>, <kbd>C</kbd>, and <kbd>D</kbd>) demonstrate the use of the expand option. A value of <kbd>expand=1</kbd> means that the button moves its place on resizing the window. Buttons with no explicit expand options stay in their place and do not respond to changes in the size of their parent container (the root window, in this case).</li>
<li>The best way to study this piece of code would be to resize the root window to see the effect that it has on various buttons.</li>
<li>The <kbd>anchor</kbd> attribute (not used in the preceding code) provides a means to position a widget relative to a reference point. If the <kbd>anchor</kbd> attribute is not specified, the pack manager places the widget at the center of the available space or the packing box. The other options that are allowed include the four cardinal directions (N, S, <kbd>E</kbd>, and <kbd>W</kbd>) and a combination of any two directions. Therefore, valid values for the <kbd>anchor</kbd> attribute are <kbd>CENTER</kbd> (the default value), N, S, E, <kbd>W</kbd>, NW, <kbd>NE</kbd>, SW, and <kbd>SE</kbd>.</li>
</ul>
<div class="packt_tip">The values for most Tkinter geometry manager attributes can either be specified in capital letters without quotes (such as <kbd>side=tk.TOP </kbd>and <kbd>anchor=tk.SE</kbd>) or in small letters within quotes (such as <kbd>side='top'</kbd>and <kbd>anchor='se'</kbd>).</div>
<p>We will use the pack geometry manager in some of our projects. Therefore, it will be worthwhile to get acquainted with pack and its options.</p>
<p>The pack manager is ideally suited for the following two kinds of situation:</p>
<ul>
<li>Placing widgets in a top-down manner</li>
<li>Placing widgets side by side</li>
</ul>
<p><br/>
<kbd>1.05.py</kbd><span> </span>shows an example of both of these scenarios:</p>
<pre>parent = tk.Frame(root)<br/># placing widgets top-down<br/>tk.Button(parent, text='ALL IS WELL').pack(fill=tk.X)<br/>tk.Button(parent, text='BACK TO BASICS').pack(fill=tk.X)<br/>tk.Button(parent, text='CATCH ME IF U CAN').pack(fill=tk.X)<br/># placing widgets side by side<br/>tk.Button(parent, text='LEFT').pack(side=tk.LEFT)<br/>tk.Button(parent, text='CENTER').pack(side=tk.LEFT)<br/>tk.Button(parent, text='RIGHT').pack(side=tk.LEFT)<br/>parent.pack()</pre>
<p>The preceding code produces a GUI, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/34000aa1-485f-43f3-ae57-9dce5eabbcc3.png"/></div>
<p>For a complete pack reference, type the following command in the Python shell:</p>
<pre><strong>&gt;&gt; import tkinter</strong><br/><strong>&gt;&gt;&gt; help(tkinter.Pack)<br/></strong></pre>
<p>Besides getting interactive help with documentation, Python's REPL is also a great tool for iterating and quick prototyping of Tkinter programs.</p>
<div class="packt_infobox"><span class="packt_screen">Where should you use the pack() geometry manager?</span><br/>
<span>Using the </span>pack<span> manager is somewhat complicated as compared to the </span><kbd>grid</kbd><span><span> method, which will be discussed next, but it is a great choice in situations such as the following:<br/></span></span>
<ul>
<li><span>Having a widget fill the complete container frame</span></li>
<li><span>Placing several widgets on top of each other or side by side (as shown in the preceding screenshot)</span></li>
</ul>
</div>
<p>Although you can create complicated layouts by nesting widgets in multiple frames, you will find the grid geometry manager more suitable for most complex layouts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The grid geometry manager</h1>
                </header>
            
            <article>
                
<p>The grid geometry manager is easy to understand and perhaps the most useful geometry manager in Tkinter. The central idea of the grid geometry manager is to organize the container frame into a two-dimensional table that is divided into a number of rows and columns. Each cell in the table can then be targeted to hold a widget. In this context, a cell is an intersection of imaginary rows and columns.</p>
<p>Note that in the <kbd>grid</kbd> method, each cell can hold only one widget. However, widgets can be made to span multiple cells.</p>
<p>Within each cell, you can further align the position of the widget using the sticky option. The sticky option decides how the widget is expanded. If its container cell is larger than the size of the widget that it contains, the sticky option can be specified using one or more of the N, S, <kbd>E</kbd>, and <kbd>W</kbd> options or the NW, <kbd>NE</kbd>, SW, and <kbd>SE</kbd> options.</p>
<p>Not specifying stickiness <span>defaults stickiness</span> to the center of the widget in the cell.</p>
<p>Let's have a look at demo code that illustrates some features of the grid geometry manager. The code in<span> </span><kbd>1.06.py</kbd><span> </span>generates a GUI, as shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/8ea6ee20-8e4a-4a32-bce6-cb95f6816f82.png"/></div>
<p>The following code (<kbd>1.06.py</kbd>) generates the preceding GUI:</p>
<pre><br/>import tkinter as tk<br/>root = tk.Tk()<br/>tk.Label(root, text="Username").grid(row=0, sticky=tk.W)<br/>tk.Label(root, text="Password").grid(row=1, sticky=tk.W)<br/>tk.Entry(root).grid(row=0, column=1, sticky=tk.E)<br/>tk.Entry(root).grid(row=1, column=1, sticky=tk.E)<br/>tk.Button(root, text="Login").grid(row=2, column=1, sticky=tk.E)<br/>root.mainloop()</pre>
<p>The following is a description of the preceding code:</p>
<ul>
<li>Take a look at the grid position defined in terms of the row and column positions for an imaginary grid table spanning the entire frame. See how the use of <kbd>sticky=tk.W</kbd> on both the labels makes them stick on the left-hand side, thus resulting in a clean layout.</li>
<li>The width of each column (or the height of each row) is automatically decided by the height or width of the widgets in the cell. Therefore, you need not worry about specifying the row or column width as equal. You can specify the width for widgets if you need that extra bit of control.</li>
<li>You can use the <kbd>sticky=tk.NSEW</kbd> argument to make the widget expandable and fill the entire cell of the grid.</li>
</ul>
<p>In a more complex scenario, your widgets may span across multiple cells in the grid. To make a grid to span multiple cells, the <kbd>grid</kbd> method offers handy options such as <kbd>rowspan</kbd><span> </span>and<span> </span><kbd>columnspan</kbd>.</p>
<p>Furthermore, you may often need to provide some padding between cells in the grid. The grid manager provides the<span> </span><kbd>padx</kbd><span> </span>and<span> </span><kbd>pady</kbd><span> </span>options to provide padding that needs to be placed around a widget.</p>
<p>Similarly, the<span> </span><kbd>ipadx</kbd><span> </span>and<span> </span><kbd>ipady</kbd><span> </span>options are used for internal padding. These options add padding within the widget itself. The default value of external and internal padding is <kbd>0</kbd>.</p>
<p>Let's have a look at an example of the grid manager, where we use most of the common arguments to the grid method, such as <kbd>row</kbd>, <kbd>column</kbd>, <kbd>padx</kbd>, <kbd>pady</kbd>, <kbd>rowspan</kbd>, and <kbd>columnspan</kbd>.</p>
<p><kbd>1.07.py</kbd> produces a GUI, as shown in the following screenshot, to demonstrate how to use the grid geometry manager options:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/d819f6d9-ae50-4602-bd32-95640349200c.png"/></div>
<p>The following code ( <kbd>1.07.py</kbd> ) generates the preceding GUI:</p>
<pre>import tkinter as tk<br/>parent = tk.Tk()<br/>parent.title('Find &amp; Replace')<br/>tk.Label(parent, text="Find:").grid(row=0, column=0, sticky='e')<br/>tk.Entry(parent, width=60).grid(row=0, column=1, padx=2, pady=2, <br/>                                sticky='we', columnspan=9)<br/>tk.Label(parent, text="Replace:").grid(row=1, column=0, sticky='e')<br/>tk.Entry(parent).grid(row=1, column=1, padx=2, pady=2, sticky='we',<br/>                       columnspan=9)<br/>tk.Button(parent, text="Find").grid( row=0, column=10, sticky='e' + 'w', <br/>                                padx=2, pady=2)<br/>tk.Button(parent, text="Find All").grid(<br/>                     row=1, column=10, sticky='e' + 'w', padx=2)<br/>tk.Button(parent, text="Replace").grid(row=2, column=10, sticky='e' +<br/>                               'w', padx=2)<br/>tk.Button(parent, text="Replace All").grid(<br/>                     row=3, column=10, sticky='e' + 'w', padx=2)<br/>tk.Checkbutton(parent, text='Match whole word only').grid(<br/>                     row=2, column=1, columnspan=4, sticky='w')<br/>tk.Checkbutton(parent, text='Match Case').grid(<br/>                     row=3, column=1, columnspan=4, sticky='w')<br/>tk.Checkbutton(parent, text='Wrap around').grid(<br/>                     row=4, column=1, columnspan=4, sticky='w')<br/>tk.Label(parent, text="Direction:").grid(row=2, column=6, sticky='w')<br/>tk.Radiobutton(parent, text='Up', value=1).grid(<br/>                     row=3, column=6, columnspan=6, sticky='w')<br/>tk.Radiobutton(parent, text='Down', value=2).grid(<br/>                     row=3, column=7, columnspan=2, sticky='e')<br/>parent.mainloop()</pre>
<p>Note how just 14 lines of the core grid manager code generate a complex layout such as the one shown in the preceding screenshot. On the other hand, developing this with the pack manager would have been much more tedious.</p>
<p>Another grid option that you can sometimes use is the<span> </span><kbd>widget.grid_forget()</kbd> method. This method can be used to hide a widget from the screen. When you use this option, the widget still exists at its former location, but it becomes invisible. The hidden widget may be made visible again, but the grid options that you originally assigned to the widget will be lost.</p>
<p>Similarly, there is a<span> </span><kbd>widget.grid_remove()</kbd><span> </span>method that removes the widget, except that in this case, when you make the widget visible again, all of its grid options will be restored.</p>
<p>For a complete grid reference, type the following command in the Python shell:</p>
<pre><strong>&gt;&gt;&gt; import tkinter</strong><br/><strong>&gt;&gt;&gt; help(tkinter.Grid)</strong></pre>
<div class="packt_tip"><span class="packt_screen">Where should you use the grid geometry manager?</span><br/>
The grid manager is a great tool for the development of complex layouts. Complex structures can be easily achieved by breaking the container widget into grids of rows and columns and then placing the widgets in grids where they are wanted. It is also commonly used to develop different kinds of dialog box.</div>
<p>Now we will delve into configuring a grid's column and row sizes.</p>
<p>Different widgets have different heights and widths. So, when you specify the position of a widget in terms of rows and columns, the cell automatically expands to accommodate the widget.</p>
<p>Normally, the height of all the grid rows is automatically adjusted so it's the height of its tallest cell. Similarly, the width of all the grid columns is adjusted so it's equal to the width of the widest widget cell.</p>
<p>If you then want a smaller widget to fill a larger cell or to stay on any one side of the cell, you can use the sticky attribute on the widget to control this aspect. </p>
<p>However, you can override this automatic sizing of columns and rows by using the following code:</p>
<pre>w.columnconfigure(n, option=value, ...) AND<br/>w.rowconfigure(<span>n</span>, option=value, ...)</pre>
<p>Use these to configure the options for a given widget, <kbd>w</kbd>, in either the <em>n</em><sup>th</sup><span> </span>column or the <em>n</em><sup>th</sup><span> </span>row, specifying values for the options, minsize, pad, and weight. Note that the numbering of rows begins from <kbd>0</kbd> and not <kbd>1</kbd>.</p>
<p>The options available are as follows:</p>
<table>
<tbody>
<tr>
<td><strong>Options</strong></td>
<td><strong>Descriptions</strong></td>
</tr>
<tr>
<td>
<p>minsize</p>
</td>
<td>
<p>This is the minimum size of a column or row in pixels. If there is no widget in a given column or row, the cell does not appear in spite of this minsize specification.</p>
</td>
</tr>
<tr>
<td>
<p>pad</p>
</td>
<td>
<p>This is the external padding in pixels that will be added to the specified column or row over the size of the largest cell.</p>
</td>
</tr>
<tr>
<td>
<p>weight</p>
</td>
<td>
<p class="mce-root">This specifies the relative weight of a row or column and then distributes the extra space. This enables making the row or column stretchable.</p>
<p>For example, the following code distributes two-fifths of the extra space to the first column and three-fifths to the second column:<br/>
<kbd>w.columnconfigure(0, weight=2)</kbd><br/>
<kbd>w.columnconfigure(1, weight=3)</kbd></p>
</td>
</tr>
</tbody>
</table>
<p>The <kbd>columnconfigure()</kbd> and <kbd>rowconfigure()</kbd> methods are often used to implement the dynamic resizing of widgets, especially on resizing the root window.</p>
<div class="packt_infobox">You cannot use the <kbd>grid</kbd> and <kbd>pack</kbd> methods together in the same container window. If you try doing that, your program will raise a <kbd>_tkinter.TclError</kbd> error.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The place geometry manager</h1>
                </header>
            
            <article>
                
<p>The place geometry manager is the most rarely used geometry manager in Tkinter. Nevertheless, it has its uses in that it lets you precisely position widgets within their parent frame by using the (<em>x</em>,<em>y</em>) coordinate system.</p>
<p>The place manager can be accessed by using the <kbd>place()</kbd> method on any standard widget.</p>
<p>The important options for place geometry include the following:</p>
<ul>
<li>Absolute positioning (specified in terms of <em>x</em>=<em>N</em> or <em>y</em>=<em>N</em>)</li>
<li>Relative positioning (the key options include <kbd>relx</kbd>, <kbd>rely</kbd>, <kbd>relwidth</kbd>, and <kbd>relheight</kbd>)</li>
</ul>
<p>The other options that are commonly used with place include<span> </span><kbd>width</kbd><span> </span>and<span> </span><kbd>anchor</kbd>(the default is NW).</p>
<p>Refer to<span> </span><kbd>1.08.py</kbd><span> </span>for a demonstration of common place options:</p>
<pre>import tkinter as tk<br/>root = tk.Tk()<br/># Absolute positioning<br/>tk.Button(root, text="Absolute Placement").place(x=20, y=10)<br/># Relative positioning<br/>tk.Button(root, text="Relative").place(relx=0.8, rely=0.2, relwidth=0.5, <br/>                              width=10,  anchor=tk.NE)<br/>root.mainloop()</pre>
<p>You may not see much of a difference between the absolute and relative positions simply by looking at the code or the window frame. However, if you try resizing the window, you will observe that the <span class="packt_screen">Absolute Placement</span> button does not change its coordinates, while the <span class="packt_screen">Relative</span> button changes its coordinates and size to accommodate the new size of the root window:</p>
<div class="CDPAlignCenter CDPAlign"><img height="182" src="assets/cb110351-f255-4945-8e08-384c44f9a116.png" width="163"/></div>
<p>For a complete <kbd>place</kbd><span> </span>reference, type the following command in the Python shell:</p>
<pre><strong>&gt;&gt;&gt; import tkinter</strong><br/><strong>&gt;&gt;&gt; help(tkinter.Place)</strong></pre>
<div class="packt_infobox"><span class="packt_screen">When should you use the place manager?</span><br/>
The place manager is useful in situations where you have to implement custom geometry managers, or where the widget placement is decided by the end user.</div>
<p>While the pack and grid managers cannot be used together in the same frame, the place manager can be used with any geometry manager within the same container frame.</p>
<p>The place manager is rarely used because, if you use it, you have to worry about the exact coordinates. If you make a minor change to a widget, it is very likely that you will have to change the <em>x</em>,<em>y</em> values for other widgets as well, which can be very cumbersome. We will use the place manager in <a href="d70da161-121d-453a-806b-95b71524fb79.xhtml">Chapter 7</a><em>, Piano Tutor</em>.</p>
<p>This concludes our discussion on geometry management in Tkinter.</p>
<p>In this section, you had a look at how to implement the pack, grid, and place geometry managers. You also understood the strengths and weaknesses of each geometry manager.</p>
<p>You learned that pack is suitable for a simple side-wise or top-down widget placement. You also learned that the grid manager is best suited for the handling of complex layouts. You saw examples of the place geometry manager and explored the reasons behind why it is rarely used.</p>
<p>You should now be able to plan and execute different layouts for your programs using these Tkinter geometry managers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Events and callbacks – adding life to programs</h1>
                </header>
            
            <article>
                
<p>Now that you have learned how to add widgets to a screen and position them where you want, let's turn our attention to the third component of GUI programming.</p>
<p>This addresses the question of how to make widgets functional.</p>
<p>Making widgets functional involves making them responsive to events such as the pressing of buttons, the pressing of keys on a keyboard, and mouse clicks. </p>
<p>This requires associating callbacks with specific events. Callbacks are normally associated with specific widget events using command binding rules, which are discussed in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Command binding</h1>
                </header>
            
            <article>
                
<p>The simplest way to add functionality to a button is called <strong>command binding</strong>, whereby a callback function is mentioned in the form of <kbd>command = some_callback</kbd> in the widget option. Note that the <kbd>command</kbd> option is available only for a few selected widgets.</p>
<p>Take a look at the following sample code:</p>
<pre>def my_callback ():<br/>   # do something when button is clicked</pre>
<p>After defining the preceding callback, we can connect it to, say, a button with the <kbd>command</kbd> option referring to the callback, as follows:</p>
<pre>tk.Button(root, text="Click me", command=my_callback)</pre>
<p>A <strong>callback</strong> is a function memory reference ( <kbd>my_callback</kbd> in the preceding example) that is called by another function (which is <kbd>Button</kbd> in the preceding example) and that takes the first function as a parameter. Put simply, a callback is a function that you provide to another function so that it can calling it.</p>
<p>Note that <kbd>my_callback</kbd> is passed without parentheses, <kbd>()</kbd>, from within the widget <kbd>command</kbd> option, because when the callback functions are set it is necessary to pass a reference to a function rather than actually call it.</p>
<p>If you add parentheses, <kbd>()</kbd>, as you would for any normal function, it would be called as soon as the program runs. In contrast, the callback is called only when an event occurs (the pressing of a button in this case).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Passing arguments to callbacks</h1>
                </header>
            
            <article>
                
<p>If a callback does not take any argument, it can be handled with a simple function, such as the one shown in the preceding code. However, if a callback needs to take arguments, we can use the <kbd>lambda</kbd> function, as shown in the following code snippet:</p>
<pre>def my_callback (argument)<br/>   #do something with argument</pre>
<p>Then, somewhere else in the code, we define a button with a command callback that takes some arguments, as follows:</p>
<pre>tk.Button(root,text="Click", command=lambda: my_callback ('some argument'))</pre>
<p>Python borrows a specific syntax from functional programming, called the <kbd>lambda</kbd> function.  The <kbd>lambda</kbd> function lets you define a single-line, nameless function on the fly. </p>
<p>The format for using <kbd>lambda</kbd> is as follows:</p>
<pre>lambda arg: #do something with arg in a single line</pre>
<p>Here's an example:</p>
<pre>square = lambda x: x**2</pre>
<p>Now, we can call the <kbd>square</kbd> method, as follows:</p>
<pre>&gt;&gt; print(square(5)) ## prints 25 to the console</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Limitations of the command option</h1>
                </header>
            
            <article>
                
<p>The <kbd>command</kbd> option that is available with the Button widget and a few other widgets is a function that can make the programming of a click-of-a-button event easy. Many other widgets do not provide an equivalent command binding option.</p>
<p>By default, the command button binds to the left-click and the spacebar. It does not bind to the <em>Return</em> key. Therefore, if you bind a button by using the <kbd>command</kbd> function, it will react to the space bar and not the <em>Return</em> key. This is counter-intuitive for many users. What's worse is that you cannot change the binding of the command function easily. The moral is that command binding, though a very handy tool, is not flexible enough when it comes to deciding your own bindings.</p>
<p>This brings us to the next method for handling events.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Event binding</h1>
                </header>
            
            <article>
                
<p>Fortunately, Tkinter provides an alternative event binding mechanism called <kbd>bind()</kbd> to let you deal with different events. The standard syntax used to bind an event is as follows:</p>
<pre>widget.bind(event, handler, add=None)</pre>
<p>When an event corresponding to the event description occurs in the widget, it calls not only the associated handler, which passes an instance of the event object as the argument, but also the details of the event. If there already exists a binding for that event for this widget, the old callback is usually replaced with the new handler, but you can trigger both the callbacks by passing <kbd>add='+'</kbd> as the last argument.</p>
<p>Let's look at an example of the <kbd>bind()</kbd> method (code <kbd>1.09.py</kbd>):</p>
<pre>import tkinter as tk<br/>root = tk.Tk()<br/>tk.Label(root, text='Click at different\n locations in the frame below').pack()<br/><br/>def callback(event):<br/>    print(dir(event))<br/>    print("you clicked at", event.x, event.y)<br/><br/>frame = tk.Frame(root, bg='khaki', width=130, height=80)<br/>frame.bind("&lt;Button-1&gt;", callback)<br/>frame.pack()<br/>root.mainloop()</pre>
<p>The following is a description of the preceding code: </p>
<ul>
<li>We bind the Frame widget to the <kbd>&lt;Button-1&gt;</kbd> event, which corresponds to the left-click. When this event occurs, it calls the <kbd>callback</kbd> function, passing an object instance as its argument.</li>
<li>We define the <kbd>callback(event)</kbd> function. Note that it takes the <kbd>event</kbd> object generated by the event as an argument.</li>
<li>We inspect the event object by using <kbd>dir(event)</kbd>, which returns a sorted list of attribute names for the event object passed to it. This prints the following list:</li>
</ul>
<pre class="mce-root" style="padding-left: 60px"> [ '__doc__' , '__module__' , 'char' , 'delta' , 'height' , 'keycode' , 'keysym' , keysym_num' , 'num' , 'send_event' , 'serial' , 'state' ,'time' , 'type' , 'widget' , 'width' , 'x' , 'x_root' , 'y' , 'y_root ']</pre>
<ul>
<li>From the attributes list generated by the object, we use two attributes, <kbd>event.x</kbd> and <kbd>event.y</kbd>, to print the coordinates of the point of click.</li>
</ul>
<p>When you run the preceding code (code <kbd>1.09.py</kbd> ), it produces a window, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8c500d3b-1712-46dd-b3ca-8e72a994dbc8.png"/></div>
<p>When you left-click anywhere in the yellow colored frame within the root window, it outputs messages to the console. A sample message passed to the console is as follows:</p>
<pre>['__doc__', '__module__', 'char', 'delta', 'height', 'keycode', 'keysym', 'keysym_num', 'num', 'send_event', 'serial', 'state', 'time', 'type', 'widget', 'width', 'x', 'x_root', 'y', 'y_root']<br/> You clicked at 63 36.</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Event patterns</h1>
                </header>
            
            <article>
                
<p>In the previous example, you learned how to use the <kbd>&lt;Button-1&gt;</kbd> event to denote a left-click. This is a built-in pattern in Tkinter that maps it to a left-click event. Tkinter has an exhaustive mapping scheme that perfectly identifies events such as this one.</p>
<p>Here are some examples to give you an idea of event patterns:</p>
<table>
<tbody>
<tr>
<td>
<p><strong>The event pattern</strong></p>
</td>
<td>
<p><strong>The associated event</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>&lt;Button-1&gt;</kbd></p>
</td>
<td>
<p><span>Left-click of the mouse</span></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span>&lt;KeyPress-B&gt;</span></kbd></p>
</td>
<td>
<p><span> A keyboard press of the <em>B</em> key</span></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span>&lt;Alt-Control-KeyPress- KP_Delete&gt;</span></kbd></p>
</td>
<td>
<p><span>A keyboard press of <em>Alt</em> + <em>Ctrl</em> + <em>Del</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>In general, the mapping pattern takes the following form:</p>
<pre>&lt;[event modifier-]...event type [-event detail]&gt;</pre>
<p>Typically, an event pattern will comprise the following:</p>
<ul>
<li><strong>An event type</strong>: Some common event types include <kbd>Button</kbd>, <kbd>ButtonRelease</kbd>, <kbd>KeyRelease</kbd>, <kbd>Keypress</kbd>, <kbd>FocusIn</kbd>, <kbd>FocusOut</kbd>, <kbd>Leave</kbd> (when the mouse leaves the widget), and <kbd>MouseWheel</kbd>. For a complete list of event types, refer to the <kbd>event</kbd> types section at <a href="http://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm#M7">http://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm#M7</a>. </li>
<li><strong>An event modifier</strong> (optional): Some common event modifiers include <kbd>Alt</kbd>, <kbd>Any</kbd> (used like <kbd>&lt;Any-KeyPress&gt;</kbd>), <kbd>Control</kbd>, <kbd>Double</kbd> (used like <kbd>&lt;Double-Button-1&gt;</kbd> to denote a double-click of the left mouse button), <kbd>Lock</kbd>, and <kbd>Shift</kbd>. For a complete list of event modifiers, refer to the <kbd>event modifiers</kbd><em> </em>section at <a href="http://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm#M6">http://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm#M6</a>.</li>
<li><strong>The event detail</strong> (optional): The mouse event detail is captured by the number 1 for a left-click and the number 2 for a right-click. Similarly, each key press on the keyboard is either represented by the key letter itself (say, <em>B</em> in <kbd>&lt;KeyPress-B&gt;</kbd>) or by using a key symbol abbreviated as <kbd>keysym</kbd>. For example, the up arrow key on the keyboard is represented by the <kbd>keysym</kbd> value of <kbd>KP_Up</kbd>. For a complete <kbd>keysym</kbd> mapping, refer to <a href="https://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm">https://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm</a>.</li>
</ul>
<p>Let's take a look at a practical example of event binding on widgets (refer to code <kbd>1.10.py</kbd> for the complete working example):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0de95f4d-c377-4f3e-acc0-a22c06c0cda7.png"/></div>
<p>The following is a modified snippet of code; it will give you an idea of commonly<br/>
used event bindings:</p>
<pre>widget.bind("&lt;Button-1&gt;", callback) #bind widget to left mouse click<br/>widget.bind("&lt;Button-2&gt;", callback) # bind to right mouse click<br/>widget.bind("&lt;Return&gt;", callback)# bind to Return(Enter) Key<br/>widget.bind("&lt;FocusIn&gt;", callback) #bind to Focus in Event<br/>widget.bind("&lt;KeyPress-A&gt;", callback)# bind to keypress A<br/>widget.bind("&lt;KeyPress-Caps_Lock&gt;", callback)# bind to CapsLock keysym<br/>widget.bind("&lt;KeyPress-F1&gt;", callback)# bind widget to F1 keysym<br/>widget.bind("&lt;KeyPress-KP_5&gt;", callback)# bind to keypad number 5<br/>widget.bind("&lt;Motion&gt;", callback) # bind to motion over widget<br/>widget.bind("&lt;Any-KeyPress&gt;", callback) # bind to any keypress</pre>
<p>Rather than binding an event to a particular widget, you can also bind it to the top-level window. The syntax remains the same except that now you call it on the root instance of the root window such as <kbd>root.bind()</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Binding levels</h1>
                </header>
            
            <article>
                
<p>In the previous section, you had a look at how to bind an event to an instance of a widget. This can be called an <strong>instance-level binding</strong>.</p>
<p>However, there may be times when you need to bind events to an entire application. At times, you may want to bind an event to a particular class of widget. Tkinter provides the following levels of binding options for this:</p>
<ul>
<li><strong>Application-level binding</strong>: Application-level bindings let you use the same binding across all windows and widgets of an application as long as any one window of the application is in focus. The syntax for application-level bindings is as follows:</li>
</ul>
<pre style="padding-left: 60px">widget.bind_all(event, callback, add=None)</pre>
<p style="padding-left: 60px">The typical usage pattern is as follows:</p>
<pre style="padding-left: 60px">root.bind_all('&lt;F1&gt;', show_help)</pre>
<p style="padding-left: 60px">Application-level binding here means that, irrespective of the widget that is currently under focus, pressing the <em>F1</em> key will always trigger the <kbd>show_help</kbd> callback as long as the application is in focus.</p>
<ul>
<li><strong>Class-level binding</strong>: You can also bind events at a particular class level. This is normally used to set the same behavior for all instances of a particular widget class. The syntax for class-level binding is as follows:</li>
</ul>
<pre style="padding-left: 60px">w.bind_class(class_name, event, callback, add=None)</pre>
<p style="padding-left: 60px">The typical usage pattern is as follows:</p>
<pre style="padding-left: 60px">my_entry.bind_class('Entry', '&lt;Control-V&gt;', paste)</pre>
<p>In the preceding example, all the entry widgets will be bound to the <kbd>&lt;Control-V&gt;</kbd> event, which will call a method named <kbd>paste</kbd> (event).</p>
<div class="packt_tip"><span class="packt_screen">Event propagation</span><br/>
Most keyboard and mouse events occur at the operating system level. The event propagates hierarchically upward from its source until it finds a window that has the corresponding binding. The event propagation does not stop there. It propagates itself upwards, looking for other bindings from other widgets, until it reaches the root window. If it does reach the root window and no bindings are discovered by it, the event is disregarded.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling widget-specific variables</h1>
                </header>
            
            <article>
                
<p>You need variables with a wide variety of widgets. You likely need a string variable to track what the user enters into the entry widget or text widget. You most probably need Boolean variables to track whether the user has checked off the Checkbox widget. You need integer variables to track the value entered in a Spinbox or Slider widget.</p>
<p>In order to respond to changes in widget-specific variables, Tkinter offers its own <kbd>variable</kbd> class. The variable that you can use to track widget-specific values must be subclassed from this Tkinter <kbd>variable</kbd> class. Tkinter offers some commonly used predefined variables. They are <kbd>StringVar</kbd>, <kbd>IntVar</kbd>, <kbd>BooleanVar</kbd>, and <kbd>DoubleVar</kbd>.</p>
<p>You can use these variables to capture and play with the changes in the values of variables from within your callback functions. You can also define your own variable type, if required.</p>
<p>Creating a Tkinter variable is simple. You simply have to call the constructor:</p>
<pre>my_string = tk.StringVar()<br/>ticked_yes = tk.BooleanVar()<br/>group_choice = tk.IntVar()<br/>volume = tk.DoubleVar() </pre>
<p>Once the variable is created, you can use it as a widget option, as follows:</p>
<pre>tk.Entry(root, textvariable=my_string)<br/>tk.Checkbutton(root, text="Remember Me", variable=ticked_yes)<br/>tk.Radiobutton(root, text="Option1", variable=group_choice, value="option1") <br/>tk.Scale(root, label="Volume Control", variable=volume, from =0, to=10)</pre>
<p>Additionally, Tkinter provides access to the values of variables via the <kbd>set()</kbd> and <kbd>get()</kbd> methods, as follows:</p>
<pre>my_var.set("FooBar") # setting value of variable<br/>my_var.get() # Assessing the value of variable from say a callback </pre>
<p>A demonstration of the Tkinter <kbd>variable</kbd> class is available in the <kbd>1.11.py</kbd> code file. The code generates a window, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="78" src="assets/35173189-b313-4e3b-9e89-2ca39d7eafeb.png" width="387"/></div>
<p>This concludes our brief discussion on events and callbacks. Here's a brief summary of the things that we discussed:</p>
<ul>
<li>Command binding, which is used to bind simple widgets to certain functions</li>
<li>Event binding using the <kbd>widget.bind_all</kbd>(<kbd>event</kbd>, <kbd>callback</kbd>, <kbd>add=None</kbd>) method to bind keyboard and mouse events to your widgets and invoke callbacks when certain events occur</li>
<li>The passing of extra arguments to a callback using the <kbd>lambda</kbd> function</li>
<li>The binding of events to an entire application or to a particular class of widget by using <kbd>bind_all()</kbd> and <kbd>bind_class()</kbd></li>
<li>Using the Tkinter <kbd>variable</kbd> class to set and get the values of widget-specific variables</li>
</ul>
<p>In short, you now know how to make your GUI program responsive to end-user requests!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Event unbinding and virtual events</h1>
                </header>
            
            <article>
                
<p>In addition to the bind method that you previously saw, you might find the following two event-related options useful in certain cases:</p>
<ul>
<li><strong>Unbind:</strong> Tkinter provides the unbind option to undo the effect of an earlier binding. The syntax is as follows:</li>
</ul>
<pre style="padding-left: 60px">widget.unbind(event)</pre>
<p style="padding-left: 60px">The following are some examples of its usage:</p>
<pre style="padding-left: 60px">entry.unbind('&lt;Alt-Shift-5&gt;')<br/>root.unbind_all('&lt;F1&gt;')<br/>root.unbind_class('Entry', '&lt;KeyPress-Del&gt;')</pre>
<ul>
<li><strong>Virtual events</strong>: Tkinter also lets you create your own events. You can give these virtual events any name that you want. For example, let's suppose that you want to create a new event called <kbd>&lt;&lt;commit&gt;&gt;</kbd>, which is triggered by the <em>F9</em> key. To create this virtual event on a given widget, use the following syntax:</li>
</ul>
<pre style="padding-left: 60px">widget.event_add('&lt;&lt;commit&gt;&gt;', '&lt;KeyRelease-F9&gt;')</pre>
<p style="padding-left: 60px">You can then bind <kbd>&lt;&lt;commit&gt;&gt;</kbd> to a callback by using a normal <kbd>bind()</kbd> method, as follows:</p>
<pre style="padding-left: 60px">widget.bind('&lt;&lt;commit&gt;&gt;', callback)</pre>
<p>Other event-related methods can be accessed by typing the following line in the Python Terminal:</p>
<pre><strong>&gt;&gt;&gt; import tkinter</strong><br/><strong>&gt;&gt;&gt; help(tkinter.Event)</strong></pre>
<p>Now that you are ready to delve into real application development with Tkinter, let's spend some time exploring a few custom styling options that Tkinter offers. We will also have a look at some configuration options that are commonly used with the root window.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Doing it in style</h1>
                </header>
            
            <article>
                
<p>So far, we have relied on Tkinter to provide specific platform-based styling for our widgets. However, you can specify your own styling of widgets, such as their color, font size, border width, and relief. A brief introduction to styling features that are available in Tkinter is supplied in the following section.</p>
<p>You may recall that we can specify widget options at the time of its instantiation, as follows:</p>
<pre>my_button = tk.Button(parent, **configuration options)</pre>
<p>Alternatively, you can specify the widget options by using <kbd>configure()</kbd> in the following way:</p>
<pre>my_button.configure(**options)</pre>
<p>Styling options are also specified as options to the widgets either at the time of creating the widgets, or later by using the <kbd>configure</kbd> option.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Specifying styles</h1>
                </header>
            
            <article>
                
<p>Under the purview of styling, we will cover how to apply different colors, fonts, border widths, reliefs, cursors, and bitmap icons to widgets.</p>
<p>First, let's see how to specify the color options for a widget. You can specify the following two types of color for most widgets:</p>
<ul>
<li>The background color</li>
<li>The foreground color</li>
</ul>
<p>You can specify the color by using hexadecimal color codes for the proportion of red(<em>r</em>), green(<em>g</em>), and blue(<em>b</em>). The commonly used representations are <kbd>#rgb</kbd> (4 bits), <kbd>#rrggbb</kbd> (8 bits), and <kbd>#rrrgggbbb</kbd> (12 bits).</p>
<p>For example, <kbd>#fff</kbd> is white, <kbd>#000000</kbd> is black, <kbd>#f00</kbd> is red (R=<kbd>0xf</kbd>, G=<kbd>0x0</kbd> , B=<kbd>0x0</kbd> ), <kbd>#00ff00</kbd> is green (R=<kbd>0x00</kbd>, G=<kbd>0xff</kbd>, B=<kbd>0x00</kbd>), and <kbd>#000000fff</kbd> is blue (R=<kbd>0x000</kbd> , G=<kbd>0x000</kbd> , B=<kbd>0xfff</kbd> ).</p>
<p>Alternatively, Tkinter provides mapping for standard color names. For a list of predefined named colors, visit <a href="http://wiki.tcl.tk/37701">http://wiki.tcl.tk/37701</a> or <a href="http://wiki.tcl.tk/16166">http://wiki.tcl.tk/16166</a>.</p>
<p>Next, let's have a look at how to specify fonts for our widgets. A font can be represented as a string by using the following string signature:</p>
<pre>{font family} fontsize fontstyle</pre>
<p>The elements of the preceding syntax can be explained as follows:</p>
<ul>
<li><kbd>font family</kbd>: This is the complete font family long name. It should preferably be in lowercase, such as <kbd>font="{nimbus roman} 36 bold italic"</kbd>.</li>
<li><kbd>fontsize</kbd>: This is in the printer's point unit (<kbd>pt</kbd>) or pixel unit (<kbd>px</kbd>).</li>
<li><kbd>fontstyle</kbd>: This is a mix of normal/bold/italic and underline/overstrike.</li>
</ul>
<p>The following are examples that illustrate the method of specifying fonts:</p>
<pre>widget.configure (font='Times 8')<br/>widget.configure(font='Helvetica 24 bold italic')</pre>
<p>If you set a Tkinter dimension in a plain integer, the measurements take place in pixel units. Alternatively, Tkinter accepts four other measurement units, which are <kbd>m</kbd>(millimeters), <kbd>c</kbd>(centimeters), <kbd>i</kbd>(inches), and <kbd>p</kbd>(printer's points, which are about 1/72").</p>
<p>For instance, if you want to specify the wrap length of a button in terms of a printer's point, you can specify it as follows:</p>
<pre>button.configure(wraplength="36p")</pre>
<p>The default border width for most Tkinter widgets is <em>2</em> px. You can change the border width for widgets by specifying it explicitly, as shown in the following line:</p>
<pre>button.configure(borderwidth=5)</pre>
<p>The relief style of a widget refers to the difference between the highest and lowest elevations in a widget. Tkinter offers six possible relief styles—<kbd>flat</kbd>, <kbd>raised</kbd>, <kbd>sunken</kbd>, <kbd>groove</kbd>, <kbd>solid</kbd>, and <kbd>ridge</kbd>:</p>
<pre>button.configure(relief='raised')</pre>
<p>Tkinter lets you change the style of the mouse cursor when you hover over a particular widget. This is done by using the option cursor, as follows:</p>
<pre>button.configure(cursor='cross')</pre>
<p>For a complete list of available cursors, refer to <a href="https://www.tcl.tk/man/tcl8.6/TkCmd/cursors.htm">https://www.tcl.tk/man/tcl8.6/TkCmd/cursors.htm</a>.</p>
<p>Though you can specify the styling options at each widget level, sometimes it may be cumbersome to do so individually for each widget. Widget-specific styling has the following disadvantages:</p>
<ul>
<li>It mixes logic and presentation into one file, making the code bulky and difficult to manage</li>
<li>Any change in styling has to be applied to each widget individually</li>
<li>It violates the don't repeat yourself (DRY) principle of effective coding, as you keep specifying the same style for a large number of widgets</li>
</ul>
<p>Fortunately, Tkinter now offers a way to separate presentation from logic and specify styles in what is called the <strong>external option database</strong>. This is just a text file where you can specify common styling options.</p>
<p>A typical option database text file looks like this:</p>
<pre>*background: AntiqueWhite1<br/>*Text*background: #454545<br/>*Button*foreground: gray55<br/>*Button*relief: raised<br/>*Button*width: 3</pre>
<p>In its simplest use, the asterisk (<kbd><strong>*</strong></kbd>) symbol here means that the particular style is applied to all the instances of the given widget. For a more complex usage of the asterisk in styling, refer to <a href="http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/resource-lines.html">http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/resource-lines.html</a>.</p>
<p>These entries are placed in an external text (<kbd>.txt</kbd>) file. To apply this styling to a particular piece of code, you can simply call it by using the <kbd>option_readfile()</kbd><em> </em>call early in your code, as shown here:</p>
<pre>root.option_readfile('optionDB.txt')</pre>
<p>Let's have a look at an example (see code <kbd>1.12.py</kbd> ) of using this external styling text file in a program:</p>
<pre>import tkinter as tk<br/>root = tk.Tk()<br/>root.configure(background='#4D4D4D')#top level styling<br/># connecting to the external styling optionDB.txt<br/>root.option_readfile('optionDB.txt')<br/>#widget specific styling<br/>mytext = tk.Text(root, background='#101010', foreground="#D6D6D6",<br/>              borderwidth=18, relief='sunken',width=17, height=5)<br/>mytext.insert(tk.END, "Style is knowing who you are, what you want to<br/>                   say, and not giving a damn.")<br/>mytext.grid(row=0, column=0, columnspan=6, padx=5, pady=5)<br/># all the below widgets get their styling from optionDB.txt file<br/>tk.Button(root, text='*').grid(row=1, column=1)<br/>tk.Button(root, text='^').grid(row=1, column=2)<br/>tk.Button(root, text='#').grid(row=1, column=3)<br/>tk.Button(root, text='&lt;').grid(row=2, column=1)<br/>tk.Button(root, text='OK', cursor='target').grid(row=2, column=2)#changing cursor style<br/>tk.Button(root, text='&gt;').grid(row=2, column=3)<br/>tk.Button(root, text='+').grid(row=3, column=1)<br/>tk.Button(root, text='v').grid(row=3, column=2)<br/>tk.Button(root, text='-').grid(row=3, column=3)<br/>for i in range(9):<br/>   tk.Button(root, text=str(i+1)).grid(row=4+i//3, column=1+i%3)<br/>root.mainloop()</pre>
<p>The following is a description of the preceding code:</p>
<ul>
<li>The code connects to an external styling file called <kbd>optionDB.txt</kbd> that defines common styling for the widgets.</li>
<li>The next segment of code creates a Text widget and specifies styling on the widget level.</li>
<li>The next segment of code has several buttons, all of which derive their styling from the centralized <kbd>optionDB.txt</kbd> file. One of the buttons also defines a custom cursor.</li>
</ul>
<p>Specifying attributes such as font sizes, the border width, the widget width, the widget height, and padding in absolute numbers, as we have done in the preceding example, can cause some display variations between different operating systems such as Ubuntu, Windows, and Mac respectively, as shown in the following screenshot. This is due to differences in the rendering engines of different operating systems:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9a6b31ec-8904-4a4a-ab9d-fad2dcd75293.png"/></div>
<div class="packt_tip">When deploying cross-platform, it is better to avoid specifying attribute sizes in absolute numbers. It is often the best choice to let the platform handle the attribute sizes.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Some common root window options</h1>
                </header>
            
            <article>
                
<p>Now that we are done discussing styling options, let's wrap up with a discussion on some commonly used options for the root window:</p>
<table style="width: 829px;height: 416px">
<tbody>
<tr>
<td>
<p><strong>Method</strong> </p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd><span>*root.geometry('142x280+150+200')</span></kbd></p>
</td>
<td>
<p>You can specify the size and location of</p>
<p>a root window by using a string of the</p>
<p><kbd>widthxheight</kbd> + <kbd>xoffset</kbd> + <kbd>yoffset</kbd> form.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>self.root.wm_iconbitmap('mynewicon.ico')</kbd> OR</p>
<p><kbd>self.root.iconbitmap('mynewicon.ico ')</kbd></p>
</td>
<td>
<p>This changes the title bar icon to something</p>
<p>that is different from the default Tk icon.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>root.overrideredirect(1)</kbd></p>
</td>
<td>
<p>This removes the root border frame. It<br/>
hides the frame that contains the minimize,<br/>
maximize, and close buttons.</p>
</td>
</tr>
</tbody>
</table>
<p>Let's explain these styling options in more detail:</p>
<ul>
<li><kbd>root.geometry('142x280+150+200')</kbd>: Specifying the geometry of the root window limits the launch size of the root window. If the widgets do not fit in the specified size, they get clipped from the window. It is often better not to specify this and let Tkinter decide this for you.</li>
<li><kbd>self.root.wm_iconbitmap('my_icon.ico')</kbd> or <kbd>self.root.iconbitmap('my_icon.ico ')</kbd>: This option is only applicable to Windows. Unix-based operating systems do not display the title bar icon.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting interactive help</h1>
                </header>
            
            <article>
                
<p>This section applies not only for Tkinter, but also for any Python object for which you may need help.</p>
<p>Let's say that you need a reference to the Tkinter pack geometry manager. You can get interactive help in your Python interactive shell by using the help command, as shown in the following command lines:</p>
<pre><strong>&gt;&gt;&gt; import tkinter</strong><br/><strong>&gt;&gt;&gt; help(tkinter.Pack)</strong></pre>
<p>This provides detailed help documentation of all the methods defined under the <kbd>Pack</kbd> class in Tkinter.</p>
<p>You can similarly receive help for all the other individual widgets. For instance, you can check the comprehensive and authoritative help documentation for the Label widget in the interactive shell by typing the following command:</p>
<pre><strong> &gt;&gt;&gt;help(tkinter.Label)</strong></pre>
<p>This provides a list of the following:</p>
<ul>
<li>All the methods defined in the <kbd>Label</kbd> class</li>
<li>All the standard and widget-specific options for the <kbd>Label</kbd> widget</li>
<li>All the methods inherited from other classes</li>
</ul>
<p>Finally, when in doubt regarding a method, look into the source code of Tkinter, which is located at <kbd>&lt;location-of-python-installation&gt;\lib\</kbd>. For instance, the Tkinter source code is located in the <kbd>/usr/lib/python3.6.3/tkinter</kbd> directory on my Linux Mint operating system. You might also find it useful to look at the source code implementation of various other modules, such as the <kbd>color chooser</kbd>, <kbd>file dialogs</kbd>, and <kbd>ttk</kbd> modules, and the other modules located in the aforementioned directory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This brings us to end of this chapter. This chapter aimed to provide a high-level overview of Tkinter. We worked our way through all the important concepts that drive a Tkinter program.</p>
<p>You now know what a root window is and how to set it up. You also know the 21 core Tkinter widgets and how to set them up. We also had a look at how to lay out our programs by using the <kbd>Pack</kbd>, <kbd>Grid</kbd>, and <kbd>Place</kbd> geometry managers, and how to make our programs functional by using <kbd>events</kbd> and <kbd>callbacks</kbd>. Finally, you saw how to apply custom styles to GUI programs.</p>
<p>To summarize, we can now start thinking about making interesting, functional, and stylish GUI programs with Tkinter! In the next chapter, we will build our first real application - a Text editor.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QA section</h1>
                </header>
            
            <article>
                
<p>Before you proceed to the next chapter, make sure you can answer these questions to your satisfaction:</p>
<ul>
<li>What is a root window?</li>
<li>What is the main loop?</li>
<li>How do you create a root window?</li>
<li>What are widgets? How do you create widgets in Tkinter?</li>
<li>Can you list or identify all available widgets in Tkinter?</li>
<li>What are geometry managers used for?</li>
<li>Can you name all the available geometry managers in Tkinter?</li>
<li>What are events in a GUI program?</li>
<li>What are callbacks? How are callbacks different from regular functions?</li>
<li>How do you apply callbacks to an event?</li>
<li>How do you style widgets using styling options?</li>
<li>What are the common configuration options for the root window?</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>It would be a good idea to modify the examples from this chapter to lay out the widgets in different ways or to tweak the code to function in other ways to get your feet wet.</p>
<p>We recommend that you take a look at the documentation for all three geometry managers in your Python shell using the following commands:</p>
<pre><strong>&gt;&gt;&gt; import tkinter</strong><br/><strong>&gt;&gt;&gt; help(tkinter.Pack)</strong><br/><strong>&gt;&gt;&gt; help(tkinter.Grid)</strong><br/><strong>&gt;&gt;&gt; help(tkinter.Place)</strong></pre>
<p>You can also find an excellent documentation of Tkinter at <a href="http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/index.html">http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/index.html</a>.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>