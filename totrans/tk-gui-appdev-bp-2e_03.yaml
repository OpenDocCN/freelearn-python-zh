- en: Programmable Drum Machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We looked at several common Tkinter widgets, such as Menu, Buttons, Label, and
    Text, in [Chapter 2](41f1fda5-b3b1-4dfa-8971-2a016274d39a.xhtml), *Making a Text
    Editor*. Let's now expand our experience with Tkinter to make some music. Let's
    build a cross-platform drum machine using Tkinter and some other Python modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the key objectives for this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning to structure Tkinter programs in the **object-oriented style** of programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delving deeper into a few more Tkinter widgets, such as Spinbox, Button, Entry,
    and Checkbutton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the grid geometry manager in a practical project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the importance of choosing the right **data structure** for our
    programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning to bind **higher-order callback** **functions** to widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning to use Tkinter in conjunction with some standard and third-party modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the need for **multithreading** and how to write multithreaded applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about **object** **serialization** or **pickling**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about **ttk widgets**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our goal here is to build a programmable drum machine. Let's call it the `Explosion
    Drum Machine`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The drum machine will let the user create an unlimited number of beat patterns using
    an unlimited number of drum samples. You can then store multiple riffs in a project
    and playback or edit the project later on. In its final form, the drum machine
    would look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ac7e30d-1364-4af6-9643-b78b52f5338e.png)'
  prefs: []
  type: TYPE_IMG
- en: To create your own drum beat patterns, simply load some drum samples (which
    can be any audio file with a `.wav` or `.ogg` extension) using the buttons on
    the left. You can design your beat patterns by clicking on the buttons on the
    right.
  prefs: []
  type: TYPE_NORMAL
- en: You can decide the number of **beats per unit** (**BPU**). Most western beats
    have 4 BPU, a Waltz would have 3 BPU, and some Indian and Arabic rhythms that
    I composed on this machine had 3-16 BPU! You can also change the **beats per minute
    (BPM)**, which in turn decides the tempo of the rhythm.
  prefs: []
  type: TYPE_NORMAL
- en: A single pattern, as shown in the previous screenshot, constitutes a single
    beat pattern. You can design multiple beat patterns by changing the Pattern Number
    Spinbox widget in the top-left section.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have made some beat patterns, you can even save the pattern and later replay
    or modify it. The saving and reloading of files are done from the File menu at
    the top.
  prefs: []
  type: TYPE_NORMAL
- en: A few drum samples are provided in the `Loops` subdirectory; however, you can
    load any other drum sample. You can download a large number of samples for free
    from the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use some more built-in libraries from the standard Python distribution
    for this chapter. This includes `tkinter`, `os`, `math`, `threading`, and `pickle`
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that these modules exist, simply run the following statement in your Python3
    IDLE interactive prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This should not cause an error, as Python3 comes with these modules built into the
    distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Other than this, you need to add an extra Python module called `pygame`. We
    will be using the version named 1.9.3 Package, which can be downloaded at [http://www.pygame.org/download.shtml](http://www.pygame.org/download.shtml).
  prefs: []
  type: TYPE_NORMAL
- en: Linux users may additionally want to take a look at the following page for instructions
    on getting `pygame` to work with Python 3.x: [http://www.pygame.org/wiki/CompileUbuntu?parent=Compilation](http://www.pygame.org/wiki/CompileUbuntu?parent=Compilation).
  prefs: []
  type: TYPE_NORMAL
- en: '`pygame` is a cross-platform package normally used for making games with Python.
    However, we will just be using a small module from the package named `pygame.mixer`,
    which is used for loading and playing sounds. The API documentation for this module
    can be found at [http://www.pygame.org/docs/ref/mixer.html](http://www.pygame.org/docs/ref/mixer.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have installed the module, you can verify it by importing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If no errors are reported and the version output is 1.9.3, you are ready to
    program the drum machine. Let's start!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the GUI in OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The text editor we developed in the previous chapter was implemented in procedural
    code. Although it offered some benefits for quick coding, it had some typical
    limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: We started encountering global variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function definitions needed to be defined above the code that called them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most importantly, the code was not reusable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, we need some way to ensure that our code is reusable. This is why programmers
    prefer to use **object-oriented programming** (**OOP**) to organize their code
    into classes.
  prefs: []
  type: TYPE_NORMAL
- en: OOP is a programming paradigm that shifts the focus onto the objects we want to
    manipulate rather than the logic required to manipulate them. This is in contrast
    to procedural programming, which views a program as a logical procedure that takes
    input, processes it, and produces some output.
  prefs: []
  type: TYPE_NORMAL
- en: OOP provides several benefits, such as **data abstraction**, **encapsulation**,
    **inheritance**, and **polymorphism**. In addition, OOP provides a clear **modular
    structure** for programs. Code modification and maintenance are easy, as new objects
    can be created without modifying the existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build our drum program using OOP to illustrate some of these features. An
    indicative OOP structure for our drum program could be as follows (code `3.01.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a class structure called `DrumMachine` and initialize the Toplevel window
    passed as an argument to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the script is run as a standalone program, that is, `if __name__ == '__main__'`,
    a new `Tk()` root object is created and the root window is passed as an argument
    to the `DrumMachine` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then initiate an object from the `DrumMachine` class to get a Toplevel window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have our Toplevel window ready, let's stop adding any more visual elements
    and think about something that is critical to how well our program will eventually
    turn out to be. Let's spend some time finalizing the data structure for our program.
  prefs: []
  type: TYPE_NORMAL
- en: Finalizing the data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As Linus Torvalds, the developer of Linux, once said:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Bad programmers worry about the code. Good programmers worry about data structures
    and their relationships."'
  prefs: []
  type: TYPE_NORMAL
- en: What he means is that well-designed data structures make the code very easy
    to design, maintain, and scale up. In contrast, if you start with a poor data
    structure, you can't make up for that, even with the best of code.
  prefs: []
  type: TYPE_NORMAL
- en: Start with a good data structure and your code will naturally be more simple, elegant,
    and easy to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, let's try to decide on a suitable data structure for our
    program. Go back and take a look at the previous screenshot (under the *G**etting
    started* section). What kind of data structure, do you think, would be needed
    to capture all the necessary fields of information?
  prefs: []
  type: TYPE_NORMAL
- en: Well, first of all our drum machine needs to keep information about beat patterns.
    So let's start by creating a list named `all_patterns = []`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, each of the patterns within the list needs to capture information about
    the drum files related to the pattern: the number of units in the pattern, the
    BPU for the pattern, the BPM, and the buttons clicked to form the pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, we need to come up with a data structure where `all_patterns`
    is a list where each item represents a single pattern. Each pattern is then denoted
    by a dictionary, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It is very important that you get familiar with the preceding data structure
    definition for our drum machine. Notice that, with just this data in hand, we
    can define the logic to display everything that you see in the finalized drum
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that this data structure does not contain information about any
    GUI elements, such as widget information or widget states. As far as possible,
    we should always strive to cleanly separate the data of the backend (program logic)
    from the data related to the frontend (user interfaces). Our data structure here
    merely represents the backend but is sufficient enough to allow us to lay out
    the logic to determine our frontend.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding data structure was what I found to be a good representation of
    the data at hand. There could have been an equally valid but altogether different
    representation of the data. There is no one *correct answer* to the question of
    data representation. However, building the representation around built-in collections
    of a language allows us to work with highly optimized code and is generally a good
    idea. The choice of data structure directly affects the performance of an application—sometimes
    trivially but at other times very severely.
  prefs: []
  type: TYPE_NORMAL
- en: 'We modify our code accordingly (see code `3.02.py`) to initialize this data
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We also initialize `is_button_clicked_list` with all values set to `False`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To support this structure, we define a few constants (see code `3.02.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you run this program, you simply see a root window—nothing different from
    the previous code. But internally our code is reserving memory for all the data
    we will need to construct our logic. We have laid a strong foundation for our program
    to run. Believe it or not, we have done half the job.
  prefs: []
  type: TYPE_NORMAL
- en: Creating broader visual elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, let''s lay out the broader visual elements of our program. For the sake
    of modularity, we divide the program into four broad visual sections, as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/898ba06f-ef69-41f1-8ad0-a1d9034ae921.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s define a method called `init_gui()`, which is called from within the
    `__init__` method as follows (see code `3.03.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We then proceed to define all four of these methods (`3.03.py`). The code is
    not discussed here, as we have done similar coding in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with the **Top Bar** section. The Top Bar is simple. It has a few
    labels, three Spinboxes, and an Entry widget. We will not reproduce the entire
    code here (see code `3.03.py`) as we have already seen examples of creating Labels
    and Entry widgets several times in the previous chapters. For `Spinbox`, the options are
    specified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the class-level properties accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Since we will allow multiple patterns to be designed, we need to keep track
    of the currently showing or active pattern. The `self.current_pattern_index` property
    keeps track of the currently active pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s code the `create_left_drum_loader()` method. This again is pretty self-explanatory.
    We create a loop (see `code 3.03.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Before we proceed to code the `create_right_button_matrix()` method, let's finish coding
    the `create_play_bar()` method, as it is the simpler of the two. All it contains
    is two Buttons, a Checkbutton, a Spinbox, and an image. We have coded similar
    widgets earlier in the book, and so I will leave it for you to explore on your
    own (see code `3.03.py`).
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's code the `create_right_button_matrix()` method. This is the most complex
    of all.
  prefs: []
  type: TYPE_NORMAL
- en: The **right button matrix** comprises a two-dimensional array of rows and columns.
    The number of rows in the matrix equals the constant, `MAX_NUMBER_OF_DRUM_SAMPLES`,
    and the number of columns represents the number of beat units per cycle and is
    calculated by multiplying the number of units and the number of beats per unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code that creates the button matrix looks like this (see code `3.03.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The associated code for the `find_number_of_columns()` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We have already created the button matrix, but we want the buttons to be colored in
    two alternating shades. Therefore, we define two constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This can be any hexadecimal color code or any color from Tkinter's predefined
    list of colors. We also require a third color to represent the button in a pressed
    state.
  prefs: []
  type: TYPE_NORMAL
- en: The constant `BUTTON_CLICKED_COLOR = 'green'` takes care of that.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then define two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The idea is simple. A button is to be colored green if the value of the button
    is found to be `True` in our data structure, or else the button is to be shaded
    in patterns of `COLOR_1` and `COLOR_2` for each alternating unit of beats.
  prefs: []
  type: TYPE_NORMAL
- en: 'This alternating color is obtained by using this mathematical formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Remember that we had created a two-dimensional Boolean list called `is_button_clicked_list`
    as a dictionary item in our original data structure to hold this value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We change the color of the button to `BUTTON_CLICKED_COLOR` if that value is
    found to be `True`. Accordingly, we define a `getter` method to get the value
    of the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now each button is attached to the command callback named `on_button_clicked`, which
    is coded as follows (see code `3.03.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice something fancy with this piece of code? This method defines a function within
    the function. It does not return a value as is typical of functions. Instead,
    it returns a function that can be executed at a later stage. These are called
    **higher-order functions** or, more precisely, **function closures**.
  prefs: []
  type: TYPE_NORMAL
- en: Why did we need to do this? We had to do this because each button is identified
    by its unique row and column-based indexes. The row values and column values are only
    available when the loop runs at the time of creating the buttons. The `row` and
    `col` variables are lost after that. We, therefore, need some way to keep these
    variables alive if we have to identify which button was clicked later on.
  prefs: []
  type: TYPE_NORMAL
- en: These callback functions come to our rescue as they encapsulate the row and
    column values in the function that they return at the time of creation.
  prefs: []
  type: TYPE_NORMAL
- en: Functions are first-class objects in Python. This means that you can pass a
    function to another function as a parameter and you can return a function from
    another function. In short, you can treat a function as any other object.
  prefs: []
  type: TYPE_NORMAL
- en: You can bind a method object to a particular context, as we did in the previous
    code, by nested scoping of a method within a method. Higher-order functions like
    these are a common way of associating functions with widgets in GUI programming.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about function closures at [https://en.wikipedia.org/wiki/Closure_(computer_programming)](https://en.wikipedia.org/wiki/Closure_(computer_programming)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We then define a method called `process_button_clicked`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The key section in the preceding code is the line that sets the button value
    opposite to its current value using the `not` operator. Once the value is toggled,
    the method calls the `display_button_color` method to recolor the buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s complete this iteration by defining some dummy methods for
    now and attach them as command callbacks to the respective widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'That completes the iteration. Now if you run the program (see code `3.03.py`),
    it should display all the broad visual elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2060aae-7d86-4f34-beb2-31140f244c73.png)'
  prefs: []
  type: TYPE_IMG
- en: The buttons matrix should be colored in two alternating shades, and pressing
    the buttons should toggle its color between green and its previous color.
  prefs: []
  type: TYPE_NORMAL
- en: All other widgets remain non-functional at this stage as we have attached them
    to non-functional command callbacks. We will soon make them functional but, before
    we do that, let's do something to make all our future coding simple, clean, and
    elegant.
  prefs: []
  type: TYPE_NORMAL
- en: Defining getter and setter methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our previous section, we needed to know the value of a button in a given
    row and column of the button matrix for a given pattern. If the value was `True`,
    we colored the button green. If the value was `False`, we colored it in an alternative
    color.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get the value of the button by calling this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice how this line has four sets of square brackets, `[]`. Since this nested
    super-scripting business can soon get ugly, we encapsulated this logic in a method
    named `get_button_value(row, col)`. Now, whenever we need to get a button's value,
    we can simply call this method with the right parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Now our code will not be littered with those ugly nested superscripts. Whenever
    we want to get the value of a button, we can call the `get_button_value(row, col)` method,
    which has a nice indicative name for the work it does. Isn't this much more readable
    and comprehensible than its rather ugly counterpart?
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing is for sure: all logic that we build from now onward will heavily
    rely on data we get from, or set to, our data structure. Given that we will need
    all this data all the time in our program, let''s write its `getter` and `setter`
    methods in advance. This will certainly make our lives a lot easier.'
  prefs: []
  type: TYPE_NORMAL
- en: The goal for this part of the iteration is simple—to define `getter` and `setter`
    methods for all the data that we have decided to store in our data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows (see `code 3.04.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That is all there is to coding the `getter` and `setter` methods. The code should
    be self-explanatory if you have understood the underlying data structure, as all
    that we do here is either get a value or set a value for various items in the
    data structure.
  prefs: []
  type: TYPE_NORMAL
- en: With these methods now handy, let's complete coding the functionality of widgets
    we had earlier left uncoded.
  prefs: []
  type: TYPE_NORMAL
- en: The number of units and beats per unit features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We earlier coded the matrix called `create_right_button_matrix`, which creates
    a two-dimensional matrix with the number of rows equal to `MAX_NUMBER_OF_DRUM_SAMPLES`.
    The number of columns would be decided by multiplying the number of units by the
    beats per unit values selected by the end user. Its formula can be given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Number of columns of buttons = Number of units x BPU*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62fb1dbc-f9ee-45d9-a72d-24fef899dc02.png)'
  prefs: []
  type: TYPE_IMG
- en: This means that every time the user changes the number of units or the beats
    per unit, the button matrix should be redrawn to change the number of columns.
    This change should also be reflected in our underlying data structure. Let's add
    this feature to our drum machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'We had earlier defined two dummy methods—`on_number_of_units_changed()` and `on_bpu_changed()`.
    We modify them now as follows (see `code 3.04.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding methods do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify the data structure to reflect the changes in BPU or number of units
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the `create_right_button_matrix()` method to recreate the button matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now if you go and run the code (see code `3.04.py`) and change either the values
    of number of units or BPU, the button matrix should redraw itself to reflect the
    change.
  prefs: []
  type: TYPE_NORMAL
- en: Loading drum samples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our main objective is to play sound files in the order of a beat pattern decided
    by the user. To do this, we need to add sound files to the drum machine.
  prefs: []
  type: TYPE_NORMAL
- en: Our program does not have any preloaded drum files. Instead, we want to let
    the user select from a wide variety of drum files.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, besides the normal drum, you can play a Japanese tsuzumi, an Indian tabla, Latin
    American bongo drums, or just about any other sound that you want to add to your
    rhythm. All you need is a small `.wav` or `.ogg` file containing that sound's
    sample.
  prefs: []
  type: TYPE_NORMAL
- en: 'The drum sample is to be loaded on the left bar, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b80c556-2219-4b10-a3a7-7b5cdc2c0de3.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's code the ability to add drum samples to our program.
  prefs: []
  type: TYPE_NORMAL
- en: We have already created buttons with folder icons on the left-hand side of our
    drum pad. Now we need to make it functional. The desired functionality is simple. When
    a user clicks on any of the left buttons, they should open a file dialog letting the
    user choose a `.wav` or `.ogg` file. When the user selects the file and clicks
    on Open, the Entry widget next to that button should be populated with the name
    of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Further, the location of the drum sample file should be added to our data structure at
    the appropriate place.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will import the required modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `filedialog` module to ask the user to select drum files. We have
    already used the file dialog module in [Chapter 2](41f1fda5-b3b1-4dfa-8971-2a016274d39a.xhtml),
    *Making a Text Editor*. The functionality here is very similar. We will also need
    to extract the filename of the given sound sample using the `os` module. Let''s
    begin by importing the two modules (see `code 3.05.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The buttons we created for uploading drum files are attached to the `on_open_file_button_clicked`
    method through a command callback. We created a dummy method earlier by that name.
    We now modify that method to add the required functionality (see `code 3.05.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method again returns a function, as we need to track which of
    the drum files was actually selected from all the rows of drum files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code does three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Asks the user for the file path using Tkinter's `filedialog`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifies the underlying data structure to save the provided file path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls another method to display the filename in the adjacent Entry widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next two methods are then responsible for displaying all drum names in
    the frontend (see code `3.05.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method uses `os.path.basename` from the `os` module to obtain the
    filename from the file path.
  prefs: []
  type: TYPE_NORMAL
- en: This completes the section. Our code is now capable of loading drum samples
    and storing records of all file paths in the data structure. Go ahead and try
    loading some drum samples (see code `3.05.py`) and the program should display
    the name of the drum file in the adjacent Entry widget.
  prefs: []
  type: TYPE_NORMAL
- en: Playing the drum machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a mechanism to load drum samples and a mechanism to define beat
    patterns in place, let's add the ability to play these beat patterns. In many ways,
    this is the core of our program.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first understand the functionality that we want to achieve here.
  prefs: []
  type: TYPE_NORMAL
- en: Once the user has loaded one or more drum samples and has defined a beat pattern using
    the toggle buttons, we need to scan each column of the pattern to see if it finds a
    green button (a `True` value in our data structure).
  prefs: []
  type: TYPE_NORMAL
- en: If the value is `True` for a given location in the matrix, our code should play
    the corresponding drum sample before moving ahead. If two or more drum samples
    are selected in the same column, all the samples should play almost simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, there should be a fixed time gap between the playing of each successive column,
    which will define the tempo of the music.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this functionality, we need to import the `pygame` module to play
    the sounds, and the `time` module to define the temporal gap between them.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing pygame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `pygame` module is a set of highly portable modules that runs on most operating
    systems. We will use the mixer module from `pygame` to play the sound files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that you have installed the package, let''s begin by importing `pygame` (see
    code `3.06.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: According to the official API documentation of the mixer module at [http://www.pygame.org/docs/ref/mixer.html](http://www.pygame.org/docs/ref/mixer.html),
    we need to initialize `pygame` before we can play back the audio files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We initialize `pygame` in a new method called `init_pygame` (see code `3.06.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mixer.pre_init` method is a special requirement for our drum machine because
    the lack of it causes a lot of sound lagging. We will not get into the details of
    audio programming here, but suffice to say that the arguments to the `pre_init` method
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'After `pygame` is initialized like this, the documentation suggests the following
    code to play the sound. Let''s add this to our code as well (see code `3.06.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Playing complete patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now our program has the ability to play any sound. But we don''t just need
    to play a single sound. We need to play a pattern. Let''s define a method called
    `play_pattern`, which reads our internal data structure and plays files accordingly
    (see code `3.06.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We also add an associated method that returns the *i*^(th) column from a matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a class attribute called `self.keep_playing` to decide whether the
    pattern is to be played just once or continuously in a loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create another class attribute called `self.now_playing` to track whether
    a beat is currently playing. This will help us to make some decisions on how to handle
    a sudden close of program or change of pattern by the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then fetch the two-dimensional Boolean list from our data structure and scan
    each column of the list to look for `True` values. We get the column data from
    the matrix by defining a separate method called `get_column_from_matrix(self,
    matrix, i)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For every column, if a `True` value is encountered, we fetch the corresponding drum
    file path and call the `self.play_sound()` method to play the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code sleeps for a fixed duration of time before reading the second column. This
    sleep duration defines the tempo of the drum beat. If the code does not sleep
    for some time between each column, all the patterns would play almost immediately
    and would not even sound like a rhythm. We need to import the `time` module to
    use the `time.sleep()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The amount of time the code sleeps between scanning each column is decided by
    another method called `self.time_to_play_each_column()`, which we define next.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining the tempo of a rhythm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mathematics of defining the tempo of a rhythm is simple. We get the value associated
    with the `beats_per_minute` attribute and divide it by `60` to get the beats per
    second. Then, the time to play each beat (or group of beats simultaneously for
    a given column) is the reciprocal of `beats_per_second`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows (see code `3.06.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'While we are handling the tempo for the pattern, let''s also complete coding
    of the command callback attached to our beats per minute Spinbox widget (see code
    `3.06.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s code the functionality related to the loop Checkbox. We have already factored
    in the looping issue in our `play_pattern` method using the `self.loop` variable.
    We simply need to set the value of the `self.loop` attribute by reading the value
    of the Spinbox widget (see code `3.06.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'With that out of the way, let''s code the command callback attached to our
    Play button and the Stop button (see code `3.06.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Our drum machine is now operational (see code `3.06.py`). You can load drum samples
    and define beat patterns, and when you click on the Play button, the drum machine
    plays that beat pattern!
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a small problem. The `play_sound` method blocks the main loop of
    our Tkinter program. It does not relinquish control back to the main loop until it
    is done playing the sound sample.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our `self.loop` variable is set to `True`, this means that `pygame` never
    returns back control to Tkinter''s main loop and our play button and program is
    stuck! This can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f8fd9e9-473b-4d5f-94ae-892dc30c887b.png)'
  prefs: []
  type: TYPE_IMG
- en: This means that if you now want to click on the Stop button or change some other
    widget, or even close the window, you will have to wait for the play loop to complete,
    which never happens in our case.
  prefs: []
  type: TYPE_NORMAL
- en: This is clearly a glitch. We need some method to confer back the control to
    the Tkinter main loop while the play is still in progress.
  prefs: []
  type: TYPE_NORMAL
- en: That brings us to the next iteration, where we discuss and implement **multithreading** in
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter and threading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the simplest ways that we can make our root window responsive is to use
    the `root.update()` method within our `play_pattern` loop. This updates the `root.mainloop()`
    method after each sound sample is played.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is an inelegant method because the control is passed to the main
    loop with some staggering experienced in the GUI. Thus, you may experience a slight delay
    in the responses of other widgets in the Toplevel window.
  prefs: []
  type: TYPE_NORMAL
- en: Further, if some other event causes the method to be called, it could result
    in a nested event loop.
  prefs: []
  type: TYPE_NORMAL
- en: A better solution would be to run the `play_pattern` method from a separate
    **thread**.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use the threading module of Python to play the pattern in a separate thread. This
    way, `pygame` will not interfere with Tkinter's main loop.
  prefs: []
  type: TYPE_NORMAL
- en: A thread is a coding construct that can advance two or more separate sets of logical
    workflow together within an instance of a running program (process), **context-switching**
    between the workflows. Each thread in a running program gets its own stack and
    its own program counter, but all threads in a process share the same memory.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to threads, processes are independent execution instances of programs, each
    maintaining its own state information and address space. Processes can only interact
    with other processes using interprocess communication mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Threading is a topic for a book in itself. However, we will not get into the
    details and instead will use the threading module from the Python standard library.
    The threading module provides a higher-level threading interface to hide away
    the inner complexities of implementing a multithreaded program. To use the module, let''s
    first import the threading module into our namespace (see code `3.07.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a method, `play_in_thread()`, as follows (`3.07.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, change the `start_play` method to call the `play_in_thread` rather
    than calling the `play_pattern` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now if you load some drum samples, define the beat patterns, and hit the Play button,
    the sound will play in a separate thread without causing other widgets to become
    unresponsive (see code `3.07.py`).
  prefs: []
  type: TYPE_NORMAL
- en: However, this poses a new problem. What happens if the user clicks the Play
    button multiple times? That would spawn multiple threads of beat patterns all
    playing simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can overcome this problem by disabling the Play button when the audio is
    playing. This can be achieved by defining `toggle_play_button_state()` (see code
    `3.07.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We then attach this state toggling method onto the Play, Stop, and Loop widget command
    callbacks, as follows (`3.07.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We also modify our `play_pattern()` method to include a call to `toggle_play_button_state()`
    at the end (see code `3.07.py`). This will ensure that when the pattern has ended
    playing, the Play button returns to its normal state.
  prefs: []
  type: TYPE_NORMAL
- en: The Play button now remains in a disabled state as long as some audio is playing. It
    returns to a normal state when audio isn't playing.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter and thread safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tkinter is not thread safe. The Tkinter interpreter is valid only in the thread
    that runs the main loop. Any calls to widgets must ideally be done from the thread
    that created the main loop. Invoking widget-specific commands from other threads
    is possible but is not reliable.
  prefs: []
  type: TYPE_NORMAL
- en: When you call a widget from another thread, the events get queued for the interpreter
    thread, which executes the command and passes the result back to the calling thread.
    If the main loop is running but not processing events, it sometimes results in
    unpredictable exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, if you find yourself calling a widget from a thread other than the
    main loop, chances are that you have not separated the visual elements from the
    underlying data structure. You are possibly doing it wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Before we complete this iteration, let's take care of a small detail. What happens
    if a beat is currently playing and the user hits the Close button on the window?
    The main loop will die and our audio-playing thread will be left in an orphaned
    state. This can lead to ugly error messages thrown at the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s, therefore, override the Close button and stop the audio play before
    we quit the window. To override the Close button, we add a small line to our class
    `__init__` method, as follows (see code `3.07.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define a method called `exit_app()`, as follows (see code `3.07.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This completes the project iteration.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, we refined our `start_play()` method to play the audio files on
    a separate thread. We also made sure to disable the Play button as long as the
    audio plays. Finally, we overrode the Close button to handle exiting when some
    audio is currently playing.
  prefs: []
  type: TYPE_NORMAL
- en: We used Python's built-in threading module to play the loops in a separate thread. We
    also looked at some of the threading-related limitations of Tkinter. However, threading
    is a vast topic in itself and we have just scratched the surface here.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more details about the threading module at [https://docs.python.org/3/library/threading.html](https://docs.python.org/3/library/threading.html).
  prefs: []
  type: TYPE_NORMAL
- en: Support for multiple beat patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our drum program is now functional. You can load drum samples and define a beat pattern
    and our drum machine will play it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now extend our drum machine to create more than one pattern in the same program.
    This will provide us with the ability to play different patterns simply by changing
    the pattern number. This gives the user the ability to make different beats for
    the intro, verse, chorus, bridge, and other parts of a song. The pattern-changing
    user interface is highlighted in red in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7606143a-fe26-4e33-8d6e-6ff623910f51.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At the very outset, we have an Entry widget adjacent to the Pattern Number
    Spinbox widget. We want to display the current pattern number in that Entry widget. We
    accordingly create a method, `display_pattern_name()`, which does this task (see
    code `3.08.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We want the pattern name to display in the text widget when the program initially launches.
    Therefore, we modify our `create_top_bar()` method to include a call to this newly
    defined method (see code `3.08.py`).
  prefs: []
  type: TYPE_NORMAL
- en: 'A change of pattern requires several changes. First of all, let''s modify the `on_pattern_changed()`
    command callback to call a new method, `change_pattern()`, as follows (see code
    `3.08.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s define the `change_pattern()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code should almost read like plain English and the steps involved
    in a change of pattern should be self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: This completes coding our drum machine to support multiple beat patterns. Go ahead
    and run code `3.08.py`. Load some drum files, define the first beat pattern, and
    play it. Change the beat pattern using the Spinbox widget at the top left,
  prefs: []
  type: TYPE_NORMAL
- en: load new drums, and define a new pattern. Then, play that pattern. While it
    is playing, try switching to your first beat pattern. The change should happen seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Saving beat patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding iteration, we added the capability to define multiple beat
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: However, the beat patterns can be played only on a single script run. When the program
    is closed and restarted, all previous pattern data is lost.
  prefs: []
  type: TYPE_NORMAL
- en: We need a way to persist or store the beat patterns beyond a single program
    run. We need the ability to store values in some form of file storage and reload,
    play, and even edit the patterns. We need some form of **object persistence**.
  prefs: []
  type: TYPE_NORMAL
- en: Python provides several modules for object persistence. The module that we will
    use for persistence is called the `pickle` module. Pickle is a standard library
    of Python.
  prefs: []
  type: TYPE_NORMAL
- en: An object represented as a string of bytes is called a **pickle** in Python.
    **Pickling**, also known as object **serialization**, let's us convert our object
    into a string of bytes. The process of reconstructing the object from the string
    of bytes is called **unpickling** or **deserialization**.
  prefs: []
  type: TYPE_NORMAL
- en: More information about the `pickle` module is available at [http://docs.python.org/3/library/pickle.html](http://docs.python.org/3/library/pickle.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s illustrate it with a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: First, we serialize or pickle our list, `party_menu`, using `pickle.dump`, and
    save it in an external file, `my_menu`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We later retrieve the object using `pickle.load`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Coming back to our drum machine—if we need to store and reuse the beat patterns, we
    only need to pickle our data structure list, named `self.all_patterns`. Having saved
    the object, we can later easily unpickle the file to reconstruct our beat patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to add three top-menu items to our program, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87a44fda-a35d-45de-beb5-5c82f1e10240.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The three top-menu items are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**File** | **Load Project**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File | Save Project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File | Exit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we are creating our menu items, let's also add an About menu item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we are particularly interested in saving the project (pickling), and
    loading the project back (unpickling). The code for menu items is defined in a
    separate method called `create_top_menu`, as shown in the following code (see
    code `3.09.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The code is self-explanatory. We have created similar menu items in our last
    two projects. Finally, to display this menu, we call this method from our `init_gui()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pickle our object, we first import the pickle module into the current namespace,
    as follows (`3.09.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The Save Project menu has a command callback attached to `self.save_project`, which
    is where we define the pickling process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `save_project` method is called when the user clicks on the Save Project menu;
    hence, we need to give the user an option to save the project in a file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have chosen to define a new file extension (`.ebt`) to keep track of our beat
    patterns. This is a completely arbitrary choice of extension name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user specifies the filename, it is saved with a `.ebt` extension. The file
    contains the serialized list `self.all_patterns`, which is dumped into the file
    using `pickle.dump`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, the title of the Toplevel window is changed to reflect the filename.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are done pickling the object. Let''s now code the unpickling process. The unpickling
    process is handled by a method, `load_project`, which is called from the Load
    Project menu, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When a user clicks on the Load Project menu, it triggers a command callback connected
    to this `load_project` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first line of the method prompts the user with an Open File window. When
    the user specifies a previously pickled file with a `.ebt` extension, the filename
    is stored in a variable called `pickled_file_object`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the filename returned is `None` because the user cancels the Open File dialog,
    nothing is done. The file is then opened in read mode, and the contents of the
    file are read into `self.all_patterns` using `pickle.load`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.all_patterns` now contains the list of beat patterns defined in the previous
    pickle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file is closed and the first pattern of `self.all_patterns` is reconstructed by
    calling our previously defined `change_pattern()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This should load the first pattern on our drum machine. Try playing any of the patterns,
    and you should be able to replay the pattern exactly as it was defined at the
    time of pickling.
  prefs: []
  type: TYPE_NORMAL
- en: Note, however, that the pickled `.ebt` files are not portable from one computer
    to another. This is because we have just pickled the file path for our drum files.
    We have not pickled the actual audio files. So if you try to run the `.ebt` file
    on another machine or if the file path to the audio files has changed since the
    pickling, our code will not be able to load the audio files and will report an
    error.
  prefs: []
  type: TYPE_NORMAL
- en: The process of pickling uncompressed audio files like those in `.wav` files,
    `.ogg` files, or PCM data is the same as the preceding process. After all, these
    uncompressed audio files are nothing but lists of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: However, trying to pickle audio files here would require us to deviate a lot
    from our current topic. Therefore, we have not implemented it here.
  prefs: []
  type: TYPE_NORMAL
- en: Pickling, though great for serialization, is vulnerable to malicious or erroneous
    data. You may want to pickle only if the data is from a trusted source, or if
    proper validation mechanisms are in place.
  prefs: []
  type: TYPE_NORMAL
- en: You may also find the `json` module useful for serializing objects in JSON.
    Also, the `ElementTree` and `xml.minidom` libraries are relevant for parsing XML
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To end this section, let''s complete coding the response to clicking on the
    About menu item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This is self-explanatory. We have done similar coding in our previous project.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize this iteration, we used Python's built-in pickle module to pickle
    and unpickle the beat patterns defined by the user.
  prefs: []
  type: TYPE_NORMAL
- en: This now lets us save our beat patterns. We can later load, replay, and edit
    these saved patterns in our drum machine (see code `3.09.py`).
  prefs: []
  type: TYPE_NORMAL
- en: Working with ttk-themed widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are almost done programming our drum machine. However, we would like to end
    this chapter by introducing you to ttk-themed widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter does not bind to the native platform widgets on many platforms, such
    as Microsoft Windows and X11.
  prefs: []
  type: TYPE_NORMAL
- en: The Tk toolkit (and Tkinter) originally appeared on **X-Window systems;** hence, it
    adopted the motif style that was the *de facto* standard for GUI development on
    X-Window systems.
  prefs: []
  type: TYPE_NORMAL
- en: When Tk was ported to other platforms, such as Windows and Mac OS, this motif style
    started appearing out of place with the look of these platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Due to this, some even argue that Tkinter widgets are rather ugly and do not integrate
    well with such desktop environments.
  prefs: []
  type: TYPE_NORMAL
- en: Another criticism of Tkinter is based on the fact that Tkinter mixes logic and
    styling by allowing both to be changed as widget options.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter was also criticized for lacking any kind of theming support. Although
    we saw an example of centralized styling via the option database, the method required styling
    to be done at the widget level. It does not allow for selective styling of two Button
    widgets differently, for example. This made it difficult for developers to implement
    visual consistency for similar groups of widgets while differentiating them from
    other groups of widgets.
  prefs: []
  type: TYPE_NORMAL
- en: As a result of this, many GUI developers moved to Tkinter alternatives, such
    as **wxPython**, **PySide**, and **PyQT**.
  prefs: []
  type: TYPE_NORMAL
- en: With Tkinter 8.5, the makers of Tkinter have tried to address all these concerns
    by introducing the **ttk module**, which may be considered as an advance to the
    original Tkinter module.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at some of the features offered by the ttk-themed widgets
    module.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first things that ttk does is provide a set of built-in themes that
    allows Tk widgets to look like the native desktop environment in which the application
    is running.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, it introduces 6 new widgets—**Combobox**, **Notebook**, **Progressbar**, **Separator**,
    **Sizegrip**, and **Treeview** to the list of widgets, in addition to supporting 11
    core Tkinter widgets, which are Button, Checkbutton, Entry, Frame, Label, LabelFrame,
    Menubutton, PanedWindow, Radiobutton, Scale, and Scrollbar.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the ttk module, we first import it into the current namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You can display the ttk widgets as follows (see code `3.10.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Code `3.10.py` provides a comparison of displays between the normal Tkinter widgets
    and the counterpart ttk widgets, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5bf786b-584c-448e-9fc0-9704f879de32.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the preceding screenshot is taken on a Microsoft Windows platform
    as the differences are more marked on systems that do not explicitly use the X-Window system.
    Notice how Tkinter widgets (on the left) look out of place on Microsoft Windows
    as compared to ttk widgets (on the right), which is the native Microsoft Windows
    look and feel (see code `3.10.py`).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even override the basic Tkinter widgets by importing ttk after Tkinter
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`from tkinter import *`'
  prefs: []
  type: TYPE_NORMAL
- en: '`from tkinter.ttk import *`'
  prefs: []
  type: TYPE_NORMAL
- en: This causes all widgets common to Tk and ttk to be replaced by ttk widgets.
  prefs: []
  type: TYPE_NORMAL
- en: This has the direct benefit of using the new widgets, which gives a better look
    and feel across platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the disadvantage of this kind of import is that you cannot distinguish
    the module from which the widget classes are imported. This is important because
    the Tkinter and ttk widget classes are not completely interchangeable. In this
    case, an unambiguous solution is to import them, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import tkinter as tk`'
  prefs: []
  type: TYPE_NORMAL
- en: '`from tkinter import ttk`'
  prefs: []
  type: TYPE_NORMAL
- en: Although most of the configuration options for Tkinter and ttk widgets are common, ttk-themed
    widgets do not support styling options such as fg, bg, relief, and border. This
    is purposefully removed from ttk in an attempt to keep logic and styling in different
    controls.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, all styling-related options are handled by the respective style names.
    In a standard ttk module, each widget has an associated style name. You can retrieve the
    default style name of a widget using the `widget.winfo_class()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider a ttk Button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This prints `Tbutton`, which is the default style name for `ttk.Button`. For
    a list of default ttk style names for different widgets, refer to [http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/ttk-style-layer.html](http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/ttk-style-layer.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the default style, you can assign a custom style class to a
    widget or group of widgets. To set up a new style, you use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'To configure the style options for a default style, you use the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: To create a new style from the built-in styles, define a style name of the form `newName.oldName`.
    For instance, to create an Entry widget to hold a date, you can call it `Date.Tentry`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the new style on a widget, you use the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will discuss **ttk theming**.
  prefs: []
  type: TYPE_NORMAL
- en: The `Style` is used to control the appearance for individual widgets. Themes,
    on the other hand, control the appearance of the entire GUI. More simply put,
    a theme is a collection of styles. Grouping styles into themes lets the user switch
    designs for the entire GUI all at once. Like styles, all themes are uniquely identified
    by their name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of available themes can be obtained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'You can change to another theme from the `style.theme_names()` list; use the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'To explore various styling and theming-related options of ttk, refer to the
    dummy example (see `code 3.11.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first three lines of code import Tkinter and ttk, and set up a new root
    window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next line, `style = ttk.Style()`, defines a new style.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next line configures a program-wide style configuration using `style.configure`.
    The dot character (`.`), which is the first argument of `configure`, means that
    this style would apply to the `Toplevel` window and to all its child elements.
    This is the reason why all of our widgets get to have a yellow background.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next line creates an extension (`danger`) to the default style (`TButton`). This
    is how you create custom styles, which are variations on a base default style.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next line creates a `ttk.Label` widget. Since we have not specified any style
    for this widget, it inherits the global style specified for the Toplevel window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next line creates a `ttk.button` widget and specifies it to be styled using our
    custom style definition of `danger.TButton`. This is why the foreground color
    of this button turns red. Notice how it still inherits the background color, yellow,
    from the global Toplevel style that we defined earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next two lines of code demonstrate how ttk allows for styling different widget
    states. In this example, we styled different states for a `ttk.Button` widget
    to display in different colors. Go ahead and click on this second button to see
    how different styles apply to different states of a button. Here, we use `map(style,
    query_options, **kw)` to specify dynamic values of style for changes in the state
    of the widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next line fetches the current applicable theme. It then overrides some of
    the options for the theme's Entry widget using `style.theme_settings('themename',
    ***options)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next line defines an Entry widget but does not specify any style to it.
    It, therefore, inherits its properties from the theme we configured earlier. If
    you now type anything in this Entry widget, you will notice that it gets a padding of
    10 px and the foreground text color is red inside the Entry widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know how to make our widgets look more like native platform widgets,
    let's change the **Play** and Stop buttons for our drum machine to `ttk.button`.
    Let's also change the `Loop` Checkbutton from `Tkinter` Checkbutton to `ttk` Checkbutton
    and add a few separators in the Play Bar section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshots show the Play Bar before and after making the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a965371a-280a-4c3f-818c-aefea9b16a94.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We first import `ttk` into our namespace and append `ttk` to the Play and Stop buttons
    as follows (code `3.12.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We then simply modify the buttons and Checkbutton in the `create_play_bar`, replacing
    `button` with `ttk.Button`, and `loopbutton` with `ttk.Checkbutton`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Note that these changes make the Buttons and the Checkbutton look more like
    the native widgets of your working platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s add `ttk.separators` to our Play Bar (see code `3.12.py`).
    The format for adding separators is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Note that we cannot change the buttons in the right-button matrix from button to
    `ttk.Button`. This is because ttk buttons do not support specifying options like background
    color.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the last iteration of this project. In this iteration, we first
    saw how and why to use **ttk-themed** widgets to improve the look and feel of
    our programs.
  prefs: []
  type: TYPE_NORMAL
- en: We then used ttk Buttons and ttk Checkbuttons in our drum program to improve
    its look. We also saw the reasons why certain Tkinter Buttons in our program could
    not be replaced by ttk Buttons.
  prefs: []
  type: TYPE_NORMAL
- en: That brings us to the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here's a quick summary of things we covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We started by learning how to structure the Tkinter program as classes and objects.
  prefs: []
  type: TYPE_NORMAL
- en: We then decided the data structure for our program. This enabled us to set the ground
    for writing the rest of the program logic, maintaining a clean separation between
    data, logic, and its visual representation. We saw the vital benefits of deciding
    the data structure in advance.
  prefs: []
  type: TYPE_NORMAL
- en: We also worked with more Tkinter widgets such as Spinbox, Button, Entry, and
    Checkbutton. We also saw the grid geometry manager in action in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We then saw how to bind widgets to higher-order functions using command callbacks.
    This is a very common technique used in GUI programming.
  prefs: []
  type: TYPE_NORMAL
- en: We then understood multithreaded programming in the context of Tkinter. We moved
    the audio playback onto a separate thread. This enabled us to keep the audio playing
    without hampering Tkinter's main loop in any way.
  prefs: []
  type: TYPE_NORMAL
- en: We then understood how to persist an object's state with the pickle module and
    then how to unpickle it later to retrieve the state of the object.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw how to use ttk-themed widgets to ensure that our GUI feels native
    on the platform where it is run.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have now completed coding your drum machine.
  prefs: []
  type: TYPE_NORMAL
- en: QA section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you proceed to the next chapter, make sure you can answer these questions
    to your satisfaction:'
  prefs: []
  type: TYPE_NORMAL
- en: How do you organize a Tkinter program in an object-oriented fashion? What are
    the advantages of using an object-oriented structure as apposed to writing pure
    procedural code? What are the disadvantages?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At what stage of programming should you consider drafting a data structure for
    your GUI program? What are the benefits of having a data structure or model in
    place?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are higher-order functions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is threading required? What are its advantages and disadvantages?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the difference between a process and a thread?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is object persistence?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you pickle and unpickle objects in Python?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides pickling, what are the other common modes of persisting objects?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are ttk widgets? Why are they used?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read about object-oriented programming terminologies like class, objects, constructor,
    inheritance, encapsulation, class methods, static methods, getters, setters, and
    their specific implementation in Python. A good place to start would be the official
    documentation of classes at [https://docs.python.org/3/tutorial/classes.html](https://docs.python.org/3/tutorial/classes.html).
  prefs: []
  type: TYPE_NORMAL
- en: Read the official documentation of Python object serialization at [https://docs.python.org/3/library/pickle.html](https://docs.python.org/3/library/pickle.html).
  prefs: []
  type: TYPE_NORMAL
- en: Read more about threading, context switching, and thread-based parallelism in
    general, along with its specific implementation in Python. The official documentation
    for threading is located at [https://docs.python.org/3/library/threading.html](https://docs.python.org/3/library/threading.html).
  prefs: []
  type: TYPE_NORMAL
