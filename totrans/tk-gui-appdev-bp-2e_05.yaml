- en: Building an Audio Player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's build an audio player! Our application should have the features offered
    by typical audio players, such as play, pause, fast forward, rewind, next, mute,
    volume scale, time seek, and more. It should let listeners easily access media
    files or a media library on their local drive. The audio player should do all
    this and more. Let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the key objectives of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Tkinter widgets, namely Slider, Listbox, Radiobutton, and Canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new widgets in Tkinter by extending the existing widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding virtual events and their usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the most common coding pattern used in Tkinter-based animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning some common Tkinter extensions such as Pmw, WCK, and TIX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of the chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's call our audio player *Achtung Baby*.
  prefs: []
  type: TYPE_NORMAL
- en: The audio player will be capable of playing audio files in **AU**, **MP2**,
    **MP3**, **OGG/Vorbis**, **WAV**, and **WMA** formats. It will have all the controls
    that you would expect of a small media player.
  prefs: []
  type: TYPE_NORMAL
- en: We will use cross-platform modules to write the code. This will ensure that
    the player can play audio files on Windows, macOS X, and Linux platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'On completion, the audio player will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c22414e-0c82-4cbc-87c0-faafb41f3d77.png)'
  prefs: []
  type: TYPE_IMG
- en: Perhaps the most important takeaway from this chapter is to learn how to create your
    own widgets in Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: The seek bar in the preceding screenshot is an example of a custom-made widget
    that was not natively available in Tkinter, but was handcrafted for this particular
    use case.
  prefs: []
  type: TYPE_NORMAL
- en: After you learn how to create custom widgets, what you can then create will
    only be limited by what you can imagine.
  prefs: []
  type: TYPE_NORMAL
- en: External library requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the several built-in modules of Python, we will use the following
    two external modules in this project:'
  prefs: []
  type: TYPE_NORMAL
- en: The `pyglet` library for audio manipulation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Pmw** (short for **Python megawidget**) for the widgets that are not available in
    core Tkinter'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The pyglet module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pyglet is a cross-platform windowing and multimedia library for Python. It can
    be downloaded at [https://bitbucket.org/pyglet/pyglet/wiki/Download](https://bitbucket.org/pyglet/pyglet/wiki/Download).
  prefs: []
  type: TYPE_NORMAL
- en: 'Pyglet can be installed using the pip installer, which is the default package
    manager for Python  by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Windows users can also download and install binary packages for `pyglet` from [http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyglet](http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyglet).
  prefs: []
  type: TYPE_NORMAL
- en: Pyglet needs another module called `AVbin` to support playback of file formats
    such as MP2 and MP3\. `AVbin` can be obtained for Windows, Linux, and macOS from the
    download section at [http://avbin.github.io](http://avbin.github.io).
  prefs: []
  type: TYPE_NORMAL
- en: Pmw Tkinter extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the Pmw Tkinter extension to code some widget features that are
    not available in core Tkinter. Pmw can be installed by using the pip command-line
    tool, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Pmw can also be installed from the source package for all the platforms. The package
    can be downloaded from [http://sourceforge.net/projects/pmw/](http://sourceforge.net/projects/pmw/).
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing `pyglet`, `AVbin`, and Pmw, execute the following command
    from the Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If the commands execute without an error message and the version of `pyglet`
    and Pmw are the same as what's shown in the preceding code, you are ready to code your
    audio player.
  prefs: []
  type: TYPE_NORMAL
- en: Program structure and broadview skeleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first goal is to build the broad modular structure for the program. As usual, we
    will keep the data structure, audio-related logic, and the presentation logic
    in three separate files. Therefore, we will create three separate files named
    `model.py`, `player.py`, and `view.py` (see `code 5.01`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an empty `Model` class and an empty `Player` class in their respective
    files. The following is the code for `5.01`—`model.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the code for `5.01`—`player.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's create the `View` class. We will leave the `Model` and `Player`
    classes empty for now. However, we will complete this iteration by coding the
    majority of the view elements for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by importing the required modules in the `View` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, import the blank `Model` and `Player` classes in the `View` namespace
    (see code `5.01`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: However, since we do not want to mix the logic with its representation, we do
    not import `View` in the `Model` class. In short, the `Model` class knows nothing
    about how its data will be presented to the frontend user.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are not using the `Controller` class in this program. We saw how
    to use controllers in [Chapter 4](7e561bee-a102-437c-bfdf-018694145027.xhtml),
    *Game of Chess*. While controllers are a great way to avoid direct coupling between
    the `Model` and `View` classes, they can be an overkill for small programs like
    this one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the top-level window. Also, we''ll create instances of the
    `Model` and `Player` classes and pass them as arguments to the `View` class, as
    follows (see code `5.01`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the boilerplate code is written, let''s start coding the actual `View`
    class, as follows (see code `5.01`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `__init__` method should look familiar to you by now. The final line of
    the `__init__` calls a method called `create_gui`, which is responsible for the
    creation of the entire GUI. The `create_gui` method in turn simply calls five
    different methods, where each method is responsible for the creation of different
    sections of the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: We also made the root window nonresizable by adding `root.resizable(width=False,
    height=False)` to the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will not reproduce the entire code that creates the GUI, since we have coded
    similar widgets in the past. But all of these five methods, when combined, create
    the GUI shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9365cfd3-e4a3-42b4-b66f-e96abf36d72c.png)'
  prefs: []
  type: TYPE_IMG
- en: For the sake of separation, we have also marked the four sections differently
    in the preceding screenshot. The fifth method creates the right-click context
    menu and is not visible here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code used to create all of these GUI elements should be familiar to you
    by now. However, note a few things about the code (see code `5.01`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: All the images used in the preceding code have been stored in a separate folder
    named `icons`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have used the grid geometry manager to place all the elements on the top-level
    window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Top Display section creates a Canvas widget and places an overlay image
    using the `canvas.create_image()` method. The currently playing text and the timer
    displayed in the top display have been created by using the `canvas.create_text()`
    method. The coordinates used to place these elements have been decided on a trial-and-error
    basis. As a reminder, the canvas coordinates are measured from the top-left corner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Button Frame** section simply creates buttons and uses images instead
    of text, using the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The **Button Frame** section also uses a ttk Scale widget, which can be used
    as a volume slider. This has been created by using the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `from` and `to` values for the Scale widget have been chosen as `0.0` and
    `1.0` because these are the numbers that the `pyglet` library uses to denote the
    minimum and maximum volume, which will be seen in the following section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Listbox section creates a playlist by using the Tkinter Listbox widget,
    which uses the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `select mode=EXTENDED` option in the preceding code means that this list
    box will allow multiple list items to be selected at once. If this line is omitted,
    the default behavior of the Listbox widget is to allow only a single selection
    at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `activestyle='none'` option means that we do not want to underline the selected
    item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Listbox section is attached to the Scrollbar widget, which is similar to
    what we have done in the earlier chapters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Bottom Frame** section adds a few image buttons as we did earlier. It
    also creates three Radiobutton widgets using a `for` loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, note that we have completely skipped the creation of the seek bar,
    as it is a custom widget that is not natively defined in Tkinter. This is something
    that we will create in a dedicated section of its own.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Listbox widget offers the following four selection modes via the selectmode
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SINGLE`: This allows only a single row to be selected at a time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BROWSE` (the default mode): This is similar to `SINGLE`, but it allows you
    to move a selection by dragging the mouse'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MULTIPLE`: This allows for multiple selections by clicking on items one at
    a time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXTENDED`: This allows for the selection of a multiple range of items using
    the *Shift* and *Ctrl* keys'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to creating all of these widgets, we have also added a command
    callback to most of these widgets. These command callbacks currently point to
    the following empty, nonfunctional methods (see code `5.01`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: None of these methods are functional now. We will end the iteration here, as there
    are a few other things that we need to do before we can think of making the widgets
    functional.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding the data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sticking to the model first philosophy, let's spend some time on deciding the appropriate
    data structure or model for the program.
  prefs: []
  type: TYPE_NORMAL
- en: The data structure of the audio player is fairly simple. All that we expect
    of the model is to keep a track of playlists. The main data then is a list called
    `play_list`, and the `Model` class is then simply responsible for the addition
    and removal of items to and from the playlist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly we came up with the following `Model` class for the program (see
    code `5.02`—`model.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Nothing fancy in the preceding code. The object simply consists of a Python
    list with various utility methods that can be used to add and remove items from
    the list.
  prefs: []
  type: TYPE_NORMAL
- en: The `play_list` method has been declared as a property so that we need not write
    the `getter` method for the playlist. This is definitely more Pythonic because a
    statement such as `play_list = self.play_list` is more readable than `play_list
    = self.get_play_list()`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Player class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's write the code for the `Player` class. This class will be responsible
    for the handling of audio playback and its related functions, such as pause, stop,
    seek, fast forward, rewind, change of volume, mute, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `pyglet` library to handle these functions.
  prefs: []
  type: TYPE_NORMAL
- en: Pyglet is a cross-platform library that uses the `AVbin` module to support a
    large variety of audio files.
  prefs: []
  type: TYPE_NORMAL
- en: You might want to look at the API documentation of the pyglet player, which
    is available at [https://bitbucket.org/pyglet/pyglet/wiki/Home](https://bitbucket.org/pyglet/pyglet/wiki/Home).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also access the documentation for the pyglet media player class by
    typing the following two lines in the Python interactive shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The online documentation at [https://pyglet.readthedocs.org/](https://pyglet.readthedocs.org/)
    tells us that we can play an audio file by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Accordingly, the code for the `Player` class is as follows (see code `5.02`—`player.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is built on the `pyglet` API, which is quite intuitive. We
    will not get into the details of audio programming here and trust the `pyglet`
    library as a black box that delivers what it says, namely, to be able to play
    and control audio.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the important things that you should note about the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: We defined the `play_media` method, which is responsible for the playing of
    audio. All the other methods support other functions related to playback, such
    as pause, stop, rewind, forward, mute, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the code defines a new pyglet `Player` class every time it wants to play
    an audio file. Though we could have used the same player instance to play multiple
    audio files, it turns out that the `pyglet` library does not have a `stop` method.
    The only way we can stop an audio file from playing is by killing the `Player`
    object and creating a fresh `Player` object for the next audio file playback.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it came to choosing an external implementation as we did for the audio API
    here, we first searched through the Python standard library at [https://docs.python.org/3.6/library/](https://docs.python.org/3.6/library/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the standard library does not have a suitable package for us, we turned our
    attention to the Python package index to check whether there exists another high-level
    audio interface implementation. The Python package index can be found at [http://pypi.python.org/](http://pypi.python.org/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fortunately, we came across several audio packages. After comparing the packages against
    our needs and seeing how active their communities were, we settled for `pyglet`. The
    same program could have been implemented with several other packages, though this
    would be done with varying levels of complexity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, the lower you go down the protocol stack, the more complex your
    programs will get.
  prefs: []
  type: TYPE_NORMAL
- en: However, at the lower layers of the protocol, you will get a finer control over
    the implementation at the cost of increasing learning curves.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that most of the audio libraries change over a period of time. While
    this current audio library may become nonfunctional over time, you can easily
    modify the `Player` class to use some other audio library and still be able to
    use this program as long as you keep the interface defined in the `Player` class.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the iteration. We now have a functional `Player` class that can manipulate
    audio files. We have a data structure that consists of a `play_list` with various
    methods to add and remove files from a playlist. We will next look at how to add
    and remove files from a playlist from the frontend of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing items from a playlist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write some code for a feature that allows us to add and remove items
    from a playlist. To be more specific, we will write the code for a function for
    the four buttons marked in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68cc3347-c466-46e2-be08-8fccefdaa0fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The four buttons, from left to right, perform the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The first button from the left adds individual audio files to a playlist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second button deletes all the selected items from the playlist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third button scans a directory for audio files and adds all the found audio
    files to the playlist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last button empties the playlist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since adding these features requires us to interact with the Listbox widget
    of Tkinter, let''s spend some time getting to know the Listbox widget:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a Listbox widget like we''d create any other widget, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When you initially create a Listbox widget, it is empty. To insert one or more
    lines of text into the Listbox, use the `insert()` method, which takes two arguments,
    namely an index of the position where the text needs to be inserted and the actual
    string that needs to be inserted, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `curselection()` method returns the index of all the items selected in
    the list, and the `get()` method returns the list item for a given index, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In addition to this, the Listbox widget has several other configurable options.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a complete Listbox widget reference, type the following into the Python interactive
    shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how to add and remove items from the Listbox widget, let's
    code these functions into the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by modifying the command callback attached to the four buttons,
    as follows (see code `5.03`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'All that these four methods do is call four other methods that do the actual
    task of adding or removing items to the playlist. All the methods will update
    the `play_list` items at the following two places:'
  prefs: []
  type: TYPE_NORMAL
- en: In the visible Listbox widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the backend data structure playlist maintained by the `Model` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's define the four new methods.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a single audio file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding a file involves asking for the location using Tkinter `filedialog` and
    updating the frontend and backend, as follows (see code `5.03`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Removing the selected files from a playlist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the Listbox allows for multiple selections, we iterate through all the
    selected items, removing them from the frontend Listbox widget as well as from
    the model `play_list`, as follows (see code `5.03`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note that we reverse the tuple before removing items from the playlist because
    we want to start removing items from the end, as a removal causes a change in
    the index of playlist items. If we do not remove items from the end, we may end
    up removing the wrong items from the list, as its index gets modified in each
    iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have defined this method here, let''s add it as a command callback
    to the right-click delete menu, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Adding all files from a directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code uses the `os.walk()` method to recursively walk through
    all the files looking for  `.wav` and `.mp3` files, as follows (see code `5.03`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Emptying the playlist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code is as follows (see code `5.03`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This completes our third iteration. In this iteration, we saw how to work with
    the Listbox widget. In particular, we saw how to add items to the Listbox widget,
    select a particular item from the Listbox widget, and delete one or more items
    from it.
  prefs: []
  type: TYPE_NORMAL
- en: You now have a playlist where you can add and delete items using the four buttons at
    the bottom-left corner of the audio player.
  prefs: []
  type: TYPE_NORMAL
- en: Playing audio and adding audio controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this iteration, we will code the features marked in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3bd65c1e-acc7-4c28-9967-c2fc5eefc226.png)'
  prefs: []
  type: TYPE_IMG
- en: This includes the play/stop, pause/unpause, next track, previous track, fast
    forward, rewind, volume change, and mute/unmute features.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the play/stop function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a playlist and a `Player` class that can play audio, playing
    audio is simply about updating the current track index and calling the `play`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, let''s add an attribute, as follows (see code `5.04`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore, the **Play** button should act as a toggle between the `play` and
    `stop` functions. The Python `itertools` module provides the `cycle` method, which
    is a very convenient way to toggle between two or more values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, import the `itertools` module and define a new attribute, as follows
    (see code `5.04`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time we call `next(toggle_play_stop)`, the value returned toggles between
    the `play` and `stop` strings.
  prefs: []
  type: TYPE_NORMAL
- en: Itertools is a very powerful standard library of Python that can emulate many
    **iterables** from a functional programming paradigm. An iterable in Python is
    an interface that implements the `next()` method. Every subsequent call to `next()`
    is **lazily evaluated**—thereby making them suitable for iterating over large
    sequences in the most efficient manner. The `cycle()` tool used here is an example
    of an iterator that can provide infinite sequences of alternating values without
    the need to define a large data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the documentation of the `itertools` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/itertools.html](https://docs.python.org/3/library/itertools.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, modify the `on_play_stop_button_clicked()` method so that it looks like
    this (see code `5.04`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding method simply toggles between calling the `start_play()` and `stop_play()`
    methods, which are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code calls the `play` and `stop` methods defined in the `Player` class.
    It also changes the button image from the *play* icon to the *stop* icon by using the
    `widget.config(image=new_image_icon)` method.
  prefs: []
  type: TYPE_NORMAL
- en: While we are handling the `play` function, let's modify the command callback
    so that a user can play a track simply by double-clicking on it. We have already
    defined a method named `on_play_list_double_clicked` earlier, which is currently
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply modify it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Adding the pause/unpause function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we need a single button to toggle between pause and unpause, we will
    again use the `cycle()` method from the `itertools` module. Define an attribute,
    as follows (see code `5.04`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, modify the command callback attached to the button, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This takes care of the pause and unpause features of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the mute/unmute function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is similar to coding the pause/unpause feature. We need an attribute that can
    toggle between the `mute` and `unmute` strings. Accordingly, add an attribute, as
    follows (see code `5.04`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, modify the command callback to call the `mute` or `unmute` functions
    from the `player` class, change the button icon to the mute or unmute image, and
    shift the volume scale accordingly, as follows (see code `5.04`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Fast forward/rewind function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The codes for fast forward and rewind are the simplest. We have already defined
    the methods to handle this in the `Player` class. Now, it''s only a matter of
    connecting them to the concerned command callback, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Adding the next track/previous track function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we had defined the code for fast forward and rewind in the `Player` class, we
    did not define the method related to next track and previous track there, because this
    can be handled by the existing `play` method. All that you need to do is simply increment
    or decrement the value of `current_track` and then call the `play` method. Accordingly,
    define two methods in the `View` class, as follows (see code `5.04`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, simply attach these two methods to the respective command callback, as
    follows (see code `5.04`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Adding the volume change function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already defined the `volume` method in the `Player` class. Now, all
    that you need to do is simply get the value of the Volume Scale widget and set
    the volume in the `Player` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, ensure that in case the volume becomes zero, we change the volume button icon
    to the mute image (see code `5.04`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the iteration. The player is now functional enough to be called
    an audio player. Go ahead and add some music files to the player. Press the play
    button and enjoy the music! Try out other player controls that we defined in this
    iteration and they should work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a seek bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's add a seek bar to the audio player. Tkinter offers the Scale widget
    that we used for the volume scale. The Scale widget could have functioned as a
    seek bar.
  prefs: []
  type: TYPE_NORMAL
- en: But we want something fancier. Moreover, the Scale widget would look different
    on different platforms. Instead, we want the seek bar to look uniform on all platforms.
    This is where we can create our own widget to meet the custom needs of the audio
    player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our own Seekbar widget, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd25afb3-8f5a-4483-a745-9c000bb5bf70.png)'
  prefs: []
  type: TYPE_IMG
- en: The simplest way to create our own widget is to inherit one from an existing
    widget or the `Widget` class.
  prefs: []
  type: TYPE_NORMAL
- en: When you look at the source code of Tkinter, you will find that all the widgets
    inherit from a class named `Widget`. The `Widget` class, in turn, inherits from
    another class called `BaseWidget`. The `BaseWidget` class contains the code that
    is used to handle a widget's `destroy()` method, but it is not aware of a geometry
    manager.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, if we want our custom widget to be aware of and use geometry managers such
    as `pack`, `grid`, or `place`, we need to inherit from the `Widget` class or from
    another Tkinter widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we want to create a widget named `Wonderwidget`. We can
    do so simply by inheriting from the `Widget` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: These four lines of code create a widget named `Wonderwidget`, which can be positioned
    with geometry managers such as `pack`, `place`, or `grid`.
  prefs: []
  type: TYPE_NORMAL
- en: However, for more practical use cases, we generally inherit from the existing
    Tkinter widgets, such as `Text`, `Button`, `Scale`, `Canvas`, and so on. In our
    case, we will create the `Seekbar` widget by inheriting from the `Canvas` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `seekbar.py` (see code `5.05.py`). Then, create a
    new class named `Seekbar` that inherits from the `Canvas` widget, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code calls the `__init__` method of the parent `Canvas` class
    to initialize the underlying canvas with all the canvas-related options that are passed
    as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'With as little code as that, let''s go back and modify the `create_top_display()`method
    in the `View` class to add this new widget, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, `SEEKBAR_WIDTH` is a constant that we defined as equal to 360 pixels in the
    program.
  prefs: []
  type: TYPE_NORMAL
- en: If you now run `view.py`, you will see the `Seekbar` widget at its place.
  prefs: []
  type: TYPE_NORMAL
- en: The seek bar is not functional, as it does not move when the seek bar knob is
    clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make the seek bar slide along, we will bind the mouse buttons by defining
    a new method and calling it from the `__init__` method, as follows (see code `5.05`—`seekbar.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We bind the entire canvas, the red rectangle, and the seek bar knob to a single method
    named `on_seekbar_clicked`, which can be defined as follows (see code `5.05`—`seekbar.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding method simply calls another method named `slide_to_position`,
     which is responsible for changing the position of the knob and the size of the
    red rectangle (see code `5.05`—`seekbar.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code slides the knob to the new position. More importantly, the
    last line creates a custom event named `SeekbarPositionChanged`. This event will
    let any code that uses this custom widget handle the event appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument, `x=new_position`, adds the value of `x` to `event.x`, making
    it available to the event handler.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have only been handling events. Tkinter also lets us create our own
    events, which are called **virtual events**.
  prefs: []
  type: TYPE_NORMAL
- en: We can specify any name for the event by enclosing the name in double pairs
    of `<<...>>`.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we generated a virtual event named `<<SeekbarPositionChanged>>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then bound it to the appropriate event handler in the `View` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all that there is to the custom `Seekbar` widget. We can write a small
    test in `seekbar.py` that will check whether the `Seekbar` widget works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and run the `5.05`—`seekbar.py` program; it should produce a seek bar. The
    seek bar should slide when you drag the seek bar knob or click at various places
    on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the iteration. We will make the audio player's seek bar functional
    in the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: One-time updates during audio playback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The audio program must update some information as soon as an audio track starts playing.
    Broadly speaking, there are two kinds of updates that the program needs to monitor
    and update:'
  prefs: []
  type: TYPE_NORMAL
- en: '**One-time updates**: Examples of this include the name of the track and the total
    length of the track.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous updates**: Examples of this include the position of the seek bar knob
    and the elapsed play duration. We also need to check continuously whether a track
    has ended either to play the next track, play the current track again, or stop
    playing, depending on the loop choice made by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These two kinds of updates will affect sections of the audio player, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50ad1983-d89e-4f73-a016-a2b2eec1858e.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's start with the one-time updates, as they are relatively simple to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since these updates must occur when the playback starts, let''s define a method named
    `manage_one_time_updates()` and call it from within the `start_play()` method
    of the `View` class, as follows (see code `5.06`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define all the methods called from within the preceding method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: These two methods simply find out the track name and track duration and update the
    related canvas text by using a call to `canvas.itemconfig`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like we use `config` to change the value of widget-related options, the
    `Canvas` widget uses `itemconfig` to change the options for individual items within
    the canvas.  The format for `itemconfig` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Let's define two helper methods in a new file named `helpers.py` and import the
    methods in the view namespace. The two methods are `truncate_text` and `get_time_in_minutes_seconds`.
    The code for this can be found in the `5.06`—`helpers.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'That takes care of one-time updates. Now, when you run `5.06`—`view.py` and
    play some audio file, the player should update the track name, and the total track
    duration in the top console, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1679bd68-61e9-407d-8b0d-5fcfcb822d49.png)'
  prefs: []
  type: TYPE_IMG
- en: We will take care of periodic updates in the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Managing continuous updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will update the position of the seek bar knob and the elapsed play
    duration, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/afb5eac3-dbaf-4742-ba55-ca90aa9d129a.png)'
  prefs: []
  type: TYPE_IMG
- en: This is nothing but a simple form of Tkinter-based animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common pattern of animating with Tkinter involves drawing a single frame
    and then calling the same method using the after method of Tkinter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Take a note of the `self.after` method, which calls the `animate` method in
    a loop. Once called, this function will keep updating frames once every `500` milliseconds.
    You can also add some conditions to break out of the animation loop. This is generally
    how all animations are handled in Tkinter. We will use this technique over and
    over again in several upcoming examples.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to manage animations in Tkinter, let's use the pattern to
    define a method that takes care of these periodic updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a method named `manage_periodic_updates_during_play`, which calls itself
    every 1 second to update the timer and the seek bar, as follows (see code `5.07`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Then, define two methods named `update_clock` and `update_seek_bar`, which update
    the sections highlighted in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `update_clock` method gets the elapsed duration in seconds from the `Player` class,
    converts it into minutes and seconds, and updates the canvas text using `canvas.itemconfig`,
    as follows (see code `5.07`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You may recall that we had previously defined a `slide_to_position` method
    in the `Seekbar` class. The `update_seek_bar` method simply calculates the proportionate position
    of the seek bar and then calls the `slide_to_position` method to slide the knob
    of the seekbar, as follows (see code `5.07`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you run `5.07`–`view.py`, add an audio file, and play it, the elapsed
    duration should be updated continuously in the top display. The seek bar should
    also move forward as the play progresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s great, but there is still one small detail missing. We want that when
    a user clicks somewhere on the seek bar, the playing audio seeks the new position.
    The code for seeking a new position is simple (see code `5.07`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the preceding method needs to be called whenever the seek bar position is
    changed. Let''s do this by adding a binding to the virtual event from within `5.07`—`view.py`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you run  `5.07`—`view.py`, play an audio file and click on the seek
    bar; the audio should start playing from the new position.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the iteration. We will look at how to loop over tracks in the next
    iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Looping over tracks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add the feature that allows users to loop over tracks. We have already
    defined radio buttons to allow three choices, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49e96b01-b2c0-4c28-af95-f6baf379556e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In essence, the player should provide a choice from the following three options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'No Loop: Play a track and end there'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Loop Current: Play a single track repeatedly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Loop All: Looping through the entire playlist, one after another'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The decision to follow one of these three options needs to be taken immediately
    after a particular track ends playing. The best place to judge whether a track
    has come to its end is from within the periodic updates loop that we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, modify the `manage_periodic_updates_during_play()` method to add the
    following two lines of highlighted code (see code `5.08`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This in effect means that the looping decision is checked only when the currently playing
    track ends. Then, define the `not_to_loop()` method, as follows (see code `5.09`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The code first checks the value of the selected radio button and, based on
    the selected choice, makes the looping choice:'
  prefs: []
  type: TYPE_NORMAL
- en: If the selected loop value is `1` (No Loop), it does nothing and returns `True`, breaking
    out of the continuous update loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the selected loop value is `2` (loop over the current song), it again calls
    the `start_play` method and returns `False`. Thus, we do not break out of the update
    loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the loop value is `3` (Loop All), it calls the `play_next_track` method and
    returns `True`. Thus, we break out of the previous update loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The audio player can now loop over the playlist based on the looping preference
    set by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Let's conclude this iteration by overriding the close button so that the audio
    player properly deletes the player object when the user decides to close the player
    while it is playing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To override the destroy method, first add a protocol override command to the `View
    __init__` method, as follows (see code `5.08`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, define the `close_player` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the iteration. We coded the logic required to loop over tracks
    and then overrode the close button to ensure that a playing track is stopped before
    we exit the player.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a tooltip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final iteration, we will add a tooltip named the **Balloon widget**
    to all the buttons in our player.
  prefs: []
  type: TYPE_NORMAL
- en: 'A tooltip is a small **popup** that shows up when you hover your mouse over
    the Bound widget (buttons, in our case). A typical tooltip for the application
    will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2d47813-10e2-47b2-8351-f8fa620f0dbf.png)'
  prefs: []
  type: TYPE_IMG
- en: Although core Tkinter has many useful widgets, it is far from complete. For
    us, the tooltip or Balloon widget is not provided as a core Tkinter widget. Therefore,
    we look for these widgets in what are called **Tkinter extensions**.
  prefs: []
  type: TYPE_NORMAL
- en: These extensions are nothing but a collection of extended Tkinter widgets, just
    like the custom seek bar that we created.
  prefs: []
  type: TYPE_NORMAL
- en: There are literally hundreds of Tkinter extensions. In fact, we just wrote our
    own Tkinter extension in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the following are some of the popular Tkinter extensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pmw**: ([http://pmw.sourceforge.net](http://pmw.sourceforge.net))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tix**: ([http://wiki.Python.org/moin/Tix](http://wiki.Python.org/moin/Tix))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TkZinc**: ([http://wiki.Python.org/moin/TkZinc](http://wiki.Python.org/moin/TkZinc))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Widget Construction Kit (WCK)**: ([http://effbot.org/zone/wck.htm](http://effbot.org/zone/wck.htm))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pmw list of extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Talking about Pmw, here is a quick list of widget extensions and dialogs from the
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows a list of widget extensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ButtonBox | ComboBox | Counter | EntryField |'
  prefs: []
  type: TYPE_TB
- en: '| Group | HistoryText | LabeledWidget | MainMenuBar |'
  prefs: []
  type: TYPE_TB
- en: '| MenuBar | MessageBar | NoteBook | OptionMenu |'
  prefs: []
  type: TYPE_TB
- en: '| PanedWidget | RadioSelect | ScrolledCanvas | ScrolledField |'
  prefs: []
  type: TYPE_TB
- en: '| ScrolledFrame | ScrolledListBox | ScrolledText | TimeCounter |'
  prefs: []
  type: TYPE_TB
- en: Dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows a list of widget dialogs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| AboutDialog | ComboBoxDialog | CounterDialog | Dialog |'
  prefs: []
  type: TYPE_TB
- en: '| MessageDialog | PromptDialog | SelectionDialog | TextDialog |'
  prefs: []
  type: TYPE_TB
- en: Miscellaneous
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a list of miscellaneous widgets offered by Pmw:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Balloon`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Blt` (used for graph generation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Color Module` functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pmw offers a large list of extended widgets. For a demonstration of all these
    widgets, browse the Pmw package that you installed earlier and look for a directory
    named `demo`. Within `demo`, look for a file named `All.py`, which demonstrates
    all of these Pmw extensions with a sample working code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pmw provides the `Balloon` widget implementation, which will be used in the current
    example. Begin by importing `Pmw` into the namespace, as follows (see code `5.09`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, instantiate the `Balloon` widget within the `create_gui` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, bind the `Balloon` widget to each button widget in the audio player.
    We will not reproduce the code for each button. However, the format is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, the Add File button will have a balloon binding, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Add similar code for each button in `5.09`—`view.py`.
  prefs: []
  type: TYPE_NORMAL
- en: This completes the iteration. We added Balloon tooltips to the audio player's
    buttons using the Pmw Tkinter extension. Most importantly, we got to know about
    the Tkinter extensions and when to use them.
  prefs: []
  type: TYPE_NORMAL
- en: When you need a widget implementation that is not available as a core widget,
    try looking for its implementations in Pmw or TIX. If you don't find one that
    suits your needs, search the internet for some other Tkinter extension. If you
    still don't find your desired implementation, it's time to build one.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of this chapter. The audio player is ready!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's recap the things that we touched upon in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to reinforcing a lot of GUI programming techniques that we discussed
    in the previous chapters, you learned how to work with more widgets such as Listbox, ttk
    Scale, and Radiobutton. We looked deeper into the features of the Canvas widget.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, we learned how to create our custom widgets, thereby extending Tkinter's
    core widgets. This is a really powerful technique that can be applied to build
    all sorts of features into programs.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to generate and handle virtual events.
  prefs: []
  type: TYPE_NORMAL
- en: We saw the most common technique for applying animation in Tkinter programs.
    This technique can also be used to build all sorts of interesting games.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we got to know about some common Tkinter extensions, such as Pmw, WCK,
    TIX, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's lose ourselves in some music!
  prefs: []
  type: TYPE_NORMAL
- en: QA section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you proceed to the next chapter, make sure you can answer these questions
    to your
  prefs: []
  type: TYPE_NORMAL
- en: 'satisfaction:'
  prefs: []
  type: TYPE_NORMAL
- en: How can we create our own custom widgets in Tkinter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you create animations with Tkinter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are virtual events? When and how do we use them?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are Tkinter extensions? What are the most popular ones?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Look at the documentation for popular Tkinter extensions such as Pmw, Tix, WCK,
    and others.  Take a note of the commonly available widgets in these extensions.
  prefs: []
  type: TYPE_NORMAL
