- en: Building an Audio Player
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个音频播放器
- en: Let's build an audio player! Our application should have the features offered
    by typical audio players, such as play, pause, fast forward, rewind, next, mute,
    volume scale, time seek, and more. It should let listeners easily access media
    files or a media library on their local drive. The audio player should do all
    this and more. Let's begin!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个音频播放器！我们的应用程序应该具备典型音频播放器提供的功能，例如播放、暂停、快进、快退、下一曲、静音、音量调节、时间搜索等。它应该让听众能够轻松访问他们本地驱动器上的媒体文件或媒体库。音频播放器应该做到所有这些，并且更多。让我们开始吧！
- en: 'The following are the key objectives of this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为本章节的关键目标：
- en: Exploring Tkinter widgets, namely Slider, Listbox, Radiobutton, and Canvas
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Tkinter 小部件，即滑块（Slider）、列表框（Listbox）、单选按钮（Radiobutton）和画布（Canvas）
- en: Creating new widgets in Tkinter by extending the existing widgets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过扩展现有小部件在 Tkinter 中创建新小部件
- en: Understanding virtual events and their usage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解虚拟活动及其用法
- en: Learning the most common coding pattern used in Tkinter-based animations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习在Tkinter动画中使用的最常见编码模式
- en: Learning some common Tkinter extensions such as Pmw, WCK, and TIX
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习一些常见的 Tkinter 扩展，如 Pmw、WCK 和 TIX
- en: An overview of the chapter
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节概述
- en: Let's call our audio player *Achtung Baby*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们的音频播放器称为*Achtung Baby*。
- en: The audio player will be capable of playing audio files in **AU**, **MP2**,
    **MP3**, **OGG/Vorbis**, **WAV**, and **WMA** formats. It will have all the controls
    that you would expect of a small media player.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 音频播放器将能够播放**AU**、**MP2**、**MP3**、**OGG/Vorbis**、**WAV**和**WMA**格式的音频文件。它将具备您期望的小型媒体播放器所拥有的所有控制功能。
- en: We will use cross-platform modules to write the code. This will ensure that
    the player can play audio files on Windows, macOS X, and Linux platforms.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用跨平台模块来编写代码。这将确保玩家可以在Windows、macOS X和Linux平台上播放音频文件。
- en: 'On completion, the audio player will look as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，音频播放器将呈现如下：
- en: '![](img/7c22414e-0c82-4cbc-87c0-faafb41f3d77.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7c22414e-0c82-4cbc-87c0-faafb41f3d77.png)'
- en: Perhaps the most important takeaway from this chapter is to learn how to create your
    own widgets in Tkinter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最重要的收获可能是学习如何创建自己的Tkinter小部件。
- en: The seek bar in the preceding screenshot is an example of a custom-made widget
    that was not natively available in Tkinter, but was handcrafted for this particular
    use case.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一张截图中的搜索栏是一个自定义小部件的例子，这个小部件在Tkinter中不是原生可用的，但为了这个特定的用例而手工制作。
- en: After you learn how to create custom widgets, what you can then create will
    only be limited by what you can imagine.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在你学会了如何创建自定义小部件之后，你能够创造的内容将只受限于你的想象力。
- en: External library requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部库需求
- en: 'In addition to the several built-in modules of Python, we will use the following
    two external modules in this project:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Python的几个内置模块外，我们将在本项目中使用以下两个外部模块：
- en: The `pyglet` library for audio manipulation
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于音频处理的 `pyglet` 库
- en: '**Pmw** (short for **Python megawidget**) for the widgets that are not available in
    core Tkinter'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Pmw**（代表**Python megawidget**）用于核心Tkinter中不可用的控件'
- en: The pyglet module
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pyglet 模块
- en: Pyglet is a cross-platform windowing and multimedia library for Python. It can
    be downloaded at [https://bitbucket.org/pyglet/pyglet/wiki/Download](https://bitbucket.org/pyglet/pyglet/wiki/Download).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Pyglet 是一个跨平台的 Python 窗口和多媒体库。您可以从 [https://bitbucket.org/pyglet/pyglet/wiki/Download](https://bitbucket.org/pyglet/pyglet/wiki/Download)
    下载。
- en: 'Pyglet can be installed using the pip installer, which is the default package
    manager for Python  by using the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Pyglet 可以使用 pip 安装程序进行安装，这是 Python 的默认包管理器，通过以下命令进行安装：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Windows users can also download and install binary packages for `pyglet` from [http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyglet](http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyglet).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Windows用户也可以从[http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyglet](http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyglet)下载并安装`pyglet`的二进制包。
- en: Pyglet needs another module called `AVbin` to support playback of file formats
    such as MP2 and MP3\. `AVbin` can be obtained for Windows, Linux, and macOS from the
    download section at [http://avbin.github.io](http://avbin.github.io).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Pyglet 需要另一个名为 `AVbin` 的模块来支持播放 MP2 和 MP3 等文件格式。`AVbin` 可以从 [http://avbin.github.io](http://avbin.github.io)
    的下载部分获取。
- en: Pmw Tkinter extension
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pmw Tkinter 扩展
- en: 'We will use the Pmw Tkinter extension to code some widget features that are
    not available in core Tkinter. Pmw can be installed by using the pip command-line
    tool, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Pmw Tkinter 扩展来编写一些在核心 Tkinter 中不可用的小部件功能。Pmw 可以通过使用 pip 命令行工具进行安装，如下所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Pmw can also be installed from the source package for all the platforms. The package
    can be downloaded from [http://sourceforge.net/projects/pmw/](http://sourceforge.net/projects/pmw/).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Pmw也可以从所有平台的源代码包中安装。该包可以从[http://sourceforge.net/projects/pmw/](http://sourceforge.net/projects/pmw/)下载。
- en: 'After installing `pyglet`, `AVbin`, and Pmw, execute the following command
    from the Python shell:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完 `pyglet`、`AVbin` 和 Pmw 后，从 Python 壳中执行以下命令：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the commands execute without an error message and the version of `pyglet`
    and Pmw are the same as what's shown in the preceding code, you are ready to code your
    audio player.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令执行没有错误信息，并且`pyglet`和Pmw的版本与前面代码中显示的相同，那么你就可以开始编写你的音频播放器了。
- en: Program structure and broadview skeleton
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序结构和宏观骨架
- en: Our first goal is to build the broad modular structure for the program. As usual, we
    will keep the data structure, audio-related logic, and the presentation logic
    in three separate files. Therefore, we will create three separate files named
    `model.py`, `player.py`, and `view.py` (see `code 5.01`).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要目标是构建程序的广泛模块化结构。像往常一样，我们将数据结构、音频相关逻辑和展示逻辑分别保存在三个独立的文件中。因此，我们将创建三个独立的文件，分别命名为`model.py`、`player.py`和`view.py`（参见`代码
    5.01`）。
- en: 'Let''s create an empty `Model` class and an empty `Player` class in their respective
    files. The following is the code for `5.01`—`model.py`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在各自的文件中创建一个空的`Model`类和一个空的`Player`类。以下是为`5.01`版本的`model.py`文件提供的代码：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here''s the code for `5.01`—`player.py`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`5.01`版本的`player.py`代码：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, let's create the `View` class. We will leave the `Model` and `Player`
    classes empty for now. However, we will complete this iteration by coding the
    majority of the view elements for the player.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建`View`类。现在我们将`Model`和`Player`类留空。然而，我们将通过编写大多数玩家视图元素来完成这个迭代。
- en: 'Let''s begin by importing the required modules in the `View` class, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`View`类中导入所需的模块开始，如下所示：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Also, import the blank `Model` and `Player` classes in the `View` namespace
    (see code `5.01`—`view.py`):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`View`命名空间中导入空的`Model`和`Player`类（参见代码`5.01`—`view.py`）：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, since we do not want to mix the logic with its representation, we do
    not import `View` in the `Model` class. In short, the `Model` class knows nothing
    about how its data will be presented to the frontend user.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我们不希望将逻辑与其表示混合在一起，我们在`Model`类中不导入`View`。简而言之，`Model`类对如何将其数据呈现给前端用户一无所知。
- en: Note that we are not using the `Controller` class in this program. We saw how
    to use controllers in [Chapter 4](7e561bee-a102-437c-bfdf-018694145027.xhtml),
    *Game of Chess*. While controllers are a great way to avoid direct coupling between
    the `Model` and `View` classes, they can be an overkill for small programs like
    this one.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个程序中我们没有使用`Controller`类。我们在[第4章](7e561bee-a102-437c-bfdf-018694145027.xhtml)，“棋盘游戏”中看到了如何使用控制器。虽然控制器是避免`Model`类和`View`类之间直接耦合的好方法，但对于像这样的小程序来说，它们可能有些过度。
- en: 'Now, let''s create the top-level window. Also, we''ll create instances of the
    `Model` and `Player` classes and pass them as arguments to the `View` class, as
    follows (see code `5.01`—`view.py`):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建顶层窗口。同时，我们还将创建`Model`和`Player`类的实例，并将它们作为参数传递给`View`类，如下所示（参见代码`5.01`—`view.py`）：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that the boilerplate code is written, let''s start coding the actual `View`
    class, as follows (see code `5.01`—`view.py`):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '现在模板代码已经编写完成，让我们开始编写实际的`View`类，如下所示（参见代码`5.01`—`view.py`):'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `__init__` method should look familiar to you by now. The final line of
    the `__init__` calls a method called `create_gui`, which is responsible for the
    creation of the entire GUI. The `create_gui` method in turn simply calls five
    different methods, where each method is responsible for the creation of different
    sections of the GUI.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__` 方法现在应该对你来说已经很熟悉了。`__init__` 方法的最后一行调用了一个名为 `create_gui` 的方法，该方法负责创建整个
    GUI。`create_gui` 方法反过来又简单地调用了五个不同的方法，其中每个方法负责创建 GUI 的不同部分。'
- en: We also made the root window nonresizable by adding `root.resizable(width=False,
    height=False)` to the code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在代码中添加 `root.resizable(width=False, height=False)` 使根窗口不可调整大小。
- en: 'We will not reproduce the entire code that creates the GUI, since we have coded
    similar widgets in the past. But all of these five methods, when combined, create
    the GUI shown in the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会重新展示创建GUI的完整代码，因为我们之前已经编写过类似的控件。但是，这五种方法结合在一起，就能创建出以下截图所示的GUI：
- en: '![](img/9365cfd3-e4a3-42b4-b66f-e96abf36d72c.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9365cfd3-e4a3-42b4-b66f-e96abf36d72c.png)'
- en: For the sake of separation, we have also marked the four sections differently
    in the preceding screenshot. The fifth method creates the right-click context
    menu and is not visible here.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分，我们在前面的截图中也用不同的方式标记了这四个部分。第五种方法创建的是右键点击上下文菜单，这里没有显示。
- en: 'The code used to create all of these GUI elements should be familiar to you
    by now. However, note a few things about the code (see code `5.01`—`view.py`):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建所有这些图形用户界面元素的代码你现在应该已经熟悉了。然而，请注意以下几点关于代码的内容（参见代码 `5.01`—`view.py`）：
- en: All the images used in the preceding code have been stored in a separate folder
    named `icons`.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的代码中使用的所有图片都已存储在一个名为 `icons` 的单独文件夹中。
- en: We have used the grid geometry manager to place all the elements on the top-level
    window.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经使用网格几何管理器将所有元素放置在顶层窗口上。
- en: The Top Display section creates a Canvas widget and places an overlay image
    using the `canvas.create_image()` method. The currently playing text and the timer
    displayed in the top display have been created by using the `canvas.create_text()`
    method. The coordinates used to place these elements have been decided on a trial-and-error
    basis. As a reminder, the canvas coordinates are measured from the top-left corner.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶部显示区域通过使用 `canvas.create_image()` 方法创建了一个画布小部件，并放置了一个覆盖图像。当前播放的文本和顶部显示中的计时器是通过使用
    `canvas.create_text()` 方法创建的。放置这些元素所使用的坐标是基于试错法决定的。作为提醒，画布坐标是从左上角测量的。
- en: 'The **Button Frame** section simply creates buttons and uses images instead
    of text, using the following code:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按钮框架**部分简单创建按钮，并使用图像代替文本，使用以下代码：'
- en: '[PRE9]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The **Button Frame** section also uses a ttk Scale widget, which can be used
    as a volume slider. This has been created by using the following code:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按钮框架**部分也使用了 ttk Scale 小部件，它可以作为音量滑块使用。这是通过以下代码创建的：'
- en: '[PRE10]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `from` and `to` values for the Scale widget have been chosen as `0.0` and
    `1.0` because these are the numbers that the `pyglet` library uses to denote the
    minimum and maximum volume, which will be seen in the following section.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scale控件中的`from`和`to`值被选为`0.0`和`1.0`，因为这些是`pyglet`库用来表示最小和最大音量的数字，这将在下一节中看到。
- en: 'The Listbox section creates a playlist by using the Tkinter Listbox widget,
    which uses the following code:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表框部分通过使用 Tkinter 列表框小部件来创建播放列表，该小部件使用以下代码：
- en: '[PRE11]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `select mode=EXTENDED` option in the preceding code means that this list
    box will allow multiple list items to be selected at once. If this line is omitted,
    the default behavior of the Listbox widget is to allow only a single selection
    at a time.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一段代码中的`select mode=EXTENDED`选项意味着这个列表框将允许一次性选择多个列表项。如果省略这一行，列表框小部件的默认行为是每次只允许选择一个项。
- en: The `activestyle='none'` option means that we do not want to underline the selected
    item.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activestyle=''none''`选项意味着我们不希望为选定的项目添加下划线。'
- en: The Listbox section is attached to the Scrollbar widget, which is similar to
    what we have done in the earlier chapters.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表框部分连接到滚动条小部件，这与我们在前面的章节中所做的是类似的。
- en: The **Bottom Frame** section adds a few image buttons as we did earlier. It
    also creates three Radiobutton widgets using a `for` loop.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**底部框架**部分添加了几个图像按钮，就像我们之前做的那样。它还使用`for`循环创建了三个单选按钮小部件。'
- en: Finally, note that we have completely skipped the creation of the seek bar,
    as it is a custom widget that is not natively defined in Tkinter. This is something
    that we will create in a dedicated section of its own.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，请注意，我们完全跳过了滚动条的创建，因为它是一个在Tkinter中未原生定义的自定义小部件。这是我们将在其独立部分中创建的内容。
- en: 'The Listbox widget offers the following four selection modes via the selectmode
    option:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表框小部件通过selectmode选项提供了以下四种选择模式：
- en: '`SINGLE`: This allows only a single row to be selected at a time'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SINGLE`: 这允许每次只选择一行'
- en: '`BROWSE` (the default mode): This is similar to `SINGLE`, but it allows you
    to move a selection by dragging the mouse'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BROWSE`（默认模式）：这与`SINGLE`类似，但它允许你通过拖动鼠标来移动选择项'
- en: '`MULTIPLE`: This allows for multiple selections by clicking on items one at
    a time'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MULTIPLE`: 这允许通过逐个点击项目进行多次选择'
- en: '`EXTENDED`: This allows for the selection of a multiple range of items using
    the *Shift* and *Ctrl* keys'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXTENDED`: 这允许使用 *Shift* 和 *Ctrl* 键选择多个范围的项'
- en: 'In addition to creating all of these widgets, we have also added a command
    callback to most of these widgets. These command callbacks currently point to
    the following empty, nonfunctional methods (see code `5.01`—`view.py`):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建所有这些小部件外，我们还为其中大多数小部件添加了命令回调。这些命令回调目前指向以下空的非功能方法（参见代码`5.01`—`view.py`）：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: None of these methods are functional now. We will end the iteration here, as there
    are a few other things that we need to do before we can think of making the widgets
    functional.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法现在都不起作用。我们将在这里结束迭代，因为在我们考虑使小部件起作用之前，我们还需要做几件事情。
- en: Deciding the data structure
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决定数据结构
- en: Sticking to the model first philosophy, let's spend some time on deciding the appropriate
    data structure or model for the program.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 坚持模型第一的哲学，让我们花些时间来决定程序中合适的数据库结构或模型。
- en: The data structure of the audio player is fairly simple. All that we expect
    of the model is to keep a track of playlists. The main data then is a list called
    `play_list`, and the `Model` class is then simply responsible for the addition
    and removal of items to and from the playlist.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 音频播放器的数据结构相当简单。我们期望模型做的只是跟踪播放列表。主要数据是一个名为 `play_list` 的列表，而 `Model` 类则负责向播放列表中添加和移除项目。
- en: 'Accordingly we came up with the following `Model` class for the program (see
    code `5.02`—`model.py`):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，我们为该程序设计了以下`Model`类（参见代码`5.02`—`model.py`):'
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Nothing fancy in the preceding code. The object simply consists of a Python
    list with various utility methods that can be used to add and remove items from
    the list.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码中没有什么花哨的地方。这个对象仅仅是一个Python列表，其中包含各种实用方法，可以用来向列表中添加和删除项目。
- en: The `play_list` method has been declared as a property so that we need not write
    the `getter` method for the playlist. This is definitely more Pythonic because a
    statement such as `play_list = self.play_list` is more readable than `play_list
    = self.get_play_list()`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`play_list` 方法已被声明为一个属性，因此我们不需要为播放列表编写 `getter` 方法。这无疑是更符合 Python 风格的，因为像 `play_list
    = self.play_list` 这样的语句比 `play_list = self.get_play_list()` 更易于阅读。'
- en: Creating the Player class
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建玩家类
- en: Now, let's write the code for the `Player` class. This class will be responsible
    for the handling of audio playback and its related functions, such as pause, stop,
    seek, fast forward, rewind, change of volume, mute, and so on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来编写`Player`类的代码。这个类将负责处理音频播放及其相关功能，例如暂停、停止、快进、快退、音量调整、静音等等。
- en: We will use the `pyglet` library to handle these functions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`pyglet`库来处理这些功能。
- en: Pyglet is a cross-platform library that uses the `AVbin` module to support a
    large variety of audio files.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Pyglet 是一个跨平台库，它使用 `AVbin` 模块来支持大量音频文件。
- en: You might want to look at the API documentation of the pyglet player, which
    is available at [https://bitbucket.org/pyglet/pyglet/wiki/Home](https://bitbucket.org/pyglet/pyglet/wiki/Home).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想查看 pyglet 播放器的 API 文档，该文档可在 [https://bitbucket.org/pyglet/pyglet/wiki/Home](https://bitbucket.org/pyglet/pyglet/wiki/Home)
    找到。
- en: 'You can also access the documentation for the pyglet media player class by
    typing the following two lines in the Python interactive shell:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过在 Python 交互式壳中输入以下两行来访问 pyglet 媒体播放器类的文档：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The online documentation at [https://pyglet.readthedocs.org/](https://pyglet.readthedocs.org/)
    tells us that we can play an audio file by using the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://pyglet.readthedocs.org/](https://pyglet.readthedocs.org/)的在线文档中，我们了解到可以通过以下代码播放音频文件：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Accordingly, the code for the `Player` class is as follows (see code `5.02`—`player.py`):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，`Player` 类的代码如下（参见代码 `5.02`—`player.py`):'
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code is built on the `pyglet` API, which is quite intuitive. We
    will not get into the details of audio programming here and trust the `pyglet`
    library as a black box that delivers what it says, namely, to be able to play
    and control audio.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码基于`pyglet` API构建，该API非常直观。我们在此不会深入探讨音频编程的细节，并将`pyglet`库视为一个黑盒，它能够实现其声明的内容，即能够播放和控制音频。
- en: 'The following are the important things that you should note about the preceding
    code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你应该注意的关于前面代码的重要事项：
- en: We defined the `play_media` method, which is responsible for the playing of
    audio. All the other methods support other functions related to playback, such
    as pause, stop, rewind, forward, mute, and so on.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了`play_media`方法，该方法负责播放音频。所有其他方法支持与播放相关的其他功能，例如暂停、停止、倒带、快进、静音等等。
- en: Note that the code defines a new pyglet `Player` class every time it wants to play
    an audio file. Though we could have used the same player instance to play multiple
    audio files, it turns out that the `pyglet` library does not have a `stop` method.
    The only way we can stop an audio file from playing is by killing the `Player`
    object and creating a fresh `Player` object for the next audio file playback.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，每次代码想要播放音频文件时，都会定义一个新的 pyglet `Player` 类。虽然我们可以使用相同的播放器实例来播放多个音频文件，但结果却是
    `pyglet` 库没有 `stop` 方法。我们唯一能够停止播放音频文件的方式就是通过终止 `Player` 对象，并为下一个音频文件播放创建一个新的 `Player`
    对象。
- en: When it came to choosing an external implementation as we did for the audio API
    here, we first searched through the Python standard library at [https://docs.python.org/3.6/library/](https://docs.python.org/3.6/library/).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们选择外部实现，就像在这里为音频API所做的那样时，我们首先在[https://docs.python.org/3.6/library/](https://docs.python.org/3.6/library/)的Python标准库中进行了搜索。
- en: Because the standard library does not have a suitable package for us, we turned our
    attention to the Python package index to check whether there exists another high-level
    audio interface implementation. The Python package index can be found at [http://pypi.python.org/](http://pypi.python.org/).
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于标准库中没有适合我们的包，我们将注意力转向了Python包索引，以检查是否存在另一个高级音频接口实现。Python包索引可以在[http://pypi.python.org/](http://pypi.python.org/)找到。
- en: Fortunately, we came across several audio packages. After comparing the packages against
    our needs and seeing how active their communities were, we settled for `pyglet`. The
    same program could have been implemented with several other packages, though this
    would be done with varying levels of complexity.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幸运的是，我们遇到了几个音频包。在将包与我们的需求进行比较并观察其社区活跃度后，我们选择了`pyglet`。虽然同样可以使用其他几个包来实现这个程序，但这将会涉及不同复杂程度的操作。
- en: In general, the lower you go down the protocol stack, the more complex your
    programs will get.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你向下深入协议栈，你的程序将变得更加复杂。
- en: However, at the lower layers of the protocol, you will get a finer control over
    the implementation at the cost of increasing learning curves.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在协议的较低层，你将获得对实现细节的更精细控制，但这会以增加学习曲线为代价。
- en: Also, note that most of the audio libraries change over a period of time. While
    this current audio library may become nonfunctional over time, you can easily
    modify the `Player` class to use some other audio library and still be able to
    use this program as long as you keep the interface defined in the `Player` class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，大多数音频库都会随着时间的推移而发生变化。虽然这个当前的音频库可能会随着时间的推移而变得无法使用，但你可以轻松修改`Player`类以使用其他音频库，并且仍然能够使用这个程序，只要你保持`Player`类中定义的接口。
- en: This concludes the iteration. We now have a functional `Player` class that can manipulate
    audio files. We have a data structure that consists of a `play_list` with various
    methods to add and remove files from a playlist. We will next look at how to add
    and remove files from a playlist from the frontend of the program.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了迭代。我们现在有一个可以操作音频文件的`Player`类。我们有一个由`play_list`组成的数据结构，它包含各种方法来向播放列表中添加和删除文件。接下来，我们将探讨如何从程序的前端添加和删除文件到播放列表。
- en: Adding and removing items from a playlist
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从播放列表中添加和删除项目
- en: 'Let''s write some code for a feature that allows us to add and remove items
    from a playlist. To be more specific, we will write the code for a function for
    the four buttons marked in the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码来实现一个功能，允许我们从播放列表中添加和删除项目。更具体地说，我们将编写以下截图中标出的四个按钮对应的函数代码：
- en: '![](img/68cc3347-c466-46e2-be08-8fccefdaa0fa.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/68cc3347-c466-46e2-be08-8fccefdaa0fa.png)'
- en: 'The four buttons, from left to right, perform the following functions:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右，四个按钮执行以下功能：
- en: The first button from the left adds individual audio files to a playlist
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从左数第一个按钮可以将单个音频文件添加到播放列表
- en: The second button deletes all the selected items from the playlist
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个按钮会从播放列表中删除所有选中的项目
- en: The third button scans a directory for audio files and adds all the found audio
    files to the playlist
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个按钮会扫描目录以查找音频文件，并将所有找到的音频文件添加到播放列表中
- en: The last button empties the playlist
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个按钮清空播放列表
- en: 'Since adding these features requires us to interact with the Listbox widget
    of Tkinter, let''s spend some time getting to know the Listbox widget:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于添加这些功能需要我们与 Tkinter 的 Listbox 小部件进行交互，让我们花些时间来了解 Listbox 小部件：
- en: 'We can create a Listbox widget like we''d create any other widget, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个类似于创建任何其他小部件的Listbox小部件，如下所示：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When you initially create a Listbox widget, it is empty. To insert one or more
    lines of text into the Listbox, use the `insert()` method, which takes two arguments,
    namely an index of the position where the text needs to be inserted and the actual
    string that needs to be inserted, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你最初创建一个Listbox小部件时，它是空的。要将一行或多行文本插入到Listbox中，请使用`insert()`方法，该方法需要两个参数，即文本需要插入的位置的索引和需要插入的实际字符串，如下所示：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `curselection()` method returns the index of all the items selected in
    the list, and the `get()` method returns the list item for a given index, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`curselection()` 方法返回列表中所有选中项的索引，而 `get()` 方法返回给定索引的列表项，如下所示：'
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In addition to this, the Listbox widget has several other configurable options.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Listbox小部件还有其他可配置选项。
- en: 'For a complete Listbox widget reference, type the following into the Python interactive
    shell:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取完整的 Listbox 小部件参考，请在 Python 交互式壳中输入以下内容：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that we know how to add and remove items from the Listbox widget, let's
    code these functions into the player.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何从列表框小部件中添加和删除项目，让我们将这些函数编码到播放器中。
- en: 'Let''s begin by modifying the command callback attached to the four buttons,
    as follows (see code `5.03`—`view.py`):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从修改与四个按钮相关联的命令回调开始，具体如下（参见代码 `5.03`—`view.py`）：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'All that these four methods do is call four other methods that do the actual
    task of adding or removing items to the playlist. All the methods will update
    the `play_list` items at the following two places:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这四种方法所做的只是调用其他四种方法来完成实际的任务，即向播放列表中添加或删除项目。所有这些方法都会在以下两个地方更新`play_list`项目：
- en: In the visible Listbox widget
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可见的 Listbox 小部件中
- en: In the backend data structure playlist maintained by the `Model` class
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在由`Model`类维护的后端数据结构播放列表中
- en: Let's define the four new methods.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义四种新的方法。
- en: Adding a single audio file
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加单个音频文件
- en: 'Adding a file involves asking for the location using Tkinter `filedialog` and
    updating the frontend and backend, as follows (see code `5.03`—`view.py`):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 添加文件涉及使用Tkinter `filedialog`请求位置并更新前端和后端，如下所示（参见代码`5.03`—`view.py`）：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Removing the selected files from a playlist
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从播放列表中移除所选文件
- en: 'Since the Listbox allows for multiple selections, we iterate through all the
    selected items, removing them from the frontend Listbox widget as well as from
    the model `play_list`, as follows (see code `5.03`—`view.py`):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表框允许进行多项选择，我们遍历所有选定的项目，将它们从前端列表框小部件以及模型`play_list`中移除，如下所示（参见代码`5.03`—`view.py`）：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that we reverse the tuple before removing items from the playlist because
    we want to start removing items from the end, as a removal causes a change in
    the index of playlist items. If we do not remove items from the end, we may end
    up removing the wrong items from the list, as its index gets modified in each
    iteration.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在从播放列表中删除项目之前会反转元组，因为我们希望从末尾开始删除项目，因为删除操作会导致播放列表项的索引发生变化。如果我们不从末尾删除项目，我们可能会最终从列表中删除错误的项目，因为它的索引在每次迭代中都会被修改。
- en: 'Since we have defined this method here, let''s add it as a command callback
    to the right-click delete menu, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这里已经定义了这种方法，让我们将其添加为右键删除菜单的命令回调，如下所示：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Adding all files from a directory
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加目录中的所有文件
- en: 'The following code uses the `os.walk()` method to recursively walk through
    all the files looking for  `.wav` and `.mp3` files, as follows (see code `5.03`—`view.py`):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用`os.walk()`方法递归遍历所有文件，查找`.wav`和`.mp3`文件，具体如下（参见代码`5.03`—`view.py`）：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Emptying the playlist
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清空播放列表
- en: 'The code is as follows (see code `5.03`—`view.py`):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下（见代码 `5.03`—`view.py`）：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This completes our third iteration. In this iteration, we saw how to work with
    the Listbox widget. In particular, we saw how to add items to the Listbox widget,
    select a particular item from the Listbox widget, and delete one or more items
    from it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的第三次迭代。在这个迭代中，我们看到了如何使用 Listbox 小部件。特别是，我们看到了如何向 Listbox 小部件添加项目，从 Listbox
    小部件中选择一个特定的项目，以及如何从中删除一个或多个项目。
- en: You now have a playlist where you can add and delete items using the four buttons at
    the bottom-left corner of the audio player.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在有一个播放列表，您可以使用音频播放器左下角的四个按钮添加和删除项目。
- en: Playing audio and adding audio controls
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放音频和添加音频控件
- en: 'In this iteration, we will code the features marked in the following screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次迭代中，我们将编写以下截图中所标记的功能的代码：
- en: '![](img/3bd65c1e-acc7-4c28-9967-c2fc5eefc226.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3bd65c1e-acc7-4c28-9967-c2fc5eefc226.png)'
- en: This includes the play/stop, pause/unpause, next track, previous track, fast
    forward, rewind, volume change, and mute/unmute features.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括播放/停止、暂停/恢复、下一曲、上一曲、快进、倒带、音量调整以及静音/取消静音等功能。
- en: Adding the play/stop function
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加播放/停止功能
- en: Now that we have a playlist and a `Player` class that can play audio, playing
    audio is simply about updating the current track index and calling the `play`
    method.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了播放列表和可以播放音频的`Player`类，播放音频的操作仅仅是更新当前曲目索引并调用`play`方法。
- en: 'Accordingly, let''s add an attribute, as follows (see code `5.04`—`view.py`):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，让我们添加一个属性，如下所示（参见代码`5.04`—`view.py`):'
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Furthermore, the **Play** button should act as a toggle between the `play` and
    `stop` functions. The Python `itertools` module provides the `cycle` method, which
    is a very convenient way to toggle between two or more values.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，**播放**按钮应作为在`播放`和`停止`功能之间的切换。Python 的 `itertools` 模块提供了 `cycle` 方法，这是一个在两个或多个值之间切换的非常方便的方式。
- en: 'Accordingly, import the `itertools` module and define a new attribute, as follows
    (see code `5.04`—`view.py`):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，导入`itertools`模块并定义一个新的属性，如下所示（参见代码`5.04`—`view.py`）：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, every time we call `next(toggle_play_stop)`, the value returned toggles between
    the `play` and `stop` strings.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次我们调用 `next(toggle_play_stop)`，返回的值会在 `play` 和 `stop` 字符串之间切换。
- en: Itertools is a very powerful standard library of Python that can emulate many
    **iterables** from a functional programming paradigm. An iterable in Python is
    an interface that implements the `next()` method. Every subsequent call to `next()`
    is **lazily evaluated**—thereby making them suitable for iterating over large
    sequences in the most efficient manner. The `cycle()` tool used here is an example
    of an iterator that can provide infinite sequences of alternating values without
    the need to define a large data structure.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Itertools 是 Python 中一个非常强大的标准库，它可以模拟许多来自函数式编程范式的 **可迭代对象**。在 Python 中，可迭代对象是一个实现了
    `next()` 方法的接口。每次对 `next()` 的后续调用都是 **惰性评估** 的——这使得它们以最有效的方式遍历大型序列变得合适。这里使用的 `cycle()`
    工具是一个可以提供无限交替值序列的迭代器的例子，而无需定义大型数据结构。
- en: 'The following is the documentation of the `itertools` module:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`itertools`模块的文档：
- en: '[https://docs.python.org/3/library/itertools.html](https://docs.python.org/3/library/itertools.html)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/itertools.html](https://docs.python.org/3/library/itertools.html)'
- en: 'Next, modify the `on_play_stop_button_clicked()` method so that it looks like
    this (see code `5.04`—`view.py`):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，修改`on_play_stop_button_clicked()`方法，使其看起来像这样（参见代码`5.04`—`view.py`):'
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding method simply toggles between calling the `start_play()` and `stop_play()`
    methods, which are defined as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法简单地切换在调用`start_play()`和`stop_play()`方法之间，这些方法定义如下：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding code calls the `play` and `stop` methods defined in the `Player` class.
    It also changes the button image from the *play* icon to the *stop* icon by using the
    `widget.config(image=new_image_icon)` method.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码调用了`Player`类中定义的`play`和`stop`方法。它还通过使用`widget.config(image=new_image_icon)`方法，将按钮图像从*播放*图标更改为*停止*图标。
- en: While we are handling the `play` function, let's modify the command callback
    so that a user can play a track simply by double-clicking on it. We have already
    defined a method named `on_play_list_double_clicked` earlier, which is currently
    empty.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理`play`函数时，让我们修改命令回调，以便用户只需通过双击即可播放曲目。我们之前已经定义了一个名为`on_play_list_double_clicked`的方法，目前它是空的。
- en: 'Simply modify it, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地按照以下方式修改它：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Adding the pause/unpause function
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加暂停/恢复功能
- en: 'Since we need a single button to toggle between pause and unpause, we will
    again use the `cycle()` method from the `itertools` module. Define an attribute,
    as follows (see code `5.04`—`view.py`):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要一个按钮来在暂停和继续之间切换，我们再次使用来自 `itertools` 模块的 `cycle()` 方法。定义一个属性，如下所示（参见代码
    `5.04`—`view.py`）：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, modify the command callback attached to the button, as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，修改按钮附加的命令回调，如下所示：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This takes care of the pause and unpause features of the program.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这处理了程序中的暂停和恢复功能。
- en: Adding the mute/unmute function
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加静音/取消静音功能
- en: 'This is similar to coding the pause/unpause feature. We need an attribute that can
    toggle between the `mute` and `unmute` strings. Accordingly, add an attribute, as
    follows (see code `5.04`—`view.py`):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这与编码暂停/恢复功能类似。我们需要一个属性，可以在“静音”和“取消静音”字符串之间切换。相应地，添加一个属性，如下所示（参见代码`5.04`—`view.py`）：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, modify the command callback to call the `mute` or `unmute` functions
    from the `player` class, change the button icon to the mute or unmute image, and
    shift the volume scale accordingly, as follows (see code `5.04`—`view.py`):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，修改命令回调以从`player`类调用`mute`或`unmute`函数，更改按钮图标为静音或取消静音的图片，并相应地调整音量刻度，如下所示（参见代码`5.04`—`view.py`）：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Fast forward/rewind function
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快进/倒退功能
- en: 'The codes for fast forward and rewind are the simplest. We have already defined
    the methods to handle this in the `Player` class. Now, it''s only a matter of
    connecting them to the concerned command callback, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 快进和快退的代码是最简单的。我们已经在`Player`类中定义了处理这些功能的方法。现在，只需要将它们连接到相应的命令回调函数，如下所示：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Adding the next track/previous track function
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加下一曲目/上一曲目功能
- en: 'While we had defined the code for fast forward and rewind in the `Player` class, we
    did not define the method related to next track and previous track there, because this
    can be handled by the existing `play` method. All that you need to do is simply increment
    or decrement the value of `current_track` and then call the `play` method. Accordingly,
    define two methods in the `View` class, as follows (see code `5.04`—`view.py`):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在`Player`类中定义了快进和快退的代码，但我们没有在那里定义与下一曲和上一曲相关的方法，因为这可以通过现有的`play`方法来处理。你所需要做的只是简单地增加或减少`current_track`的值，然后调用`play`方法。因此，在`View`类中定义两个方法，如下所示（参见代码`5.04`—`view.py`）：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, simply attach these two methods to the respective command callback, as
    follows (see code `5.04`—`view.py`):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，只需将这些两种方法分别附加到相应的命令回调中，如下所示（参见代码`5.04`—`view.py`）：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Adding the volume change function
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加体积变化函数
- en: We have already defined the `volume` method in the `Player` class. Now, all
    that you need to do is simply get the value of the Volume Scale widget and set
    the volume in the `Player` class.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`Player`类中定义了`volume`方法。现在，你所需要做的就是简单地获取音量比例小部件的值，并在`Player`类中设置音量。
- en: 'Also, ensure that in case the volume becomes zero, we change the volume button icon
    to the mute image (see code `5.04`—`view.py`):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，确保在音量变为零的情况下，我们将音量按钮图标更改为静音图像（参见代码`5.04`—`view.py`）：
- en: '[PRE39]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This concludes the iteration. The player is now functional enough to be called
    an audio player. Go ahead and add some music files to the player. Press the play
    button and enjoy the music! Try out other player controls that we defined in this
    iteration and they should work as expected.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了迭代。现在玩家已经足够功能化，可以被称为音频播放器。请继续向播放器添加一些音乐文件。按下播放按钮，享受音乐吧！尝试使用我们在这次迭代中定义的其他播放器控制功能，它们应该会按预期工作。
- en: Creating a seek bar
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个搜索栏
- en: Now, let's add a seek bar to the audio player. Tkinter offers the Scale widget
    that we used for the volume scale. The Scale widget could have functioned as a
    seek bar.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们给音频播放器添加一个进度条。Tkinter 提供了 Scale 小部件，我们之前用它来制作音量条。Scale 小部件原本也可以用作进度条。
- en: But we want something fancier. Moreover, the Scale widget would look different
    on different platforms. Instead, we want the seek bar to look uniform on all platforms.
    This is where we can create our own widget to meet the custom needs of the audio
    player.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们想要更华丽一些。此外，缩放小部件在不同平台上看起来也会不同。相反，我们希望滑块在所有平台上看起来都是统一的。这就是我们可以创建自己的小部件来满足音频播放器定制需求的地方。
- en: 'Let''s create our own Seekbar widget, as shown in the following screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建自己的 Seekbar 小部件，如图下所示：
- en: '![](img/fd25afb3-8f5a-4483-a745-9c000bb5bf70.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fd25afb3-8f5a-4483-a745-9c000bb5bf70.png)'
- en: The simplest way to create our own widget is to inherit one from an existing
    widget or the `Widget` class.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们自己的小部件最简单的方法是从现有的小部件或`Widget`类继承。
- en: When you look at the source code of Tkinter, you will find that all the widgets
    inherit from a class named `Widget`. The `Widget` class, in turn, inherits from
    another class called `BaseWidget`. The `BaseWidget` class contains the code that
    is used to handle a widget's `destroy()` method, but it is not aware of a geometry
    manager.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看 Tkinter 的源代码时，你会发现所有的小部件都继承自一个名为 `Widget` 的类。`Widget` 类反过来又继承自另一个名为 `BaseWidget`
    的类。`BaseWidget` 类包含了用于处理小部件的 `destroy()` 方法的代码，但它并不了解几何管理器。
- en: Therefore, if we want our custom widget to be aware of and use geometry managers such
    as `pack`, `grid`, or `place`, we need to inherit from the `Widget` class or from
    another Tkinter widget.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想让我们的自定义小部件能够了解并使用几何管理器，例如 `pack`、`grid` 或 `place`，我们需要从 `Widget` 类或另一个
    Tkinter 小部件继承。
- en: 'Let''s assume that we want to create a widget named `Wonderwidget`. We can
    do so simply by inheriting from the `Widget` class, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个名为 `Wonderwidget` 的部件。我们可以通过从 `Widget` 类继承来实现这一点，如下所示：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: These four lines of code create a widget named `Wonderwidget`, which can be positioned
    with geometry managers such as `pack`, `place`, or `grid`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这四行代码创建了一个名为 `Wonderwidget` 的部件，它可以使用 `pack`、`place` 或 `grid` 等几何管理器进行定位。
- en: However, for more practical use cases, we generally inherit from the existing
    Tkinter widgets, such as `Text`, `Button`, `Scale`, `Canvas`, and so on. In our
    case, we will create the `Seekbar` widget by inheriting from the `Canvas` class.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于更实用的用例，我们通常继承现有的 Tkinter 小部件，例如 `Text`、`Button`、`Scale`、`Canvas` 等等。在我们的情况下，我们将通过继承
    `Canvas` 类来创建 `Seekbar` 小部件。
- en: 'Create a new file called `seekbar.py` (see code `5.05.py`). Then, create a
    new class named `Seekbar` that inherits from the `Canvas` widget, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `seekbar.py` 的新文件（参见代码 `5.05.py`）。然后，创建一个名为 `Seekbar` 的新类，该类继承自 `Canvas`
    小部件，如下所示：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The preceding code calls the `__init__` method of the parent `Canvas` class
    to initialize the underlying canvas with all the canvas-related options that are passed
    as an argument.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码调用了父类 `Canvas` 的 `__init__` 方法，以所有作为参数传递的与画布相关的选项初始化底层画布。
- en: 'With as little code as that, let''s go back and modify the `create_top_display()`method
    in the `View` class to add this new widget, as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么少的代码，让我们回到`View`类中的`create_top_display()`方法，添加这个新小部件，具体如下：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, `SEEKBAR_WIDTH` is a constant that we defined as equal to 360 pixels in the
    program.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`SEEKBAR_WIDTH` 是一个我们定义为等于 360 像素的常量。
- en: If you now run `view.py`, you will see the `Seekbar` widget at its place.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行 `view.py`，你将看到 `Seekbar` 小部件在其位置上。
- en: The seek bar is not functional, as it does not move when the seek bar knob is
    clicked.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索栏无法使用，因为当点击搜索栏旋钮时，它不会移动。
- en: 'In order to make the seek bar slide along, we will bind the mouse buttons by defining
    a new method and calling it from the `__init__` method, as follows (see code `5.05`—`seekbar.py`):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使滑动条能够滑动，我们将通过定义一个新的方法并从`__init__`方法中调用它来绑定鼠标按钮，如下所示（参见代码`5.05`—`seekbar.py`）：
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We bind the entire canvas, the red rectangle, and the seek bar knob to a single method
    named `on_seekbar_clicked`, which can be defined as follows (see code `5.05`—`seekbar.py`):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将整个画布、红色矩形和滑动条旋钮绑定到单个名为 `on_seekbar_clicked` 的方法上，该方法可以定义为如下（参见代码 `5.05`—`seekbar.py`）：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The preceding method simply calls another method named `slide_to_position`,
     which is responsible for changing the position of the knob and the size of the
    red rectangle (see code `5.05`—`seekbar.py`):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法简单地调用了另一个名为 `slide_to_position` 的方法，该方法负责改变旋钮的位置和红色矩形的大小（参见代码 `5.05`—`seekbar.py`）：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The preceding code slides the knob to the new position. More importantly, the
    last line creates a custom event named `SeekbarPositionChanged`. This event will
    let any code that uses this custom widget handle the event appropriately.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将旋钮滑动到新位置。更重要的是，最后一行创建了一个名为 `SeekbarPositionChanged` 的自定义事件。这个事件将允许任何使用此自定义小部件的代码适当地处理该事件。
- en: The second argument, `x=new_position`, adds the value of `x` to `event.x`, making
    it available to the event handler.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数 `x=new_position` 将 `x` 的值添加到 `event.x` 中，使其对事件处理器可用。
- en: So far, we have only been handling events. Tkinter also lets us create our own
    events, which are called **virtual events**.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只处理过事件。Tkinter 还允许我们创建自己的事件，这些事件被称为 **虚拟事件**。
- en: We can specify any name for the event by enclosing the name in double pairs
    of `<<...>>`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将名称用双对`<<...>>`括起来来指定任何事件名称。
- en: In the preceding code, we generated a virtual event named `<<SeekbarPositionChanged>>`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们生成了一个名为`<<SeekbarPositionChanged>>`的虚拟事件。
- en: 'We then bound it to the appropriate event handler in the `View` class, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后将其绑定到`View`类中的相应事件处理器，具体如下：
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'That''s all that there is to the custom `Seekbar` widget. We can write a small
    test in `seekbar.py` that will check whether the `Seekbar` widget works as expected:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是自定义`Seekbar`小部件的全部内容。我们可以在`seekbar.py`中编写一个小测试，以检查`Seekbar`小部件是否按预期工作：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Go ahead and run the `5.05`—`seekbar.py` program; it should produce a seek bar. The
    seek bar should slide when you drag the seek bar knob or click at various places
    on the canvas.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行 `5.05`—`seekbar.py` 程序；它应该会生成一个进度条。进度条应该在您拖动进度条旋钮或在画布上的各个位置点击时滑动。
- en: This concludes the iteration. We will make the audio player's seek bar functional
    in the next iteration.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次迭代到此结束。我们将在下一次迭代中使音频播放器的定位条功能化。
- en: One-time updates during audio playback
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频播放期间的单一更新
- en: 'The audio program must update some information as soon as an audio track starts playing.
    Broadly speaking, there are two kinds of updates that the program needs to monitor
    and update:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 音频程序必须在音频轨道开始播放时立即更新一些信息。总的来说，程序需要监控和更新的更新类型有两种：
- en: '**One-time updates**: Examples of this include the name of the track and the total
    length of the track.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一次性更新**：此类例子包括轨道名称和轨道总长度。'
- en: '**Continuous updates**: Examples of this include the position of the seek bar knob
    and the elapsed play duration. We also need to check continuously whether a track
    has ended either to play the next track, play the current track again, or stop
    playing, depending on the loop choice made by the user.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续更新**：此类例子包括寻道按钮的位置和播放进度。我们还需要持续检查是否已播放完一首曲目，以便根据用户选择的循环选项播放下一首曲目、重新播放当前曲目或停止播放。'
- en: 'These two kinds of updates will affect sections of the audio player, as shown
    in the following screenshot:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种更新将影响音频播放器的部分区域，如下所示截图：
- en: '![](img/50ad1983-d89e-4f73-a016-a2b2eec1858e.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/50ad1983-d89e-4f73-a016-a2b2eec1858e.png)'
- en: Let's start with the one-time updates, as they are relatively simple to implement.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一次性更新开始，因为它们相对容易实现。
- en: 'Since these updates must occur when the playback starts, let''s define a method named
    `manage_one_time_updates()` and call it from within the `start_play()` method
    of the `View` class, as follows (see code `5.06`—`view.py`):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些更新必须在播放开始时发生，让我们定义一个名为 `manage_one_time_updates()` 的方法，并在 `View` 类的 `start_play()`
    方法中调用它，如下所示（参见代码 `5.06`—`view.py`）：
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, define all the methods called from within the preceding method, as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，按照以下方式定义在前面方法中调用的所有方法：
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: These two methods simply find out the track name and track duration and update the
    related canvas text by using a call to `canvas.itemconfig`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法简单地通过调用 `canvas.itemconfig` 来找出轨道名称和轨道时长，并更新相关的画布文本。
- en: 'Just like we use `config` to change the value of widget-related options, the
    `Canvas` widget uses `itemconfig` to change the options for individual items within
    the canvas.  The format for `itemconfig` is as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们使用 `config` 来更改与小部件相关的选项一样，`Canvas` 小部件使用 `itemconfig` 来更改画布内单个项目的选项。`itemconfig`
    的格式如下：
- en: '[PRE50]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Let's define two helper methods in a new file named `helpers.py` and import the
    methods in the view namespace. The two methods are `truncate_text` and `get_time_in_minutes_seconds`.
    The code for this can be found in the `5.06`—`helpers.py` file.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在名为 `helpers.py` 的新文件中定义两个辅助方法，并在视图命名空间中导入这些方法。这两个方法分别是 `truncate_text` 和
    `get_time_in_minutes_seconds`。相关代码可以在 `5.06`—`helpers.py` 文件中找到。
- en: 'That takes care of one-time updates. Now, when you run `5.06`—`view.py` and
    play some audio file, the player should update the track name, and the total track
    duration in the top console, as shown in the following screenshot:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理了一次性更新。现在，当你运行 `5.06`—`view.py` 并播放一些音频文件时，播放器应该更新轨道名称，并在顶部控制台中显示总轨道时长，如下面的截图所示：
- en: '![](img/1679bd68-61e9-407d-8b0d-5fcfcb822d49.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1679bd68-61e9-407d-8b0d-5fcfcb822d49.png)'
- en: We will take care of periodic updates in the next iteration.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一次迭代中负责定期更新。
- en: Managing continuous updates
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理持续更新
- en: 'Next, we will update the position of the seek bar knob and the elapsed play
    duration, as shown in the following screenshot:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新寻道旋钮的位置和已播放的持续时间，如下所示截图：
- en: '![](img/afb5eac3-dbaf-4742-ba55-ca90aa9d129a.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/afb5eac3-dbaf-4742-ba55-ca90aa9d129a.png)'
- en: This is nothing but a simple form of Tkinter-based animation.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是基于Tkinter的简单动画形式。
- en: 'The most common pattern of animating with Tkinter involves drawing a single frame
    and then calling the same method using the after method of Tkinter, as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Tkinter 动画最常见的方式是先绘制一个单独的框架，然后通过 Tkinter 的 after 方法调用相同的方法，具体如下：
- en: '[PRE51]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Take a note of the `self.after` method, which calls the `animate` method in
    a loop. Once called, this function will keep updating frames once every `500` milliseconds.
    You can also add some conditions to break out of the animation loop. This is generally
    how all animations are handled in Tkinter. We will use this technique over and
    over again in several upcoming examples.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 记录一下`self.after`方法，它会在循环中调用`animate`方法。一旦被调用，这个函数将每隔`500`毫秒更新一次帧。你还可以添加一些条件来跳出动画循环。在Tkinter中，所有动画都是这样处理的。我们将在接下来的几个示例中反复使用这项技术。
- en: Now that we know how to manage animations in Tkinter, let's use the pattern to
    define a method that takes care of these periodic updates.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何在 Tkinter 中管理动画，让我们使用这个模式来定义一个处理这些周期性更新的方法。
- en: 'Define a method named `manage_periodic_updates_during_play`, which calls itself
    every 1 second to update the timer and the seek bar, as follows (see code `5.07`—`view.py`):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个名为 `manage_periodic_updates_during_play` 的方法，该方法每秒调用自己一次以更新计时器和进度条，如下所示（参见代码
    `5.07`—`view.py`）：
- en: '[PRE52]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Then, define two methods named `update_clock` and `update_seek_bar`, which update
    the sections highlighted in the preceding screenshot.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义两个名为 `update_clock` 和 `update_seek_bar` 的方法，它们用于更新前一个截图中所突出显示的部分。
- en: 'The `update_clock` method gets the elapsed duration in seconds from the `Player` class,
    converts it into minutes and seconds, and updates the canvas text using `canvas.itemconfig`,
    as follows (see code `5.07`—`view.py`):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`update_clock` 方法从 `Player` 类获取已过时间（以秒为单位），将其转换为分钟和秒，并使用 `canvas.itemconfig`
    更新画布文本，具体如下（参见代码 `5.07`—`view.py`）：'
- en: '[PRE53]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You may recall that we had previously defined a `slide_to_position` method
    in the `Seekbar` class. The `update_seek_bar` method simply calculates the proportionate position
    of the seek bar and then calls the `slide_to_position` method to slide the knob
    of the seekbar, as follows (see code `5.07`—`view.py`):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，我们之前在`Seekbar`类中定义了一个`slide_to_position`方法。`update_seek_bar`方法只是简单地计算滑块的相对位置，然后调用`slide_to_position`方法来滑动滑块的旋钮，如下所示（参见代码`5.07`—`view.py`）：
- en: '[PRE54]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now, if you run `5.07`–`view.py`, add an audio file, and play it, the elapsed
    duration should be updated continuously in the top display. The seek bar should
    also move forward as the play progresses.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行 `5.07`–`view.py`，添加一个音频文件并播放它，顶部显示中的已过时长应该会持续更新。随着播放的进行，进度条也应该向前移动。
- en: 'That''s great, but there is still one small detail missing. We want that when
    a user clicks somewhere on the seek bar, the playing audio seeks the new position.
    The code for seeking a new position is simple (see code `5.07`—`view.py`):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '那很好，但还有一个小的细节没有完善。我们希望当用户在进度条上点击某个位置时，播放的音频能够跳转到新的位置。跳转到新位置的代码很简单（见代码 `5.07`—`view.py`):'
- en: '[PRE55]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'However, the preceding method needs to be called whenever the seek bar position is
    changed. Let''s do this by adding a binding to the virtual event from within `5.07`—`view.py`,
    as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前述方法需要在滑动条位置改变时被调用。我们可以通过在`5.07`—`view.py`中添加对虚拟事件的绑定来实现这一点，如下所示：
- en: '[PRE56]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now, when you run  `5.07`—`view.py`, play an audio file and click on the seek
    bar; the audio should start playing from the new position.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行 `5.07`—`view.py`，播放音频文件并点击进度条；音频应该从新位置开始播放。
- en: This concludes the iteration. We will look at how to loop over tracks in the next
    iteration.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了迭代。我们将在下一次迭代中查看如何遍历轨道。
- en: Looping over tracks
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历轨道
- en: 'Let''s add the feature that allows users to loop over tracks. We have already
    defined radio buttons to allow three choices, as shown in the following screenshot:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个允许用户循环播放歌曲的功能。我们已经定义了单选按钮来允许三种选择，如下面的截图所示：
- en: '![](img/49e96b01-b2c0-4c28-af95-f6baf379556e.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/49e96b01-b2c0-4c28-af95-f6baf379556e.png)'
- en: 'In essence, the player should provide a choice from the following three options:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，玩家应从以下三个选项中选择：
- en: 'No Loop: Play a track and end there'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无循环：播放一首曲目并结束
- en: 'Loop Current: Play a single track repeatedly'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环播放：重复播放单个曲目
- en: 'Loop All: Looping through the entire playlist, one after another'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环全部：依次循环整个播放列表
- en: The decision to follow one of these three options needs to be taken immediately
    after a particular track ends playing. The best place to judge whether a track
    has come to its end is from within the periodic updates loop that we created earlier.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定轨道播放结束后，需要立即做出选择其中一种选项的决定。判断一个轨道是否已经结束的最佳位置，是在我们之前创建的周期性更新循环中。
- en: 'Therefore, modify the `manage_periodic_updates_during_play()` method to add the
    following two lines of highlighted code (see code `5.08`—`view.py`):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，修改`manage_periodic_updates_during_play()`方法，添加以下两条高亮代码（见代码`5.08`—`view.py`）：
- en: '[PRE57]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This in effect means that the looping decision is checked only when the currently playing
    track ends. Then, define the `not_to_loop()` method, as follows (see code `5.09`—`view.py`):'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上意味着只有在当前播放的曲目结束时才会检查循环决策。然后，定义`not_to_loop()`方法，如下所示（参见代码`5.09`—`view.py`）：
- en: '[PRE58]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The code first checks the value of the selected radio button and, based on
    the selected choice, makes the looping choice:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先检查所选单选按钮的值，并根据所选选项，做出循环选择：
- en: If the selected loop value is `1` (No Loop), it does nothing and returns `True`, breaking
    out of the continuous update loop.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果选择的循环值为 `1`（无循环），则不执行任何操作并返回 `True`，从而跳出连续更新循环。
- en: If the selected loop value is `2` (loop over the current song), it again calls
    the `start_play` method and returns `False`. Thus, we do not break out of the update
    loop.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果选定的循环值为 `2`（循环当前歌曲），它将再次调用 `start_play` 方法并返回 `False`。因此，我们不会跳出更新循环。
- en: If the loop value is `3` (Loop All), it calls the `play_next_track` method and
    returns `True`. Thus, we break out of the previous update loop.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果循环值是 `3`（循环全部），它将调用 `play_next_track` 方法并返回 `True`。因此，我们跳出之前的更新循环。
- en: The audio player can now loop over the playlist based on the looping preference
    set by the user.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 音频播放器现在可以根据用户设置的循环偏好来循环播放播放列表。
- en: Let's conclude this iteration by overriding the close button so that the audio
    player properly deletes the player object when the user decides to close the player
    while it is playing.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过重写关闭按钮来结束这次迭代，这样当用户在播放时决定关闭播放器时，音频播放器可以正确地删除播放器对象。
- en: 'To override the destroy method, first add a protocol override command to the `View
    __init__` method, as follows (see code `5.08`—`view.py`):'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 要重写销毁方法，首先在`View __init__`方法中添加一个协议覆盖命令，如下所示（参见代码`5.08`—`view.py`）：
- en: '[PRE59]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, define the `close_player` method, as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，定义`close_player`方法，如下所示：
- en: '[PRE60]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This concludes the iteration. We coded the logic required to loop over tracks
    and then overrode the close button to ensure that a playing track is stopped before
    we exit the player.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了迭代。我们编写了循环遍历轨道所需的逻辑，然后覆盖了关闭按钮，以确保在我们退出播放器之前，正在播放的轨道被停止。
- en: Adding a tooltip
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加工具提示
- en: In this final iteration, we will add a tooltip named the **Balloon widget**
    to all the buttons in our player.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最终迭代中，我们将为我们的播放器中的所有按钮添加一个名为**气球小部件**的工具提示。
- en: 'A tooltip is a small **popup** that shows up when you hover your mouse over
    the Bound widget (buttons, in our case). A typical tooltip for the application
    will look as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 工具提示是一个当你在“边界小部件”（在我们的例子中是按钮）上悬停鼠标时出现的**弹出窗口**。应用程序的典型工具提示将如下所示：
- en: '![](img/a2d47813-10e2-47b2-8351-f8fa620f0dbf.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a2d47813-10e2-47b2-8351-f8fa620f0dbf.png)'
- en: Although core Tkinter has many useful widgets, it is far from complete. For
    us, the tooltip or Balloon widget is not provided as a core Tkinter widget. Therefore,
    we look for these widgets in what are called **Tkinter extensions**.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Tkinter的核心库拥有许多有用的控件，但它远非完整。对我们来说，工具提示或气球控件并不是作为Tkinter的核心控件提供的。因此，我们在所谓的**Tkinter扩展**中寻找这些控件。
- en: These extensions are nothing but a collection of extended Tkinter widgets, just
    like the custom seek bar that we created.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这些扩展不过是扩展的 Tkinter 小部件集合，就像我们创建的自定义进度条一样。
- en: There are literally hundreds of Tkinter extensions. In fact, we just wrote our
    own Tkinter extension in this chapter.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Tkinter扩展有成百上千种。事实上，我们就在本章中编写了自己的Tkinter扩展。
- en: 'However, the following are some of the popular Tkinter extensions:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以下是一些流行的 Tkinter 扩展：
- en: '**Pmw**: ([http://pmw.sourceforge.net](http://pmw.sourceforge.net))'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pmw**: ([http://pmw.sourceforge.net](http://pmw.sourceforge.net))'
- en: '**Tix**: ([http://wiki.Python.org/moin/Tix](http://wiki.Python.org/moin/Tix))'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tix**: ([http://wiki.Python.org/moin/Tix](http://wiki.Python.org/moin/Tix))'
- en: '**TkZinc**: ([http://wiki.Python.org/moin/TkZinc](http://wiki.Python.org/moin/TkZinc))'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TkZinc**: ([http://wiki.Python.org/moin/TkZinc](http://wiki.Python.org/moin/TkZinc))'
- en: '**Widget Construction Kit (WCK)**: ([http://effbot.org/zone/wck.htm](http://effbot.org/zone/wck.htm))'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小部件构建工具包 (WCK)**: ([http://effbot.org/zone/wck.htm](http://effbot.org/zone/wck.htm))'
- en: Pmw list of extensions
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pmw 扩展列表
- en: Talking about Pmw, here is a quick list of widget extensions and dialogs from the
    package.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 谈及Pmw，以下是从该包中快速列出的一些小部件扩展和对话框。
- en: Widgets
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小部件
- en: 'The following table shows a list of widget extensions:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了一系列小部件扩展列表：
- en: '| ButtonBox | ComboBox | Counter | EntryField |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 按钮框 | 组合框 | 计数器 | 输入字段 |'
- en: '| Group | HistoryText | LabeledWidget | MainMenuBar |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 群组 | 历史文本 | 标记小部件 | 主菜单栏 |'
- en: '| MenuBar | MessageBar | NoteBook | OptionMenu |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 菜单栏 | 消息栏 | 笔记本 | 选项菜单 |'
- en: '| PanedWidget | RadioSelect | ScrolledCanvas | ScrolledField |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 分割小部件 | 单选选择框 | 滚动画布 | 滚动字段 |'
- en: '| ScrolledFrame | ScrolledListBox | ScrolledText | TimeCounter |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 滚动框架 | 滚动列表框 | 滚动文本 | 时间计数器 |'
- en: Dialogs
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对话
- en: 'The following table shows a list of widget dialogs:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了一组小部件对话框列表：
- en: '| AboutDialog | ComboBoxDialog | CounterDialog | Dialog |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| 关于对话框 | 组合框对话框 | 计数器对话框 | 对话框 |'
- en: '| MessageDialog | PromptDialog | SelectionDialog | TextDialog |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| 消息对话框 | 提示对话框 | 选择对话框 | 文本对话框 |'
- en: Miscellaneous
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 杂项
- en: 'The following is a list of miscellaneous widgets offered by Pmw:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由 Pmw 提供的杂项小部件列表：
- en: '`Balloon`'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`气球`'
- en: '`Blt` (used for graph generation)'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Blt`（用于图形生成）'
- en: The `Color Module` functions
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`颜色模块`功能'
- en: Pmw offers a large list of extended widgets. For a demonstration of all these
    widgets, browse the Pmw package that you installed earlier and look for a directory
    named `demo`. Within `demo`, look for a file named `All.py`, which demonstrates
    all of these Pmw extensions with a sample working code.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Pmw 提供了大量扩展小部件。要演示所有这些小部件，请浏览您之前安装的 Pmw 包，并寻找名为 `demo` 的目录。在 `demo` 目录中，寻找一个名为
    `All.py` 的文件，该文件使用示例代码演示了所有这些 Pmw 扩展。
- en: 'Pmw provides the `Balloon` widget implementation, which will be used in the current
    example. Begin by importing `Pmw` into the namespace, as follows (see code `5.09`—`view.py`):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Pmw 提供了 `Balloon` 小部件的实现，该实现将在当前示例中使用。首先，将 `Pmw` 导入命名空间，如下所示（参见代码 `5.09`—`view.py`）：
- en: '[PRE61]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, instantiate the `Balloon` widget within the `create_gui` method, as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`create_gui`方法中实例化`Balloon`小部件，如下所示：
- en: '[PRE62]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, bind the `Balloon` widget to each button widget in the audio player.
    We will not reproduce the code for each button. However, the format is as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将`气球`小部件绑定到音频播放器中的每个按钮小部件。我们不会为每个按钮重复代码。然而，格式如下：
- en: '[PRE63]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Thus, the Add File button will have a balloon binding, as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，添加文件按钮将具有气球绑定，如下所示：
- en: '[PRE64]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Add similar code for each button in `5.09`—`view.py`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为`5.09`—`view.py`中的每个按钮添加类似的代码。
- en: This completes the iteration. We added Balloon tooltips to the audio player's
    buttons using the Pmw Tkinter extension. Most importantly, we got to know about
    the Tkinter extensions and when to use them.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了迭代。我们使用 Pmw Tkinter 扩展为音频播放器的按钮添加了气球提示。最重要的是，我们了解了 Tkinter 扩展及其使用时机。
- en: When you need a widget implementation that is not available as a core widget,
    try looking for its implementations in Pmw or TIX. If you don't find one that
    suits your needs, search the internet for some other Tkinter extension. If you
    still don't find your desired implementation, it's time to build one.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要一个作为核心小部件不可用的 widget 实现时，尝试在 Pmw 或 TIX 中寻找其实现。如果你找不到一个符合你需求的实现，请在互联网上搜索其他
    Tkinter 扩展。如果你仍然找不到你想要的实现，那么是时候自己构建一个了。
- en: This brings us to the end of this chapter. The audio player is ready!
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了本章的内容。音频播放器已准备就绪！
- en: Summary
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Let's recap the things that we touched upon in this chapter.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下本章中我们提到的事情。
- en: In addition to reinforcing a lot of GUI programming techniques that we discussed
    in the previous chapters, you learned how to work with more widgets such as Listbox, ttk
    Scale, and Radiobutton. We looked deeper into the features of the Canvas widget.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 除了加强我们在前几章讨论的许多GUI编程技术之外，你还学会了如何使用更多的小部件，例如Listbox、ttk Scale和Radiobutton。我们还深入探讨了Canvas小部件的功能。
- en: Most importantly, we learned how to create our custom widgets, thereby extending Tkinter's
    core widgets. This is a really powerful technique that can be applied to build
    all sorts of features into programs.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我们学会了如何创建自定义小部件，从而扩展了Tkinter的核心小部件。这是一个非常强大的技术，可以应用于将各种功能构建到程序中。
- en: We saw how to generate and handle virtual events.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何生成和处理虚拟事件。
- en: We saw the most common technique for applying animation in Tkinter programs.
    This technique can also be used to build all sorts of interesting games.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了在 Tkinter 程序中应用动画的最常见技术。这种技术也可以用来构建各种有趣的游戏。
- en: Finally, we got to know about some common Tkinter extensions, such as Pmw, WCK,
    TIX, and so on.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解了一些常见的 Tkinter 扩展，例如 Pmw、WCK、TIX 等等。
- en: Now, let's lose ourselves in some music!
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们迷失在一些音乐中！
- en: QA section
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QA部分
- en: Before you proceed to the next chapter, make sure you can answer these questions
    to your
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续阅读下一章之前，请确保你能回答这些问题
- en: 'satisfaction:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 满意度：
- en: How can we create our own custom widgets in Tkinter?
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何在Tkinter中创建自己的自定义小部件？
- en: How do you create animations with Tkinter?
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何使用 Tkinter 创建动画？
- en: What are virtual events? When and how do we use them?
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是虚拟活动？何时以及如何使用它们？
- en: What are Tkinter extensions? What are the most popular ones?
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tkinter扩展是什么？哪些是最受欢迎的？
- en: Further reading
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Look at the documentation for popular Tkinter extensions such as Pmw, Tix, WCK,
    and others.  Take a note of the commonly available widgets in these extensions.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Tkinter流行扩展（如Pmw、Tix、WCK等）的文档。注意记录这些扩展中常见的控件。
