- en: Building an Audio Player
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个音频播放器
- en: Let's build an audio player! Our application should have the features offered
    by typical audio players, such as play, pause, fast forward, rewind, next, mute,
    volume scale, time seek, and more. It should let listeners easily access media
    files or a media library on their local drive. The audio player should do all
    this and more. Let's begin!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个音频播放器！我们的应用程序应该具备典型音频播放器提供的功能，例如播放、暂停、快进、快退、下一曲、静音、音量调节、时间搜索等。它应该让听众能够轻松访问他们本地驱动器上的媒体文件或媒体库。音频播放器应该做到所有这些，并且更多。让我们开始吧！
- en: 'The following are the key objectives of this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为本章节的关键目标：
- en: Exploring Tkinter widgets, namely Slider, Listbox, Radiobutton, and Canvas
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Tkinter 小部件，即滑块（Slider）、列表框（Listbox）、单选按钮（Radiobutton）和画布（Canvas）
- en: Creating new widgets in Tkinter by extending the existing widgets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过扩展现有小部件在 Tkinter 中创建新小部件
- en: Understanding virtual events and their usage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解虚拟活动及其用法
- en: Learning the most common coding pattern used in Tkinter-based animations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习在Tkinter动画中使用的最常见编码模式
- en: Learning some common Tkinter extensions such as Pmw, WCK, and TIX
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习一些常见的 Tkinter 扩展，如 Pmw、WCK 和 TIX
- en: An overview of the chapter
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节概述
- en: Let's call our audio player *Achtung Baby*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们的音频播放器称为*Achtung Baby*。
- en: The audio player will be capable of playing audio files in **AU**, **MP2**,
    **MP3**, **OGG/Vorbis**, **WAV**, and **WMA** formats. It will have all the controls
    that you would expect of a small media player.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 音频播放器将能够播放**AU**、**MP2**、**MP3**、**OGG/Vorbis**、**WAV**和**WMA**格式的音频文件。它将具备您期望的小型媒体播放器所拥有的所有控制功能。
- en: We will use cross-platform modules to write the code. This will ensure that
    the player can play audio files on Windows, macOS X, and Linux platforms.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用跨平台模块来编写代码。这将确保玩家可以在Windows、macOS X和Linux平台上播放音频文件。
- en: 'On completion, the audio player will look as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，音频播放器将呈现如下：
- en: '![](img/7c22414e-0c82-4cbc-87c0-faafb41f3d77.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7c22414e-0c82-4cbc-87c0-faafb41f3d77.png)'
- en: Perhaps the most important takeaway from this chapter is to learn how to create your
    own widgets in Tkinter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最重要的收获可能是学习如何创建自己的Tkinter小部件。
- en: The seek bar in the preceding screenshot is an example of a custom-made widget
    that was not natively available in Tkinter, but was handcrafted for this particular
    use case.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一张截图中的搜索栏是一个自定义小部件的例子，这个小部件在Tkinter中不是原生可用的，但为了这个特定的用例而手工制作。
- en: After you learn how to create custom widgets, what you can then create will
    only be limited by what you can imagine.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在你学会了如何创建自定义小部件之后，你能够创造的内容将只受限于你的想象力。
- en: External library requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部库需求
- en: 'In addition to the several built-in modules of Python, we will use the following
    two external modules in this project:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Python的几个内置模块外，我们将在本项目中使用以下两个外部模块：
- en: The `pyglet` library for audio manipulation
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于音频处理的 `pyglet` 库
- en: '**Pmw** (short for **Python megawidget**) for the widgets that are not available in
    core Tkinter'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Pmw**（代表**Python megawidget**）用于核心Tkinter中不可用的控件'
- en: The pyglet module
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pyglet 模块
- en: Pyglet is a cross-platform windowing and multimedia library for Python. It can
    be downloaded at [https://bitbucket.org/pyglet/pyglet/wiki/Download](https://bitbucket.org/pyglet/pyglet/wiki/Download).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Pyglet 是一个跨平台的 Python 窗口和多媒体库。您可以从 [https://bitbucket.org/pyglet/pyglet/wiki/Download](https://bitbucket.org/pyglet/pyglet/wiki/Download)
    下载。
- en: 'Pyglet can be installed using the pip installer, which is the default package
    manager for Python  by using the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Pyglet 可以使用 pip 安装程序进行安装，这是 Python 的默认包管理器，通过以下命令进行安装：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Windows users can also download and install binary packages for `pyglet` from [http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyglet](http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyglet).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Windows用户也可以从[http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyglet](http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyglet)下载并安装`pyglet`的二进制包。
- en: Pyglet needs another module called `AVbin` to support playback of file formats
    such as MP2 and MP3\. `AVbin` can be obtained for Windows, Linux, and macOS from the
    download section at [http://avbin.github.io](http://avbin.github.io).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Pyglet 需要另一个名为 `AVbin` 的模块来支持播放 MP2 和 MP3 等文件格式。`AVbin` 可以从 [http://avbin.github.io](http://avbin.github.io)
    的下载部分获取。
- en: Pmw Tkinter extension
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pmw Tkinter 扩展
- en: 'We will use the Pmw Tkinter extension to code some widget features that are
    not available in core Tkinter. Pmw can be installed by using the pip command-line
    tool, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Pmw Tkinter 扩展来编写一些在核心 Tkinter 中不可用的小部件功能。Pmw 可以通过使用 pip 命令行工具进行安装，如下所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Pmw can also be installed from the source package for all the platforms. The package
    can be downloaded from [http://sourceforge.net/projects/pmw/](http://sourceforge.net/projects/pmw/).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Pmw也可以从所有平台的源代码包中安装。该包可以从[http://sourceforge.net/projects/pmw/](http://sourceforge.net/projects/pmw/)下载。
- en: 'After installing `pyglet`, `AVbin`, and Pmw, execute the following command
    from the Python shell:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完 `pyglet`、`AVbin` 和 Pmw 后，从 Python 壳中执行以下命令：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the commands execute without an error message and the version of `pyglet`
    and Pmw are the same as what's shown in the preceding code, you are ready to code your
    audio player.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令执行没有错误信息，并且`pyglet`和Pmw的版本与前面代码中显示的相同，那么你就可以开始编写你的音频播放器了。
- en: Program structure and broadview skeleton
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序结构和宏观骨架
- en: Our first goal is to build the broad modular structure for the program. As usual, we
    will keep the data structure, audio-related logic, and the presentation logic
    in three separate files. Therefore, we will create three separate files named
    `model.py`, `player.py`, and `view.py` (see `code 5.01`).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要目标是构建程序的广泛模块化结构。像往常一样，我们将数据结构、音频相关逻辑和展示逻辑分别保存在三个独立的文件中。因此，我们将创建三个独立的文件，分别命名为`model.py`、`player.py`和`view.py`（参见`代码
    5.01`）。
- en: 'Let''s create an empty `Model` class and an empty `Player` class in their respective
    files. The following is the code for `5.01`—`model.py`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在各自的文件中创建一个空的`Model`类和一个空的`Player`类。以下是为`5.01`版本的`model.py`文件提供的代码：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here''s the code for `5.01`—`player.py`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`5.01`版本的`player.py`代码：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, let's create the `View` class. We will leave the `Model` and `Player`
    classes empty for now. However, we will complete this iteration by coding the
    majority of the view elements for the player.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建`View`类。现在我们将`Model`和`Player`类留空。然而，我们将通过编写大多数玩家视图元素来完成这个迭代。
- en: 'Let''s begin by importing the required modules in the `View` class, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`View`类中导入所需的模块开始，如下所示：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Also, import the blank `Model` and `Player` classes in the `View` namespace
    (see code `5.01`—`view.py`):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`View`命名空间中导入空的`Model`和`Player`类（参见代码`5.01`—`view.py`）：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, since we do not want to mix the logic with its representation, we do
    not import `View` in the `Model` class. In short, the `Model` class knows nothing
    about how its data will be presented to the frontend user.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我们不希望将逻辑与其表示混合在一起，我们在`Model`类中不导入`View`。简而言之，`Model`类对如何将其数据呈现给前端用户一无所知。
- en: Note that we are not using the `Controller` class in this program. We saw how
    to use controllers in [Chapter 4](7e561bee-a102-437c-bfdf-018694145027.xhtml),
    *Game of Chess*. While controllers are a great way to avoid direct coupling between
    the `Model` and `View` classes, they can be an overkill for small programs like
    this one.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个程序中我们没有使用`Controller`类。我们在[第4章](7e561bee-a102-437c-bfdf-018694145027.xhtml)，“棋盘游戏”中看到了如何使用控制器。虽然控制器是避免`Model`类和`View`类之间直接耦合的好方法，但对于像这样的小程序来说，它们可能有些过度。
- en: 'Now, let''s create the top-level window. Also, we''ll create instances of the
    `Model` and `Player` classes and pass them as arguments to the `View` class, as
    follows (see code `5.01`—`view.py`):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建顶层窗口。同时，我们还将创建`Model`和`Player`类的实例，并将它们作为参数传递给`View`类，如下所示（参见代码`5.01`—`view.py`）：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that the boilerplate code is written, let''s start coding the actual `View`
    class, as follows (see code `5.01`—`view.py`):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '现在模板代码已经编写完成，让我们开始编写实际的`View`类，如下所示（参见代码`5.01`—`view.py`):'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `__init__` method should look familiar to you by now. The final line of
    the `__init__` calls a method called `create_gui`, which is responsible for the
    creation of the entire GUI. The `create_gui` method in turn simply calls five
    different methods, where each method is responsible for the creation of different
    sections of the GUI.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__` 方法现在应该对你来说已经很熟悉了。`__init__` 方法的最后一行调用了一个名为 `create_gui` 的方法，该方法负责创建整个
    GUI。`create_gui` 方法反过来又简单地调用了五个不同的方法，其中每个方法负责创建 GUI 的不同部分。'
- en: We also made the root window nonresizable by adding `root.resizable(width=False,
    height=False)` to the code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在代码中添加 `root.resizable(width=False, height=False)` 使根窗口不可调整大小。
- en: 'We will not reproduce the entire code that creates the GUI, since we have coded
    similar widgets in the past. But all of these five methods, when combined, create
    the GUI shown in the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会重新展示创建GUI的完整代码，因为我们之前已经编写过类似的控件。但是，这五种方法结合在一起，就能创建出以下截图所示的GUI：
- en: '![](img/9365cfd3-e4a3-42b4-b66f-e96abf36d72c.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9365cfd3-e4a3-42b4-b66f-e96abf36d72c.png)'
- en: For the sake of separation, we have also marked the four sections differently
    in the preceding screenshot. The fifth method creates the right-click context
    menu and is not visible here.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分，我们在前面的截图中也用不同的方式标记了这四个部分。第五种方法创建的是右键点击上下文菜单，这里没有显示。
- en: 'The code used to create all of these GUI elements should be familiar to you
    by now. However, note a few things about the code (see code `5.01`—`view.py`):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建所有这些图形用户界面元素的代码你现在应该已经熟悉了。然而，请注意以下几点关于代码的内容（参见代码 `5.01`—`view.py`）：
- en: All the images used in the preceding code have been stored in a separate folder
    named `icons`.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的代码中使用的所有图片都已存储在一个名为 `icons` 的单独文件夹中。
- en: We have used the grid geometry manager to place all the elements on the top-level
    window.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经使用网格几何管理器将所有元素放置在顶层窗口上。
- en: The Top Display section creates a Canvas widget and places an overlay image
    using the `canvas.create_image()` method. The currently playing text and the timer
    displayed in the top display have been created by using the `canvas.create_text()`
    method. The coordinates used to place these elements have been decided on a trial-and-error
    basis. As a reminder, the canvas coordinates are measured from the top-left corner.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶部显示区域通过使用 `canvas.create_image()` 方法创建了一个画布小部件，并放置了一个覆盖图像。当前播放的文本和顶部显示中的计时器是通过使用
    `canvas.create_text()` 方法创建的。放置这些元素所使用的坐标是基于试错法决定的。作为提醒，画布坐标是从左上角测量的。
- en: 'The **Button Frame** section simply creates buttons and uses images instead
    of text, using the following code:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按钮框架**部分简单创建按钮，并使用图像代替文本，使用以下代码：'
- en: '[PRE9]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The **Button Frame** section also uses a ttk Scale widget, which can be used
    as a volume slider. This has been created by using the following code:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按钮框架**部分也使用了 ttk Scale 小部件，它可以作为音量滑块使用。这是通过以下代码创建的：'
- en: '[PRE10]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `from` and `to` values for the Scale widget have been chosen as `0.0` and
    `1.0` because these are the numbers that the `pyglet` library uses to denote the
    minimum and maximum volume, which will be seen in the following section.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scale控件中的`from`和`to`值被选为`0.0`和`1.0`，因为这些是`pyglet`库用来表示最小和最大音量的数字，这将在下一节中看到。
- en: 'The Listbox section creates a playlist by using the Tkinter Listbox widget,
    which uses the following code:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表框部分通过使用 Tkinter 列表框小部件来创建播放列表，该小部件使用以下代码：
- en: '[PRE11]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `select mode=EXTENDED` option in the preceding code means that this list
    box will allow multiple list items to be selected at once. If this line is omitted,
    the default behavior of the Listbox widget is to allow only a single selection
    at a time.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一段代码中的`select mode=EXTENDED`选项意味着这个列表框将允许一次性选择多个列表项。如果省略这一行，列表框小部件的默认行为是每次只允许选择一个项。
- en: The `activestyle='none'` option means that we do not want to underline the selected
    item.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activestyle=''none''`选项意味着我们不希望为选定的项目添加下划线。'
- en: The Listbox section is attached to the Scrollbar widget, which is similar to
    what we have done in the earlier chapters.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表框部分连接到滚动条小部件，这与我们在前面的章节中所做的是类似的。
- en: The **Bottom Frame** section adds a few image buttons as we did earlier. It
    also creates three Radiobutton widgets using a `for` loop.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**底部框架**部分添加了几个图像按钮，就像我们之前做的那样。它还使用`for`循环创建了三个单选按钮小部件。'
- en: Finally, note that we have completely skipped the creation of the seek bar,
    as it is a custom widget that is not natively defined in Tkinter. This is something
    that we will create in a dedicated section of its own.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，请注意，我们完全跳过了滚动条的创建，因为它是一个在Tkinter中未原生定义的自定义小部件。这是我们将在其独立部分中创建的内容。
- en: 'The Listbox widget offers the following four selection modes via the selectmode
    option:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表框小部件通过selectmode选项提供了以下四种选择模式：
- en: '`SINGLE`: This allows only a single row to be selected at a time'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SINGLE`: 这允许每次只选择一行'
- en: '`BROWSE` (the default mode): This is similar to `SINGLE`, but it allows you
    to move a selection by dragging the mouse'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MULTIPLE`: This allows for multiple selections by clicking on items one at
    a time'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MULTIPLE`: 这允许通过逐个点击项目进行多次选择'
- en: '`EXTENDED`: This allows for the selection of a multiple range of items using
    the *Shift* and *Ctrl* keys'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXTENDED`: 这允许使用 *Shift* 和 *Ctrl* 键选择多个范围的项'
- en: 'In addition to creating all of these widgets, we have also added a command
    callback to most of these widgets. These command callbacks currently point to
    the following empty, nonfunctional methods (see code `5.01`—`view.py`):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: None of these methods are functional now. We will end the iteration here, as there
    are a few other things that we need to do before we can think of making the widgets
    functional.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Deciding the data structure
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sticking to the model first philosophy, let's spend some time on deciding the appropriate
    data structure or model for the program.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: The data structure of the audio player is fairly simple. All that we expect
    of the model is to keep a track of playlists. The main data then is a list called
    `play_list`, and the `Model` class is then simply responsible for the addition
    and removal of items to and from the playlist.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly we came up with the following `Model` class for the program (see
    code `5.02`—`model.py`):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Nothing fancy in the preceding code. The object simply consists of a Python
    list with various utility methods that can be used to add and remove items from
    the list.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The `play_list` method has been declared as a property so that we need not write
    the `getter` method for the playlist. This is definitely more Pythonic because a
    statement such as `play_list = self.play_list` is more readable than `play_list
    = self.get_play_list()`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Player class
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's write the code for the `Player` class. This class will be responsible
    for the handling of audio playback and its related functions, such as pause, stop,
    seek, fast forward, rewind, change of volume, mute, and so on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `pyglet` library to handle these functions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Pyglet is a cross-platform library that uses the `AVbin` module to support a
    large variety of audio files.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: You might want to look at the API documentation of the pyglet player, which
    is available at [https://bitbucket.org/pyglet/pyglet/wiki/Home](https://bitbucket.org/pyglet/pyglet/wiki/Home).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also access the documentation for the pyglet media player class by
    typing the following two lines in the Python interactive shell:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The online documentation at [https://pyglet.readthedocs.org/](https://pyglet.readthedocs.org/)
    tells us that we can play an audio file by using the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Accordingly, the code for the `Player` class is as follows (see code `5.02`—`player.py`):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code is built on the `pyglet` API, which is quite intuitive. We
    will not get into the details of audio programming here and trust the `pyglet`
    library as a black box that delivers what it says, namely, to be able to play
    and control audio.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the important things that you should note about the preceding
    code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: We defined the `play_media` method, which is responsible for the playing of
    audio. All the other methods support other functions related to playback, such
    as pause, stop, rewind, forward, mute, and so on.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the code defines a new pyglet `Player` class every time it wants to play
    an audio file. Though we could have used the same player instance to play multiple
    audio files, it turns out that the `pyglet` library does not have a `stop` method.
    The only way we can stop an audio file from playing is by killing the `Player`
    object and creating a fresh `Player` object for the next audio file playback.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it came to choosing an external implementation as we did for the audio API
    here, we first searched through the Python standard library at [https://docs.python.org/3.6/library/](https://docs.python.org/3.6/library/).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the standard library does not have a suitable package for us, we turned our
    attention to the Python package index to check whether there exists another high-level
    audio interface implementation. The Python package index can be found at [http://pypi.python.org/](http://pypi.python.org/).
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fortunately, we came across several audio packages. After comparing the packages against
    our needs and seeing how active their communities were, we settled for `pyglet`. The
    same program could have been implemented with several other packages, though this
    would be done with varying levels of complexity.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, the lower you go down the protocol stack, the more complex your
    programs will get.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: However, at the lower layers of the protocol, you will get a finer control over
    the implementation at the cost of increasing learning curves.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that most of the audio libraries change over a period of time. While
    this current audio library may become nonfunctional over time, you can easily
    modify the `Player` class to use some other audio library and still be able to
    use this program as long as you keep the interface defined in the `Player` class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the iteration. We now have a functional `Player` class that can manipulate
    audio files. We have a data structure that consists of a `play_list` with various
    methods to add and remove files from a playlist. We will next look at how to add
    and remove files from a playlist from the frontend of the program.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing items from a playlist
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write some code for a feature that allows us to add and remove items
    from a playlist. To be more specific, we will write the code for a function for
    the four buttons marked in the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68cc3347-c466-46e2-be08-8fccefdaa0fa.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: 'The four buttons, from left to right, perform the following functions:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The first button from the left adds individual audio files to a playlist
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second button deletes all the selected items from the playlist
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third button scans a directory for audio files and adds all the found audio
    files to the playlist
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last button empties the playlist
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since adding these features requires us to interact with the Listbox widget
    of Tkinter, let''s spend some time getting to know the Listbox widget:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a Listbox widget like we''d create any other widget, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When you initially create a Listbox widget, it is empty. To insert one or more
    lines of text into the Listbox, use the `insert()` method, which takes two arguments,
    namely an index of the position where the text needs to be inserted and the actual
    string that needs to be inserted, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `curselection()` method returns the index of all the items selected in
    the list, and the `get()` method returns the list item for a given index, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In addition to this, the Listbox widget has several other configurable options.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'For a complete Listbox widget reference, type the following into the Python interactive
    shell:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that we know how to add and remove items from the Listbox widget, let's
    code these functions into the player.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by modifying the command callback attached to the four buttons,
    as follows (see code `5.03`—`view.py`):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'All that these four methods do is call four other methods that do the actual
    task of adding or removing items to the playlist. All the methods will update
    the `play_list` items at the following two places:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: In the visible Listbox widget
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the backend data structure playlist maintained by the `Model` class
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's define the four new methods.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Adding a single audio file
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding a file involves asking for the location using Tkinter `filedialog` and
    updating the frontend and backend, as follows (see code `5.03`—`view.py`):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Removing the selected files from a playlist
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the Listbox allows for multiple selections, we iterate through all the
    selected items, removing them from the frontend Listbox widget as well as from
    the model `play_list`, as follows (see code `5.03`—`view.py`):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that we reverse the tuple before removing items from the playlist because
    we want to start removing items from the end, as a removal causes a change in
    the index of playlist items. If we do not remove items from the end, we may end
    up removing the wrong items from the list, as its index gets modified in each
    iteration.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have defined this method here, let''s add it as a command callback
    to the right-click delete menu, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Adding all files from a directory
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code uses the `os.walk()` method to recursively walk through
    all the files looking for  `.wav` and `.mp3` files, as follows (see code `5.03`—`view.py`):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Emptying the playlist
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code is as follows (see code `5.03`—`view.py`):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This completes our third iteration. In this iteration, we saw how to work with
    the Listbox widget. In particular, we saw how to add items to the Listbox widget,
    select a particular item from the Listbox widget, and delete one or more items
    from it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: You now have a playlist where you can add and delete items using the four buttons at
    the bottom-left corner of the audio player.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Playing audio and adding audio controls
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this iteration, we will code the features marked in the following screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3bd65c1e-acc7-4c28-9967-c2fc5eefc226.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: This includes the play/stop, pause/unpause, next track, previous track, fast
    forward, rewind, volume change, and mute/unmute features.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Adding the play/stop function
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a playlist and a `Player` class that can play audio, playing
    audio is simply about updating the current track index and calling the `play`
    method.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, let''s add an attribute, as follows (see code `5.04`—`view.py`):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Furthermore, the **Play** button should act as a toggle between the `play` and
    `stop` functions. The Python `itertools` module provides the `cycle` method, which
    is a very convenient way to toggle between two or more values.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, import the `itertools` module and define a new attribute, as follows
    (see code `5.04`—`view.py`):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, every time we call `next(toggle_play_stop)`, the value returned toggles between
    the `play` and `stop` strings.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Itertools is a very powerful standard library of Python that can emulate many
    **iterables** from a functional programming paradigm. An iterable in Python is
    an interface that implements the `next()` method. Every subsequent call to `next()`
    is **lazily evaluated**—thereby making them suitable for iterating over large
    sequences in the most efficient manner. The `cycle()` tool used here is an example
    of an iterator that can provide infinite sequences of alternating values without
    the need to define a large data structure.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the documentation of the `itertools` module:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/itertools.html](https://docs.python.org/3/library/itertools.html)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, modify the `on_play_stop_button_clicked()` method so that it looks like
    this (see code `5.04`—`view.py`):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding method simply toggles between calling the `start_play()` and `stop_play()`
    methods, which are defined as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding code calls the `play` and `stop` methods defined in the `Player` class.
    It also changes the button image from the *play* icon to the *stop* icon by using the
    `widget.config(image=new_image_icon)` method.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: While we are handling the `play` function, let's modify the command callback
    so that a user can play a track simply by double-clicking on it. We have already
    defined a method named `on_play_list_double_clicked` earlier, which is currently
    empty.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply modify it, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Adding the pause/unpause function
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we need a single button to toggle between pause and unpause, we will
    again use the `cycle()` method from the `itertools` module. Define an attribute,
    as follows (see code `5.04`—`view.py`):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, modify the command callback attached to the button, as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This takes care of the pause and unpause features of the program.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Adding the mute/unmute function
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is similar to coding the pause/unpause feature. We need an attribute that can
    toggle between the `mute` and `unmute` strings. Accordingly, add an attribute, as
    follows (see code `5.04`—`view.py`):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, modify the command callback to call the `mute` or `unmute` functions
    from the `player` class, change the button icon to the mute or unmute image, and
    shift the volume scale accordingly, as follows (see code `5.04`—`view.py`):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Fast forward/rewind function
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The codes for fast forward and rewind are the simplest. We have already defined
    the methods to handle this in the `Player` class. Now, it''s only a matter of
    connecting them to the concerned command callback, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Adding the next track/previous track function
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we had defined the code for fast forward and rewind in the `Player` class, we
    did not define the method related to next track and previous track there, because this
    can be handled by the existing `play` method. All that you need to do is simply increment
    or decrement the value of `current_track` and then call the `play` method. Accordingly,
    define two methods in the `View` class, as follows (see code `5.04`—`view.py`):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, simply attach these two methods to the respective command callback, as
    follows (see code `5.04`—`view.py`):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Adding the volume change function
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already defined the `volume` method in the `Player` class. Now, all
    that you need to do is simply get the value of the Volume Scale widget and set
    the volume in the `Player` class.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, ensure that in case the volume becomes zero, we change the volume button icon
    to the mute image (see code `5.04`—`view.py`):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This concludes the iteration. The player is now functional enough to be called
    an audio player. Go ahead and add some music files to the player. Press the play
    button and enjoy the music! Try out other player controls that we defined in this
    iteration and they should work as expected.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Creating a seek bar
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's add a seek bar to the audio player. Tkinter offers the Scale widget
    that we used for the volume scale. The Scale widget could have functioned as a
    seek bar.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: But we want something fancier. Moreover, the Scale widget would look different
    on different platforms. Instead, we want the seek bar to look uniform on all platforms.
    This is where we can create our own widget to meet the custom needs of the audio
    player.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our own Seekbar widget, as shown in the following screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd25afb3-8f5a-4483-a745-9c000bb5bf70.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: The simplest way to create our own widget is to inherit one from an existing
    widget or the `Widget` class.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: When you look at the source code of Tkinter, you will find that all the widgets
    inherit from a class named `Widget`. The `Widget` class, in turn, inherits from
    another class called `BaseWidget`. The `BaseWidget` class contains the code that
    is used to handle a widget's `destroy()` method, but it is not aware of a geometry
    manager.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, if we want our custom widget to be aware of and use geometry managers such
    as `pack`, `grid`, or `place`, we need to inherit from the `Widget` class or from
    another Tkinter widget.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we want to create a widget named `Wonderwidget`. We can
    do so simply by inheriting from the `Widget` class, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: These four lines of code create a widget named `Wonderwidget`, which can be positioned
    with geometry managers such as `pack`, `place`, or `grid`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: However, for more practical use cases, we generally inherit from the existing
    Tkinter widgets, such as `Text`, `Button`, `Scale`, `Canvas`, and so on. In our
    case, we will create the `Seekbar` widget by inheriting from the `Canvas` class.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `seekbar.py` (see code `5.05.py`). Then, create a
    new class named `Seekbar` that inherits from the `Canvas` widget, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The preceding code calls the `__init__` method of the parent `Canvas` class
    to initialize the underlying canvas with all the canvas-related options that are passed
    as an argument.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'With as little code as that, let''s go back and modify the `create_top_display()`method
    in the `View` class to add this new widget, as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, `SEEKBAR_WIDTH` is a constant that we defined as equal to 360 pixels in the
    program.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: If you now run `view.py`, you will see the `Seekbar` widget at its place.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The seek bar is not functional, as it does not move when the seek bar knob is
    clicked.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make the seek bar slide along, we will bind the mouse buttons by defining
    a new method and calling it from the `__init__` method, as follows (see code `5.05`—`seekbar.py`):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We bind the entire canvas, the red rectangle, and the seek bar knob to a single method
    named `on_seekbar_clicked`, which can be defined as follows (see code `5.05`—`seekbar.py`):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The preceding method simply calls another method named `slide_to_position`,
     which is responsible for changing the position of the knob and the size of the
    red rectangle (see code `5.05`—`seekbar.py`):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The preceding code slides the knob to the new position. More importantly, the
    last line creates a custom event named `SeekbarPositionChanged`. This event will
    let any code that uses this custom widget handle the event appropriately.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: The second argument, `x=new_position`, adds the value of `x` to `event.x`, making
    it available to the event handler.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have only been handling events. Tkinter also lets us create our own
    events, which are called **virtual events**.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: We can specify any name for the event by enclosing the name in double pairs
    of `<<...>>`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we generated a virtual event named `<<SeekbarPositionChanged>>`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'We then bound it to the appropriate event handler in the `View` class, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'That''s all that there is to the custom `Seekbar` widget. We can write a small
    test in `seekbar.py` that will check whether the `Seekbar` widget works as expected:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Go ahead and run the `5.05`—`seekbar.py` program; it should produce a seek bar. The
    seek bar should slide when you drag the seek bar knob or click at various places
    on the canvas.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the iteration. We will make the audio player's seek bar functional
    in the next iteration.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: One-time updates during audio playback
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The audio program must update some information as soon as an audio track starts playing.
    Broadly speaking, there are two kinds of updates that the program needs to monitor
    and update:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '**One-time updates**: Examples of this include the name of the track and the total
    length of the track.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous updates**: Examples of this include the position of the seek bar knob
    and the elapsed play duration. We also need to check continuously whether a track
    has ended either to play the next track, play the current track again, or stop
    playing, depending on the loop choice made by the user.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These two kinds of updates will affect sections of the audio player, as shown
    in the following screenshot:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50ad1983-d89e-4f73-a016-a2b2eec1858e.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: Let's start with the one-time updates, as they are relatively simple to implement.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Since these updates must occur when the playback starts, let''s define a method named
    `manage_one_time_updates()` and call it from within the `start_play()` method
    of the `View` class, as follows (see code `5.06`—`view.py`):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, define all the methods called from within the preceding method, as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: These two methods simply find out the track name and track duration and update the
    related canvas text by using a call to `canvas.itemconfig`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like we use `config` to change the value of widget-related options, the
    `Canvas` widget uses `itemconfig` to change the options for individual items within
    the canvas.  The format for `itemconfig` is as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Let's define two helper methods in a new file named `helpers.py` and import the
    methods in the view namespace. The two methods are `truncate_text` and `get_time_in_minutes_seconds`.
    The code for this can be found in the `5.06`—`helpers.py` file.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'That takes care of one-time updates. Now, when you run `5.06`—`view.py` and
    play some audio file, the player should update the track name, and the total track
    duration in the top console, as shown in the following screenshot:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1679bd68-61e9-407d-8b0d-5fcfcb822d49.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
- en: We will take care of periodic updates in the next iteration.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Managing continuous updates
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will update the position of the seek bar knob and the elapsed play
    duration, as shown in the following screenshot:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/afb5eac3-dbaf-4742-ba55-ca90aa9d129a.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: This is nothing but a simple form of Tkinter-based animation.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common pattern of animating with Tkinter involves drawing a single frame
    and then calling the same method using the after method of Tkinter, as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Take a note of the `self.after` method, which calls the `animate` method in
    a loop. Once called, this function will keep updating frames once every `500` milliseconds.
    You can also add some conditions to break out of the animation loop. This is generally
    how all animations are handled in Tkinter. We will use this technique over and
    over again in several upcoming examples.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to manage animations in Tkinter, let's use the pattern to
    define a method that takes care of these periodic updates.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a method named `manage_periodic_updates_during_play`, which calls itself
    every 1 second to update the timer and the seek bar, as follows (see code `5.07`—`view.py`):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Then, define two methods named `update_clock` and `update_seek_bar`, which update
    the sections highlighted in the preceding screenshot.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'The `update_clock` method gets the elapsed duration in seconds from the `Player` class,
    converts it into minutes and seconds, and updates the canvas text using `canvas.itemconfig`,
    as follows (see code `5.07`—`view.py`):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You may recall that we had previously defined a `slide_to_position` method
    in the `Seekbar` class. The `update_seek_bar` method simply calculates the proportionate position
    of the seek bar and then calls the `slide_to_position` method to slide the knob
    of the seekbar, as follows (see code `5.07`—`view.py`):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now, if you run `5.07`–`view.py`, add an audio file, and play it, the elapsed
    duration should be updated continuously in the top display. The seek bar should
    also move forward as the play progresses.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s great, but there is still one small detail missing. We want that when
    a user clicks somewhere on the seek bar, the playing audio seeks the new position.
    The code for seeking a new position is simple (see code `5.07`—`view.py`):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'However, the preceding method needs to be called whenever the seek bar position is
    changed. Let''s do this by adding a binding to the virtual event from within `5.07`—`view.py`,
    as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now, when you run  `5.07`—`view.py`, play an audio file and click on the seek
    bar; the audio should start playing from the new position.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the iteration. We will look at how to loop over tracks in the next
    iteration.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Looping over tracks
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add the feature that allows users to loop over tracks. We have already
    defined radio buttons to allow three choices, as shown in the following screenshot:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49e96b01-b2c0-4c28-af95-f6baf379556e.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
- en: 'In essence, the player should provide a choice from the following three options:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'No Loop: Play a track and end there'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Loop Current: Play a single track repeatedly'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Loop All: Looping through the entire playlist, one after another'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The decision to follow one of these three options needs to be taken immediately
    after a particular track ends playing. The best place to judge whether a track
    has come to its end is from within the periodic updates loop that we created earlier.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, modify the `manage_periodic_updates_during_play()` method to add the
    following two lines of highlighted code (see code `5.08`—`view.py`):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This in effect means that the looping decision is checked only when the currently playing
    track ends. Then, define the `not_to_loop()` method, as follows (see code `5.09`—`view.py`):'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The code first checks the value of the selected radio button and, based on
    the selected choice, makes the looping choice:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: If the selected loop value is `1` (No Loop), it does nothing and returns `True`, breaking
    out of the continuous update loop.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the selected loop value is `2` (loop over the current song), it again calls
    the `start_play` method and returns `False`. Thus, we do not break out of the update
    loop.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the loop value is `3` (Loop All), it calls the `play_next_track` method and
    returns `True`. Thus, we break out of the previous update loop.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The audio player can now loop over the playlist based on the looping preference
    set by the user.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Let's conclude this iteration by overriding the close button so that the audio
    player properly deletes the player object when the user decides to close the player
    while it is playing.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'To override the destroy method, first add a protocol override command to the `View
    __init__` method, as follows (see code `5.08`—`view.py`):'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, define the `close_player` method, as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This concludes the iteration. We coded the logic required to loop over tracks
    and then overrode the close button to ensure that a playing track is stopped before
    we exit the player.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Adding a tooltip
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final iteration, we will add a tooltip named the **Balloon widget**
    to all the buttons in our player.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'A tooltip is a small **popup** that shows up when you hover your mouse over
    the Bound widget (buttons, in our case). A typical tooltip for the application
    will look as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2d47813-10e2-47b2-8351-f8fa620f0dbf.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
- en: Although core Tkinter has many useful widgets, it is far from complete. For
    us, the tooltip or Balloon widget is not provided as a core Tkinter widget. Therefore,
    we look for these widgets in what are called **Tkinter extensions**.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: These extensions are nothing but a collection of extended Tkinter widgets, just
    like the custom seek bar that we created.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: There are literally hundreds of Tkinter extensions. In fact, we just wrote our
    own Tkinter extension in this chapter.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the following are some of the popular Tkinter extensions:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '**Pmw**: ([http://pmw.sourceforge.net](http://pmw.sourceforge.net))'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tix**: ([http://wiki.Python.org/moin/Tix](http://wiki.Python.org/moin/Tix))'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TkZinc**: ([http://wiki.Python.org/moin/TkZinc](http://wiki.Python.org/moin/TkZinc))'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Widget Construction Kit (WCK)**: ([http://effbot.org/zone/wck.htm](http://effbot.org/zone/wck.htm))'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pmw list of extensions
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Talking about Pmw, here is a quick list of widget extensions and dialogs from the
    package.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Widgets
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows a list of widget extensions:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '| ButtonBox | ComboBox | Counter | EntryField |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
- en: '| Group | HistoryText | LabeledWidget | MainMenuBar |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
- en: '| MenuBar | MessageBar | NoteBook | OptionMenu |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
- en: '| PanedWidget | RadioSelect | ScrolledCanvas | ScrolledField |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
- en: '| ScrolledFrame | ScrolledListBox | ScrolledText | TimeCounter |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
- en: Dialogs
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows a list of widget dialogs:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '| AboutDialog | ComboBoxDialog | CounterDialog | Dialog |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
- en: '| MessageDialog | PromptDialog | SelectionDialog | TextDialog |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
- en: Miscellaneous
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a list of miscellaneous widgets offered by Pmw:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '`Balloon`'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Blt` (used for graph generation)'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Color Module` functions
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pmw offers a large list of extended widgets. For a demonstration of all these
    widgets, browse the Pmw package that you installed earlier and look for a directory
    named `demo`. Within `demo`, look for a file named `All.py`, which demonstrates
    all of these Pmw extensions with a sample working code.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'Pmw provides the `Balloon` widget implementation, which will be used in the current
    example. Begin by importing `Pmw` into the namespace, as follows (see code `5.09`—`view.py`):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, instantiate the `Balloon` widget within the `create_gui` method, as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, bind the `Balloon` widget to each button widget in the audio player.
    We will not reproduce the code for each button. However, the format is as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Thus, the Add File button will have a balloon binding, as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Add similar code for each button in `5.09`—`view.py`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: This completes the iteration. We added Balloon tooltips to the audio player's
    buttons using the Pmw Tkinter extension. Most importantly, we got to know about
    the Tkinter extensions and when to use them.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: When you need a widget implementation that is not available as a core widget,
    try looking for its implementations in Pmw or TIX. If you don't find one that
    suits your needs, search the internet for some other Tkinter extension. If you
    still don't find your desired implementation, it's time to build one.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of this chapter. The audio player is ready!
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's recap the things that we touched upon in this chapter.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: In addition to reinforcing a lot of GUI programming techniques that we discussed
    in the previous chapters, you learned how to work with more widgets such as Listbox, ttk
    Scale, and Radiobutton. We looked deeper into the features of the Canvas widget.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, we learned how to create our custom widgets, thereby extending Tkinter's
    core widgets. This is a really powerful technique that can be applied to build
    all sorts of features into programs.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to generate and handle virtual events.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: We saw the most common technique for applying animation in Tkinter programs.
    This technique can also be used to build all sorts of interesting games.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we got to know about some common Tkinter extensions, such as Pmw, WCK,
    TIX, and so on.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's lose ourselves in some music!
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: QA section
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you proceed to the next chapter, make sure you can answer these questions
    to your
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'satisfaction:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: How can we create our own custom widgets in Tkinter?
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you create animations with Tkinter?
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are virtual events? When and how do we use them?
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are Tkinter extensions? What are the most popular ones?
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Look at the documentation for popular Tkinter extensions such as Pmw, Tix, WCK,
    and others.  Take a note of the commonly available widgets in these extensions.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
