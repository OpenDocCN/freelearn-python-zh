- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web Forms with WTForms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Form handling is an integral part of any web application. There can be innumerable
    cases that make the presence of forms in any web app very important. Some cases
    may include situations where users need to log in or submit some data, or where
    applications might require input from users. As much as forms are important, their
    validation holds equal importance, if not more. Presenting this information to
    users in an interactive fashion adds a lot of value to the application.
  prefs: []
  type: TYPE_NORMAL
- en: There are various ways in which we can design and implement forms in a web application.
    As web applications have matured, form validation and communicating the correct
    messages to a user have become very important. Client-side validations can be
    implemented at the frontend using JavaScript and HTML5\. Server-side validations
    have a more important role in adding security to an application, rather than being
    user-interactive. Server-side validations prevent any incorrect data from going
    through to the database and, hence, curb fraud and attacks.
  prefs: []
  type: TYPE_NORMAL
- en: WTForms provides many fields with server-side validation by default and, hence,
    increases development speed and decreases the overall effort required. It also
    provides the flexibility to write custom validations and custom fields as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a Flask extension in this chapter. This extension is called Flask-WTF
    ([https://flask-wtf.readthedocs.io/en/latest/](https://flask-wtf.readthedocs.io/en/latest/));
    it provides integration between WTForms and Flask, taking care of important and
    trivial stuff that we would have to otherwise reinvent in order to make our application
    secure and effective. We can install it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Representing SQLAlchemy model data as a form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating fields on the server side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a common form set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom fields and validations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading files via forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting applications from **cross-site request** **forgery** (**CSRF**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representing SQLAlchemy model data as a form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let’s build a form using a SQLAlchemy model. In this recipe, we will
    take the product model from our catalog application used previously in this book
    and add functionality, creating products from the frontend using a web form.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use our catalog application from [*Chapter 4*](B19111_04.xhtml#_idTextAnchor184),
    *Working with Views*, and we will develop a form for the `Product` model.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you recall, the `Product` model looks like the following lines of code in
    the `models.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we will create a `ProductForm` class in `models.py`; this will subclass
    the `FlaskForm` class, which is provided by `flask_wtf`, to represent the fields
    required on a web form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We import `FlaskForm` from the `flask-wtf` extension. Everything else, such
    as `fields` and `validators`, are imported from `wtforms` directly. The `Name`
    field is of the `StringField` type, as it requires text data, while `Price` is
    of the `DecimalField` type, which will parse the data to Python’s `Decimal` data
    type. We have kept `Category` as the `SelectField` type, which means that we can
    choose only from the categories created previously when creating a product.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have a parameter called `coerce` in the field definition for `Category`
    (which is a selection list); this means that the incoming data from the HTML form
    will be coerced to an integer value prior to validating or any other processing.
    Here, coercing simply means converting a value, provided in a specific data type,
    to a different data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `create_product()` handler in `views.py` should now accommodate the form
    created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `create_product()` method accepts values from a form on a `POST` request.
    This method will render an empty form with the prefilled choices in the `Category`
    field on a `GET` request. On the `POST` request, the form data will be used to
    create a new product, and when the creation of the product is completed, the newly
    created product’s page will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that while creating the `form` object as `form = ProductForm(meta={''csrf'':
    False})`, we set `csrf` to `False`. CSRF is an important part of any secure web
    application. We will talk about this in detail in the *Protecting applications
    from CSRF* recipe of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `templates/product-create.html` template also requires some modification.
    The `form` objects created by WTForms provide an easy way to create HTML forms
    and keep code readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On a `GET` request – that is, upon opening `http://127.0.0.1:5000/product-create`
    – we will see a form similar to the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Product creation form using WTForms](img/B19111_05_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Product creation form using WTForms
  prefs: []
  type: TYPE_NORMAL
- en: You can fill in this form to create a new product.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the following *Validating fields on the server side* recipe to understand
    how to validate the fields we just learned to create.
  prefs: []
  type: TYPE_NORMAL
- en: Validating fields on the server side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created forms and fields, but we need to validate them in order to make
    sure that only the correct data goes through to the database and that errors are
    handled beforehand, rather than corrupting the database. These validations can
    also protect an application against **cross-site scripting** (**XSS**) and CSRF
    attacks. WTForms provides a whole lot of field types that, themselves, have validations
    written for them by default. Apart from these, there are a bunch of validators
    that can be used based on choice and need. In this recipe, we will use a few of
    them to understand the concept.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is pretty easy to add validations to our WTForm fields. We just need to pass
    a `validators` parameter, which accepts a list of validators to be implemented.
    Each of the validators can have their own arguments, which enables us to control
    the validations to a great extent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify our `ProductForm` object in the `models.py` class to have validations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have the `InputRequired` validator on all three fields; this means
    that these fields are required, and the form will not be submitted unless we have
    values for these fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Price` field has an additional validator, `NumberRange`, with a `min`
    parameter set to `0.0`. This implies that we cannot have a value of less than
    `0` as the price of a product. To complement these changes, we will have to modify
    our `create_product()` method in `views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The flashing of `form.errors` will just display the errors in the form of a
    JSON object. This can be formatted to be shown in a pleasing format to a user.
    This is left for you to try yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we modified our `create_product()` method to validate the form for the
    input value when submitted. Some of the validations will be translated and applied
    to the frontend as well, just like the `InputRequired` validation will add a `required`
    property to the form field’s HTML. On a `POST` request, the form data will be
    validated first. If the validation fails for some reason, the same page will be
    rendered again, with error messages flashed on it. If the validation succeeds
    and the creation of the product is completed, the newly created product’s page
    will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note the very convenient `validate_on_submit()` method. This will automatically
    check whether the request is `POST` and whether it is valid. It is essentially
    a combination of `request.method == 'POST'` and `form.validate()`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, try to submit the form without any field filled in – that is, an empty
    form. An alert message with an error will be shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – In-built error handling in WTForms](img/B19111_05_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – In-built error handling in WTForms
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to submit the form with a negative price value, the flashed error
    will look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Custom error handling in WTForms](img/B19111_05_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Custom error handling in WTForms
  prefs: []
  type: TYPE_NORMAL
- en: Try different combinations of form submissions that will violate the defined
    validators, and note the different error messages that come up.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the previous recipe, *Representing SQLAlchemy model data as a form*,
    to understand basic form creation using WTForms.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a common form set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application can have many forms, depending on the design and purpose. Some
    of these forms will have common fields with common validators. You might think,
    “*Why not have common form parts and then reuse them as and when needed?*” In
    this recipe, we will see that this is certainly possible with the class structure
    for forms’ definition provided by WTForms.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our catalog application, we can have two forms, one each for the `Product`
    and `Category` models. These forms will have a common field called `Name`. We
    can create a common form for this field, and then the separate forms for the `Product`
    and `Category` models can use this form, instead of having a `Name` field in each
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be implemented as follows in `models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We created a common form called `NameForm`, and the other forms, `ProductForm`
    and `CategoryForm`, inherit from this form to have a field called `Name` by default.
    Then, we can add more fields as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can modify the `create_category()` method in `views.py` to use `CategoryForm`
    to create categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A new template, `templates/category-create.html`, also needs to be added for
    category creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `http://127.0.0.1:5000/category-create` URL in your browser. The newly
    created category form will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – A common form used for category creation](img/B19111_05_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – A common form used for category creation
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: This is a very small example of how a common form set can be implemented. The
    actual benefits of this approach can be seen in e-commerce applications, where
    we can have common address forms, and then they can be expanded to have separate
    billing and shipping addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom fields and validations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from providing a bunch of fields and validations, Flask and WTForms also
    provide you with the flexibility to create custom fields and validations. Sometimes,
    we might need to parse some form of data that cannot be processed using the available
    current fields. In such cases, we can implement our own fields.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our catalog application, we used `SelectField` for the category, and we populated
    the values for this field in our `create_product()` method on a `GET` request
    by querying the `Category` model. It would be much more convenient if we did not
    concern ourselves with this and the population of this field took care of itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s implement a custom field to do this in `models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`SelectField` implements a method called `iter_choices()`, which populates
    the values to the form using the list of values provided to the `choices` parameter.
    We overwrite the `iter_choices()` method to get the values of categories directly
    from the database, and this eliminates the need to populate this field every time
    we need to use this form.'
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: The behavior created by `CategoryField` here can also be achieved using `QuerySelectField`.
    Refer to [https://wtforms-sqlalchemy.readthedocs.io/en/stable/wtforms_sqlalchemy/#wtforms_sqlalchemy.fields.QuerySelectField](https://wtforms-sqlalchemy.readthedocs.io/en/stable/wtforms_sqlalchemy/#wtforms_sqlalchemy.fields.QuerySelectField)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the changes described in this section, our `create_product()` method
    in `views.py` will have to be modified. For this, just remove the following two
    statements that populated the categories in the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There will not be any visual effect on the application. The only change will
    be in the way the categories are populated in the form, as explained in the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We just saw how to write custom fields. Similarly, we can write custom validations,
    too. Let’s assume that we do not want to allow duplicate categories. We can implement
    this in our models easily, but let’s do this using a custom validator on our form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: So, we created our validator in a factory style, where we can get separate validation
    results based on whether we want a case-sensitive comparison. We can even write
    a class-based design, which makes the validator much more generic and flexible,
    but I will leave that for you to explore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you try to create a new category with the same name as the one that
    already exists, the following error will be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.5 – An error on the duplicate ca\uFEFFtegory creation](img/B19111_05_5.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – An error on the duplicate category creation
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like we can create custom fields and validators, we can also create custom
    widgets. These widgets allow us to control how our fields will look on the frontend.
    Each field type has a widget associated with it, and WTForms, by itself, provides
    a lot of basic and HTML5 widgets. In this recipe, to understand how to write a
    custom widget, we will convert our custom selection field for `Category` into
    a radio field. I agree with those of you who would argue that we can directly
    use the radio field provided by WTForms. Here, we are just trying to understand
    how to do it ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: The widgets provided by default by WTForms can be found at [https://wtforms.readthedocs.io/en/3.0.x/widgets/](https://wtforms.readthedocs.io/en/3.0.x/widgets/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our previous recipe, we created `CategoryField`. This field used the `Select`
    widget, which was provided by the `Select` superclass. Let’s replace the `Select`
    widget with a radio input in `models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we added a class attribute called `widget` to our `CategoryField` class.
    This widget points to `CustomCategoryInput`, which takes care of HTML code generation
    for the field to be rendered. This class has a `__call__()` method, which is overwritten
    to return radio inputs corresponding to the values provided by the `iter_choices()`
    method of `CategoryField`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you open the product creation page, `http://127.0.0.1:5000/product-create`,
    it will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.6 – A custom widget for \uFEFFcategory selection](img/B19111_05_6.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – A custom widget for category selection
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the previous recipe, *Creating custom fields and validation*, to understand
    more about the level of customization that can be done to the components of WTForms.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading files via forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Uploading files via forms, and doing it properly, is usually a matter of concern
    for many web frameworks. In this recipe, we will see how Flask and WTForms handle
    this for us in a simple and streamlined manner.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will implement a feature to store product images while creating
    products. First, we will start with the configuration bit. We need to provide
    a parameter to our application configuration – that is, `UPLOAD_FOLDER`. This
    parameter tells Flask about the location where our uploaded files will be stored.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: One way to store product images can be to store images in a binary-type field
    in our database, but this method is highly inefficient and never recommended in
    any application. We should always store images and other uploads in a filesystem,
    and store their locations in a database using a `string` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following statements to the configuration in `my_app/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Note the `app.config['UPLOAD_FOLDER']` statement, where we store the images
    inside a subfolder in the `static` folder itself. This will make the process of
    rendering images easier. Also, note the `ALLOWED_EXTENSIONS` statement, which
    is used to make sure that only files of a specific format go through. The list
    here is actually for demonstration purposes only, and for image types, we can
    filter this list even more. Make sure the folder path specified in the `app.config['UPLOAD_FOLDER']`
    statement exists; otherwise, the application will error out.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `models` file – that is, `my_app/catalog/models.py` – add the following
    highlighted statements to their designated places:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Check `FileField` for `image` in `ProductForm` and the field for `image_path`
    to the `Product` model. Here, the uploaded file will be stored on the filesystem
    at the path defined in the config, and the path generated will be stored in the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, modify the `create_product()` method to save the file in `my_app/catalog/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the new field to the product create form in `template templates/product-create.html`.
    Modify the `form` tag definition to include the `enctype` parameter, and add the
    field for the image before the **Submit** button (or wherever you feel it is necessary
    inside the form):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The form should have the `enctype="multipart/form-data"` statement to tell the
    application that the form input will have multipart data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rendering the image is very easy, as we are storing the files in the `static`
    folder itself. Just add the `img` tag wherever the image needs to be displayed
    in `templates/product.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The field to upload the image will look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Uploading files for the product image](img/B19111_05_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Uploading files for the product image
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the creation of the product, the image will be displayed, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.8 – The product page \uFEFFwith the uploaded file](img/B19111_05_8.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – The product page with the uploaded file
  prefs: []
  type: TYPE_NORMAL
- en: Protecting applications from CSRF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first recipe of this chapter, we learned that CSRF is an important part
    of web form security. We will now talk about this in detail. CSRF basically means
    that someone can hack into the request that carries a cookie and use this to trigger
    a destructive action. We won’t be discussing CSRF in detail here, since ample
    resources are available on the internet to learn about it. We will talk about
    how WTForms helps us to prevent CSRF. Flask does not provide any security against
    CSRF by default, as this has to be handled at the form-validation level, which
    is not a core feature of Flask as a framework. However, in this recipe, we will
    see how this can be done for us by using the Flask-WTF extension.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: More information about CSRF can be found at [https://owasp.org/www-community/attacks/csrf](https://owasp.org/www-community/attacks/csrf).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flask-WTF, by default, provides a form that is CSRF-protected. If we have a
    look at the recipes so far, we can see that we have explicitly told our form to
    *not be CSRF-protected*. We just have to remove the corresponding statement to
    enable CSRF.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, `form = ProductForm(meta={''csrf'': False})` will become `form =` `ProductForm()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some configuration bits also need to be done in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: By default, the CSRF key is the same as our application’s secret key.
  prefs: []
  type: TYPE_NORMAL
- en: 'With CSRF enabled, we will have to provide an additional field in our forms;
    this is a hidden field and contains the CSRF token. WTForms takes care of the
    hidden field for us, and we just have to add `{{ form.csrf_token }}` to our form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: That was easy! Now, this is not the only type of form submission that we do.
    We also submit AJAX form posts; this actually happens a lot more than normal forms
    since the advent of JavaScript-based web applications, which are replacing traditional
    web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we need to include another step in our application’s configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding configuration will allow us to access the CSRF token using `{{
    csrf_token() }}` anywhere in our templates. Now, there are two ways to add a CSRF
    token to AJAX `POST` requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way is to fetch the CSRF token in our `script` tag and use it in the `POST`
    request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way is to render the token in a `meta` tag and use it whenever required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The difference between the two approaches is that the first approach may have
    to be repeated in multiple places, depending on the number of `script` tags in
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to add the CSRF token to the AJAX `POST` request, we have to add the `X-CSRFToken`
    attribute to it. This attribute’s value can be taken from either of the two approaches
    stated here. We will take the second one for our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This will make sure that a CSRF token is added to all the AJAX `POST` requests
    that go out.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following screenshot shows what the CSRF token added by WTForms in our
    form looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – The CSRF token](img/B19111_05_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – The CSRF token
  prefs: []
  type: TYPE_NORMAL
- en: The token is completely random and different for all the requests. There are
    multiple ways of implementing CSRF token generation, but this is beyond the scope
    of this book, although I encourage you to explore some alternative implementations
    on your own to understand how it’s done.
  prefs: []
  type: TYPE_NORMAL
