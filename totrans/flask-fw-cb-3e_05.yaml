- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web Forms with WTForms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Form handling is an integral part of any web application. There can be innumerable
    cases that make the presence of forms in any web app very important. Some cases
    may include situations where users need to log in or submit some data, or where
    applications might require input from users. As much as forms are important, their
    validation holds equal importance, if not more. Presenting this information to
    users in an interactive fashion adds a lot of value to the application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: There are various ways in which we can design and implement forms in a web application.
    As web applications have matured, form validation and communicating the correct
    messages to a user have become very important. Client-side validations can be
    implemented at the frontend using JavaScript and HTML5\. Server-side validations
    have a more important role in adding security to an application, rather than being
    user-interactive. Server-side validations prevent any incorrect data from going
    through to the database and, hence, curb fraud and attacks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: WTForms provides many fields with server-side validation by default and, hence,
    increases development speed and decreases the overall effort required. It also
    provides the flexibility to write custom validations and custom fields as required.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a Flask extension in this chapter. This extension is called Flask-WTF
    ([https://flask-wtf.readthedocs.io/en/latest/](https://flask-wtf.readthedocs.io/en/latest/));
    it provides integration between WTForms and Flask, taking care of important and
    trivial stuff that we would have to otherwise reinvent in order to make our application
    secure and effective. We can install it using the following command:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Representing SQLAlchemy model data as a form
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating fields on the server side
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a common form set
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom fields and validations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom widget
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading files via forms
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting applications from **cross-site request** **forgery** (**CSRF**)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representing SQLAlchemy model data as a form
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let’s build a form using a SQLAlchemy model. In this recipe, we will
    take the product model from our catalog application used previously in this book
    and add functionality, creating products from the frontend using a web form.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use our catalog application from [*Chapter 4*](B19111_04.xhtml#_idTextAnchor184),
    *Working with Views*, and we will develop a form for the `Product` model.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you recall, the `Product` model looks like the following lines of code in
    the `models.py` file:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'First, we will create a `ProductForm` class in `models.py`; this will subclass
    the `FlaskForm` class, which is provided by `flask_wtf`, to represent the fields
    required on a web form:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We import `FlaskForm` from the `flask-wtf` extension. Everything else, such
    as `fields` and `validators`, are imported from `wtforms` directly. The `Name`
    field is of the `StringField` type, as it requires text data, while `Price` is
    of the `DecimalField` type, which will parse the data to Python’s `Decimal` data
    type. We have kept `Category` as the `SelectField` type, which means that we can
    choose only from the categories created previously when creating a product.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Information
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have a parameter called `coerce` in the field definition for `Category`
    (which is a selection list); this means that the incoming data from the HTML form
    will be coerced to an integer value prior to validating or any other processing.
    Here, coercing simply means converting a value, provided in a specific data type,
    to a different data type.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'The `create_product()` handler in `views.py` should now accommodate the form
    created earlier:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `create_product()` method accepts values from a form on a `POST` request.
    This method will render an empty form with the prefilled choices in the `Category`
    field on a `GET` request. On the `POST` request, the form data will be used to
    create a new product, and when the creation of the product is completed, the newly
    created product’s page will be displayed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Information
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that while creating the `form` object as `form = ProductForm(meta={''csrf'':
    False})`, we set `csrf` to `False`. CSRF is an important part of any secure web
    application. We will talk about this in detail in the *Protecting applications
    from CSRF* recipe of this chapter.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'The `templates/product-create.html` template also requires some modification.
    The `form` objects created by WTForms provide an easy way to create HTML forms
    and keep code readable:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On a `GET` request – that is, upon opening `http://127.0.0.1:5000/product-create`
    – we will see a form similar to the one shown in the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Product creation form using WTForms](img/B19111_05_1.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Product creation form using WTForms
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: You can fill in this form to create a new product.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the following *Validating fields on the server side* recipe to understand
    how to validate the fields we just learned to create.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Validating fields on the server side
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created forms and fields, but we need to validate them in order to make
    sure that only the correct data goes through to the database and that errors are
    handled beforehand, rather than corrupting the database. These validations can
    also protect an application against **cross-site scripting** (**XSS**) and CSRF
    attacks. WTForms provides a whole lot of field types that, themselves, have validations
    written for them by default. Apart from these, there are a bunch of validators
    that can be used based on choice and need. In this recipe, we will use a few of
    them to understand the concept.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is pretty easy to add validations to our WTForm fields. We just need to pass
    a `validators` parameter, which accepts a list of validators to be implemented.
    Each of the validators can have their own arguments, which enables us to control
    the validations to a great extent.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify our `ProductForm` object in the `models.py` class to have validations:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we have the `InputRequired` validator on all three fields; this means
    that these fields are required, and the form will not be submitted unless we have
    values for these fields.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Price` field has an additional validator, `NumberRange`, with a `min`
    parameter set to `0.0`. This implies that we cannot have a value of less than
    `0` as the price of a product. To complement these changes, we will have to modify
    our `create_product()` method in `views.py`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The flashing of `form.errors` will just display the errors in the form of a
    JSON object. This can be formatted to be shown in a pleasing format to a user.
    This is left for you to try yourself.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Here, we modified our `create_product()` method to validate the form for the
    input value when submitted. Some of the validations will be translated and applied
    to the frontend as well, just like the `InputRequired` validation will add a `required`
    property to the form field’s HTML. On a `POST` request, the form data will be
    validated first. If the validation fails for some reason, the same page will be
    rendered again, with error messages flashed on it. If the validation succeeds
    and the creation of the product is completed, the newly created product’s page
    will be displayed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Note the very convenient `validate_on_submit()` method. This will automatically
    check whether the request is `POST` and whether it is valid. It is essentially
    a combination of `request.method == 'POST'` and `form.validate()`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, try to submit the form without any field filled in – that is, an empty
    form. An alert message with an error will be shown as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – In-built error handling in WTForms](img/B19111_05_2.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – In-built error handling in WTForms
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to submit the form with a negative price value, the flashed error
    will look something like the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Custom error handling in WTForms](img/B19111_05_3.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Custom error handling in WTForms
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Try different combinations of form submissions that will violate the defined
    validators, and note the different error messages that come up.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the previous recipe, *Representing SQLAlchemy model data as a form*,
    to understand basic form creation using WTForms.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Creating a common form set
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application can have many forms, depending on the design and purpose. Some
    of these forms will have common fields with common validators. You might think,
    “*Why not have common form parts and then reuse them as and when needed?*” In
    this recipe, we will see that this is certainly possible with the class structure
    for forms’ definition provided by WTForms.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序可以有多个表单，这取决于设计和目的。其中一些表单将具有共同的字段和共同的验证器。你可能会想，“*为什么不创建通用的表单部分并在需要时重用它们呢？*”在这个菜谱中，我们将看到使用
    WTForms 提供的表单定义类结构，这确实是可能的。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: In our catalog application, we can have two forms, one each for the `Product`
    and `Category` models. These forms will have a common field called `Name`. We
    can create a common form for this field, and then the separate forms for the `Product`
    and `Category` models can use this form, instead of having a `Name` field in each
    of them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的目录应用程序中，我们可以有两个表单，每个分别对应 `Product` 和 `Category` 模型。这些表单将有一个共同的字段称为 `Name`。我们可以为这个字段创建一个通用的表单，然后
    `Product` 和 `Category` 模型的单独表单可以使用这个表单，而不是在每个模型中都有一个 `Name` 字段。
- en: 'This can be implemented as follows in `models.py`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在 `models.py` 中如下实现：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We created a common form called `NameForm`, and the other forms, `ProductForm`
    and `CategoryForm`, inherit from this form to have a field called `Name` by default.
    Then, we can add more fields as necessary.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `NameForm` 的通用表单，其他表单 `ProductForm` 和 `CategoryForm` 从这个表单继承，默认包含一个名为
    `Name` 的字段。然后，我们可以根据需要添加更多字段。
- en: 'We can modify the `create_category()` method in `views.py` to use `CategoryForm`
    to create categories:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改 `views.py` 中的 `create_category()` 方法，使用 `CategoryForm` 来创建分类：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A new template, `templates/category-create.html`, also needs to be added for
    category creation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要添加一个新的模板，`templates/category-create.html`，用于创建分类：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Open the `http://127.0.0.1:5000/category-create` URL in your browser. The newly
    created category form will look like the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开 `http://127.0.0.1:5000/category-create` URL。新创建的分类表单将看起来像以下截图：
- en: '![Figure 5.4 – A common form used for category creation](img/B19111_05_4.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 用于创建分类的通用表单](img/B19111_05_4.jpg)'
- en: Figure 5.4 – A common form used for category creation
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 用于创建分类的通用表单
- en: Tip
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: This is a very small example of how a common form set can be implemented. The
    actual benefits of this approach can be seen in e-commerce applications, where
    we can have common address forms, and then they can be expanded to have separate
    billing and shipping addresses.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个如何实现通用表单集的小例子。这种方法的实际好处可以在电子商务应用程序中看到，在那里我们可以有通用的地址表单，然后它们可以扩展为具有单独的账单和发货地址。
- en: Creating custom fields and validations
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义字段和验证
- en: Apart from providing a bunch of fields and validations, Flask and WTForms also
    provide you with the flexibility to create custom fields and validations. Sometimes,
    we might need to parse some form of data that cannot be processed using the available
    current fields. In such cases, we can implement our own fields.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供一系列字段和验证之外，Flask 和 WTForms 还提供了创建自定义字段和验证的灵活性。有时，我们可能需要解析一些无法使用当前可用字段处理的数据格式。在这种情况下，我们可以实现自己的字段。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: In our catalog application, we used `SelectField` for the category, and we populated
    the values for this field in our `create_product()` method on a `GET` request
    by querying the `Category` model. It would be much more convenient if we did not
    concern ourselves with this and the population of this field took care of itself.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的目录应用程序中，我们使用 `SelectField` 来处理分类，并在 `GET` 请求中通过查询 `Category` 模型来填充这个字段的值。如果我们不需要关心这一点，并且这个字段的填充可以自动完成，那就方便多了。
- en: 'Now, let’s implement a custom field to do this in `models.py`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 `models.py` 中实现一个自定义字段来完成这个功能：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`SelectField` implements a method called `iter_choices()`, which populates
    the values to the form using the list of values provided to the `choices` parameter.
    We overwrite the `iter_choices()` method to get the values of categories directly
    from the database, and this eliminates the need to populate this field every time
    we need to use this form.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectField` 实现了一个名为 `iter_choices()` 的方法，它使用提供给 `choices` 参数的值列表来填充表单。我们重写了
    `iter_choices()` 方法，直接从数据库中获取分类的值，这样就消除了每次使用这个表单时都需要填充这个字段的必要性。'
- en: Information
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The behavior created by `CategoryField` here can also be achieved using `QuerySelectField`.
    Refer to [https://wtforms-sqlalchemy.readthedocs.io/en/stable/wtforms_sqlalchemy/#wtforms_sqlalchemy.fields.QuerySelectField](https://wtforms-sqlalchemy.readthedocs.io/en/stable/wtforms_sqlalchemy/#wtforms_sqlalchemy.fields.QuerySelectField)
    for more information.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the changes described in this section, our `create_product()` method
    in `views.py` will have to be modified. For this, just remove the following two
    statements that populated the categories in the form:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There will not be any visual effect on the application. The only change will
    be in the way the categories are populated in the form, as explained in the previous
    section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We just saw how to write custom fields. Similarly, we can write custom validations,
    too. Let’s assume that we do not want to allow duplicate categories. We can implement
    this in our models easily, but let’s do this using a custom validator on our form:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So, we created our validator in a factory style, where we can get separate validation
    results based on whether we want a case-sensitive comparison. We can even write
    a class-based design, which makes the validator much more generic and flexible,
    but I will leave that for you to explore.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you try to create a new category with the same name as the one that
    already exists, the following error will be shown:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.5 – An error on the duplicate ca\uFEFFtegory creation](img/B19111_05_5.jpg)"
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – An error on the duplicate category creation
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom widget
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like we can create custom fields and validators, we can also create custom
    widgets. These widgets allow us to control how our fields will look on the frontend.
    Each field type has a widget associated with it, and WTForms, by itself, provides
    a lot of basic and HTML5 widgets. In this recipe, to understand how to write a
    custom widget, we will convert our custom selection field for `Category` into
    a radio field. I agree with those of you who would argue that we can directly
    use the radio field provided by WTForms. Here, we are just trying to understand
    how to do it ourselves.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Information
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The widgets provided by default by WTForms can be found at [https://wtforms.readthedocs.io/en/3.0.x/widgets/](https://wtforms.readthedocs.io/en/3.0.x/widgets/).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our previous recipe, we created `CategoryField`. This field used the `Select`
    widget, which was provided by the `Select` superclass. Let’s replace the `Select`
    widget with a radio input in `models.py`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we added a class attribute called `widget` to our `CategoryField` class.
    This widget points to `CustomCategoryInput`, which takes care of HTML code generation
    for the field to be rendered. This class has a `__call__()` method, which is overwritten
    to return radio inputs corresponding to the values provided by the `iter_choices()`
    method of `CategoryField`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you open the product creation page, `http://127.0.0.1:5000/product-create`,
    it will look like the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.6 – A custom widget for \uFEFFcategory selection](img/B19111_05_6.jpg)"
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – A custom widget for category selection
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the previous recipe, *Creating custom fields and validation*, to understand
    more about the level of customization that can be done to the components of WTForms.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Uploading files via forms
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Uploading files via forms, and doing it properly, is usually a matter of concern
    for many web frameworks. In this recipe, we will see how Flask and WTForms handle
    this for us in a simple and streamlined manner.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will implement a feature to store product images while creating
    products. First, we will start with the configuration bit. We need to provide
    a parameter to our application configuration – that is, `UPLOAD_FOLDER`. This
    parameter tells Flask about the location where our uploaded files will be stored.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: One way to store product images can be to store images in a binary-type field
    in our database, but this method is highly inefficient and never recommended in
    any application. We should always store images and other uploads in a filesystem,
    and store their locations in a database using a `string` field.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following statements to the configuration in `my_app/__init__.py`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Note the `app.config['UPLOAD_FOLDER']` statement, where we store the images
    inside a subfolder in the `static` folder itself. This will make the process of
    rendering images easier. Also, note the `ALLOWED_EXTENSIONS` statement, which
    is used to make sure that only files of a specific format go through. The list
    here is actually for demonstration purposes only, and for image types, we can
    filter this list even more. Make sure the folder path specified in the `app.config['UPLOAD_FOLDER']`
    statement exists; otherwise, the application will error out.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `models` file – that is, `my_app/catalog/models.py` – add the following
    highlighted statements to their designated places:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Check `FileField` for `image` in `ProductForm` and the field for `image_path`
    to the `Product` model. Here, the uploaded file will be stored on the filesystem
    at the path defined in the config, and the path generated will be stored in the
    database.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, modify the `create_product()` method to save the file in `my_app/catalog/views.py`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the new field to the product create form in `template templates/product-create.html`.
    Modify the `form` tag definition to include the `enctype` parameter, and add the
    field for the image before the **Submit** button (or wherever you feel it is necessary
    inside the form):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The form should have the `enctype="multipart/form-data"` statement to tell the
    application that the form input will have multipart data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Rendering the image is very easy, as we are storing the files in the `static`
    folder itself. Just add the `img` tag wherever the image needs to be displayed
    in `templates/product.html`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The field to upload the image will look something like the following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Uploading files for the product image](img/B19111_05_7.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Uploading files for the product image
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the creation of the product, the image will be displayed, as shown
    in the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.8 – The product page \uFEFFwith the uploaded file](img/B19111_05_8.jpg)"
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – The product page with the uploaded file
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Protecting applications from CSRF
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first recipe of this chapter, we learned that CSRF is an important part
    of web form security. We will now talk about this in detail. CSRF basically means
    that someone can hack into the request that carries a cookie and use this to trigger
    a destructive action. We won’t be discussing CSRF in detail here, since ample
    resources are available on the internet to learn about it. We will talk about
    how WTForms helps us to prevent CSRF. Flask does not provide any security against
    CSRF by default, as this has to be handled at the form-validation level, which
    is not a core feature of Flask as a framework. However, in this recipe, we will
    see how this can be done for us by using the Flask-WTF extension.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Information
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: More information about CSRF can be found at [https://owasp.org/www-community/attacks/csrf](https://owasp.org/www-community/attacks/csrf).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flask-WTF, by default, provides a form that is CSRF-protected. If we have a
    look at the recipes so far, we can see that we have explicitly told our form to
    *not be CSRF-protected*. We just have to remove the corresponding statement to
    enable CSRF.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'So, `form = ProductForm(meta={''csrf'': False})` will become `form =` `ProductForm()`.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Some configuration bits also need to be done in our application:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By default, the CSRF key is the same as our application’s secret key.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'With CSRF enabled, we will have to provide an additional field in our forms;
    this is a hidden field and contains the CSRF token. WTForms takes care of the
    hidden field for us, and we just have to add `{{ form.csrf_token }}` to our form:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That was easy! Now, this is not the only type of form submission that we do.
    We also submit AJAX form posts; this actually happens a lot more than normal forms
    since the advent of JavaScript-based web applications, which are replacing traditional
    web applications.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we need to include another step in our application’s configuration:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding configuration will allow us to access the CSRF token using `{{
    csrf_token() }}` anywhere in our templates. Now, there are two ways to add a CSRF
    token to AJAX `POST` requests.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'One way is to fetch the CSRF token in our `script` tag and use it in the `POST`
    request:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Another way is to render the token in a `meta` tag and use it whenever required:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The difference between the two approaches is that the first approach may have
    to be repeated in multiple places, depending on the number of `script` tags in
    the application.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法之间的区别在于，第一种方法可能需要根据应用程序中 `script` 标签的数量在多个地方重复。
- en: 'Now, to add the CSRF token to the AJAX `POST` request, we have to add the `X-CSRFToken`
    attribute to it. This attribute’s value can be taken from either of the two approaches
    stated here. We will take the second one for our example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了将 CSRF 令牌添加到 AJAX `POST` 请求中，我们必须向其中添加 `X-CSRFToken` 属性。此属性的值可以从这里提到的两种方法中的任何一种获取。我们将采用第二种方法作为我们的示例：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will make sure that a CSRF token is added to all the AJAX `POST` requests
    that go out.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保 CSRF 令牌被添加到所有发出的 AJAX `POST` 请求中。
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following screenshot shows what the CSRF token added by WTForms in our
    form looks like:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 WTForms 在我们的表单中添加的 CSRF 令牌的外观：
- en: '![Figure 5.9 – The CSRF token](img/B19111_05_9.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – CSRF 令牌](img/B19111_05_9.jpg)'
- en: Figure 5.9 – The CSRF token
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – CSRF 令牌
- en: The token is completely random and different for all the requests. There are
    multiple ways of implementing CSRF token generation, but this is beyond the scope
    of this book, although I encourage you to explore some alternative implementations
    on your own to understand how it’s done.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌是完全随机的，对于所有请求都是不同的。有多种实现 CSRF 令牌生成的方法，但这超出了本书的范围，尽管我鼓励你自己探索一些替代实现来了解它是如何完成的。
