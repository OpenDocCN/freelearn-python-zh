<html><head></head><body>
<div id="_idContainer050">
<h1 class="chapter-number" id="_idParaDest-165"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-166"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.2.1">Using Go and Python for Network Programming</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we’re going to see how Python and Go are powerful and used for network programming, but depending on what your requirements are and your environment, one might be better suited for you than the other. </span><span class="koboSpan" id="kobo.3.2">We are going to use Python and Go for network programming by checking the advantages and disadvantages of using each.</span></p>
<p><span class="koboSpan" id="kobo.4.1">By the end of this chapter, you will be able to identify which language (Python or Go) is more suitable for your network project and which library to use. </span><span class="koboSpan" id="kobo.4.2">You are going to learn the differences and superpowers of each language that will probably make the difference in your network automation work.</span></p>
<p><span class="koboSpan" id="kobo.5.1">The topics we are going to cover in this chapter are as follows:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.6.1">Looking into the language runtime</span></li>
<li><span class="koboSpan" id="kobo.7.1">Using third-party libraries</span></li>
<li><span class="koboSpan" id="kobo.8.1">Accessing network devices using libraries</span></li>
</ul>
<h1 id="_idParaDest-167"><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.9.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.10.1">The source code described in this chapter is stored in this book’s GitHub repository at </span><a href="https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter06"><span class="koboSpan" id="kobo.11.1">https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter06</span></a><span class="koboSpan" id="kobo.12.1">.</span></p>
<p><span class="koboSpan" id="kobo.13.1">The examples in this chapter were created and tested using a simple network device simulator. </span><span class="koboSpan" id="kobo.13.2">The instructions on how to download and run this simulator are included in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.14.1">Chapter06/Device-Simulator</span></strong><span class="koboSpan" id="kobo.15.1"> directory. </span></p>
<h1 id="_idParaDest-168"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.16.1">Looking into the language runtime</span></h1>
<p><span class="koboSpan" id="kobo.17.1">After writing your </span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.18.1">code and saving it, you are going to run it somewhere in your network. </span><span class="koboSpan" id="kobo.18.2">Go and Python have different ways to combine your source code and all imported libraries before running. </span><span class="koboSpan" id="kobo.18.3">Which one suits you more? </span><span class="koboSpan" id="kobo.18.4">Are there any relevant differences that are important to know? </span><span class="koboSpan" id="kobo.18.5">We’ll discuss that in this section.</span></p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.19.1">What are compiled and interpreted languages? </span></h2>
<p><span class="koboSpan" id="kobo.20.1">After </span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.21.1">writing your code, some computer languages need to be compiled to run on your machine, though some don’t as they are interpreted line by line as it runs. </span></p>
<p><span class="koboSpan" id="kobo.22.1">The </span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.23.1">languages that are </span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.24.1">compiled have to have a compiler that translates the source code into a series of bits and bytes that can run on the CPU architecture of your computer; it also has to link all static and dynamic system libraries. </span><span class="koboSpan" id="kobo.24.2">For instance, a computer with an Apple M1 processor will have a different compiler than an Apple with an Intel x86 processor. </span><span class="koboSpan" id="kobo.24.3">The result after the compilation is a binary program that can’t be read by humans and when it runs, it is loaded from disk to main memory.</span></p>
<p><span class="koboSpan" id="kobo.25.1">Once you have compiled, you don’t need to have your source code to run your program. </span><span class="koboSpan" id="kobo.25.2">The machine that runs your code does not need the compiler or the source code, only the compiled program binaries, which adds free space, code privacy, and code security.</span></p>
<p><span class="koboSpan" id="kobo.26.1">On the other</span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.27.1"> hand, interpreted languages (as it stands) are interpreted by a code interpreter, which interprets your code line by line when it is running. </span><span class="koboSpan" id="kobo.27.2">These interpreted languages are also known</span><a id="_idIndexMarker690"/><span class="koboSpan" id="kobo.28.1"> as </span><strong class="bold"><span class="koboSpan" id="kobo.29.1">scripting languages</span></strong><span class="koboSpan" id="kobo.30.1">. </span><span class="koboSpan" id="kobo.30.2">The machine that runs the interpreted language needs to have the interpreter and the source code, which unfortunately exposes the source code and needs additional space to store.</span></p>
<p><span class="koboSpan" id="kobo.31.1">Examples of compiled languages include Go, C, C++, Haskel, and Rust. </span><span class="koboSpan" id="kobo.31.2">Examples of interpreted languages include Python, PHP, Unix Shell, JavaScript, and Ruby.</span></p>
<p><span class="koboSpan" id="kobo.32.1">Java is a special case because it has a compiler but compiles to its own </span><strong class="bold"><span class="koboSpan" id="kobo.33.1">Java Virtual Machine</span></strong><span class="koboSpan" id="kobo.34.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.35.1">JVM</span></strong><span class="koboSpan" id="kobo.36.1">) architecture, which</span><a id="_idIndexMarker691"/><span class="koboSpan" id="kobo.37.1"> is not the CPU architecture where the program will run. </span><span class="koboSpan" id="kobo.37.2">Once compiled, you can use it anywhere but will need to install a JVM for the specific CPU architecture, adding extra storage and runtime complexity.</span></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.38.1">Python interpreter</span></h2>
<p><span class="koboSpan" id="kobo.39.1">The</span><a id="_idIndexMarker692"/><span class="koboSpan" id="kobo.40.1"> Python interpreter is </span><a id="_idIndexMarker693"/><span class="koboSpan" id="kobo.41.1">sometimes called a Python virtual machine as a reference to a JVM, which can run anywhere. </span><span class="koboSpan" id="kobo.41.2">But Python does not provide a virtual machine like Java – it provides an interpreter, which is quite different.</span></p>
<p><span class="koboSpan" id="kobo.42.1">In Java, this virtual machine is like a virtual CPU that provides an environment for the Java bytecode-compiled program to run. </span><span class="koboSpan" id="kobo.42.2">The JVM translates the Java-compiled bytecode into the bytecode of the CPU architecture where it is running. </span><span class="koboSpan" id="kobo.42.3">So, Java code will need to be compiled first; then, the compiled program can run on any machine that has a JVM installed.</span></p>
<p><span class="koboSpan" id="kobo.43.1">On the contrary, the interpreter is much more complicated as it does not translate bytecode as it does in a JVM but interprets lines in a context with its surroundings. </span><span class="koboSpan" id="kobo.43.2">The interpreter reads the whole code and parses the syntax that must be decoded in the program’s context. </span><span class="koboSpan" id="kobo.43.3">Because of this complexity, this can be a very slow process.</span></p>
<p><span class="koboSpan" id="kobo.44.1">Let’s investigate some of the available Python interpreters.</span></p>
<h3><span class="koboSpan" id="kobo.45.1">Using CPython</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.46.1">CPython</span></strong><span class="koboSpan" id="kobo.47.1"> is </span><a id="_idIndexMarker694"/><span class="koboSpan" id="kobo.48.1">one</span><a id="_idIndexMarker695"/><span class="koboSpan" id="kobo.49.1"> of the most common interpreter programs that is required to be installed in the machine where the Python code will run. </span><span class="koboSpan" id="kobo.49.2">CPython is written in C and is perhaps the first implementation of the Python interpreter.</span></p>
<p><span class="koboSpan" id="kobo.50.1">CPython is the place where new functionalities will be created before they can be exposed in Python. </span><span class="koboSpan" id="kobo.50.2">As an example, when concurrency was added to Python, it was first achieved by the CPython interpreter process using the operating system’s multitasking properties.</span></p>
<p><span class="koboSpan" id="kobo.51.1">CPython implementations can be compiled into proprietary bytecode before being passed to the interpreter. </span><span class="koboSpan" id="kobo.51.2">The reason is that it is easier to create an interpreter based on a stack machine instruction set, even though an interpreter doesn’t need to do so.</span></p>
<p><span class="koboSpan" id="kobo.52.1">The following is an example</span><a id="_idIndexMarker696"/><span class="koboSpan" id="kobo.53.1"> of a CPython stack machine instruction set:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.54.1">
$ pythonPython 3.9.4  [MSC v.1928 64 bit (AMD64)] on win32
&gt;&gt;&gt; import dis
&gt;&gt;&gt;
&gt;&gt;&gt; def return_the_bigest(a, b):
...     if a &gt; b:
...         return a
...     if b &gt; a:
...         return b
...     return None
...
</span><span class="koboSpan" id="kobo.54.2">&gt;&gt;&gt; dis.dis(return_the_bigest)
  2           0 LOAD_FAST                0 (a)
              2 LOAD_FAST                1 (b)
              4 COMPARE_OP               4 (&gt;)
              6 POP_JUMP_IF_FALSE       12
 
  3           8 LOAD_FAST                0 (a)
             10 RETURN_VALUE
 
  4     &gt;&gt;   12 LOAD_FAST                1 (b)
             14 LOAD_FAST                0 (a)
             16 COMPARE_OP               4 (&gt;)
             18 POP_JUMP_IF_FALSE       24
 
  5          20 LOAD_FAST                1 (b)
             22 RETURN_VALUE
 
  6     &gt;&gt;   24 LOAD_GLOBAL              0 (Null)
             26 RETURN_VALUE</span></pre>
<p><span class="koboSpan" id="kobo.55.1">As you can </span><a id="_idIndexMarker697"/><span class="koboSpan" id="kobo.56.1">see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">return_the_bigest</span></strong><span class="koboSpan" id="kobo.58.1"> function is translated into the CPython bytecode </span><a id="_idIndexMarker698"/><span class="koboSpan" id="kobo.59.1">shown, which will be used by the CPython interpreter when it’s run. </span><span class="koboSpan" id="kobo.59.2">Note that the instruction set does the same as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">return_the_bigest</span></strong><span class="koboSpan" id="kobo.61.1"> function, which is harder for humans to read and easier for the Python interpreter. </span></p>
<p><span class="koboSpan" id="kobo.62.1">More on disassembler Python bytecode can be found here: </span><a href="https://docs.python.org/3/library/dis.html"><span class="koboSpan" id="kobo.63.1">https://docs.python.org/3/library/dis.html</span></a><span class="koboSpan" id="kobo.64.1">.</span></p>
<p><span class="koboSpan" id="kobo.65.1">More on CPython can </span><a id="_idIndexMarker699"/><span class="koboSpan" id="kobo.66.1">be found here: </span><a href="https://github.com/python/cpython"><span class="koboSpan" id="kobo.67.1">https://github.com/python/cpython</span></a><span class="koboSpan" id="kobo.68.1">.</span></p>
<h3><span class="koboSpan" id="kobo.69.1">Using Jython</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.70.1">Jython</span></strong><span class="koboSpan" id="kobo.71.1"> is </span><a id="_idIndexMarker700"/><span class="koboSpan" id="kobo.72.1">another Python interpreter that was created </span><a id="_idIndexMarker701"/><span class="koboSpan" id="kobo.73.1">originally in 1997 by Jim Hugunin as </span><strong class="bold"><span class="koboSpan" id="kobo.74.1">JPython</span></strong><span class="koboSpan" id="kobo.75.1">. </span><span class="koboSpan" id="kobo.75.2">In 1999, JPython was renamed to Jython, as it is known today.</span></p>
<p><span class="koboSpan" id="kobo.76.1">Jython is used to compile Python code into a Java bytecode virtual machine that can run on any hardware that has a JVM installed. </span><span class="koboSpan" id="kobo.76.2">Sometimes, it can run faster as it does not need to be interpreted like CPython.</span></p>
<p><span class="koboSpan" id="kobo.77.1">Although the project started with high expectations, today, it only supports Python 2.7, and the support for Python 3.x is still under development. </span><span class="koboSpan" id="kobo.77.2">Therefore, you are only going to need Jython if you are running your code on a machine that only supports JVMs. </span><span class="koboSpan" id="kobo.77.3">There will also be lots of limitations as it only supports Python version 2.7, which is no longer supported by the Python community and was deprecated in January 2020.</span></p>
<p><span class="koboSpan" id="kobo.78.1">More on Jython can </span><a id="_idIndexMarker702"/><span class="koboSpan" id="kobo.79.1">be found here: </span><a href="https://github.com/jython/jython"><span class="koboSpan" id="kobo.80.1">https://github.com/jython/jython</span></a><span class="koboSpan" id="kobo.81.1">.</span></p>
<h3><span class="koboSpan" id="kobo.82.1">Using PyPy</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.83.1">PyPy</span></strong><span class="koboSpan" id="kobo.84.1"> is </span><a id="_idIndexMarker703"/><span class="koboSpan" id="kobo.85.1">another</span><a id="_idIndexMarker704"/><span class="koboSpan" id="kobo.86.1"> Python interpreter implementation that claims to run Python code faster than CPython. </span><span class="koboSpan" id="kobo.86.2">PyPy also claims to handle concurrency better than CPython with the usage of micro-threads. </span><span class="koboSpan" id="kobo.86.3">And finally, it claims to use less memory than CPython.</span></p>
<p><span class="koboSpan" id="kobo.87.1">Despite the great advantages of PyPy, CPython is still the most used Python interpreter, mainly because people don’t know about PyPy and the default Python installation uses CPython.</span></p>
<p><span class="koboSpan" id="kobo.88.1">PyPy has a website dedicated to comparing its speed with other interpreters, such as CPython. </span><span class="koboSpan" id="kobo.88.2">The website also has comparisons with other versions of PyPy. </span><em class="italic"><span class="koboSpan" id="kobo.89.1">Figure 6.1</span></em><span class="koboSpan" id="kobo.90.1"> shows a comparison between CPython and PyPy with information taken from the PyPy speed website. </span><span class="koboSpan" id="kobo.90.2">On average, PyPy is 4 times faster than CPython:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<span class="koboSpan" id="kobo.91.1"><img alt="Figure 6.1 – CPython and PyPy comparison taken from speed.pypy.org" src="image/B18165_06_001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.92.1">Figure 6.1 – CPython and PyPy comparison taken from speed.pypy.org</span></p>
<p><span class="koboSpan" id="kobo.93.1">The </span><a id="_idIndexMarker705"/><span class="koboSpan" id="kobo.94.1">preceding</span><a id="_idIndexMarker706"/><span class="koboSpan" id="kobo.95.1"> figure contains blue bars, which represent how a specific benchmark runs in PyPy 3.9 in comparison to CPython 3.7.6. </span><span class="koboSpan" id="kobo.95.2">As an example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">bm_dulwich_log</span></strong><span class="koboSpan" id="kobo.97.1"> benchmark runs twice as fast compared to CPython (0.5). </span><span class="koboSpan" id="kobo.97.2">The sixth blue bar shows that PyPy runs slower for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">bm_mdp</span></strong><span class="koboSpan" id="kobo.99.1"> benchmark (1.3), but for the second blue bar, which represents the </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">chaos</span></strong><span class="koboSpan" id="kobo.101.1"> benchmark, PyPy runs up to 20 times faster. </span><span class="koboSpan" id="kobo.101.2">Details about each benchmark can be obtained at </span><a href="https://speed.pypy.org/"><span class="koboSpan" id="kobo.102.1">https://speed.pypy.org/</span></a><span class="koboSpan" id="kobo.103.1">.</span></p>
<p><span class="koboSpan" id="kobo.104.1">For more on PyPy, check</span><a id="_idIndexMarker707"/><span class="koboSpan" id="kobo.105.1"> its home page at </span><a href="https://www.pypy.org/"><span class="koboSpan" id="kobo.106.1">https://www.pypy.org/</span></a><span class="koboSpan" id="kobo.107.1">.</span></p>
<h3><span class="koboSpan" id="kobo.108.1">Using Cython</span></h3>
<p><span class="koboSpan" id="kobo.109.1">Although</span><a id="_idIndexMarker708"/><span class="koboSpan" id="kobo.110.1"> some</span><a id="_idIndexMarker709"/><span class="koboSpan" id="kobo.111.1"> people compare PyPy with </span><strong class="bold"><span class="koboSpan" id="kobo.112.1">Cython</span></strong><span class="koboSpan" id="kobo.113.1">, Cython is not a Python interpreter like PyPy. </span><span class="koboSpan" id="kobo.113.2">Cython is a compiler that can be used with the Python and Cython languages, which is</span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.114.1"> based on </span><strong class="bold"><span class="koboSpan" id="kobo.115.1">Pyrex</span></strong><span class="koboSpan" id="kobo.116.1">, a superset of the</span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.117.1"> Python language. </span><span class="koboSpan" id="kobo.117.2">Cython can add C and C++ extensions easily to your code. </span><span class="koboSpan" id="kobo.117.3">As it is implemented in C, the Cython code claims to be faster than Python when using PyPy.</span></p>
<p><span class="koboSpan" id="kobo.118.1">Therefore, if you are looking to write Python code and require high performance, try Cython. </span><span class="koboSpan" id="kobo.118.2">More on Cython</span><a id="_idIndexMarker712"/><span class="koboSpan" id="kobo.119.1"> can be found at </span><a href="https://cython.org/"><span class="koboSpan" id="kobo.120.1">https://cython.org/</span></a><span class="koboSpan" id="kobo.121.1">.</span></p>
<h3><span class="koboSpan" id="kobo.122.1">Using IPython and Jupyter</span></h3>
<p><span class="koboSpan" id="kobo.123.1">The major</span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.124.1"> advantage of an interpreted language is </span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.125.1">that it can run interactively easier. </span><span class="koboSpan" id="kobo.125.2">Python has an interpreter for this called </span><strong class="bold"><span class="koboSpan" id="kobo.126.1">IPython</span></strong><span class="koboSpan" id="kobo.127.1">. </span></p>
<p><span class="koboSpan" id="kobo.128.1">IPython can be used to run your code gradually line by line and then check what happens in memory. </span><span class="koboSpan" id="kobo.128.2">This is useful when testing or trying a new code or function. </span><span class="koboSpan" id="kobo.128.3">It is also quite handy to get results as the program runs and adapts the code to suit your desired output during code development.</span></p>
<p><span class="koboSpan" id="kobo.129.1">In </span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.130.1">conjunction with IPython, you </span><a id="_idIndexMarker716"/><span class="koboSpan" id="kobo.131.1">can use a </span><strong class="bold"><span class="koboSpan" id="kobo.132.1">Jupyter</span></strong><span class="koboSpan" id="kobo.133.1"> notebook, which is a web interface that’s easy to use and has graphical output capabilities.</span></p>
<p><span class="koboSpan" id="kobo.134.1">As an example, imagine you need to gather information from 100 network nodes on CPU usage on the network and make a graphical report for the last hour. </span><span class="koboSpan" id="kobo.134.2">How could you do that quickly without worrying about building or testing? </span><span class="koboSpan" id="kobo.134.3">The best platform you can use is Jupyter notebook with IPython.</span></p>
<p><span class="koboSpan" id="kobo.135.1">IPython and Jupyter are also frequently used for data science and machine learning, because of their advantages in terms of interactive methods and graphical interfaces.</span></p>
<p><span class="koboSpan" id="kobo.136.1">For our network programming, IPython is a powerful tool to create </span><strong class="bold"><span class="koboSpan" id="kobo.137.1">Proof of Concept</span></strong><span class="koboSpan" id="kobo.138.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.139.1">PoC</span></strong><span class="koboSpan" id="kobo.140.1">) coding </span><a id="_idIndexMarker717"/><span class="koboSpan" id="kobo.141.1">and test new functionalities when creating solutions in Python.</span></p>
<p><span class="koboSpan" id="kobo.142.1">More on IPython</span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.143.1"> can be found at </span><a href="https://ipython.org/"><span class="koboSpan" id="kobo.144.1">https://ipython.org/</span></a><span class="koboSpan" id="kobo.145.1">. </span><span class="koboSpan" id="kobo.145.2">More on Jupyter can </span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.146.1">be found at </span><a href="https://jupyter.org/"><span class="koboSpan" id="kobo.147.1">https://jupyter.org/</span></a><span class="koboSpan" id="kobo.148.1">.</span></p>
<p><span class="koboSpan" id="kobo.149.1">With that, we have looked at the major Python interpreters. </span><span class="koboSpan" id="kobo.149.2">Now, let’s look at how Go works.</span></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.150.1">Go compiler</span></h2>
<p><span class="koboSpan" id="kobo.151.1">In </span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.152.1">Go language development, there</span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.153.1"> is no code interpretation like in Python code; instead, there’s compilation. </span><span class="koboSpan" id="kobo.153.2">This compilation is done by the Go compiler, which normally comes with the Go language package. </span><span class="koboSpan" id="kobo.153.3">The compiler reads the source code and then translates it into the bytecode of the CPU architecture where this program is going to be executed. </span><span class="koboSpan" id="kobo.153.4">When executing the compiled code, there is no need to have the compiler or the source code, only the compiled binary code.</span></p>
<p><span class="koboSpan" id="kobo.154.1">Because of this compilation, Go programs run faster than Python-based programs – in some cases, they can run 30 to 100 times faster, especially when dealing with concurrency. </span><span class="koboSpan" id="kobo.154.2">As an example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">fannkuch-redux</span></strong><span class="koboSpan" id="kobo.156.1"> benchmark, which</span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.157.1"> is used to test multicore parallelism, takes 8 seconds to run in Go, whereas</span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.158.1"> it takes 5 minutes to run in Python (source: </span><a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/fannkuchredux.html"><span class="koboSpan" id="kobo.159.1">https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/fannkuchredux.html</span></a><span class="koboSpan" id="kobo.160.1">).</span></p>
<p><span class="koboSpan" id="kobo.161.1">Although the Go language distribution provides the compiler, the Go community has started other projects as alternatives for the Go compiler. </span><span class="koboSpan" id="kobo.161.2">One of them is called </span><strong class="bold"><span class="koboSpan" id="kobo.162.1">TinyGo</span></strong><span class="koboSpan" id="kobo.163.1">, which</span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.164.1"> is used when the compiled code does not have much memory to be stored, such as in small microcontrollers or small computers. </span><span class="koboSpan" id="kobo.164.2">Therefore, TinyGo is used when memory space in the running target computer is limited. </span><span class="koboSpan" id="kobo.164.3">More on TinyGo can be </span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.165.1">found at </span><a href="https://github.com/tinygo-org/tinygo"><span class="koboSpan" id="kobo.166.1">https://github.com/tinygo-org/tinygo</span></a><span class="koboSpan" id="kobo.167.1">.</span></p>
<p><span class="koboSpan" id="kobo.168.1">Now, let’s compare both languages in terms of computing runtime.</span></p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.169.1">Pros and cons of programming runtimes</span></h2>
<p><span class="koboSpan" id="kobo.170.1">Let’s explore the pros and cons of using Go and Python for programming while focusing on the code that will run on the machine during runtime.</span></p>
<p><span class="koboSpan" id="kobo.171.1">Pros of using the</span><a id="_idIndexMarker726"/><span class="koboSpan" id="kobo.172.1"> Python runtime:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.173.1">Easy to create PoC code by using interactive Python with IPython and Jupyter notebooks</span></li>
<li><span class="koboSpan" id="kobo.174.1">Easy to create data visualization during prototyping</span></li>
<li><span class="koboSpan" id="kobo.175.1">Has a large community with different interpreters, libraries, and frameworks</span></li>
</ul>
<p><span class="koboSpan" id="kobo.176.1">Cons of using the</span><a id="_idIndexMarker727"/><span class="koboSpan" id="kobo.177.1"> Python runtime:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.178.1">Consumes more space and memory on the target running machine</span></li>
<li><span class="koboSpan" id="kobo.179.1">Consumes more CPU and is slower to complete tasks compared to Go</span></li>
<li><span class="koboSpan" id="kobo.180.1">Code is visible on the target running machine, which can be unsecure</span></li>
<li><span class="koboSpan" id="kobo.181.1">Runtime parallelism implementation is weak compared to Go</span></li>
</ul>
<p><span class="koboSpan" id="kobo.182.1">Pros of using the</span><a id="_idIndexMarker728"/><span class="koboSpan" id="kobo.183.1"> Go runtime:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.184.1">Consumes less memory and space on the target running machine</span></li>
<li><span class="koboSpan" id="kobo.185.1">Consumes less CPU and runs faster than Python</span></li>
<li><span class="koboSpan" id="kobo.186.1">Code is compiled, which is not human readable and can’t easily be decoded</span></li>
<li><span class="koboSpan" id="kobo.187.1">The runtime parallelism implementation is much better than Python</span></li>
</ul>
<p><span class="koboSpan" id="kobo.188.1">Cons of using </span><a id="_idIndexMarker729"/><span class="koboSpan" id="kobo.189.1">the Go runtime:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.190.1">More difficult to create prototypes</span></li>
<li><span class="koboSpan" id="kobo.191.1">A smaller development community and fewer runtime libraries</span></li>
</ul>
<p><span class="koboSpan" id="kobo.192.1">For network programming, Go has much more benefits compared to Python in terms of performance. </span><span class="koboSpan" id="kobo.192.2">However, as Python is an older language, it has a broader community with more network libraries and functionalities. </span></p>
<p><span class="koboSpan" id="kobo.193.1">So, choosing which language to use will depend on the use case you are working on. </span><span class="koboSpan" id="kobo.193.2">If you want something quick and wish to write less code by reusing someone else’s library, then Python is probably the best fit. </span><span class="koboSpan" id="kobo.193.3">But if you want something that has more performance, is secure, uses less memory, and can be built as one binary program, Go is your best fit. </span><span class="koboSpan" id="kobo.193.4">As the Go community grows, it will probably have more libraries that can help with network automation over time, but as it stands today, Python has more community contributions in the network automation field.</span></p>
<p><span class="koboSpan" id="kobo.194.1">In the next section, we’ll learn how we can add external libraries to our code in Go and Python.</span></p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.195.1">Using third-party libraries</span></h1>
<p><span class="koboSpan" id="kobo.196.1">When</span><a id="_idIndexMarker730"/><span class="koboSpan" id="kobo.197.1"> developing network automation, it is always worth researching tools and libraries in the community to see if you can incorporate some external code that will add functionalities or speed up your development process.</span></p>
<p><span class="koboSpan" id="kobo.198.1">In preparation to explain how to use third-party libraries, it is important to understand how libraries in general are used in Python and Go. </span><span class="koboSpan" id="kobo.198.2">We’ll detail the library-adding process in Python and Go in this section.</span></p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.199.1">Adding Python libraries</span></h2>
<p><span class="koboSpan" id="kobo.200.1">Before</span><a id="_idIndexMarker731"/><span class="koboSpan" id="kobo.201.1"> discussing how libraries are added to Python, it is important </span><a id="_idIndexMarker732"/><span class="koboSpan" id="kobo.202.1">to explain that, in Python, a </span><strong class="bold"><span class="koboSpan" id="kobo.203.1">library</span></strong><span class="koboSpan" id="kobo.204.1"> is </span><a id="_idIndexMarker733"/><span class="koboSpan" id="kobo.205.1">also known as a </span><strong class="bold"><span class="koboSpan" id="kobo.206.1">package</span></strong><span class="koboSpan" id="kobo.207.1"> or a </span><strong class="bold"><span class="koboSpan" id="kobo.208.1">module</span></strong><span class="koboSpan" id="kobo.209.1">.  </span><span class="koboSpan" id="kobo.209.2">These </span><a id="_idIndexMarker734"/><span class="koboSpan" id="kobo.210.1">three terms are used widely throughout Python documentation, which</span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.211.1"> can make some new Python developers confused. </span><span class="koboSpan" id="kobo.211.2">So, whenever you see the term “Python library”, it can also mean a package or a module.</span></p>
<p><span class="koboSpan" id="kobo.212.1">A library in Python can be external, internal, or built-in. </span><span class="koboSpan" id="kobo.212.2">These external libraries are also known as third-party modules, packages, or libraries.</span></p>
<p><span class="koboSpan" id="kobo.213.1">To use a</span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.214.1"> library in Python, you just need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">import</span></strong><span class="koboSpan" id="kobo.216.1"> statement at the beginning of the code. </span><span class="koboSpan" id="kobo.216.2">If the library is not found, it will raise an error exception called </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">ModuleNotFoundError</span></strong><span class="koboSpan" id="kobo.218.1">, as shown here:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.219.1">
$ python
Python 3.10.4 (main, Apr  8 2022, 17:35:13) on linux
Type "help", "copyright", "credits" or "license" for more information.
</span><span class="koboSpan" id="kobo.219.2">&gt;&gt;&gt; import netmiko
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.220.1">ModuleNotFoundError</span></strong><span class="koboSpan" id="kobo.221.1">: No module named 'netmiko'</span></pre>
<p><span class="koboSpan" id="kobo.222.1">In the preceding example, the Python interpreter threw an exception called </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">ModuleNotFoundError</span></strong><span class="koboSpan" id="kobo.224.1">, which means the package is not installed or is not in the search path. </span><span class="koboSpan" id="kobo.224.2">The search path is normally included in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">path</span></strong><span class="koboSpan" id="kobo.226.1"> variable inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">sys</span></strong><span class="koboSpan" id="kobo.228.1"> package, as shown in the following example:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.229.1">
$ python3.10
Python 3.10.4 (main, Apr  8 2022, 17:35:13) on linux
Type "help", "copyright", "credits" or "license" for more information.
</span><span class="koboSpan" id="kobo.229.2">&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
['', '/usr/lib/python3.10', '/usr/lib/python3.10/lib-dynload', '/usr/local/lib/python3.10/dist-packages', '/usr/lib/python3/dist-packages']</span></pre>
<p><span class="koboSpan" id="kobo.230.1">Note that </span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.231.1">in the preceding example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">sys.path</span></strong><span class="koboSpan" id="kobo.233.1"> variable has been pre-filed with a list of system paths, but you can append more if needed.</span></p>
<p><span class="koboSpan" id="kobo.234.1">Now, let’s discuss how the built-in, standard, and external modules are used in Python.</span></p>
<h3><span class="koboSpan" id="kobo.235.1">Using Python built-in libraries</span></h3>
<p><span class="koboSpan" id="kobo.236.1">The </span><a id="_idIndexMarker738"/><span class="koboSpan" id="kobo.237.1">built-in modules (or libraries) are modules that can be</span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.238.1"> imported, but they come within the Python runtime program. </span><span class="koboSpan" id="kobo.238.2">They are not external files to be added, so they don’t need to be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">sys.path</span></strong><span class="koboSpan" id="kobo.240.1"> variable. </span><span class="koboSpan" id="kobo.240.2">There are also built-in functions, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">print</span></strong><span class="koboSpan" id="kobo.242.1">, but built-in modules are the ones that you are going to explicitly import before using them, such as the popular one known as </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">sys</span></strong><span class="koboSpan" id="kobo.244.1">, or others such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">array</span></strong><span class="koboSpan" id="kobo.246.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">time</span></strong><span class="koboSpan" id="kobo.248.1">. </span><span class="koboSpan" id="kobo.248.2">These built-in modules are not external programs like they are in Python standard libraries, but they are included in the binary code of the interpreter, like in CPython.</span></p>
<h3><span class="koboSpan" id="kobo.249.1">Using Python standard libraries</span></h3>
<p><span class="koboSpan" id="kobo.250.1">These </span><a id="_idIndexMarker740"/><span class="koboSpan" id="kobo.251.1">are</span><a id="_idIndexMarker741"/><span class="koboSpan" id="kobo.252.1"> modules that come with the Python distribution, but they are separate Python files that are added when you state </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">import</span></strong><span class="koboSpan" id="kobo.254.1"> at the beginning of the Python code; they need to be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">sys.path</span></strong><span class="koboSpan" id="kobo.256.1"> variable. </span><span class="koboSpan" id="kobo.256.2">These modules are Python programs and can be found in the Python library installation directory, such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">socket</span></strong><span class="koboSpan" id="kobo.258.1"> library, as illustrated in the following example:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.259.1">
$ python3.10
Python 3.10.4 (main, Apr  8 2022, 17:35:13) on linux
Type "help", "copyright", "credits" or "license" for more information.
</span><span class="koboSpan" id="kobo.259.2">&gt;&gt;&gt; import inspect
&gt;&gt;&gt; import socket
&gt;&gt;&gt; inspect.getfile(socket)
'</span><strong class="bold"><span class="koboSpan" id="kobo.260.1">/usr/lib/python3.10/socket.py</span></strong><span class="koboSpan" id="kobo.261.1">'</span></pre>
<p><span class="koboSpan" id="kobo.262.1">Note</span><a id="_idIndexMarker742"/><span class="koboSpan" id="kobo.263.1"> that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">/usr/lib/pytho3.10/socket.py</span></strong><span class="koboSpan" id="kobo.265.1"> location will depend on the operating system and version </span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.266.1">of Python. </span><span class="koboSpan" id="kobo.266.2">In the preceding example, Linux Ubuntu and Python 3.10 are being used. </span><span class="koboSpan" id="kobo.266.3">A list of all standard libraries for Python 3.10.x can be found at </span><a href="https://github.com/python/cpython/tree/3.10/Lib"><span class="koboSpan" id="kobo.267.1">https://github.com/python/cpython/tree/3.10/Lib</span></a><span class="koboSpan" id="kobo.268.1">. </span><span class="koboSpan" id="kobo.268.2">More information about each built-in and standard library for Python 3.x can be found at </span><a href="https://docs.python.org/3/library/"><span class="koboSpan" id="kobo.269.1">https://docs.python.org/3/library/</span></a><span class="koboSpan" id="kobo.270.1">.</span></p>
<h3><span class="koboSpan" id="kobo.271.1">Using third-party Python libraries</span></h3>
<p><span class="koboSpan" id="kobo.272.1">External libraries </span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.273.1">or third-party libraries are modules (or packages) in Python that are not included with the Python distribution and need to be</span><a id="_idIndexMarker745"/><span class="koboSpan" id="kobo.274.1"> installed manually before they’re used. </span><span class="koboSpan" id="kobo.274.2">These modules are normally not maintained by the Python library team but by developers of the Python community, which are not necessarily related to the Python main distribution.</span></p>
<p><span class="koboSpan" id="kobo.275.1">As we discussed in </span><a href="B18165_05.xhtml#_idTextAnchor127"><em class="italic"><span class="koboSpan" id="kobo.276.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.277.1">, before adding the external module to your code, have a look in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">LICENSE</span></strong><span class="koboSpan" id="kobo.279.1"> file and check if any limitations might impact the usage of this module on your code or in your organization.</span></p>
<p><span class="koboSpan" id="kobo.280.1">The Python community has </span><a id="_idIndexMarker746"/><span class="koboSpan" id="kobo.281.1">organized a group called </span><strong class="bold"><span class="koboSpan" id="kobo.282.1">Python Packaging Authority</span></strong><span class="koboSpan" id="kobo.283.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.284.1">PyPA</span></strong><span class="koboSpan" id="kobo.285.1">), which is responsible for documenting and creating the infrastructure for Python developers to create and publish Python external packages. </span><span class="koboSpan" id="kobo.285.2">The group is responsible for maintaining a set of tools that are used to create, install, and maintain Python packages. </span><span class="koboSpan" id="kobo.285.3">The most popular tool is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">pip</span></strong><span class="koboSpan" id="kobo.287.1">. </span></p>
<p><span class="koboSpan" id="kobo.288.1">PyPA is also responsible for </span><a id="_idIndexMarker747"/><span class="koboSpan" id="kobo.289.1">maintaining </span><a href="http://pypi.org"><span class="koboSpan" id="kobo.290.1">pypi.org</span></a><span class="koboSpan" id="kobo.291.1">, where all packages that can be included with </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">pip</span></strong><span class="koboSpan" id="kobo.293.1"> are documented. </span><span class="koboSpan" id="kobo.293.2">On this site, there is a search engine for finding packages and also documentation for developers that want to contribute or share their packages. </span><span class="koboSpan" id="kobo.293.3">Note that the source code for the packages is not on the </span><a href="http://pypi.org"><span class="koboSpan" id="kobo.294.1">pypi.org</span></a><span class="koboSpan" id="kobo.295.1"> site, but in repositories such as </span><strong class="bold"><span class="koboSpan" id="kobo.296.1">GitHub</span></strong><span class="koboSpan" id="kobo.297.1">.</span></p>
<p><span class="koboSpan" id="kobo.298.1">Now, let’s go through an example of the process of using a third-party package in our code. </span><span class="koboSpan" id="kobo.298.2">The </span><a id="_idIndexMarker748"/><span class="koboSpan" id="kobo.299.1">package that we are adding as an example is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">netmiko</span></strong><span class="koboSpan" id="kobo.301.1">:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.302.1">Check if the package is included on </span><a href="http://pypi.org"><span class="koboSpan" id="kobo.303.1">pypi.org</span></a><span class="koboSpan" id="kobo.304.1"> as per PyPA. </span><span class="koboSpan" id="kobo.304.2">If so, we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">pip</span></strong><span class="koboSpan" id="kobo.306.1"> to add the package to our local Python environment.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.307.1">Yes, it is: </span><a href="https://pypi.org/project/netmiko/"><span class="koboSpan" id="kobo.308.1">https://pypi.org/project/netmiko/</span></a><span class="koboSpan" id="kobo.309.1">.</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.310.1">Read the </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">LICENSE</span></strong><span class="koboSpan" id="kobo.312.1"> file and check if it is allowed to be used in your organization.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.313.1">This</span><a id="_idIndexMarker749"/><span class="koboSpan" id="kobo.314.1"> license is based on MIT, which is less restrictive, so we can use it: </span><a href="https://github.com/ktbyers/netmiko/blob/develop/LICENSE"><span class="koboSpan" id="kobo.315.1">https://github.com/ktbyers/netmiko/blob/develop/LICENSE</span></a><span class="koboSpan" id="kobo.316.1">.</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.317.1">Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">pip</span></strong><span class="koboSpan" id="kobo.319.1"> to install the package to your local Python environment, as shown in the following example:</span><pre class="console">
<strong class="bold"><span class="koboSpan" id="kobo.320.1">$ pip install netmiko</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.321.1">Installing collected packages: netmiko</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.322.1">Successfully installed netmiko-4.1.0</span></strong></pre></li>
<li><span class="koboSpan" id="kobo.323.1">Check if you can import and locate where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">netmiko</span></strong><span class="koboSpan" id="kobo.325.1"> library is installed:</span><pre class="console">
<strong class="bold"><span class="koboSpan" id="kobo.326.1">&gt;&gt;&gt; import netmiko</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.327.1">&gt;&gt;&gt; import inspect</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.328.1">&gt;&gt;&gt; inspect.getfile(netmiko)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.329.1">'/home/claus/.local/lib/python3.10/site-packages/netmiko/__init__.py'</span></strong></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.330.1">In the preceding example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">netmiko</span></strong><span class="koboSpan" id="kobo.332.1"> package has been installed using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">pip</span></strong><span class="koboSpan" id="kobo.334.1"> tool, and the library is located under my home directory, </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">/home/claus</span></strong><span class="koboSpan" id="kobo.336.1">. </span><span class="koboSpan" id="kobo.336.2">However, this varies, depending on the version of Python and the operating system used. </span><span class="koboSpan" id="kobo.336.3">It also varies within Linux, depending on the distribution, such as Debian, Ubuntu, or Red Hat.</span></p>
<p><span class="koboSpan" id="kobo.337.1">Just keep in mind that third-party Python libraries will be installed normally under a directory called </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">site-packages</span></strong><span class="koboSpan" id="kobo.339.1">. </span><span class="koboSpan" id="kobo.339.2">Here are some examples of where it can be located for each operating system: </span></p>
<ul>
<li><span class="koboSpan" id="kobo.340.1">For macOS: </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages</span></strong></li>
<li><span class="koboSpan" id="kobo.342.1">For Windows: </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">C:\Users\username\AppData\Local\Programs\Python\Python39\lib\site-packages</span></strong></li>
<li><span class="koboSpan" id="kobo.344.1">For Linux Ubuntu: </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">/usr/lib/python3.9/site-packages</span></strong></li>
</ul>
<p><span class="koboSpan" id="kobo.346.1">A</span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.347.1"> complete list of all packages that you have installed on</span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.348.1"> your system can be found by typing the following command: </span></p>
<pre class="console"><span class="koboSpan" id="kobo.349.1">
pip list -v</span></pre>
<p><span class="koboSpan" id="kobo.350.1">Now, let’s explore how we can use libraries and third-party libraries in Go.</span></p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.351.1">Adding Go libraries</span></h2>
<p><span class="koboSpan" id="kobo.352.1">In</span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.353.1"> contrast </span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.354.1">with Python, Go only has two types of libraries: the standard libraries and the third-party libraries. </span><span class="koboSpan" id="kobo.354.2">For Go, there is no concept of built-in libraries because it does not have an interpreter; instead, it has a compiler. </span><span class="koboSpan" id="kobo.354.3">The reason is that an interpreter can include a few libraries in its binary, which are called built-in libraries.</span></p>
<p><span class="koboSpan" id="kobo.355.1">To add a library to your Go code, you will need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">import</span></strong><span class="koboSpan" id="kobo.357.1"> statement, which is the same in Python but the syntax is a bit different.</span></p>
<p><span class="koboSpan" id="kobo.358.1">Similar to Python, in Go, a library is also known </span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.359.1">as a </span><strong class="bold"><span class="koboSpan" id="kobo.360.1">package</span></strong><span class="koboSpan" id="kobo.361.1">.</span></p>
<p><span class="koboSpan" id="kobo.362.1">Let’s have a look at how to add standard libraries and then third-party libraries in Go.</span></p>
<h3><span class="koboSpan" id="kobo.363.1">Using standard libraries in Go</span></h3>
<p><span class="koboSpan" id="kobo.364.1">Each version of Go includes a set of standard libraries that are installed with the Go distribution. </span><span class="koboSpan" id="kobo.364.2">These </span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.365.1">standard libraries are also Go programs that, when imported, will be combined with your code during compilation.</span></p>
<p><span class="koboSpan" id="kobo.366.1">A list of standard libraries can be found at </span><a href="https://pkg.go.dev/std"><span class="koboSpan" id="kobo.367.1">https://pkg.go.dev/std</span></a><span class="koboSpan" id="kobo.368.1">. </span><span class="koboSpan" id="kobo.368.2">The </span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.369.1">website is very useful because it includes an explanation of each library (or package).</span></p>
<p><span class="koboSpan" id="kobo.370.1">The </span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.371.1">standard libraries can also be found in your local development filesystem. </span><span class="koboSpan" id="kobo.371.2">Go’s installation includes all standard libraries, such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">fmt</span></strong><span class="koboSpan" id="kobo.373.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">math</span></strong><span class="koboSpan" id="kobo.375.1"> packages. </span><span class="koboSpan" id="kobo.375.2">The location of these standard libraries will vary for each operating system but can be found by looking into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">GOROOT</span></strong><span class="koboSpan" id="kobo.377.1"> environment variable.</span></p>
<p><span class="koboSpan" id="kobo.378.1">Most operating systems do not populate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">GOROOT</span></strong><span class="koboSpan" id="kobo.380.1"> variable, so they will use the Go language’s default location. </span><span class="koboSpan" id="kobo.380.2">To find out your default location, you can run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">go env</span></strong><span class="koboSpan" id="kobo.382.1"> command, as shown here:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.383.1">
$ go env GOROOT
/usr/lib/go-1.19</span></pre>
<p><span class="koboSpan" id="kobo.384.1">In the preceding example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">GOROOT</span></strong><span class="koboSpan" id="kobo.386.1"> is located in </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">/usr/lib/go-1.19</span></strong><span class="koboSpan" id="kobo.388.1">.</span></p>
<p><span class="koboSpan" id="kobo.389.1">To learn how the libraries are located, let’s use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">fmt</span></strong><span class="koboSpan" id="kobo.391.1"> standard library to print a string to the computer terminal:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.392.1">
package main
import "fmt"
func main() {
    fmt.Println("My code is awesome")
}</span></pre>
<p><span class="koboSpan" id="kobo.393.1">In the preceding example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">import</span></strong><span class="koboSpan" id="kobo.395.1"> statement tells the Go compiler that it needs to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">fmt</span></strong><span class="koboSpan" id="kobo.397.1"> package, which in this case is a standard library package. </span><span class="koboSpan" id="kobo.397.2">In this example, the Go compiler will search for this package, starting by looking in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">/usr/lib/go-1.19</span></strong><span class="koboSpan" id="kobo.399.1"> directory.</span></p>
<p><span class="koboSpan" id="kobo.400.1">To be more specific, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">fmt</span></strong><span class="koboSpan" id="kobo.402.1"> package is located at </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">/usr/lib/go-1.19/src/fmt</span></strong><span class="koboSpan" id="kobo.404.1">. </span><span class="koboSpan" id="kobo.404.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">Println</span></strong><span class="koboSpan" id="kobo.406.1"> function that’s being used in this example is described in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">/usr/lib/go-1.19/src/fmt/print.go</span></strong><span class="koboSpan" id="kobo.408.1"> file.</span></p>
<p><span class="koboSpan" id="kobo.409.1">In Go, all </span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.410.1">programs have to belong to a package, and the package name is described in the first line of the code. </span><span class="koboSpan" id="kobo.410.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">fmt</span></strong><span class="koboSpan" id="kobo.412.1"> directory (</span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">/usr/lib/go-1.19/src/fmt</span></strong><span class="koboSpan" id="kobo.414.1">), all the files included in the directory have a first line that contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">package fmt</span></strong><span class="koboSpan" id="kobo.416.1"> statement. </span><span class="koboSpan" id="kobo.416.2">This includes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">scan.go</span></strong><span class="koboSpan" id="kobo.418.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">format.go</span></strong><span class="koboSpan" id="kobo.420.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">print.go</span></strong><span class="koboSpan" id="kobo.422.1"> files, which are located in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">fmt</span></strong><span class="koboSpan" id="kobo.424.1"> directory.</span></p>
<p><span class="koboSpan" id="kobo.425.1">Other examples</span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.426.1"> of standard libraries in Go can be found in your local Go installation, normally under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">src</span></strong><span class="koboSpan" id="kobo.428.1"> directory. </span><span class="koboSpan" id="kobo.428.2">In the preceding example, it is under </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">/usr/lib/go-1.19/src</span></strong><span class="koboSpan" id="kobo.430.1">. </span><span class="koboSpan" id="kobo.430.2">Some other examples include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">math</span></strong><span class="koboSpan" id="kobo.432.1"> package, located at </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">/usr/lib/go-1.19/src/math/</span></strong><span class="koboSpan" id="kobo.434.1">, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">time</span></strong><span class="koboSpan" id="kobo.436.1"> package, located at </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">/usr/lib/go-1.19/src/time/</span></strong><span class="koboSpan" id="kobo.438.1">.</span></p>
<p><span class="koboSpan" id="kobo.439.1">Here is another example, which uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">math</span></strong><span class="koboSpan" id="kobo.441.1"> standard library:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.442.1">
package main
import (
    "fmt"
    "math"
)
func main() {
    fmt.Println("Square root of 2 is", math.Sqrt(2))
}</span></pre>
<p><span class="koboSpan" id="kobo.443.1">In the preceding example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">math</span></strong><span class="koboSpan" id="kobo.445.1"> library uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">Sqrt</span></strong><span class="koboSpan" id="kobo.447.1"> function, which is described in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">/usr/lib/go-1.19/src/math/sqrt.go</span></strong><span class="koboSpan" id="kobo.449.1"> file. </span><span class="koboSpan" id="kobo.449.2">Again, all the files in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">math</span></strong><span class="koboSpan" id="kobo.451.1"> directory have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">package math</span></strong><span class="koboSpan" id="kobo.453.1"> statement on their first line. </span></p>
<p><span class="koboSpan" id="kobo.454.1">Now, let’s learn how to add third-party libraries to Go.</span></p>
<h3><span class="koboSpan" id="kobo.455.1">Using third-party libraries in Go</span></h3>
<p><span class="koboSpan" id="kobo.456.1">Third-party library</span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.457.1"> packages in Go are added in a similar </span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.458.1">way to standard libraries – by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">import</span></strong><span class="koboSpan" id="kobo.460.1"> statement in your code. </span><span class="koboSpan" id="kobo.460.2">However, the underlying process of adding these packages to the Go development environment is a bit different in terms of a few characteristics.</span></p>
<p><span class="koboSpan" id="kobo.461.1">In the </span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.462.1">case of third-party packages, the compiler needs to search for new files containing the package in a different path, which is populated in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">GOPATH</span></strong><span class="koboSpan" id="kobo.464.1"> environment variable. </span><span class="koboSpan" id="kobo.464.2">Like </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">GOROOT</span></strong><span class="koboSpan" id="kobo.466.1">, you don’t need to populate </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">GOPATH</span></strong><span class="koboSpan" id="kobo.468.1"> as the Go compiler has a default location for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">GOPATH</span></strong><span class="koboSpan" id="kobo.470.1"> variable.</span></p>
<p><span class="koboSpan" id="kobo.471.1">In our Go example, let’s check the default location for </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">GOPATH</span></strong><span class="koboSpan" id="kobo.473.1"> by running the following command:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.474.1">
$ go env GOPATH
/home/claus/go</span></pre>
<p><span class="koboSpan" id="kobo.475.1">As we can see, the default location for </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">GOPATH</span></strong><span class="koboSpan" id="kobo.477.1"> is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">go</span></strong><span class="koboSpan" id="kobo.479.1"> directory inside my home directory (</span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">/home/claus</span></strong><span class="koboSpan" id="kobo.481.1">).</span></p>
<p><span class="koboSpan" id="kobo.482.1">In Go, third-party libraries can be added by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">get</span></strong><span class="koboSpan" id="kobo.484.1"> subcommand on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">go</span></strong><span class="koboSpan" id="kobo.486.1"> command line, as shown here:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.487.1">
$ go get golang.org/x/crypto
go: downloading golang.org/x/crypto v0.0.0-20220622213112-05595931fe9d
go: downloading golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1
go: added golang.org/x/crypto v0.0.0-20220622213112-05595931fe9d</span></pre>
<p><span class="koboSpan" id="kobo.488.1">In the preceding example, we added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">x/crypto</span></strong><span class="koboSpan" id="kobo.490.1"> package. </span><span class="koboSpan" id="kobo.490.2">Note that all other dependencies of the package are also added; in this example, the other dependency is </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">x/sys</span></strong><span class="koboSpan" id="kobo.492.1">. </span><span class="koboSpan" id="kobo.492.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">get</span></strong><span class="koboSpan" id="kobo.494.1"> subcommand also stores the version of the package – in this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">v0.0.0-20220622213112-05595931fe9d</span></strong><span class="koboSpan" id="kobo.496.1">.</span></p>
<p><span class="koboSpan" id="kobo.497.1">Then, the package is saved under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">GOPATH</span></strong><span class="koboSpan" id="kobo.499.1"> directory. </span><span class="koboSpan" id="kobo.499.2">In the preceding example, it is saved at </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">/home/claus/go/pkg/mod/golang.org/x/crypto@&lt;VERSION&gt;</span></strong><span class="koboSpan" id="kobo.501.1">.</span></p>
<p><span class="koboSpan" id="kobo.502.1">Every time you run </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">go get</span></strong><span class="koboSpan" id="kobo.504.1"> and there is a new version available, Go stores the new version and keeps the old one in a different directory.</span></p>
<p><span class="koboSpan" id="kobo.505.1">You don’t need to run </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">go get</span></strong><span class="koboSpan" id="kobo.507.1"> when adding a third-party library. </span><span class="koboSpan" id="kobo.507.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">get</span></strong><span class="koboSpan" id="kobo.509.1"> command is sometimes</span><a id="_idIndexMarker763"/><span class="koboSpan" id="kobo.510.1"> invoked when you run </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">go build</span></strong><span class="koboSpan" id="kobo.512.1"> if the package has not been downloaded or cached, as shown here:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.513.1">
$ go build
go: downloading golang.org/x/crypto v0.0.0-20220622213112-05595931fe9d</span></pre>
<p><span class="koboSpan" id="kobo.514.1">In the preceding example, the Go program had an </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">import</span></strong><span class="koboSpan" id="kobo.516.1"> statement:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.517.1">
import (
    "golang.org/x/crypto/ssh"
)</span></pre>
<p><span class="koboSpan" id="kobo.518.1">After</span><a id="_idIndexMarker764"/><span class="koboSpan" id="kobo.519.1"> adding a third-party library, Go also updates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">go.mod</span></strong><span class="koboSpan" id="kobo.521.1"> file. </span><span class="koboSpan" id="kobo.521.2">This file is required to keep track of the versions of the packages that are added to your Go program. </span><span class="koboSpan" id="kobo.521.3">The following is the content of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">go.mod</span></strong><span class="koboSpan" id="kobo.523.1"> file for the preceding examples:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.524.1">
$ cat go.mod 
module connect
 
go 1.19
require (
    golang.org/x/crypto v0.0.0-20220622213112-05595931fe9d
)
require golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1 // indirect</span></pre>
<p><span class="koboSpan" id="kobo.525.1">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">go.mod</span></strong><span class="koboSpan" id="kobo.527.1"> file also stores the versions of the packages for all dependencies. </span><span class="koboSpan" id="kobo.527.2">In the preceding example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">x/sys</span></strong><span class="koboSpan" id="kobo.529.1"> package version is also stored in the file.</span></p>
<p><span class="koboSpan" id="kobo.530.1">Now that you’re familiar with adding third-party libraries to Go and Python, let’s dive into the next section and look at some libraries that can be used to access the network.</span></p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.531.1">Accessing network devices using libraries</span></h1>
<p><span class="koboSpan" id="kobo.532.1">So far, we have </span><a id="_idIndexMarker765"/><span class="koboSpan" id="kobo.533.1">discussed how to run and work</span><a id="_idIndexMarker766"/><span class="koboSpan" id="kobo.534.1"> with libraries in Python and Go. </span><span class="koboSpan" id="kobo.534.2">Now, let’s focus on how to use Python and Go to access network devices, which is one of the most important points in our network automation work.</span></p>
<p><span class="koboSpan" id="kobo.535.1">In </span><a href="B18165_03.xhtml#_idTextAnchor067"><em class="italic"><span class="koboSpan" id="kobo.536.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.537.1">, we discussed several methods to access network devices. </span><span class="koboSpan" id="kobo.537.2">One of the most popular ones is using a </span><strong class="bold"><span class="koboSpan" id="kobo.538.1">command-line interface</span></strong><span class="koboSpan" id="kobo.539.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.540.1">CLI</span></strong><span class="koboSpan" id="kobo.541.1">). </span><span class="koboSpan" id="kobo.541.2">We also discussed SNMP, NETCONF, gRPC, and gNMI. </span><span class="koboSpan" id="kobo.541.3">In this section, we are going to explore a few examples of how to use libraries to access network devices, mainly using the CLI. </span><span class="koboSpan" id="kobo.541.4">Later, we are going to explain and show the libraries for accessing the network using other methods. </span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.542.1">Libraries to access the network via a CLI</span></h2>
<p><span class="koboSpan" id="kobo.543.1">There are </span><a id="_idIndexMarker767"/><span class="koboSpan" id="kobo.544.1">lots of libraries on the internet that can access network devices, and some of them might be obsolete or not used anymore. </span><span class="koboSpan" id="kobo.544.2">Here, we are going to present the most popular ones in chronological order, from the old to the newer ones.</span></p>
<p><span class="koboSpan" id="kobo.545.1">The following examples are going to collect the uptime of the network device by sending the </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">uptime</span></strong><span class="koboSpan" id="kobo.547.1"> command via the CLI on an SSH connection.</span></p>
<h3><span class="koboSpan" id="kobo.548.1">Using Python Paramiko</span></h3>
<p><span class="koboSpan" id="kobo.549.1">Paramiko is </span><a id="_idIndexMarker768"/><span class="koboSpan" id="kobo.550.1">perhaps one of the oldest</span><a id="_idIndexMarker769"/><span class="koboSpan" id="kobo.551.1"> implementations for accessing network devices via the CLI. </span><span class="koboSpan" id="kobo.551.2">The first release was published in 2003. </span><span class="koboSpan" id="kobo.551.3">Today, it has more than 300 contributors and there are almost 2,000 packages </span><a id="_idIndexMarker770"/><span class="koboSpan" id="kobo.552.1">depending on Paramiko (</span><a href="https://github.com/paramiko/paramiko/network/dependents"><span class="koboSpan" id="kobo.553.1">https://github.com/paramiko/paramiko/network/dependents</span></a><span class="koboSpan" id="kobo.554.1">).</span></p>
<p><span class="koboSpan" id="kobo.555.1">As we discussed in </span><a href="B18165_03.xhtml#_idTextAnchor067"><em class="italic"><span class="koboSpan" id="kobo.556.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.557.1">, the correct way to use CLI libraries is</span><a id="_idIndexMarker771"/><span class="koboSpan" id="kobo.558.1"> via </span><strong class="bold"><span class="koboSpan" id="kobo.559.1">Secure Shell</span></strong><span class="koboSpan" id="kobo.560.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.561.1">SSH</span></strong><span class="koboSpan" id="kobo.562.1">). </span><span class="koboSpan" id="kobo.562.2">Paramiko </span><a id="_idIndexMarker772"/><span class="koboSpan" id="kobo.563.1">implements secure cryptography for SSH using a lower-level library called PyCrypto (</span><a href="http://pycrypto.org/"><span class="koboSpan" id="kobo.564.1">http://pycrypto.org/</span></a><span class="koboSpan" id="kobo.565.1">).</span></p>
<p><span class="koboSpan" id="kobo.566.1">Let’s look at a </span><a id="_idIndexMarker773"/><span class="koboSpan" id="kobo.567.1">simple example to obtain the uptime of the network host:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.568.1">
import paramiko
TARGET = {
    "hostname": "10.0.4.1",
    "username": "netlab",
    "password": "netlab",
}
ssh = paramiko.SSHClient()
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
ssh.connect(**TARGET)
stdin, stdout, stderr = ssh.exec_command("uptime")
stdin.close()
print(stdout.read().decode("ascii"))</span></pre>
<p><span class="koboSpan" id="kobo.569.1">If the</span><a id="_idIndexMarker774"/><span class="koboSpan" id="kobo.570.1"> connection is successful, the </span><a id="_idIndexMarker775"/><span class="koboSpan" id="kobo.571.1">output of the preceding program will be the uptime of the network host: </span></p>
<pre class="console"><span class="koboSpan" id="kobo.572.1">
13:22:57 up 59 min,  0 users,  load average: 0.02, 0.07, 0.08</span></pre>
<h3><span class="koboSpan" id="kobo.573.1">Using Python Netmiko</span></h3>
<p><span class="koboSpan" id="kobo.574.1">Netmiko is</span><a id="_idIndexMarker776"/><span class="koboSpan" id="kobo.575.1"> also another popular library for </span><a id="_idIndexMarker777"/><span class="koboSpan" id="kobo.576.1">accessing network devices via the CLI. </span><span class="koboSpan" id="kobo.576.2">The first release was published in 2014 and was built on top of Paramiko to simplify connections to network devices. </span><span class="koboSpan" id="kobo.576.3">In summary, Netmiko is simpler than Paramiko and more focused on network devices.</span></p>
<p><span class="koboSpan" id="kobo.577.1">Let’s learn what the same</span><a id="_idIndexMarker778"/><span class="koboSpan" id="kobo.578.1"> example for Paramiko will look like when using Netmiko:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.579.1">
import netmiko
host = {
    "host": "10.0.4.1",
    "username": "netlab",
    "password": "netlab",
    "device_type": "linux_ssh",
}
with netmiko.ConnectHandler(**host) as netcon:
    output = netcon.send_command(command)
print(output)</span></pre>
<p><span class="koboSpan" id="kobo.580.1">As you </span><a id="_idIndexMarker779"/><span class="koboSpan" id="kobo.581.1">can see, the implementation of the Netmiko code is just 2 lines, with much smaller and simpler code compared to Paramiko. </span><span class="koboSpan" id="kobo.581.2">The big advantage of the Netmiko library is that it handles the device’s command prompt automatically and works with ease when changing the configuration in privilege mode since the prompt normally changes. </span><span class="koboSpan" id="kobo.581.3">In the preceding example, the device type was </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">linux_ssh</span></strong><span class="koboSpan" id="kobo.583.1"> because our target host was a Linux device. </span></p>
<p><span class="koboSpan" id="kobo.584.1">Netmiko can support</span><a id="_idIndexMarker780"/><span class="koboSpan" id="kobo.585.1"> dozens of network devices, including Cisco, Huawei, Juniper, and Alcatel. </span><span class="koboSpan" id="kobo.585.2">A complete list of devices can be found here: </span><a href="https://github.com/ktbyers/netmiko/blob/develop/PLATFORMS.md"><span class="koboSpan" id="kobo.586.1">https://github.com/ktbyers/netmiko/blob/develop/PLATFORMS.md</span></a><span class="koboSpan" id="kobo.587.1">.</span></p>
<h3><span class="koboSpan" id="kobo.588.1">Using Python AsyncSSH</span></h3>
<p><span class="koboSpan" id="kobo.589.1">AsyncSSH is</span><a id="_idIndexMarker781"/><span class="koboSpan" id="kobo.590.1"> a modern implementation </span><a id="_idIndexMarker782"/><span class="koboSpan" id="kobo.591.1">of </span><a id="_idIndexMarker783"/><span class="koboSpan" id="kobo.592.1">Python </span><strong class="bold"><span class="koboSpan" id="kobo.593.1">AsyncIO</span></strong><span class="koboSpan" id="kobo.594.1"> for SSH. </span><span class="koboSpan" id="kobo.594.2">Python AsyncIO was introduced in Python version 3.4 and allows Python to work concurrently using async/await syntax and provides high performance for network access. </span><span class="koboSpan" id="kobo.594.3">To use AsyncSSH, you will need to have Python version 3.6 or higher.</span></p>
<p><span class="koboSpan" id="kobo.595.1">In summary, AsyncSSH provides better performance for multiple hosts, but it is a lower-level implementation that requires more complexity in your code to handle network devices in comparison to Netmiko.</span></p>
<p><span class="koboSpan" id="kobo.596.1">The same</span><a id="_idIndexMarker784"/><span class="koboSpan" id="kobo.597.1"> example of getting uptime for AsyncSSH can be written like so:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.598.1">
import asyncio, asyncssh, sys
TARGET = {
    "host": "10.0.4.1",
    "username": "netlab",
    "password": "netlab",
    "known_hosts": None,
}
async def run_client() -&gt; None:
    async with asyncssh.connect(**TARGET) as conn:
       result = await conn.run("uptime", check=True)
       print(result.stdout, end="")
try:
    asyncio.get_event_loop().run_until_complete( run_client() )
except (OSError, asyncssh.Error) as execrr:
        sys.exit("Connection failed:" + str(execrr))</span></pre>
<p><span class="koboSpan" id="kobo.599.1">Note that </span><a id="_idIndexMarker785"/><span class="koboSpan" id="kobo.600.1">when using AsyncSSH, you will have to work with routines and events, as instructed by Python AsyncIO and the preceding example. </span><span class="koboSpan" id="kobo.600.2">If you want to dig into this, some great documentation can be </span><a id="_idIndexMarker786"/><span class="koboSpan" id="kobo.601.1">found at https://realpython.com/async-io-python/.</span></p>
<h3><span class="koboSpan" id="kobo.602.1">Using Python Scrapli</span></h3>
<p><span class="koboSpan" id="kobo.603.1">In comparison</span><a id="_idIndexMarker787"/><span class="koboSpan" id="kobo.604.1"> to Netmiko, Scrapli is newer. </span><span class="koboSpan" id="kobo.604.2">The</span><a id="_idIndexMarker788"/><span class="koboSpan" id="kobo.605.1"> first release was published in 2019 and is also built on top of Paramiko but has capabilities to use AsyncSSH, which claims to improve performance when accessing multiple devices. </span><span class="koboSpan" id="kobo.605.2">The idea of the name Scrapli came from </span><em class="italic"><span class="koboSpan" id="kobo.606.1">scrape cli</span></em><span class="koboSpan" id="kobo.607.1">, similar to someone scraping the screen. </span><span class="koboSpan" id="kobo.607.2">This is because Scrapli’s main objective is to interpret text from the network terminal using the CLI.</span></p>
<p><span class="koboSpan" id="kobo.608.1">Scrapli </span><a id="_idIndexMarker789"/><span class="koboSpan" id="kobo.609.1">was built to allow its users to interpret prompts from multi-vendor network devices such as Netmiko but with a reduced set of platforms. </span><span class="koboSpan" id="kobo.609.2">The 2022.7.30 version supports Cisco, Juniper, and Arista. </span><span class="koboSpan" id="kobo.609.3">One advantage of using Scrapli is that it also supports NETCONF.</span></p>
<p><span class="koboSpan" id="kobo.610.1">The following is the same example to get uptime but using Scrapli:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.611.1">
from scrapli.driver import GenericDriver
TARGET = {
    "host": "10.0.4.1",
    "auth_username": "netlab",
    "auth_password": "netlab",
    "auth_strict_key": False,
}
with GenericDriver(**TARGET) as con:
    command_return = con.send_command("uptime")
print(command_return.result)</span></pre>
<p><span class="koboSpan" id="kobo.612.1">So far, we have learned about the most popular libraries for accessing network terminals using Python. </span><span class="koboSpan" id="kobo.612.2">Now, let’s learn we can do this with the Go language. </span></p>
<h3><span class="koboSpan" id="kobo.613.1">Using Go ssh</span></h3>
<p><span class="koboSpan" id="kobo.614.1">In contrast </span><a id="_idIndexMarker790"/><span class="koboSpan" id="kobo.615.1">to Python, Go does not have a large</span><a id="_idIndexMarker791"/><span class="koboSpan" id="kobo.616.1"> community for working with libraries that can handle network devices. </span><span class="koboSpan" id="kobo.616.2">Therefore, in some particular cases, you might have to write your own scrape mechanism to interpret the remote network terminal via the CLI. </span><span class="koboSpan" id="kobo.616.3">The problem with doing this yourself is it will be different for each network vendor and will take more coding time as you add different network devices.</span></p>
<p><span class="koboSpan" id="kobo.617.1">Let’s look at an</span><a id="_idIndexMarker792"/><span class="koboSpan" id="kobo.618.1"> example of getting uptime</span><a id="_idIndexMarker793"/><span class="koboSpan" id="kobo.619.1"> from the remote network host:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.620.1">
package main
import (
    "bytes"
    "fmt"
    "log"
    "golang.org/x/crypto/ssh"
)
func main() {
    host := "10.0.4.1"
    config := &amp;ssh.ClientConfig{
        User:            "netlab",
        HostKeyCallback: ssh.InsecureIgnoreHostKey(),
        Auth: []ssh.AuthMethod{
            ssh.Password("netlab"),
        },
    }
    conn, err := ssh.Dial("tcp", host+":22", config)
    if err != nil {
        log.Fatalf("Dial failed: %s", err)
    }
    session, err := conn.NewSession()
    if err != nil {
        log.Fatalf("NewSession failed: %s", err)
    }
    var buff bytes.Buffer
    session.Stdout = &amp;buff
    if err := session.Run("uptime"); err != nil {
        log.Fatalf("Run failed: %s", err)
    }
    fmt.Println(buff.String())
}</span></pre>
<p><span class="koboSpan" id="kobo.621.1">As you</span><a id="_idIndexMarker794"/><span class="koboSpan" id="kobo.622.1"> can see, the preceding example </span><a id="_idIndexMarker795"/><span class="koboSpan" id="kobo.623.1">contains much more code than some higher-level libraries.</span></p>
<h3><span class="koboSpan" id="kobo.624.1">Using Go vSSH</span></h3>
<p><span class="koboSpan" id="kobo.625.1">There</span><a id="_idIndexMarker796"/><span class="koboSpan" id="kobo.626.1"> is a library in Go called vSSH, which is </span><a id="_idIndexMarker797"/><span class="koboSpan" id="kobo.627.1">built on top of </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">golang.org/x/crypto</span></strong><span class="koboSpan" id="kobo.629.1"> by engineers at Yahoo. </span><span class="koboSpan" id="kobo.629.2">It creates an abstraction for accessing remote terminals on network devices, which avoids the code that we saw previously with the SSH example.</span></p>
<p><span class="koboSpan" id="kobo.630.1">One of the main claims of vSSH is that it can handle access to multiple targets with high performance, which is obtained by using Go routines (a great beginner’s guide for Go routines can be found at </span><a href="https://go.dev/tour/concurrency/1"><span class="koboSpan" id="kobo.631.1">https://go.dev/tour/concurrency/1</span></a><span class="koboSpan" id="kobo.632.1">).</span></p>
<p><span class="koboSpan" id="kobo.633.1">Although </span><a id="_idIndexMarker798"/><span class="koboSpan" id="kobo.634.1">vSSH can handle multiple targets efficiently, let’s start by writing an example that uses </span><a id="_idIndexMarker799"/><span class="koboSpan" id="kobo.635.1">only one target:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.636.1">
package main
import (
    "context"
    "fmt"
    "log"
    "time"
    "github.com/yahoo/vssh"
)
func main() {
    vs := vssh.New().Start()
    config := vssh.GetConfigUserPass("netlab", "netlab")
    vs.AddClient(
        "10.0.4.1:22", config, vssh.SetMaxSessions(1),
    )
    vs.Wait()
    ctx, cancel := context.WithCancel(
        context.Background()
    )
    defer cancel()
    timeout, _ := time.ParseDuration("4s")
    rChannel := vs.Run(ctx, "uptime", timeout)
    for resp := range rChannel {
        if err := resp.Err(); err != nil {
            log.Println(err)
            continue
        }
        outTxt, _, _ := resp.GetText(vs)
        fmt.Println(outTxt)
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.637.1">Go routines</span><a id="_idIndexMarker800"/><span class="koboSpan" id="kobo.638.1"> have been used in this example. </span><span class="koboSpan" id="kobo.638.2">Additional targets can be added using </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">vs.AddClient()</span></strong><span class="koboSpan" id="kobo.640.1"> before calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">vs.Wait()</span></strong><span class="koboSpan" id="kobo.642.1">. </span><span class="koboSpan" id="kobo.642.2">In our example, only one target was added to </span><a id="_idIndexMarker801"/><span class="koboSpan" id="kobo.643.1">get the uptime of the remote network host. </span><span class="koboSpan" id="kobo.643.2">The loop at the end is not necessary for only one target, but I left it there to demonstrate how to use it with multiple targets.</span></p>
<p><span class="koboSpan" id="kobo.644.1">As we can have one host that might be faulty or slow when using multiple targets, a parse timeout is used, which in our example is 4 seconds. </span><span class="koboSpan" id="kobo.644.2">The preceding example uses a channel via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">rChannel</span></strong><span class="koboSpan" id="kobo.646.1"> variable to obtain the results of the Go routines for each target.</span></p>
<h3><span class="koboSpan" id="kobo.647.1">Using Go Scrapligo</span></h3>
<p><span class="koboSpan" id="kobo.648.1">Scrapligo</span><a id="_idIndexMarker802"/><span class="koboSpan" id="kobo.649.1"> is a</span><a id="_idIndexMarker803"/><span class="koboSpan" id="kobo.650.1"> Go version of the successful Python library Scrapli. </span><span class="koboSpan" id="kobo.650.2">It supports the same network platforms and also supports NETCONF. </span><span class="koboSpan" id="kobo.650.3">The advantages of using Scrapligo over Scrapli are the ones we discussed earlier in this chapter related to how Go and Python runtime perform.</span></p>
<p><span class="koboSpan" id="kobo.651.1">The </span><a id="_idIndexMarker804"/><span class="koboSpan" id="kobo.652.1">preceding example in Scrapligo would look like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.653.1">
package main
import (
    "fmt"
    "log"
    "github.com/scrapli/scrapligo/driver/generic"
    "github.com/scrapli/scrapligo/driver/options"
)
func main() {
    target, err := generic.NewDriver(
        "10.0.4.1",
        options.WithAuthNoStrictKey(),
        options.WithAuthUsername("netlab"),
        options.WithAuthPassword("netlab"),
    )
    if err != nil {
        log.Fatalf("Failed to create target: %+v\n", err)
    }
    if err = target.Open(); err != nil {
        log.Fatalf("Failed to open: %+v\n", err)
    }
    output, err := target.Channel.SendInput("uptime")
    if err != nil {
        log.Fatalf("Failed to send command: %+v\n", err)
    }
    fmt.Println(string(output))
}</span></pre>
<p><span class="koboSpan" id="kobo.654.1">We</span><a id="_idIndexMarker805"/><span class="koboSpan" id="kobo.655.1"> have</span><a id="_idIndexMarker806"/><span class="koboSpan" id="kobo.656.1"> just discussed how to access network devices via the CLI using Python and Go libraries. </span><span class="koboSpan" id="kobo.656.2">Now, let’s learn how to use libraries to access the network using other methods.</span></p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.657.1">Libraries to access networks using SNMP</span></h2>
<p><span class="koboSpan" id="kobo.658.1">Excluding the CLI, the</span><a id="_idIndexMarker807"/><span class="koboSpan" id="kobo.659.1"> second most popular network device access method is SNMP. </span><span class="koboSpan" id="kobo.659.2">But as we discussed in </span><a href="B18165_03.xhtml#_idTextAnchor067"><em class="italic"><span class="koboSpan" id="kobo.660.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.661.1">, SNMP is only used to read information from network devices. </span><span class="koboSpan" id="kobo.661.2">The SNMP write method is not used for the reasons discussed in </span><a href="B18165_03.xhtml#_idTextAnchor067"><em class="italic"><span class="koboSpan" id="kobo.662.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.663.1">.</span></p>
<p><span class="koboSpan" id="kobo.664.1">For the SNMP examples, we are going to pick up one library from Python and one from Go. </span><span class="koboSpan" id="kobo.664.2">These libraries are the most popular ones for using the SNMP method today.</span></p>
<p><span class="koboSpan" id="kobo.665.1">In the previous subsection, we used CLI methods to collect the uptime of the network device. </span><span class="koboSpan" id="kobo.665.2">We</span><a id="_idIndexMarker808"/><span class="koboSpan" id="kobo.666.1"> are going to demonstrate now that we can also get the uptime of the remote network device by using the SNMP method. </span><span class="koboSpan" id="kobo.666.2">For that, we need to collect the </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">SNMPv2-MIB::sysUpTime</span></strong><span class="koboSpan" id="kobo.668.1"> MIB variable.</span></p>
<h3><span class="koboSpan" id="kobo.669.1">Using Python PySNMP</span></h3>
<p><span class="koboSpan" id="kobo.670.1">PySNMP is </span><a id="_idIndexMarker809"/><span class="koboSpan" id="kobo.671.1">the most popular library </span><a id="_idIndexMarker810"/><span class="koboSpan" id="kobo.672.1">for Python for the SNMP method. </span><span class="koboSpan" id="kobo.672.2">It supports all versions of SNMP from version 1 to version 3. </span><span class="koboSpan" id="kobo.672.3">The following is an example of using the SNMP method to obtain the uptime of the network device:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.673.1">
from pysnmp.hlapi import *
snmpIt = getCmd(SnmpEngine(),
    CommunityData("public"),
    UdpTransportTarget(("10.0.4.1", 161)),
    ContextData(),
    ObjectType(ObjectIdentity("SNMPv2-MIB", "sysUpTime", 0)))
errEngine, errAgent, errorIndex, vars = next(snmpIt)
if errEngine:
    print("Got engine error:", errEngine)
elif errAgent:
    print("Got agent error:", errAgent.prettyPrint())
else:
    for var in vars:
        print(' = '.join([x.prettyPrint() for x in var]))</span></pre>
<p><span class="koboSpan" id="kobo.674.1">The output will be </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">SNMPv2-MIB::sysUpTime.0 = 72515</span></strong><span class="koboSpan" id="kobo.676.1">.</span></p>
<p><span class="koboSpan" id="kobo.677.1">More on </span><a id="_idIndexMarker811"/><span class="koboSpan" id="kobo.678.1">PySNMP can be found at </span><a href="https://pysnmp.readthedocs.io/en/latest/"><span class="koboSpan" id="kobo.679.1">https://pysnmp.readthedocs.io/en/latest/</span></a><span class="koboSpan" id="kobo.680.1">.</span></p>
<h3><span class="koboSpan" id="kobo.681.1">Using gosnmp</span></h3>
<p><span class="koboSpan" id="kobo.682.1">For Go, the </span><a id="_idIndexMarker812"/><span class="koboSpan" id="kobo.683.1">most </span><a id="_idIndexMarker813"/><span class="koboSpan" id="kobo.684.1">popular library for the SNMP method is </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">gosnmp</span></strong><span class="koboSpan" id="kobo.686.1">. </span><span class="koboSpan" id="kobo.686.2">It also supports version 1 to version 3 of the SNMP protocol. </span><span class="koboSpan" id="kobo.686.3">Compared to PySNMP, </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">gosnmp</span></strong><span class="koboSpan" id="kobo.688.1"> is newer but has more developers and more users, making it more reliable in terms of future development. </span><span class="koboSpan" id="kobo.688.2">The following is an example of collecting uptime from a network device using the SNMP method in Go. </span><span class="koboSpan" id="kobo.688.3">In this example, the OID number (</span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">1.3.6.1.2.1.1.3.0</span></strong><span class="koboSpan" id="kobo.690.1">) represents the same as </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">SNMPv2-MIB::sysUpTime</span></strong><span class="koboSpan" id="kobo.692.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.693.1">
package main
import (
    "fmt"
    "log"
    snmp "github.com/gosnmp/gosnmp"
)
func main() {
    snmp.Default.Target = "10.0.4.1"
    if err := snmp.Default.Connect(); err != nil {
        log.Fatalf("Failed Connect: %v", err)
    }
    defer snmp.Default.Conn.Close()
    //SNMPv2-MIB::sysUpTime
    oid := []string{"1.3.6.1.2.1.1.3.0"}
    result, err := snmp.Default.Get(oid)
    if err != nil {
        log.Fatalf("Failed Get: %v", err)
    }
    for _, variable := range result.Variables {
        fmt.Printf("oid: %s ", variable.Name)
        fmt.Printf(": %d\n", snmp.ToBigInt(variable.Value))
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.694.1">The </span><a id="_idIndexMarker814"/><span class="koboSpan" id="kobo.695.1">output will be </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">oid: .1.3.6.1.2.1.1.3.0 : 438678</span></strong><span class="koboSpan" id="kobo.697.1">.</span></p>
<p><span class="koboSpan" id="kobo.698.1">More on </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">gosnmp</span></strong><span class="koboSpan" id="kobo.700.1"> can </span><a id="_idIndexMarker815"/><span class="koboSpan" id="kobo.701.1">be found at </span><a href="https://pkg.go.dev/github.com/gosnmp/gosnmp"><span class="koboSpan" id="kobo.702.1">https://pkg.go.dev/github.com/gosnmp/gosnmp</span></a><span class="koboSpan" id="kobo.703.1">.</span></p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.704.1">Libraries to access networks using NETCONF or RESTCONF</span></h2>
<p><span class="koboSpan" id="kobo.705.1">When</span><a id="_idIndexMarker816"/><span class="koboSpan" id="kobo.706.1"> writing configuration to the network devices, the preferred method would be NETCONF or RESTCONF. </span><span class="koboSpan" id="kobo.706.2">However, some</span><a id="_idIndexMarker817"/><span class="koboSpan" id="kobo.707.1"> devices or some functions of the device might not </span><a id="_idIndexMarker818"/><span class="koboSpan" id="kobo.708.1">have it implemented yet. </span><span class="koboSpan" id="kobo.708.2">In this case, the most appropriate method would be via a CLI as SNMP is not used to write data on the device.</span></p>
<p><span class="koboSpan" id="kobo.709.1">The RESTCONF/NETCONF methods are newer methods to access network devices compared to a CLI or SNMP. </span><span class="koboSpan" id="kobo.709.2">Because of that, there are not many libraries available. </span><span class="koboSpan" id="kobo.709.3">Today, the best library to use NETCONF in Python would be Scrapli; for Go, this would be Scrapligo. </span></p>
<p><span class="koboSpan" id="kobo.710.1">Examples of using</span><a id="_idIndexMarker819"/><span class="koboSpan" id="kobo.711.1"> Python Scrapli with NETCONF can be found at </span><a href="https://scrapli.github.io/scrapli_netconf/"><span class="koboSpan" id="kobo.712.1">https://scrapli.github.io/scrapli_netconf/</span></a><span class="koboSpan" id="kobo.713.1">.</span></p>
<p><span class="koboSpan" id="kobo.714.1">Examples of using </span><a id="_idIndexMarker820"/><span class="koboSpan" id="kobo.715.1">Go Scrapligo with NETCONF can be found at </span><a href="https://github.com/scrapli/scrapligo/tree/main/examples/netconf_driver/basics"><span class="koboSpan" id="kobo.716.1">https://github.com/scrapli/scrapligo/tree/main/examples/netconf_driver/basics</span></a><span class="koboSpan" id="kobo.717.1">.</span></p>
<p><span class="koboSpan" id="kobo.718.1">You</span><a id="_idIndexMarker821"/><span class="koboSpan" id="kobo.719.1"> can also use a plain HTTP library to collect information using RESTCONF, as shown in the following Python example:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.720.1">
import requests
from requests.auth import HTTPBasicAuth
import json
requests.packages.urllib3.disable_warnings()
headers = {"Accept": "application/yang-data+json"}
rest_call = "https://10.0.4.1:6060/data/interfaces/state"
result = requests.get(rest_call, auth=HTTPBasicAuth("netlab", "netlab"), headers=headers, verify=False)
print(result.content)</span></pre>
<p><span class="koboSpan" id="kobo.721.1">Now, let’s learn how to use Python and Go to access networks using gRPC and gNMI.</span></p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.722.1">Libraries to access networks using gRPC and gNMI</span></h2>
<p><span class="koboSpan" id="kobo.723.1">Compared </span><a id="_idIndexMarker822"/><span class="koboSpan" id="kobo.724.1">to the other methods, gRPC is quite new and network device vendors have added this capability in recent years. </span><span class="koboSpan" id="kobo.724.2">So, if you have old devices in your network, you might not be able to use gRPC or gNMI.</span></p>
<p><span class="koboSpan" id="kobo.725.1">As we discussed in </span><a href="B18165_03.xhtml#_idTextAnchor067"><em class="italic"><span class="koboSpan" id="kobo.726.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.727.1">, gRPC is a more generic method, and gNMI is more specific for network interfaces. </span><span class="koboSpan" id="kobo.727.2">The main use of gNMI is network telemetry by invoking the underlying gRPC streaming subscription capability. </span><span class="koboSpan" id="kobo.727.3">Using gNMI allows your network code to scale easily and collect much more </span><a id="_idIndexMarker823"/><span class="koboSpan" id="kobo.728.1">network management data compared to SNMP. </span><span class="koboSpan" id="kobo.728.2">The gNMI libraries are built on top of the gRPC protocol.</span></p>
<p><span class="koboSpan" id="kobo.729.1">All major network device vendors have some sort of gRPC and/or gNMI implementation on their newer network operating systems. </span><span class="koboSpan" id="kobo.729.2">Among them are Cisco, Juniper, Arista, Nokia, Broadcom, and others.</span></p>
<h3><span class="koboSpan" id="kobo.730.1">Using gRPC in Python</span></h3>
<p><span class="koboSpan" id="kobo.731.1">Only newer</span><a id="_idIndexMarker824"/><span class="koboSpan" id="kobo.732.1"> versions of Python support gRPC, and the Python version has to be 3.7 or above. </span><span class="koboSpan" id="kobo.732.2">To use it, you need to</span><a id="_idIndexMarker825"/><span class="koboSpan" id="kobo.733.1"> install </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">grpcio</span></strong><span class="koboSpan" id="kobo.735.1"> (</span><a href="https://pypi.org/project/grpcio/"><span class="koboSpan" id="kobo.736.1">https://pypi.org/project/grpcio/</span></a><span class="koboSpan" id="kobo.737.1">).</span></p>
<p><span class="koboSpan" id="kobo.738.1">Examples of </span><a id="_idIndexMarker826"/><span class="koboSpan" id="kobo.739.1">using gRPC in Python can be obtained here: </span><a href="https://grpc.io/docs/languages/python/quickstart/"><span class="koboSpan" id="kobo.740.1">https://grpc.io/docs/languages/python/quickstart/</span></a><span class="koboSpan" id="kobo.741.1">.</span></p>
<h3><span class="koboSpan" id="kobo.742.1">Using gRPC in Go</span></h3>
<p><span class="koboSpan" id="kobo.743.1">In Go, gRPC </span><a id="_idIndexMarker827"/><span class="koboSpan" id="kobo.744.1">can run on any major version. </span><span class="koboSpan" id="kobo.744.2">It is </span><a id="_idIndexMarker828"/><span class="koboSpan" id="kobo.745.1">well documented and several examples can be found at </span><a href="https://github.com/grpc/grpc-go"><span class="koboSpan" id="kobo.746.1">https://github.com/grpc/grpc-go</span></a><span class="koboSpan" id="kobo.747.1">.</span></p>
<h3><span class="koboSpan" id="kobo.748.1">Using gNMI in Python</span></h3>
<p><span class="koboSpan" id="kobo.749.1">Python </span><a id="_idIndexMarker829"/><span class="koboSpan" id="kobo.750.1">support</span><a id="_idIndexMarker830"/><span class="koboSpan" id="kobo.751.1"> for gNMI is particularly rare. </span><span class="koboSpan" id="kobo.751.2">There are not many libraries available in the Python community. </span><span class="koboSpan" id="kobo.751.3">The following list describes the major ones:</span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">Cisco-gnmi-python</span></strong><span class="koboSpan" id="kobo.753.1"> was </span><a id="_idIndexMarker831"/><span class="koboSpan" id="kobo.754.1">created in 2018 and was initially supported by Cisco Networks. </span><span class="koboSpan" id="kobo.754.2">The library was created by Cisco to foment the use of gNMI on Cisco devices, and perhaps not a good match for multi-vendor support. </span><span class="koboSpan" id="kobo.754.3">More details </span><a id="_idIndexMarker832"/><span class="koboSpan" id="kobo.755.1">can be found at </span><a href="https://github.com/cisco-ie/cisco-gnmi-python"><span class="koboSpan" id="kobo.756.1">https://github.com/cisco-ie/cisco-gnmi-python</span></a><span class="koboSpan" id="kobo.757.1">.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">gnmi-py</span></strong><span class="koboSpan" id="kobo.759.1"> was </span><a id="_idIndexMarker833"/><span class="koboSpan" id="kobo.760.1">created in 2019 and is sponsored by Arista Networks. </span><span class="koboSpan" id="kobo.760.2">This library does not support multi-vendor platforms and can be only used for Arista devices. </span><span class="koboSpan" id="kobo.760.3">More </span><a id="_idIndexMarker834"/><span class="koboSpan" id="kobo.761.1">details can be found at </span><a href="https://github.com/arista-northwest/gnmi-py"><span class="koboSpan" id="kobo.762.1">https://github.com/arista-northwest/gnmi-py</span></a><span class="koboSpan" id="kobo.763.1">.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">pyygnmi</span></strong><span class="koboSpan" id="kobo.765.1"> was </span><a id="_idIndexMarker835"/><span class="koboSpan" id="kobo.766.1">created in 2020. </span><span class="koboSpan" id="kobo.766.2">The library can be imported using </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">pip</span></strong><span class="koboSpan" id="kobo.768.1"> and has been tested on Cisco, Arista, Juniper, and Nokia devices. </span><span class="koboSpan" id="kobo.768.2">This would be the preferred choice for multi-vendor platform support. </span><span class="koboSpan" id="kobo.768.3">More details can be </span><a id="_idIndexMarker836"/><span class="koboSpan" id="kobo.769.1">found at </span><a href="https://github.com/akarneliuk/pygnmi"><span class="koboSpan" id="kobo.770.1">https://github.com/akarneliuk/pygnmi</span></a><span class="koboSpan" id="kobo.771.1">.</span></li>
</ul>
<h3><span class="koboSpan" id="kobo.772.1">Using gNMI in Go</span></h3>
<p><span class="koboSpan" id="kobo.773.1">For Go, gNMI is </span><a id="_idIndexMarker837"/><span class="koboSpan" id="kobo.774.1">more mature and has better support compared to gNMI implementations </span><a id="_idIndexMarker838"/><span class="koboSpan" id="kobo.775.1">for Python. </span><span class="koboSpan" id="kobo.775.2">There is only one library that can use gNMI in Go, which is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">openconfig-gnmi</span></strong><span class="koboSpan" id="kobo.777.1">.</span></p>
<p><span class="koboSpan" id="kobo.778.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">openconfig-gnmi</span></strong><span class="koboSpan" id="kobo.780.1"> library was </span><a id="_idIndexMarker839"/><span class="koboSpan" id="kobo.781.1">created in 2016/2017 by Google and is now supported under the GitHub </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">openconfig</span></strong><span class="koboSpan" id="kobo.783.1"> group. </span><span class="koboSpan" id="kobo.783.2">More on this library can be</span><a id="_idIndexMarker840"/><span class="koboSpan" id="kobo.784.1"> found at </span><a href="https://pkg.go.dev/github.com/openconfig/gnmi"><span class="koboSpan" id="kobo.785.1">https://pkg.go.dev/github.com/openconfig/gnmi</span></a><span class="koboSpan" id="kobo.786.1">.</span></p>
<p><span class="koboSpan" id="kobo.787.1">Besides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">openconfig-gnmi</span></strong><span class="koboSpan" id="kobo.789.1"> library, there are other libraries related to gNMI in Go that you might find useful. </span><span class="koboSpan" id="kobo.789.2">Here is a list of the major ones:</span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">google-gnxi</span></strong><span class="koboSpan" id="kobo.791.1"> is a </span><a id="_idIndexMarker841"/><span class="koboSpan" id="kobo.792.1">combination of tools that can be used with gNMI and gNOI. </span><span class="koboSpan" id="kobo.792.2">Details </span><a id="_idIndexMarker842"/><span class="koboSpan" id="kobo.793.1">can be found at </span><a href="https://github.com/google/gnxi"><span class="koboSpan" id="kobo.794.1">https://github.com/google/gnxi</span></a><span class="koboSpan" id="kobo.795.1">.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">openconfig-gnmi-gateway</span></strong><span class="koboSpan" id="kobo.797.1"> is a library that can be used for high-availability streaming to collect network data with multiple clients. </span><span class="koboSpan" id="kobo.797.2">Details can be found </span><a id="_idIndexMarker843"/><span class="koboSpan" id="kobo.798.1">at </span><a href="https://github.com/openconfig/gnmi-gateway"><span class="koboSpan" id="kobo.799.1">https://github.com/openconfig/gnmi-gateway</span></a><span class="koboSpan" id="kobo.800.1">.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">openconfig-gnmic</span></strong><span class="koboSpan" id="kobo.802.1"> is a</span><a id="_idIndexMarker844"/><span class="koboSpan" id="kobo.803.1"> CLI tool written in Go that you can use to test gNMI capabilities. </span><span class="koboSpan" id="kobo.803.2">The CLI implements all gNMI client capabilities. </span><span class="koboSpan" id="kobo.803.3">More details can be found </span><a id="_idIndexMarker845"/><span class="koboSpan" id="kobo.804.1">at https://github.com/openconfig/gnmic.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.805.1">So far, we have covered the major and most popular libraries used to access network devices via several different methods. </span><span class="koboSpan" id="kobo.805.2">Further discussion on this topic can be found in open chat communities such as Slack groups. </span><span class="koboSpan" id="kobo.805.3">Examples include </span><a href="https://devopschat.slack.com/"><span class="koboSpan" id="kobo.806.1">https://devopschat.slack.com/</span></a><span class="koboSpan" id="kobo.807.1"> and https://alldaydevops.slack.com/.</span></p>
<h1 id="_idParaDest-181"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.808.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.809.1">In this chapter, we dove deeper into Python and Go runtime behavior, investigated how libraries are added to both languages, and we saw a few examples of network libraries to use when accessing the network devices.</span></p>
<p><span class="koboSpan" id="kobo.810.1">This chapter provided sufficient information to help you differentiate how Python and Go run and how they can be used with standard and third-party libraries. </span><span class="koboSpan" id="kobo.810.2">Now, you should be able to choose a proper language for your network automation based on the requirements of performance, security, maintainability, and reliability. </span><span class="koboSpan" id="kobo.810.3">You should also be able to choose a proper method and a library to access your network devices, either for configuration purposes or to collect network data.  </span></p>
<p><span class="koboSpan" id="kobo.811.1">In the next chapter, we are going to touch on how to handle errors in Go and Python, and how we can write code to handle exceptions properly in our network automation.</span></p>
</div>
</body></html>