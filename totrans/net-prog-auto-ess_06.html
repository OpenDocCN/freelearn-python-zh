<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-165"><a id="_idTextAnchor166"/>6</h1>
<h1 id="_idParaDest-166"><a id="_idTextAnchor167"/>Using Go and Python for Network Programming</h1>
<p>In this chapter, we’re going to see how Python and Go are powerful and used for network programming, but depending on what your requirements are and your environment, one might be better suited for you than the other. We are going to use Python and Go for network programming by checking the advantages and disadvantages of using each.</p>
<p>By the end of this chapter, you will be able to identify which language (Python or Go) is more suitable for your network project and which library to use. You are going to learn the differences and superpowers of each language that will probably make the difference in your network automation work.</p>
<p>The topics we are going to cover in this chapter are as follows:</p>
<ul>
<li>Looking into the language runtime</li>
<li>Using third-party libraries</li>
<li>Accessing network devices using libraries</li>
</ul>
<h1 id="_idParaDest-167"><a id="_idTextAnchor168"/>Technical requirements</h1>
<p>The source code described in this chapter is stored in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter06">https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter06</a>.</p>
<p>The examples in this chapter were created and tested using a simple network device simulator. The instructions on how to download and run this simulator are included in the <code>Chapter06/Device-Simulator</code> directory. </p>
<h1 id="_idParaDest-168"><a id="_idTextAnchor169"/>Looking into the language runtime</h1>
<p>After writing your <a id="_idIndexMarker685"/>code and saving it, you are going to run it somewhere in your network. Go and Python have different ways to combine your source code and all imported libraries before running. Which one suits you more? Are there any relevant differences that are important to know? We’ll discuss that in this section.</p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor170"/>What are compiled and interpreted languages? </h2>
<p>After <a id="_idIndexMarker686"/>writing your code, some computer languages need to be compiled to run on your machine, though some don’t as they are interpreted line by line as it runs. </p>
<p>The <a id="_idIndexMarker687"/>languages that are <a id="_idIndexMarker688"/>compiled have to have a compiler that translates the source code into a series of bits and bytes that can run on the CPU architecture of your computer; it also has to link all static and dynamic system libraries. For instance, a computer with an Apple M1 processor will have a different compiler than an Apple with an Intel x86 processor. The result after the compilation is a binary program that can’t be read by humans and when it runs, it is loaded from disk to main memory.</p>
<p>Once you have compiled, you don’t need to have your source code to run your program. The machine that runs your code does not need the compiler or the source code, only the compiled program binaries, which adds free space, code privacy, and code security.</p>
<p>On the other<a id="_idIndexMarker689"/> hand, interpreted languages (as it stands) are interpreted by a code interpreter, which interprets your code line by line when it is running. These interpreted languages are also known<a id="_idIndexMarker690"/> as <strong class="bold">scripting languages</strong>. The machine that runs the interpreted language needs to have the interpreter and the source code, which unfortunately exposes the source code and needs additional space to store.</p>
<p>Examples of compiled languages include Go, C, C++, Haskel, and Rust. Examples of interpreted languages include Python, PHP, Unix Shell, JavaScript, and Ruby.</p>
<p>Java is a special case because it has a compiler but compiles to its own <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>) architecture, which<a id="_idIndexMarker691"/> is not the CPU architecture where the program will run. Once compiled, you can use it anywhere but will need to install a JVM for the specific CPU architecture, adding extra storage and runtime complexity.</p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor171"/>Python interpreter</h2>
<p>The<a id="_idIndexMarker692"/> Python interpreter is <a id="_idIndexMarker693"/>sometimes called a Python virtual machine as a reference to a JVM, which can run anywhere. But Python does not provide a virtual machine like Java – it provides an interpreter, which is quite different.</p>
<p>In Java, this virtual machine is like a virtual CPU that provides an environment for the Java bytecode-compiled program to run. The JVM translates the Java-compiled bytecode into the bytecode of the CPU architecture where it is running. So, Java code will need to be compiled first; then, the compiled program can run on any machine that has a JVM installed.</p>
<p>On the contrary, the interpreter is much more complicated as it does not translate bytecode as it does in a JVM but interprets lines in a context with its surroundings. The interpreter reads the whole code and parses the syntax that must be decoded in the program’s context. Because of this complexity, this can be a very slow process.</p>
<p>Let’s investigate some of the available Python interpreters.</p>
<h3>Using CPython</h3>
<p><strong class="bold">CPython</strong> is <a id="_idIndexMarker694"/>one<a id="_idIndexMarker695"/> of the most common interpreter programs that is required to be installed in the machine where the Python code will run. CPython is written in C and is perhaps the first implementation of the Python interpreter.</p>
<p>CPython is the place where new functionalities will be created before they can be exposed in Python. As an example, when concurrency was added to Python, it was first achieved by the CPython interpreter process using the operating system’s multitasking properties.</p>
<p>CPython implementations can be compiled into proprietary bytecode before being passed to the interpreter. The reason is that it is easier to create an interpreter based on a stack machine instruction set, even though an interpreter doesn’t need to do so.</p>
<p>The following is an example<a id="_idIndexMarker696"/> of a CPython stack machine instruction set:</p>
<pre class="console">
$ pythonPython 3.9.4  [MSC v.1928 64 bit (AMD64)] on win32
&gt;&gt;&gt; import dis
&gt;&gt;&gt;
&gt;&gt;&gt; def return_the_bigest(a, b):
...     if a &gt; b:
...         return a
...     if b &gt; a:
...         return b
...     return None
...
&gt;&gt;&gt; dis.dis(return_the_bigest)
  2           0 LOAD_FAST                0 (a)
              2 LOAD_FAST                1 (b)
              4 COMPARE_OP               4 (&gt;)
              6 POP_JUMP_IF_FALSE       12
 
  3           8 LOAD_FAST                0 (a)
             10 RETURN_VALUE
 
  4     &gt;&gt;   12 LOAD_FAST                1 (b)
             14 LOAD_FAST                0 (a)
             16 COMPARE_OP               4 (&gt;)
             18 POP_JUMP_IF_FALSE       24
 
  5          20 LOAD_FAST                1 (b)
             22 RETURN_VALUE
 
  6     &gt;&gt;   24 LOAD_GLOBAL              0 (Null)
             26 RETURN_VALUE</pre>
<p>As you can <a id="_idIndexMarker697"/>see, the <code>return_the_bigest</code> function is translated into the CPython bytecode <a id="_idIndexMarker698"/>shown, which will be used by the CPython interpreter when it’s run. Note that the instruction set does the same as the <code>return_the_bigest</code> function, which is harder for humans to read and easier for the Python interpreter. </p>
<p>More on disassembler Python bytecode can be found here: <a href="https://docs.python.org/3/library/dis.html">https://docs.python.org/3/library/dis.html</a>.</p>
<p>More on CPython can <a id="_idIndexMarker699"/>be found here: <a href="https://github.com/python/cpython">https://github.com/python/cpython</a>.</p>
<h3>Using Jython</h3>
<p><strong class="bold">Jython</strong> is <a id="_idIndexMarker700"/>another Python interpreter that was created <a id="_idIndexMarker701"/>originally in 1997 by Jim Hugunin as <strong class="bold">JPython</strong>. In 1999, JPython was renamed to Jython, as it is known today.</p>
<p>Jython is used to compile Python code into a Java bytecode virtual machine that can run on any hardware that has a JVM installed. Sometimes, it can run faster as it does not need to be interpreted like CPython.</p>
<p>Although the project started with high expectations, today, it only supports Python 2.7, and the support for Python 3.x is still under development. Therefore, you are only going to need Jython if you are running your code on a machine that only supports JVMs. There will also be lots of limitations as it only supports Python version 2.7, which is no longer supported by the Python community and was deprecated in January 2020.</p>
<p>More on Jython can <a id="_idIndexMarker702"/>be found here: <a href="https://github.com/jython/jython">https://github.com/jython/jython</a>.</p>
<h3>Using PyPy</h3>
<p><strong class="bold">PyPy</strong> is <a id="_idIndexMarker703"/>another<a id="_idIndexMarker704"/> Python interpreter implementation that claims to run Python code faster than CPython. PyPy also claims to handle concurrency better than CPython with the usage of micro-threads. And finally, it claims to use less memory than CPython.</p>
<p>Despite the great advantages of PyPy, CPython is still the most used Python interpreter, mainly because people don’t know about PyPy and the default Python installation uses CPython.</p>
<p>PyPy has a website dedicated to comparing its speed with other interpreters, such as CPython. The website also has comparisons with other versions of PyPy. <em class="italic">Figure 6.1</em> shows a comparison between CPython and PyPy with information taken from the PyPy speed website. On average, PyPy is 4 times faster than CPython:</p>
<div><div><img alt="Figure 6.1 – CPython and PyPy comparison taken from speed.pypy.org" src="img/B18165_06_001.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – CPython and PyPy comparison taken from speed.pypy.org</p>
<p>The <a id="_idIndexMarker705"/>preceding<a id="_idIndexMarker706"/> figure contains blue bars, which represent how a specific benchmark runs in PyPy 3.9 in comparison to CPython 3.7.6. As an example, the <code>bm_dulwich_log</code> benchmark runs twice as fast compared to CPython (0.5). The sixth blue bar shows that PyPy runs slower for the <code>bm_mdp</code> benchmark (1.3), but for the second blue bar, which represents the <code>chaos</code> benchmark, PyPy runs up to 20 times faster. Details about each benchmark can be obtained at <a href="https://speed.pypy.org/">https://speed.pypy.org/</a>.</p>
<p>For more on PyPy, check<a id="_idIndexMarker707"/> its home page at <a href="https://www.pypy.org/">https://www.pypy.org/</a>.</p>
<h3>Using Cython</h3>
<p>Although<a id="_idIndexMarker708"/> some<a id="_idIndexMarker709"/> people compare PyPy with <strong class="bold">Cython</strong>, Cython is not a Python interpreter like PyPy. Cython is a compiler that can be used with the Python and Cython languages, which is<a id="_idIndexMarker710"/> based on <strong class="bold">Pyrex</strong>, a superset of the<a id="_idIndexMarker711"/> Python language. Cython can add C and C++ extensions easily to your code. As it is implemented in C, the Cython code claims to be faster than Python when using PyPy.</p>
<p>Therefore, if you are looking to write Python code and require high performance, try Cython. More on Cython<a id="_idIndexMarker712"/> can be found at <a href="https://cython.org/">https://cython.org/</a>.</p>
<h3>Using IPython and Jupyter</h3>
<p>The major<a id="_idIndexMarker713"/> advantage of an interpreted language is <a id="_idIndexMarker714"/>that it can run interactively easier. Python has an interpreter for this called <strong class="bold">IPython</strong>. </p>
<p>IPython can be used to run your code gradually line by line and then check what happens in memory. This is useful when testing or trying a new code or function. It is also quite handy to get results as the program runs and adapts the code to suit your desired output during code development.</p>
<p>In <a id="_idIndexMarker715"/>conjunction with IPython, you <a id="_idIndexMarker716"/>can use a <strong class="bold">Jupyter</strong> notebook, which is a web interface that’s easy to use and has graphical output capabilities.</p>
<p>As an example, imagine you need to gather information from 100 network nodes on CPU usage on the network and make a graphical report for the last hour. How could you do that quickly without worrying about building or testing? The best platform you can use is Jupyter notebook with IPython.</p>
<p>IPython and Jupyter are also frequently used for data science and machine learning, because of their advantages in terms of interactive methods and graphical interfaces.</p>
<p>For our network programming, IPython is a powerful tool to create <strong class="bold">Proof of Concept</strong> (<strong class="bold">PoC</strong>) coding <a id="_idIndexMarker717"/>and test new functionalities when creating solutions in Python.</p>
<p>More on IPython<a id="_idIndexMarker718"/> can be found at <a href="https://ipython.org/">https://ipython.org/</a>. More on Jupyter can <a id="_idIndexMarker719"/>be found at <a href="https://jupyter.org/">https://jupyter.org/</a>.</p>
<p>With that, we have looked at the major Python interpreters. Now, let’s look at how Go works.</p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor172"/>Go compiler</h2>
<p>In <a id="_idIndexMarker720"/>Go language development, there<a id="_idIndexMarker721"/> is no code interpretation like in Python code; instead, there’s compilation. This compilation is done by the Go compiler, which normally comes with the Go language package. The compiler reads the source code and then translates it into the bytecode of the CPU architecture where this program is going to be executed. When executing the compiled code, there is no need to have the compiler or the source code, only the compiled binary code.</p>
<p>Because of this compilation, Go programs run faster than Python-based programs – in some cases, they can run 30 to 100 times faster, especially when dealing with concurrency. As an example, the <code>fannkuch-redux</code> benchmark, which<a id="_idIndexMarker722"/> is used to test multicore parallelism, takes 8 seconds to run in Go, whereas<a id="_idIndexMarker723"/> it takes 5 minutes to run in Python (source: <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/fannkuchredux.html">https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/fannkuchredux.html</a>).</p>
<p>Although the Go language distribution provides the compiler, the Go community has started other projects as alternatives for the Go compiler. One of them is called <strong class="bold">TinyGo</strong>, which<a id="_idIndexMarker724"/> is used when the compiled code does not have much memory to be stored, such as in small microcontrollers or small computers. Therefore, TinyGo is used when memory space in the running target computer is limited. More on TinyGo can be <a id="_idIndexMarker725"/>found at <a href="https://github.com/tinygo-org/tinygo">https://github.com/tinygo-org/tinygo</a>.</p>
<p>Now, let’s compare both languages in terms of computing runtime.</p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor173"/>Pros and cons of programming runtimes</h2>
<p>Let’s explore the pros and cons of using Go and Python for programming while focusing on the code that will run on the machine during runtime.</p>
<p>Pros of using the<a id="_idIndexMarker726"/> Python runtime:</p>
<ul>
<li>Easy to create PoC code by using interactive Python with IPython and Jupyter notebooks</li>
<li>Easy to create data visualization during prototyping</li>
<li>Has a large community with different interpreters, libraries, and frameworks</li>
</ul>
<p>Cons of using the<a id="_idIndexMarker727"/> Python runtime:</p>
<ul>
<li>Consumes more space and memory on the target running machine</li>
<li>Consumes more CPU and is slower to complete tasks compared to Go</li>
<li>Code is visible on the target running machine, which can be unsecure</li>
<li>Runtime parallelism implementation is weak compared to Go</li>
</ul>
<p>Pros of using the<a id="_idIndexMarker728"/> Go runtime:</p>
<ul>
<li>Consumes less memory and space on the target running machine</li>
<li>Consumes less CPU and runs faster than Python</li>
<li>Code is compiled, which is not human readable and can’t easily be decoded</li>
<li>The runtime parallelism implementation is much better than Python</li>
</ul>
<p>Cons of using <a id="_idIndexMarker729"/>the Go runtime:</p>
<ul>
<li>More difficult to create prototypes</li>
<li>A smaller development community and fewer runtime libraries</li>
</ul>
<p>For network programming, Go has much more benefits compared to Python in terms of performance. However, as Python is an older language, it has a broader community with more network libraries and functionalities. </p>
<p>So, choosing which language to use will depend on the use case you are working on. If you want something quick and wish to write less code by reusing someone else’s library, then Python is probably the best fit. But if you want something that has more performance, is secure, uses less memory, and can be built as one binary program, Go is your best fit. As the Go community grows, it will probably have more libraries that can help with network automation over time, but as it stands today, Python has more community contributions in the network automation field.</p>
<p>In the next section, we’ll learn how we can add external libraries to our code in Go and Python.</p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor174"/>Using third-party libraries</h1>
<p>When<a id="_idIndexMarker730"/> developing network automation, it is always worth researching tools and libraries in the community to see if you can incorporate some external code that will add functionalities or speed up your development process.</p>
<p>In preparation to explain how to use third-party libraries, it is important to understand how libraries in general are used in Python and Go. We’ll detail the library-adding process in Python and Go in this section.</p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor175"/>Adding Python libraries</h2>
<p>Before<a id="_idIndexMarker731"/> discussing how libraries are added to Python, it is important <a id="_idIndexMarker732"/>to explain that, in Python, a <strong class="bold">library</strong> is <a id="_idIndexMarker733"/>also known as a <strong class="bold">package</strong> or a <strong class="bold">module</strong>.  These <a id="_idIndexMarker734"/>three terms are used widely throughout Python documentation, which<a id="_idIndexMarker735"/> can make some new Python developers confused. So, whenever you see the term “Python library”, it can also mean a package or a module.</p>
<p>A library in Python can be external, internal, or built-in. These external libraries are also known as third-party modules, packages, or libraries.</p>
<p>To use a<a id="_idIndexMarker736"/> library in Python, you just need to use the <code>import</code> statement at the beginning of the code. If the library is not found, it will raise an error exception called <code>ModuleNotFoundError</code>, as shown here:</p>
<pre class="source-code">
$ python
Python 3.10.4 (main, Apr  8 2022, 17:35:13) on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import netmiko
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
<strong class="bold">ModuleNotFoundError</strong>: No module named 'netmiko'</pre>
<p>In the preceding example, the Python interpreter threw an exception called <code>ModuleNotFoundError</code>, which means the package is not installed or is not in the search path. The search path is normally included in the <code>path</code> variable inside the <code>sys</code> package, as shown in the following example:</p>
<pre class="console">
$ python3.10
Python 3.10.4 (main, Apr  8 2022, 17:35:13) on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
['', '/usr/lib/python3.10', '/usr/lib/python3.10/lib-dynload', '/usr/local/lib/python3.10/dist-packages', '/usr/lib/python3/dist-packages']</pre>
<p>Note that <a id="_idIndexMarker737"/>in the preceding example, the <code>sys.path</code> variable has been pre-filed with a list of system paths, but you can append more if needed.</p>
<p>Now, let’s discuss how the built-in, standard, and external modules are used in Python.</p>
<h3>Using Python built-in libraries</h3>
<p>The <a id="_idIndexMarker738"/>built-in modules (or libraries) are modules that can be<a id="_idIndexMarker739"/> imported, but they come within the Python runtime program. They are not external files to be added, so they don’t need to be found in the <code>sys.path</code> variable. There are also built-in functions, such as <code>print</code>, but built-in modules are the ones that you are going to explicitly import before using them, such as the popular one known as <code>sys</code>, or others such as <code>array</code> and <code>time</code>. These built-in modules are not external programs like they are in Python standard libraries, but they are included in the binary code of the interpreter, like in CPython.</p>
<h3>Using Python standard libraries</h3>
<p>These <a id="_idIndexMarker740"/>are<a id="_idIndexMarker741"/> modules that come with the Python distribution, but they are separate Python files that are added when you state <code>import</code> at the beginning of the Python code; they need to be found in the <code>sys.path</code> variable. These modules are Python programs and can be found in the Python library installation directory, such as the <code>socket</code> library, as illustrated in the following example:</p>
<pre class="source-code">
$ python3.10
Python 3.10.4 (main, Apr  8 2022, 17:35:13) on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import inspect
&gt;&gt;&gt; import socket
&gt;&gt;&gt; inspect.getfile(socket)
'<strong class="bold">/usr/lib/python3.10/socket.py</strong>'</pre>
<p>Note<a id="_idIndexMarker742"/> that the <code>/usr/lib/pytho3.10/socket.py</code> location will depend on the operating system and version <a id="_idIndexMarker743"/>of Python. In the preceding example, Linux Ubuntu and Python 3.10 are being used. A list of all standard libraries for Python 3.10.x can be found at <a href="https://github.com/python/cpython/tree/3.10/Lib">https://github.com/python/cpython/tree/3.10/Lib</a>. More information about each built-in and standard library for Python 3.x can be found at <a href="https://docs.python.org/3/library/">https://docs.python.org/3/library/</a>.</p>
<h3>Using third-party Python libraries</h3>
<p>External libraries <a id="_idIndexMarker744"/>or third-party libraries are modules (or packages) in Python that are not included with the Python distribution and need to be<a id="_idIndexMarker745"/> installed manually before they’re used. These modules are normally not maintained by the Python library team but by developers of the Python community, which are not necessarily related to the Python main distribution.</p>
<p>As we discussed in <a href="B18165_05.xhtml#_idTextAnchor127"><em class="italic">Chapter 5</em></a>, before adding the external module to your code, have a look in the <code>LICENSE</code> file and check if any limitations might impact the usage of this module on your code or in your organization.</p>
<p>The Python community has <a id="_idIndexMarker746"/>organized a group called <code>pip</code>. </p>
<p>PyPA is also responsible for <a id="_idIndexMarker747"/>maintaining <a href="http://pypi.org">pypi.org</a>, where all packages that can be included with <code>pip</code> are documented. On this site, there is a search engine for finding packages and also documentation for developers that want to contribute or share their packages. Note that the source code for the packages is not on the <a href="http://pypi.org">pypi.org</a> site, but in repositories such as <strong class="bold">GitHub</strong>.</p>
<p>Now, let’s go through an example of the process of using a third-party package in our code. The <a id="_idIndexMarker748"/>package that we are adding as an example is called <code>netmiko</code>:</p>
<ol>
<li>Check if the package is included on <a href="http://pypi.org">pypi.org</a> as per PyPA. If so, we can use <code>pip</code> to add the package to our local Python environment.</li>
</ol>
<p>Yes, it is: <a href="https://pypi.org/project/netmiko/">https://pypi.org/project/netmiko/</a>.</p>
<ol>
<li value="2">Read the <code>LICENSE</code> file and check if it is allowed to be used in your organization.</li>
</ol>
<p>This<a id="_idIndexMarker749"/> license is based on MIT, which is less restrictive, so we can use it: <a href="https://github.com/ktbyers/netmiko/blob/develop/LICENSE">https://github.com/ktbyers/netmiko/blob/develop/LICENSE</a>.</p>
<ol>
<li value="3">Use <code>pip</code> to install the package to your local Python environment, as shown in the following example:<pre class="console">
<strong class="bold">$ pip install netmiko</strong>
<strong class="bold">Installing collected packages: netmiko</strong>
<strong class="bold">Successfully installed netmiko-4.1.0</strong></pre></li>
<li>Check if you can import and locate where the <code>netmiko</code> library is installed:<pre class="console">
<strong class="bold">&gt;&gt;&gt; import netmiko</strong>
<strong class="bold">&gt;&gt;&gt; import inspect</strong>
<strong class="bold">&gt;&gt;&gt; inspect.getfile(netmiko)</strong>
<strong class="bold">'/home/claus/.local/lib/python3.10/site-packages/netmiko/__init__.py'</strong></pre></li>
</ol>
<p>In the preceding example, the <code>netmiko</code> package has been installed using the <code>pip</code> tool, and the library is located under my home directory, <code>/home/claus</code>. However, this varies, depending on the version of Python and the operating system used. It also varies within Linux, depending on the distribution, such as Debian, Ubuntu, or Red Hat.</p>
<p>Just keep in mind that third-party Python libraries will be installed normally under a directory called <code>site-packages</code>. Here are some examples of where it can be located for each operating system: </p>
<ul>
<li>For macOS: <code>/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages</code></li>
<li>For Windows: <code>C:\Users\username\AppData\Local\Programs\Python\Python39\lib\site-packages</code></li>
<li>For Linux Ubuntu: <code>/usr/lib/python3.9/site-packages</code></li>
</ul>
<p>A<a id="_idIndexMarker750"/> complete list of all packages that you have installed on<a id="_idIndexMarker751"/> your system can be found by typing the following command: </p>
<pre class="console">
pip list -v</pre>
<p>Now, let’s explore how we can use libraries and third-party libraries in Go.</p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor176"/>Adding Go libraries</h2>
<p>In<a id="_idIndexMarker752"/> contrast <a id="_idIndexMarker753"/>with Python, Go only has two types of libraries: the standard libraries and the third-party libraries. For Go, there is no concept of built-in libraries because it does not have an interpreter; instead, it has a compiler. The reason is that an interpreter can include a few libraries in its binary, which are called built-in libraries.</p>
<p>To add a library to your Go code, you will need to use the <code>import</code> statement, which is the same in Python but the syntax is a bit different.</p>
<p>Similar to Python, in Go, a library is also known <a id="_idIndexMarker754"/>as a <strong class="bold">package</strong>.</p>
<p>Let’s have a look at how to add standard libraries and then third-party libraries in Go.</p>
<h3>Using standard libraries in Go</h3>
<p>Each version of Go includes a set of standard libraries that are installed with the Go distribution. These <a id="_idIndexMarker755"/>standard libraries are also Go programs that, when imported, will be combined with your code during compilation.</p>
<p>A list of standard libraries can be found at <a href="https://pkg.go.dev/std">https://pkg.go.dev/std</a>. The <a id="_idIndexMarker756"/>website is very useful because it includes an explanation of each library (or package).</p>
<p>The <a id="_idIndexMarker757"/>standard libraries can also be found in your local development filesystem. Go’s installation includes all standard libraries, such as the <code>fmt</code> and <code>math</code> packages. The location of these standard libraries will vary for each operating system but can be found by looking into the <code>GOROOT</code> environment variable.</p>
<p>Most operating systems do not populate the <code>GOROOT</code> variable, so they will use the Go language’s default location. To find out your default location, you can run the <code>go env</code> command, as shown here:</p>
<pre class="console">
$ go env GOROOT
/usr/lib/go-1.19</pre>
<p>In the preceding example, <code>GOROOT</code> is located in <code>/usr/lib/go-1.19</code>.</p>
<p>To learn how the libraries are located, let’s use the <code>fmt</code> standard library to print a string to the computer terminal:</p>
<pre class="source-code">
package main
import "fmt"
func main() {
    fmt.Println("My code is awesome")
}</pre>
<p>In the preceding example, the <code>import</code> statement tells the Go compiler that it needs to add the <code>fmt</code> package, which in this case is a standard library package. In this example, the Go compiler will search for this package, starting by looking in the <code>/usr/lib/go-1.19</code> directory.</p>
<p>To be more specific, the <code>fmt</code> package is located at <code>/usr/lib/go-1.19/src/fmt</code>. The <code>Println</code> function that’s being used in this example is described in the <code>/usr/lib/go-1.19/src/fmt/print.go</code> file.</p>
<p>In Go, all <a id="_idIndexMarker758"/>programs have to belong to a package, and the package name is described in the first line of the code. In the <code>fmt</code> directory (<code>/usr/lib/go-1.19/src/fmt</code>), all the files included in the directory have a first line that contains the <code>package fmt</code> statement. This includes the <code>scan.go</code>, <code>format.go</code>, and <code>print.go</code> files, which are located in the <code>fmt</code> directory.</p>
<p>Other examples<a id="_idIndexMarker759"/> of standard libraries in Go can be found in your local Go installation, normally under the <code>src</code> directory. In the preceding example, it is under <code>/usr/lib/go-1.19/src</code>. Some other examples include the <code>math</code> package, located at <code>/usr/lib/go-1.19/src/math/</code>, and the <code>time</code> package, located at <code>/usr/lib/go-1.19/src/time/</code>.</p>
<p>Here is another example, which uses the <code>math</code> standard library:</p>
<pre class="source-code">
package main
import (
    "fmt"
    "math"
)
func main() {
    fmt.Println("Square root of 2 is", math.Sqrt(2))
}</pre>
<p>In the preceding example, the <code>math</code> library uses the <code>Sqrt</code> function, which is described in the <code>/usr/lib/go-1.19/src/math/sqrt.go</code> file. Again, all the files in the <code>math</code> directory have the <code>package math</code> statement on their first line. </p>
<p>Now, let’s learn how to add third-party libraries to Go.</p>
<h3>Using third-party libraries in Go</h3>
<p>Third-party library<a id="_idIndexMarker760"/> packages in Go are added in a similar <a id="_idIndexMarker761"/>way to standard libraries – by using the <code>import</code> statement in your code. However, the underlying process of adding these packages to the Go development environment is a bit different in terms of a few characteristics.</p>
<p>In the <a id="_idIndexMarker762"/>case of third-party packages, the compiler needs to search for new files containing the package in a different path, which is populated in the <code>GOPATH</code> environment variable. Like <code>GOROOT</code>, you don’t need to populate <code>GOPATH</code> as the Go compiler has a default location for the <code>GOPATH</code> variable.</p>
<p>In our Go example, let’s check the default location for <code>GOPATH</code> by running the following command:</p>
<pre class="console">
$ go env GOPATH
/home/claus/go</pre>
<p>As we can see, the default location for <code>GOPATH</code> is the <code>go</code> directory inside my home directory (<code>/home/claus</code>).</p>
<p>In Go, third-party libraries can be added by invoking the <code>get</code> subcommand on the <code>go</code> command line, as shown here:</p>
<pre class="console">
$ go get golang.org/x/crypto
go: downloading golang.org/x/crypto v0.0.0-20220622213112-05595931fe9d
go: downloading golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1
go: added golang.org/x/crypto v0.0.0-20220622213112-05595931fe9d</pre>
<p>In the preceding example, we added the <code>x/crypto</code> package. Note that all other dependencies of the package are also added; in this example, the other dependency is <code>x/sys</code>. The <code>get</code> subcommand also stores the version of the package – in this case, <code>v0.0.0-20220622213112-05595931fe9d</code>.</p>
<p>Then, the package is saved under the <code>GOPATH</code> directory. In the preceding example, it is saved at <code>/home/claus/go/pkg/mod/golang.org/x/crypto@&lt;VERSION&gt;</code>.</p>
<p>Every time you run <code>go get</code> and there is a new version available, Go stores the new version and keeps the old one in a different directory.</p>
<p>You don’t need to run <code>go get</code> when adding a third-party library. The <code>get</code> command is sometimes<a id="_idIndexMarker763"/> invoked when you run <code>go build</code> if the package has not been downloaded or cached, as shown here:</p>
<pre class="console">
$ go build
go: downloading golang.org/x/crypto v0.0.0-20220622213112-05595931fe9d</pre>
<p>In the preceding example, the Go program had an <code>import</code> statement:</p>
<pre class="source-code">
import (
    "golang.org/x/crypto/ssh"
)</pre>
<p>After<a id="_idIndexMarker764"/> adding a third-party library, Go also updates the <code>go.mod</code> file. This file is required to keep track of the versions of the packages that are added to your Go program. The following is the content of the <code>go.mod</code> file for the preceding examples:</p>
<pre class="console">
$ cat go.mod 
module connect
 
go 1.19
require (
    golang.org/x/crypto v0.0.0-20220622213112-05595931fe9d
)
require golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1 // indirect</pre>
<p>Note that the <code>go.mod</code> file also stores the versions of the packages for all dependencies. In the preceding example, the <code>x/sys</code> package version is also stored in the file.</p>
<p>Now that you’re familiar with adding third-party libraries to Go and Python, let’s dive into the next section and look at some libraries that can be used to access the network.</p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor177"/>Accessing network devices using libraries</h1>
<p>So far, we have <a id="_idIndexMarker765"/>discussed how to run and work<a id="_idIndexMarker766"/> with libraries in Python and Go. Now, let’s focus on how to use Python and Go to access network devices, which is one of the most important points in our network automation work.</p>
<p>In <a href="B18165_03.xhtml#_idTextAnchor067"><em class="italic">Chapter 3</em></a>, we discussed several methods to access network devices. One of the most popular ones is using a <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>). We also discussed SNMP, NETCONF, gRPC, and gNMI. In this section, we are going to explore a few examples of how to use libraries to access network devices, mainly using the CLI. Later, we are going to explain and show the libraries for accessing the network using other methods. </p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor178"/>Libraries to access the network via a CLI</h2>
<p>There are <a id="_idIndexMarker767"/>lots of libraries on the internet that can access network devices, and some of them might be obsolete or not used anymore. Here, we are going to present the most popular ones in chronological order, from the old to the newer ones.</p>
<p>The following examples are going to collect the uptime of the network device by sending the <code>uptime</code> command via the CLI on an SSH connection.</p>
<h3>Using Python Paramiko</h3>
<p>Paramiko is <a id="_idIndexMarker768"/>perhaps one of the oldest<a id="_idIndexMarker769"/> implementations for accessing network devices via the CLI. The first release was published in 2003. Today, it has more than 300 contributors and there are almost 2,000 packages <a id="_idIndexMarker770"/>depending on Paramiko (<a href="https://github.com/paramiko/paramiko/network/dependents">https://github.com/paramiko/paramiko/network/dependents</a>).</p>
<p>As we discussed in <a href="B18165_03.xhtml#_idTextAnchor067"><em class="italic">Chapter 3</em></a>, the correct way to use CLI libraries is<a id="_idIndexMarker771"/> via <strong class="bold">Secure Shell</strong> (<strong class="bold">SSH</strong>). Paramiko <a id="_idIndexMarker772"/>implements secure cryptography for SSH using a lower-level library called PyCrypto (<a href="http://pycrypto.org/">http://pycrypto.org/</a>).</p>
<p>Let’s look at a <a id="_idIndexMarker773"/>simple example to obtain the uptime of the network host:</p>
<pre class="source-code">
import paramiko
TARGET = {
    "hostname": "10.0.4.1",
    "username": "netlab",
    "password": "netlab",
}
ssh = paramiko.SSHClient()
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
ssh.connect(**TARGET)
stdin, stdout, stderr = ssh.exec_command("uptime")
stdin.close()
print(stdout.read().decode("ascii"))</pre>
<p>If the<a id="_idIndexMarker774"/> connection is successful, the <a id="_idIndexMarker775"/>output of the preceding program will be the uptime of the network host: </p>
<pre class="console">
13:22:57 up 59 min,  0 users,  load average: 0.02, 0.07, 0.08</pre>
<h3>Using Python Netmiko</h3>
<p>Netmiko is<a id="_idIndexMarker776"/> also another popular library for <a id="_idIndexMarker777"/>accessing network devices via the CLI. The first release was published in 2014 and was built on top of Paramiko to simplify connections to network devices. In summary, Netmiko is simpler than Paramiko and more focused on network devices.</p>
<p>Let’s learn what the same<a id="_idIndexMarker778"/> example for Paramiko will look like when using Netmiko:</p>
<pre class="source-code">
import netmiko
host = {
    "host": "10.0.4.1",
    "username": "netlab",
    "password": "netlab",
    "device_type": "linux_ssh",
}
with netmiko.ConnectHandler(**host) as netcon:
    output = netcon.send_command(command)
print(output)</pre>
<p>As you <a id="_idIndexMarker779"/>can see, the implementation of the Netmiko code is just 2 lines, with much smaller and simpler code compared to Paramiko. The big advantage of the Netmiko library is that it handles the device’s command prompt automatically and works with ease when changing the configuration in privilege mode since the prompt normally changes. In the preceding example, the device type was <code>linux_ssh</code> because our target host was a Linux device. </p>
<p>Netmiko can support<a id="_idIndexMarker780"/> dozens of network devices, including Cisco, Huawei, Juniper, and Alcatel. A complete list of devices can be found here: <a href="https://github.com/ktbyers/netmiko/blob/develop/PLATFORMS.md">https://github.com/ktbyers/netmiko/blob/develop/PLATFORMS.md</a>.</p>
<h3>Using Python AsyncSSH</h3>
<p>AsyncSSH is<a id="_idIndexMarker781"/> a modern implementation <a id="_idIndexMarker782"/>of <a id="_idIndexMarker783"/>Python <strong class="bold">AsyncIO</strong> for SSH. Python AsyncIO was introduced in Python version 3.4 and allows Python to work concurrently using async/await syntax and provides high performance for network access. To use AsyncSSH, you will need to have Python version 3.6 or higher.</p>
<p>In summary, AsyncSSH provides better performance for multiple hosts, but it is a lower-level implementation that requires more complexity in your code to handle network devices in comparison to Netmiko.</p>
<p>The same<a id="_idIndexMarker784"/> example of getting uptime for AsyncSSH can be written like so:</p>
<pre class="source-code">
import asyncio, asyncssh, sys
TARGET = {
    "host": "10.0.4.1",
    "username": "netlab",
    "password": "netlab",
    "known_hosts": None,
}
async def run_client() -&gt; None:
    async with asyncssh.connect(**TARGET) as conn:
       result = await conn.run("uptime", check=True)
       print(result.stdout, end="")
try:
    asyncio.get_event_loop().run_until_complete( run_client() )
except (OSError, asyncssh.Error) as execrr:
        sys.exit("Connection failed:" + str(execrr))</pre>
<p>Note that <a id="_idIndexMarker785"/>when using AsyncSSH, you will have to work with routines and events, as instructed by Python AsyncIO and the preceding example. If you want to dig into this, some great documentation can be <a id="_idIndexMarker786"/>found at https://realpython.com/async-io-python/.</p>
<h3>Using Python Scrapli</h3>
<p>In comparison<a id="_idIndexMarker787"/> to Netmiko, Scrapli is newer. The<a id="_idIndexMarker788"/> first release was published in 2019 and is also built on top of Paramiko but has capabilities to use AsyncSSH, which claims to improve performance when accessing multiple devices. The idea of the name Scrapli came from <em class="italic">scrape cli</em>, similar to someone scraping the screen. This is because Scrapli’s main objective is to interpret text from the network terminal using the CLI.</p>
<p>Scrapli <a id="_idIndexMarker789"/>was built to allow its users to interpret prompts from multi-vendor network devices such as Netmiko but with a reduced set of platforms. The 2022.7.30 version supports Cisco, Juniper, and Arista. One advantage of using Scrapli is that it also supports NETCONF.</p>
<p>The following is the same example to get uptime but using Scrapli:</p>
<pre class="source-code">
from scrapli.driver import GenericDriver
TARGET = {
    "host": "10.0.4.1",
    "auth_username": "netlab",
    "auth_password": "netlab",
    "auth_strict_key": False,
}
with GenericDriver(**TARGET) as con:
    command_return = con.send_command("uptime")
print(command_return.result)</pre>
<p>So far, we have learned about the most popular libraries for accessing network terminals using Python. Now, let’s learn we can do this with the Go language. </p>
<h3>Using Go ssh</h3>
<p>In contrast <a id="_idIndexMarker790"/>to Python, Go does not have a large<a id="_idIndexMarker791"/> community for working with libraries that can handle network devices. Therefore, in some particular cases, you might have to write your own scrape mechanism to interpret the remote network terminal via the CLI. The problem with doing this yourself is it will be different for each network vendor and will take more coding time as you add different network devices.</p>
<p>Let’s look at an<a id="_idIndexMarker792"/> example of getting uptime<a id="_idIndexMarker793"/> from the remote network host:</p>
<pre class="source-code">
package main
import (
    "bytes"
    "fmt"
    "log"
    "golang.org/x/crypto/ssh"
)
func main() {
    host := "10.0.4.1"
    config := &amp;ssh.ClientConfig{
        User:            "netlab",
        HostKeyCallback: ssh.InsecureIgnoreHostKey(),
        Auth: []ssh.AuthMethod{
            ssh.Password("netlab"),
        },
    }
    conn, err := ssh.Dial("tcp", host+":22", config)
    if err != nil {
        log.Fatalf("Dial failed: %s", err)
    }
    session, err := conn.NewSession()
    if err != nil {
        log.Fatalf("NewSession failed: %s", err)
    }
    var buff bytes.Buffer
    session.Stdout = &amp;buff
    if err := session.Run("uptime"); err != nil {
        log.Fatalf("Run failed: %s", err)
    }
    fmt.Println(buff.String())
}</pre>
<p>As you<a id="_idIndexMarker794"/> can see, the preceding example <a id="_idIndexMarker795"/>contains much more code than some higher-level libraries.</p>
<h3>Using Go vSSH</h3>
<p>There<a id="_idIndexMarker796"/> is a library in Go called vSSH, which is <a id="_idIndexMarker797"/>built on top of <code>golang.org/x/crypto</code> by engineers at Yahoo. It creates an abstraction for accessing remote terminals on network devices, which avoids the code that we saw previously with the SSH example.</p>
<p>One of the main claims of vSSH is that it can handle access to multiple targets with high performance, which is obtained by using Go routines (a great beginner’s guide for Go routines can be found at <a href="https://go.dev/tour/concurrency/1">https://go.dev/tour/concurrency/1</a>).</p>
<p>Although <a id="_idIndexMarker798"/>vSSH can handle multiple targets efficiently, let’s start by writing an example that uses <a id="_idIndexMarker799"/>only one target:</p>
<pre class="source-code">
package main
import (
    "context"
    "fmt"
    "log"
    "time"
    "github.com/yahoo/vssh"
)
func main() {
    vs := vssh.New().Start()
    config := vssh.GetConfigUserPass("netlab", "netlab")
    vs.AddClient(
        "10.0.4.1:22", config, vssh.SetMaxSessions(1),
    )
    vs.Wait()
    ctx, cancel := context.WithCancel(
        context.Background()
    )
    defer cancel()
    timeout, _ := time.ParseDuration("4s")
    rChannel := vs.Run(ctx, "uptime", timeout)
    for resp := range rChannel {
        if err := resp.Err(); err != nil {
            log.Println(err)
            continue
        }
        outTxt, _, _ := resp.GetText(vs)
        fmt.Println(outTxt)
    }
}</pre>
<p>Go routines<a id="_idIndexMarker800"/> have been used in this example. Additional targets can be added using <code>vs.AddClient()</code> before calling <code>vs.Wait()</code>. In our example, only one target was added to <a id="_idIndexMarker801"/>get the uptime of the remote network host. The loop at the end is not necessary for only one target, but I left it there to demonstrate how to use it with multiple targets.</p>
<p>As we can have one host that might be faulty or slow when using multiple targets, a parse timeout is used, which in our example is 4 seconds. The preceding example uses a channel via the <code>rChannel</code> variable to obtain the results of the Go routines for each target.</p>
<h3>Using Go Scrapligo</h3>
<p>Scrapligo<a id="_idIndexMarker802"/> is a<a id="_idIndexMarker803"/> Go version of the successful Python library Scrapli. It supports the same network platforms and also supports NETCONF. The advantages of using Scrapligo over Scrapli are the ones we discussed earlier in this chapter related to how Go and Python runtime perform.</p>
<p>The <a id="_idIndexMarker804"/>preceding example in Scrapligo would look like this:</p>
<pre class="source-code">
package main
import (
    "fmt"
    "log"
    "github.com/scrapli/scrapligo/driver/generic"
    "github.com/scrapli/scrapligo/driver/options"
)
func main() {
    target, err := generic.NewDriver(
        "10.0.4.1",
        options.WithAuthNoStrictKey(),
        options.WithAuthUsername("netlab"),
        options.WithAuthPassword("netlab"),
    )
    if err != nil {
        log.Fatalf("Failed to create target: %+v\n", err)
    }
    if err = target.Open(); err != nil {
        log.Fatalf("Failed to open: %+v\n", err)
    }
    output, err := target.Channel.SendInput("uptime")
    if err != nil {
        log.Fatalf("Failed to send command: %+v\n", err)
    }
    fmt.Println(string(output))
}</pre>
<p>We<a id="_idIndexMarker805"/> have<a id="_idIndexMarker806"/> just discussed how to access network devices via the CLI using Python and Go libraries. Now, let’s learn how to use libraries to access the network using other methods.</p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor179"/>Libraries to access networks using SNMP</h2>
<p>Excluding the CLI, the<a id="_idIndexMarker807"/> second most popular network device access method is SNMP. But as we discussed in <a href="B18165_03.xhtml#_idTextAnchor067"><em class="italic">Chapter 3</em></a>, SNMP is only used to read information from network devices. The SNMP write method is not used for the reasons discussed in <a href="B18165_03.xhtml#_idTextAnchor067"><em class="italic">Chapter 3</em></a>.</p>
<p>For the SNMP examples, we are going to pick up one library from Python and one from Go. These libraries are the most popular ones for using the SNMP method today.</p>
<p>In the previous subsection, we used CLI methods to collect the uptime of the network device. We<a id="_idIndexMarker808"/> are going to demonstrate now that we can also get the uptime of the remote network device by using the SNMP method. For that, we need to collect the <code>SNMPv2-MIB::sysUpTime</code> MIB variable.</p>
<h3>Using Python PySNMP</h3>
<p>PySNMP is <a id="_idIndexMarker809"/>the most popular library <a id="_idIndexMarker810"/>for Python for the SNMP method. It supports all versions of SNMP from version 1 to version 3. The following is an example of using the SNMP method to obtain the uptime of the network device:</p>
<pre class="source-code">
from pysnmp.hlapi import *
snmpIt = getCmd(SnmpEngine(),
    CommunityData("public"),
    UdpTransportTarget(("10.0.4.1", 161)),
    ContextData(),
    ObjectType(ObjectIdentity("SNMPv2-MIB", "sysUpTime", 0)))
errEngine, errAgent, errorIndex, vars = next(snmpIt)
if errEngine:
    print("Got engine error:", errEngine)
elif errAgent:
    print("Got agent error:", errAgent.prettyPrint())
else:
    for var in vars:
        print(' = '.join([x.prettyPrint() for x in var]))</pre>
<p>The output will be <code>SNMPv2-MIB::sysUpTime.0 = 72515</code>.</p>
<p>More on <a id="_idIndexMarker811"/>PySNMP can be found at <a href="https://pysnmp.readthedocs.io/en/latest/">https://pysnmp.readthedocs.io/en/latest/</a>.</p>
<h3>Using gosnmp</h3>
<p>For Go, the <a id="_idIndexMarker812"/>most <a id="_idIndexMarker813"/>popular library for the SNMP method is <code>gosnmp</code>. It also supports version 1 to version 3 of the SNMP protocol. Compared to PySNMP, <code>gosnmp</code> is newer but has more developers and more users, making it more reliable in terms of future development. The following is an example of collecting uptime from a network device using the SNMP method in Go. In this example, the OID number (<code>1.3.6.1.2.1.1.3.0</code>) represents the same as <code>SNMPv2-MIB::sysUpTime</code>:</p>
<pre class="source-code">
package main
import (
    "fmt"
    "log"
    snmp "github.com/gosnmp/gosnmp"
)
func main() {
    snmp.Default.Target = "10.0.4.1"
    if err := snmp.Default.Connect(); err != nil {
        log.Fatalf("Failed Connect: %v", err)
    }
    defer snmp.Default.Conn.Close()
    //SNMPv2-MIB::sysUpTime
    oid := []string{"1.3.6.1.2.1.1.3.0"}
    result, err := snmp.Default.Get(oid)
    if err != nil {
        log.Fatalf("Failed Get: %v", err)
    }
    for _, variable := range result.Variables {
        fmt.Printf("oid: %s ", variable.Name)
        fmt.Printf(": %d\n", snmp.ToBigInt(variable.Value))
    }
}</pre>
<p>The <a id="_idIndexMarker814"/>output will be <code>oid: .1.3.6.1.2.1.1.3.0 : 438678</code>.</p>
<p>More on <code>gosnmp</code> can <a id="_idIndexMarker815"/>be found at <a href="https://pkg.go.dev/github.com/gosnmp/gosnmp">https://pkg.go.dev/github.com/gosnmp/gosnmp</a>.</p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor180"/>Libraries to access networks using NETCONF or RESTCONF</h2>
<p>When<a id="_idIndexMarker816"/> writing configuration to the network devices, the preferred method would be NETCONF or RESTCONF. However, some<a id="_idIndexMarker817"/> devices or some functions of the device might not <a id="_idIndexMarker818"/>have it implemented yet. In this case, the most appropriate method would be via a CLI as SNMP is not used to write data on the device.</p>
<p>The RESTCONF/NETCONF methods are newer methods to access network devices compared to a CLI or SNMP. Because of that, there are not many libraries available. Today, the best library to use NETCONF in Python would be Scrapli; for Go, this would be Scrapligo. </p>
<p>Examples of using<a id="_idIndexMarker819"/> Python Scrapli with NETCONF can be found at <a href="https://scrapli.github.io/scrapli_netconf/">https://scrapli.github.io/scrapli_netconf/</a>.</p>
<p>Examples of using <a id="_idIndexMarker820"/>Go Scrapligo with NETCONF can be found at <a href="https://github.com/scrapli/scrapligo/tree/main/examples/netconf_driver/basics">https://github.com/scrapli/scrapligo/tree/main/examples/netconf_driver/basics</a>.</p>
<p>You<a id="_idIndexMarker821"/> can also use a plain HTTP library to collect information using RESTCONF, as shown in the following Python example:</p>
<pre class="source-code">
import requests
from requests.auth import HTTPBasicAuth
import json
requests.packages.urllib3.disable_warnings()
headers = {"Accept": "application/yang-data+json"}
rest_call = "https://10.0.4.1:6060/data/interfaces/state"
result = requests.get(rest_call, auth=HTTPBasicAuth("netlab", "netlab"), headers=headers, verify=False)
print(result.content)</pre>
<p>Now, let’s learn how to use Python and Go to access networks using gRPC and gNMI.</p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor181"/>Libraries to access networks using gRPC and gNMI</h2>
<p>Compared <a id="_idIndexMarker822"/>to the other methods, gRPC is quite new and network device vendors have added this capability in recent years. So, if you have old devices in your network, you might not be able to use gRPC or gNMI.</p>
<p>As we discussed in <a href="B18165_03.xhtml#_idTextAnchor067"><em class="italic">Chapter 3</em></a>, gRPC is a more generic method, and gNMI is more specific for network interfaces. The main use of gNMI is network telemetry by invoking the underlying gRPC streaming subscription capability. Using gNMI allows your network code to scale easily and collect much more <a id="_idIndexMarker823"/>network management data compared to SNMP. The gNMI libraries are built on top of the gRPC protocol.</p>
<p>All major network device vendors have some sort of gRPC and/or gNMI implementation on their newer network operating systems. Among them are Cisco, Juniper, Arista, Nokia, Broadcom, and others.</p>
<h3>Using gRPC in Python</h3>
<p>Only newer<a id="_idIndexMarker824"/> versions of Python support gRPC, and the Python version has to be 3.7 or above. To use it, you need to<a id="_idIndexMarker825"/> install <code>grpcio</code> (<a href="https://pypi.org/project/grpcio/">https://pypi.org/project/grpcio/</a>).</p>
<p>Examples of <a id="_idIndexMarker826"/>using gRPC in Python can be obtained here: <a href="https://grpc.io/docs/languages/python/quickstart/">https://grpc.io/docs/languages/python/quickstart/</a>.</p>
<h3>Using gRPC in Go</h3>
<p>In Go, gRPC <a id="_idIndexMarker827"/>can run on any major version. It is <a id="_idIndexMarker828"/>well documented and several examples can be found at <a href="https://github.com/grpc/grpc-go">https://github.com/grpc/grpc-go</a>.</p>
<h3>Using gNMI in Python</h3>
<p>Python <a id="_idIndexMarker829"/>support<a id="_idIndexMarker830"/> for gNMI is particularly rare. There are not many libraries available in the Python community. The following list describes the major ones:</p>
<ul>
<li><code>Cisco-gnmi-python</code> was <a id="_idIndexMarker831"/>created in 2018 and was initially supported by Cisco Networks. The library was created by Cisco to foment the use of gNMI on Cisco devices, and perhaps not a good match for multi-vendor support. More details <a id="_idIndexMarker832"/>can be found at <a href="https://github.com/cisco-ie/cisco-gnmi-python">https://github.com/cisco-ie/cisco-gnmi-python</a>.</li>
<li><code>gnmi-py</code> was <a id="_idIndexMarker833"/>created in 2019 and is sponsored by Arista Networks. This library does not support multi-vendor platforms and can be only used for Arista devices. More <a id="_idIndexMarker834"/>details can be found at <a href="https://github.com/arista-northwest/gnmi-py">https://github.com/arista-northwest/gnmi-py</a>.</li>
<li><code>pyygnmi</code> was <a id="_idIndexMarker835"/>created in 2020. The library can be imported using <code>pip</code> and has been tested on Cisco, Arista, Juniper, and Nokia devices. This would be the preferred choice for multi-vendor platform support. More details can be <a id="_idIndexMarker836"/>found at <a href="https://github.com/akarneliuk/pygnmi">https://github.com/akarneliuk/pygnmi</a>.</li>
</ul>
<h3>Using gNMI in Go</h3>
<p>For Go, gNMI is <a id="_idIndexMarker837"/>more mature and has better support compared to gNMI implementations <a id="_idIndexMarker838"/>for Python. There is only one library that can use gNMI in Go, which is called <code>openconfig-gnmi</code>.</p>
<p>The <code>openconfig-gnmi</code> library was <a id="_idIndexMarker839"/>created in 2016/2017 by Google and is now supported under the GitHub <code>openconfig</code> group. More on this library can be<a id="_idIndexMarker840"/> found at <a href="https://pkg.go.dev/github.com/openconfig/gnmi">https://pkg.go.dev/github.com/openconfig/gnmi</a>.</p>
<p>Besides the <code>openconfig-gnmi</code> library, there are other libraries related to gNMI in Go that you might find useful. Here is a list of the major ones:</p>
<ul>
<li><code>google-gnxi</code> is a <a id="_idIndexMarker841"/>combination of tools that can be used with gNMI and gNOI. Details <a id="_idIndexMarker842"/>can be found at <a href="https://github.com/google/gnxi">https://github.com/google/gnxi</a>.</li>
<li><code>openconfig-gnmi-gateway</code> is a library that can be used for high-availability streaming to collect network data with multiple clients. Details can be found <a id="_idIndexMarker843"/>at <a href="https://github.com/openconfig/gnmi-gateway">https://github.com/openconfig/gnmi-gateway</a>.</li>
<li><code>openconfig-gnmic</code> is a<a id="_idIndexMarker844"/> CLI tool written in Go that you can use to test gNMI capabilities. The CLI implements all gNMI client capabilities. More details can be found <a id="_idIndexMarker845"/>at https://github.com/openconfig/gnmic.</li>
</ul>
<p>So far, we have covered the major and most popular libraries used to access network devices via several different methods. Further discussion on this topic can be found in open chat communities such as Slack groups. Examples include <a href="https://devopschat.slack.com/">https://devopschat.slack.com/</a> and https://alldaydevops.slack.com/.</p>
<h1 id="_idParaDest-181"><a id="_idTextAnchor182"/>Summary</h1>
<p>In this chapter, we dove deeper into Python and Go runtime behavior, investigated how libraries are added to both languages, and we saw a few examples of network libraries to use when accessing the network devices.</p>
<p>This chapter provided sufficient information to help you differentiate how Python and Go run and how they can be used with standard and third-party libraries. Now, you should be able to choose a proper language for your network automation based on the requirements of performance, security, maintainability, and reliability. You should also be able to choose a proper method and a library to access your network devices, either for configuration purposes or to collect network data.  </p>
<p>In the next chapter, we are going to touch on how to handle errors in Go and Python, and how we can write code to handle exceptions properly in our network automation.</p>
</div>
</body></html>