- en: 2\. Models and Migrations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 模型和迁移
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces you to the concept of databases and their importance
    in building web applications. You will start by creating a database using an open-source
    database visualization tool called **SQLite DB Browser**. You will then perform
    some basic **Create Read Update Delete** (**CRUD**) database operations using
    SQL commands. Then, you will learn about Django's **Object Relational Mapping**
    (**ORM**), using which your application can interact and seamlessly work with
    a relational database using simple Python code, eliminating the need to run complex
    SQL queries. You will learn about **models** and **migrations**, which are a part
    of Django's ORM, that are used to propagate database schematic changes from the
    application to the database, and also perform database CRUD operations. Toward
    the end of the chapter, you will study the various types of database relationships
    and use that knowledge to perform queries across related records.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍数据库的概念及其在构建网络应用中的重要性。您将首先使用一个名为**SQLite DB Browser**的开源数据库可视化工具创建数据库。然后，您将使用SQL命令执行一些基本的**创建、读取、更新、删除**（**CRUD**）数据库操作。接着，您将学习Django的**对象关系映射**（**ORM**），使用它，您的应用程序可以使用简单的Python代码与关系型数据库无缝交互和工作，从而消除运行复杂SQL查询的需要。您将学习**模型**和**迁移**，它们是Django
    ORM的一部分，用于将数据库模式更改从应用程序传播到数据库，并执行数据库CRUD操作。在本章的末尾，您将研究各种类型的数据库关系，并利用这些知识对相关记录进行查询。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Data is at the core of most web applications. Unless we're talking about a very
    simple application such as a calculator, in most cases we need to store data,
    process it, and display it to the user on a page. Since most operations in user-facing
    web applications involve data, there is a need to store data in places that are
    secure, easily accessible, and readily available. This is where databases come
    in handy. Imagine a library operational before the advent of computers. The librarian
    would have to maintain records of book inventories, records of book lending, returns
    from students, and so on. All of these would have been maintained in physical
    records. The librarian, while carrying out their day-to-day activities, would
    modify these records for each operation, for example, when lending a book to someone
    or when the book was returned.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是大多数网络应用的核心。除非我们谈论的是一个非常简单的应用，例如计算器，在大多数情况下，我们需要存储数据，处理它，并在页面上向用户展示。由于用户界面网络应用中的大多数操作都涉及数据，因此需要在安全、易于访问和随时可用的地方存储数据。这正是数据库发挥作用的地方。想象一下在计算机出现之前运作的图书馆。图书管理员必须维护书籍库存记录、书籍借阅记录、学生归还记录等等。所有这些都会在物理记录中维护。图书管理员在执行日常活动时，会为每个操作修改这些记录，例如，当向某人借书或书籍归还时。
- en: 'Today, we have databases to help us with such administrative tasks. A database
    looks like a spreadsheet or an Excel sheet containing records, with each table
    consisting of multiple rows and columns. An application can have many such tables.
    Here is an example table of a book inventory in a library:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们有数据库来帮助我们处理这样的管理任务。数据库看起来像是一个包含记录的电子表格或Excel表，其中每个表由多行和多列组成。一个应用程序可以有许多这样的表。以下是一个图书馆书籍库存表的示例：
- en: '![Figure 2.1: Table of a book inventory for a library'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1：图书馆书籍库存表](img/B15509_02_01.jpg)'
- en: '](img/B15509_02_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_02_01.jpg)'
- en: 'Figure 2.1: Table of a book inventory for a library'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：图书馆书籍库存表
- en: In the preceding table, we can see that there are columns with details about
    various attributes of the books in the library, while the rows contain entries
    for each book. To manage a library, there can be many such tables working together
    as a system. For example, along with an inventory, we may have other tables such
    as student information, book lending records, and so on. Databases are built with
    the same logic, where software applications can easily manage data.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表中，我们可以看到有关于图书馆中书籍各种属性的详细信息的列，而行包含每本书的条目。为了管理图书馆，可以有多个这样的表作为一个系统协同工作。例如，除了库存之外，我们可能还有其他表，如学生信息、书籍借阅记录等等。数据库是用相同的逻辑构建的，其中软件应用程序可以轻松地管理数据。
- en: In the previous chapter, we had a brief introduction to Django and its use in
    developing web applications. Then we learned about the Model-View-Template (MVT)
    concept. Later, we created a Django project and started the Django development
    server. We also had a brief discussion about Django's views, URLs, and templates.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要介绍了 Django 及其在开发 Web 应用程序中的应用。然后我们学习了模型-视图-模板（MVT）的概念。随后，我们创建了一个 Django
    项目并启动了 Django 开发服务器。我们还简要讨论了 Django 的视图、URL 和模板。
- en: In this chapter, we will start by learning about the types of databases and
    a few basic database operations using SQL. After that, we will move on to the
    concept of models and migrations in Django, which assist in faster development
    by providing a layer of abstraction to facilitate database operations using Python
    objects.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先学习数据库的类型以及使用 SQL 进行的一些基本数据库操作。之后，我们将继续学习 Django 中的模型和迁移概念，这些概念通过提供一层抽象来简化数据库操作，从而加速开发过程。
- en: Databases
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库
- en: A database is a structured collection of data that helps manage information
    easily. A software layer called the Database Management System (DBMS) is used
    to store, maintain, and perform operations on the data. Databases are of two types,
    relational databases and non-relational databases.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库是一个结构化的数据集合，有助于轻松管理信息。一个称为数据库管理系统（DBMS）的软件层用于存储、维护和执行数据操作。数据库分为两种类型：关系型数据库和非关系型数据库。
- en: Relational Databases
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系型数据库
- en: Relational databases or Structured Query Language (SQL) databases store data
    in a pre-determined structure of rows and columns called tables. A database can
    be made up of more than one such table, and these tables have a fixed structure
    of attributes, data types, and relations with other tables. For example, as we
    just saw in *Figure 2.1*, the book inventory table has a fixed structure of columns
    comprising **Book Number**, **Author**, **Title**, and **Number of Copies**, and
    the entries form the rows in the table. There could be other tables as well, such
    as **Student Information** and **Lending Records**, which could be related to
    the inventory table. Also, whenever a book is lent to a student, the records will
    be stored per the relationships between multiple tables (say, the **Student Information**
    and the **Book Inventory** tables).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库或结构化查询语言（SQL）数据库将数据存储在预先确定的行和列结构中，这种结构称为表。一个数据库可以由多个这样的表组成，这些表具有固定的属性、数据类型和其他表之间的关系结构。例如，正如我们在
    *图 2.1* 中所看到的，图书库存表具有由 **书号**、**作者**、**标题** 和 **副本数量** 组成的固定列结构，而条目则形成表中的行。也可能有其他表，例如
    **学生信息** 和 **借阅记录**，这些表可能与库存表相关。此外，每当一本书借给学生时，记录将根据多个表之间的关系（例如，**学生信息** 和 **图书库存**
    表）进行存储。
- en: This pre-determined structure of rules defining the data types, tabular structures,
    and relationships across different tables acts like scaffolding or a blueprint
    for a database. This blueprint is collectively called a database schema. When
    applied to a database, it will prepare the database to store application data.
    To manage and maintain these databases, there is a common language for relational
    databases called SQL. Some examples of relational databases are SQLite, PostgreSQL,
    MySQL, and OracleDB.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 定义数据类型、表格结构和不同表之间关系的预定义规则结构类似于脚手架或数据库的蓝图。这个蓝图统称为数据库模式。当应用于数据库时，它将准备数据库以存储应用程序数据。为了管理和维护这些数据库，关系型数据库有一个通用的语言，称为
    SQL。一些关系型数据库的例子包括 SQLite、PostgreSQL、MySQL 和 OracleDB。
- en: Non-Relational Databases
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非关系型数据库
- en: Non-relational databases or NoSQL (Not Only SQL) databases are designed to store
    unstructured data. They are well suited to large amounts of generated data that
    does not follow rigid rules, as is the case with relational databases. Some examples
    of non-relational databases are Cassandra, MongoDB, CouchDB, and Redis.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 非关系型数据库或 NoSQL（不仅限于 SQL）数据库旨在存储非结构化数据。它们非常适合大量生成的不遵循严格规则的数据，正如关系型数据库的情况一样。一些非关系型数据库的例子包括
    Cassandra、MongoDB、CouchDB 和 Redis。
- en: For example, imagine that you need to store the stock value of companies in
    a database using Redis. Here, the company name will be stored as the key and the
    stock value as the value. Using the key-value type NoSQL database in this use
    case is appropriate because it stores the desired value for a unique key and is
    faster to access.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你需要使用 Redis 在数据库中存储公司的股票价值。在这里，公司名称将被存储为键，股票价值将被存储为值。在这个用例中使用键值类型的 NoSQL
    数据库是合适的，因为它为唯一的键存储了所需的价值，并且访问速度更快。
- en: For the scope of this book, we will be dealing only with relational databases
    as Django does not officially support non-relational databases. However, if you
    wish to explore, there are many forked projects, such as Django non-rel, that
    support NoSQL databases.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的范围内，我们将只处理关系型数据库，因为Django官方不支持非关系型数据库。然而，如果你希望探索，有许多分支项目，如Django non-rel，支持NoSQL数据库。
- en: Database Operations Using SQL
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SQL进行数据库操作
- en: SQL uses a set of commands to perform a variety of database operations, such
    as creating an entry, reading values, updating an entry, and deleting an entry.
    These operations are collectively called **CRUD operations**, which stands for
    Create, Read, Update, and Delete. To understand database operations in detail,
    let's first get some hands-on experience with SQL commands. Most relational databases
    share a similar SQL syntax; however, some operations will differ.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: SQL使用一系列命令来执行各种数据库操作，如创建条目、读取值、更新条目和删除条目。这些操作统称为**CRUD操作**，代表创建（Create）、读取（Read）、更新（Update）和删除（Delete）。为了详细了解数据库操作，让我们首先通过SQL命令获得一些实际操作经验。大多数关系型数据库共享类似的SQL语法；然而，某些操作可能会有所不同。
- en: For the scope of this chapter, we will use SQLite as the database. SQLite is
    a lightweight relational database that is a part of Python standard libraries.
    That's why Django uses SQLite as its default database configuration. However,
    we will also learn more about how to perform configuration changes to use other
    databases in *Chapter 17*, *Deployment of a Django Application (Part 1 – Server
    Setup)*. This chapter can be downloaded from the GitHub repository of this book,
    from [http://packt.live/2Kx6FmR](http://packt.live/2Kx6FmR).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的范围内，我们将使用SQLite作为数据库。SQLite是一个轻量级的关系型数据库，它是Python标准库的一部分。这就是为什么Django将其作为默认数据库配置。然而，我们还将学习如何在*第17章*，*Django应用程序的部署（第1部分
    - 服务器设置）*中执行配置更改以使用其他数据库。本章可以从本书的GitHub仓库中下载，从[http://packt.live/2Kx6FmR](http://packt.live/2Kx6FmR)。
- en: Data Types in Relational databases
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系型数据库中的数据类型
- en: 'Databases provide us with a way to restrict the type of data that can be stored
    in a given column. These are called data types. Some examples of data types for
    a relational database such as SQLite3 are given here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库为我们提供了一种限制给定列中可以存储的数据类型的方法。这些被称为数据类型。以下是一些关系型数据库（如SQLite3）的数据类型示例：
- en: '`INTEGER` is used for storing integers.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTEGER` 用于存储整数。'
- en: '`TEXT` can store text.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TEXT` 可以存储文本。'
- en: '`REAL` is used for floating-point values.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REAL` 用于存储浮点数。'
- en: For example, you would want the title of a book to have `TEXT` as the data type.
    So, the database will enforce a rule that no type of data, other than text data,
    can be stored in that column. Similarly, the book's price can have a `REAL` data
    type, and so on.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能希望书的标题使用 `TEXT` 作为数据类型。因此，数据库将强制执行一条规则，即在该列中只能存储文本数据，而不能存储其他类型的数据。同样，书的定价可以使用
    `REAL` 数据类型，等等。
- en: 'Exercise 2.01: Creating a Book Database'
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.01：创建图书数据库
- en: In this exercise, you will create a book database for a book review application.
    For better visualization of the data in the SQLite database, you will install
    an open-source tool called **DB Browser** for SQLite. This tool helps visualize
    the data and provides a shell to execute the SQL commands.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将为书评应用程序创建一个图书数据库。为了更好地可视化SQLite数据库中的数据，你将安装一个名为**DB Browser**的SQLite开源工具。此工具有助于可视化数据，并提供一个执行SQL命令的shell。
- en: If you haven't done so already, visit the URL [https://sqlitebrowser.org](https://sqlitebrowser.org)
    and from the *downloads* section, install the application as per your operating
    system and launch it. Detailed instructions for DB Browser installation can be
    found in the *Preface*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，请访问URL [https://sqlitebrowser.org](https://sqlitebrowser.org)，并在*下载*部分根据你的操作系统安装应用程序并启动它。DB
    Browser安装的详细说明可以在*前言*中找到。
- en: Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Database operations can be performed using a command-line shell as well.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用命令行shell执行数据库操作。
- en: 'After launching the application, create a new database by clicking `New Database`
    in the top-left corner of the application. Create a database named `bookr`, as
    you are working on a book review application:![Figure 2.2: Creating a database
    named bookr'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序后，通过点击应用程序左上角的“新建数据库”来创建一个新的数据库。创建一个名为 `bookr` 的数据库，因为你正在开发一个书评应用程序：![图2.2：创建名为bookr的数据库
- en: '](img/B15509_02_02.jpg)'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15509_02_02.jpg]'
- en: 'Figure 2.2: Creating a database named bookr'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.2：创建名为bookr的数据库
- en: Next, click the `Create Table` button in the top-left corner and enter `book`
    as the table name.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击左上角的`创建表`按钮，输入表名为`book`。
- en: Note
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: After clicking the `Save` button, you may find that the window for creating
    a table opens up automatically. In that case, you won't have to click the `Create
    Table` button; simply proceed with the creation of the book table as specified
    in the preceding step.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击`保存`按钮后，你可能发现创建表的窗口会自动打开。在这种情况下，你不需要点击`创建表`按钮；只需按照前面步骤指定的方式继续创建图书表即可。
- en: 'Now, click the `Add field` button, enter the field name as `title`, and select
    the type as `TEXT` from the dropdown. Here `TEXT` is the data type for the `title`
    field in the database:![Figure 2.3: Adding a TEXT field named title'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击`添加字段`按钮，输入字段名为`title`，并从下拉菜单中选择类型为`TEXT`。在这里，`TEXT`是数据库中`title`字段的类型：![图2.3：添加名为title的文本字段]
- en: '](img/B15509_02_03.jpg)'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片B15509_02_03.jpg]'
- en: 'Figure 2.3: Adding a TEXT field named title'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.3：添加一个名为title的文本字段
- en: 'Similarly, add two more fields for the table named `publisher` and `author`
    and select `TEXT` as the type for both the fields. Then, click the `OK` button:![Figure
    2.4: Creating TEXT fields named publisher and author'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，为名为`publisher`和`author`的表添加两个更多字段，并将两个字段的类型都选择为`TEXT`。然后，点击`确定`按钮：![图2.4：创建名为publisher和author的文本字段]
- en: '](img/B15509_02_04.jpg)'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片B15509_02_04.jpg]'
- en: 'Figure 2.4: Creating TEXT fields named publisher and author'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：创建名为publisher和author的文本字段
- en: 'This creates a database table called `book` in the `bookr` database with the
    fields title, publisher, and `author`. This can be seen as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这在`bookr`数据库中创建了一个名为`book`的数据库表，包含字段title、publisher和`author`。如下所示：
- en: '![Figure 2.5: Database with the fields title, publisher, and author'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5：包含字段title、publisher和author的数据库]'
- en: '](img/B15509_02_05.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片B15509_02_05.jpg]'
- en: 'Figure 2.5: Database with the fields title, publisher, and author'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5：包含字段title、publisher和author的数据库]'
- en: In this exercise, we used an open-source tool called DB Browser (SQLite) to
    create our first database called `bookr`, and in it, we created our first table
    named `book`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用了一个名为DB Browser（SQLite）的开源工具来创建我们的第一个数据库`bookr`，并在其中创建了我们第一个名为`book`的表。
- en: SQL CRUD Operations
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL CRUD操作
- en: Let's assume that the editors or the users of our book review application want
    to make some modifications to the book inventory, such as adding a few books to
    the database, updating an entry in the database, and so on. SQL provides various
    ways to perform such CRUD operations. Before we dive into the world of Django
    models and migrations, let's explore these basic SQL operations first.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的书评应用编辑器或用户想要对图书库存进行一些修改，例如向数据库中添加几本书，更新数据库中的条目等。SQL提供了各种方式来执行此类CRUD操作。在我们深入Django模型和迁移的世界之前，让我们首先探索这些基本的SQL操作。
- en: 'For the CRUD operations that follow, you will be running a few SQL queries.
    To run them, navigate to the `Execute SQL` tab in DB Browser. You can type in
    or paste the SQL queries we''ve listed in the sections that follow in the `SQL
    1` window. You can spend some time modifying your queries, and understanding them,
    before you execute them. When you''re ready, click the icon that looks like a
    `Play` button or press the F5 key to execute the command. The results will show
    up in the window below the `SQL 1` window:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接下来的CRUD操作，你将运行几个SQL查询。要运行它们，导航到DB Browser中的`执行SQL`标签页。你可以在`SQL 1`窗口中键入或粘贴我们在后续部分列出的SQL查询。在执行它们之前，你可以花些时间修改和了解这些查询。准备好后，点击看起来像播放按钮的图标或按F5键来执行命令。结果将显示在`SQL
    1`窗口下面的窗口中：
- en: '![Figure 2.6: Executing SQL queries in DB Browser'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6：在DB Browser中执行SQL查询]'
- en: '](img/B15509_02_06.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片B15509_02_06.jpg]'
- en: 'Figure 2.6: Executing SQL queries in DB Browser'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6：在DB Browser中执行SQL查询]'
- en: SQL Create Operations
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL创建操作
- en: 'The `insert` command, which, as the name implies, lets us insert data into
    the database. Let''s go back to our `bookr` example. Since we have already created
    the database and the `book` table, we can now create or insert an entry in the
    database by executing the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert`命令，正如其名所示，允许我们将数据插入到数据库中。让我们回到我们的`bookr`示例。由于我们已经创建了数据库和`book`表，我们现在可以通过执行以下命令在数据库中创建或插入一个条目：'
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This inserts into the table named `book` the values defined in the command.
    Here, `The Sparrow Warrior` is the title, `Super Hero Publications` is the publisher,
    and `Patric Javagal` is the author of the book. Note that the order of insertion
    corresponds with the way we have created our table; that is, the values are inserted
    into the columns representing title, publisher, and author respectively. Similarly,
    let''s execute two more inserts to populate the `book` table:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把命令中定义的值插入到名为 `book` 的表中。在这里，`The Sparrow Warrior` 是标题，`Super Hero Publications`
    是出版社，`Patric Javagal` 是这本书的作者。请注意，插入的顺序与我们创建表的方式相对应；也就是说，值分别插入到代表标题、出版社和作者的列中。同样，让我们执行另外两个插入操作以填充
    `book` 表：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The three inserts executed so far will insert three rows into the `book` table.
    But how do we verify that? How would we know whether those three entries we inserted
    were entered into the database correctly? Let's learn how to do that in the next
    section.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止已执行了三个插入操作，将三个行插入到 `book` 表中。但我们如何验证这一点？我们如何知道我们插入的三个条目是否正确地输入到数据库中？让我们在下一节中学习如何做到这一点。
- en: SQL Read Operations
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL 读取操作
- en: 'We can read from the database using the `select` SQL operation. For example,
    the following SQL `select` command retrieves the selected entries created in the
    `book` table:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `select` SQL 操作从数据库中读取。例如，以下 SQL `select` 命令检索在 `book` 表中创建的所选条目：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should see the following output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![Figure 2.7: Output after using the select command'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.7：使用选择命令后的输出'
- en: '](img/B15509_02_07.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_02_07.jpg)'
- en: 'Figure 2.7: Output after using the select command'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7：使用选择命令后的输出
- en: 'Here, `select` is the command that reads from the database, and the fields
    `title`, `publisher`, and `author` are the columns that we intend to select from
    the book table. Since these are all the columns the database has, the select statement
    has returned all the values present in the database. The select statement is also
    called a SQL query. An alternate way to get all the fields in the database is
    by using the wildcard `*` in the select query instead of specifying all the column
    names explicitly:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`select` 是从数据库中读取的命令，字段 `title`、`publisher` 和 `author` 是我们打算从书籍表中选择的列。由于这些列都是数据库中有的，所以选择语句返回了数据库中所有存在的值。选择语句也被称为
    SQL 查询。另一种获取数据库中所有字段的方法是在选择查询中使用通配符 `*` 而不是明确指定所有列名：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will return the same output as shown in the preceding figure. Now, suppose
    we want to get the author name for the book titled `The Sparrow Warrior`; in this
    case, the `select` query would be as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回与前面图中所示相同的输出。现在，假设我们想获取名为《The Sparrow Warrior》的书的作者姓名；在这种情况下，`select` 查询将如下所示：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we have added a special SQL keyword called `where` so that the `select`
    query returns only the entries that match the condition. The result of the query,
    of course, will be `Patric Javagal`. Now, what if we wanted to change the name
    of the book's publisher?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们添加了一个特殊的 SQL 关键字 `where`，以便 `select` 查询只返回与条件匹配的条目。查询的结果当然是 `Patric Javagal`。现在，如果我们想更改书的出版社的名称呢？
- en: SQL Update Operations
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL 更新操作
- en: 'In SQL, the way to update a record in the database is by using the `update`
    command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL 中，更新数据库中记录的方式是通过使用 `update` 命令：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we are setting the value of publisher to `Northside Publications` if
    the value of the title is `The Sparrow Warrior`. We can then run the `select`
    query we ran in the SQL Read Operations section to see how the updated table looks
    after running the `update` command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们设置出版社的值为 `Northside Publications`，如果标题的值为 `The Sparrow Warrior`。然后我们可以运行在
    SQL 读取操作部分运行的 `select` 查询，以查看运行 `update` 命令后更新的表看起来如何：
- en: '![Figure 2.8: Updating the value of publisher for the title The Sparrow Warrior'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.8：更新《The Sparrow Warrior》标题的出版社值'
- en: '](img/B15509_02_08.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_02_08.jpg)'
- en: 'Figure 2.8: Updating the value of publisher for the title The Sparrow Warrior'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8：更新《The Sparrow Warrior》标题的出版社值
- en: Next, what if we wanted to delete the title of the record we just updated?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果我们想删除刚刚更新的记录的标题呢？
- en: SQL Delete Operations
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL 删除操作
- en: 'Here is an example of how to delete a record from the database using the `delete` command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用 `delete` 命令从数据库中删除记录的示例：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`delete` is the SQL keyword for delete operations. Here, this operation will
    be performed only if the title is `The Sparrow Warrior`. Here is how the book
    table will look after the delete operation:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`是SQL中用于删除操作的关键字。在这里，只有当标题为`The Sparrow Warrior`时，才会执行此操作。以下是删除操作后书籍表的外观：'
- en: '![Figure 2.9: Output after performing the delete operation'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.9：执行删除操作后的输出]'
- en: '](img/B15509_02_09.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.9：执行删除操作后的输出]'
- en: 'Figure 2.9: Output after performing the delete operation'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.9：执行删除操作后的输出]'
- en: These are the basic operations of SQL. We will not go very deep into all the
    SQL commands and syntax, but feel free to explore more about database base operations
    using SQL.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是SQL的基本操作。我们不会深入探讨所有的SQL命令和语法，但你可以自由探索使用SQL进行数据库基础操作的相关内容。
- en: Note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For further reading, you can start by exploring some advanced SQL `select` operations
    with `join` statements, which are used to query data across multiple tables. For
    a detailed course on SQL, you can refer to *The SQL Workshop* ([https://www.packtpub.com/product/the-sql-workshop/9781838642358](https://www.packtpub.com/product/the-sql-workshop/9781838642358)).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步学习，你可以从探索一些使用`join`语句的高级SQL `select`操作开始，这些操作用于查询多个表中的数据。有关SQL的详细课程，你可以参考*The
    SQL Workshop* ([https://www.packtpub.com/product/the-sql-workshop/9781838642358](https://www.packtpub.com/product/the-sql-workshop/9781838642358))。
- en: Django ORM
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django ORM
- en: Web applications constantly interact with databases, and one of the ways to
    do so is using SQL. If you decide to write a web application without a web framework
    like Django and instead use Python alone, Python libraries such as `psycopg2`
    could be used to interact directly with the databases using SQL commands. But
    while developing a web application with multiple tables and fields, SQL commands
    can easily become overly complex and thus difficult to maintain. For this reason,
    popular web frameworks such as Django provide a level of abstraction using which
    we can easily work with databases. The part of Django that helps us do this is
    called **ORM**, which stands for **Object Relational Mapping**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序不断与数据库进行交互，其中一种方式就是使用SQL。如果你决定不使用像Django这样的网络框架，而是单独使用Python来编写网络应用程序，那么可以使用Python库如`psycopg2`来直接使用SQL命令与数据库进行交互。但在开发包含多个表和字段的网络应用程序时，SQL命令可能会变得过于复杂，从而难以维护。因此，像Django这样的流行网络框架提供了抽象层，使我们能够轻松地与数据库进行交互。Django中帮助我们完成这一功能的部分被称为**ORM**，即**对象关系映射**。
- en: Django ORM converts object-oriented Python code into actual database constructs
    such as database tables with data type definitions and facilitates all the database
    operations via simple Python code. Because of this, we do not have to deal with
    SQL commands while performing database operations. This helps in faster application
    development and ease in maintaining the application source code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Django ORM将面向对象的Python代码转换为实际的数据库结构，如具有数据类型定义的数据库表，并通过简单的Python代码简化所有数据库操作。正因为如此，我们在执行数据库操作时无需处理SQL命令。这有助于加快应用程序的开发速度，并简化应用程序源代码的维护。
- en: Django supports relational databases such as SQLite, PostgreSQL, Oracle Database,
    and MySQL. Django's database abstraction layer ensures that the same Python/Django
    source code can be used across any of the above relational databases with very
    little modification to the project settings. Since SQLite is part of the Python
    libraries and Django is configured by default to SQLite, for the scope of this
    chapter, we shall use SQLite while we learn about Django models and migrations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Django支持关系型数据库，如SQLite、PostgreSQL、Oracle数据库和MySQL。Django的数据库抽象层确保了相同的Python/Django源代码可以在上述任何关系型数据库上使用，只需对项目设置进行很少的修改。由于SQLite是Python库的一部分，并且Django默认配置为SQLite，因此在本章的学习过程中，我们将使用SQLite来了解Django模型和迁移。
- en: Database Configuration and Creating Django Applications
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库配置和创建Django应用程序
- en: As we have already seen in *Chapter 1*, *Introduction to Django*, when we create
    a Django project and run the Django server, the default database configuration
    is of SQLite3\. The database configuration will be present in the project directory,
    in the `settings.py` file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第一章*，*Django简介*中已经看到的，当我们创建Django项目并运行Django服务器时，默认的数据库配置是SQLite3。数据库配置将位于项目目录中的`settings.py`文件中。
- en: Note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Make sure you go through the `settings.py` file for the `bookr` app. Going
    through the entire file once will help you understand the concepts that follow.
    You can find the file at this link: [http://packt.live/2KEdaUM](http://packt.live/2KEdaUM).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您仔细阅读`bookr`应用的`settings.py`文件。通读整个文件一次将有助于您理解后续的概念。您可以通过此链接找到文件：[http://packt.live/2KEdaUM](http://packt.live/2KEdaUM)。
- en: 'So, for our example project, the database configuration will be present at
    the following location: `bookr/settings.py`. The default database configuration
    present in this file, when a Django project is created, is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于我们的示例项目，数据库配置将位于以下位置：`bookr/settings.py`。当创建Django项目时，该文件中默认的数据库配置如下：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding code snippet uses a backslash ( \ ) to split the logic across
    multiple lines. When the code is executed, Python will ignore the backslash, and
    treat the code on the next line as a direct continuation of the current line.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段使用反斜杠（\）将逻辑拆分到多行。当代码执行时，Python将忽略反斜杠，并将下一行的代码视为当前行的直接延续。
- en: The DATABASES variable is assigned with a dictionary containing the database
    details for the project. Inside the dictionary, there is a nested dictionary with
    a key as default. This holds the configuration of a default database for the Django
    project. The reason we have a nested dictionary with `default` as a key is that
    a Django project could potentially interact with multiple databases, and the default
    database is the one used by Django for all operations unless explicitly specified.
    The ENGINE key represents which database engine is being used; in this case, it
    is `sqlite3`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`DATABASES`变量被分配了一个包含项目数据库详细信息的字典。在字典中，有一个嵌套字典，其键为`default`。这包含了Django项目的默认数据库配置。我们使用带有`default`键的嵌套字典的原因是，Django项目可能需要与多个数据库交互，而默认数据库是Django在所有操作中默认使用的数据库，除非明确指定。`ENGINE`键表示正在使用哪个数据库引擎；在这种情况下，它是`sqlite3`。'
- en: The `NAME` key defines the name of the database, which can have any value. But
    for SQLite3, since the database is created as a file, `NAME` can have the full
    path of the directory where the file needs to be created. The full path of the
    `db` file is processed by joining (or concatenating) the previously defined path
    in `BASE_DIR` with `db.sqlite3`. Note that `BASE_DIR` is the project directory
    as already defined in the `settings.py` file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`NAME`键定义了数据库的名称，可以有任何值。但对于SQLite3，由于数据库是以文件形式创建的，因此`NAME`可以包含需要创建文件的目录的完整路径。`db`文件的完整路径是通过将`BASE_DIR`中定义的先前路径与`db.sqlite3`连接（或连接）来处理的。请注意，`BASE_DIR`是在`settings.py`文件中已定义的项目目录。'
- en: 'If you are using other databases, such as PostgreSQL, MySQL, and so on, changes
    will have to be made in the preceding database settings as shown here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用其他数据库，例如PostgreSQL、MySQL等，则需要在此前的数据库设置中进行更改，如下所示：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, changes have been made to `ENGINE` to use PostgreSQL. The host IP address
    and port number of the server need to be provided for `HOST` and `PORT` respectively.
    As the names suggest, `USER` is the database username and `PASSWORD` is the database
    password. In addition to changes in the configuration, we will have to install
    the database drivers or bindings along with the database host and credentials.
    This will be covered in detail in later chapters, but for now, since we are using
    SQLite3, the default configuration will be sufficient. Note that the above is
    just an example to show the changes you'll need to make to use a different database
    such as PostgreSQL, but since we are using SQLite, we shall use the database configuration
    that exists already, and there is no need to make any modifications to the database
    settings.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，已对`ENGINE`进行了更改以使用PostgreSQL。需要分别提供服务器的IP地址和端口号作为`HOST`和`PORT`。正如其名称所暗示的，`USER`是数据库用户名，`PASSWORD`是数据库密码。除了配置更改外，我们还需要安装数据库驱动程序或绑定，包括数据库主机和凭证。这将在后面的章节中详细说明，但就目前而言，由于我们正在使用SQLite3，默认配置就足够了。请注意，上面的只是一个示例，以展示您需要为使用不同的数据库（如PostgreSQL）所做的更改，但由于我们正在使用SQLite，我们将使用现有的数据库配置，并且不需要对数据库设置进行任何修改。
- en: Django Apps
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django应用
- en: A Django project can have multiple apps that often act as discrete entities.
    That's why, whenever required, an app can be plugged into a different Django project
    as well. For example, if we are developing an e-commerce web application, the
    web application can have multiple apps, such as a chatbot for customer support
    or a payment gateway to accept payments as users purchase goods from the application.
    These apps, if needed, can also be plugged into or reused in a different project.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Django 项目可以有多个应用程序，这些应用程序通常作为独立的实体。这就是为什么，在需要时，一个应用程序也可以插入到不同的 Django 项目中。例如，如果我们正在开发一个电子商务网络应用程序，该网络应用程序可以有多个应用程序，例如用于客户支持的聊天机器人或用于接受用户从应用程序购买商品时的支付网关。如果需要，这些应用程序也可以插入到或在不同项目中重用。
- en: 'Django comes with the following apps enabled by default. The following is a
    snippet from a project''s `settings.py` file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Django 默认启用了以下应用程序。以下是从一个项目的 `settings.py` 文件中摘录的一段内容：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These are a set of installed or default apps used for the admin site, authentication,
    content types, sessions, messaging, and an application to collect and manage static
    files. In the upcoming chapters, we shall study this in-depth. For the scope of
    this chapter, though, we shall understand why Django migration is needed for these
    installed apps.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一组用于管理站点、身份验证、内容类型、会话、消息传递以及用于收集和管理静态文件的应用程序。在接下来的章节中，我们将深入研究这些内容。然而，在本章范围内，我们将了解为什么
    Django 迁移对于这些已安装的应用程序是必要的。
- en: Django Migration
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django 迁移
- en: As we have learned before, Django's ORM helps make database operations simpler.
    A major part of the operation is to transform the Python code into database structures
    such as database fields with stated data types and tables. In other words, the
    transformation of Python code into database structures is known as `TEXT` in *step
    4* of *Exercise 2.01*, *Creating a Book Database*).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所学的，Django 的 ORM 有助于使数据库操作更简单。操作的主要部分是将 Python 代码转换为数据库结构，如具有指定数据类型的数据库字段和表。换句话说，将
    Python 代码转换为数据库结构称为 *Exercise 2.01*，*创建一个图书数据库*）中的 *第 4 步* 的 `TEXT`。
- en: 'Since we have a Django project set up, let''s perform our first migration.
    Although we have not added any code yet to our project, we can migrate the applications
    listed in `INSTALLED_APPS`. This is necessary because Django''s installed apps
    need to store the relevant data in the database for their operations, and migration
    will create the required database tables to store the data in the database. The
    following command should be entered in the terminal or shell to do this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经设置了 Django 项目，让我们执行第一次迁移。尽管我们还没有向项目中添加任何代码，但我们仍然可以迁移 `INSTALLED_APPS`
    中列出的应用程序。这是必要的，因为 Django 安装的程序需要将相关数据存储在数据库中以供其操作，迁移将创建所需的数据库表以在数据库中存储数据。为此，应在终端或
    shell 中输入以下命令：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For macOS, you can use `python3` instead of `python` in the preceding command.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 macOS，您可以在上述命令中使用 `python3` 而不是 `python`。
- en: Here, `manage.py` is a script that was automatically created when the project
    was created. It is used for carrying out managerial or administrative tasks. By
    executing this command, we create all the database structures required by the
    installed apps.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`manage.py` 是在创建项目时自动创建的脚本。它用于执行管理或行政任务。通过执行此命令，我们创建所有已安装应用程序所需的数据库结构。
- en: As we are using DB Browser for SQLite to browse the database, let's take a look
    at the database for which changes have been made after executing the `migrate` command.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用 DB Browser for SQLite 浏览数据库，让我们看一下执行 `migrate` 命令后已更改的数据库。
- en: 'The database file will have been created in the project directory under the
    name `db.sqlite3`. Open DB Browser, click `Open Database`, navigate until you
    find the `db.sqlite3` file, and open it. You should see a set of newly created
    tables created by the Django migration. It will look as follows in DB Browser:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库文件将在项目目录下以 `db.sqlite3` 的名称创建。打开 DB Browser，点击 `Open Database`，导航直到找到 `db.sqlite3`
    文件，然后打开它。您应该会看到由 Django 迁移创建的一组新表。在 DB Browser 中看起来如下：
- en: '![Figure 2.10: Contents of the db.sqlite3 file'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.10：db.sqlite3 文件的内容'
- en: '](img/B15509_02_10.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_02_10.jpg)'
- en: 'Figure 2.10: Contents of the db.sqlite3 file'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10：db.sqlite3 文件的内容
- en: 'Now, if we browse through the newly created database structure by clicking
    the database tables, we see the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们通过点击数据库表浏览新创建的数据库结构，我们会看到以下内容：
- en: '![Figure 2.11: Browsing through the newly created database structure'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.11：浏览新创建的数据库结构'
- en: '](img/B15509_02_11.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15509_02_11.jpg)'
- en: 'Figure 2.11: Browsing through the newly created database structure'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11：浏览新创建的数据库结构
- en: 'Notice that the database tables created have different fields, each with their
    respective data types. Click the `Browse data` tab in DB Browser and select a
    table from the dropdown. For instance, after clicking the `auth_group_permissions`
    table, you should see something like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到创建的数据库表有不同的字段，每个字段都有其对应的数据类型。在DB Browser中点击`浏览数据`标签页，并从下拉菜单中选择一个表。例如，在点击`auth_group_permissions`表后，您应该看到类似以下的内容：
- en: '![Figure 2.12: Viewing the auth_group_permissions table'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.12: Viewing the auth_group_permissions table'
- en: '](img/B15509_02_12.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15509_02_12.jpg](img/B15509_02_12.jpg)'
- en: 'Figure 2.12: Viewing the auth_group_permissions table'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12：查看auth_group_permissions表
- en: You will see that there is no data available for these tables yet because Django
    migration only creates the database structure or the blueprint, and the actual
    data in the database is stored during the operation of the application. Now since
    we have migrated the built-in or default Django apps, let's try to create an app
    and perform a Django migration.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到这些表还没有数据，因为Django迁移只创建数据库结构或蓝图，而实际数据是在应用程序运行期间存储在数据库中的。现在，既然我们已经迁移了内置或默认的Django应用程序，让我们尝试创建一个应用程序并执行Django迁移。
- en: Creating Django Models and Migrations
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Django模型和迁移
- en: A Django model is essentially a Python class that holds the blueprint for creating
    a table in a database. The `models.py` file can have many such models, and each
    model transforms into a database table. The attributes of the class form the fields
    and relationships of the database table as per the model definitions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Django模型本质上是一个Python类，它包含了在数据库中创建表的蓝图。`models.py`文件可以包含许多这样的模型，每个模型都会转换成一个数据库表。类的属性根据模型定义形成了数据库表的字段和关系。
- en: 'For our reviews application, we need to create the following models and their
    database tables consequently:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的评论应用程序，我们需要创建以下模型及其相应的数据库表：
- en: 'Book: This should store information about books.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍：这个模型应该存储关于书籍的信息。
- en: 'Contributor: This should store information about the person(s) who contributed
    to writing the book, such as author, co-author, or editor.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贡献者：这个模型应该存储关于为书籍写作的个人（如作者、合著者或编辑）的信息。
- en: 'Publisher: As the name implies, this refers to the book publisher.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出版社：正如其名所示，这指的是书籍的出版社。
- en: 'Review: This should store all the books'' reviews written by the users of the application.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评论：这个模型应该存储应用程序用户所写的所有书籍评论。
- en: 'Every book in our application will need to have a publisher, so let''s create
    `Publisher` as our first model. Enter the following code in `reviews/models.py`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，每本书都需要有一个出版社，因此让我们创建`Publisher`作为我们的第一个模型。在`reviews/models.py`中输入以下代码：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can take a look at the complete models.py file for the bookr app by clicking
    the following link: [http://packt.live/3hmFQxn](http://packt.live/3hmFQxn).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过点击以下链接查看bookr应用程序的完整`models.py`文件：[http://packt.live/3hmFQxn](http://packt.live/3hmFQxn)。
- en: The first line of code imports the Django's `models` module. While this line
    will be autogenerated at the time of the creation of the Django app, do make sure
    you add it if it is not present. Following the import, the rest of the code is
    defining a class named `Publisher`, which will be a subclass of Django's `models.Model`.
    Furthermore, this class will have attributes or fields such as name, website,
    and email.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一行导入了Django的`models`模块。虽然这一行将在创建Django应用程序时自动生成，但请确保如果它不存在，您已经添加了它。在导入之后，其余的代码定义了一个名为`Publisher`的类，它将是Django的`models.Model`的子类。此外，这个类将具有名称、网站和电子邮件等属性或字段。
- en: Field Types
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段类型
- en: 'As we can see, each of these fields is defined to have the following types:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，每个字段都被定义为以下类型：
- en: '`CharField`: This field type is used to store shorter string fields, for example,
    Packt Publishing. For very large strings, we use `TextField`.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CharField`：这种字段类型用于存储较短的字符串字段，例如，Packt Publishing。对于非常长的字符串，我们使用`TextField`。'
- en: '`EmailField`: This is similar to `CharField`, but validates whether the string
    represents a valid email address, for example, customersupport@packtpub.com.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmailField`：这与`CharField`类似，但会验证字符串是否代表一个有效的电子邮件地址，例如，customersupport@packtpub.com。'
- en: '`URLField`: This is again similar to `CharField`, but validates whether the
    string represents a valid URL, for example, [https://www.packtpub.com](https://www.packtpub.com).'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URLField`：这又类似于`CharField`，但会验证字符串是否代表一个有效的URL，例如，[https://www.packtpub.com](https://www.packtpub.com)。'
- en: Field Options
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段选项
- en: 'Django provides a way to define field options to a model''s field. These field
    options are used to set a value or a constraint, and so on. For example, we can
    set a default value for a field using `default=<value>`, to ensure that every
    time a record is created in the database for the field, it is set to a default
    value specified by us. Following are the two field options that we have used while
    defining the `Publisher` model:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了一种为模型字段定义字段选项的方法。这些字段选项用于设置值或约束等。例如，我们可以使用`default=<value>`为字段设置默认值，以确保每次在数据库中为该字段创建记录时，它都被设置为指定的默认值。以下是我们定义`Publisher`模型时使用的两个字段选项：
- en: '`help_text`: This is a field option that helps us add descriptive text for
    a field that gets automatically included for Django forms.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`help_text`：这是一个字段选项，帮助我们为字段添加描述性文本，该文本会自动包含在Django表单中。'
- en: '`max_length`: This option is provided to `CharField` where it defines the maximum
    length of the field in terms of the number of characters.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_length`：此选项提供给了`CharField`，其中它定义了字段以字符数表示的最大长度。'
- en: 'Django has many more field types and field options that can be explored from
    the extensive official Django documentation. As we go about developing our sample
    book review application, we shall learn about those types and fields that are
    used for the project. Now let''s migrate the Django models into the database.
    Execute the following command in the shell or terminal to do that (run it from
    the folder where your `manage.py` file is stored):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Django有许多更多的字段类型和字段选项，可以在广泛的官方Django文档中进行探索。随着我们开发我们的示例书评应用程序，我们将了解用于项目的那些类型和字段。现在让我们将Django模型迁移到数据库中。在shell或终端中执行以下命令以完成此操作（从存储`manage.py`文件的文件夹中运行）：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output of the command looks like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出如下：
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `makemigrations <appname>` command creates the migration scripts for the
    given app; in this case, for the reviews app. Notice that after running makemigrations,
    there is a new file created under the `migrations` folder:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`makemigrations <appname>`命令为给定的应用创建迁移脚本；在这种情况下，为reviews应用。注意，在运行makemigrations之后，在`migrations`文件夹下创建了一个新文件：'
- en: '![Figure 2.13: New file under the migrations folder'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.13：在migrations文件夹下创建的新文件'
- en: '](img/B15509_02_13.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.13：在migrations文件夹下创建的新文件'
- en: 'Figure 2.13: New file under the migrations folder'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13：在migrations文件夹下创建的新文件
- en: 'This is the migration script created by Django. When we run `makemigrations`
    without the app name, the migration scripts will be created for all the apps in
    the project. Next, let''s list the project migration status. Remember that earlier,
    we applied migrations to Django''s installed apps and now we have created a new
    app, reviews. The following command, when run in the shell or terminal, will show
    the status of model migrations throughout the project (run it from the folder
    where your `manage.py` file is stored):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Django创建的迁移脚本。当我们运行不带应用名称的`makemigrations`时，将为项目中的所有应用创建迁移脚本。接下来，让我们列出项目的迁移状态。记住，之前我们为Django已安装的应用程序应用了迁移，现在我们创建了一个新的应用，reviews。以下命令在shell或终端中运行时，将显示整个项目中模型迁移的状态（从存储`manage.py`文件的文件夹中运行）：
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output for the preceding command is as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令的输出如下：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, the `[X]` mark indicates that the migrations have been applied. Notice
    the difference that all the other apps' migrations have applied except that of
    reviews. The `showmigrations` command can be executed to understand the migration
    status, but this is not a mandatory step while performing model migrations.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`[X]`标记表示迁移已经应用。注意，除了reviews之外，所有其他应用的迁移都已应用。可以使用`showmigrations`命令来了解迁移状态，但在执行模型迁移时这不是一个强制性的步骤。
- en: 'Next, let''s understand how Django transforms a model into an actual database
    table. This can be understood by running the `sqlmigrate` command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们了解Django如何将模型转换为实际的数据库表。这可以通过运行`sqlmigrate`命令来理解：
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We should see the following output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到以下输出：
- en: '[PRE17]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding snippet shows the SQL command equivalent used when Django migrates
    the database. In this case, we are creating the `reviews_publisher` table with
    the fields name, website, and email with the defined field types. Furthermore,
    all these fields are defined to be `NOT NULL`, implying that the entries for these
    fields cannot be null and should have some value. The `sqlmigrate` command is
    not a mandatory step while doing the model migrations.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段显示了当 Django 迁移数据库时使用的 SQL 命令等效。在这种情况下，我们正在创建一个名为 `reviews_publisher`
    的表，包含名称、网站和电子邮件字段，并定义了相应的字段类型。此外，所有这些字段都被定义为 `NOT NULL`，这意味着这些字段的条目不能为空，应该有一些值。在执行模型迁移时，`sqlmigrate`
    命令不是必须的步骤。
- en: Primary Keys
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主键
- en: Let's assume that a database table called users, as its name suggests, stores
    information about users. Let's say it has more than 1,000 records and there are
    at least 3 users with the same name, Joe Burns. How do we uniquely identify these
    users from the application? The solution is to have a way to uniquely identify
    each record in the database. This is done using `id` as the primary key (of type
    integer), which auto increments as new records are created.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个名为 users 的数据库表，正如其名称所暗示的，它存储有关用户的信息。假设它有超过 1,000 条记录，并且至少有 3 个用户的名字叫 Joe
    Burns。我们如何从应用程序中唯一地识别这些用户呢？解决方案是找到一种方法来唯一地识别数据库中的每条记录。这是通过使用 `id` 作为主键（整数类型）来实现的，它在创建新记录时会自动递增。
- en: 'In the previous section, notice the output of the `python manage.py sqlmigrate`
    command. While creating the `Publisher` table, the `SQL CREATE TABLE` command
    was adding one more field called `id` to the table. `id` is defined to be `PRIMARY
    KEY AUTOINCREMENT`. In relational databases, a primary key is used to uniquely
    identify an entry in the database. For example, the book table has `id` as the
    primary key, which has numbers starting from 1\. This value increments by 1 as
    new records are created. The integer value of `id` is always unique across the
    book table. Since the migration script has already been created by executing makemigrations,
    let''s now migrate the newly created model in the reviews app by executing the
    following command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，注意 `python manage.py sqlmigrate` 命令的输出。在创建 `Publisher` 表时，`SQL CREATE
    TABLE` 命令向表中添加了一个额外的字段，称为 `id`。`id` 被定义为 `PRIMARY KEY AUTOINCREMENT`。在关系型数据库中，主键用于在数据库中唯一地标识一个条目。例如，书籍表有
    `id` 作为主键，其数字从 1 开始。这个值在新记录创建时会递增 1。`id` 的整数值在书籍表中总是唯一的。由于迁移脚本已经通过执行 makemigrations
    被创建，现在让我们通过执行以下命令来迁移 reviews 应用程序中新建的模型：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You should get the following output:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This operation creates the database table for the reviews app. The following
    is a snippet from DB Browser indicating the new table `reviews_publisher` has
    been created in the database:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作创建了 reviews 应用的数据库表。以下是从 DB Browser 中摘录的片段，表明新表 `reviews_publisher` 已在数据库中创建：
- en: '![Figure 2.14: reviews_publisher table created after executing the migration
    command'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.14：执行迁移命令后创建的 reviews_publisher 表]'
- en: '](img/B15509_02_14.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15509_02_14.jpg]'
- en: 'Figure 2.14: reviews_publisher table created after executing the migration
    command'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14：执行迁移命令后创建的 reviews_publisher 表
- en: 'So far, we have explored how to create a model and migrate it into the database.
    Let''s now work on creating the rest of the models for our book review application.
    As we''ve already seen, the application will have the following database tables:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了如何创建一个模型并将其迁移到数据库中。现在让我们着手创建我们书籍评论应用程序的其余模型。正如我们已经看到的，应用程序将具有以下数据库表：
- en: '`Book`: This is the database table that holds the information about the book
    itself. We have already created a `Book` model and have migrated this to the database.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Book`：这是包含关于书籍本身信息的数据库表。我们已创建了一个 `Book` 模型并将其迁移到数据库中。'
- en: '`Publisher`: This table holds information about the book publisher.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Publisher`：这个表包含有关书籍出版者的信息。'
- en: '`Contributor`: This table holds information about the contributor, that is,
    the author, co-author, or editor.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Contributor`：这个表包含有关贡献者（即作者、合著者或编辑）的信息。'
- en: '`Review`: This table holds information about the review comments posted by
    the reviewers.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Review`：这个表包含由评论者发布的评论信息。'
- en: 'Let''s add the `Book` and `Contributor` models, as shown in the following code
    snippet, into `reviews/models.py`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 `Book` 和 `Contributor` 模型，如以下代码片段所示，添加到 `reviews/models.py` 中：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The code is self-explanatory. The `Book` model has the fields title, publication_date,
    and isbn. The `Contributor` model has the fields `first_names` and `last_names`
    fields and the email ID of the contributor. There are some newly added models
    as well, apart from the ones we have seen in the Publisher model. They have `DateField`
    as a new field type, which, as the name suggests, is used to store a date. A new
    field option called `verbose_name` is also used. It provides a descriptive name
    for the field.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是自我解释的。`Book`模型有标题、出版日期和isbn字段。`Contributor`模型有`first_names`和`last_names`字段以及贡献者的电子邮件ID。还有一些新添加的模型，除了我们在`Publisher`模型中看到的外。它们有一个新的字段类型`DateField`，正如其名所示，用于存储日期。还有一个名为`verbose_name`的新字段选项也被使用。它为字段提供了一个描述性名称。
- en: Relationships
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系
- en: One of the powers of relational databases is the ability to establish relationships
    between data stored across database tables. Relationships help maintain data integrity
    by establishing the correct references across tables, which in turn helps maintain
    the database. Relationship rules, on the other hand, ensure data consistency and
    prevent duplicates.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库的一项强大功能是能够在数据库表间建立数据关系。通过在表间建立正确的引用，关系有助于维护数据完整性，进而帮助维护数据库。另一方面，关系规则确保数据一致性并防止重复。
- en: 'In a relational database, there can be the following types of relations:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系型数据库中，可能存在以下类型的关联：
- en: Many to one
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多对一
- en: Many to many
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多对多
- en: One to one
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对一
- en: Let's explore each relationship in detail.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细探讨每种关系。
- en: Many to One
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多对一
- en: In this relationship, many records (rows/entries) from one table can refer to
    one record (row/entry) in another table. For example, there can be many books
    produced by one publisher. This is a case of a many-to-one relationship. To establish
    this relationship, we need to use the database's foreign keys. A foreign key in
    a relational database establishes the relationship between a field from one table
    and a primary key from a different table.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种关系中，一个表中的多个记录（行/条目）可以引用另一个表中的一个记录（行/条目）。例如，可以有一个出版社出版多本书。这是一个多对一关系的例子。为了建立这种关系，我们需要使用数据库的外键。关系型数据库中的外键在一个表中的字段与另一个表的主键之间建立关系。
- en: For example, say you have data about employees belonging to different departments
    stored in a table called `employee_info` with their employee ID as the primary
    key alongside a column that stores their department name; this table also contains
    a column that stores that department's department ID. Now, there's another table
    called `departments_info`, which has department ID as the primary key. In this
    case, then, the department ID is a foreign key in the `employee_info` table.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个存储在名为`employee_info`的表中的员工数据，该表以员工ID作为主键，并包含一个存储部门名称的列；此表还包含一个存储该部门ID的列。现在，还有一个名为`departments_info`的表，其中部门ID作为主键。在这种情况下，部门ID是`employee_info`表的外键。
- en: 'In our `bookr` app, the `Book` model can have a foreign key referring to the
    primary key of the `Publisher` table. Since we have already created the models
    for `Book`, `Contributor`, and `Publisher`, now let''s establish a many-to-one
    relationship across the `Book` and `Publisher` models. For the `Book` model, add
    the last line:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`bookr`应用中，`Book`模型可以有一个外键引用`Publisher`表的主键。由于我们已创建了`Book`、`Contributor`和`Publisher`的模型，现在让我们在`Book`和`Publisher`模型之间建立多对一关系。对于`Book`模型，添加最后一行：
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now the newly added `publisher` field is establishing a many-to-one relationship
    between `Book` and `Publisher` using a foreign key. This relationship ensures
    the nature of a many-to-one relationship, which is that many books can have one publisher:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在新增的`publisher`字段正在使用外键在`Book`和`Publisher`之间建立多对一关系。这种关系确保了多对一关系的性质，即多本书可以有一个出版商：
- en: '`models.ForeignKey`: This is the field option to establish a many-to-one relationship.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models.ForeignKey`：这是用于建立多对一关系的字段选项。'
- en: '`Publisher`: When we establish relationships with different tables in Django,
    we refer to the model that creates the table; in this case, the `Publisher` table
    is created by the `Publisher` model (or the Python class Publisher).'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Publisher`：当我们与Django中的不同表建立关系时，我们指的是创建表的模型；在这种情况下，`Publisher`表是由`Publisher`模型（或Python类Publisher）创建的。'
- en: '`on_delete`: This is a field option that determines the action to be taken
    upon the deletion of the referenced object. In this case, the `on_delete` option
    is set to `CASCADE(models.CASCADE)`, which deletes the referenced objects.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on_delete`: 这是一个字段选项，用于确定在删除引用对象时要采取的操作。在这种情况下，`on_delete` 选项设置为 `CASCADE(models.CASCADE)`，这将删除引用对象。'
- en: 'For example, assume a publisher has published a set of books. For some reason,
    if the publisher has to be deleted from the application, the next action is CASCADE,
    which means delete all the referenced books from the application. There are many
    more `on_delete` actions, such as the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一个出版社出版了一系列书籍。由于某种原因，如果需要从应用程序中删除该出版社，则下一步操作是 CASCADE，这意味着从应用程序中删除所有引用的书籍。还有许多其他的
    `on_delete` 操作，例如以下内容：
- en: '`PROTECT`: This prevents the deletion of the record unless all the referenced
    objects are deleted.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROTECT`: 这防止删除记录，除非所有引用对象都被删除。'
- en: '`SET_NULL`: This sets a null value if the database field has been previously
    configured to store null values.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SET_NULL`: 如果数据库字段之前已配置为存储空值，则此操作将设置一个空值。'
- en: '`SET_DEFAULT`: Sets to a default value on the deletion of the referenced object.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SET_DEFAULT`: 在删除引用对象时设置为默认值。'
- en: For our book review application, we will be using only the CASCADE option.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的书评应用程序，我们将仅使用 CASCADE 选项。
- en: Many to Many
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多对多
- en: 'In this relationship, multiple records in a table can have a relationship with
    multiple records in a different table. For example, a book can have multiple co-authors
    and each author (contributor) could have written multiple books. So, this forms
    a many-to-many relationship between the `Book` and `Contributor` tables:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种关系中，一个表中的多个记录可以与另一个表中的多个记录建立关系。例如，一本书可以有多个合著者，而每位作者（贡献者）可能都写过多本书。因此，这形成了
    `Book` 和 `Contributor` 表之间的多对多关系：
- en: '![Figure 2.15: Many-to-many relationship between books and co-authors'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.15：书籍与合著者之间的多对多关系](img/B15509_02_15.jpg)'
- en: '](img/B15509_02_15.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.15](img/B15509_02_15.jpg)'
- en: 'Figure 2.15: Many-to-many relationship between books and co-authors'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15：书籍与合著者之间的多对多关系
- en: 'In `models.py`, for the Book model, add the last line as shown here:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `models.py` 中，对于 Book 模型，添加如下所示的最后一条线：
- en: '[PRE22]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The newly added contributors field establishes a many-to-many relationship
    with Book and Contributor using the ManyToManyField field type:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 新增的贡献者字段通过使用 ManyToManyField 字段类型与书籍和贡献者建立了多对多关系：
- en: '`models.ManyToManyField`: This is the field type to establish a many-to-many relationship.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models.ManyToManyField`: 这是用于建立多对多关系的字段类型。'
- en: '`through`: This is a special field option for many-to-many relationships. When
    we have a many-to-many relationship across two tables, if we want to store some
    extra information about the relationship, then we can use this to establish the
    relationship via an intermediary table.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`through`: 这是多对多关系的一个特殊字段选项。当我们有两个表之间的多对多关系时，如果我们想存储关于关系的额外信息，则可以使用此选项通过中介表建立关系。'
- en: 'For example, we have two tables, namely `Book` and `Contributor`, where we
    need to store the information on the type of contributor for the book, such as
    Author, Co-author, or Editor. Then the type of contributor is stored in an intermediary
    table called `BookContributor`. Here is how the `BookContributor` table/model
    looks. Make sure you include this model in `reviews/models.py`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有两个表，即 `Book` 和 `Contributor`，我们需要存储关于书籍贡献者类型的信息，如作者、合著者或编辑。然后贡献者类型存储在一个称为
    `BookContributor` 的中介表中。以下是 `BookContributor` 表/模型的外观。确保您将此模型包含在 `reviews/models.py`
    中：
- en: '[PRE23]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: 'The complete `models.py` file can be viewed at this link: [http://packt.live/3hmFQxn](http://packt.live/3hmFQxn).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 `models.py` 文件可以在此链接查看：[http://packt.live/3hmFQxn](http://packt.live/3hmFQxn)。
- en: 'An intermediary table such as `BookContributor` establishes relationships by
    using foreign keys to both the `Book` and `Contributor` tables. It can also have
    extra fields that can store information about the relationship the `BookContributor`
    model has with the following fields:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一个中介表，如 `BookContributor`，通过使用到 `Book` 和 `Contributor` 表的外键来建立关系。它还可以有额外的字段，可以存储关于
    `BookContributor` 模型与以下字段之间的关系的信息：
- en: '`book`: This is a foreign key to the `Book` model. As we saw previously, `on_delete=models.CASCADE`
    will delete an entry from the relationship table when the relevant book is deleted
    from the application.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`book`: 这是到 `Book` 模型的外键。正如我们之前所看到的，`on_delete=models.CASCADE` 将在应用程序中删除相关书籍时从关系表中删除一个条目。'
- en: '`Contributor`: This is again a foreign key to the `Contributor` model/table.
    This is also defined as `CASCADE` upon deletion.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Contributor`: 这又是 `Contributor` 模型/表的另一个外键。在删除时也定义为 `CASCADE`。'
- en: '`role`: This is the field of the intermediary model, which stores the extra
    information about the relationship between `Book` and `Contributor`.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`role`: 这是中间模型字段，它存储关于 `Book` 和 `Contributor` 之间关系的额外信息。'
- en: '`class ContributionRole(models.TextChoices)`: This can be used to define a
    set of choices by creating a subclass of `models.TextChoices`. For example, `ContributionRole`
    is a subclass created out of `TextChoices`, which is used by the roles field to
    define Author, Co-Author, and Editor as a set of choices.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class ContributionRole(models.TextChoices)`: 这可以通过创建 `models.TextChoices`
    的子类来定义一组选择。例如，`ContributionRole` 是从 `TextChoices` 创建的子类，它用于 roles 字段，将作者、合著者和编辑定义为一组选择。'
- en: '`choices`: This refers to a set of choices defined in the models, and they
    are useful when creating Django `Forms` using the models.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`choices`: 这指的是在模型中定义的一组选择，当使用模型创建 Django `Forms` 时非常有用。'
- en: Note
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: When the through field option is not provided while establishing a many-to-many
    relationship, Django automatically creates an intermediary table to manage the
    relationship.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当在建立多对多关系时没有提供 through 字段选项，Django 会自动创建一个中间表来管理关系。
- en: One-to-One Relationships
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对一关系
- en: 'In this relationship, one record in a table will have a reference to only one
    record in a different table. For example, a person can have only one driver''s
    license, so a person to their driver''s license could form a one-to-one relationship:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种关系中，一个表中的一个记录将只引用另一个表中的一个记录。例如，一个人只能有一个驾照，因此一个人和他们的驾照可以形成一对一关系：
- en: '![Figure 2.16: Example of a one-to-one relationship'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.16：一对一关系的示例'
- en: '](img/B15509_02_16.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15509_02_16.jpg](img/B15509_02_16.jpg)'
- en: 'Figure 2.16: Example of a one-to-one relationship'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16：一对一关系的示例
- en: 'The OneToOneField can be used to establish a one-to-one relationship, as shown here:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: OneToOneField 可以用来建立一对一关系，如下所示：
- en: '[PRE24]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now that we have explored database relationships, let's come back to our bookr
    application and add one more model there.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经探讨了数据库关系，让我们回到我们的 bookr 应用程序，并添加一个额外的模型。
- en: Adding the Review Model
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加评论模型
- en: 'We''ve already added the `Book` and `Publisher` models to the `reviews/models.py`
    file. The last model that we are going to add is the `Review` model. The following
    code snippet should help us do this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将 `Book` 和 `Publisher` 模型添加到了 `reviews/models.py` 文件中。我们将要添加的最后一个模型是 `Review`
    模型。以下代码片段应该能帮助我们完成这项工作：
- en: '[PRE25]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The complete `models.py` file can be viewed at this link: [http://packt.live/3hmFQxn](http://packt.live/3hmFQxn).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 `models.py` 文件可以在以下链接查看：[http://packt.live/3hmFQxn](http://packt.live/3hmFQxn)。
- en: 'The `review` model/table will be used to store user-provided review comments
    and ratings for books. It has the following fields:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`review` 模型/表将用于存储用户提供的书籍评论和评分。它有以下字段：'
- en: '`content`: This field stores the text for a book review, hence the field type
    used is `TextField` as this can store a large amount of text.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content`: 此字段存储书籍评论的文本，因此使用的字段类型是 `TextField`，因为它可以存储大量文本。'
- en: '`rating`: This field stores the review rating of a book. Since the rating is
    going to be an integer, the field type used is `IntegerField`.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rating`: 此字段存储书籍的评论评分。由于评分将是一个整数，因此使用的字段类型是 `IntegerField`。'
- en: '`date_created`: This field stores the time and date when the review was written,
    hence the field type is `DateTimeField`.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date_created`: 此字段存储评论被撰写的时间和日期，因此字段类型是 `DateTimeField`。'
- en: '`date_edited`: This field stores the date and time whenever a review is edited.
    The field type is again `DateTimeField`.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date_edited`: 此字段存储每次编辑评论时的日期和时间。字段类型再次是 `DateTimeField`。'
- en: '`Creator`: This field specifies the review creator or the person who writes
    the book review. Notice that this is a foreign key to `auth.get_user_model()`,
    which is referring to the `User` model from Django''s built-in authentication
    module. It has a field option `on_delete=models.CASCADE`. This explains that when
    a user is deleted from the database, all the reviews written by that user will
    be deleted.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Creator`: 此字段指定评论创建者或撰写书评的人。请注意，这是一个指向 `auth.get_user_model()` 的外键，它引用了 Django
    内置认证模块中的 `User` 模型。它有一个字段选项 `on_delete=models.CASCADE`。这解释了当从数据库中删除用户时，该用户所写的所有评论也将被删除。'
- en: '`Book`: Reviews have a field called `book`, which is a foreign key to the `Book`
    model. This is because for a book review application, reviews have to be written,
    and a book can have many reviews, so this is a many-to-one relationship. This
    is also defined with a field option, `on_delete=models.CASCADE`, because once
    the book is deleted, there is no point in retaining the reviews in the application.
    So, when a book is deleted, all the reviews referring to the book will also get deleted.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Book`：评论有一个名为`book`的字段，它是`Book`模型的外键。这是因为对于评论应用，评论必须被撰写，一本书可以有多个评论，所以这是一个多对一的关系。这也通过字段选项`on_delete=models.CASCADE`定义，因为一旦删除书籍，保留应用中的评论就没有意义了。所以，当删除书籍时，所有引用该书籍的评论也将被删除。'
- en: Model Methods
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型方法
- en: 'In Django, we can write methods inside a model class. These are called `__str__()`.
    This method returns the string representation of the `Model` instances and can
    be especially useful while using the Django shell. In the following example, where
    the `__str__()` method is added to the `Publisher` model, the string representation
    of the `Publisher` object will be the publisher''s name:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django中，我们可以在模型类内部编写方法。这些被称为`__str__()`。此方法返回`Model`实例的字符串表示形式，在使用Django shell时特别有用。在以下示例中，当`__str__()`方法添加到`Publisher`模型时，`Publisher`对象的字符串表示形式将是出版商的名称：
- en: '[PRE26]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the `_str_()` methods to `Contributor` and `Book` as well, as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 还要将`_str_()`方法添加到`Contributor`和`Book`中，如下所示：
- en: '[PRE27]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Migrating the Reviews App
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移评论应用
- en: 'Since we have the entire model file ready, let''s now migrate the models into
    the database, similar to what we did before with the installed apps. Since the
    reviews app has a set of models created by us, before running the migration, it
    is important to create the migration scripts. Migration scripts help in identifying
    any changes to the models and will propagate these changes into the database while
    running the migration. Execute the following command to create the migration scripts:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经准备好了整个模型文件，现在让我们将模型迁移到数据库中，就像我们之前对已安装的应用程序所做的那样。由于评论应用有一组我们创建的模型，在运行迁移之前，创建迁移脚本非常重要。迁移脚本有助于识别模型中的任何更改，并在运行迁移时将这些更改传播到数据库中。执行以下命令以创建迁移脚本：
- en: '[PRE28]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You should get an output similar to this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到类似以下输出：
- en: '[PRE29]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Migration scripts will be created in a folder named `migrations` in the application
    folder. Next, migrate all the models into the database using the `migrate` command:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移脚本将在应用程序文件夹中名为`migrations`的文件夹中创建。接下来，使用`migrate`命令将所有模型迁移到数据库中：
- en: '[PRE30]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You should see the following output:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE31]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After executing this command, we have successfully created the database tables
    defined in the `reviews` app. You may use DB Browser for SQLite to explore the
    tables you have just created after the migration. To do so, open DB Browser for
    SQLite, click the `Open` `Database` button (*Figure 2.17*), and navigate to your
    project directory:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，我们已经成功创建了`reviews`应用中定义的数据库表格。你可以在迁移后使用DB Browser for SQLite来探索你刚刚创建的表格。为此，打开DB
    Browser for SQLite，点击`Open` `Database`按钮（*图2.17*），并导航到你的项目目录：
- en: '![Figure 2.17: Click the Open Database button'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.17：点击打开数据库按钮'
- en: '](img/B15509_02_17.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15509_02_17.jpg](img/B15509_02_17.jpg)'
- en: 'Figure 2.17: Click the Open Database button'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17：点击打开数据库按钮
- en: Select the database file named `db.sqlite3` to open it (*Figure 2.18*).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 选择名为`db.sqlite3`的数据库文件以打开它（*图2.18*）。
- en: '![Figure 2.18: Locating db.sqlite3 in the bookr directory'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.18：在bookr目录中定位db.sqlite3'
- en: '](img/B15509_02_18.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15509_02_18.jpg](img/B15509_02_18.jpg)'
- en: 'Figure 2.18: Locating db.sqlite3 in the bookr directory'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18：在bookr目录中定位db.sqlite3
- en: 'You should now be able to browse the new sets of tables created. The following
    figure shows the database tables defined in the `reviews` app:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够浏览创建的新表格集。以下图显示了`reviews`应用中定义的数据库表格：
- en: '![Figure 2.19: Database tables as defined in the reviews app'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.19：评论应用中定义的数据库表格'
- en: '](img/B15509_02_19.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15509_02_19.jpg](img/B15509_02_19.jpg)'
- en: 'Figure 2.19: Database tables as defined in the reviews app'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19：评论应用中定义的数据库表格
- en: Django's Database CRUD Operations
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Django的数据库CRUD操作
- en: As we have created the necessary database tables for the book review application,
    let's work on understanding the basic database operations with Django.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经为评论应用创建了必要的数据库表格，让我们现在通过Django了解基本数据库操作。
- en: We've already briefly touched on database operations using SQL statements in
    the section titled *SQL CRUD Operations*. We tried creating an entry into the
    database using the `Insert` statement, read from the database using the `select`
    statement, updated an entry using the `update` statement, and deleted an entry
    from the database using the `delete` statement.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在名为“SQL CRUD操作”的部分中简要介绍了使用SQL语句进行数据库操作。我们尝试使用`Insert`语句将条目插入数据库，使用`select`语句从数据库中读取，使用`update`语句更新条目，以及使用`delete`语句从数据库中删除条目。
- en: Django's ORM provides the same functionality without having to deal with the
    SQL statements. Django's database operations are simple Python code, hence we
    overcome the hassle of maintaining SQL statements among the Python code. Let's
    take a look at how these are performed.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Django的ORM提供了相同的功能，无需处理SQL语句。Django的数据库操作是简单的Python代码，因此我们克服了在Python代码中维护SQL语句的麻烦。让我们看看这些是如何执行的。
- en: 'To execute the CRUD operations, we will enter Django''s command-line shell
    by executing the following command:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行CRUD操作，我们将通过执行以下命令进入Django的命令行shell：
- en: '[PRE32]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For this chapter, we will designate Django shell commands using the `>>>` notation
    (highlighted) at the start of the code block. While pasting the query into DB
    Browser, make sure you exclude this notation every time.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将使用代码块开头的`>>>`符号（突出显示）来指定Django shell命令。当将查询粘贴到数据库浏览器时，请确保每次都排除这个符号。
- en: 'When the interactive console starts, it looks as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当交互式控制台启动时，看起来如下所示：
- en: '[PRE33]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Exercise 2.02: Creating an Entry in the Bookr Database'
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.02：在Bookr数据库中创建条目
- en: 'In this exercise, you will create a new entry in the database by saving a model
    instance. In other words, you will create an entry in a database table without
    explicitly running a SQL query:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将通过保存模型实例来在数据库中创建一个新条目。换句话说，您将在数据库表中创建一个条目，而不需要显式运行SQL查询：
- en: 'First, import the `Publisher` class/model from `reviews.models`:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从`reviews.models`导入`Publisher`类/模型：
- en: '[PRE34]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create an object or an instance of the `Publisher` class by passing all the
    field values (name, website, and email) required by the `Publisher` model:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过传递`Publisher`模型所需的所有字段值（名称、网站和电子邮件）来创建`Publisher`类的对象或实例：
- en: '[PRE35]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, to write the object into the database, it is important to call the `save()`
    method, because until this is called there will not be an entry created in the database:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，要将对象写入数据库，重要的是调用`save()`方法，因为直到这个方法被调用，数据库中才不会创建条目：
- en: '[PRE36]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now you can see a new entry created in the database using DB Browser:'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，您可以在数据库浏览器中看到一个新条目被创建：
- en: '![Figure 2.20: Entry created in the database'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.20：数据库中创建的条目'
- en: '](img/B15509_02_20.jpg)'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_02_20.jpg)'
- en: 'Figure 2.20: Entry created in the database'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图2.20：数据库中创建的条目
- en: 'Use the object attributes to make any further changes to the object and save
    the changes to the database:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用对象属性对对象进行任何进一步的修改，并将更改保存到数据库中：
- en: '[PRE37]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can see the changes using DB Browser as follows:'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以使用以下方式使用数据库浏览器查看更改：
- en: '![Figure 2.21: Entry with the updated email field'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.21：更新了电子邮件字段的条目'
- en: '](img/B15509_02_21.jpg)'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_02_21.jpg)'
- en: 'Figure 2.21: Entry with the updated email field'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21：更新了电子邮件字段的条目
- en: In this exercise, you created an entry in the database by creating an instance
    of the model object and used the `save()` method to write the model object into
    the database.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您通过创建模型对象的实例并在数据库中写入模型对象来创建数据库条目使用了`save()`方法。
- en: Note that by following the preceding method, the changes to the class instance
    are not saved until the `save()` method is called. However, if we use the `create()`
    method, Django saves the changes to the database in a single step. We'll use this
    method in the exercise that follows.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过遵循前面的方法，直到调用`save()`方法，对类实例的更改都不会被保存。然而，如果我们使用`create()`方法，Django将在一步中将更改保存到数据库中。我们将在接下来的练习中使用此方法。
- en: 'Exercise 2.03: Using the create() Method to Create an Entry'
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.03：使用create()方法创建条目
- en: 'Here, you will create a record in the `contributor` table using the `create()`
    method in a single step:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将使用`create()`方法一步创建`contributor`表中的记录：
- en: 'First, import the Contributor class as before:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，像之前一样导入`Contributor`类：
- en: '[PRE38]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Invoke the `create()` method to create an object in the database in a single
    step. Ensure that you pass all the required parameters (f`irst_names, last_names`,
    and `email`):'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`create()`方法，您可以一步在数据库中创建一个对象。确保您传递所有必需的参数（`first_names`、`last_names`和`email`）：
- en: '[PRE39]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Use DB Browser to verify that the contributor record has been created in the
    database. If your DB Browser is not already open, open the database file `db.sqlite3`
    as we just did in the previous section. Click `Browse Data` and select the desired
    table – in this case, the `reviews_contributor` table from the `Table` dropdown,
    as shown in the screenshot – and verify the newly created database record:![Figure
    2.22: Verifying the creation of the record in DB Browser'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用DB Browser验证贡献者记录是否已创建在数据库中。如果你的DB Browser还没有打开，请像上一节中那样打开数据库文件`db.sqlite3`。点击`浏览数据`并选择所需的表——在本例中，从`表`下拉菜单中选择`reviews_contributor`表，如图所示——并验证新创建的数据库记录：![图2.22：在DB
    Browser中验证记录的创建
- en: '](img/B15509_02_22.jpg)'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_02_22.jpg)'
- en: 'Figure 2.22: Verifying the creation of the record in DB Browser'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22：在DB Browser中验证记录的创建
- en: In this exercise, we learned that using the `create()` method, we can create
    a record for a model in a database in a single step.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了使用`create()`方法，我们可以一次性在数据库中为模型创建记录。
- en: Creating an Object with a Foreign Key
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建具有外键的对象
- en: Similar to how we created a record in the `Publisher` and `Contributor` tables,
    let's now create one for the `Book` table. If you recall, the `Book` model has
    a foreign key to `Publisher` that cannot have a null value. So, a way to populate
    the publisher's foreign key is by providing the created `publisher` object in
    the book's `publisher` field as shown in the following exercise.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们创建`Publisher`和`Contributor`表中的记录类似，现在让我们为`Book`表创建一个记录。如果你还记得，`Book`模型有一个不能为空的外键`Publisher`。因此，填充出版商外键的一种方法是在书籍的`publisher`字段中提供创建的`publisher`对象，如下面的练习所示。
- en: 'Exercise 2.04: Creating Records for a Many-to-One Relationship'
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.04：创建多对一关系的记录
- en: 'In this exercise, you will create a record in the `Book` table including a
    foreign key to the `Publisher` model. As you already know, the relationship between
    `Book` and `Publisher` is a many-to-one relationship, so you have to first fetch
    the `Publisher` object and then use it while creating the book record:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将在`Book`表中创建一个包含指向`Publisher`模型外键的记录。正如你所知，`Book`和`Publisher`之间的关系是多对一关系，因此你必须首先获取`Publisher`对象，然后在创建书籍记录时使用它：
- en: 'First, import the `Publisher` class:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入`Publisher`类：
- en: '[PRE40]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Retrieve the `publisher` object from the database using the following command.
    The `get()` method is used to retrieve an object from the database. We still haven''t
    explored database read operations. For now, use the following command; we will
    go deeper into database read/retrieve in the next section:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令从数据库中检索`publisher`对象。`get()`方法用于从数据库中检索对象。我们还没有探索数据库的读取操作。现在，使用以下命令；我们将在下一节中深入探讨数据库的读取/检索：
- en: '[PRE41]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When creating a book, we need to supply a `date` object as publication_date
    is a date field in the `Book` model. So, import `date` from datetime so that a
    date object can be supplied when creating the `book` object as shown in the following code:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建书籍时，我们需要提供一个`date`对象，因为`Book`模型中的`publication_date`是一个日期字段。因此，从`datetime`导入`date`，以便在创建`book`对象时提供日期对象，如下代码所示：
- en: '[PRE42]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Use the `create()` method to create a record of the book in the database. Ensure
    that you pass all the fields, namely `title`, `publication_ date`, `isbn`, and
    the `publisher` object:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`create()`方法在数据库中创建书籍的记录。确保你传递所有字段，即`title`、`publication_date`、`isbn`和`publisher`对象：
- en: '[PRE43]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that since `publisher` is a foreign key and it is not nullable (cannot
    hold a `null` value), it is mandatory to pass a `publisher` object. When the mandatory
    foreign key object publisher is not provided, the database will throw an integrity error.
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，由于`publisher`是一个外键，并且它不可为空（不能持有`null`值），因此必须传递一个`publisher`对象。当必需的外键对象`publisher`未提供时，数据库将抛出完整性错误。
- en: '*Figure 2.23* shows the `Book` table where the first entry is created. Notice
    that the foreign key field (`publisher_id` ) points to the `Publisher` table.
    The entry `publisher_id` in the book''s record is pointing to a `Publisher` record
    that has `id` (primary key) `1` as shown in the following two screenshots:'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图2.23*显示了创建第一条记录的`Book`表。注意，外键字段（`publisher_id`）指向`Publisher`表。书籍记录中的`publisher_id`条目指向一个具有`id`（主键）`1`的`Publisher`记录，如下两个屏幕截图所示：'
- en: '![Figure 2.23: Foreign key pointing to the primary key for reviews_book'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.23：指向reviews_book主键的外键'
- en: '](img/B15509_02_23.jpg)'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15509_02_23.jpg)'
- en: 'Figure 2.23: Foreign key pointing to the primary key for reviews_book'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23：指向reviews_book主键的外键
- en: '![Figure 2.24: Foreign key pointing to the primary key for reviews_publisher'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.24：指向reviews_publisher主键的外键]'
- en: '](img/B15509_02_24.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15509_02_24.jpg]'
- en: 'Figure 2.24: Foreign key pointing to the primary key for reviews_publisher'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.24：指向reviews_publisher主键的外键
- en: In this exercise, we learned that while creating a database record, an object
    can be assigned to a field if it is a foreign key. We know that the `Book` model
    also has a many-to-many relationship with the Contributor model. Let's now explore
    the ways to establish many-to-many relations as we create records in the database.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们了解到在创建数据库记录时，如果是一个外键，可以将对象分配给字段。我们知道`Book`模型也与`Contributor`模型有多个对多个的关系。现在，让我们在创建数据库记录时探索建立多个对多个关系的方法。
- en: 'Exercise 2.05: Creating Records with Many-to-Many Relationships'
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.05：使用多对多关系创建记录
- en: 'In this exercise, you will create a many-to-many relationship between `Book`
    and `Contributor` using the relationship model `BookContributor`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用关系模型`BookContributor`在`Book`和`Contributor`之间创建多对多关系：
- en: 'In case you have restarted the shell and lost the `publisher` and the `book`
    objects, retrieve them from the database by using the following set of Python statements:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在重启了shell后丢失了`publisher`和`book`对象，可以通过以下一组Python语句从数据库中检索它们：
- en: '[PRE44]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The way to establish a many-to-many relationship is by storing the information
    about the relationship in the intermediary model or the relationship model; in
    this case, it is `BookContributor`. Since we have already fetched the book and
    the contributor records from the database, let''s use these objects while creating
    a record for the `BookContributor` relationship model. To do so, first, create
    an instance of the `BookContributor` relationship class and then save the object
    to the database. While doing so, ensure you pass the required fields, namely the
    `book` object, `contributor` object, and `role`:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立多对多关系的方法是将关系信息存储在中间模型或关系模型中；在这种情况下，它是`BookContributor`。由于我们已经从数据库中检索了书籍和贡献者记录，让我们在创建`BookContributor`关系模型记录时使用这些对象。为此，首先创建`BookContributor`关系类的实例，然后将对象保存到数据库中。在这个过程中，确保你传递了所需的字段，即`book`对象、`contributor`对象和`role`：
- en: '[PRE45]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Notice that we specified the role as `AUTHOR` while creating the `book_contributor`
    object. This is a classic example of storing relationship data while establishing
    a many-to-many relationship. The role can be `AUTHOR`, `CO_AUTHOR`, or `EDITOR`.
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们在创建`book_contributor`对象时指定了角色为`AUTHOR`。这是一个在建立多对多关系时存储关系数据的经典示例。角色可以是`AUTHOR`、`CO_AUTHOR`或`EDITOR`。
- en: This established the relationship between the book *Advanced Deep Learning with
    Keras* and the contributor Rowel (Rowel being the author of the book).
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这建立了书籍《高级深度学习与Keras》和贡献者Rowel（Rowel是这本书的作者）之间的关系。
- en: In this exercise, we established a many-to-many relationship between `Book`
    and `Contributor` using the `BookContributor` relationship model. With regards
    to the verification of the many-to-many relationship that we just created, we
    will see this in detail in a few exercises later on in this chapter.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用`BookContributor`关系模型在`Book`和`Contributor`之间建立了多对多关系。关于我们刚刚创建的多对多关系的验证，我们将在本章稍后的几个练习中详细看到。
- en: 'Exercise 2.06: A Many-to-Many Relationship Using the add() Method'
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.06：使用add()方法建立多对多关系
- en: 'In this exercise, you will establish a many-to-many relationship using the
    `add()` method. When we don''t use the relationship to create the objects, we
    can use `through_default` to pass in a dictionary with the parameters defining
    the required fields. Continuing from the previous exercise, let''s add one more
    contributor to the book titled *Advanced Deep Learning with Keras*. This time,
    the contributor is an editor of the book:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用`add()`方法建立多对多关系。当我们不使用关系来创建对象时，我们可以使用`through_default`传入一个包含定义所需字段的参数的字典。从上一个练习继续，让我们向名为《高级深度学习与Keras》的书籍添加一个额外的贡献者。这次，这个贡献者是这本书的编辑：
- en: 'If you have restarted the shell, run the following two commands to import and
    fetch the desired book instance:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你重启了shell，运行以下两个命令来导入和检索所需的书籍实例：
- en: '[PRE46]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Use the `create()` method to create a contributor as shown here:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`create()`方法创建一个贡献者，如下所示：
- en: '[PRE47]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Add the newly created contributor to the book using the `add()` method. Ensure
    you provide the relationship parameter `role` as `dict`. Enter the following code:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `add()` 方法将新创建的贡献者添加到书籍中。确保您提供的关系参数 `role` 作为 `dict`。输入以下代码：
- en: '[PRE48]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Thus, we used the `add()` method to establish a many-to-many relationship between
    the book and contributor while storing the relationship data role as `Editor`.
    Let's now take a look at other ways of doing this.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用了 `add()` 方法在书籍和贡献者之间建立多对多关系，同时将关系数据角色存储为 `Editor`。现在让我们看看其他实现这一点的其他方法。
- en: Using create() and set() Methods for Many-to-Many Relationships
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 create() 和 set() 方法处理多对多关系
- en: 'Assume the book *Advanced Deep Learning with Keras* has a total of two editors.
    Let''s use the following method to add another editor to the book. If the contributor
    is not already present in the database, then we can use the `create()` method
    to simultaneously create an entry as well as to establish the relation with the
    book:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 假设书籍 *Advanced Deep Learning with Keras* 有两位编辑。让我们使用以下方法为这本书添加另一位编辑。如果贡献者尚未存在于数据库中，则我们可以使用
    `create()` 方法同时创建条目以及与书籍建立关系：
- en: '[PRE49]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Similarly, we can also use the `set()` method to add a list of contributors
    for a book. Let''s create a publisher, a set of two contributors who are the co-authors,
    and a `book` object. First, import the `Publisher` model, if not already imported,
    using the following code:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以使用 `set()` 方法为书籍添加一系列贡献者。让我们创建一个 `Publisher` 模型，一组两位合著者贡献者，以及一个 `book`
    对象。首先，如果尚未导入，使用以下代码导入 `Publisher` 模型：
- en: '[PRE50]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following code will help us do so:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将帮助我们做到这一点：
- en: '[PRE51]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Since this is a many-to-many relationship, we can add a list of objects in
    just one go, using the `set()` method. We can use through_defaults to specify
    the role of the contributors; in this case, they are co-authors:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个多对多关系，我们可以通过一次添加一个对象列表，使用 `set()` 方法。我们可以使用 through_defaults 来指定贡献者的角色；在这种情况下，他们是合著者：
- en: '[PRE52]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Read Operations
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取操作
- en: Django provides us with methods that allow us to read/retrieve from the database.
    We can retrieve a single object from the database using the `get()` method. We
    have already created a few records in the previous sections, so let's use the
    `get()` method to retrieve an object.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: Django 为我们提供了允许我们从数据库中读取/检索的方法。我们可以使用 `get()` 方法从数据库中检索单个对象。在前面的章节中，我们已经创建了一些记录，所以让我们使用
    `get()` 方法来检索一个对象。
- en: 'Exercise 2.07: Using the get() Method to Retrieve an Object'
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.07：使用 get() 方法检索对象
- en: 'In this exercise, you will retrieve an object from the database using the `get()` method:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用 `get()` 方法从数据库中检索一个对象：
- en: 'Fetch a `Publisher` object that has a `name` field with the value `Pocket Books`:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取具有 `name` 字段值为 `Pocket Books` 的 `Publisher` 对象：
- en: '[PRE53]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Re-enter the retrieved `publisher` object and press *Enter*:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新输入检索到的 `publisher` 对象并按 *Enter* 键：
- en: '[PRE54]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Notice that the output is displayed in the shell. This is called a string representation
    of an object. It is the result of adding the model method `__str__()` as we did
    in the *Model Methods* section for the `Publisher` class.
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，输出显示在壳中。这被称为对象的字符串表示。这是在 *模型方法* 部分为 `Publisher` 类添加模型方法 `__str__()` 的结果。
- en: 'Upon retrieving the object, you have access to all the object''s attributes.
    Since this is a Python object, the attributes of the object can be accessed by
    using `.` followed by the attribute name. So, you can retrieve the publisher''s
    name with the following command:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检索对象后，你可以访问所有对象的属性。由于这是一个 Python 对象，可以通过使用 `.` 后跟属性名称来访问对象的属性。因此，你可以使用以下命令检索出版商的名称：
- en: '[PRE55]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Similarly, retrieve the publisher''s website:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，检索出版商的网站：
- en: '[PRE56]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The publisher''s email address can be retrieved as well:'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以检索出版商的电子邮件地址：
- en: '[PRE57]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In this exercise, we learned how to fetch a single object using the `get()`
    method. There are several disadvantages to using this method, though. Let's find
    out why.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何使用 `get()` 方法检索单个对象。尽管如此，使用这种方法有几个缺点。让我们找出原因。
- en: Returning an Object Using the get() Method
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 get() 方法返回对象
- en: It is important to note that the `get()` method can only fetch one object. If
    there is another object carrying the same value as the field mentioned, then we
    can expect a *"returned more than one"* error message. For example, if there are
    two entries in the `Publisher` table with the same value for the name field, we
    can expect an error. In such cases, there are alternate ways to retrieve those
    objects, which we will be exploring in the subsequent sections.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`get()` 方法只能获取一个对象。如果有另一个对象具有与字段相同的值，那么我们可以预期会收到一个 *"返回了多个"* 错误消息。例如，如果
    `Publisher` 表中有两个条目具有相同的名称字段值，我们可能会收到一个错误。在这种情况下，有其他方法可以检索这些对象，我们将在后续章节中探讨。
- en: 'We can also get a *"matching query does not exist"* error message when there
    are no objects returned from the `get()` query. The `get()` method can be used
    with any of the object''s fields to retrieve a record. In the following case,
    we are using the `website` field:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `get()` 查询没有返回对象时，我们也可以得到一个 *"匹配的查询不存在"* 错误消息。`get()` 方法可以与对象的任何字段一起使用来检索记录。在以下情况下，我们正在使用
    `website` 字段：
- en: '[PRE58]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'After retrieving the object, we can still get the publisher''s name, as shown
    here:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在检索对象之后，我们仍然可以获取出版者的名字，如下所示：
- en: '[PRE59]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Another way to retrieve an object is by using its primary key – `pk`, as can
    be seen here:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种检索对象的方法是使用其主键 `pk`，如下所示：
- en: '[PRE60]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Using pk for the primary key is a more generic way of using the primary key
    field. But for the `Publisher` table, since we know that `id` is the primary key,
    we can simply use the field name `id` to create our `get()` query:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 使用主键 `pk` 是使用主键字段的一种更通用的方式。但对于 `Publisher` 表，由于我们知道 `id` 是主键，我们可以简单地使用字段名 `id`
    来创建我们的 `get()` 查询：
- en: '[PRE61]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For `Publisher` and all the other tables, the primary key is `id`, which was
    automatically created by Django. This happens when a primary key field is not
    mentioned at the time of the creation of the table. But there can be instances
    where a field can be explicitly declared as a primary key.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Publisher` 以及其他所有表，主键是 `id`，这是 Django 自动创建的。这发生在创建表时没有提到主键字段的情况下。但也可以有字段被明确声明为主键的情况。
- en: 'Exercise 2.08: Using the all() Method to Retrieve a Set of Objects'
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.08：使用 all() 方法检索一组对象
- en: 'We can use the `all()` method to retrieve a set of objects. In this exercise,
    you will use this method to retrieve the names of all contributors:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `all()` 方法检索一组对象。在这个练习中，你将使用这个方法检索所有贡献者的名字：
- en: 'Add the following code to retrieve all the objects from the `Contributor` table:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码以从 `Contributor` 表中检索所有对象：
- en: '[PRE62]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Upon execution, you will get a `QuerySet` of all the objects.
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行后，您将得到所有对象的 `QuerySet`。
- en: 'We can use list indexing to look up a specific object or to iterate over the
    list using a loop to do any other operation:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用列表索引来查找特定的对象，或者使用循环遍历列表以执行任何其他操作：
- en: '[PRE63]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Since `Contributor` is a list of objects, you can use indexing to access any
    element in the list as shown in the following command:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 `Contributor` 是一个对象列表，你可以使用索引来访问列表中的任何元素，如下面的命令所示：
- en: '[PRE64]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In this case, the first element in the list is a contributor with a `first_names`
    value of `''Rowel''` and a `last_names` value of `''Atienza''`, as you can see
    from the following code:'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，列表中的第一个元素是一个具有 `'Rowel'` 的 `first_names` 值和 `'Atienza'` 的 `last_names`
    值的贡献者，如下面的代码所示：
- en: '[PRE65]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this exercise, we learned how to retrieve all the objects using the `all()`
    method and we also learned how to use the retrieved set of objects as a list.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何使用 `all()` 方法检索所有对象，我们还学习了如何使用检索到的对象集作为列表。
- en: Retrieving Objects by Filtering
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过过滤检索对象
- en: If we have more than one object for a field value, then we cannot use the `get()`
    method since the `get()` method can return only one object. For such cases, we
    have the `filter()` method, which can retrieve all the objects that match a specified condition.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个字段值对应多个对象，那么我们不能使用 `get()` 方法，因为 `get()` 方法只能返回一个对象。对于这种情况，我们有 `filter()`
    方法，它可以检索所有符合指定条件的对象。
- en: 'Exercise 2.09: Using the filter() Method to Retrieve Objects'
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.09：使用 filter() 方法检索对象
- en: 'In this exercise, you will use the `filter()` method to get a specific set
    of objects for a certain condition. Specifically, you will retrieve all the contributors''
    names who have their first name as `Peter`:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用 `filter()` 方法获取满足特定条件的特定对象集。具体来说，你将检索所有名字为 `Peter` 的贡献者的名字：
- en: 'First, create two more contributors:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建两个额外的贡献者：
- en: '[PRE66]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To retrieve those contributors who have the value of `first_names` as `Peter`,
    add the following code:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检索那些`first_names`值为`Peter`的捐助者，请添加以下代码：
- en: '[PRE67]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `filter()` method returns the object even if there is only one. You can
    see this here:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使只有一个对象匹配，`filter()`方法也会返回该对象。你可以在这里看到：
- en: '[PRE68]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Furthermore, the `filter()` method returns an empty `QuerySet` if there is
    none matching the query. This can be seen here:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，如果查询没有匹配项，`filter()`方法返回一个空的`QuerySet`。这在这里可以看到：
- en: '[PRE69]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In this exercise, we saw the use of filters to retrieve a set of a few objects
    filtered by a certain condition.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何使用过滤器根据特定条件检索一组少量对象。
- en: Filtering by Field Lookups
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过字段查找进行过滤
- en: 'Now, let''s suppose we want to filter and query a set of objects using the
    object''s fields by providing certain conditions. In such a case, we can use what
    is called a double-underscore lookup. For example, the `Book` object has a field
    named `publication_date`; let''s say we want to filter and fetch all the books
    that were published after 01-01-2014\. We can easily look these up by using the
    double-underscore method. To do this, we will first import the `Book` model:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们想要通过提供某些条件来过滤和查询一组对象。在这种情况下，我们可以使用所谓的双下划线查找。例如，`Book`对象有一个名为`publication_date`的字段；假设我们想要过滤并获取所有在01-01-2014之后出版的书籍。我们可以通过使用双下划线方法轻松地查找这些书籍。为此，我们首先导入`Book`模型：
- en: '[PRE70]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here, `publication_date__gt` indicates the publication date, which is greater
    than (`gt`) a certain specified date – in this case, 01-01-2014\. Similar to this,
    we have the following abbreviations:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`publication_date__gt`表示出版日期，大于（`gt`）某个指定的日期——在本例中是01-01-2014。类似地，我们有以下缩写：
- en: '`lt`: Less than'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lt`：小于'
- en: '`lte`: Less than or equal to'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lte`：小于或等于'
- en: '`gte`: Greater than or equal to'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gte`：大于或等于'
- en: 'The result after filtering can be seen here:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤后的结果如下所示：
- en: '[PRE71]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Here is the publication date of the book that is part of the query set, which
    confirms that the publication date was after 01-01-2014:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这是查询集中的书籍的出版日期，这证实了出版日期是在01-01-2014之后的：
- en: '[PRE72]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Using Pattern Matching for Filtering Operations
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模式匹配进行过滤操作
- en: 'For filtered results, we can also look up whether the parameter contains a
    part of the string we are looking for:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 对于过滤结果，我们还可以查找参数是否包含我们正在寻找的字符串的一部分：
- en: '[PRE73]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Here, `title__contains` looks for all those objects with titles containing
    `''Deep learning''` as a part of the string:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`title__contains`查找所有标题包含字符串`'Deep learning'`的对象：
- en: '[PRE74]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Similarly, we can use `icontains` if the string match needs to be case-insensitive.
    Using `startswith` matches any string starting with the specified string.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果字符串匹配需要不区分大小写，我们可以使用`icontains`。使用`startswith`匹配以指定字符串开头的任何字符串。
- en: Retrieving Objects by Excluding
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过排除检索对象
- en: 'In the previous section, we learned about fetching a set of objects by matching
    a certain condition. Now, suppose we want to do the opposite; that is, we want
    to fetch all those objects that do not match a certain condition. In such cases,
    we can use the `exclude()` method to exclude a certain condition and fetch all
    the required objects. This will be clearer with an example. The following is a
    list of all contributors:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了通过匹配特定条件来获取一组对象。现在，假设我们想要做相反的操作；也就是说，我们想要获取所有那些不匹配特定条件的对象。在这种情况下，我们可以使用`exclude()`方法来排除特定条件并获取所有所需的对象。以下是一个所有捐助者的列表：
- en: '[PRE75]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, from this list, we will exclude all those contributors who have the value
    of `first_names` as `Peter`:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从这个列表中，我们将排除所有那些`first_names`值为`Peter`的捐助者：
- en: '[PRE76]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We see here that the query returned all those contributors whose first name
    is not Peter.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，查询返回了所有那些名字不是Peter的捐助者。
- en: Retrieving Objects Using the order_by() Method
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用order_by()方法检索对象
- en: 'We can retrieve a list of objects while ordering by a specified field, using
    the `order_by()` method. For example, in the following code snippet, we order
    the books by their publication date:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`order_by()`方法按指定字段排序来检索对象列表。例如，在以下代码片段中，我们按出版日期对书籍进行排序：
- en: '[PRE77]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Let''s examine the order of the query. Since the query set is a list, we can
    use indexing to check the publication date of each book:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查查询的顺序。由于查询集是一个列表，我们可以使用索引来检查每本书的出版日期：
- en: '[PRE78]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Notice that the publication date of the first book with index `0` is older
    than the publication date of the second book with index `1`. So, this confirms
    that the queried list of books has been properly ordered as per their publication
    dates. We can also use a prefix with the negative sign for the field parameter
    to order results in descending order. This can be seen from the following code
    snippet:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，索引为 `0` 的第一本书的出版日期早于索引为 `1` 的第二本书的出版日期。因此，这证实了查询到的书籍列表已经按照出版日期正确排序。我们还可以使用带有负号的字段参数前缀来按降序排序结果。这可以从以下代码片段中看出：
- en: '[PRE79]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Since we have prefixed a negative sign to the publication date, notice that
    the queried set of books has now been returned in the opposite order, where the
    first book object with index `0` has a more recent date than the second book:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在出版日期前加上了负号，请注意，现在查询到的书籍集合已经以相反的顺序返回，其中索引为 `0` 的第一本书对象比索引为 `1` 的第二本书对象更晚。
- en: '[PRE80]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We can also order by using a string field or a numerical. For example, the
    following code can be used to order books by their primary key or `id`:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用字符串字段或数值进行排序。例如，以下代码可以用来按书籍的主键或 `id` 排序：
- en: '[PRE81]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The queried set of books has been ordered as per book `id` in ascending order:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 查询到的书籍集合已经按照书籍 `id` 升序排序：
- en: '[PRE82]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Again, to order in descending order, the negative sign can be used as a prefix,
    as follows:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，为了按降序排序，我们可以使用负号作为前缀，如下所示：
- en: '[PRE83]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, the queried set of books has been ordered per book `id` in descending
    order:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，查询到的书籍集合已经按照书籍 `id` 降序排序：
- en: '[PRE84]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'To order by a string field in alphabetical order, we can do something like
    this:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 按照字符串字段按字母顺序排序，我们可以这样做：
- en: '[PRE85]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Since we have used the title of the book to order by, the query set has been
    ordered in alphabetical order. We can see this as follows:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了书籍的标题进行排序，查询集已经按字母顺序排序。我们可以如下看到：
- en: '[PRE86]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Similar to what we''ve seen for the previous ordering types, the negative sign
    prefix can help us sort in reverse alphabetical order, as we can see here:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前看到的排序类型类似，负号前缀可以帮助我们按逆字母顺序排序，正如我们在这里可以看到的：
- en: '[PRE87]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This will lead to the following output:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下输出：
- en: '[PRE88]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Yet another useful method offered by Django is `values()`. It helps us get
    a query set of dictionaries instead of objects. In the following code snippet,
    we''re using this for a `Publisher` object:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: Django 提供的另一个有用方法是 `values()`。它帮助我们获取字典查询集而不是对象。在以下代码片段中，我们使用它来查询 `Publisher`
    对象：
- en: '[PRE89]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Querying Across Relationships
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨关系查询
- en: As we have studied in this chapter, the `reviews` app has two kinds of relationships
    – many-to-one and many-to-many. So far, we have learned various ways of making
    queries using `get()`, filters, field lookups, and so on. Now let's study how
    to perform queries across relationships. There are several ways to go about this
    – we could use foreign keys, object instances, and more. Let's explore these with
    the help of some examples.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中学到的，`reviews` 应用有两种关系类型——多对一和多对多。到目前为止，我们已经学习了使用 `get()`、过滤器、字段查找等方法进行查询的各种方式。现在让我们研究如何执行跨关系查询。有几种方法可以做到这一点——我们可以使用外键、对象实例等等。让我们通过一些示例来探讨这些方法。
- en: Querying Using Foreign Keys
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用外键进行查询
- en: 'When we have relationships across two models/tables, Django provides a way
    to perform a query using the relationship. The command shown in this section will
    retrieve all the books published by `Packt Publishing` by performing a query using
    model relationships. Similar to what we''ve seen previously, this is done using
    the double-underscore lookup. For example, the `Book` model has a foreign key
    of `publisher` pointing to the `Publisher` model. Using this foreign key, we can
    perform a query using double underscores and the field `name` in the `Publisher`
    model. This can be seen from the following code:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在两个模型/表之间有关系时，Django 提供了一种使用关系执行查询的方法。本节中显示的命令将通过执行模型关系查询来检索由 `Packt Publishing`
    出版的所有书籍。与之前看到的情况类似，这是通过使用双下划线查找来完成的。例如，`Book` 模型有一个指向 `Publisher` 模型的外键 `publisher`。使用这个外键，我们可以使用双下划线和
    `Publisher` 模型中的 `name` 字段来执行查询。这可以从以下代码中看出：
- en: '[PRE90]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Querying Using Model Name
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模型名称进行查询
- en: 'Another way of querying is where we can use a relationship to do the query
    backward, using the model name in lowercase. For instance, let''s say we want
    to query the publisher who published the book *Advanced Deep Learning with Keras*
    using model relationships in the query. For this, we can execute the following
    statement to retrieve the `Publisher` information object:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 查询的另一种方式是，我们可以使用关系反向进行查询，使用模型名称的小写形式。例如，假设我们想要使用查询中的模型关系查询出版《Advanced Deep Learning
    with Keras》书籍的出版商。为此，我们可以执行以下语句来检索`Publisher`信息对象：
- en: '[PRE91]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Here, `book` is the model name in lowercase. As we already know, the `Book`
    model has a `publisher` foreign key with the value of `name` as Packt Publishing.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`book`是模型名称的小写形式。正如我们已经知道的，`Book`模型有一个`publisher`外键，其值为`name`，即Packt Publishing。
- en: Querying Across Foreign Key Relationships Using the Object Instance
  id: totrans-483
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用对象实例跨外键关系进行查询
- en: 'We can also retrieve the information using the object''s foreign key. Suppose
    we want to query the publisher''s name for the title *The Talisman*:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用对象的 外键检索信息。假设我们想要查询标题为《The Talisman》的出版商名称：
- en: '[PRE92]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Using the object here is an example where we use the reverse direction to get
    all the books published by a publisher by using the `set.all()` method:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用对象是一个例子，我们使用反向方向通过`set.all()`方法获取一个出版商出版的所有书籍：
- en: '[PRE93]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We can also create queries using chains of queries:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用查询链来创建查询：
- en: '[PRE94]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Let's perform some more exercises to shore up our knowledge of the various kinds
    of queries we have learned about so far.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行更多练习，以巩固我们对迄今为止所学的各种查询类型的知识。
- en: 'Exercise 2.10: Querying Across a Many-to-Many Relationship Using Field Lookup'
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.10：使用字段查找跨多对多关系查询
- en: 'We know that `Book` and `Contributor` have a many-to-many relationship. In
    this exercise, without creating an object, you will perform a query to retrieve
    all the contributors who contributed to writing the book titled *The Talisman*:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`Book`和`Contributor`之间存在多对多关系。在这个练习中，不创建对象，您将执行查询以检索所有参与编写标题为《The Talisman》的书籍的贡献者：
- en: 'First, import the `Contributor` class:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入`Contributor`类：
- en: '[PRE95]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now, add the following code to query for the set of contributors on *The Talisman*:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加以下代码以查询《The Talisman》的所有贡献者：
- en: '[PRE96]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'You should see the following:'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该看到以下内容：
- en: '[PRE97]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: From the preceding output, we can see that Stephen and Peter are the contributors
    who contributed to writing the book *The Talisman*. The query uses the `book`
    model (written in lowercase) and does a field lookup for the `title` field using
    the double underscore as shown in the command.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到Stephen和Peter是参与编写《The Talisman》书籍的贡献者。查询使用`book`模型（小写形式）并使用命令中的双下划线进行`title`字段的字段查找。
- en: In this exercise, we learned how to perform queries across many-to-many relationships
    using field lookup. Let's now look at using another method to carry out the same
    task.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何使用字段查找执行跨多对多关系的查询。现在，让我们看看使用另一种方法来完成相同任务。
- en: 'Exercise 2.11: A Many-to-Many Query Using Objects'
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.11：使用对象进行多对多查询
- en: 'In this exercise, using a `Book` object, search for all the contributors who
    contributed to writing the book with the title *The Talisman*. The following steps
    will help you do that:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，使用`Book`对象，搜索所有参与编写标题为《The Talisman》的书籍的贡献者。以下步骤将帮助您完成此操作：
- en: 'Import the Book model:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`Book`模型：
- en: '[PRE98]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Retrieve a book object with the title *The Talisman*, by adding the following
    line of code:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下代码行检索标题为《The Talisman》的书籍对象：
- en: '[PRE99]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Then retrieve all the contributors who worked on the book The Talisman using
    the `book` object. Add the following code to do so:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后使用`book`对象检索参与编写《The Talisman》书籍的所有贡献者。为此，请添加以下代码：
- en: '[PRE100]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Again, we can see that Stephen and Peter are the contributors who worked on
    the book *The Talisman*. Since the book has a many-to-many relationship with contributors,
    we have used the `contributors.all()` method to get a query set of all those contributors
    who worked on the book. Now, let's try using the `set` method to perform a similar
    task.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以看到Stephen和Peter是参与编写书籍《The Talisman》的贡献者。由于书籍与贡献者之间存在多对多关系，我们使用了`contributors.all()`方法来获取所有参与编写该书籍的贡献者的查询集。现在，让我们尝试使用`set`方法执行类似的任务。
- en: 'Exercise 2.12: A Many-to-Many Query Using the set() Method'
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.12：使用set()方法进行多对多查询
- en: 'In this exercise, you will use a `contributor` object to fetch all the books
    written by the contributor named `Rowel`:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用`contributor`对象检索名为`Rowel`的贡献者所写的所有书籍：
- en: 'Import the `Contributor` model:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `Contributor` 模型：
- en: '[PRE101]'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Fetch a `contributor` object whose `first_names` is `''Rowel''` using the `get()`
    method:'
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 get() 方法获取一个 `contributor` 对象，其 `first_names` 为 `'Rowel'`：
- en: '[PRE102]'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Using the `contributor` object and the `book_set()` method, get all those books
    written by the contributor:'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `contributor` 对象和 `book_set()` 方法，获取该作者所写的所有书籍：
- en: '[PRE103]'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Since `Book` and `Contributor` have a many-to-many relationship, we can use
    the `set()` method to query a set of objects associated with the model. In this
    case, `contributor.book_set.all()` returned all the books written by the contributor.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Book` 和 `Contributor` 之间存在多对多关系，我们可以使用 `set()` 方法查询与模型关联的对象集。在这种情况下，`contributor.book_set.all()`
    返回了该作者所写的所有书籍。
- en: 'Exercise 2.13: Using the update() Method'
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.13：使用 update() 方法
- en: 'In this exercise, you will use the `update()` method to update an existing
    record:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用 `update()` 方法更新现有记录：
- en: 'Change `first_names` for a contributor who has the last name `Tyrrell`:'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改具有 `last_name` 为 `Tyrrell` 的贡献者的 `first_names`：
- en: '[PRE104]'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The return value shows the number of records that have been updated. In this
    case, one record has been updated.
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回值显示已更新的记录数。在这种情况下，一条记录已被更新。
- en: 'Fetch the contributor that was just modified using the `get()` method and verify
    that the first name has been changed to `Mike`:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 get() 方法获取刚刚修改的 `contributor` 对象，并验证其名字是否已更改为 `Mike`：
- en: '[PRE105]'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Note
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: If the filter operation has more than one record, then the `update()` method
    will update the specified field in all the records returned by the filter.
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果过滤操作返回多个记录，则 `update()` 方法将更新所有返回记录中的指定字段。
- en: In this exercise, we learned how to use the `update()` method to update a record
    in the database. Now, finally, let's try deleting a record from the database using
    the `delete()` method.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何使用 `update` 方法更新数据库中的记录。现在，让我们尝试使用 `delete()` 方法从数据库中删除记录。
- en: 'Exercise 2.14: Using the delete() Method'
  id: totrans-529
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.14：使用 delete() 方法
- en: 'An existing record in the database can be deleted using the `delete()` method.
    In this exercise, you will delete a record from the `contributors` table that
    has the value of `last_name` as `Wharton`:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `delete()` 方法从数据库中删除现有记录。在这个练习中，你将删除 `contributors` 表中 `last_name` 值为 `Wharton`
    的记录：
- en: 'Fetch the object using the `get` method and use the `delete` method as shown here:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 get 方法获取对象，并按以下方式使用 delete 方法：
- en: '[PRE106]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Notice that you called the `delete()` method without assigning the `contributor`
    object to a variable. Since the `get()` method returns a single object, you can
    access the object's method without actually creating a variable for it.
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，你没有将 `contributor` 对象分配给变量就调用了 `delete()` 方法。由于 get() 方法返回单个对象，你可以直接访问对象的方法，而无需为它创建变量。
- en: 'Verify the `contributor` object with `last_name` as `''Wharton''` has been deleted:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证具有 `last_name` 为 `'Wharton'` 的 `contributor` 对象已被删除：
- en: '[PRE107]'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: As you can see upon running the query, we got an *object does not exist* error.
    This is expected since the record has been deleted. In this exercise, we learned
    how to use the `delete` method to delete a record from the database.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，运行查询时出现了 *对象不存在* 错误。这是预期的，因为记录已被删除。在这个练习中，我们学习了如何使用 `delete` 方法从数据库中删除记录。
- en: 'Activity 2.01: Create Models for a Project Management Application'
  id: totrans-537
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 2.01：为项目管理应用程序创建模型
- en: 'Imagine you are developing a project management application called `Juggler`.
    Juggler is an application that can track multiple projects, and each project can
    have multiple tasks associated with it. The following steps will help you complete
    this activity:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在开发一个名为 `Juggler` 的项目管理应用程序。Juggler 是一个可以跟踪多个项目，并且每个项目可以关联多个任务的应用程序。以下步骤将帮助你完成此活动：
- en: Using the techniques we have learned so far, create a Django project called `juggler`.
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们迄今为止学到的技术，创建一个名为 `juggler` 的 Django 项目。
- en: Create a Django app called `projectp`.
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `projectp` 的 Django 应用程序。
- en: Add the app projects in the `juggler/settings.py` file.
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `juggler/settings.py` 文件中添加 app projects。
- en: Create two related model classes called `Project` and `Task` in `projectp/models.py`.
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `projectp/models.py` 中创建两个相关模型类 `Project` 和 `Task`。
- en: Create migration scripts and migrate the models' definitions to the database.
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建迁移脚本并将模型定义迁移到数据库中。
- en: Open the Django shell now and import the models.
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开 Django shell 并导入模型。
- en: Populate the database with an example and write a query displaying the list
    of tasks associated with a given project.
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用示例数据填充数据库，并编写一个查询以显示与给定项目关联的任务列表。
- en: Note
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在 [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ) 找到。
- en: Populating the Bookr Project's Database
  id: totrans-548
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充 Bookr 项目的数据库
- en: 'Although we know how to create database records for the project, in the next
    few chapters, we will have to create a lot of records to work with the project.
    For that reason, we have created a script that can make things easy for us. This
    script populates the database by reading a **.csv** (**Comma-Separated Values**)
    file consisting of many records. Follow the next few steps to populate the project''s
    database:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们知道如何为项目创建数据库记录，但在接下来的几章中，我们将不得不创建大量记录以与项目一起工作。因此，我们创建了一个脚本，可以使事情变得简单。此脚本通过读取包含许多记录的
    **.csv** （逗号分隔值）文件来填充数据库。按照以下步骤填充项目的数据库：
- en: 'Create the following folder structure inside the project directory:'
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目目录内创建以下文件夹结构：
- en: '[PRE108]'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Copy the `loadcsv.py` file from the following location and `WebDevWithDjangoData.csv`
    into the folder created. This can be found on the GitHub repository for this book
    at [http://packt.live/3pvbCLM](http://packt.live/3pvbCLM).
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下位置复制 `loadcsv.py` 文件和 `WebDevWithDjangoData.csv` 到创建的文件夹中。这些文件可以在本书的 GitHub
    仓库 [http://packt.live/3pvbCLM](http://packt.live/3pvbCLM) 中找到。
- en: 'Because `loadcsv.py` is placed inside the `management/commands` folder, now
    it works like a Django custom management command. You can go through the `loadcsv.py`
    file and read more about writing Django custom management commands at this link:
    [https://docs.djangoproject.com/en/3.0/howto/custom-management-commands/.](https://docs.djangoproject.com/en/3.0/howto/custom-management-commands/.)'
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为 `loadcsv.py` 放置在 `management/commands` 文件夹中，现在它就像一个 Django 自定义管理命令一样工作。您可以查看
    `loadcsv.py` 文件，并在此链接中了解更多关于编写 Django 自定义管理命令的信息：[https://docs.djangoproject.com/en/3.0/howto/custom-management-commands/](https://docs.djangoproject.com/en/3.0/howto/custom-management-commands/)。
- en: 'Now let''s recreate a fresh database. Delete your SQL database file present
    in the project folder:'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们重新创建一个全新的数据库。删除项目文件夹中存在的 SQL 数据库文件：
- en: '[PRE109]'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'To create a fresh database again, execute the Django `migrate` command:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要再次创建一个全新的数据库，请执行 Django 的 `migrate` 命令：
- en: '[PRE110]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Now you can see the newly created `db.sqlite3` file under the `reviews` folder.
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，您可以在 `reviews` 文件夹下看到新创建的 `db.sqlite3` 文件。
- en: 'Execute the custom management command `loadcsv` to populate the database:'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行自定义管理命令 `loadcsv` 以填充数据库：
- en: '[PRE111]'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Using DB Browser for SQLite, verify that all the tables created by the `bookr`
    project are populated.
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 DB Browser for SQLite，验证由 `bookr` 项目创建的所有表都已填充。
- en: Summary
  id: totrans-562
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about some basic database concepts and their importance
    in application development. We used a free database visualization tool, DB Browser
    for SQLite, to understand what database tables and fields are, how records are
    stored in a database, and further performed some basic CRUD operations on the
    database using simple SQL queries.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了某些基本数据库概念及其在应用程序开发中的重要性。我们使用了一个免费的数据库可视化工具 DB Browser for SQLite，以了解数据库表和字段是什么，记录如何在数据库中存储，并进一步使用简单的
    SQL 查询在数据库上执行了一些基本的 CRUD 操作。
- en: We then learned how Django provides a valuable abstraction layer called ORM
    that helps us interact seamlessly with relational databases using simple Python
    code, without having to compose SQL commands. As a part of ORM, we learned about
    Django models, migrations, and how they help propagate the changes to the Django
    models in the database.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了 Django 提供的一个非常有价值的抽象层，称为 ORM，它帮助我们通过简单的 Python 代码无缝地与关系数据库交互，而无需编写
    SQL 命令。作为 ORM 的一部分，我们学习了 Django 模型、迁移以及它们如何帮助将更改传播到数据库中的 Django 模型。
- en: We shored up our knowledge of databases by learning about database relationships,
    and their key types, in relational databases. We also worked with the Django shell,
    where we used Python code to perform the same CRUD queries we performed earlier
    using SQL. Later, we learned how to retrieve our data in a more refined manner
    using pattern matching and field lookups. As we learned these concepts, we made
    considerable progress on our Bookr application as well. We created models for
    our `reviews` app and gained all the skills we need to interact with the data
    stored inside the app's database. In the next chapter, we will learn how to create
    Django views, URL routing, and templates.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过学习关系型数据库中的数据库关系及其关键类型，巩固了我们对数据库的知识。我们还使用了Django shell，在那里我们用Python代码执行了之前用SQL执行过的相同的CRUD查询。后来，我们学习了如何使用模式匹配和字段查找以更精细的方式检索我们的数据。在我们学习这些概念的同时，我们在Bookr应用程序上也取得了显著的进展。我们为`reviews`应用程序创建了模型，并获得了与该应用程序数据库中存储的数据交互所需的所有技能。在下一章中，我们将学习如何创建Django视图、URL路由和模板。
