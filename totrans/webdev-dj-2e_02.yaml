- en: 2\. Models and Migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces you to the concept of databases and their importance
    in building web applications. You will start by creating a database using an open-source
    database visualization tool called **SQLite DB Browser**. You will then perform
    some basic **Create Read Update Delete** (**CRUD**) database operations using
    SQL commands. Then, you will learn about Django's **Object Relational Mapping**
    (**ORM**), using which your application can interact and seamlessly work with
    a relational database using simple Python code, eliminating the need to run complex
    SQL queries. You will learn about **models** and **migrations**, which are a part
    of Django's ORM, that are used to propagate database schematic changes from the
    application to the database, and also perform database CRUD operations. Toward
    the end of the chapter, you will study the various types of database relationships
    and use that knowledge to perform queries across related records.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data is at the core of most web applications. Unless we're talking about a very
    simple application such as a calculator, in most cases we need to store data,
    process it, and display it to the user on a page. Since most operations in user-facing
    web applications involve data, there is a need to store data in places that are
    secure, easily accessible, and readily available. This is where databases come
    in handy. Imagine a library operational before the advent of computers. The librarian
    would have to maintain records of book inventories, records of book lending, returns
    from students, and so on. All of these would have been maintained in physical
    records. The librarian, while carrying out their day-to-day activities, would
    modify these records for each operation, for example, when lending a book to someone
    or when the book was returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, we have databases to help us with such administrative tasks. A database
    looks like a spreadsheet or an Excel sheet containing records, with each table
    consisting of multiple rows and columns. An application can have many such tables.
    Here is an example table of a book inventory in a library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: Table of a book inventory for a library'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_02_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.1: Table of a book inventory for a library'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding table, we can see that there are columns with details about
    various attributes of the books in the library, while the rows contain entries
    for each book. To manage a library, there can be many such tables working together
    as a system. For example, along with an inventory, we may have other tables such
    as student information, book lending records, and so on. Databases are built with
    the same logic, where software applications can easily manage data.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we had a brief introduction to Django and its use in
    developing web applications. Then we learned about the Model-View-Template (MVT)
    concept. Later, we created a Django project and started the Django development
    server. We also had a brief discussion about Django's views, URLs, and templates.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start by learning about the types of databases and
    a few basic database operations using SQL. After that, we will move on to the
    concept of models and migrations in Django, which assist in faster development
    by providing a layer of abstraction to facilitate database operations using Python
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A database is a structured collection of data that helps manage information
    easily. A software layer called the Database Management System (DBMS) is used
    to store, maintain, and perform operations on the data. Databases are of two types,
    relational databases and non-relational databases.
  prefs: []
  type: TYPE_NORMAL
- en: Relational Databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Relational databases or Structured Query Language (SQL) databases store data
    in a pre-determined structure of rows and columns called tables. A database can
    be made up of more than one such table, and these tables have a fixed structure
    of attributes, data types, and relations with other tables. For example, as we
    just saw in *Figure 2.1*, the book inventory table has a fixed structure of columns
    comprising **Book Number**, **Author**, **Title**, and **Number of Copies**, and
    the entries form the rows in the table. There could be other tables as well, such
    as **Student Information** and **Lending Records**, which could be related to
    the inventory table. Also, whenever a book is lent to a student, the records will
    be stored per the relationships between multiple tables (say, the **Student Information**
    and the **Book Inventory** tables).
  prefs: []
  type: TYPE_NORMAL
- en: This pre-determined structure of rules defining the data types, tabular structures,
    and relationships across different tables acts like scaffolding or a blueprint
    for a database. This blueprint is collectively called a database schema. When
    applied to a database, it will prepare the database to store application data.
    To manage and maintain these databases, there is a common language for relational
    databases called SQL. Some examples of relational databases are SQLite, PostgreSQL,
    MySQL, and OracleDB.
  prefs: []
  type: TYPE_NORMAL
- en: Non-Relational Databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Non-relational databases or NoSQL (Not Only SQL) databases are designed to store
    unstructured data. They are well suited to large amounts of generated data that
    does not follow rigid rules, as is the case with relational databases. Some examples
    of non-relational databases are Cassandra, MongoDB, CouchDB, and Redis.
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine that you need to store the stock value of companies in
    a database using Redis. Here, the company name will be stored as the key and the
    stock value as the value. Using the key-value type NoSQL database in this use
    case is appropriate because it stores the desired value for a unique key and is
    faster to access.
  prefs: []
  type: TYPE_NORMAL
- en: For the scope of this book, we will be dealing only with relational databases
    as Django does not officially support non-relational databases. However, if you
    wish to explore, there are many forked projects, such as Django non-rel, that
    support NoSQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: Database Operations Using SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQL uses a set of commands to perform a variety of database operations, such
    as creating an entry, reading values, updating an entry, and deleting an entry.
    These operations are collectively called **CRUD operations**, which stands for
    Create, Read, Update, and Delete. To understand database operations in detail,
    let's first get some hands-on experience with SQL commands. Most relational databases
    share a similar SQL syntax; however, some operations will differ.
  prefs: []
  type: TYPE_NORMAL
- en: For the scope of this chapter, we will use SQLite as the database. SQLite is
    a lightweight relational database that is a part of Python standard libraries.
    That's why Django uses SQLite as its default database configuration. However,
    we will also learn more about how to perform configuration changes to use other
    databases in *Chapter 17*, *Deployment of a Django Application (Part 1 – Server
    Setup)*. This chapter can be downloaded from the GitHub repository of this book,
    from [http://packt.live/2Kx6FmR](http://packt.live/2Kx6FmR).
  prefs: []
  type: TYPE_NORMAL
- en: Data Types in Relational databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Databases provide us with a way to restrict the type of data that can be stored
    in a given column. These are called data types. Some examples of data types for
    a relational database such as SQLite3 are given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`INTEGER` is used for storing integers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TEXT` can store text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REAL` is used for floating-point values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, you would want the title of a book to have `TEXT` as the data type.
    So, the database will enforce a rule that no type of data, other than text data,
    can be stored in that column. Similarly, the book's price can have a `REAL` data
    type, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.01: Creating a Book Database'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will create a book database for a book review application.
    For better visualization of the data in the SQLite database, you will install
    an open-source tool called **DB Browser** for SQLite. This tool helps visualize
    the data and provides a shell to execute the SQL commands.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't done so already, visit the URL [https://sqlitebrowser.org](https://sqlitebrowser.org)
    and from the *downloads* section, install the application as per your operating
    system and launch it. Detailed instructions for DB Browser installation can be
    found in the *Preface*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Database operations can be performed using a command-line shell as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'After launching the application, create a new database by clicking `New Database`
    in the top-left corner of the application. Create a database named `bookr`, as
    you are working on a book review application:![Figure 2.2: Creating a database
    named bookr'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_02_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 2.2: Creating a database named bookr'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, click the `Create Table` button in the top-left corner and enter `book`
    as the table name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After clicking the `Save` button, you may find that the window for creating
    a table opens up automatically. In that case, you won't have to click the `Create
    Table` button; simply proceed with the creation of the book table as specified
    in the preceding step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, click the `Add field` button, enter the field name as `title`, and select
    the type as `TEXT` from the dropdown. Here `TEXT` is the data type for the `title`
    field in the database:![Figure 2.3: Adding a TEXT field named title'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_02_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 2.3: Adding a TEXT field named title'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Similarly, add two more fields for the table named `publisher` and `author`
    and select `TEXT` as the type for both the fields. Then, click the `OK` button:![Figure
    2.4: Creating TEXT fields named publisher and author'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_02_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 2.4: Creating TEXT fields named publisher and author'
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates a database table called `book` in the `bookr` database with the
    fields title, publisher, and `author`. This can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5: Database with the fields title, publisher, and author'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_02_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.5: Database with the fields title, publisher, and author'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we used an open-source tool called DB Browser (SQLite) to
    create our first database called `bookr`, and in it, we created our first table
    named `book`.
  prefs: []
  type: TYPE_NORMAL
- en: SQL CRUD Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's assume that the editors or the users of our book review application want
    to make some modifications to the book inventory, such as adding a few books to
    the database, updating an entry in the database, and so on. SQL provides various
    ways to perform such CRUD operations. Before we dive into the world of Django
    models and migrations, let's explore these basic SQL operations first.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the CRUD operations that follow, you will be running a few SQL queries.
    To run them, navigate to the `Execute SQL` tab in DB Browser. You can type in
    or paste the SQL queries we''ve listed in the sections that follow in the `SQL
    1` window. You can spend some time modifying your queries, and understanding them,
    before you execute them. When you''re ready, click the icon that looks like a
    `Play` button or press the F5 key to execute the command. The results will show
    up in the window below the `SQL 1` window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6: Executing SQL queries in DB Browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_02_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.6: Executing SQL queries in DB Browser'
  prefs: []
  type: TYPE_NORMAL
- en: SQL Create Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `insert` command, which, as the name implies, lets us insert data into
    the database. Let''s go back to our `bookr` example. Since we have already created
    the database and the `book` table, we can now create or insert an entry in the
    database by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This inserts into the table named `book` the values defined in the command.
    Here, `The Sparrow Warrior` is the title, `Super Hero Publications` is the publisher,
    and `Patric Javagal` is the author of the book. Note that the order of insertion
    corresponds with the way we have created our table; that is, the values are inserted
    into the columns representing title, publisher, and author respectively. Similarly,
    let''s execute two more inserts to populate the `book` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The three inserts executed so far will insert three rows into the `book` table.
    But how do we verify that? How would we know whether those three entries we inserted
    were entered into the database correctly? Let's learn how to do that in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Read Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can read from the database using the `select` SQL operation. For example,
    the following SQL `select` command retrieves the selected entries created in the
    `book` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7: Output after using the select command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_02_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.7: Output after using the select command'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `select` is the command that reads from the database, and the fields
    `title`, `publisher`, and `author` are the columns that we intend to select from
    the book table. Since these are all the columns the database has, the select statement
    has returned all the values present in the database. The select statement is also
    called a SQL query. An alternate way to get all the fields in the database is
    by using the wildcard `*` in the select query instead of specifying all the column
    names explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the same output as shown in the preceding figure. Now, suppose
    we want to get the author name for the book titled `The Sparrow Warrior`; in this
    case, the `select` query would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have added a special SQL keyword called `where` so that the `select`
    query returns only the entries that match the condition. The result of the query,
    of course, will be `Patric Javagal`. Now, what if we wanted to change the name
    of the book's publisher?
  prefs: []
  type: TYPE_NORMAL
- en: SQL Update Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In SQL, the way to update a record in the database is by using the `update`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are setting the value of publisher to `Northside Publications` if
    the value of the title is `The Sparrow Warrior`. We can then run the `select`
    query we ran in the SQL Read Operations section to see how the updated table looks
    after running the `update` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8: Updating the value of publisher for the title The Sparrow Warrior'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_02_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.8: Updating the value of publisher for the title The Sparrow Warrior'
  prefs: []
  type: TYPE_NORMAL
- en: Next, what if we wanted to delete the title of the record we just updated?
  prefs: []
  type: TYPE_NORMAL
- en: SQL Delete Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is an example of how to delete a record from the database using the `delete` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`delete` is the SQL keyword for delete operations. Here, this operation will
    be performed only if the title is `The Sparrow Warrior`. Here is how the book
    table will look after the delete operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9: Output after performing the delete operation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_02_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.9: Output after performing the delete operation'
  prefs: []
  type: TYPE_NORMAL
- en: These are the basic operations of SQL. We will not go very deep into all the
    SQL commands and syntax, but feel free to explore more about database base operations
    using SQL.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For further reading, you can start by exploring some advanced SQL `select` operations
    with `join` statements, which are used to query data across multiple tables. For
    a detailed course on SQL, you can refer to *The SQL Workshop* ([https://www.packtpub.com/product/the-sql-workshop/9781838642358](https://www.packtpub.com/product/the-sql-workshop/9781838642358)).
  prefs: []
  type: TYPE_NORMAL
- en: Django ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Web applications constantly interact with databases, and one of the ways to
    do so is using SQL. If you decide to write a web application without a web framework
    like Django and instead use Python alone, Python libraries such as `psycopg2`
    could be used to interact directly with the databases using SQL commands. But
    while developing a web application with multiple tables and fields, SQL commands
    can easily become overly complex and thus difficult to maintain. For this reason,
    popular web frameworks such as Django provide a level of abstraction using which
    we can easily work with databases. The part of Django that helps us do this is
    called **ORM**, which stands for **Object Relational Mapping**.
  prefs: []
  type: TYPE_NORMAL
- en: Django ORM converts object-oriented Python code into actual database constructs
    such as database tables with data type definitions and facilitates all the database
    operations via simple Python code. Because of this, we do not have to deal with
    SQL commands while performing database operations. This helps in faster application
    development and ease in maintaining the application source code.
  prefs: []
  type: TYPE_NORMAL
- en: Django supports relational databases such as SQLite, PostgreSQL, Oracle Database,
    and MySQL. Django's database abstraction layer ensures that the same Python/Django
    source code can be used across any of the above relational databases with very
    little modification to the project settings. Since SQLite is part of the Python
    libraries and Django is configured by default to SQLite, for the scope of this
    chapter, we shall use SQLite while we learn about Django models and migrations.
  prefs: []
  type: TYPE_NORMAL
- en: Database Configuration and Creating Django Applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have already seen in *Chapter 1*, *Introduction to Django*, when we create
    a Django project and run the Django server, the default database configuration
    is of SQLite3\. The database configuration will be present in the project directory,
    in the `settings.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you go through the `settings.py` file for the `bookr` app. Going
    through the entire file once will help you understand the concepts that follow.
    You can find the file at this link: [http://packt.live/2KEdaUM](http://packt.live/2KEdaUM).'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for our example project, the database configuration will be present at
    the following location: `bookr/settings.py`. The default database configuration
    present in this file, when a Django project is created, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code snippet uses a backslash ( \ ) to split the logic across
    multiple lines. When the code is executed, Python will ignore the backslash, and
    treat the code on the next line as a direct continuation of the current line.
  prefs: []
  type: TYPE_NORMAL
- en: The DATABASES variable is assigned with a dictionary containing the database
    details for the project. Inside the dictionary, there is a nested dictionary with
    a key as default. This holds the configuration of a default database for the Django
    project. The reason we have a nested dictionary with `default` as a key is that
    a Django project could potentially interact with multiple databases, and the default
    database is the one used by Django for all operations unless explicitly specified.
    The ENGINE key represents which database engine is being used; in this case, it
    is `sqlite3`.
  prefs: []
  type: TYPE_NORMAL
- en: The `NAME` key defines the name of the database, which can have any value. But
    for SQLite3, since the database is created as a file, `NAME` can have the full
    path of the directory where the file needs to be created. The full path of the
    `db` file is processed by joining (or concatenating) the previously defined path
    in `BASE_DIR` with `db.sqlite3`. Note that `BASE_DIR` is the project directory
    as already defined in the `settings.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using other databases, such as PostgreSQL, MySQL, and so on, changes
    will have to be made in the preceding database settings as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, changes have been made to `ENGINE` to use PostgreSQL. The host IP address
    and port number of the server need to be provided for `HOST` and `PORT` respectively.
    As the names suggest, `USER` is the database username and `PASSWORD` is the database
    password. In addition to changes in the configuration, we will have to install
    the database drivers or bindings along with the database host and credentials.
    This will be covered in detail in later chapters, but for now, since we are using
    SQLite3, the default configuration will be sufficient. Note that the above is
    just an example to show the changes you'll need to make to use a different database
    such as PostgreSQL, but since we are using SQLite, we shall use the database configuration
    that exists already, and there is no need to make any modifications to the database
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: Django Apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Django project can have multiple apps that often act as discrete entities.
    That's why, whenever required, an app can be plugged into a different Django project
    as well. For example, if we are developing an e-commerce web application, the
    web application can have multiple apps, such as a chatbot for customer support
    or a payment gateway to accept payments as users purchase goods from the application.
    These apps, if needed, can also be plugged into or reused in a different project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Django comes with the following apps enabled by default. The following is a
    snippet from a project''s `settings.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: These are a set of installed or default apps used for the admin site, authentication,
    content types, sessions, messaging, and an application to collect and manage static
    files. In the upcoming chapters, we shall study this in-depth. For the scope of
    this chapter, though, we shall understand why Django migration is needed for these
    installed apps.
  prefs: []
  type: TYPE_NORMAL
- en: Django Migration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have learned before, Django's ORM helps make database operations simpler.
    A major part of the operation is to transform the Python code into database structures
    such as database fields with stated data types and tables. In other words, the
    transformation of Python code into database structures is known as `TEXT` in *step
    4* of *Exercise 2.01*, *Creating a Book Database*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have a Django project set up, let''s perform our first migration.
    Although we have not added any code yet to our project, we can migrate the applications
    listed in `INSTALLED_APPS`. This is necessary because Django''s installed apps
    need to store the relevant data in the database for their operations, and migration
    will create the required database tables to store the data in the database. The
    following command should be entered in the terminal or shell to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For macOS, you can use `python3` instead of `python` in the preceding command.
  prefs: []
  type: TYPE_NORMAL
- en: Here, `manage.py` is a script that was automatically created when the project
    was created. It is used for carrying out managerial or administrative tasks. By
    executing this command, we create all the database structures required by the
    installed apps.
  prefs: []
  type: TYPE_NORMAL
- en: As we are using DB Browser for SQLite to browse the database, let's take a look
    at the database for which changes have been made after executing the `migrate` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The database file will have been created in the project directory under the
    name `db.sqlite3`. Open DB Browser, click `Open Database`, navigate until you
    find the `db.sqlite3` file, and open it. You should see a set of newly created
    tables created by the Django migration. It will look as follows in DB Browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10: Contents of the db.sqlite3 file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_02_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.10: Contents of the db.sqlite3 file'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we browse through the newly created database structure by clicking
    the database tables, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11: Browsing through the newly created database structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_02_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.11: Browsing through the newly created database structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the database tables created have different fields, each with their
    respective data types. Click the `Browse data` tab in DB Browser and select a
    table from the dropdown. For instance, after clicking the `auth_group_permissions`
    table, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12: Viewing the auth_group_permissions table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_02_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.12: Viewing the auth_group_permissions table'
  prefs: []
  type: TYPE_NORMAL
- en: You will see that there is no data available for these tables yet because Django
    migration only creates the database structure or the blueprint, and the actual
    data in the database is stored during the operation of the application. Now since
    we have migrated the built-in or default Django apps, let's try to create an app
    and perform a Django migration.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Django Models and Migrations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Django model is essentially a Python class that holds the blueprint for creating
    a table in a database. The `models.py` file can have many such models, and each
    model transforms into a database table. The attributes of the class form the fields
    and relationships of the database table as per the model definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our reviews application, we need to create the following models and their
    database tables consequently:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Book: This should store information about books.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contributor: This should store information about the person(s) who contributed
    to writing the book, such as author, co-author, or editor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Publisher: As the name implies, this refers to the book publisher.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Review: This should store all the books'' reviews written by the users of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Every book in our application will need to have a publisher, so let''s create
    `Publisher` as our first model. Enter the following code in `reviews/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can take a look at the complete models.py file for the bookr app by clicking
    the following link: [http://packt.live/3hmFQxn](http://packt.live/3hmFQxn).'
  prefs: []
  type: TYPE_NORMAL
- en: The first line of code imports the Django's `models` module. While this line
    will be autogenerated at the time of the creation of the Django app, do make sure
    you add it if it is not present. Following the import, the rest of the code is
    defining a class named `Publisher`, which will be a subclass of Django's `models.Model`.
    Furthermore, this class will have attributes or fields such as name, website,
    and email.
  prefs: []
  type: TYPE_NORMAL
- en: Field Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we can see, each of these fields is defined to have the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CharField`: This field type is used to store shorter string fields, for example,
    Packt Publishing. For very large strings, we use `TextField`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EmailField`: This is similar to `CharField`, but validates whether the string
    represents a valid email address, for example, customersupport@packtpub.com.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`URLField`: This is again similar to `CharField`, but validates whether the
    string represents a valid URL, for example, [https://www.packtpub.com](https://www.packtpub.com).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Field Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Django provides a way to define field options to a model''s field. These field
    options are used to set a value or a constraint, and so on. For example, we can
    set a default value for a field using `default=<value>`, to ensure that every
    time a record is created in the database for the field, it is set to a default
    value specified by us. Following are the two field options that we have used while
    defining the `Publisher` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '`help_text`: This is a field option that helps us add descriptive text for
    a field that gets automatically included for Django forms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_length`: This option is provided to `CharField` where it defines the maximum
    length of the field in terms of the number of characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django has many more field types and field options that can be explored from
    the extensive official Django documentation. As we go about developing our sample
    book review application, we shall learn about those types and fields that are
    used for the project. Now let''s migrate the Django models into the database.
    Execute the following command in the shell or terminal to do that (run it from
    the folder where your `manage.py` file is stored):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `makemigrations <appname>` command creates the migration scripts for the
    given app; in this case, for the reviews app. Notice that after running makemigrations,
    there is a new file created under the `migrations` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13: New file under the migrations folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_02_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.13: New file under the migrations folder'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the migration script created by Django. When we run `makemigrations`
    without the app name, the migration scripts will be created for all the apps in
    the project. Next, let''s list the project migration status. Remember that earlier,
    we applied migrations to Django''s installed apps and now we have created a new
    app, reviews. The following command, when run in the shell or terminal, will show
    the status of model migrations throughout the project (run it from the folder
    where your `manage.py` file is stored):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `[X]` mark indicates that the migrations have been applied. Notice
    the difference that all the other apps' migrations have applied except that of
    reviews. The `showmigrations` command can be executed to understand the migration
    status, but this is not a mandatory step while performing model migrations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s understand how Django transforms a model into an actual database
    table. This can be understood by running the `sqlmigrate` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet shows the SQL command equivalent used when Django migrates
    the database. In this case, we are creating the `reviews_publisher` table with
    the fields name, website, and email with the defined field types. Furthermore,
    all these fields are defined to be `NOT NULL`, implying that the entries for these
    fields cannot be null and should have some value. The `sqlmigrate` command is
    not a mandatory step while doing the model migrations.
  prefs: []
  type: TYPE_NORMAL
- en: Primary Keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's assume that a database table called users, as its name suggests, stores
    information about users. Let's say it has more than 1,000 records and there are
    at least 3 users with the same name, Joe Burns. How do we uniquely identify these
    users from the application? The solution is to have a way to uniquely identify
    each record in the database. This is done using `id` as the primary key (of type
    integer), which auto increments as new records are created.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, notice the output of the `python manage.py sqlmigrate`
    command. While creating the `Publisher` table, the `SQL CREATE TABLE` command
    was adding one more field called `id` to the table. `id` is defined to be `PRIMARY
    KEY AUTOINCREMENT`. In relational databases, a primary key is used to uniquely
    identify an entry in the database. For example, the book table has `id` as the
    primary key, which has numbers starting from 1\. This value increments by 1 as
    new records are created. The integer value of `id` is always unique across the
    book table. Since the migration script has already been created by executing makemigrations,
    let''s now migrate the newly created model in the reviews app by executing the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This operation creates the database table for the reviews app. The following
    is a snippet from DB Browser indicating the new table `reviews_publisher` has
    been created in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14: reviews_publisher table created after executing the migration
    command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_02_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.14: reviews_publisher table created after executing the migration
    command'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have explored how to create a model and migrate it into the database.
    Let''s now work on creating the rest of the models for our book review application.
    As we''ve already seen, the application will have the following database tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Book`: This is the database table that holds the information about the book
    itself. We have already created a `Book` model and have migrated this to the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Publisher`: This table holds information about the book publisher.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Contributor`: This table holds information about the contributor, that is,
    the author, co-author, or editor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Review`: This table holds information about the review comments posted by
    the reviewers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s add the `Book` and `Contributor` models, as shown in the following code
    snippet, into `reviews/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The code is self-explanatory. The `Book` model has the fields title, publication_date,
    and isbn. The `Contributor` model has the fields `first_names` and `last_names`
    fields and the email ID of the contributor. There are some newly added models
    as well, apart from the ones we have seen in the Publisher model. They have `DateField`
    as a new field type, which, as the name suggests, is used to store a date. A new
    field option called `verbose_name` is also used. It provides a descriptive name
    for the field.
  prefs: []
  type: TYPE_NORMAL
- en: Relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the powers of relational databases is the ability to establish relationships
    between data stored across database tables. Relationships help maintain data integrity
    by establishing the correct references across tables, which in turn helps maintain
    the database. Relationship rules, on the other hand, ensure data consistency and
    prevent duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a relational database, there can be the following types of relations:'
  prefs: []
  type: TYPE_NORMAL
- en: Many to one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many to many
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One to one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's explore each relationship in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Many to One
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this relationship, many records (rows/entries) from one table can refer to
    one record (row/entry) in another table. For example, there can be many books
    produced by one publisher. This is a case of a many-to-one relationship. To establish
    this relationship, we need to use the database's foreign keys. A foreign key in
    a relational database establishes the relationship between a field from one table
    and a primary key from a different table.
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you have data about employees belonging to different departments
    stored in a table called `employee_info` with their employee ID as the primary
    key alongside a column that stores their department name; this table also contains
    a column that stores that department's department ID. Now, there's another table
    called `departments_info`, which has department ID as the primary key. In this
    case, then, the department ID is a foreign key in the `employee_info` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `bookr` app, the `Book` model can have a foreign key referring to the
    primary key of the `Publisher` table. Since we have already created the models
    for `Book`, `Contributor`, and `Publisher`, now let''s establish a many-to-one
    relationship across the `Book` and `Publisher` models. For the `Book` model, add
    the last line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the newly added `publisher` field is establishing a many-to-one relationship
    between `Book` and `Publisher` using a foreign key. This relationship ensures
    the nature of a many-to-one relationship, which is that many books can have one publisher:'
  prefs: []
  type: TYPE_NORMAL
- en: '`models.ForeignKey`: This is the field option to establish a many-to-one relationship.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Publisher`: When we establish relationships with different tables in Django,
    we refer to the model that creates the table; in this case, the `Publisher` table
    is created by the `Publisher` model (or the Python class Publisher).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on_delete`: This is a field option that determines the action to be taken
    upon the deletion of the referenced object. In this case, the `on_delete` option
    is set to `CASCADE(models.CASCADE)`, which deletes the referenced objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, assume a publisher has published a set of books. For some reason,
    if the publisher has to be deleted from the application, the next action is CASCADE,
    which means delete all the referenced books from the application. There are many
    more `on_delete` actions, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PROTECT`: This prevents the deletion of the record unless all the referenced
    objects are deleted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SET_NULL`: This sets a null value if the database field has been previously
    configured to store null values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SET_DEFAULT`: Sets to a default value on the deletion of the referenced object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our book review application, we will be using only the CASCADE option.
  prefs: []
  type: TYPE_NORMAL
- en: Many to Many
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this relationship, multiple records in a table can have a relationship with
    multiple records in a different table. For example, a book can have multiple co-authors
    and each author (contributor) could have written multiple books. So, this forms
    a many-to-many relationship between the `Book` and `Contributor` tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15: Many-to-many relationship between books and co-authors'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_02_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.15: Many-to-many relationship between books and co-authors'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `models.py`, for the Book model, add the last line as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The newly added contributors field establishes a many-to-many relationship
    with Book and Contributor using the ManyToManyField field type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`models.ManyToManyField`: This is the field type to establish a many-to-many relationship.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`through`: This is a special field option for many-to-many relationships. When
    we have a many-to-many relationship across two tables, if we want to store some
    extra information about the relationship, then we can use this to establish the
    relationship via an intermediary table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, we have two tables, namely `Book` and `Contributor`, where we
    need to store the information on the type of contributor for the book, such as
    Author, Co-author, or Editor. Then the type of contributor is stored in an intermediary
    table called `BookContributor`. Here is how the `BookContributor` table/model
    looks. Make sure you include this model in `reviews/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete `models.py` file can be viewed at this link: [http://packt.live/3hmFQxn](http://packt.live/3hmFQxn).'
  prefs: []
  type: TYPE_NORMAL
- en: 'An intermediary table such as `BookContributor` establishes relationships by
    using foreign keys to both the `Book` and `Contributor` tables. It can also have
    extra fields that can store information about the relationship the `BookContributor`
    model has with the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`book`: This is a foreign key to the `Book` model. As we saw previously, `on_delete=models.CASCADE`
    will delete an entry from the relationship table when the relevant book is deleted
    from the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Contributor`: This is again a foreign key to the `Contributor` model/table.
    This is also defined as `CASCADE` upon deletion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`role`: This is the field of the intermediary model, which stores the extra
    information about the relationship between `Book` and `Contributor`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class ContributionRole(models.TextChoices)`: This can be used to define a
    set of choices by creating a subclass of `models.TextChoices`. For example, `ContributionRole`
    is a subclass created out of `TextChoices`, which is used by the roles field to
    define Author, Co-Author, and Editor as a set of choices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`choices`: This refers to a set of choices defined in the models, and they
    are useful when creating Django `Forms` using the models.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When the through field option is not provided while establishing a many-to-many
    relationship, Django automatically creates an intermediary table to manage the
    relationship.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One-to-One Relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this relationship, one record in a table will have a reference to only one
    record in a different table. For example, a person can have only one driver''s
    license, so a person to their driver''s license could form a one-to-one relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16: Example of a one-to-one relationship'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_02_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.16: Example of a one-to-one relationship'
  prefs: []
  type: TYPE_NORMAL
- en: 'The OneToOneField can be used to establish a one-to-one relationship, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have explored database relationships, let's come back to our bookr
    application and add one more model there.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Review Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve already added the `Book` and `Publisher` models to the `reviews/models.py`
    file. The last model that we are going to add is the `Review` model. The following
    code snippet should help us do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete `models.py` file can be viewed at this link: [http://packt.live/3hmFQxn](http://packt.live/3hmFQxn).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `review` model/table will be used to store user-provided review comments
    and ratings for books. It has the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`content`: This field stores the text for a book review, hence the field type
    used is `TextField` as this can store a large amount of text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rating`: This field stores the review rating of a book. Since the rating is
    going to be an integer, the field type used is `IntegerField`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`date_created`: This field stores the time and date when the review was written,
    hence the field type is `DateTimeField`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`date_edited`: This field stores the date and time whenever a review is edited.
    The field type is again `DateTimeField`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Creator`: This field specifies the review creator or the person who writes
    the book review. Notice that this is a foreign key to `auth.get_user_model()`,
    which is referring to the `User` model from Django''s built-in authentication
    module. It has a field option `on_delete=models.CASCADE`. This explains that when
    a user is deleted from the database, all the reviews written by that user will
    be deleted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Book`: Reviews have a field called `book`, which is a foreign key to the `Book`
    model. This is because for a book review application, reviews have to be written,
    and a book can have many reviews, so this is a many-to-one relationship. This
    is also defined with a field option, `on_delete=models.CASCADE`, because once
    the book is deleted, there is no point in retaining the reviews in the application.
    So, when a book is deleted, all the reviews referring to the book will also get deleted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Django, we can write methods inside a model class. These are called `__str__()`.
    This method returns the string representation of the `Model` instances and can
    be especially useful while using the Django shell. In the following example, where
    the `__str__()` method is added to the `Publisher` model, the string representation
    of the `Publisher` object will be the publisher''s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `_str_()` methods to `Contributor` and `Book` as well, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Migrating the Reviews App
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we have the entire model file ready, let''s now migrate the models into
    the database, similar to what we did before with the installed apps. Since the
    reviews app has a set of models created by us, before running the migration, it
    is important to create the migration scripts. Migration scripts help in identifying
    any changes to the models and will propagate these changes into the database while
    running the migration. Execute the following command to create the migration scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get an output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Migration scripts will be created in a folder named `migrations` in the application
    folder. Next, migrate all the models into the database using the `migrate` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing this command, we have successfully created the database tables
    defined in the `reviews` app. You may use DB Browser for SQLite to explore the
    tables you have just created after the migration. To do so, open DB Browser for
    SQLite, click the `Open` `Database` button (*Figure 2.17*), and navigate to your
    project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17: Click the Open Database button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_02_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.17: Click the Open Database button'
  prefs: []
  type: TYPE_NORMAL
- en: Select the database file named `db.sqlite3` to open it (*Figure 2.18*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.18: Locating db.sqlite3 in the bookr directory'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_02_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.18: Locating db.sqlite3 in the bookr directory'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now be able to browse the new sets of tables created. The following
    figure shows the database tables defined in the `reviews` app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19: Database tables as defined in the reviews app'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_02_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.19: Database tables as defined in the reviews app'
  prefs: []
  type: TYPE_NORMAL
- en: Django's Database CRUD Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have created the necessary database tables for the book review application,
    let's work on understanding the basic database operations with Django.
  prefs: []
  type: TYPE_NORMAL
- en: We've already briefly touched on database operations using SQL statements in
    the section titled *SQL CRUD Operations*. We tried creating an entry into the
    database using the `Insert` statement, read from the database using the `select`
    statement, updated an entry using the `update` statement, and deleted an entry
    from the database using the `delete` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Django's ORM provides the same functionality without having to deal with the
    SQL statements. Django's database operations are simple Python code, hence we
    overcome the hassle of maintaining SQL statements among the Python code. Let's
    take a look at how these are performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute the CRUD operations, we will enter Django''s command-line shell
    by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, we will designate Django shell commands using the `>>>` notation
    (highlighted) at the start of the code block. While pasting the query into DB
    Browser, make sure you exclude this notation every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the interactive console starts, it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 2.02: Creating an Entry in the Bookr Database'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create a new entry in the database by saving a model
    instance. In other words, you will create an entry in a database table without
    explicitly running a SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the `Publisher` class/model from `reviews.models`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an object or an instance of the `Publisher` class by passing all the
    field values (name, website, and email) required by the `Publisher` model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, to write the object into the database, it is important to call the `save()`
    method, because until this is called there will not be an entry created in the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you can see a new entry created in the database using DB Browser:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.20: Entry created in the database'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_02_20.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 2.20: Entry created in the database'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the object attributes to make any further changes to the object and save
    the changes to the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can see the changes using DB Browser as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.21: Entry with the updated email field'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_02_21.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 2.21: Entry with the updated email field'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you created an entry in the database by creating an instance
    of the model object and used the `save()` method to write the model object into
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: Note that by following the preceding method, the changes to the class instance
    are not saved until the `save()` method is called. However, if we use the `create()`
    method, Django saves the changes to the database in a single step. We'll use this
    method in the exercise that follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.03: Using the create() Method to Create an Entry'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, you will create a record in the `contributor` table using the `create()`
    method in a single step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the Contributor class as before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Invoke the `create()` method to create an object in the database in a single
    step. Ensure that you pass all the required parameters (f`irst_names, last_names`,
    and `email`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use DB Browser to verify that the contributor record has been created in the
    database. If your DB Browser is not already open, open the database file `db.sqlite3`
    as we just did in the previous section. Click `Browse Data` and select the desired
    table – in this case, the `reviews_contributor` table from the `Table` dropdown,
    as shown in the screenshot – and verify the newly created database record:![Figure
    2.22: Verifying the creation of the record in DB Browser'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15509_02_22.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 2.22: Verifying the creation of the record in DB Browser'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we learned that using the `create()` method, we can create
    a record for a model in a database in a single step.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Object with a Foreign Key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to how we created a record in the `Publisher` and `Contributor` tables,
    let's now create one for the `Book` table. If you recall, the `Book` model has
    a foreign key to `Publisher` that cannot have a null value. So, a way to populate
    the publisher's foreign key is by providing the created `publisher` object in
    the book's `publisher` field as shown in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.04: Creating Records for a Many-to-One Relationship'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create a record in the `Book` table including a
    foreign key to the `Publisher` model. As you already know, the relationship between
    `Book` and `Publisher` is a many-to-one relationship, so you have to first fetch
    the `Publisher` object and then use it while creating the book record:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the `Publisher` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Retrieve the `publisher` object from the database using the following command.
    The `get()` method is used to retrieve an object from the database. We still haven''t
    explored database read operations. For now, use the following command; we will
    go deeper into database read/retrieve in the next section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When creating a book, we need to supply a `date` object as publication_date
    is a date field in the `Book` model. So, import `date` from datetime so that a
    date object can be supplied when creating the `book` object as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `create()` method to create a record of the book in the database. Ensure
    that you pass all the fields, namely `title`, `publication_ date`, `isbn`, and
    the `publisher` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that since `publisher` is a foreign key and it is not nullable (cannot
    hold a `null` value), it is mandatory to pass a `publisher` object. When the mandatory
    foreign key object publisher is not provided, the database will throw an integrity error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Figure 2.23* shows the `Book` table where the first entry is created. Notice
    that the foreign key field (`publisher_id` ) points to the `Publisher` table.
    The entry `publisher_id` in the book''s record is pointing to a `Publisher` record
    that has `id` (primary key) `1` as shown in the following two screenshots:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.23: Foreign key pointing to the primary key for reviews_book'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15509_02_23.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 2.23: Foreign key pointing to the primary key for reviews_book'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.24: Foreign key pointing to the primary key for reviews_publisher'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15509_02_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.24: Foreign key pointing to the primary key for reviews_publisher'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we learned that while creating a database record, an object
    can be assigned to a field if it is a foreign key. We know that the `Book` model
    also has a many-to-many relationship with the Contributor model. Let's now explore
    the ways to establish many-to-many relations as we create records in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.05: Creating Records with Many-to-Many Relationships'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create a many-to-many relationship between `Book`
    and `Contributor` using the relationship model `BookContributor`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you have restarted the shell and lost the `publisher` and the `book`
    objects, retrieve them from the database by using the following set of Python statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The way to establish a many-to-many relationship is by storing the information
    about the relationship in the intermediary model or the relationship model; in
    this case, it is `BookContributor`. Since we have already fetched the book and
    the contributor records from the database, let''s use these objects while creating
    a record for the `BookContributor` relationship model. To do so, first, create
    an instance of the `BookContributor` relationship class and then save the object
    to the database. While doing so, ensure you pass the required fields, namely the
    `book` object, `contributor` object, and `role`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we specified the role as `AUTHOR` while creating the `book_contributor`
    object. This is a classic example of storing relationship data while establishing
    a many-to-many relationship. The role can be `AUTHOR`, `CO_AUTHOR`, or `EDITOR`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This established the relationship between the book *Advanced Deep Learning with
    Keras* and the contributor Rowel (Rowel being the author of the book).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, we established a many-to-many relationship between `Book`
    and `Contributor` using the `BookContributor` relationship model. With regards
    to the verification of the many-to-many relationship that we just created, we
    will see this in detail in a few exercises later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.06: A Many-to-Many Relationship Using the add() Method'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will establish a many-to-many relationship using the
    `add()` method. When we don''t use the relationship to create the objects, we
    can use `through_default` to pass in a dictionary with the parameters defining
    the required fields. Continuing from the previous exercise, let''s add one more
    contributor to the book titled *Advanced Deep Learning with Keras*. This time,
    the contributor is an editor of the book:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have restarted the shell, run the following two commands to import and
    fetch the desired book instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `create()` method to create a contributor as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the newly created contributor to the book using the `add()` method. Ensure
    you provide the relationship parameter `role` as `dict`. Enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Thus, we used the `add()` method to establish a many-to-many relationship between
    the book and contributor while storing the relationship data role as `Editor`.
    Let's now take a look at other ways of doing this.
  prefs: []
  type: TYPE_NORMAL
- en: Using create() and set() Methods for Many-to-Many Relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assume the book *Advanced Deep Learning with Keras* has a total of two editors.
    Let''s use the following method to add another editor to the book. If the contributor
    is not already present in the database, then we can use the `create()` method
    to simultaneously create an entry as well as to establish the relation with the
    book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can also use the `set()` method to add a list of contributors
    for a book. Let''s create a publisher, a set of two contributors who are the co-authors,
    and a `book` object. First, import the `Publisher` model, if not already imported,
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will help us do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is a many-to-many relationship, we can add a list of objects in
    just one go, using the `set()` method. We can use through_defaults to specify
    the role of the contributors; in this case, they are co-authors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Read Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Django provides us with methods that allow us to read/retrieve from the database.
    We can retrieve a single object from the database using the `get()` method. We
    have already created a few records in the previous sections, so let's use the
    `get()` method to retrieve an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.07: Using the get() Method to Retrieve an Object'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will retrieve an object from the database using the `get()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fetch a `Publisher` object that has a `name` field with the value `Pocket Books`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Re-enter the retrieved `publisher` object and press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the output is displayed in the shell. This is called a string representation
    of an object. It is the result of adding the model method `__str__()` as we did
    in the *Model Methods* section for the `Publisher` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Upon retrieving the object, you have access to all the object''s attributes.
    Since this is a Python object, the attributes of the object can be accessed by
    using `.` followed by the attribute name. So, you can retrieve the publisher''s
    name with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, retrieve the publisher''s website:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The publisher''s email address can be retrieved as well:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we learned how to fetch a single object using the `get()`
    method. There are several disadvantages to using this method, though. Let's find
    out why.
  prefs: []
  type: TYPE_NORMAL
- en: Returning an Object Using the get() Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to note that the `get()` method can only fetch one object. If
    there is another object carrying the same value as the field mentioned, then we
    can expect a *"returned more than one"* error message. For example, if there are
    two entries in the `Publisher` table with the same value for the name field, we
    can expect an error. In such cases, there are alternate ways to retrieve those
    objects, which we will be exploring in the subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also get a *"matching query does not exist"* error message when there
    are no objects returned from the `get()` query. The `get()` method can be used
    with any of the object''s fields to retrieve a record. In the following case,
    we are using the `website` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'After retrieving the object, we can still get the publisher''s name, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to retrieve an object is by using its primary key – `pk`, as can
    be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Using pk for the primary key is a more generic way of using the primary key
    field. But for the `Publisher` table, since we know that `id` is the primary key,
    we can simply use the field name `id` to create our `get()` query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For `Publisher` and all the other tables, the primary key is `id`, which was
    automatically created by Django. This happens when a primary key field is not
    mentioned at the time of the creation of the table. But there can be instances
    where a field can be explicitly declared as a primary key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.08: Using the all() Method to Retrieve a Set of Objects'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the `all()` method to retrieve a set of objects. In this exercise,
    you will use this method to retrieve the names of all contributors:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to retrieve all the objects from the `Contributor` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Upon execution, you will get a `QuerySet` of all the objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can use list indexing to look up a specific object or to iterate over the
    list using a loop to do any other operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since `Contributor` is a list of objects, you can use indexing to access any
    element in the list as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this case, the first element in the list is a contributor with a `first_names`
    value of `''Rowel''` and a `last_names` value of `''Atienza''`, as you can see
    from the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we learned how to retrieve all the objects using the `all()`
    method and we also learned how to use the retrieved set of objects as a list.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving Objects by Filtering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we have more than one object for a field value, then we cannot use the `get()`
    method since the `get()` method can return only one object. For such cases, we
    have the `filter()` method, which can retrieve all the objects that match a specified condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.09: Using the filter() Method to Retrieve Objects'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will use the `filter()` method to get a specific set
    of objects for a certain condition. Specifically, you will retrieve all the contributors''
    names who have their first name as `Peter`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create two more contributors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To retrieve those contributors who have the value of `first_names` as `Peter`,
    add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `filter()` method returns the object even if there is only one. You can
    see this here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Furthermore, the `filter()` method returns an empty `QuerySet` if there is
    none matching the query. This can be seen here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we saw the use of filters to retrieve a set of a few objects
    filtered by a certain condition.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering by Field Lookups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s suppose we want to filter and query a set of objects using the
    object''s fields by providing certain conditions. In such a case, we can use what
    is called a double-underscore lookup. For example, the `Book` object has a field
    named `publication_date`; let''s say we want to filter and fetch all the books
    that were published after 01-01-2014\. We can easily look these up by using the
    double-underscore method. To do this, we will first import the `Book` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `publication_date__gt` indicates the publication date, which is greater
    than (`gt`) a certain specified date – in this case, 01-01-2014\. Similar to this,
    we have the following abbreviations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lt`: Less than'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lte`: Less than or equal to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gte`: Greater than or equal to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The result after filtering can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the publication date of the book that is part of the query set, which
    confirms that the publication date was after 01-01-2014:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Using Pattern Matching for Filtering Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For filtered results, we can also look up whether the parameter contains a
    part of the string we are looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `title__contains` looks for all those objects with titles containing
    `''Deep learning''` as a part of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we can use `icontains` if the string match needs to be case-insensitive.
    Using `startswith` matches any string starting with the specified string.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving Objects by Excluding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we learned about fetching a set of objects by matching
    a certain condition. Now, suppose we want to do the opposite; that is, we want
    to fetch all those objects that do not match a certain condition. In such cases,
    we can use the `exclude()` method to exclude a certain condition and fetch all
    the required objects. This will be clearer with an example. The following is a
    list of all contributors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, from this list, we will exclude all those contributors who have the value
    of `first_names` as `Peter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We see here that the query returned all those contributors whose first name
    is not Peter.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving Objects Using the order_by() Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can retrieve a list of objects while ordering by a specified field, using
    the `order_by()` method. For example, in the following code snippet, we order
    the books by their publication date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s examine the order of the query. Since the query set is a list, we can
    use indexing to check the publication date of each book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the publication date of the first book with index `0` is older
    than the publication date of the second book with index `1`. So, this confirms
    that the queried list of books has been properly ordered as per their publication
    dates. We can also use a prefix with the negative sign for the field parameter
    to order results in descending order. This can be seen from the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have prefixed a negative sign to the publication date, notice that
    the queried set of books has now been returned in the opposite order, where the
    first book object with index `0` has a more recent date than the second book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also order by using a string field or a numerical. For example, the
    following code can be used to order books by their primary key or `id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The queried set of books has been ordered as per book `id` in ascending order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, to order in descending order, the negative sign can be used as a prefix,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the queried set of books has been ordered per book `id` in descending
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'To order by a string field in alphabetical order, we can do something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have used the title of the book to order by, the query set has been
    ordered in alphabetical order. We can see this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to what we''ve seen for the previous ordering types, the negative sign
    prefix can help us sort in reverse alphabetical order, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'This will lead to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Yet another useful method offered by Django is `values()`. It helps us get
    a query set of dictionaries instead of objects. In the following code snippet,
    we''re using this for a `Publisher` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Querying Across Relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have studied in this chapter, the `reviews` app has two kinds of relationships
    – many-to-one and many-to-many. So far, we have learned various ways of making
    queries using `get()`, filters, field lookups, and so on. Now let's study how
    to perform queries across relationships. There are several ways to go about this
    – we could use foreign keys, object instances, and more. Let's explore these with
    the help of some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Querying Using Foreign Keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we have relationships across two models/tables, Django provides a way
    to perform a query using the relationship. The command shown in this section will
    retrieve all the books published by `Packt Publishing` by performing a query using
    model relationships. Similar to what we''ve seen previously, this is done using
    the double-underscore lookup. For example, the `Book` model has a foreign key
    of `publisher` pointing to the `Publisher` model. Using this foreign key, we can
    perform a query using double underscores and the field `name` in the `Publisher`
    model. This can be seen from the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Querying Using Model Name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way of querying is where we can use a relationship to do the query
    backward, using the model name in lowercase. For instance, let''s say we want
    to query the publisher who published the book *Advanced Deep Learning with Keras*
    using model relationships in the query. For this, we can execute the following
    statement to retrieve the `Publisher` information object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Here, `book` is the model name in lowercase. As we already know, the `Book`
    model has a `publisher` foreign key with the value of `name` as Packt Publishing.
  prefs: []
  type: TYPE_NORMAL
- en: Querying Across Foreign Key Relationships Using the Object Instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also retrieve the information using the object''s foreign key. Suppose
    we want to query the publisher''s name for the title *The Talisman*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the object here is an example where we use the reverse direction to get
    all the books published by a publisher by using the `set.all()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create queries using chains of queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Let's perform some more exercises to shore up our knowledge of the various kinds
    of queries we have learned about so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.10: Querying Across a Many-to-Many Relationship Using Field Lookup'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We know that `Book` and `Contributor` have a many-to-many relationship. In
    this exercise, without creating an object, you will perform a query to retrieve
    all the contributors who contributed to writing the book titled *The Talisman*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the `Contributor` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the following code to query for the set of contributors on *The Talisman*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From the preceding output, we can see that Stephen and Peter are the contributors
    who contributed to writing the book *The Talisman*. The query uses the `book`
    model (written in lowercase) and does a field lookup for the `title` field using
    the double underscore as shown in the command.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we learned how to perform queries across many-to-many relationships
    using field lookup. Let's now look at using another method to carry out the same
    task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.11: A Many-to-Many Query Using Objects'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, using a `Book` object, search for all the contributors who
    contributed to writing the book with the title *The Talisman*. The following steps
    will help you do that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the Book model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Retrieve a book object with the title *The Talisman*, by adding the following
    line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then retrieve all the contributors who worked on the book The Talisman using
    the `book` object. Add the following code to do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, we can see that Stephen and Peter are the contributors who worked on
    the book *The Talisman*. Since the book has a many-to-many relationship with contributors,
    we have used the `contributors.all()` method to get a query set of all those contributors
    who worked on the book. Now, let's try using the `set` method to perform a similar
    task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.12: A Many-to-Many Query Using the set() Method'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will use a `contributor` object to fetch all the books
    written by the contributor named `Rowel`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `Contributor` model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fetch a `contributor` object whose `first_names` is `''Rowel''` using the `get()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the `contributor` object and the `book_set()` method, get all those books
    written by the contributor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since `Book` and `Contributor` have a many-to-many relationship, we can use
    the `set()` method to query a set of objects associated with the model. In this
    case, `contributor.book_set.all()` returned all the books written by the contributor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.13: Using the update() Method'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will use the `update()` method to update an existing
    record:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change `first_names` for a contributor who has the last name `Tyrrell`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The return value shows the number of records that have been updated. In this
    case, one record has been updated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Fetch the contributor that was just modified using the `get()` method and verify
    that the first name has been changed to `Mike`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the filter operation has more than one record, then the `update()` method
    will update the specified field in all the records returned by the filter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, we learned how to use the `update()` method to update a record
    in the database. Now, finally, let's try deleting a record from the database using
    the `delete()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.14: Using the delete() Method'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An existing record in the database can be deleted using the `delete()` method.
    In this exercise, you will delete a record from the `contributors` table that
    has the value of `last_name` as `Wharton`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fetch the object using the `get` method and use the `delete` method as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that you called the `delete()` method without assigning the `contributor`
    object to a variable. Since the `get()` method returns a single object, you can
    access the object's method without actually creating a variable for it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify the `contributor` object with `last_name` as `''Wharton''` has been deleted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see upon running the query, we got an *object does not exist* error.
    This is expected since the record has been deleted. In this exercise, we learned
    how to use the `delete` method to delete a record from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2.01: Create Models for a Project Management Application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine you are developing a project management application called `Juggler`.
    Juggler is an application that can track multiple projects, and each project can
    have multiple tasks associated with it. The following steps will help you complete
    this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the techniques we have learned so far, create a Django project called `juggler`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Django app called `projectp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the app projects in the `juggler/settings.py` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two related model classes called `Project` and `Task` in `projectp/models.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create migration scripts and migrate the models' definitions to the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Django shell now and import the models.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Populate the database with an example and write a query displaying the list
    of tasks associated with a given project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [http://packt.live/2Nh1NTJ](http://packt.live/2Nh1NTJ).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Populating the Bookr Project's Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although we know how to create database records for the project, in the next
    few chapters, we will have to create a lot of records to work with the project.
    For that reason, we have created a script that can make things easy for us. This
    script populates the database by reading a **.csv** (**Comma-Separated Values**)
    file consisting of many records. Follow the next few steps to populate the project''s
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following folder structure inside the project directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Copy the `loadcsv.py` file from the following location and `WebDevWithDjangoData.csv`
    into the folder created. This can be found on the GitHub repository for this book
    at [http://packt.live/3pvbCLM](http://packt.live/3pvbCLM).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Because `loadcsv.py` is placed inside the `management/commands` folder, now
    it works like a Django custom management command. You can go through the `loadcsv.py`
    file and read more about writing Django custom management commands at this link:
    [https://docs.djangoproject.com/en/3.0/howto/custom-management-commands/.](https://docs.djangoproject.com/en/3.0/howto/custom-management-commands/.)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s recreate a fresh database. Delete your SQL database file present
    in the project folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create a fresh database again, execute the Django `migrate` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now you can see the newly created `db.sqlite3` file under the `reviews` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Execute the custom management command `loadcsv` to populate the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using DB Browser for SQLite, verify that all the tables created by the `bookr`
    project are populated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about some basic database concepts and their importance
    in application development. We used a free database visualization tool, DB Browser
    for SQLite, to understand what database tables and fields are, how records are
    stored in a database, and further performed some basic CRUD operations on the
    database using simple SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: We then learned how Django provides a valuable abstraction layer called ORM
    that helps us interact seamlessly with relational databases using simple Python
    code, without having to compose SQL commands. As a part of ORM, we learned about
    Django models, migrations, and how they help propagate the changes to the Django
    models in the database.
  prefs: []
  type: TYPE_NORMAL
- en: We shored up our knowledge of databases by learning about database relationships,
    and their key types, in relational databases. We also worked with the Django shell,
    where we used Python code to perform the same CRUD queries we performed earlier
    using SQL. Later, we learned how to retrieve our data in a more refined manner
    using pattern matching and field lookups. As we learned these concepts, we made
    considerable progress on our Bookr application as well. We created models for
    our `reviews` app and gained all the skills we need to interact with the data
    stored inside the app's database. In the next chapter, we will learn how to create
    Django views, URL routing, and templates.
  prefs: []
  type: TYPE_NORMAL
