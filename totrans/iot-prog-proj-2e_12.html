<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer249">
<h1 class="chapter-number" id="_idParaDest-193"><a id="_idTextAnchor195"/>12</h1>
<h1 id="_idParaDest-194"><a id="_idTextAnchor196"/>Creating an IoT Joystick</h1>
<p>In this chapter, we will create an IoT joystick for remotely controlling a ROS TurtleSim robot. We will build upon our experience from <a href="B21282_07.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>’s IoT button project as well as <a href="B21282_11.xhtml#_idTextAnchor173"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>’s introduction to the TurtleSim <span class="No-Break">virtual robot.</span></p>
<p>Utilizing the Raspberry Pi Pico WH’s Wi-Fi capabilities, we will demonstrate the practical application of IoT in robotics. The chapter outlines the design and construction of a USB-powered joystick, integrating components such as a PS2 joystick module, an LED, and an arcade button. We will use this IoT joystick to control our A.R.E.S. robot in the <span class="No-Break">coming chapters.</span></p>
<p>We will use a Raspberry Pi Pico WH for this chapter, although a Raspberry Pi Pico W would work just <span class="No-Break">as well.</span></p>
<p>We will cover the following topics in <span class="No-Break">this chapter:</span></p>
<ul>
<li>Understanding our IoT <span class="No-Break">joystick application</span></li>
<li>Wiring up <span class="No-Break">our circuit</span></li>
<li>Developing the code for our <span class="No-Break">IoT joystick</span></li>
<li>Creating a custom ROS node for <span class="No-Break">our application</span></li>
<li>Constructing the IoT <span class="No-Break">joystick case</span></li>
</ul>
<p><span class="No-Break">Let’s begin!</span></p>
<h1 id="_idParaDest-195"><a id="_idTextAnchor197"/>Technical requirements</h1>
<p>In this chapter, you will require <span class="No-Break">the following:</span></p>
<ul>
<li>Intermediate knowledge of <span class="No-Break">Python programming</span></li>
<li>Basic knowledge of the Linux <span class="No-Break">command line.</span></li>
<li>A CloudAMQP account for the MQTT <span class="No-Break">server instance</span></li>
<li>Ubuntu-ROS installed computer from the <span class="No-Break">previous chapter</span></li>
<li>Access to a 3D printer or 3D <span class="No-Break">printing service</span></li>
<li>Raspberry Pi <span class="No-Break">Pico WH</span></li>
<li>Raspberry Pi Pico WH <span class="No-Break">GPIO expander</span></li>
<li>PS2 <span class="No-Break">joystick module</span></li>
<li>LED with 220 <span class="No-Break">Ohm resistor</span></li>
<li>24 mm <span class="No-Break">arcade-style pushbutton</span></li>
<li>4 x M3 10 <span class="No-Break">mm bolts</span></li>
<li>4 x M2 5 <span class="No-Break">mm screws</span></li>
<li>8 x M2.5 5 <span class="No-Break">mm bolts</span></li>
<li>4 x M2.5 10 <span class="No-Break">mm standoffs</span></li>
<li>1 x 8 mm <span class="No-Break">LED holder</span></li>
<li>Wires to connect Raspberry Pi Pico WH to <span class="No-Break">GPIO expander</span></li>
<li>Build files for custom cases may be found in our <span class="No-Break">GitHub repository</span></li>
</ul>
<p>The code for this chapter may be <span class="No-Break">found here:</span></p>
<p><a href="https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter12%0D"><span class="No-Break">https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter12</span></a></p>
<h1 id="_idParaDest-196"><a id="_idTextAnchor198"/>Understanding our IoT joystick application</h1>
<p>In <a href="B21282_07.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, we developed a device to remotely arm an IoT alarm system. Building on this experience, our <a id="_idIndexMarker912"/>application in this chapter involves creating an IoT joystick using a Raspberry Pi Pico WH. This joystick will remotely control a ROS TurtleSim robot and thus display a practical application of IoT <span class="No-Break">in robotics.</span></p>
<p>We will use the Raspberry Pi Pico WH for our design given Wi-Fi capability and pre-soldered pin headers. In our application, we’ll integrate a PS2 joystick module, an LED, and an arcade-style pushbutton with a Raspberry Pi Pico WH. The Raspberry Pi Pico WH will be programmed to transmit MQTT messages that reflect the joystick’s movements, the status of the joystick button, and the arcade button’s state. Additionally, the LED will serve a dual-purpose role, indicating both the Wi-Fi connectivity status and the MQTT connection <span class="No-Break">status sequentially:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer237">
<img alt="Figure 12.1 – Overview of the IoT joystick application" height="428" src="image/B21282_12_1.jpg" width="1132"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Overview of the IoT joystick application</p>
<p>As we see in <span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.1</em>, our Raspberry Pi Pico WH transmits the state of the <em class="italic">x</em> axis, <em class="italic">y </em>axis, and two <a id="_idIndexMarker913"/>buttons as an MQTT message under the <strong class="source-inline">JoystickPosition</strong> topic to our <strong class="source-inline">robot_control</strong> custom ROS node. Our ROS node then in turn transmits <strong class="source-inline">vel_msg</strong> messages to an instance of a <span class="No-Break">TurtleSim robot.</span></p>
<p>We will start by wiring up the circuit for our <span class="No-Break">IoT joystick.</span></p>
<h1 id="_idParaDest-197"><a id="_idTextAnchor199"/>Wiring up our circuit</h1>
<p>To simplify wiring, we’re using a GPIO expander along with our Raspberry Pi Pico WH. The case that <a id="_idIndexMarker914"/>we will build later allows for easy transfer of the test circuit wiring, highlighting the practicality of using a GPIO expander. We can see the components that make up the IoT joystick in the <span class="No-Break">following figure:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer238">
<img alt="Figure 12.2 – Components of the IoT joystick" height="595" src="image/B21282_12_2.jpg" width="759"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Components of the IoT joystick</p>
<p>In <span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.2</em>, the components <a id="_idIndexMarker915"/>we are using include a 24 mm arcade-style button, a green LED (any color will do) soldered to a 220 Ohm resistor (refer to <a href="B21282_03.xhtml#_idTextAnchor048"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> for directions on this), and a PS2 <span class="No-Break">joystick module.</span></p>
<p>This setup makes it easier to transfer our components to a custom case for final installation. Using these components, we wire up our circuit using <span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.3</em> as <span class="No-Break">a reference:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer239">
<img alt="Figure 12.3 – Wiring up the IoT joystick" height="742" src="image/B21282_12_3.jpg" width="778"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Wiring up the IoT joystick</p>
<p>The connections <a id="_idIndexMarker916"/>are <span class="No-Break">as follows:</span></p>
<ul>
<li>The arcade-style button connects to GP0 <span class="No-Break">and GND.</span></li>
<li>The positive end of the LED with a 220 Ohm resistor connects <span class="No-Break">to GP5.</span></li>
<li>The negative end of the LED connects <span class="No-Break">to GND.</span></li>
<li>SW (switch) from the PS2 joystick module connects <span class="No-Break">to GP22.</span></li>
<li>VRY (<em class="italic">y</em> axis) from the PS2 joystick module connects <span class="No-Break">to GP26.</span></li>
<li>VRX (<em class="italic">x</em> axis) from the PS2 joystick module connects <span class="No-Break">to GP27.</span></li>
<li>+5V (power) from the PS2 joystick module connects <span class="No-Break">to 3V3.</span></li>
<li>GND from the PS2 joystick module connects <span class="No-Break">to GND.</span></li>
</ul>
<p>With our <a id="_idIndexMarker917"/>circuit wired up, we are ready to start coding <span class="No-Break">our application.</span></p>
<h1 id="_idParaDest-198"><a id="_idTextAnchor200"/>Developing the code for our IoT joystick</h1>
<p>We will install CircuitPython on our Raspberry Pi Pico WH and use Thonny for development. Our <a id="_idIndexMarker918"/>Pico WH code will consist of two files, one to encapsulate the joystick functionalities and the other to transmit <span class="No-Break">MQTT messages.</span></p>
<p>We will start by setting up our Raspberry Pi Pico WH <span class="No-Break">for development.</span></p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor201"/>Setting up our Raspberry Pi Pico WH</h2>
<p>For our IoT joystick, we will install CircuitPython and use the Adafruit MiniMQTT library. We could <a id="_idIndexMarker919"/>just as easily use MicroPython and the <strong class="source-inline">micropython-umqtt.simple</strong> package. However, using CircuitPython for the Raspberry Pi Pico WH in our IoT joystick application offers more stable and well-maintained libraries compared <span class="No-Break">to MicroPython.</span></p>
<p>To install CircuitPython on our Raspberry Pi Pico WH, we do the following same steps as we did in <a href="B21282_09.xhtml#_idTextAnchor140"><span class="No-Break"><em class="italic">Chapter 9</em></span></a><span class="No-Break">:</span></p>
<ol>
<li>If Thonny is not available on our operating system, we visit the Thonny website and download an appropriate <span class="No-Break">version (</span><a href="https://thonny.org"><span class="No-Break">https://thonny.org</span></a><span class="No-Break">).</span></li>
<li>We then launch Thonny using the appropriate method for our <span class="No-Break">operating system.</span></li>
<li>While holding the <em class="italic">BOOTSEL</em> button on the Pico WH (the small white button near the USB port), we insert it into an available USB port and disregard any pop-up windows that <span class="No-Break">may appear.</span></li>
<li>We then click on the interpreter information at the bottom right-hand side of the screen and select <span class="No-Break"><strong class="bold">Install CircuitPython…</strong></span><span class="No-Break">:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer240">
<img alt="Figure 12.4 – Install CircuitPython… option" height="140" src="image/B21282_12_4.jpg" width="642"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Install CircuitPython… option</p>
<ol>
<li value="5">For our <a id="_idIndexMarker920"/>target volume, we select our Pico WH (<strong class="bold">RPI-RP2 (D:)</strong> in our example). We then select the latest version of the CircuitPython variant – <strong class="bold">Raspberry Pi • Pico W / </strong><span class="No-Break"><strong class="bold">Pico WH</strong></span><span class="No-Break">:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer241">
<img alt="Figure 12.5 – Installing CircuitPython on the Raspberry Pi Pico WH" height="428" src="image/B21282_12_5.jpg" width="471"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Installing CircuitPython on the Raspberry Pi Pico WH</p>
<ol>
<li value="6">We click on the <strong class="bold">Install</strong> button and then the <strong class="bold">Close</strong> button once the installation <span class="No-Break">has completed.</span></li>
<li>To have Thonny configured to run the CircuitPython interpreter on our Pico, we select it from the bottom right-hand side of <span class="No-Break">the screen:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer242">
<img alt="Figure 12.6 – Selecting the CircuitPython interpreter from our Pico WH" height="106" src="image/B21282_12_6.jpg" width="642"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – Selecting the CircuitPython interpreter from our Pico WH</p>
<ol>
<li value="8">With CircuitPython installed on our Raspberry Pi Pico WH, the next step is to install <a id="_idIndexMarker921"/>the Adafruit MiniMQTT library. To do so, we follow the steps outlined in <a href="B21282_10.xhtml#_idTextAnchor157"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, in the <em class="italic">Installing the CircuitPython library for </em><span class="No-Break"><em class="italic">MQTT</em></span><span class="No-Break"> section.</span></li>
</ol>
<p>With our Raspberry Pi Pico WH ready for development, it’s time to create a <span class="No-Break"><strong class="source-inline">Joystick </strong></span><span class="No-Break">class.</span></p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor202"/>Creating a Joystick class</h2>
<p>As mentioned, our Pico WH code is broken down into two files, one to encapsulate the joystick in <a id="_idIndexMarker922"/>a class we call <strong class="source-inline">Joystick</strong> and the other to send MQTT messages based on the values of this class. We start with the <span class="No-Break">joystick code.</span></p>
<p>To write the joystick code, we do <span class="No-Break">the following:</span></p>
<ol>
<li>We connect our Raspberry Pi Pico WH to a USB port and launch Thonny. We may use our Raspberry Pi or another operating system <span class="No-Break">for this.</span></li>
<li>We then activate the CircuitPython environment on our Pico WH by selecting it from the bottom right-hand side of <span class="No-Break">the screen.</span></li>
<li>In a new editor, we start our code with <span class="No-Break">the imports:</span><pre class="source-code">
import board
import digitalio
import analogio
import time</pre><p class="list-inset">In our code, we have <span class="No-Break">the following:</span></p><ul><li><strong class="source-inline">import board</strong>: Accesses the board-specific pins and hardware interfaces, crucial for interfacing with the GPIO pins on the Raspberry Pi <span class="No-Break">Pico W.</span></li><li><strong class="source-inline">import digitalio</strong>: Manages digital input and output, such as reading the state of buttons or controlling LEDs, essential for digital <span class="No-Break">signal interactions.</span></li><li><strong class="source-inline">import analogio</strong>: Facilitates analog input functionalities, such as reading sensor data that vary over a range, a common requirement in projects involving variable inputs such <span class="No-Break">as potentiometers.</span></li><li><strong class="source-inline">import time</strong>: Provides time-related functions, enabling tasks such as introducing delays in the program execution, which is useful in controlling the flow and timing <span class="No-Break">of operations.</span></li></ul></li> <li>We then <a id="_idIndexMarker923"/>define a <strong class="source-inline">Joystick</strong> class and set <span class="No-Break">the variables:</span><pre class="source-code">
class Joystick:
    def __init__(self):
        self.adc_x = analogio.AnalogIn(board.GP27)
        self.adc_y = analogio.AnalogIn(board.GP26)
        self.button = digitalio.DigitalInOut(board.GP0)
        self.button.direction = digitalio.Direction.INPUT
        self.button.pull = digitalio.Pull.UP
        self.button2 = digitalio.DigitalInOut(board.GP22)
        self.button2.direction = digitalio.Direction.INPUT
        self.button2.pull = digitalio.Pull.UP
        self.mid = 32767
        self.dead_zone = 10000</pre><p class="list-inset">In our code, we <a id="_idIndexMarker924"/>have <span class="No-Break">the following:</span></p><ul><li>Initialization (<strong class="source-inline">__init__()</strong> method): Our code sets up the <span class="No-Break"><strong class="source-inline">Joystick</strong></span><span class="No-Break"> class.</span></li><li><strong class="source-inline">self.adc_x</strong> and <strong class="source-inline">self.adc_y</strong>: These are analog input objects for the <em class="italic">x</em> and <em class="italic">y</em> axes of the joystick, connected to the GP27 and GP26 pins, respectively. They read the analog values from the <span class="No-Break">joystick’s potentiometers.</span></li><li><strong class="source-inline">self.button</strong>: A digital input/output object for a button, connected to the GP0 pin. It’s configured as an input with a pull-up resistor, which is a common setup for buttons. This variable represents the state of our <span class="No-Break">arcade-style button.</span></li><li><strong class="source-inline">self.button2</strong>: Similar to <strong class="source-inline">self.button</strong>. This represents a second button connected to the GP22 pin, also set as an input with a pull-up resistor. This variable represents the state of the joystick button (activated by pushing down on <span class="No-Break">the joystick).</span></li><li><strong class="source-inline">self.mid</strong>: The midpoint value for the analog readings, used to determine the neutral position of <span class="No-Break">the joystick.</span></li><li><strong class="source-inline">self.dead_zone</strong>: The dead zone threshold determines the joystick’s sensitivity, distinguishing slight, unintentional movements from deliberate ones. This accounts for minor variances when the joystick is in its <span class="No-Break">neutral position.</span></li></ul></li> <li>With our variables set, we write our first method, which we call <strong class="source-inline">get_binary_value()</strong>. This function is designed to interpret the joystick’s position as a binary output. It first checks if the joystick’s current position, represented by <strong class="source-inline">value</strong>, is within a predefined dead zone around the midpoint (<strong class="source-inline">self.mid</strong>). If so, it returns <strong class="source-inline">0</strong>, indicating the joystick is in a neutral position. If the joystick’s <a id="_idIndexMarker925"/>position is outside this dead zone, the function returns <strong class="source-inline">-1</strong> for positions below the midpoint (negative direction) and <strong class="source-inline">1</strong> for positions above it (<span class="No-Break">positive direction):</span><pre class="source-code">
def get_binary_value(self, value):
        if abs(value - self.mid) &lt; self.dead_zone:
            return 0
        return -1 if value &lt; self.mid else 1</pre></li> <li>We then define our second method, <strong class="source-inline">read()</strong>. This method consolidates the joystick’s and buttons’ statuses into a single output. It computes binary values for the <em class="italic">x</em> and <em class="italic">y</em> axes of the joystick using the <strong class="source-inline">get_binary_value()</strong> method, translating analog readings into binary (<strong class="source-inline">-1</strong>, <strong class="source-inline">0</strong>, or <strong class="source-inline">1</strong>) based on position. It also assesses the states of two buttons, converting their digital values into a Boolean format (pressed or not pressed). The method then returns a tuple containing these binary values and <span class="No-Break">button states:</span><pre class="source-code">
    def read(self):
        x_val = self.get_binary_value(self.adc_x.value)
        y_val = self.get_binary_value(self.adc_y.value)
        button_state = not self.button.value
        button2_state = not self.button2.value
        return x_val, y_val, button_state, button2_state</pre></li> <li>We then write our test code. We use this code to test our <strong class="source-inline">Joystick</strong> class. It initializes an instance of the <strong class="source-inline">Joystick</strong> class and enters an infinite loop to continuously test the functionality of the joystick. In each iteration of the loop, it reads the <a id="_idIndexMarker926"/>current positions of the joystick’s <em class="italic">x</em> and <em class="italic">y</em> axes and the states of the two buttons using the <strong class="source-inline">read()</strong> method. These values are then printed to the console, displaying the joystick’s <em class="italic">x</em> and <em class="italic">y</em> positions along with the press status of each button. The <strong class="source-inline">if __name__ == "__main__":</strong> block ensures that this main loop runs only if the script is executed as the main program, not when imported as a module, allowing us to easily test our <span class="No-Break"><strong class="source-inline">Joystick</strong></span><span class="No-Break"> class:</span><pre class="source-code">
if __name__ == "__main__":
    joystick = Joystick()
    while True:
        x, y, button_state, button2_state = joystick.read()
        print("X Position:", x)
        print("Y Position:", y)
        print("Button 1 Pressed:", button_state)
        print("Button 2 Pressed:", button2_state)
        time.sleep(5)</pre></li> <li>To save the file, we click on <strong class="bold">File</strong> | <strong class="bold">Save as...</strong> from the drop-down menu. We save our file as <strong class="source-inline">joystick.py</strong> to our Raspberry Pi <span class="No-Break">Pico WH.</span></li>
<li>To run <a id="_idIndexMarker927"/>our code, we click on the green <strong class="bold">Run</strong> button, hit <em class="italic">F5</em> on the keyboard, or click on the <strong class="bold">Run</strong> menu option at the top, and then <strong class="bold">Run </strong><span class="No-Break"><strong class="bold">current script</strong></span><span class="No-Break">.</span></li>
<li>In the shell, we should observe the joystick values change as we move the joystick and press <span class="No-Break">the buttons:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer243">
<img alt="Figure 12.7 – Joystick and button state" height="216" src="image/B21282_12_7.jpg" width="812"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7 – Joystick and button state</p>
<p>With our <strong class="source-inline">Joystick</strong> class and <strong class="source-inline">joystick.py</strong> file written and successfully tested, we are now ready to write the code to send out the joystick status via <span class="No-Break">MQTT messaging.</span></p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor203"/>Sending MQTT messages from our IoT joystick</h2>
<p>With the <strong class="source-inline">Joystick</strong> class created and tested, it is time to write the code to send the joystick <a id="_idIndexMarker928"/>and button status in an <span class="No-Break">MQTT message.</span></p>
<p>To write the joystick code, we do <span class="No-Break">the following:</span></p>
<ol>
<li>We connect our Raspberry Pi Pico WH to a USB port and launch Thonny. We may use our Raspberry Pi or another operating system <span class="No-Break">for this.</span></li>
<li>We then activate the CircuitPython environment on our Pico WH by selecting it from the bottom right-hand side of the screen (see <span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">).</span></li>
<li>In a new editor, we start our code with <span class="No-Break">the imports:</span><pre class="source-code">
import time
import board
import wifi
import socketpool
import digitalio
from adafruit_minimqtt.adafruit_minimqtt import MQTT
from joystick import Joystick</pre><p class="list-inset">In our <a id="_idIndexMarker929"/>code, we have <span class="No-Break">the following:</span></p><ul><li><strong class="source-inline">import time</strong>: Incorporates time-related functions, useful for delays and timing control in <span class="No-Break">the code.</span></li><li><strong class="source-inline">import board</strong>: Provides access to the hardware-specific details of the Raspberry Pi Pico WH, particularly its <span class="No-Break">GPIO pins.</span></li><li><strong class="source-inline">import wifi</strong>: Enables Wi-Fi functionality, crucial for network connectivity in <span class="No-Break">IoT applications.</span></li><li><strong class="source-inline">import socketpool</strong>: Manages network sockets, used for network communications, such as <span class="No-Break">MQTT messaging.</span></li><li><strong class="source-inline">import digitalio</strong>: Allows for digital input and output control, useful for managing LEDs, buttons, and other <span class="No-Break">digital components.</span></li><li><strong class="source-inline">from adafruit_minimqtt.adafruit_minimqtt import MQTT</strong>: Imports the Adafruit MiniMQTT library, which is used for handling MQTT protocol communication, a standard for <span class="No-Break">IoT messaging.</span></li><li><strong class="source-inline">from joystick import Joystick</strong>: Imports our custom <strong class="source-inline">Joystick</strong> class for handling the logic for interfacing with our <span class="No-Break">joystick module.</span></li></ul></li> <li>We then set our <span class="No-Break">variable declarations:</span><pre class="source-code">
WIFI_SSID = 'MySSID'
WIFI_PASSWORD = 'SSID-password'
MQTT_SERVER = "mqtt-server"
MQTT_PORT = 18756
USERNAME = "mqtt-username"
PASSWORD = "mqtt-password"
MQTT_TOPIC = "JoystickPosition"
led = digitalio.DigitalInOut(board.GP5)
led.direction = digitalio.Direction.OUTPUT</pre><p class="list-inset">In our <a id="_idIndexMarker930"/>code, we have <span class="No-Break">the following:</span></p><ul><li><strong class="source-inline">WIFI_SSID</strong> and <strong class="source-inline">WIFI_PASSWORD</strong>: These variables store the credentials for the Wi-Fi network, essential for connecting the Raspberry Pi Pico WH to <span class="No-Break">the internet.</span></li><li><strong class="source-inline">MQTT_SERVER</strong>, <strong class="source-inline">MQTT_PORT</strong>, <strong class="source-inline">USERNAME</strong>, <strong class="source-inline">PASSWORD</strong>: These settings are for configuring the MQTT client. They specify the server address, port number, and authentication credentials needed to connect to our <span class="No-Break">CloudAMQP server.</span></li><li><strong class="source-inline">MQTT_TOPIC</strong>: Defines the MQTT topic under which the messages will be published. In this case, it’s set to <strong class="source-inline">JoystickPosition</strong>, indicating that messages related to the joystick’s position will be sent to <span class="No-Break">this topic.</span></li><li><strong class="source-inline">led = digitalio.DigitalInOut(board.GP5)</strong>: Initializes a digital output on pin GP5 of the Raspberry Pi Pico W for <span class="No-Break">our LED.</span></li><li><strong class="source-inline">led.direction = digitalio.Direction.OUTPUT</strong>: Sets the direction of the pin to output, allowing our program to control the LED (for example, turning it on <span class="No-Break">or off).</span></li></ul></li> <li>We use the <strong class="source-inline">flash_led()</strong> method to turn on and off our LED to use it as a status indicator. Our method takes in times and duration values to allow for custom <a id="_idIndexMarker931"/>flashing of the LED based on a particular <span class="No-Break">program state:</span><pre class="source-code">
def flash_led(times, duration):
    for _ in range(times):
        led.value = True
        time.sleep(duration)
        led.value = False
        time.sleep(duration)</pre></li> <li>The <strong class="source-inline">connect_to_wifi()</strong> method is used to connect our Raspberry Pi Pico WH to our Wi-Fi router and the internet. This function continuously attempts to connect to Wi-Fi, using the <strong class="source-inline">WIFI_SSID</strong> and <strong class="source-inline">WIFI_PASSWORD</strong> credentials. On failure, it prints an error message, flashes an LED, and retries after a <span class="No-Break">3-second pause:</span><pre class="source-code">
def connect_to_wifi():
    while True:
        try:
            print("Trying to connect to WiFi...")
            wifi.radio.connect(WIFI_SSID, WIFI_PASSWORD)
            print("Connected to Wi-Fi!")
            break
        except Exception as e:
            print("Failed to connect to WiFi. Retrying...")
            flash_led(1, 2)
            time.sleep(3)</pre></li> <li>The <strong class="source-inline">connect_to_mqtt()</strong> function attempts to establish a connection to the MQTT server in a loop. If the connection is successful, it prints a confirmation message <a id="_idIndexMarker932"/>and exits the loop. In case of a connection failure, it reports the failure, activates a half-second LED flash as an error indicator, and then waits for 3 seconds <span class="No-Break">before retrying:</span><pre class="source-code">
def connect_to_mqtt(mqtt_client):
    while True:
        try:
            print("Trying to connect to MQTT Broker...")
            mqtt_client.connect()
            print("Connected to MQTT server!")
            break
        except Exception as e:
            print("Failed to connect to MQTT. Retrying...")
            flash_led(1, 0.5)
            time.sleep(3)</pre></li> <li>Our code then calls <strong class="source-inline">connect_to_wifi()</strong> to establish a Wi-Fi connection. Next, a socket pool is created from <strong class="source-inline">wifi.radio</strong> to manage network communication. An MQTT client is then instantiated with the specified server, port, and user credentials and connected to the MQTT broker using <strong class="source-inline">connect_to_mqtt(mqtt_client)</strong>. After establishing an MQTT connection, the LED is set to a steady on state (<strong class="source-inline">led.value = True</strong>) as an indicator of <a id="_idIndexMarker933"/>successful setup. Finally, an instance of the <strong class="source-inline">Joystick</strong> class is created, readying it for capturing <span class="No-Break">user inputs:</span><pre class="source-code">
connect_to_wifi()
pool = socketpool.SocketPool(wifi.radio)
mqtt_client = MQTT(broker=MQTT_SERVER, port=MQTT_PORT,
username=USERNAME,
password=PASSWORD,
socket_pool=pool)
connect_to_mqtt(mqtt_client)
led.value = True
joystick = Joystick()</pre></li> <li>The <strong class="source-inline">send_mqtt_message()</strong> function in the code is responsible for formatting and sending joystick data over MQTT. It accepts the joystick’s <em class="italic">x</em> and <em class="italic">y</em> axes’ values and the states of two buttons. The states of the buttons are converted to <strong class="source-inline">True</strong> or <strong class="source-inline">False</strong> based on whether they are pressed. The function then constructs a message string that includes the <em class="italic">x</em> and <em class="italic">y</em> positions and the states of both buttons. This message is published to the MQTT topic defined by <strong class="source-inline">MQTT_TOPIC</strong>, allowing the joystick’s status to be transmitted via the <span class="No-Break">MQTT protocol:</span><pre class="source-code">
def send_mqtt_message(x, y, button1, button2):
    button1_state = True if button1 else False
    button2_state = True if button2 else False
    message = f'X: {x}, Y: {y}, Button 1: \
              {button1_state}, Button 2: {button2_state}'
    mqtt_client.publish(MQTT_TOPIC, message)</pre></li> <li>The <strong class="source-inline">main()</strong> function in the code represents the primary loop for reading joystick inputs and sending corresponding MQTT messages. Within an infinite loop, it continually calls the <strong class="source-inline">joystick.read()</strong> method to get the current positions <a id="_idIndexMarker934"/>of the joystick’s <em class="italic">x</em> and <em class="italic">y</em> axes and the states of two buttons. It then passes these values to the <strong class="source-inline">send_mqtt_message()</strong> function to format and transmit them as MQTT messages. A 1-second delay (<strong class="source-inline">time.sleep(1)</strong>) is included at the end of each loop iteration to manage the frequency of MQTT transmissions. The <strong class="source-inline">if __name__ == "__main__":</strong> block ensures that this main loop runs only if the script is executed as the main program, not when imported as <span class="No-Break">a module:</span><pre class="source-code">
def main():
    while True:
        x, y, button1_pressed, button2_pressed = joystick.read()
        send_mqtt_message(x, y, button1_pressed, button2_pressed)
        time.sleep(1)
if __name__ == "__main__":
    main()</pre></li> <li>To save the file, we click on <strong class="bold">File</strong> | <strong class="bold">Save as...</strong> from the drop-down menu. We save our file as <strong class="source-inline">code.py</strong> to our Raspberry Pi <span class="No-Break">Pico WH.</span></li>
<li>To run our code, we click on the green <strong class="bold">Run</strong> button, hit <em class="italic">F5</em> on the keyboard, or click on the <strong class="bold">Run</strong> menu option at the top, and then <strong class="bold">Run </strong><span class="No-Break"><strong class="bold">current script</strong></span><span class="No-Break">.</span></li>
<li>To test our code, we connect the MQTT-Explorer app to our CloudAMQP server and observe the <span class="No-Break">messages received.</span></li>
<li>We should <a id="_idIndexMarker935"/>observe outputs as three distinct values: <strong class="source-inline">1</strong>, <strong class="source-inline">0</strong>, and <strong class="source-inline">-1</strong>, indicating their neutral, positive, and negative positions respectively. Additionally, we should see the state of two buttons (<strong class="source-inline">True</strong> or <strong class="source-inline">False</strong>): <strong class="source-inline">Button 1</strong> corresponds to the arcade-style button, and <strong class="source-inline">Button 2</strong> indicates the joystick’s <span class="No-Break">click action.</span></li>
</ol>
<p>With the code completed for our IoT joystick, it is time to create our custom <strong class="source-inline">robot_control</strong> ROS node so that we may control the <span class="No-Break">TurtleSim robot.</span></p>
<h1 id="_idParaDest-202"><a id="_idTextAnchor204"/>Creating a custom ROS node for our application</h1>
<p>In <a href="B21282_11.xhtml#_idTextAnchor173"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>’s <em class="italic">Creating an ROS workspace and package</em> section, we outlined how to set up a <strong class="source-inline">circle</strong> node for TurtleSim robot control. Following this blueprint, we’ll now create a <strong class="source-inline">robot_control</strong> node on the ROS-equipped Ubuntu system from <a href="B21282_11.xhtml#_idTextAnchor173"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>. This involves <a id="_idIndexMarker936"/>setting up a new ROS workspace and package for the <strong class="source-inline">robot_control</strong> node, enabling us to control the TurtleSim robot using our new <span class="No-Break">IoT joystick.</span></p>
<p>To ensure clarity and avoid any potential mix-up with the existing <strong class="source-inline">circle</strong> node, we’ll create a new workspace and package for the <strong class="source-inline">robot_control</strong> node, despite the possibility of reusing those from <a href="B21282_11.xhtml#_idTextAnchor173"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>. This approach allows us to maintain distinct environments for <span class="No-Break">each project.</span></p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor205"/>Creating our custom robot_control node</h2>
<p>As we <a id="_idIndexMarker937"/>have already installed the <strong class="source-inline">paho-mqtt</strong> Python library onto our Ubuntu installation, we will not need to install <span class="No-Break">it again.</span></p>
<p>To create <a id="_idIndexMarker938"/>our new node, we do <span class="No-Break">the following:</span></p>
<ol>
<li>We open an Ubuntu Terminal and execute the following command in our <span class="No-Break">home directory:</span><pre class="source-code">
<strong class="bold">mkdir -p ch12_ws/src</strong></pre></li> <li>With the folder created, we navigate to the <strong class="source-inline">src</strong> folder with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">cd ch12_ws/src</strong></pre></li> <li>To initialize the ROS environment, we execute the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">source /opt/ros/humble/setup.bash</strong></pre></li> <li>We then create our package by executing the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">ros2 pkg create --build-type ament_python --license Apache-2.0 --node-name robot_control mqtt_robot</strong>
<strong class="bold">--license Apache-2.0</strong></pre></li> <li>With this line, we created a new package named <strong class="source-inline">mqtt_robot</strong> with the Python build type and generated a node named <strong class="source-inline">robot_control</strong>. This will give us a Python script named <strong class="source-inline">robot_control.py</strong>. To navigate to the folder that contains this script, we enter the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">cd ~/ch11_ws/src/mqtt_robot/mqtt_robot</strong></pre></li> <li>To open the <strong class="source-inline">robot_control.py</strong> file in a text editor, we execute the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">gedit robot_control.py</strong></pre></li> <li>We start by deleting all the code. We then start our new code <span class="No-Break">with imports:</span><pre class="source-code">
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
import paho.mqtt.client as mqtt</pre><p class="list-inset">In our <a id="_idIndexMarker939"/>code, we have <span class="No-Break">the following:</span></p><ul><li><strong class="source-inline">import rclpy</strong>: Imports the ROS 2 client library for Python, allowing the script to <a id="_idIndexMarker940"/>interact with ROS 2 functionalities and create ROS <span class="No-Break">2 nodes</span></li><li><strong class="source-inline">from rclpy.node import Node</strong>: Imports the <strong class="source-inline">Node</strong> class from the <strong class="source-inline">rclpy</strong> module, enabling the script to define custom nodes for ROS <span class="No-Break">2 applications</span></li><li><strong class="source-inline">from geometry_msgs.msg import Twist</strong>: Imports the <strong class="source-inline">Twist</strong> message type from the <strong class="source-inline">geometry_msgs</strong> package; we use this for sending commands to move the <span class="No-Break">TurtleSim robot</span></li><li><strong class="source-inline">import paho.mqtt.client as mqtt</strong>: Imports the Paho MQTT client library we will use for MQTT <span class="No-Break">protocol communication</span></li></ul></li> <li>In our code, we create an <strong class="source-inline">MQTTMessage</strong> class. This class effectively parses and updates its properties based on the content of an MQTT message, which contains joystick position data and <span class="No-Break">button states:</span><pre class="source-code">
class MQTTMessage:
    def __init__(self):
        self.x = 0
        self.y = 0
        self.button1 = False
        self.button2 = False
    def update_values(self, message):
        parts = message.split(', ')
        self.x = float(parts[0].split(': ')[1])
        self.y = float(parts[1].split(': ')[1])
        self.button1=parts[2].split(': ')[1].strip() == "True"
        self.button2 = parts[3].split(': ')[1].strip() == "True"</pre><p class="list-inset">In our <a id="_idIndexMarker941"/>code, we have <a id="_idIndexMarker942"/><span class="No-Break">the following:</span></p><ul><li><strong class="source-inline">class MQTTMessage</strong>: Defines a class for handling <span class="No-Break">MQTT messages.</span></li><li><span class="No-Break"><strong class="source-inline">__init__()</strong></span><span class="No-Break"> method:</span><ul><li>Initializes <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> to <strong class="source-inline">0</strong>, representing <span class="No-Break">default positions.</span></li><li>Sets <strong class="source-inline">button1</strong> and <strong class="source-inline">button2</strong> to <strong class="source-inline">False</strong>, indicating their default <span class="No-Break">unpressed state.</span></li></ul></li><li><span class="No-Break"><strong class="source-inline">update_values()</strong></span><span class="No-Break"> method:</span><ul><li>Takes a <strong class="source-inline">message</strong> string as input and splits it into parts based <span class="No-Break">on commas.</span></li><li>Parses the <strong class="source-inline">message</strong> to extract and convert <strong class="source-inline">X</strong> and <strong class="source-inline">Y</strong> values <span class="No-Break">to floats.</span></li><li>Determines the states of <strong class="source-inline">button1</strong> and <strong class="source-inline">button2</strong> by splitting the string parts and comparing them with <strong class="source-inline">"True"</strong>. The <strong class="source-inline">strip()</strong> method is used to remove any <span class="No-Break">leading/trailing whitespace.</span></li></ul></li></ul></li> <li>The <strong class="source-inline">RobotController</strong> class is a subclass of the <span class="No-Break"><strong class="source-inline">Node</strong></span><span class="No-Break"> class:</span><pre class="source-code">
class RobotController(Node):
    def __init__(self, mqtt_message):
        super().__init__('robot_controller')
        self.mqtt_message = mqtt_message
        self.publisher = self.create_publisher(
            Twist, 'turtle1/cmd_vel', 10)
        timer_period = 0.1
        self.timer = self.create_timer(
            timer_period, self.timer_callback)
        self.vel_msg = Twist()
        self.mqtt_client = mqtt.Client()
        self.mqtt_client.on_connect = self.on_connect
        self.mqtt_client.on_message = self.on_message
        self.mqtt_client.username_pw_set(
            "mqtt-username", "mqtt-password")
        self.mqtt_client.connect(
            "driver.cloudmqtt.com", 18756, 60)
        self.mqtt_client.loop_start()</pre><p class="list-inset">In our <a id="_idIndexMarker943"/>code, we have <a id="_idIndexMarker944"/><span class="No-Break">the following:</span></p><ul><li>We define <strong class="source-inline">RobotController</strong> as a subclass <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Node</strong></span></li><li><span class="No-Break"><strong class="source-inline">__init__()</strong></span><span class="No-Break"> method:</span><ul><li>Initializes the node with the <span class="No-Break">name </span><span class="No-Break"><strong class="source-inline">robot_controller</strong></span></li><li>Stores <strong class="source-inline">mqtt_message</strong> passed as <span class="No-Break">a parameter</span></li><li>Creates a publisher for ROS <strong class="source-inline">Twist</strong> messages on the <span class="No-Break"><strong class="source-inline">turtle1/cmd_vel</strong></span><span class="No-Break"> topic</span></li><li>Sets a timer for a periodic callback function with a <span class="No-Break">0.1-second interval</span></li><li>Initializes <strong class="source-inline">self.vel_msg</strong> as a <strong class="source-inline">Twist</strong> object for <span class="No-Break">velocity commands</span></li></ul></li><li>MQTT <span class="No-Break">client configuration:</span><ul><li>Creates a new <span class="No-Break">MQTT client</span></li><li>Sets up connection and message callbacks (<strong class="source-inline">on_connect()</strong> and <span class="No-Break"><strong class="source-inline">on_message()</strong></span><span class="No-Break"> methods)</span></li><li>Configures the client with a username and password <span class="No-Break">for MQTT</span></li><li>Establishes a connection to the MQTT server at <strong class="source-inline">driver.cloudmqtt.com</strong> on port <strong class="source-inline">18756</strong> (verify port number in the <strong class="bold">Instance Details</strong> section of the <span class="No-Break">CloudMQTT dashboard)</span></li><li>Starts the MQTT client loop for <span class="No-Break">asynchronous operation</span></li></ul></li></ul></li> <li>The <strong class="source-inline">on_connect()</strong> method is used to handle MQTT client connections. Upon successfully connecting (indicated by <strong class="source-inline">rc</strong> being <strong class="source-inline">0</strong>), it prints a confirmation message <a id="_idIndexMarker945"/>and subscribes the client to the <strong class="source-inline">JoystickPosition</strong> topic, enabling the client to receive <a id="_idIndexMarker946"/>related messages. If the connection fails, it displays an error message with the specific <strong class="source-inline">rc</strong> code to help diagnose the issue. The method’s parameters follow the Paho MQTT <span class="No-Break">library’s conventions:</span><pre class="source-code">
    def on_connect(self, client, userdata, flags, rc):
        if rc == 0:
            print("Connected successfully to MQTT Broker")
            client.subscribe("JoystickPosition")
        else:
            print(f"Failed to connect with error code {rc}.")</pre></li> <li>The <strong class="source-inline">on_message()</strong> method is used to handle incoming MQTT messages. Upon receiving a message, it decodes the message payload from bytes to a string and then updates the MQTT <strong class="source-inline">message</strong> object with the new values using the <span class="No-Break"><strong class="source-inline">update_values()</strong></span><span class="No-Break"> method:</span><pre class="source-code">
    def on_message(self, client, userdata, msg):
        self.mqtt_message.update_values(msg.payload.decode())</pre></li> <li>The <strong class="source-inline">timer_callback()</strong> method is the final method in the <strong class="source-inline">RobotController</strong> class. It adjusts the robot’s movement based on the state of two buttons. If <strong class="source-inline">button1</strong> is pressed, it sets the robot to draw a circle in the counterclockwise direction. Pressing <strong class="source-inline">button2</strong> does the opposite, making the robot move <a id="_idIndexMarker947"/>in the clockwise direction. If neither button is pressed, the robot’s linear and angular <a id="_idIndexMarker948"/>velocities are set based on the joystick’s <strong class="source-inline">Y</strong> and <strong class="source-inline">X</strong> positions, respectively. After setting the velocities, the updated <strong class="source-inline">vel_msg()</strong> function is published to control the <span class="No-Break">robot’s movement:</span><pre class="source-code">
def timer_callback(self):
        if self.mqtt_message.button1:
            self.vel_msg.linear.x = 1.0
            self.vel_msg.angular.z = 1.0
        elif self.mqtt_message.button2:
            self.vel_msg.linear.x = -1.0
            self.vel_msg.angular.z = -1.0
        else:
            self.vel_msg.linear.x = float(self.mqtt_message.y)
            self.vel_msg.angular.z = float(self.mqtt_message.x)
        self.publisher.publish(self.vel_msg)</pre></li> <li>The <strong class="source-inline">main()</strong> function is executed outside any class and serves as the entry point for running a ROS 2 node integrated with MQTT for robot control. It begins with initializing the ROS client library, then creates an instance of the <strong class="source-inline">MQTTMessage</strong> and <strong class="source-inline">RobotController</strong> classes, passing the MQTT message object to <a id="_idIndexMarker949"/>the latter. The <a id="_idIndexMarker950"/>application enters a ROS event loop to process callbacks, including MQTT messages, ensuring the robot responds to joystick commands. Upon exit, it shuts down by destroying the ROS node and terminating the ROS <span class="No-Break">client library:</span><pre class="source-code">
def main(args=None):
    rclpy.init(args=args)
    mqtt_message = MQTTMessage()
    robot_controller = RobotController(mqtt_message)
    rclpy.spin(robot_controller)
    robot_controller.destroy_node()
    rclpy.shutdown()
if __name__ == '__main__':
    main()</pre></li> <li>With our code completed, we save the file using the same name, <strong class="source-inline">robot_control.py</strong>. Our next step is to update the <strong class="source-inline">package.xml</strong> file to include Python library dependencies for our code (refer to <a href="B21282_11.xhtml#_idTextAnchor173"><span class="No-Break"><em class="italic">Chapter 11</em></span></a> for more information on ROS packages). To do so, we open an Ubuntu Terminal and navigate to the folder containing the <span class="No-Break"><strong class="source-inline">package.xml</strong></span><span class="No-Break"> file:</span><pre class="source-code">
<strong class="bold">cd ~/ch12_ws/src/mqtt_robot</strong></pre></li> <li>To open <strong class="source-inline">package.xml</strong> in a text editor, we execute the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">gedit package.xml</strong></pre></li> <li>We update the XML by adding the following lines before the last <span class="No-Break">tag (</span><span class="No-Break"><strong class="source-inline">&lt;/package&gt;</strong></span><span class="No-Break">):</span><pre class="source-code">
  &lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;
  &lt;exec_depend&gt;paho-mqtt&lt;/exec_depend&gt;</pre></li> <li>We save <a id="_idIndexMarker951"/>our changes <a id="_idIndexMarker952"/>and close <span class="No-Break">the editor.</span></li>
</ol>
<p>With updates to <strong class="source-inline">robot_control.py</strong> and <strong class="source-inline">package.xml</strong>, we are now ready to compile our code and run our <span class="No-Break">new node.</span></p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor206"/>Controlling a ROS TurtleSim robot using our IoT joystick</h2>
<p>Before <a id="_idIndexMarker953"/>we can run our new node, we <a id="_idIndexMarker954"/>must compile it. As we did in <a href="B21282_11.xhtml#_idTextAnchor173"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, we compile our code using the <strong class="source-inline">colcon</strong> ROS tool. To compile and execute our new code, we do <span class="No-Break">the following:</span></p>
<ol>
<li>In Ubuntu, we open a new Terminal and source our ROS <span class="No-Break">2 environment:</span><pre class="source-code">
<strong class="bold">source /opt/ros/humble/setup.bash</strong></pre></li> <li>We then navigate to the root of <span class="No-Break">our workspace:</span><pre class="source-code">
<strong class="bold">cd ~/ch12_ws</strong></pre></li> <li>To compile our code, we execute the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">colcon build</strong></pre></li> <li>Upon completion, a message confirming a successful build will appear in <span class="No-Break">the terminal.</span></li>
<li>With our code compiled, it is time to source our new ROS environment. We do this with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">source ~/ch12_ws/install/setup.bash</strong></pre></li> <li>This is similar to how we source the ROS environment. To run our node, we execute the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">ros2 run mqtt_robot robot_control</strong></pre></li> <li>Here, we <a id="_idIndexMarker955"/>are running our <a id="_idIndexMarker956"/>new node, <strong class="source-inline">robot_control</strong>, from the package we created, <strong class="source-inline">mqtt_robot</strong>. We should observe a message indicating that we have successfully connected to the <span class="No-Break">MQTT broker:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer244">
<img alt="Figure 12.8 – Running the robot_control node" height="270" src="image/B21282_12_8.jpg" width="1002"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8 – Running the robot_control node</p>
<ol>
<li value="8">In a separate Ubuntu Terminal, we launch an instance of the TurtleSim robot with the <span class="No-Break">following commands:</span><pre class="source-code">
<strong class="bold">source /opt/ros/humble/setup.bash</strong>
<strong class="bold">ros2 run turtlesim turtlesim_node</strong></pre></li> <li>To start our IoT joystick, we may simply plug it into a USB power source or run the <strong class="source-inline">code.py</strong> program <span class="No-Break">from Thonny.</span></li>
<li>We should observe that we can navigate the TurtleSim robot with our IoT joystick. Pressing and holding the main arcade-style button will make the robot draw a circle in the counterclockwise direction, while clicking and holding the joystick control down should make the robot draw a circle in the <span class="No-Break">clockwise direction:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer245">
<img alt="Figure 12.9 – Results of pressing the arcade-style button on the IoT joystick followed by pressing the joystick control button" height="399" src="image/B21282_12_9.jpg" width="502"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.9 – Results of pressing the arcade-style button on the IoT joystick followed by pressing the joystick control button</p>
<p>With this, we have successfully managed the remote control of a virtual robot using our IoT <a id="_idIndexMarker957"/>joystick, demonstrating <a id="_idIndexMarker958"/>the system’s global reach. This application demonstrates the vast potential for IoT and <span class="No-Break">robotics integration.</span></p>
<p>For our final step, we’ll encase the IoT joystick’s components in a custom-designed housing. This enhances usability by making the device easier to manage and operate. Additionally, the custom case offers protection for the electronics and gives our application a <span class="No-Break">professional finish.</span></p>
<h1 id="_idParaDest-205"><a id="_idTextAnchor207"/>Constructing the IoT joystick case</h1>
<p>As mentioned, our custom case gives our IoT joystick a professional look and gives us something <a id="_idIndexMarker959"/>to place in our hands. We assemble the custom case using 3D-printed parts and some <span class="No-Break">common components.</span></p>
<p>The <strong class="source-inline">.stl</strong> files for the 3D-printed parts of our case may be found under the <strong class="source-inline">Build Files</strong> section of this chapter’s GitHub repository. We may see the parts that make up the case in the <span class="No-Break">following figure:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer246">
<img alt="" height="708" role="presentation" src="image/B21282_12_10.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.10 – Parts that make up the IoT joystick case</p>
<p>The parts that make up the IoT joystick case from <span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.10</em> are <span class="No-Break">as follows:</span></p>
<ul>
<li><em class="italic">A</em>: Backplate. 3D printed from the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">stl</strong></span><span class="No-Break"> file.</span></li>
<li><em class="italic">B</em>: Front shell. 3D printed from the <strong class="source-inline">.stl</strong> file (the part in the figure has <span class="No-Break">been painted).</span></li>
<li><em class="italic">C</em>: 4 x M2.5 10 <span class="No-Break">mm stand-offs.</span></li>
<li><em class="italic">D</em>: 8 mm <span class="No-Break">LED holder.</span></li>
<li><em class="italic">E</em>: Thumbstick for PS2 joystick stick module. 3D printed from the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">stl</strong></span><span class="No-Break"> file.</span></li>
<li><em class="italic">F</em>: Drilling guide for PS2 joystick module. 3D printed from the <strong class="source-inline">.stl</strong> file. We use a drilling guide as there are discrepancies in the position of mounting holes for various <a id="_idIndexMarker960"/>versions of the PS2 joystick module. The version we are using in our example has mounting holes that are 20.5 mm apart on the <em class="italic">y</em> axis and 26 mm apart on the <span class="No-Break"><em class="italic">x</em></span><span class="No-Break"> axis.</span></li>
<li><em class="italic">G</em>: 1 x M2 8 mm screw (<span class="No-Break">not shown).</span></li>
<li><em class="italic">H</em>: 4 x M2 5 mm screws (<span class="No-Break">not shown).</span></li>
<li><em class="italic">I</em>: 8 x M2.5 5 mm bolts (<span class="No-Break">not shown).</span></li>
<li><em class="italic">J</em>: 4 x M3 10 mm bolts (<span class="No-Break">not shown).</span></li>
</ul>
<p>To construct the IoT joystick case, we begin by securing the thumbstick (<em class="italic">E</em> from <span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.10</em>) to the PS2 joystick (as shown in <span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.11</em>). We are replacing the thumbstick that comes with the PS2 joystick with our own to allow for more range. We can see the construction of the IoT joystick in the <span class="No-Break">following figure:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer247">
<img alt="" height="704" role="presentation" src="image/B21282_12_11.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.11 – Preparing our custom case for the PS2 joystick</p>
<p>To prepare <a id="_idIndexMarker961"/>our case for the PS2 joystick, we do <span class="No-Break">the following:</span></p>
<ol>
<li>Secure the M2 8 mm screw to the thumbstick such that a portion of it extends through the thumbstick (<em class="italic">Step 1</em> from <span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.11</em></span><span class="No-Break">).</span></li>
<li>Fasten the thumbstick to the stem of the PS2 joystick by screwing it in by hand (<em class="italic">Step 2</em> from <span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.11</em></span><span class="No-Break">).</span></li>
<li>Attach the four M2.5 10 mm standoffs to the PS2 joystick using four M2.5 5 mm bolts (<em class="italic">Step 3</em> from <span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.11</em></span><span class="No-Break">).</span></li>
<li>Line up the drilling guide to the joystick hole of the front shell matching the orientation shown in <em class="italic">Step 4</em> of <span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.11</em>. The PS2 joystick will be installed such that the pins will extend out to <span class="No-Break">the right.</span></li>
<li>Using an appropriately sized drill bit, drill four holes into the front shell (<em class="italic">Step 5</em> from <span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.11</em></span><span class="No-Break">).</span></li>
</ol>
<p>With the thumbstick installed <a id="_idIndexMarker962"/>and the holes drilled, it is now time to construct the case. To do so, we follow the steps in the <span class="No-Break">following figure:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer248">
<img alt="Figure 12.12 – Constructing the IoT joystick case" height="915" src="image/B21282_12_12.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.12 – Constructing the IoT joystick case</p>
<p>Using <span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.12</em> as a reference, we construct the IoT joystick case <span class="No-Break">as follows:</span></p>
<ol>
<li>We start by securing the Raspberry Pi Pico WH to the back plate using four M2 5 mm screws, positioning the USB port downward for easy access. This setup ensures the Pico’s <em class="italic">Reset</em> button is accessible through a designated hole in the back plate. Opting for a Pico WH provides easy integration with our GPIO expander from the test circuit. While a Raspberry Pi Pico W can also be used, it requires soldering to install, making the Pico WH a more convenient choice for this application (<em class="italic">Step 1</em> from <span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.12</em></span><span class="No-Break">).</span></li>
<li>We then <a id="_idIndexMarker963"/>secure the PS2 joystick to the front shell using four M2.5 5 mm bolts. We must ensure that we install the P2 joystick such that the pins are pointing to the right of the case (<em class="italic">Step 2</em> from <span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.12</em></span><span class="No-Break">).</span></li>
<li>Using the LED holder, we attach the LED with the resistor to the front shell. We secure the arcade-style button to the front shell, as well as using the appropriate hole (<em class="italic">Step 3</em> from <span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.12</em></span><span class="No-Break">).</span></li>
<li>We secure the backplate to the front shell using four M3 10 mm bolts (<em class="italic">Step 4</em> from <span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.12</em></span><span class="No-Break">).</span></li>
<li>To power the IoT joystick, we attach a micro-USB cord to the USB port of the Raspberry Pi <span class="No-Break">Pico WH.</span></li>
</ol>
<p>We may now plug in our IoT joystick and use it to control a <span class="No-Break">TurtleSim robot.</span></p>
<h1 id="_idParaDest-206"><a id="_idTextAnchor208"/>Summary</h1>
<p>In this chapter, we assembled our IoT joystick and used it to control a TurtleSim virtual robot. We started with component wiring and then proceeded to write code for transmitting joystick movements via <span class="No-Break">MQTT messages.</span></p>
<p>Our application culminated in encasing the components in a custom 3D-printed case, enhancing the joystick’s usability and durability. Through this application, we displayed the seamless integration of IoT devices with <span class="No-Break">robotic systems.</span></p>
<p>In the next chapter, we will convert our virtual TurtleSim robot into a real-life physical robot and control it with our new <span class="No-Break">IoT joystick.</span></p>
</div>
</div></body></html>