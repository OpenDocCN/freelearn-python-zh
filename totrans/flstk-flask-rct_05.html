<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-70"><a id="_idTextAnchor095"/>5</h1>
<h1 id="_idParaDest-71"><a id="_idTextAnchor096"/>JSX and Displaying Lists in React</h1>
<p><strong class="bold">Componentization</strong> is a design<a id="_idIndexMarker256"/> paradigm in React application development. As a developer and React enthusiast, you will develop tons of useful components. You will need a combination of units to provide interfaces the user can interact with seamlessly.</p>
<p><strong class="bold">JavaScript Syntax Extension</strong> (<strong class="bold">JSX</strong>) is an innovative<a id="_idIndexMarker257"/> approach to describing the <strong class="bold">User Interface</strong> (<strong class="bold">UI</strong>) for modern web applications. In this chapter, we are going to take a clinical dive into why JSX is one of the core requirements in developing production-ready React applications. In addition, you will learn how to display lists in React.</p>
<p>We use lists in virtually every web application development project we undertake, and knowing how to render lists is a required skill set for web developers. HTML and JavaScript, as languages of the web, have been with us from the beginning, helping web developers build web applications.</p>
<p>However, in recent times, the demand for complex and highly rich interactive web applications has necessitated using JSX as a creative approach for building user interface components.</p>
<p>In this chapter, we are going to understand what JSX is about and how it is different from HTML. We will use JSX to describe the user interfaces we will be building in this chapter. Then, we will examine how we handle event operations in React.</p>
<p>As a React developer, you will consume both internal and external API data for your user consumption. By the end of this chapter, you will be able to display list objects to your users, handle common events in React, and render lists with loop functions.</p>
<p>In this chapter, we’ll cover the following topics:</p>
<ul>
<li>What is JSX?</li>
<li>JSX versus HTML</li>
<li>How JSX abstracts JavaScript</li>
<li>Event handling in React</li>
<li>Displaying lists in React</li>
<li>Nesting lists in JSX</li>
<li>Looping over objects in JSX</li>
</ul>
<h1 id="_idParaDest-72"><a id="_idTextAnchor097"/>Technical requirements</h1>
<p>The complete code for this chapter is available on GitHub at: <a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter05">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter05</a>.</p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor098"/>What is JSX?</h1>
<p>You’ve already<a id="_idIndexMarker258"/> been introduced to and seen some JSX. Let’s discuss in more depth what JSX means as a new approach to adding HTML to JavaScript when designing user interfaces.</p>
<p>JSX is simply an XML-like syntax extension for JavaScript. JSX allows frontend developers to bake HTML elements with JavaScript. The effect of this mix is usually an impressive user-friendly interface. As we know, the main purpose of React is to provide us with a set of APIs for building user interfaces.</p>
<p>With little or no controversy, React has been up to the challenge, becoming the leading shining gem in the jungle of frontend JavaScript libraries and frameworks. React powers large-scale, production-grade web and mobile applications with an improved user experience.</p>
<p>Interestingly, React is achieving this improved efficiency and performance with the same set of tools, languages, and techniques we are already familiar with: HTML and JavaScript. React leverages HTML elements and JavaScript functions to build reusable UI components. JSX evolved as an approach that allows us to mix markup and display logic for building React components.</p>
<p>You can safely run JavaScript code as a JSX expression. Consider the following snippet of a simple React component to see some of the ways you can use JSX in React:</p>
<pre class="source-code">import React from 'react';export function App() {
    const speakerName = "John Holt"
    return (
        &lt;div className='App'&gt;
            &lt;h2&gt;{speakerName}&lt;/h2&gt;/* This outputs  John
                Holt */
            &lt;h2&gt;{5 + 5 }&lt;/h2&gt;/* This outputs the sum of 5 +
                5 = 10 */
        &lt;/div&gt;
    );
}</pre>
<p>Let’s examine<a id="_idIndexMarker259"/> what is going on with this code snippet.</p>
<p>The preceding code explains how to use JSX in React:</p>
<ul>
<li><code>import React from 'react'</code> is used to bring React into scope</li>
<li><code>export function App()</code> describes a function component named <code>App()</code> that can be accessed by other components</li>
<li>The <code>const speakerName</code> variable is declared and assigned a value of <code>John Holt</code></li>
<li>The following part of the preceding code snippet depicts the JSX part of the <code>component </code><code>App()</code> code:<pre class="source-code">return (    &lt;div className='App'&gt;        &lt;h1&gt;Displaying name of a conference            speaker:&lt;/h1&gt;        &lt;h2&gt;{speakerName}&lt;/h2&gt;   /* This outputs John                                   Holt */        &lt;h2&gt;{5 + 5 }&lt;/h2&gt;   /* This outputs number 10                           */    &lt;/div&gt;);</pre></li>
</ul>
<p>The preceding code is a mix of HTML elements (<code>h2</code> and <code>div</code>) and a JavaScript expression inside curly braces (<code>{speakerName}</code>). This displays the text <code>John Holt</code> while <code>{5 + 5 }</code> displays the result of the sum of 5 + 5.</p>
<p>Whatever JavaScript expression you have can be put inside a curly brace in JSX and it will return the expected valid JavaScript output. However, the browser doesn’t know what to do with JSX syntax by default; but with the help of the Babel compiler, JSX code is transformed into equivalent JavaScript syntax that the browser natively understands.</p>
<p>The JSX transpilation by Babel contributes significantly to factors that make React applications so<a id="_idIndexMarker260"/> brazenly fast. It doesn’t just transpile JSX codes into browser JavaScript; it optimizes as well.</p>
<p>You can also see how the <code>&lt;div className='App'&gt;</code> attribute is used in JSX; the naming convention for the class attribute is important. We write it in camelCase format – <code>className</code> in React. The <code>className</code> attribute is assigned a value of <code>App</code>, which is used in the CSS file to add style to the component.</p>
<p>In addition, we need to understand that a high-level connection exists between JSX and the <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>). The<a id="_idIndexMarker261"/> DOM is an object-oriented representation of a web document. It is a set of APIs that’s used to manipulate web documents that can be loaded on a web browser. A typical web application page represents a web document that DOM APIs use to maintain the DOM structure and content.</p>
<p>The DOM manipulation is usually done by JavaScript – a scripting language. You can use JavaScript objects to create, update, and remove HTML elements. The DOM manipulation is the bedrock of interactivity you see with most web applications. But React handles DOM differently and at best with some creativity.</p>
<p>The React team has been able to identify the challenges with DOM tree re-rendering on every HTML element operation (create, update, and delete), and decided to develop a <strong class="bold">virtual DOM</strong> (<strong class="bold">VDOM</strong>). VDOM is<a id="_idIndexMarker262"/> an abstraction of the native browser DOM that enables React applications to be fast and efficient and exhibit cross-browser compatibility.</p>
<p>React components only re-render the changed node (<code>h1</code>, <code>div</code>, and <code>p</code> – all these represent nodes on HTML) of a DOM, rather than causing the entire web document to be re-rendered on a<a id="_idIndexMarker263"/> single node change.</p>
<p>Next, we will discuss how JSX and HTML elements are used to design UI components and the inherent differences between JSX and HMTL.</p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor099"/>JSX versus HTML</h1>
<p><code>React.createElement()</code> under the hood. JSX makes component interface development hassle-free while optimizing efficiency.</p>
<p>HTML is the standard language for structuring the web. HTML elements power every web page you see on the internet. HTML syntax is easy to understand, and it is the language the browser understands natively.</p>
<p>The following table clearly states the subtle differences that exist between JSX and HTML for better understanding and usage in React applications:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style"/>
<td class="No-Table-Style">
<p><strong class="bold">HTML</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">JSX</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Native to the browser</p>
</td>
<td class="No-Table-Style">
<p>HTML elements are native to the browser.</p>
</td>
<td class="No-Table-Style">
<p>JSX is transpiled into JavaScript using Babel before browsers can understand its syntax.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Attribute usage</p>
</td>
<td class="No-Table-Style">
<p>You have flexibility regarding how you name your HTML attributes, though this is mostly in lowercase, such as <code>onmouseover</code>, <code>onclick</code>, <code>onsubmit</code>, <code>onload</code>, <code>onfocus</code>, and so on.</p>
</td>
<td class="No-Table-Style">
<p>You must follow the camelCase rule in naming attributes in JSX and event references such as <code>onClick</code>, <code>onChange</code>, <code>onMouseOver</code>, and so on.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>The naming of the <code>class</code> and <code>for</code> attributes</p>
</td>
<td class="No-Table-Style">
<p>You must use lowercase <code>class</code> when naming CSS classes and <code>for</code> when naming input labels in HTML.</p>
</td>
<td class="No-Table-Style">
<p>In JSX, you must use <code>className</code> (camelCase) and <code>htmlFor</code> for input labels.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Handles JavaScript code</p>
</td>
<td class="No-Table-Style">
<p>You must use the <code>&lt;script&gt;...&lt;/script&gt;</code> script tag or an external JS file to add JavaScript to HTML.</p>
</td>
<td class="No-Table-Style">
<p>In JSX, you can write JS expressions inside curly braces; for instance, <code>{ new </code><code>Date().toString }</code>.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Returns a single parent element</p>
</td>
<td class="No-Table-Style">
<p>In HTML, you are permitted to return HTML elements without enclosing them in a single parent; for example:</p>
<p><code>&lt;div &gt; &lt;/</code><code>div&gt;</code></p>
<p><code>&lt;</code><code>p&gt;...&lt;/p&gt;</code></p>
<p><code>&lt;</code><code>ul&gt;...&lt;/ul&gt;</code></p>
<p><code>&lt;</code><code>span&gt;...&lt;/span&gt;</code>.</p>
<p>All these tags can independently stay on a web page with enclosing tags.</p>
</td>
<td class="No-Table-Style">
<p>In JSX, you must return a single parent element; otherwise, you will get JSX errors; for instance:</p>
<p><code>&lt;div&gt;&lt;/div&gt;</code> or a fragment tag, <code>&lt;&gt; &lt;/&gt;</code>, must enclose all your HTML elements:</p>
<p><code>&lt;</code><code>div&gt;</code></p>
<p><code>&lt;</code><code>p&gt;...&lt;/p&gt;</code></p>
<p><code>&lt;</code><code>ul&gt;...&lt;/ul&gt;</code></p>
<p><code>&lt;/</code><code>div</code></p>
<p>Or</p>
<p><code>&lt;&gt;</code></p>
<p><code>&lt;</code><code>p&gt;...&lt;/p&gt;</code></p>
<p><code>&lt;</code><code>ul&gt;...&lt;/ul&gt;</code></p>
<p><code>&lt;/&gt;</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Self-closing tags</p>
</td>
<td class="No-Table-Style">
<p>In HTML, you can have a self-closing tag without a forward slash; for example, <code>&lt;br&gt;</code>.</p>
</td>
<td class="No-Table-Style">
<p>In JSX, you must add a forward slash to any self-closing tag; for example, <code>&lt;</code><code>br /&gt;</code>.</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Figure">Table 5.1 – Differences between JSX and HTML</p>
<p>JSX and HTML allow<a id="_idIndexMarker266"/> you<a id="_idIndexMarker267"/> to structure web content and enable users to interact with web application interfaces. As a React developer, you must be conversant with the inherent differences between HTML and JSX elements to avoid being red-flagged by the JSX compiler.</p>
<p>Next, we will discuss how JSX allows us to describe a UI with HTML-like tags while it leverages the power of JavaScript under the hood.</p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor100"/>How JSX abstracts JavaScript</h1>
<p>Nowadays, coding <a id="_idIndexMarker268"/>React applications without JSX is not recommended, though it is possible. For instance, you can write a <code>React.createElement(component, props, ...children)</code> function to describe a UI.</p>
<p>However, you can easily describe a button UI in JSX with the following code:</p>
<pre class="source-code">&lt;Button color="wine"&gt;    Click a Wine Button
&lt;/Button&gt;</pre>
<p>Writing the preceding code without JSX would require you to describe a button UI with the following code:</p>
<pre class="source-code">React.createElement(Button,
    {color: 'wine'},
    ' Click a Wine Button')</pre>
<p>Doing this in a large React project could lead to multiple issues, such as having to deal with more bugs in your code base and facing a steeper learning curve to become a code-savvy developer who could function optimally at writing this low-level code to describe a UI. However, with very little to disagree on, you would agree that JSX is a better route to toll rather than plain React-modified JavaScript at describing a UI component.</p>
<p>Let’s examine how JSX abstracts JavaScript in its data presentation by providing a syntactic creamy chocolate on top of a low-level React function: <code>React.createElement()</code>. This implies how React takes on the burden of converting JSX into JavaScript using Babel to make seamless DOM interaction possible.</p>
<p>In <code>src/index.js</code>, update the file with the following snippet to see how you can write <code>React Conference 2024</code> to a screen without JSX:</p>
<pre class="source-code">import React from 'react';import ReactDOM from 'react-dom/client';
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(React.createElement('div', {}, 'React Conference 2024'));</pre>
<p>In the preceding code snippet, <code>React.createElement()</code> is a function call with three parameters: <code>div</code>, <code>{}</code>, and the expected output text of <code>React </code><code>Conference 2024</code>:</p>
<ul>
<li>The <code>div</code> parameter in the <code>React.createElement</code> function represents the type of HTML element we are creating. This could be any HTML element or tags (<code>h1</code>, <code>p</code>, <code>ul</code>, <code>li</code>, and so on). You could even add components as your first parameter.</li>
<li>The empty curly <a id="_idIndexMarker269"/>brace parameter, <code>{}</code>, represents props. It could be an object or null.</li>
<li>The third parameter represents what we want to see on the screen. This could be ordinary text or a child component.</li>
</ul>
<p>In <code>src/app.js</code>, update the file with the following snippet that explains the use of JSX:</p>
<pre class="source-code">import React from 'react';export function App() {
    return (
        &lt;div className='App'&gt;
            &lt;h1&gt;React Conference 2024&lt;/h1&gt;
        &lt;/div&gt;
    );
}</pre>
<p>The preceding snippet shows the JSX constructs of the code that displays <code>React Conference 2024</code> – that is, <code>&lt;div className='App'&gt;</code>,  <code>&lt;h1&gt;React Conference 2024&lt;/h1&gt;</code>, and <code>&lt;/div&gt;</code>.</p>
<p>While these look like regular HTML elements, they are JSX expressions. Now, reset <code>index.js</code> as follows to describe a UI with JSX:</p>
<pre class="source-code">import React from 'react';import ReactDOM from 'react-dom/client';
import { App } from './App.jsx'
ReactDOM.createRoot(document.querySelector('#root'))
    .render(&lt;App /&gt;)</pre>
<p>Run the code <a id="_idIndexMarker270"/>with <code>npm start</code>; you will see the text <strong class="bold">React Conference 2024</strong> on your browser screen:</p>
<div><div><img alt="Figure 5.1 – Screenshot showing the JSX output" src="img/Figure_5.1_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Screenshot showing the JSX output</p>
<p>To summarize, JSX is a useful tool within the React community that allows developers to meet the presentational needs of components without a hardcore approach to DOM manipulation. It facilitates a smooth UI experience and rich interactivity for end users. With this, we have a fast, efficient, and independent wide range of browser-compatible web applications.</p>
<p>Next, we will discuss event handling in React. Traditional event methods such as <code>onclick</code>, <code>onfocus</code>, <code>onblur</code>, and others are closely related to what we have in React with some subtle naming differences.</p>
<p>We are going to discuss this and more to see how we can harness the knowledge covered in this chapter <a id="_idIndexMarker271"/>and add it to the skill set required to build an interactive conference web app project for this book.</p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor101"/>Event handling in React</h1>
<p>React’s event system is another <a id="_idIndexMarker272"/>powerful feature shipped with React core APIs. It is called <code>SyntheticEvent</code>. As React developers, we will come across event handling daily in<a id="_idIndexMarker273"/> React application development projects. Handling events shouldn’t be new to you if you are familiar with the basics of JavaScript. You could add an event to HTML DOM using the browser-native approach.</p>
<p>Let’s have a glimpse at this code snippet:</p>
<pre class="source-code">&lt;html&gt;&lt;body&gt;
&lt;h1&gt;HTML DOM Operations&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Click here to see my message.&lt;/strong&gt;&lt;/p&gt;
&lt;div id="root"&gt;&lt;/div&gt;
&lt;script&gt;
document.addEventListener("click", function(){
document.getElementById("root").innerHTML =
    "This is a text added to the DOM tree!";
});
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<p><code>&lt;div id="root"&gt; &lt;/div&gt;</code> indicates the location where the DOM will inject the text we will create. The <code>div</code> element has an <code>id</code> attribute with a value of <code>root</code> passed into it. This helps the event objects know where text should appear. The <code>document.addEventListener()</code> method adds an event listener with two parameters: <code>click</code> and a callback function.</p>
<p>When we click on a button, we fire an event. The event name is called click event. In this scenario, there is a <code>Post</code> message to click to fire an event: <code>&lt;p&gt;&lt;strong&gt;Click here to see my message.&lt;/strong&gt;&lt;/p&gt;</code>. Once this message is clicked, a callback function, the second parameter, is triggered and causes the <code>getElementById</code> window method to use the <code>id</code> attribute with a value of <code>root</code> from the <code>div</code> element to pass <code>innerHTML</code> the newly assigned text – that is, <code>This  text is then added to the </code><code>DOM tree!</code></p>
<p>In React, we have various events with a camelCase naming convention: <code>onClick</code>, <code>onChange</code>, <code>onInput</code>, <code>onInvalid</code>, <code>onReset</code>, <code>onSubmit</code>, <code>onFocus</code>, <code>onBlur</code>, <code>onToggle</code>, and others. You<a id="_idIndexMarker274"/> can find a whole list of events in the React documentation – <strong class="bold">React </strong><strong class="bold">SythenticEvents</strong> (https://reactjs.org/docs/events.html)</p>
<p>Let’s dive into the <a id="_idIndexMarker275"/>following snippet to see how we can handle form events in<a id="_idIndexMarker276"/> React. This snippet illustrates the <code>onChange</code> form event:</p>
<pre class="source-code">import React,{useState} from 'react';const App = ()=&gt; {
const [username,setUsername]= useState("");
const [name,setName]=useState("");
const [email,setEmail]=useState("");
const handleSubmit=(e)=&gt;{
    e.preventDefault()
    alert(`Username:${username}, Name: ${name} and Email:
        ${email} submitted`)
  }
    return (
        &lt;div&gt;
            &lt;form onSubmit={handleSubmit}&gt;
                &lt;label htmlFor="username"&gt; Username&lt;/label&gt;
                    &lt;br /&gt;
                &lt;input type="text" placeholder="Username"
                    onChange={(e)=&gt;setUsername(
                        e.target.value)} /&gt;&lt;br /&gt;
                &lt;label htmlFor="name"&gt;Name&lt;/label&gt;&lt;br /&gt;
                &lt;input type="text" placeholder="Name"
                    onChange={(e)=&gt;setName(e.target.value)}
                        /&gt;&lt;br /&gt;
                &lt;label htmlFor="email"&gt; Email&lt;/label&gt;&lt;br /&gt;
                &lt;input type="email" placeholder="Email"
                     onChange={ (e)=&gt;setEmail(
                         e.target.value)}/&gt;&lt;br /&gt;
                &lt;button&gt;Submit&lt;/button&gt;
            &lt;/form&gt;
            &lt;div&gt;
                &lt;p&gt;Username: {username}&lt;/p&gt;
                &lt;p&gt;Name: {name}&lt;/p&gt;
                &lt;p&gt;Email: {email}&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}
export default App;</pre>
<p>Let’s closely examine this snippet:</p>
<ul>
<li><code>import React, {useState} from 'react'</code> makes the <code>useState</code> hook available to the <code>App()</code> component for state tracking.</li>
<li>The <code>const [username,setUsername]=useState("") </code><code>const name,</code><strong class="source-inline">
setName]=useState("")</strong> and <code>const [email,setEmail]=useState("")</code> snippets allow us to have access to the states for username, email, and name. With <code>setUsername</code>, <code>setName</code>, and <code>setEmail</code>, we can track the new states for the variables. The initial states for all the variables are set to empty strings.<pre>const handleSubmit=(e)=&gt;{  e.preventDefault()    alert(`Username:${username}, Name: ${name} and        Email: ${email} submitted`)}</pre><p class="list-inset">In the preceding <a id="_idIndexMarker277"/>snippet, <code>handleSubmit()</code> is an event handler that <a id="_idIndexMarker278"/>accepts <code>e</code> as the event object. <code>e.preventDefault</code> prevents browser default behavior on form field submission. There won’t be a page refresh on form submission. <code>handleSubmit</code> is added to the form as an attribute to execute <code>alert()</code>to display the <code>username</code>, <code>name</code>, and <code>email</code> states on the screen.</pre></li>
<li>In the input tags, <code>&lt;input </code><code>type="text" placeholder="Username"onChange=</code><strong class="source-inline">
{(e)=&gt;setUsername(e.target.value)} /&gt;</strong>, the <code>onChange</code> event attribute is added to the input element. The <code>onChange</code> event has a callback function that accepts <code>e</code> as a parameter. <code>setUsername(e.target.values)</code> listens for a change event in the input field. The same <code>onChange</code> event callbacks are added to input tags for the name and email.</li>
<li>The <code>&lt;p&gt;Username: {username}&lt;/p&gt;, &lt;p&gt;Name: {name}&lt;/p&gt;, &lt;p&gt;Email: {email}&lt;/p&gt;</code> snippet displays the current input text in the input form fields.<p class="list-inset">The following screenshot shows the effect of event handling in forms:</p></li>
</ul>
<div><div><img alt="Figure 5.2 – Screenshot showing the effects of event handlers on form fields" src="img/Figure_5.2_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Screenshot showing the effects of event handlers on form fields</p>
<p>To summarize, event <a id="_idIndexMarker279"/>handling in React is managed by a cross-browser wrapper called <code>SyntheticEvent</code>. We<a id="_idIndexMarker280"/> pass event handlers as instances to <code>SyntheticEvent</code> in React applications. It is best practice to prevent the default browser behavior by using <code>preventDefault()</code>.</p>
<p>Next, we will discuss how to use lists in React applications. A list is a common feature in any enterprise web application. Let’s see how React helps us improve the user experience with a well-thought-out UI list design.</p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor102"/>Displaying lists in React</h1>
<p>Most web<a id="_idIndexMarker281"/> applications we see around today use list components in<a id="_idIndexMarker282"/> describing a user interface. In any complex web application project or production-grade application, you will see the list feature, often used in data presentation. In React, you can use a list to display your component data.</p>
<p>We are going to use mocked data to showcase how you can use <code>map()</code> to fetch a list of data items. We will also discuss the essence of the <code>key</code> and <code>id</code> attributes in React list management. The GitHub repository for this book’s project (https://github.com/PacktPublishing/Full-Stack-Flask-Web-Development-with-React/tree/main/Chapter-05/06/frontend) contains the mocked conference speakers <code>data</code> source; you can find <code>images</code> in the public folders and <code>css</code> (<code>index.css</code>) inside the <code>src</code> folder.</p>
<p>However, the backend section of this book (<a href="B18554_09.xhtml#_idTextAnchor186"><em class="italic">Chapter 9</em></a>, <em class="italic">API Development and Documentation</em>) will explain how we can pull this data from an API endpoint developed in Flask.</p>
<p>This <code>url</code> leads you to the speakers page – <code>http://localhost:3000/speakers</code>:</p>
<div><div><img alt="Figure 5.3 – Screenshot showing the list of conference speakers pulled from a data source" src="img/Figure_5.3_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Screenshot showing the list of conference speakers pulled from a data source</p>
<p>Let’s examine the code <a id="_idIndexMarker283"/>snippet for showing a list of speakers working with a <a id="_idIndexMarker284"/>couple of components:</p>
<p>Inside <code>src/components</code>, create <code>SpeakersCard/SpeakersCard.jsx</code> and add the following code snippet:</p>
<pre class="source-code">import React from 'react'const SpeakersCard= ({name, jobTitle, company, profileImg}) =&gt; {
    return (
        &lt;&gt;
            &lt;div className="card"&gt;
                &lt;div className="speaker-card"&gt;
                    &lt;div className="speaker-info"&gt;
                        &lt;img src={profileImg} alt={name} /&gt;
                        &lt;span&gt;
                            &lt;h3&gt;{name}&lt;/h3&gt;
                        &lt;/span&gt;
                        &lt;p&gt;{jobTitle}&lt;/p&gt;
                        &lt;p&gt;{company}&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/&gt;)
}
export default SpeakersCard;</pre>
<p>In the preceding<a id="_idIndexMarker285"/> snippet, we created a <code>SpeakersCard</code> component that accepts an <a id="_idIndexMarker286"/>object with four properties: <code>name</code>, <code>jobTitle</code>, <code>company</code>, and <code>profileImg</code>. These properties will be passed to the component as props by the <code>SpeakersPage</code> component (parent component) that will be created shortly.</p>
<p>The <code>SpeakersCard</code> component’s return statement contains JSX, which represents the structure of the rendered output.</p>
<p>We need this <code>SpeakersCard</code> component to encapsulate and represent the visual appearance and information display for a speaker entity for the conference web app. By creating this component, we can reuse it throughout the application whenever we need to display information about the speaker.</p>
<p>Now, inside <code>src/pages</code>, create <code>SpeakersPage/SpeakersPage.js</code>. The <code>SpeakersPage</code> component will be used to display a list of speakers by rendering the <code>SpeakersCard</code> component for each speaker in <code>speakerList</code>.</p>
<p>Add the following<a id="_idIndexMarker287"/> code<a id="_idIndexMarker288"/> to <code>SpeakersPage.js</code>:</p>
<pre class="source-code">import React from 'react';import SpeakersCard from
    '../../components/SpeakersCard/SpeakersCard';
import speakerList from '../../data/SpeakerList';
import Breadcrumb from
    '../../components/Common/Breadcrumb/Breadcrumb'
import Header from '../../components/Header/Header';
import Footer from '../../components/Footer/Footer';
const SpeakersPage = () =&gt; {
    return (
        &lt;&gt;
            &lt;Header/&gt;
            &lt;Breadcrumb title={"Speakers"}/&gt;
            &lt;div className="speakers-container"&gt;
                &lt;div className="section-heading" &gt;
                    &lt;h1&gt;Meet Our Speakers&lt;/h1&gt;
                &lt;/div&gt;
                &lt;div className="card"&gt;
                    {speakerList.map((speaker) =&gt; (
                        &lt;SpeakersCard
                            key={speaker.id}
                            name={speaker.name}
                            jobTitle={speaker.jobTitle}
                            company={speaker.company}
                            profileImg={speaker.profileImg}
                        /&gt;
                    ))}
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;Footer/&gt;
        &lt;/&gt;
    )
}
export default SpeakersPage;</pre>
<p>In the preceding snippet, we import dependencies to make the page functionalities work:</p>
<ul>
<li><code>import SpeakersCard from '../../components/SpeakersCard/SpeakersCard'</code>: This code line imports the <code>SpeakersCard</code> component from the <code>SpeakersCard</code> directory within<a id="_idIndexMarker289"/> the components directory. The <code>../../</code> notation is used to <a id="_idIndexMarker290"/>navigate to the appropriate directory level.</li>
<li><code>import speakerList from '../../data/SpeakerList'</code>: This code line imports the <code>speakerList</code> data from the <code>SpeakerList.js</code> file located in the data directory. You can find the data file in the GitHub repository for this chapter. This data contains an array of objects, each representing a speaker with properties such as <code>name</code>, <code>jobTitle</code>, <code>company</code>, and <code>profileImg</code>.</li>
</ul>
<p>Then, we add <code>&lt;SpeakersCard ... /&gt;</code>. This code line renders the <code>SpeakersCard</code> component and passes the necessary props (<code>name</code>, <code>jobTitle</code>, <code>company</code>, and <code>profileImg</code>) for each speaker from <code>speakerList</code>. The <code>key={speaker.id}</code> prop is added to each <code>SpeakersCard</code> component. The <code>key</code> prop helps React efficiently update and re-render components when the list changes.</p>
<p><code>SpeakersPage</code> also includes <code>header</code>, <code>breadcrumb navigation</code>, and <code>footer</code> components to provide a complete layout for the speakers’ section. The codes for the <code>Header</code>, <code>Breadcrumb</code>, and <code>Footer</code> components <a id="_idIndexMarker291"/>can be found in this chapter’s GitHub<a id="_idIndexMarker292"/> repository.</p>
<p>Next, we will examine how we can follow React best practices in dealing with list items by uniquely identifying the items in a list with a key.</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor103"/>Using key and id in JSX</h2>
<p>The <strong class="bold">key</strong> in React list items is a unique identifier of the state <a id="_idIndexMarker293"/>of items in a list. We use a key to track items in the list that have been changed, added, or removed. It is usually expected to be a unique item in a list.</p>
<p>Take a look at the object array we used in the preceding example:</p>
<pre class="source-code">    const speakerList = [        {
        id: 1,
        name: 'Advon Hunt',
        jobTitle:'CEO',
        company:'Robel-Corkery',
        profileImg: 'https://images.unsplash.com/photo-
            1500648767791' },
]</pre>
<p>The <code>id</code> attribute in this array should be a unique number. This allows us to track object data states appropriately. We used the <code>{speaker.id}</code> ID as the value for the key attribute in the preceding <code>speakersList</code> example.</p>
<p>We will now delve into nested lists in JSX and learn how to use a nested list in React to handle complex data structures.</p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor104"/>Nesting lists in JSX</h1>
<p>As mentioned<a id="_idIndexMarker294"/> earlier, lists are a critical component of <a id="_idIndexMarker295"/>most web applications. Lists are often used to structure data and organize information neatly. We are familiar with some of the list clichés in <a id="_idIndexMarker296"/>web development: <em class="italic">a to-do list</em>, <em class="italic">a task list</em>, and even <em class="italic">a menu list</em>. All these<a id="_idIndexMarker297"/> lists can become complicated, depending on the data structure and how you are expected to present list items <a id="_idIndexMarker298"/>to end users. Dealing with lists in a React application requires an understanding of how you can handle data that comes in the form of an array of objects.</p>
<p>In this section, we will learn how to render nested lists of items in JSX in React applications. You are going to see complex nested data structure like this and even more coming from your API data sources, so having an understanding of nested lists will make React applications that contain complex data easier to handle.</p>
<p>The following code snippet displays a list of nested web technology stack items in a component.</p>
<p>Edit <code>App.js</code> inside <code>src/App.js</code>:</p>
<pre class="source-code">import React from "react";import {webStacksData} from "./data/webStacksData";
import WebStacks from "./components/WebStacks/WebStacks";
const App = () =&gt; {
    return (
        &lt;ul&gt;
            {webStacksData.map(i =&gt; (
                &lt;WebStacks item={i} key={i.id} /&gt;
            ))}
        &lt;/ul&gt;
    );
}
export default App;</pre>
<p>So, what’s happening in this code? We are dealing with a named nested list of object data called <code>webStacksData</code>, which can be found in the GitHub repository for this book:</p>
<ul>
<li>The data is imported into scope with <code>import {webStacksData}</code> from <code>"./data/webStacksData";</code>.</li>
<li>We also imported the <code>WebStacks</code> components into scope.</li>
<li> The <code>webStacksData.map</code> function iterates over each item in the <code>webStacksData</code> array, creating a new <code>WebStacks</code> component for each item. The <code>key</code> prop is set to the <code>id</code> property of each item to help React efficiently update the list when needed. For each item in the <code>webStacksData</code> array, a <code>WebStacks</code> component is rendered with the <code>item</code> prop set to the current <code>item</code> from the array.</li>
</ul>
<p>Let’s create a<a id="_idIndexMarker299"/> component called <code>WebStacks</code> to see the inner <a id="_idIndexMarker300"/>working of the component:</p>
<pre class="source-code">import React from "react";const  WebStacks = ({ item })=&gt; {
let children = null;
if (item.values &amp;&amp; item.values.length) {
    children = (
        &lt;ul&gt;
            {item.values.map(i =&gt; (
                &lt;WebStacks item={i} key={i.id} /&gt;
            ))}
        &lt;/ul&gt;
    );
}
return (
    &lt;li&gt;
        {item.name}
        {children}
    &lt;/li&gt;
);
}
export default WebStacks;</pre>
<p>The <code>WebStacks</code> component takes props items. In the component body function, we check to see whether the parent list items exist and whether it has child items. We then invoke <code>map()</code> to recursively iterate over the list items with valid child list items.</p>
<p>This <code>&lt;li&gt;{item.name}{children}&lt;/li&gt;</code> returns the name of the list items and all the <a id="_idIndexMarker301"/>children. Next, we are going to see how you can loop through<a id="_idIndexMarker302"/> objects in React and display the output in JSX.</p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor105"/>Looping over objects in JSX</h1>
<p>Looping through <a id="_idIndexMarker303"/>complex data objects is part of what experienced React developers need to know how to handle effortlessly. You will undoubtedly encounter scenarios where you will have to work with both simple and nested object data from your API endpoints to extract useful data for your application. In this section, we are going to understand how to seamlessly iterate over data objects in an application.</p>
<p>In JavaScript, objects are not iterable. You simply can’t loop over the object properties with the <code>for ... of</code> syntax. <code>Object.Keys()</code> is one of the in-built standard object methods used to loop over object data in JavaScript. However, in ES2017, new object methods were added that can be used to loop over object properties: <code>Object.values()</code> and <code>Object.entries()</code>.</p>
<p>Let’s briefly examine each of these methods and learn how to use them with object data.</p>
<p>Create the object data to loop over and name it <code>speakersData</code>:</p>
<pre class="source-code">const speakersData = {name:"Juliet Abert",
company:"ACME Group",
street:"1st Avenue",
state:"Pretoria",
country:"South Africa"
}</pre>
<p>Next, we will examine a variety of techniques that are used to efficiently iterate over object properties, allowing you to access and manipulate data within objects using methods such <a id="_idIndexMarker304"/>as <code>Object.keys()</code>, <code>Object.values()</code>, and <code>Object.entries()</code>. We will briefly delve into each of these techniques, starting with <code>Object.keys()</code>.</p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor106"/>Using Object.keys()</h2>
<p>The <code>Object.keys</code> method <a id="_idIndexMarker305"/>returns an array of object’s keys. As you know, objects contain key and value pairs, so <code>Object.keys()</code> will return arrays of keys/properties.</p>
<p>Let’s pass in our data object as a parameter in the following code snippet:</p>
<pre class="source-code">console.log(Object.keys(speakersData));</pre>
<p>We will get the following output:</p>
<div><div><img alt="Figure 5.4 – Screenshot showing the effect of using the Objects.keys() method" src="img/Figure_5.4_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Screenshot showing the effect of using the Objects.keys() method</p>
<p>Here, you can see the array of keys. You can retrieve the values of the key with a loop function:</p>
<pre class="source-code">for (const key in speakersData){  console.log(`${key}: ${speakersData[key]}`);
}</pre>
<p>The following screenshot shows the keys and values of the object data:</p>
<div><div><img alt="Figure 5.5 – Screenshot showing object keys and values" src="img/Figure_5.5_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – Screenshot showing object keys and values</p>
<p>Later, you can invoke <code>map()</code> to retrieve the values of the keys in a React component. This will be<a id="_idIndexMarker306"/> explained later in this section.</p>
<p>Now, let’s learn how to use <code>Object.values()</code>.</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor107"/>Using Object.values()</h2>
<p>The <code>Object.values()</code> method<a id="_idIndexMarker307"/> returns an array of object property values:</p>
<pre class="source-code">console.log(Object.values(speakersData));</pre>
<p>This returns only the properties values without keys, thus making it less useful in a use case where keys and values are needed.</p>
<div><div><img alt="Figure 5.6 – Screenshot showing the effect of using the Objects.values() method" src="img/Figure_5.6_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Screenshot showing the effect of using the Objects.values() method</p>
<p>Let’s look at the last technique we can use to loop over object data.</p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor108"/>Using Object.entries()</h2>
<p>The <code>Object.entries()</code> method <a id="_idIndexMarker308"/>returns an array of object key-value pairs – <code>[key, value]</code>. Looping over an object with <code>Object.entries()</code> is easier with the <code>[key value]</code> pair. For instance, consider the following code:</p>
<pre class="source-code">for (const  key of Object.entries(speakersData) ){    console.log(`${key[0]} : ${key[1]}`)  }</pre>
<p>The following screenshot shows the output of using <code>Object.entries()</code> on object data:</p>
<div><div><img alt="Figure 5.7 – Screenshot showing the effect of using the Objects.entries() method" src="img/Figure_5.7_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – Screenshot showing the effect of using the Objects.entries() method</p>
<p>We can see that 2D arrays are returned with keys and values of object properties.</p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor109"/>Example of looping with Object.keys</h2>
<p>Now, we are <a id="_idIndexMarker309"/>going to work with a data object that contains useful speakers’ information with an object data format. It can be found in this book’s project repository on GitHub (https://github.com/PacktPublishing/Full-Stack-Flask-Web-Development-with-React/blob/main/Chapter-05/data/objSpeakersData.js) and displays the output in a React component.</p>
<p>The following code iterates over the <code>speakers</code> object data and displays the output in JSX:</p>
<pre class="source-code">import React from 'rea<a id="_idTextAnchor110"/>ct';imp<a id="_idTextAnchor111"/>ort {simpleSpeakerData} from
    '../../data/objSpeakersData';
const Speakers = () =&gt; {
    return (
        &lt;&gt;
            &lt;h1&gt;Speakers&lt;/h1&gt;
            &lt;div&gt;
                &lt;ul&gt;
                    {Object.keys(s).map(key =&gt; (
                        &lt;li key=
                           {key}&gt;{simpleSpeakerData[key]
                               .name}
                           {simpleSpeakerData[key].company}
                           {simpleSpeakerData[key].street}
                           {simpleSpeakerData[key].state}
                           {simpleSpeakerData[key].country}
                        &lt;/li&gt;
                    ))}
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/&gt;
    );
}
export default Speakers;</pre>
<p>The preceding<a id="_idIndexMarker310"/> code is explained as follows:</p>
<ul>
<li><code>import {simpleSpeakerData} from '../../data/objSpeakersData'</code> brings our data into scope so that it can be used in the code.</li>
<li>Then, we declare a <code>Speakers</code> component, which returns a list of object data.</li>
<li><code>simpleSpeakerData</code> is passed to <code>Object.keys(simpleSpeakerData)</code>.</li>
<li><code>map()</code> is then called on the returned keys from <code>Object.keys()</code>. This iterates over the key arrays that are returned.<p class="list-inset">We are now able to access the individual key and values of the object.</p></li>
<li><code>{simpleSpeakerData[key].name}</code> points to the name property value of the object data.</li>
</ul>
<p>The following figure shows the output of iterating over complex object data in React using JSX:</p>
<div><div><img alt="Figure 5.8 – Screenshot showing object data" src="img/Figure_5.8_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – Screenshot showing object data</p>
<p>Looping over objects in JSX using <code>Object.keys()</code>,<code> Object.values()</code>, and <code>Object.entries()</code> is essential and involves iterating through the properties of an object to render<a id="_idIndexMarker311"/> JSX elements dynamically. This approach allows you to generate lists, tables, or other UI components that display data from objects in a structured manner.</p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor112"/>Summary</h1>
<p>In this chapter, we extensively discussed JSX in React. We delved into explaining what JSX is all about as well as the rules guiding the use of JSX in React. Then, we discussed the DOM and how VDOM in React abstracts the native browser DOM for React developers to build a more efficient, cross-browser user interface. JSX improves DOM interaction in React applications and also optimizes the speed for elements in React components to render.</p>
<p>We also examined event handling in React and the use of the <code>SyntheticEvent</code> event wrapper in React in handling event operations in React. We discussed the subtle differences between JSX and HTML and the rules guiding the usage in React.</p>
<p>Finally, with use cases, we discussed how you can display lists in a React project and how <code>key</code> and <code>id</code> are used in managing list items uniquely. We also looked at how you can iterate over objects and display complex nested objects in React.</p>
<p>In the next chapter, we will discuss how to handle form operations in depth and routing in React web applications.</p>
</div>
</body></html>