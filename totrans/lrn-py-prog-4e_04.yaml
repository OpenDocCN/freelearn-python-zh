- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions, the Building Blocks of Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ”To create architecture is to put in order. Put what in order? Functions and
    objects.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Le Corbusier
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the previous chapters, we have seen that everything is an object in Python,
    and functions are no exception. But what exactly is a function? A function is
    *a block of reusable code designed to perform a specific task or a related group
    of tasks* . This unit can then be imported and used wherever it is needed. There
    are many advantages to using functions in your code, as we will see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions—what they are and why we should use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scopes and name resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function signatures—input parameters and return values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursive and anonymous functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing objects for code reuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We believe the saying *a picture is worth a thousand words* is particularly
    true when explaining functions to someone who is new to this concept, so please
    take a look at the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B30992_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: An example of a function'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a function is a block of instructions, packaged as a whole,
    like a box. Functions can accept input parameters and produce output values. Both
    of these are optional, as we will see in the examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A function in Python is defined using the `def` keyword, after which the name
    of the function follows, terminated by a pair of parentheses (which may or may
    not contain input parameters); a colon ( `:` ) then signals the end of the function
    definition. Immediately afterward, indented by four spaces, we find the body of
    the function, which is the set of instructions that the function will execute
    when called.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the indentation by four spaces is not mandatory, but it is the number
    of spaces suggested by PEP 8, and, in practice, it is the most widely used spacing
    measure.
  prefs: []
  type: TYPE_NORMAL
- en: A function may or may not return an output. If a function wants to return an
    output, it does so by using the `return` keyword, followed by the desired output.
    You may have noticed the little `*` after *Optional* in the output section of
    the preceding diagram. This is because a function always returns something in
    Python, even if you do not explicitly use the `return` statement. If the function
    has no `return` statement in its body, or no value is given to the `return` statement
    itself, the function returns `None` .
  prefs: []
  type: TYPE_NORMAL
- en: 'This design choice is rooted in several reasons, the most important of which
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplicity and consistency** : Whether the function is explicitly returning
    a value or not, its behavior is consistent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity reduction** : Several languages make a distinction between functions
    (which return a value) and **procedures** (which do not). Functions in Python
    can act as both, with no need for separate constructs. This minimizes the number
    of concepts a programmer must learn.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency for multiple pathways** : Functions with multiple conditional
    branches will return `None` when no other return statement is executed. `None`
    , therefore, is a useful default value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list provided demonstrates the multitude of factors that can influence an
    apparently simple design decision. It is the careful and deliberate choices underpinning
    Python’s design that contribute to its elegance, simplicity, and versatility.
  prefs: []
  type: TYPE_NORMAL
- en: Why use functions?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions are among the most important concepts and constructs of any language,
    so let us give you a few reasons why we need them:'
  prefs: []
  type: TYPE_NORMAL
- en: They reduce code duplication in a program. Encapsulating the instructions for
    a task in a function that we can import and call whenever we want allows us to
    avoid duplicating the implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They help in splitting a complex task or procedure into smaller blocks, each
    of which becomes a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They hide the implementation details from their users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They improve traceability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They improve readability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us now look at a few examples to get a better understanding of each point.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing code duplication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that you are writing a piece of scientific software, and you need to
    calculate prime numbers up to a certain limit—as we did in the previous chapter.
    You have an algorithm to calculate them, so you copy it and paste it to wherever
    you need to use it. One day, though, a colleague gives you a more performant algorithm
    to calculate primes. At this point, you need to go over your whole code base and
    replace the old code with the new one.
  prefs: []
  type: TYPE_NORMAL
- en: This procedure is quite error-prone. You can easily remove parts of the surrounding
    code by mistake or fail to remove some of the code you meant to replace. You also
    risk missing some of the places where the prime calculation is done, leaving your
    software in an inconsistent state where the same action is performed in different
    ways. What if, instead of replacing code with a better version of it, you need
    to fix a bug and you miss a spot. That would be even worse. What if the names
    of the variables in the old algorithm are different from those used in the new
    one? That will also complicate things.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid all that, you write a function, `get_prime_numbers(upto)` , and use
    it anywhere you need to calculate a list of primes. When your colleague gives
    you a better implementation, all you need to do is replace the body of that function
    with the new code. The rest of the software will automatically adapt since it
    is just calling the function.
  prefs: []
  type: TYPE_NORMAL
- en: Your code will be shorter and free from inconsistencies between old and new
    ways of performing a task. You are also less likely to leave behind undetected
    bugs that arise from copy-and-paste failures or oversights.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting a complex task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions are also useful for splitting long or complex tasks into smaller ones.
    The result is that the code benefits from it in several ways, including readability,
    testability, and reusability.
  prefs: []
  type: TYPE_NORMAL
- en: To give you a simple example, imagine that you are preparing a report. Your
    code needs to fetch data from a data source, parse it, filter it, and polish it,
    and then a whole series of algorithms needs to be run against it, to produce the
    results that will be written into the report. It is common to see procedures like
    this that are just one big `do_report(data_source)` function. There might be hundreds
    of lines of code that run before we finally produce the report.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inexperienced programmers, not well versed in the art of crafting simple, well
    structured code, may produce functions with hundreds of lines of code. They are
    hard to follow through, to find the places where things are changing context (such
    as finishing one task and starting the next one). Let us show you a better approach
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The previous example is fictitious, of course, but can you see how easy it would
    be to go through the code? If the end result looks wrong, it would be easy to
    debug each of the single data outputs in the `do_report()` function. Moreover,
    it is even easier to exclude part of the process temporarily from the whole procedure
    (you just need to comment out the parts that you need to suspend). Code like this
    is easier to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding implementation details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us stay with the preceding example to talk about this point as well. We
    can see that, by going through the code of the `do_report()` function, we can
    get a surprisingly good understanding without reading one single line of implementation.
    This is because functions hide the implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: This feature means that, if we do not need to delve into the details, we are
    not forced to, in the way that we would be if `do_report()` was just one big,
    long function. To understand what was going on, we would have to read and understand
    every single line of its code. When it is broken down into smaller functions,
    we do not necessarily need to read every line of every one of them to understand
    what the code does. This reduces the time we spend reading the code and, since
    in a professional environment reading code takes much more time than writing it,
    it is important to reduce it to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: Improving readability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programmers sometimes do not see the point in writing a function with a body
    of one or two lines of code, so let us look at an example that shows you why you
    should probably still do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you need to multiply two matrices, like in the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B30992_04_001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Would you prefer to have to read this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, would you prefer this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is much easier to understand that `c` is the result of the multiplication
    of `a` and `b` in the second example, and it is much easier to read the code.
    If we do not need to modify that multiplication logic, we do not even need to
    go into the implementation details of `matrix_mul()` . Therefore, readability
    is improved here while, in the first snippet, we would have to spend time trying
    to understand what that complicated list comprehension is doing.
  prefs: []
  type: TYPE_NORMAL
- en: Do not worry if you do not understand list comprehensions, as we will study
    them in *Chapter 5* , *Comprehensions and Generators* .
  prefs: []
  type: TYPE_NORMAL
- en: Improving traceability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that we have written some code for an e-commerce website. We display
    the product prices on several pages. Imagine that the prices in the database are
    stored with no VAT (sales tax), but we want to display them on the website with
    VAT at 20%. Here are a few ways of calculating the VAT-inclusive price from the
    VAT-exclusive price:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These four different ways of calculating a VAT-inclusive price are all perfectly
    acceptable; we have encountered all of them in the professional code that we have
    worked on over the years.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine that we start selling products in different countries, and some
    of them have different VAT rates, so we need to refactor the code (throughout
    the website) in order to make that VAT calculation dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: How do we trace all the places in which we are performing a VAT calculation?
    Coding today is a collaborative task and we cannot be sure that the VAT has been
    calculated using only one of those forms. It is going to be difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let us write a function that takes the input values `vat` and `price` (VAT-exclusive)
    and returns a VAT-inclusive price:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now we can import that function and use it in any place on the website where
    we need to calculate a VAT-inclusive price, and when we need to trace those calls,
    we can search for `calculate_price_with_vat` .
  prefs: []
  type: TYPE_NORMAL
- en: Note that, in the preceding example, `price` is assumed to be VAT-exclusive,
    and `vat` is a percentage value (for example, 19, 20, or 23).
  prefs: []
  type: TYPE_NORMAL
- en: Scopes and name resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *Chapter 1* , *A Gentle Introduction to Python* , we discussed scopes and
    namespaces. We are going to expand on that concept now. Finally, we can talk in
    terms of functions, and this will make everything easier to understand. Let us
    start with a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We defined the `test` name in two different places in the previous example—it
    is actually in two different scopes. One is the global scope ( `test = 0` ), and
    the other is the local scope of the `my_function()` function ( `test = 1` ). If
    we execute the code, we will see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It is clear that `test = 1` shadows the `test = 0` assignment in `my_function()`
    . In the global context, `test` is still `0` , as you can see from the output
    of the program, but we define the `test` name again in the function body, and
    we set it to point to the integer `1` . Both of the `test` names therefore exist:
    one in the global scope, pointing to an int object with a value of `0` , and the
    other in the `my_function()` scope, pointing to an `int` object with a value of
    `1` . Let us comment out the line with `test = 1` . Python searches for the `test`
    name in the next enclosing namespace (recall the **LEGB** rule: **local** , **enclosing**
    , **global** , **built-in** , described in *Chapter 1* , *A Gentle Introduction
    to Python* ) and, in this case, we will see the value `0` printed twice. Try it
    in your code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us give you a more complex example with nested functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have two levels of shadowing. One level is in the
    `outer()` function, and the other one is in the `inner()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the code, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Try commenting out the `test = 1` line. Can you figure out what the result will
    be? When reaching the `print('outer:', test)` line, Python will have to look for
    `test` in the next enclosing scope; therefore it will find and print `0` , instead
    of `1` . Make sure you comment out `test = 2` as well, to see whether you understand
    what happens and whether the LEGB rule is clear to you, before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note is that Python gives us the ability to define a function
    in another function. The `inner()` function’s name is defined within the namespace
    of the `outer()` function, exactly as would happen with any other name.
  prefs: []
  type: TYPE_NORMAL
- en: The global and nonlocal statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding example, we can alter what happens to the shadowing of the
    test name by using one of these two special statements: `global` and `nonlocal`
    . As you can see, when we define `test = 2` in the `inner()` function, we do not
    overwrite `test` in the `outer()` function or in the global scope.'
  prefs: []
  type: TYPE_NORMAL
- en: We can get read access to those names if we use them in a nested scope that
    does not define them, but we cannot modify them because when we write an assignment
    instruction, we are actually defining a new name in the current scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `nonlocal` statement to change this behavior. According to the
    official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: ”The `nonlocal` statement causes the listed identifiers to refer to previously
    bound variables in the nearest enclosing scope excluding globals.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let us introduce it in the `inner()` function and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how in the body of the `inner()` function we have declared the `test`
    name to be `nonlocal` . Running this code produces the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: By declaring `test` to be `nonlocal` in the `inner()` function, we actually
    bind the `test` name to the one declared in the `outer` function. If we removed
    the `nonlocal test` line from the `inner()` function and tried it inside the `outer()`
    function, we would get a `SyntaxError` , because the `nonlocal` statement works
    on enclosing scopes, but not in the global one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Is there a way to get write access to that `test = 0` in the global namespace?
    Yes, we just need to use the `global` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have now declared the `test` name to be `global` , which will
    bind it to the one we defined in the global namespace ( `test = 0` ). Run the
    code and you should get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This shows that the name affected by the `test = 2` assignment is now the one
    in the `global` scope. This would also work in the `outer()` function because,
    in this case, we are referring to the global scope.
  prefs: []
  type: TYPE_NORMAL
- en: Try it for yourself and see what changes. Spend some time to get comfortable
    with scopes and name resolution—it is very important. As a bonus question, can
    you tell what would happen if you defined `inner()` outside `outer()` in the preceding
    examples?
  prefs: []
  type: TYPE_NORMAL
- en: Input parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the beginning of this chapter, we saw that a function can take input parameters.
    Before we delve into all the possible types of parameters, let us make sure you
    have a clear understanding of what passing an argument to a function means. There
    are three key points to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Argument-passing is nothing more than assigning an object to a local variable
    name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning an object to an argument name inside a function does not affect the
    caller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing a mutable object argument in a function does affect the caller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we explore the topic of arguments any further, please allow us to clarify
    the terminology a little. According to the official Python documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: ”Parameters are defined by the names that appear in a function definition, whereas
    arguments are the values actually passed to a function when calling it. Parameters
    define what types of arguments a function can accept.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We will try to be precise when referring to parameters and arguments, but it
    is worth noting that they are sometimes used synonymously as well. Let us now
    look at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Argument-passing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a look at the following code. We declare a name, `x` , in the global scope,
    then we declare a function, `func(y)` , and finally, we call it, passing `x` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When `func()` is called with `x` , within its local scope, a name, `y` , is
    created, and it is pointed to the same object that `x` is pointing to. This is
    better clarified in *Figure 4.2* (do not worry about the fact that this example
    was run with Python 3.11—this is a feature that has not changed).
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B30992_04_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Understanding argument-passing with Python Tutor'
  prefs: []
  type: TYPE_NORMAL
- en: 'The right-hand side of *Figure 4.2* depicts the state of the program when execution
    has reached the end, after `func()` has returned ( `None` ). Take a look at the
    **Frames** column, and note that we have two names, `x` and `func()` , in the
    global namespace ( **Global frame** ), pointing respectively to an **int** (with
    a value of `3` ) and to a `function` object. Right beneath it, in the rectangle
    titled **func** , we can see the function’s local namespace, in which only one
    name has been defined: `y` . Because we have called `func()` with `x` (line 6
    on the left side of the figure), `y` is pointing to the same object that `x` is.
    This is what happens under the hood when an argument is passed to a function.
    If we had used the name `x` instead of `y` in the function definition, things
    would have been exactly the same (but perhaps a bit confusing at first)—there
    would be a local `x` in the function, and a global `x` outside, as we saw in the
    *Scopes and name resolution* section previously in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: So, in a nutshell, what really happens is that the function creates, in its
    local scope, the names defined as parameters and, when we call it, we tell Python
    which objects those names must be pointed toward.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment to parameter names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assignment to parameter names does not affect the caller. This is something
    that can be tricky to understand at first, so let us look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, when we call the function with `func(x)` , the instruction
    `x = 7` is executed within the local scope of the `func()` function; the name
    `x` is pointed to an integer with a value of `7` , leaving the global `x` unaltered.
  prefs: []
  type: TYPE_NORMAL
- en: Changing a mutable object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Changing a mutable object does affect the caller. This is important because
    although Python *appears to* behave differently with mutable objects, the behavior
    is, in fact, perfectly consistent. Let us look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we changed the original object. If you think about it, there
    is nothing weird in this behavior. When we call `func(x)` , name `x` in the function’s
    namespace is set to point to the same object as the global `x` . Within the body
    of the function, we are not changing the global `x` , in that we are not changing
    which object it points to. We are merely accessing the element at position 1 in
    that object and changing its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember *point 2* in the *Input parameters* section: *Assigning an object
    to a parameter name within a function does not affect the caller* . If that is
    clear to you, the following code should not be surprising:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Look at the two lines we have highlighted. At first, like before, we just access
    the caller object again, at position 1, and change that value to number `42` .
    Then, we reassign `x` to point to the `'something else'` string. This leaves the
    caller unaltered and, in fact, the output is the same as that of the previous
    snippet.
  prefs: []
  type: TYPE_NORMAL
- en: Take your time to play around with this concept, and experiment with prints
    and calls to the `id()` function until everything is clear in your mind. This
    is one of the key aspects of Python and it must be very clear, otherwise you risk
    introducing subtle bugs into your code. Once again, the Python Tutor website (
    [http://www.pythontutor.com/](http://www.pythontutor.com/) ) will help you a lot
    by giving you a visual representation of these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a good understanding of input parameters and how they behave,
    let us look at the different ways of passing arguments to functions.
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are four different ways of passing arguments to a function:'
  prefs: []
  type: TYPE_NORMAL
- en: Positional arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyword arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterable unpacking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionary unpacking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us look at them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Positional arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we call a function, each positional argument is assigned to the parameter
    in the corresponding *position* in the function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is the most common way of passing arguments to functions (in some programming
    languages, this is the only way of passing arguments).
  prefs: []
  type: TYPE_NORMAL
- en: Keyword arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Keyword arguments in a function call are assigned to parameters using the `name=value`
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When we use keyword arguments, the order of the arguments does not need to match
    the order of the parameters in the function definition. This can make our code
    easier to read and debug. We do not need to remember (or look up) the order of
    parameters in a function definition. We can look at a function call and immediately
    know which argument corresponds to which parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use both positional and keyword arguments at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep in mind, however, that **positional arguments always have to be listed
    before any keyword arguments** . For example, if you try something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Iterable unpacking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Iterable unpacking uses the syntax `*iterable_name` to pass the elements of
    an *iterable* as positional arguments to a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is a very useful feature, particularly when we need to programmatically
    generate arguments for a function.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary unpacking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Dictionary unpacking is to keyword arguments what iterable unpacking is to
    positional arguments. We use the syntax `**dictionary_name` to pass keyword arguments,
    constructed from the keys and values of a dictionary, to a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Combining argument types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already seen that positional and keyword arguments can be used together,
    as long as they are passed in the proper order. We can also combine unpacking
    (of both kinds) with normal positional and keyword arguments. We can even combine
    unpacking multiple iterables and dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arguments must be passed in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, positional arguments: both ordinary ( `name` ) and iterable unpacking
    ( `*name` )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next come keyword arguments ( `name=value` ), which can be mixed with iterable
    unpacking `(*name` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, there is dictionary unpacking ( `**name` ), which can be mixed with
    keyword arguments ( `name=value` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This will be much easier to understand with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: All the above calls to `func()` are equivalent and print `1 2 3 4 5 6` . Play
    around with this example until you are sure you understand it. Pay close attention
    to the errors you get when you get the order wrong.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to unpack multiple iterables and dictionaries was introduced to
    Python by PEP 448. This PEP also introduced the ability to use unpacking in contexts
    other than just function calls. You can read all about it at [https://peps.python.org/pep-0448/](https://peps.python.org/pep-0448/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'When combining positional and keyword arguments, it is important to remember
    that each parameter can only appear once in the argument list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are passing two values for parameter `a` : the positional argument
    `2` and the keyword argument `a=1` . This is illegal, so we get an error when
    we try to run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Defining parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Function parameters can be classified into five groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'Positional or keyword parameters: allow both positional and keyword arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Variable positional parameters: collect an arbitrary number of positional arguments
    in a tuple'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Variable keyword parameters: collect an arbitrary number of keyword arguments
    in a dictionary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Positional-only parameters: can only be passed as positional arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keyword-only parameters: can only be passed as keyword arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the parameters in the examples we have seen so far in this chapter are regular
    positional or keyword parameters. We have seen how they can be passed as both
    positional and keyword arguments. There is not much more to say about them, so
    let us look at the other categories. Before we do, though, let us briefly look
    at optional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Optional parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Apart from the categories we have looked at here, parameters can also be classified
    as either *required* or *optional* . **Optional parameters** have a default value
    specified in the function definition. The syntax is `name=value` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, `a` is required, while `b` has the default value `4` and `c` has the default
    value `88` . It is important to note that, with the exception of keyword-only
    parameters, required parameters must always be to the left of all optional parameters
    in the function definition. Try removing the default value from `c` in the above
    example and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Variable positional parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes you may prefer not to specify the exact number of positional parameters
    to a function; Python provides you with the ability to do this by using **variable
    positional parameters** . Let us look at a very common use case, the `minimum()`
    function. This is a function that calculates the minimum of its input values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when we define a parameter with an asterisk, `*` , prepended
    to its name, we are telling Python that this parameter will collect a variable
    number of positional arguments when the function is called. Within the function,
    `n` is a tuple. Uncomment `print(type(n))` to see for yourself, and play around
    with it for a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Note that a function can have at most one variable positional parameter—it would
    not make sense to have more. Python would have no way of deciding how to divide
    up the arguments between them. You also cannot specify a default value for a variable
    positional parameter. The default value is always an empty tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Have you noticed how we checked whether `n` was not empty with a simple `if
    n:` ? This is because collection objects evaluate to `True` when non-empty, and
    otherwise `False` , in Python. This is the case for tuples, sets, lists, dictionaries,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: One other thing to note is that we may want to throw an error when we call the
    function with no parameters, instead of silently doing nothing. In this context,
    we are not concerned about making this function robust, but rather understanding
    variable positional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Did you notice that the syntax for defining variable positional parameters looks
    very much like the syntax for iterable unpacking? This is no coincidence. After
    all, the two features mirror each other. They are also frequently used together,
    since variable positional parameters save you from worrying about whether the
    length of the iterable you are unpacking matches the number of parameters in the
    function definition.
  prefs: []
  type: TYPE_NORMAL
- en: Variable keyword parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Variable keyword parameters** are very similar to variable positional parameters.
    The only difference is the syntax ( `**` instead of `*` ) and the fact that they
    are collected in a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You can see that adding `**` in front of the parameter name in the function
    definition tells Python to use that name to collect a variable number of keyword
    parameters. As in the case of variable positional parameters, each function can
    have at most one variable keyword parameter—and you cannot specify a default value.
  prefs: []
  type: TYPE_NORMAL
- en: Just like variable positional parameters resemble iterable unpacking, variable
    keyword parameters resemble dictionary unpacking. Dictionary unpacking is also
    often used to pass arguments to functions with variable keyword parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason why being able to pass a variable number of keyword arguments is
    so important may not be evident at the moment, so how about a more realistic example?
    Let us define a function that connects to a database: we want to connect to a
    default database by simply calling this function with no parameters. We also want
    to connect to any other database by passing to the function the appropriate parameters.
    Before you read on, try to spend a couple of minutes figuring out a solution by
    yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, in the function, we can prepare a dictionary of connection parameters
    ( `conn_params` ) using default values as fallbacks, allowing them to be overwritten
    if they are provided in the function call. There are better ways to do this with
    fewer lines of code, but we are not concerned with that right now. Running the
    preceding code yields the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note the correspondence between the function calls and the output, and how default
    values are overridden according to what was passed to the function.
  prefs: []
  type: TYPE_NORMAL
- en: Positional-only parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Starting from Python 3.8, PEP 570 ( [https://peps.python.org/pep-0570/](https://peps.python.org/pep-0570/)
    ) introduced **positional-only parameters** . There is a new function parameter
    syntax, `/` , indicating that a set of the function parameters must be specified
    positionally and *cannot* be passed as keyword arguments. Let us see a simple
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we define a function, `func()` , which specifies
    three parameters: `a` , `b` , and `c` . The `/` in the function signature indicates
    that `a` and `b` must be passed positionally, that is, not by keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last two lines in the example show that we can call the function passing
    all three arguments positionally, or we can pass `c` by keyword. Both cases work
    fine, as `c` is defined after the `/` in the function signature. If we try to
    call the function by passing `a` or `b` by keyword, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following traceback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows us that Python is now complaining about how we called
    `func()` . We have passed `b` by keyword, but we are not allowed to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Positional-only parameters can also be optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us see what this feature brings to the language with a few examples borrowed
    from the official documentation. One advantage is the ability to fully emulate
    behaviors of existing C-coded functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Another important use case is to preclude keyword arguments when the parameter
    name is not helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `obj` keyword argument impairs readability. Moreover,
    if we wish to refactor the internals of the `len` function, and rename `obj` to
    `the_object` (or any other name), the change is guaranteed not to break any client
    code, because there will not be any call to the `len()` function involving the
    now stale `obj` parameter name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, using positional-only parameters implies that whatever is on the left
    of `/` remains available for use in variable keyword arguments, as shown by the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The ability to retain parameter names in function signatures for use in `**kwargs`
    can lead to simpler and cleaner code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now explore the mirror version of positional-only: keyword-only parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword-only parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python 3 introduced **keyword-only parameters** . We are going to study them
    only briefly, as their use cases are not that frequent. There are two ways of
    specifying them, either after the variable positional parameters or after a bare
    `*` . Let us see an example of both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As anticipated, the function `kwo()` takes a variable number of positional parameters
    ( `a` ) and a keyword-only one, `c` . The results of the calls are straightforward
    and you can uncomment the third call to see what error Python returns.
  prefs: []
  type: TYPE_NORMAL
- en: The same applies to the function `kwo2()` , which differs from `kwo` in that
    it takes a positional argument, `a` , a keyword argument, `b` , and then a keyword-only
    one, `c` . You can uncomment the third call to see the error that is produced.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to specify different types of input parameters, let us
    see how you can combine them in function definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Combining input parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can combine different parameter types in the same function (in fact, it
    is often very useful to do so). As in the case of combining different types of
    arguments in the same function call, there are some restrictions on ordering:'
  prefs: []
  type: TYPE_NORMAL
- en: Positional-only parameters come first, followed by a `/` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normal parameters go after any positional-only parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable positional parameters go after normal parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyword-only parameters go after variable positional parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable keyword parameters always go last.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For positional-only and normal parameters, any required parameters must be defined
    before any optional parameters. This means that if you have an optional positional-only
    parameter, all your normal parameters must be optional too. This rule does not
    affect keyword-only parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These rules can be a bit tricky to understand without an example, so let us
    look at a couple of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the order of the parameters in the function definition. The execution
    of this yields the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now look at an example with keyword-only parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have both positional-only and keyword-only parameters in the function
    declaration: `a` is positional-only, while `d` and `e` are keyword-only. They
    come after the `*args` variable positional argument, and it would be the same
    if they came right after a single `*` (in which case there would not be any variable
    positional parameter). The execution of this yields the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: One other thing to note is the names we gave to the variable positional and
    keyword parameters. You are free to choose differently but be aware that `args`
    and `kwargs` are the conventional names given to these parameters, at least generically.
  prefs: []
  type: TYPE_NORMAL
- en: More signature examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To briefly recap on function signatures that use the positional- and keyword-only
    specifiers, here are some further examples. Omitting the variable positional and
    keyword parameters, for brevity, we are left with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: First, we have positional-only, then positional or keyword parameters, and finally
    keyword-only ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other valid signatures are presented below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the above are valid signatures, while the following would be invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You can read about the grammar specifications in the official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/reference/compound_stmts.html#function-definitions](https://docs.python.org/3/reference/compound_stmts.html#function-definitions)'
  prefs: []
  type: TYPE_NORMAL
- en: A useful exercise for you at this point would be to implement any of the above
    example signatures, print out the values of those parameters, like we have done
    in previous exercises, and play around passing arguments in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid the trap! Mutable defaults
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One thing to be aware of, in Python, is that default values are created at
    definition time; therefore, subsequent calls to the same function will possibly
    behave differently according to the mutability of their default values. Let us
    look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Both parameters have mutable default values. This means that, if you affect
    those objects, any modification will stick around in subsequent function calls.
    See if you can understand the output of those calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'While this behavior may seem weird at first, it actually makes sense, and it
    is very handy—when using **memoization** techniques, for example. Even more interesting
    is what happens when, between the calls, we introduce one that does not use defaults,
    such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this code, this is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This output shows us that the defaults are retained even if we call the function
    with other values. One question that comes to mind is, how do I get a fresh empty
    value every time? Well, the convention is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note that, by using the preceding technique, if `a` is not passed when calling
    the function, we always get a brand new, empty list.
  prefs: []
  type: TYPE_NORMAL
- en: After a thorough exposition of input parameters, it is now time to look at the
    other side of the coin, returning output values.
  prefs: []
  type: TYPE_NORMAL
- en: Return values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already said that to return something from a function we need to use
    the `return` statement, followed by what we want to return. There can be as many
    `return` statements as needed in the body of a function.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if within the body of a function we do not return anything,
    or we invoke a bare `return` statement, the function will return `None` . This
    behavior is harmless when it is not needed, but allows for interesting patterns,
    and confirms Python as a very consistent language.
  prefs: []
  type: TYPE_NORMAL
- en: 'We say it is harmless because you are never forced to collect the result of
    a function call. We will show you what we mean with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that the whole body of the function is composed only of the `pass` statement.
    As the official documentation tells us, `pass` is a null operation, as, when it
    is executed, nothing happens. It is useful as a placeholder when a statement is
    required syntactically but no code needs to be executed. In other languages, we
    would probably just indicate that with a pair of curly brackets ( `{}` ), which
    define an *empty scope* ; but in Python, a scope is defined by indenting code,
    therefore a statement such as `pass` is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also that the first call to `func()` returns a value ( `None` ) that
    we do not collect. As we mentioned before, collecting the return value of a function
    call is not mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see a more interesting example. Remember that, in *Chapter 1* , *A Gentle
    Introduction to Python* , we talked about the *factorial* function. Let us write
    our own implementation here (for simplicity, we will assume the function is always
    called correctly with appropriate values, so we do not need to sanity-check the
    input argument):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have two points of return. If `n` is either `0` or `1` , we return
    `1` . Otherwise, we perform the required calculation and return `result` .
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, it is common to use the `in` operator to do a membership check,
    as we did in the preceding example, instead of the more verbose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now try to write this function a little bit more succinctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This simple example shows how Python is both elegant and concise. This implementation
    is readable even if we have never seen `reduce()` or `mul()` . If you cannot read
    or understand it, set aside a few minutes, and do some research in the Python
    documentation until its behavior is clear to you. Being able to look up functions
    in the documentation and understand code written by someone else is a task that
    every developer needs to be able to perform.
  prefs: []
  type: TYPE_NORMAL
- en: To this end, make sure you look up the `help()` function, which proves quite
    helpful when exploring with the console.
  prefs: []
  type: TYPE_NORMAL
- en: Returning multiple values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To return multiple values is easy: you just use tuples. Let us look at a simple
    example that mimics the `divmod()` built-in function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We could have wrapped the part that is highlighted in the preceding code within
    brackets, but there is no need for that. The preceding function returns both the
    result and the remainder of the division, at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: In the source code for this example, we have left a simple example of a test
    function to make sure the code is doing the correct calculation.
  prefs: []
  type: TYPE_NORMAL
- en: A few useful tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When writing functions, it is very useful to follow guidelines so that you
    write them well. We will quickly point some of them out:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functions should do one thing** : Functions that do one thing are easy to
    describe in one short sentence; functions that do multiple things can be split
    into smaller functions that do one thing. These smaller functions are usually
    easier to read and understand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions should be small** : The smaller they are, the easier it is to test
    and write them so that they do one thing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The fewer input parameters, the better** : Functions that take a lot of parameters
    quickly become hard to manage (among other issues).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions should be consistent in their return values** : Returning `False`
    and returning `None` are not the same thing, even if, within a Boolean context,
    they both evaluate to `False` . `False` means that we have information ( `False`
    ), while `None` means that there is no information. Try writing functions that
    return in a consistent way, no matter what happens in their logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions should have no side effects** : In functional programming, there
    is the concept of **pure functions** . This type of function adheres to two main
    principles:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deterministic output** : This means that given the same set of inputs, the
    output produced will always be the same. In other words, the function’s behavior
    is not dependent on any external or global state that might change during execution.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No side effects** : This means that pure functions do not cause any observable
    side effects in the system. That is, they do not alter any external state, like
    modifying global variables or performing I/O operations like reading from or writing
    to a file or the display.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: While you should aim to write pure functions whenever possible, it is important
    that those you write should at least have no side effects. They should not affect
    the value of the arguments they are called with.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is probably the hardest statement to understand at this point, so we will
    give you an example using lists. In the following code, note how `numbers` is
    not sorted by the `sorted()` function, which returns a sorted copy of `numbers`
    . Conversely, the `list.sort()` method is acting on the `numbers` object itself,
    and that is fine because it is a method (a function that belongs to an object
    and therefore has the right to modify it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Follow these guidelines and you will automatically shield yourself from certain
    types of bugs.
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 3* of *Clean Code* , by Robert C. Martin, is dedicated to functions,
    and it is one of the best sets of guidelines we have ever read on the subject.'
  prefs: []
  type: TYPE_NORMAL
- en: Recursive functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a function calls itself to produce a result, it is said to be **recursive**
    . Sometimes recursive functions are very useful, in that they make it easier to
    write the logic. Some algorithms are very easy to write using recursion, while
    others are not. There is no recursive function that cannot be rewritten in an
    iterative fashion, so it is usually up to the programmer to choose the best approach
    for the case at hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of a recursive function usually has two sections: one where the return
    value depends on a subsequent call to itself, and one where it does not (called
    the **base case** ).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we can consider the (hopefully now familiar) **factorial** function,
    *N!* . The base case is when *N* is either 0 or 1—the function returns `1` with
    no need for further calculation. On the other hand, in the general case, *N!*
    returns the product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If you think about it, *N!* can be rewritten like this: *N! = (N-1)! * N* .
    As a practical example, consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us write this down in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Recursive functions are often used when writing algorithms, and they can be
    really fun to write. As an exercise, try to solve a couple of simple problems
    using both a recursive and an iterative approach. Good candidates for practice
    might be calculating Fibonacci numbers or the length of a string—things like that.
  prefs: []
  type: TYPE_NORMAL
- en: When writing recursive functions, always consider how many nested calls you
    make, since there is a limit. For further information on this, check out `sys.getrecursionlimit()`
    and `sys.setrecursionlimit()` .
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One last type of function that we want to talk about is **anonymous** functions.
    These functions, which are called **lambdas** in Python, are usually used when
    a fully-fledged function with its own name would be overkill, and all we want
    is a quick, simple one-liner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we wanted a list of all the numbers up to a certain value of *N*
    that are also multiples of five. We could use the `filter()` function for this,
    which will require a function and an iterable as input. The return value is a
    filter object that, when iterated over, yields the elements from the input iterable
    for which the function returns `True` . Without using an anonymous function, we
    might do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how we use `is_multiple_of_five()` to filter through the first *n* natural
    numbers. This seems a bit excessive—the task is simple and we do not need to keep
    the `is_multiple_of_five()` function around for anything else. Let us rewrite
    it using a lambda function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic is the same, but the filtering function is now a lambda. Defining
    a lambda is very easy and follows this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'A function object is returned, which is equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Note that optional parameters are indicated following the common syntax of wrapping
    them in square brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at another couple of examples of equivalent functions, defined
    in both forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The preceding examples are very simple. The first one adds two numbers, and
    the second one produces the uppercase version of a string. Note that we assigned
    what is returned by the `lambda` expressions to a name ( `adder_lambda` , `to_upper_lambda`
    ), but there is no need for that when you use lambdas in the way we did in the
    `filter()` example.
  prefs: []
  type: TYPE_NORMAL
- en: Function attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every function is a fully fledged object and, as such, it has several attributes.
    Some of them are special and can be used in an introspective way to inspect the
    function object at runtime. The following script is an example that shows a few
    of them and how to display their value for an example function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We used the built-in `getattr()` function to get the value of those attributes.
    `getattr(obj, attribute)` is equivalent to `obj.attribute` and comes in handy
    when we need to dynamically get an attribute at runtime, taking the name of the
    attribute from a variable (as in this example). Running this script yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We have omitted the value of the `__globals__` attribute, as it was too big.
    An explanation of the meaning of this attribute can be found in the *Callable
    types* section of the *Python Data Model* documentation page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy](https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy)'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the built-in `dir()` function to get a list of all the attributes
    of any object.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to notice in the previous example is the use of this clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This line makes sure that whatever follows is only executed when the module
    is run directly. When you run a Python script, Python sets the `__name__` variable
    to `"__main__"` in that script. Conversely, when you import a Python script as
    a module into another script, the `__name__` variable is set to the name of the
    script/module being imported.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python comes with a lot of built-in functions. They are available anywhere,
    and you can get a list of them by inspecting the `builtins` module with `dir(__builtins__)`
    , or by going to the official Python documentation. Unfortunately, we do not have
    the room to go through all of them here. We have already seen some of them, such
    as `any` , `bin` , `bool` , `divmod` , `filter` , `float` , `getattr` , `id` ,
    `int` , `len` , `list` , `min` , `print` , `set` , `tuple` , `type` , and `zip`
    , but there are many more, which you should read about at least once. Get familiar
    with them, experiment, write a small piece of code for each of them, and make
    sure you have them at your fingertips so that you can use them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a list of built-in functions in the official documentation, here:
    [https://docs.python.org/3/library/functions.html](https://docs.python.org/3/library/functions.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Documenting your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are big fans of code that does not need documentation. When we write elegant
    code, following established principles, the code should come out as self-explanatory,
    with documentation being almost unnecessary. Nevertheless, adding a docstring
    to a function, or a comment with important information, can be very useful.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the guidelines for documenting Python in PEP 257 – Docstring conventions
    at [https://peps.python.org/pep-0257/](https://peps.python.org/pep-0257/) , but
    we will show you the basics here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python is documented with strings, which are aptly called **docstrings** .
    Any object can be documented, and we can use either one-line or multi-line docstrings.
    One-liners are very simple. They should not provide another signature for the
    function, but instead state its purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Using triple double-quoted strings allows you to expand easily later. Use sentences
    that end in a period, and do not leave blank lines before or after.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiline comments are structured in a similar way. There should be a one-liner
    that briefly gives you the gist of what the object is about, and then a more verbose
    description. As an example, we have documented a fictitious `connect()` function,
    using the **Sphinx** notation, in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Sphinx is one of the most widely used tools for creating Python documentation—in
    fact, the official Python documentation was written with it. It is definitely
    worth spending some time checking it out.
  prefs: []
  type: TYPE_NORMAL
- en: The `help()` built-in function, which is intended for interactive use, creates
    a documentation page for an object using its docstring.
  prefs: []
  type: TYPE_NORMAL
- en: Importing objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know a lot about functions, let us look at how to use them. The
    whole point of writing functions is to be able to reuse them later and, in Python,
    this translates to importing them into the namespace where they are needed. There
    are many ways to import objects into a namespace, but the most common ones are
    `import module_name` and `from module_name import function_name` . Of course,
    these are quite simplistic examples, but bear with us for the time being.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `import module_name` form finds the `module_name` module and defines a
    name for it in the local namespace, where the `import` statement is executed.
    The `from module_name import identifier` form is a little bit more complicated
    than that but basically does the same thing. It finds `module_name` and searches
    for an attribute (or a submodule) and stores a reference to `identifier` in the
    local namespace. Both forms have the option to change the name of the imported
    object using the `as` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Just to give you a flavor of what importing looks like, here is an example
    from a test module of one of Fabrizio’s projects (notice that the blank lines
    between blocks of imports follow the guidelines from PEP 8 at [https://peps.python.org/pep-0008/#imports](https://peps.python.org/pep-0008/#imports)
    : standard library first, then third party, and finally local code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: When we have a structure of files starting in the root of our project, we can
    use the dot notation to get to the object we want to import into our current namespace,
    be it a package, a module, a class, a function, or anything else.
  prefs: []
  type: TYPE_NORMAL
- en: The `from module import` syntax also allows a catch-all clause, `from module
    import *` , which is sometimes used to get all the names from a module into the
    current namespace at once. This practice is frowned upon for several reasons,
    relating to performance and the risk of silently shadowing other names. You can
    read all that there is to know about imports in the official Python documentation
    but, before we leave the subject, let us give you a better example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we have defined a couple of functions, `square(n)` and `cube(n)`
    , in a module, `funcdef.py` , which is in the `util` folder. We want to use them
    in a couple of modules that are at the same level as the `util` folder, called
    `func_import.py` and `func_from.py` . Showing the tree structure of that project
    produces something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Before we show you the code of each module, please remember that in order to
    tell Python that it is actually a package, we need to put an `__init__.py` module
    in it.
  prefs: []
  type: TYPE_NORMAL
- en: There are two things to note about the `__init__.py` file. First, it is a fully
    fledged Python module so you can put code into it as you would with any other
    module. Second, as of Python 3.3, its presence is no longer required to make a
    folder be interpreted as a Python package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Both these files, when executed, print `100` and `1000` . You can see how differently
    we then access the `square` and `cube` functions, according to how and what we
    imported in the current scope.
  prefs: []
  type: TYPE_NORMAL
- en: Relative imports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The type of import we have seen so far is called an **absolute import** ; that
    is, it defines the whole path of either the module that we want to import or from
    which we want to import an object. There is another way of importing objects into
    Python, which is called a **relative import** . Relative imports are done by adding
    as many leading dots in front of the module as the number of folders we need to
    backtrack, to find what we are searching for. Simply put, it is something such
    as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Relative imports are quite useful when restructuring projects. Not having the
    full path in the imports allows the developer to move things around without having
    to rename too many of those paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a complete explanation of relative imports, refer to PEP 328: [https://peps.python.org/pep-0328/](https://peps.python.org/pep-0328/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: In later chapters, we will create projects using different libraries and use
    several different types of imports, including relative ones, so make sure you
    take a bit of time to read up about them in the official Python documentation.
  prefs: []
  type: TYPE_NORMAL
- en: One final example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we finish off this chapter, let us go through one last example. We could
    write a function to generate a list of prime numbers up to a limit; we have already
    seen the code for this in *Chapter 3* , *Conditionals and Iteration* , so let
    us make it a function and, to keep it interesting, let us optimize it a bit.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we do not need to divide by all the numbers from *2* to *N-1*
    to decide whether a number, *N* , is prime. We can stop at *√N* (the square root
    of *N* ). Moreover, we do not need to test the division for all the numbers from
    *2* to *√N* , as we can just use the primes in that range. We leave it up to you
    to figure out the math for why this works, if you are interested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see how the code changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The code is the same as that in the previous chapter. We have changed the division
    algorithm so that we only test divisibility using the previously calculated primes,
    and we stopped once the testing divisor was greater than the root of the candidate.
    We used the `primelist` result list to get the primes for the division and calculated
    the root value using a fancy formula, the integer value of the ceiling of the
    root of the candidate. While a simple `int(k ** 0.5) + 1` would have also served
    our purpose, the formula we chose is cleaner and requires a couple of imports,
    which is what we wanted to show. Check out the functions in the `math` module—they
    are very interesting!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the world of functions. They are very important
    and, from now on, we will use them in virtually everything we do. We talked about
    the main reasons for using them, the most important of which are code reuse and
    implementation hiding.
  prefs: []
  type: TYPE_NORMAL
- en: We saw that a function object is like a box that takes optional inputs and may
    produce outputs. We can feed input arguments to a function in many different ways,
    using positional and keyword arguments, and using variable syntax for both types.
  prefs: []
  type: TYPE_NORMAL
- en: You should now know how to write a function, document it, import it into your
    code, and call it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be picking up the pace a little bit, so we suggest
    you spend a bit of time consolidating and enriching the knowledge you have gathered
    so far by experimenting with code and reading the Python official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_4.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/QR_Code119001106417026468.png)'
  prefs: []
  type: TYPE_IMG
