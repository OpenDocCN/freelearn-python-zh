- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions, the Building Blocks of Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ”To create architecture is to put in order. Put what in order? Functions and
    objects.”
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Le Corbusier
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the previous chapters, we have seen that everything is an object in Python,
    and functions are no exception. But what exactly is a function? A function is
    *a block of reusable code designed to perform a specific task or a related group
    of tasks* . This unit can then be imported and used wherever it is needed. There
    are many advantages to using functions in your code, as we will see shortly.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Functions—what they are and why we should use them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scopes and name resolution
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function signatures—input parameters and return values
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursive and anonymous functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing objects for code reuse
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We believe the saying *a picture is worth a thousand words* is particularly
    true when explaining functions to someone who is new to this concept, so please
    take a look at the following figure:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B30992_04_01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: An example of a function'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a function is a block of instructions, packaged as a whole,
    like a box. Functions can accept input parameters and produce output values. Both
    of these are optional, as we will see in the examples in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: A function in Python is defined using the `def` keyword, after which the name
    of the function follows, terminated by a pair of parentheses (which may or may
    not contain input parameters); a colon ( `:` ) then signals the end of the function
    definition. Immediately afterward, indented by four spaces, we find the body of
    the function, which is the set of instructions that the function will execute
    when called.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Note that the indentation by four spaces is not mandatory, but it is the number
    of spaces suggested by PEP 8, and, in practice, it is the most widely used spacing
    measure.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: A function may or may not return an output. If a function wants to return an
    output, it does so by using the `return` keyword, followed by the desired output.
    You may have noticed the little `*` after *Optional* in the output section of
    the preceding diagram. This is because a function always returns something in
    Python, even if you do not explicitly use the `return` statement. If the function
    has no `return` statement in its body, or no value is given to the `return` statement
    itself, the function returns `None` .
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'This design choice is rooted in several reasons, the most important of which
    are:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplicity and consistency** : Whether the function is explicitly returning
    a value or not, its behavior is consistent.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity reduction** : Several languages make a distinction between functions
    (which return a value) and **procedures** (which do not). Functions in Python
    can act as both, with no need for separate constructs. This minimizes the number
    of concepts a programmer must learn.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency for multiple pathways** : Functions with multiple conditional
    branches will return `None` when no other return statement is executed. `None`
    , therefore, is a useful default value.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多路径一致性**：具有多个条件分支的函数在没有执行其他返回语句时将返回`None`。因此，`None`是一个有用的默认值。'
- en: The list provided demonstrates the multitude of factors that can influence an
    apparently simple design decision. It is the careful and deliberate choices underpinning
    Python’s design that contribute to its elegance, simplicity, and versatility.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表展示了众多可能影响看似简单的设计决策的因素。正是这些支撑Python设计的精心和深思熟虑的选择，使其具有优雅、简单和多功能性。
- en: Why use functions?
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用函数？
- en: 'Functions are among the most important concepts and constructs of any language,
    so let us give you a few reasons why we need them:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是任何语言中最重要和最基本的概念和结构之一，所以让我们给你几个为什么我们需要它们的原因：
- en: They reduce code duplication in a program. Encapsulating the instructions for
    a task in a function that we can import and call whenever we want allows us to
    avoid duplicating the implementation.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们减少了程序中的代码重复。将任务的指令封装在我们可以导入和随时调用的函数中，使我们能够避免重复实现。
- en: They help in splitting a complex task or procedure into smaller blocks, each
    of which becomes a function.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有助于将复杂任务或过程拆分成更小的块，每个块都成为一个函数。
- en: They hide the implementation details from their users.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们隐藏了实现细节，不让用户知道。
- en: They improve traceability.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提高了可追溯性。
- en: They improve readability.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提高了可读性。
- en: Let us now look at a few examples to get a better understanding of each point.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些例子，以更好地理解每个要点。
- en: Reducing code duplication
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少代码重复
- en: Imagine that you are writing a piece of scientific software, and you need to
    calculate prime numbers up to a certain limit—as we did in the previous chapter.
    You have an algorithm to calculate them, so you copy it and paste it to wherever
    you need to use it. One day, though, a colleague gives you a more performant algorithm
    to calculate primes. At this point, you need to go over your whole code base and
    replace the old code with the new one.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在编写一段科学软件，你需要计算到一定限制的素数——就像我们在上一章中做的那样。你有一个计算它们的算法，所以你把它复制并粘贴到你需要使用它的任何地方。然而，有一天，一个同事给你一个更高效的算法来计算素数。在这个时候，你需要遍历整个代码库，用新代码替换旧代码。
- en: This procedure is quite error-prone. You can easily remove parts of the surrounding
    code by mistake or fail to remove some of the code you meant to replace. You also
    risk missing some of the places where the prime calculation is done, leaving your
    software in an inconsistent state where the same action is performed in different
    ways. What if, instead of replacing code with a better version of it, you need
    to fix a bug and you miss a spot. That would be even worse. What if the names
    of the variables in the old algorithm are different from those used in the new
    one? That will also complicate things.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程很容易出错。你可能会不小心删除周围代码的一部分，或者未能删除你打算替换的某些代码。你还可能错过一些主要计算完成的地方，导致你的软件处于不一致的状态，同一操作以不同的方式执行。如果，你不仅需要用更好的版本替换代码，还需要修复一个错误而你却错过了某个地方，那会变得更糟。如果旧算法中变量的名称与新的不同，这也会使事情变得复杂。
- en: To avoid all that, you write a function, `get_prime_numbers(upto)` , and use
    it anywhere you need to calculate a list of primes. When your colleague gives
    you a better implementation, all you need to do is replace the body of that function
    with the new code. The rest of the software will automatically adapt since it
    is just calling the function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免所有这些，你编写一个函数，`get_prime_numbers(upto)`，并在你需要计算素数列表的任何地方使用它。当你的同事给你一个更好的实现时，你只需要替换那个函数的主体为新代码。其余的软件将自动适应，因为它只是调用这个函数。
- en: Your code will be shorter and free from inconsistencies between old and new
    ways of performing a task. You are also less likely to leave behind undetected
    bugs that arise from copy-and-paste failures or oversights.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码会更短，并且不会出现旧方法和新方法执行任务时的一致性问题。你也更不可能留下由于复制粘贴失败或疏忽而产生的未被发现的问题。
- en: Splitting a complex task
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将复杂任务拆分
- en: Functions are also useful for splitting long or complex tasks into smaller ones.
    The result is that the code benefits from it in several ways, including readability,
    testability, and reusability.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 函数还有助于将长或复杂的任务拆分成更小的任务。结果是代码在可读性、可测试性和可重用性等方面受益。
- en: To give you a simple example, imagine that you are preparing a report. Your
    code needs to fetch data from a data source, parse it, filter it, and polish it,
    and then a whole series of algorithms needs to be run against it, to produce the
    results that will be written into the report. It is common to see procedures like
    this that are just one big `do_report(data_source)` function. There might be hundreds
    of lines of code that run before we finally produce the report.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给你一个简单的例子，想象你正在准备一份报告。你的代码需要从数据源获取数据，解析它，过滤它，并对其进行润色，然后需要对它运行一系列算法，以生成将被写入报告的结果。常见的情况是，这样的流程通常只有一个大的`do_report(data_source)`函数。在最终生成报告之前，可能会有数百行代码需要运行。
- en: 'Inexperienced programmers, not well versed in the art of crafting simple, well
    structured code, may produce functions with hundreds of lines of code. They are
    hard to follow through, to find the places where things are changing context (such
    as finishing one task and starting the next one). Let us show you a better approach
    instead:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏经验的程序员，如果不擅长编写简单、结构良好的代码，可能会编写出数百行代码的函数。这些函数很难跟踪，很难找到事物改变上下文的地方（例如，完成一项任务并开始下一项任务）。让我们展示一个更好的方法：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The previous example is fictitious, of course, but can you see how easy it would
    be to go through the code? If the end result looks wrong, it would be easy to
    debug each of the single data outputs in the `do_report()` function. Moreover,
    it is even easier to exclude part of the process temporarily from the whole procedure
    (you just need to comment out the parts that you need to suspend). Code like this
    is easier to deal with.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子当然是虚构的，但你能否看出遍历代码有多容易？如果最终结果看起来不正确，那么在`do_report()`函数中调试每个单独的数据输出将会很容易。此外，从整个流程中临时排除部分过程（你只需注释掉需要暂停的部分）也更为简单。这样的代码更容易处理。
- en: Hiding implementation details
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏实现细节
- en: Let us stay with the preceding example to talk about this point as well. We
    can see that, by going through the code of the `do_report()` function, we can
    get a surprisingly good understanding without reading one single line of implementation.
    This is because functions hide the implementation details.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续之前的例子来讨论这个点。我们可以看到，通过遍历`do_report()`函数的代码，我们可以在不阅读任何一行实现代码的情况下获得一个令人惊讶的理解。这是因为函数隐藏了实现细节。
- en: This feature means that, if we do not need to delve into the details, we are
    not forced to, in the way that we would be if `do_report()` was just one big,
    long function. To understand what was going on, we would have to read and understand
    every single line of its code. When it is broken down into smaller functions,
    we do not necessarily need to read every line of every one of them to understand
    what the code does. This reduces the time we spend reading the code and, since
    in a professional environment reading code takes much more time than writing it,
    it is important to reduce it to a minimum.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性意味着，如果我们不需要深入了解细节，我们就不必像如果`do_report()`只是一个又长又大的函数那样被迫去深入。要理解发生了什么，我们不得不阅读并理解它的每一行代码。当它被分解成更小的函数时，我们不一定需要阅读每一个函数的每一行代码来理解代码的功能。这减少了我们阅读代码所花费的时间，因为在专业环境中阅读代码所花费的时间比编写代码多得多，因此将其减少到最低限度是很重要的。
- en: Improving readability
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高可读性
- en: Programmers sometimes do not see the point in writing a function with a body
    of one or two lines of code, so let us look at an example that shows you why you
    should probably still do it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员有时看不到编写一个只有一或两行代码的函数的意义，所以让我们看看一个例子，说明为什么你可能仍然应该这样做。
- en: 'Imagine that you need to multiply two matrices, like in the example below:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你需要乘以两个矩阵，就像下面的例子：
- en: '![img](img/B30992_04_001.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B30992_04_001.png)'
- en: 'Would you prefer to have to read this code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否更喜欢阅读以下代码：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or, would you prefer this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你更喜欢这个：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is much easier to understand that `c` is the result of the multiplication
    of `a` and `b` in the second example, and it is much easier to read the code.
    If we do not need to modify that multiplication logic, we do not even need to
    go into the implementation details of `matrix_mul()` . Therefore, readability
    is improved here while, in the first snippet, we would have to spend time trying
    to understand what that complicated list comprehension is doing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，理解`c`是`a`和`b`相乘的结果要容易得多，阅读代码也更容易。如果我们不需要修改这个乘法逻辑，我们甚至不需要进入`matrix_mul()`函数的实现细节。因此，在这里可读性得到了提高，而在第一个片段中，我们可能需要花费时间试图理解那个复杂的列表推导式在做什么。
- en: Do not worry if you do not understand list comprehensions, as we will study
    them in *Chapter 5* , *Comprehensions and Generators* .
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不理解列表推导式，请不要担心，我们将在*第五章*，*推导式和生成器*中学习它们。
- en: Improving traceability
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高可追溯性
- en: 'Imagine that we have written some code for an e-commerce website. We display
    the product prices on several pages. Imagine that the prices in the database are
    stored with no VAT (sales tax), but we want to display them on the website with
    VAT at 20%. Here are a few ways of calculating the VAT-inclusive price from the
    VAT-exclusive price:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们为电子商务网站编写了一些代码。我们在几个页面上显示产品价格。想象一下，数据库中的价格没有包含增值税（销售税），但我们想在网站上以20%的增值税显示它们。这里有几种从不含增值税价格计算含增值税价格的方法：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These four different ways of calculating a VAT-inclusive price are all perfectly
    acceptable; we have encountered all of them in the professional code that we have
    worked on over the years.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这四种计算含增值税价格的方法都是完全可以接受的；我们在过去几年中遇到的所有专业代码中都有遇到过。
- en: Now, imagine that we start selling products in different countries, and some
    of them have different VAT rates, so we need to refactor the code (throughout
    the website) in order to make that VAT calculation dynamic.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们开始在多个国家销售产品，其中一些国家有不同的增值税率，因此我们需要重构代码（在整个网站上）以使增值税计算动态化。
- en: How do we trace all the places in which we are performing a VAT calculation?
    Coding today is a collaborative task and we cannot be sure that the VAT has been
    calculated using only one of those forms. It is going to be difficult.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何追踪所有执行增值税计算的地方？现在的编码是一个协作任务，我们无法确定增值税是否只使用其中一种形式进行计算。这将是一件困难的事情。
- en: 'So, let us write a function that takes the input values `vat` and `price` (VAT-exclusive)
    and returns a VAT-inclusive price:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们编写一个函数，该函数接受输入值`vat`和`price`（不含增值税）并返回含增值税的价格：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now we can import that function and use it in any place on the website where
    we need to calculate a VAT-inclusive price, and when we need to trace those calls,
    we can search for `calculate_price_with_vat` .
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以导入这个函数，并在网站上任何需要计算含增值税价格的地方使用它，当我们需要追踪这些调用时，我们可以搜索`calculate_price_with_vat`。
- en: Note that, in the preceding example, `price` is assumed to be VAT-exclusive,
    and `vat` is a percentage value (for example, 19, 20, or 23).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的例子中，`price`被认为是不含增值税的，而`vat`是一个百分比值（例如，19、20或23）。
- en: Scopes and name resolution
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围和命名解析
- en: 'In *Chapter 1* , *A Gentle Introduction to Python* , we discussed scopes and
    namespaces. We are going to expand on that concept now. Finally, we can talk in
    terms of functions, and this will make everything easier to understand. Let us
    start with a simple example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第一章*，*Python的温和介绍*中，我们讨论了范围和命名空间。现在我们将扩展这个概念。最后，我们可以用函数来讨论，这将使一切更容易理解。让我们从一个简单的例子开始：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We defined the `test` name in two different places in the previous example—it
    is actually in two different scopes. One is the global scope ( `test = 0` ), and
    the other is the local scope of the `my_function()` function ( `test = 1` ). If
    we execute the code, we will see this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在两个不同的地方定义了`test`这个名字——它实际上是在两个不同的范围内。一个是全局范围（`test = 0`），另一个是`my_function()`函数的局部范围（`test
    = 1`）。如果我们执行代码，我们会看到这个：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It is clear that `test = 1` shadows the `test = 0` assignment in `my_function()`
    . In the global context, `test` is still `0` , as you can see from the output
    of the program, but we define the `test` name again in the function body, and
    we set it to point to the integer `1` . Both of the `test` names therefore exist:
    one in the global scope, pointing to an int object with a value of `0` , and the
    other in the `my_function()` scope, pointing to an `int` object with a value of
    `1` . Let us comment out the line with `test = 1` . Python searches for the `test`
    name in the next enclosing namespace (recall the **LEGB** rule: **local** , **enclosing**
    , **global** , **built-in** , described in *Chapter 1* , *A Gentle Introduction
    to Python* ) and, in this case, we will see the value `0` printed twice. Try it
    in your code.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，`test = 1`遮蔽了`my_function()`中的`test = 0`赋值。在全局范围内，`test`仍然是`0`，正如你可以从程序输出中看到的那样，但我们再次在函数体中定义了`test`名称，并将其设置为指向整数`1`。因此，两个`test`名称都存在：一个在全局作用域中，指向值为`0`的int对象，另一个在`my_function()`作用域中，指向值为`1`的`int`对象。让我们注释掉包含`test
    = 1`的行。Python会在下一个封装的作用域中搜索`test`名称（回想一下**LEGB**规则：**local**，**enclosing**，**global**，**built-in**，在*第一章*，*Python的温柔介绍*中描述），在这种情况下，我们会看到`0`被打印两次。在你的代码中试一试。
- en: 'Now, let us give you a more complex example with nested functions:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们给你一个更复杂的例子，包含嵌套函数：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we have two levels of shadowing. One level is in the
    `outer()` function, and the other one is in the `inner()` function.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有两个层次的遮蔽。一个层次在`outer()`函数中，另一个层次在`inner()`函数中。
- en: 'If we run the code, we get:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行代码，我们会得到：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Try commenting out the `test = 1` line. Can you figure out what the result will
    be? When reaching the `print('outer:', test)` line, Python will have to look for
    `test` in the next enclosing scope; therefore it will find and print `0` , instead
    of `1` . Make sure you comment out `test = 2` as well, to see whether you understand
    what happens and whether the LEGB rule is clear to you, before proceeding.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试注释掉`test = 1`行。你能想出结果会是什么吗？当到达`print('outer:', test)`行时，Python将不得不在下一个封装的作用域中寻找`test`；因此，它会找到并打印`0`，而不是`1`。在继续之前，确保你也注释掉了`test
    = 2`，以确保你理解发生了什么，以及LEGB规则是否对你来说很清晰。
- en: Another thing to note is that Python gives us the ability to define a function
    in another function. The `inner()` function’s name is defined within the namespace
    of the `outer()` function, exactly as would happen with any other name.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的事情是，Python给了我们定义一个函数在另一个函数中的能力。`inner()`函数的名称是在`outer()`函数的作用域中定义的，这与任何其他名称的情况完全一样。
- en: The global and nonlocal statements
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局和非局部语句
- en: 'In the preceding example, we can alter what happens to the shadowing of the
    test name by using one of these two special statements: `global` and `nonlocal`
    . As you can see, when we define `test = 2` in the `inner()` function, we do not
    overwrite `test` in the `outer()` function or in the global scope.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们可以通过使用这两个特殊语句之一来改变对test名称的遮蔽：`global`和`nonlocal`。正如你所看到的，当我们定义`test
    = 2`在`inner()`函数中时，我们没有覆盖`outer()`函数或全局作用域中的`test`。
- en: We can get read access to those names if we use them in a nested scope that
    does not define them, but we cannot modify them because when we write an assignment
    instruction, we are actually defining a new name in the current scope.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在不定义它们的嵌套作用域中使用这些名称，我们可以获取对这些名称的读取访问权限，但因为我们实际上在当前作用域中定义了一个新名称，所以我们不能修改它们。
- en: 'We can use the `nonlocal` statement to change this behavior. According to the
    official documentation:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`nonlocal`语句来改变这种行为。根据官方文档：
- en: ”The `nonlocal` statement causes the listed identifiers to refer to previously
    bound variables in the nearest enclosing scope excluding globals.”
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “`nonlocal`语句使列出的标识符引用最近封装作用域中先前绑定的变量，但不包括全局变量。”
- en: 'Let us introduce it in the `inner()` function and see what happens:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`inner()`函数中引入它，看看会发生什么：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice how in the body of the `inner()` function we have declared the `test`
    name to be `nonlocal` . Running this code produces the following result:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`inner()`函数体中我们如何声明`test`名称为`nonlocal`。运行此代码会产生以下结果：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By declaring `test` to be `nonlocal` in the `inner()` function, we actually
    bind the `test` name to the one declared in the `outer` function. If we removed
    the `nonlocal test` line from the `inner()` function and tried it inside the `outer()`
    function, we would get a `SyntaxError` , because the `nonlocal` statement works
    on enclosing scopes, but not in the global one.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Is there a way to get write access to that `test = 0` in the global namespace?
    Yes, we just need to use the `global` statement:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that we have now declared the `test` name to be `global` , which will
    bind it to the one we defined in the global namespace ( `test = 0` ). Run the
    code and you should get the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This shows that the name affected by the `test = 2` assignment is now the one
    in the `global` scope. This would also work in the `outer()` function because,
    in this case, we are referring to the global scope.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Try it for yourself and see what changes. Spend some time to get comfortable
    with scopes and name resolution—it is very important. As a bonus question, can
    you tell what would happen if you defined `inner()` outside `outer()` in the preceding
    examples?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Input parameters
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the beginning of this chapter, we saw that a function can take input parameters.
    Before we delve into all the possible types of parameters, let us make sure you
    have a clear understanding of what passing an argument to a function means. There
    are three key points to keep in mind:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Argument-passing is nothing more than assigning an object to a local variable
    name
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning an object to an argument name inside a function does not affect the
    caller
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing a mutable object argument in a function does affect the caller
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we explore the topic of arguments any further, please allow us to clarify
    the terminology a little. According to the official Python documentation:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: ”Parameters are defined by the names that appear in a function definition, whereas
    arguments are the values actually passed to a function when calling it. Parameters
    define what types of arguments a function can accept.”
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We will try to be precise when referring to parameters and arguments, but it
    is worth noting that they are sometimes used synonymously as well. Let us now
    look at some examples.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Argument-passing
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a look at the following code. We declare a name, `x` , in the global scope,
    then we declare a function, `func(y)` , and finally, we call it, passing `x` :'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When `func()` is called with `x` , within its local scope, a name, `y` , is
    created, and it is pointed to the same object that `x` is pointing to. This is
    better clarified in *Figure 4.2* (do not worry about the fact that this example
    was run with Python 3.11—this is a feature that has not changed).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B30992_04_02.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Understanding argument-passing with Python Tutor'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'The right-hand side of *Figure 4.2* depicts the state of the program when execution
    has reached the end, after `func()` has returned ( `None` ). Take a look at the
    **Frames** column, and note that we have two names, `x` and `func()` , in the
    global namespace ( **Global frame** ), pointing respectively to an **int** (with
    a value of `3` ) and to a `function` object. Right beneath it, in the rectangle
    titled **func** , we can see the function’s local namespace, in which only one
    name has been defined: `y` . Because we have called `func()` with `x` (line 6
    on the left side of the figure), `y` is pointing to the same object that `x` is.
    This is what happens under the hood when an argument is passed to a function.
    If we had used the name `x` instead of `y` in the function definition, things
    would have been exactly the same (but perhaps a bit confusing at first)—there
    would be a local `x` in the function, and a global `x` outside, as we saw in the
    *Scopes and name resolution* section previously in this chapter.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: So, in a nutshell, what really happens is that the function creates, in its
    local scope, the names defined as parameters and, when we call it, we tell Python
    which objects those names must be pointed toward.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Assignment to parameter names
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assignment to parameter names does not affect the caller. This is something
    that can be tricky to understand at first, so let us look at an example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, when we call the function with `func(x)` , the instruction
    `x = 7` is executed within the local scope of the `func()` function; the name
    `x` is pointed to an integer with a value of `7` , leaving the global `x` unaltered.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Changing a mutable object
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Changing a mutable object does affect the caller. This is important because
    although Python *appears to* behave differently with mutable objects, the behavior
    is, in fact, perfectly consistent. Let us look at an example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, we changed the original object. If you think about it, there
    is nothing weird in this behavior. When we call `func(x)` , name `x` in the function’s
    namespace is set to point to the same object as the global `x` . Within the body
    of the function, we are not changing the global `x` , in that we are not changing
    which object it points to. We are merely accessing the element at position 1 in
    that object and changing its value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember *point 2* in the *Input parameters* section: *Assigning an object
    to a parameter name within a function does not affect the caller* . If that is
    clear to you, the following code should not be surprising:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Look at the two lines we have highlighted. At first, like before, we just access
    the caller object again, at position 1, and change that value to number `42` .
    Then, we reassign `x` to point to the `'something else'` string. This leaves the
    caller unaltered and, in fact, the output is the same as that of the previous
    snippet.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Take your time to play around with this concept, and experiment with prints
    and calls to the `id()` function until everything is clear in your mind. This
    is one of the key aspects of Python and it must be very clear, otherwise you risk
    introducing subtle bugs into your code. Once again, the Python Tutor website (
    [http://www.pythontutor.com/](http://www.pythontutor.com/) ) will help you a lot
    by giving you a visual representation of these concepts.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细研究这个概念，并通过打印和调用 `id()` 函数进行实验，直到你心中的一切都清晰。这是 Python 的一个关键特性，它必须非常清晰，否则你可能会在代码中引入微妙的错误。再次强调，Python
    Tutor 网站（[http://www.pythontutor.com/](http://www.pythontutor.com/)）通过提供这些概念的可视化表示，将极大地帮助你。
- en: Now that we have a good understanding of input parameters and how they behave,
    let us look at the different ways of passing arguments to functions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很好地理解了输入参数及其行为，让我们看看传递参数给函数的不同方式。
- en: Passing arguments
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递参数
- en: 'There are four different ways of passing arguments to a function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 传递函数参数有四种不同的方式：
- en: Positional arguments
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置参数
- en: Keyword arguments
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字参数
- en: Iterable unpacking
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可迭代解包
- en: Dictionary unpacking
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典解包
- en: Let us look at them one by one.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一来看。
- en: Positional arguments
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位置参数
- en: 'When we call a function, each positional argument is assigned to the parameter
    in the corresponding *position* in the function definition:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用函数时，每个位置参数都被分配到函数定义中相应 *位置* 的参数：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is the most common way of passing arguments to functions (in some programming
    languages, this is the only way of passing arguments).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在某些编程语言中传递参数最常见的方式（在某些编程语言中，这是唯一的方式）。
- en: Keyword arguments
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关键字参数
- en: 'Keyword arguments in a function call are assigned to parameters using the `name=value`
    syntax:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用中的关键字参数使用 `name=value` 语法分配给参数：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When we use keyword arguments, the order of the arguments does not need to match
    the order of the parameters in the function definition. This can make our code
    easier to read and debug. We do not need to remember (or look up) the order of
    parameters in a function definition. We can look at a function call and immediately
    know which argument corresponds to which parameter.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用关键字参数时，参数的顺序不需要与函数定义中参数的顺序匹配。这可以使我们的代码更容易阅读和调试。我们不需要记住（或查找）函数定义中参数的顺序。我们可以查看函数调用，并立即知道哪个参数对应哪个参数。
- en: 'You can also use both positional and keyword arguments at the same time:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以同时使用位置参数和关键字参数：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Keep in mind, however, that **positional arguments always have to be listed
    before any keyword arguments** . For example, if you try something like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，**位置参数必须始终在关键字参数之前列出**。例如，如果你尝试这样做：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You will get the following error:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下错误：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Iterable unpacking
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可迭代解包
- en: 'Iterable unpacking uses the syntax `*iterable_name` to pass the elements of
    an *iterable* as positional arguments to a function:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代解包使用 `*iterable_name` 语法将可迭代对象的元素作为位置参数传递给函数：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is a very useful feature, particularly when we need to programmatically
    generate arguments for a function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有用的特性，尤其是在我们需要以编程方式为函数生成参数时。
- en: Dictionary unpacking
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典解包
- en: 'Dictionary unpacking is to keyword arguments what iterable unpacking is to
    positional arguments. We use the syntax `**dictionary_name` to pass keyword arguments,
    constructed from the keys and values of a dictionary, to a function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 字典解包对于关键字参数来说，就像可迭代解包对于位置参数一样。我们使用 `**dictionary_name` 语法将字典的键和值构造的关键字参数传递给函数：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Combining argument types
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结合参数类型
- en: We have already seen that positional and keyword arguments can be used together,
    as long as they are passed in the proper order. We can also combine unpacking
    (of both kinds) with normal positional and keyword arguments. We can even combine
    unpacking multiple iterables and dictionaries.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，位置参数和关键字参数可以一起使用，只要它们按照正确的顺序传递。我们还可以将解包（两种类型）与正常的位置参数和关键字参数结合使用。我们甚至可以将多个可迭代对象和字典进行解包。
- en: 'Arguments must be passed in the following order:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 参数必须按照以下顺序传递：
- en: 'First, positional arguments: both ordinary ( `name` ) and iterable unpacking
    ( `*name` )'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，位置参数：普通（`name`）和解包（`*name`）
- en: Next come keyword arguments ( `name=value` ), which can be mixed with iterable
    unpacking `(*name` )
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是关键字参数（`name=value`），它可以与可迭代解包 `(*name)` 混合使用
- en: Finally, there is dictionary unpacking ( `**name` ), which can be mixed with
    keyword arguments ( `name=value` )
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This will be much easier to understand with an example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: All the above calls to `func()` are equivalent and print `1 2 3 4 5 6` . Play
    around with this example until you are sure you understand it. Pay close attention
    to the errors you get when you get the order wrong.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The ability to unpack multiple iterables and dictionaries was introduced to
    Python by PEP 448. This PEP also introduced the ability to use unpacking in contexts
    other than just function calls. You can read all about it at [https://peps.python.org/pep-0448/](https://peps.python.org/pep-0448/)
    .
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'When combining positional and keyword arguments, it is important to remember
    that each parameter can only appear once in the argument list:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, we are passing two values for parameter `a` : the positional argument
    `2` and the keyword argument `a=1` . This is illegal, so we get an error when
    we try to run it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Defining parameters
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Function parameters can be classified into five groups.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Positional or keyword parameters: allow both positional and keyword arguments'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Variable positional parameters: collect an arbitrary number of positional arguments
    in a tuple'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Variable keyword parameters: collect an arbitrary number of keyword arguments
    in a dictionary'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Positional-only parameters: can only be passed as positional arguments'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keyword-only parameters: can only be passed as keyword arguments'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the parameters in the examples we have seen so far in this chapter are regular
    positional or keyword parameters. We have seen how they can be passed as both
    positional and keyword arguments. There is not much more to say about them, so
    let us look at the other categories. Before we do, though, let us briefly look
    at optional parameters.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Optional parameters
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Apart from the categories we have looked at here, parameters can also be classified
    as either *required* or *optional* . **Optional parameters** have a default value
    specified in the function definition. The syntax is `name=value` :'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, `a` is required, while `b` has the default value `4` and `c` has the default
    value `88` . It is important to note that, with the exception of keyword-only
    parameters, required parameters must always be to the left of all optional parameters
    in the function definition. Try removing the default value from `c` in the above
    example and see what happens.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Variable positional parameters
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes you may prefer not to specify the exact number of positional parameters
    to a function; Python provides you with the ability to do this by using **variable
    positional parameters** . Let us look at a very common use case, the `minimum()`
    function. This is a function that calculates the minimum of its input values:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, when we define a parameter with an asterisk, `*` , prepended
    to its name, we are telling Python that this parameter will collect a variable
    number of positional arguments when the function is called. Within the function,
    `n` is a tuple. Uncomment `print(type(n))` to see for yourself, and play around
    with it for a bit.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Note that a function can have at most one variable positional parameter—it would
    not make sense to have more. Python would have no way of deciding how to divide
    up the arguments between them. You also cannot specify a default value for a variable
    positional parameter. The default value is always an empty tuple.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Have you noticed how we checked whether `n` was not empty with a simple `if
    n:` ? This is because collection objects evaluate to `True` when non-empty, and
    otherwise `False` , in Python. This is the case for tuples, sets, lists, dictionaries,
    and so on.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: One other thing to note is that we may want to throw an error when we call the
    function with no parameters, instead of silently doing nothing. In this context,
    we are not concerned about making this function robust, but rather understanding
    variable positional parameters.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Did you notice that the syntax for defining variable positional parameters looks
    very much like the syntax for iterable unpacking? This is no coincidence. After
    all, the two features mirror each other. They are also frequently used together,
    since variable positional parameters save you from worrying about whether the
    length of the iterable you are unpacking matches the number of parameters in the
    function definition.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Variable keyword parameters
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Variable keyword parameters** are very similar to variable positional parameters.
    The only difference is the syntax ( `**` instead of `*` ) and the fact that they
    are collected in a dictionary:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can see that adding `**` in front of the parameter name in the function
    definition tells Python to use that name to collect a variable number of keyword
    parameters. As in the case of variable positional parameters, each function can
    have at most one variable keyword parameter—and you cannot specify a default value.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Just like variable positional parameters resemble iterable unpacking, variable
    keyword parameters resemble dictionary unpacking. Dictionary unpacking is also
    often used to pass arguments to functions with variable keyword parameters.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason why being able to pass a variable number of keyword arguments is
    so important may not be evident at the moment, so how about a more realistic example?
    Let us define a function that connects to a database: we want to connect to a
    default database by simply calling this function with no parameters. We also want
    to connect to any other database by passing to the function the appropriate parameters.
    Before you read on, try to spend a couple of minutes figuring out a solution by
    yourself:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that, in the function, we can prepare a dictionary of connection parameters
    ( `conn_params` ) using default values as fallbacks, allowing them to be overwritten
    if they are provided in the function call. There are better ways to do this with
    fewer lines of code, but we are not concerned with that right now. Running the
    preceding code yields the following result:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note the correspondence between the function calls and the output, and how default
    values are overridden according to what was passed to the function.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Positional-only parameters
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Starting from Python 3.8, PEP 570 ( [https://peps.python.org/pep-0570/](https://peps.python.org/pep-0570/)
    ) introduced **positional-only parameters** . There is a new function parameter
    syntax, `/` , indicating that a set of the function parameters must be specified
    positionally and *cannot* be passed as keyword arguments. Let us see a simple
    example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding example, we define a function, `func()` , which specifies
    three parameters: `a` , `b` , and `c` . The `/` in the function signature indicates
    that `a` and `b` must be passed positionally, that is, not by keyword.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'The last two lines in the example show that we can call the function passing
    all three arguments positionally, or we can pass `c` by keyword. Both cases work
    fine, as `c` is defined after the `/` in the function signature. If we try to
    call the function by passing `a` or `b` by keyword, like so:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This produces the following traceback:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding example shows us that Python is now complaining about how we called
    `func()` . We have passed `b` by keyword, but we are not allowed to do that.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Positional-only parameters can also be optional:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let us see what this feature brings to the language with a few examples borrowed
    from the official documentation. One advantage is the ability to fully emulate
    behaviors of existing C-coded functions:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Another important use case is to preclude keyword arguments when the parameter
    name is not helpful:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding example, the `obj` keyword argument impairs readability. Moreover,
    if we wish to refactor the internals of the `len` function, and rename `obj` to
    `the_object` (or any other name), the change is guaranteed not to break any client
    code, because there will not be any call to the `len()` function involving the
    now stale `obj` parameter name.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, using positional-only parameters implies that whatever is on the left
    of `/` remains available for use in variable keyword arguments, as shown by the
    following example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The ability to retain parameter names in function signatures for use in `**kwargs`
    can lead to simpler and cleaner code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now explore the mirror version of positional-only: keyword-only parameters.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Keyword-only parameters
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python 3 introduced **keyword-only parameters** . We are going to study them
    only briefly, as their use cases are not that frequent. There are two ways of
    specifying them, either after the variable positional parameters or after a bare
    `*` . Let us see an example of both:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As anticipated, the function `kwo()` takes a variable number of positional parameters
    ( `a` ) and a keyword-only one, `c` . The results of the calls are straightforward
    and you can uncomment the third call to see what error Python returns.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: The same applies to the function `kwo2()` , which differs from `kwo` in that
    it takes a positional argument, `a` , a keyword argument, `b` , and then a keyword-only
    one, `c` . You can uncomment the third call to see the error that is produced.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to specify different types of input parameters, let us
    see how you can combine them in function definitions.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Combining input parameters
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can combine different parameter types in the same function (in fact, it
    is often very useful to do so). As in the case of combining different types of
    arguments in the same function call, there are some restrictions on ordering:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Positional-only parameters come first, followed by a `/` .
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normal parameters go after any positional-only parameters.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable positional parameters go after normal parameters.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyword-only parameters go after variable positional parameters.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable keyword parameters always go last.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For positional-only and normal parameters, any required parameters must be defined
    before any optional parameters. This means that if you have an optional positional-only
    parameter, all your normal parameters must be optional too. This rule does not
    affect keyword-only parameters.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These rules can be a bit tricky to understand without an example, so let us
    look at a couple of them:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note the order of the parameters in the function definition. The execution
    of this yields the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let us now look at an example with keyword-only parameters:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Note that we have both positional-only and keyword-only parameters in the function
    declaration: `a` is positional-only, while `d` and `e` are keyword-only. They
    come after the `*args` variable positional argument, and it would be the same
    if they came right after a single `*` (in which case there would not be any variable
    positional parameter). The execution of this yields the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: One other thing to note is the names we gave to the variable positional and
    keyword parameters. You are free to choose differently but be aware that `args`
    and `kwargs` are the conventional names given to these parameters, at least generically.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: More signature examples
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To briefly recap on function signatures that use the positional- and keyword-only
    specifiers, here are some further examples. Omitting the variable positional and
    keyword parameters, for brevity, we are left with the following syntax:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: First, we have positional-only, then positional or keyword parameters, and finally
    keyword-only ones.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other valid signatures are presented below:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'All of the above are valid signatures, while the following would be invalid:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can read about the grammar specifications in the official documentation:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/reference/compound_stmts.html#function-definitions](https://docs.python.org/3/reference/compound_stmts.html#function-definitions)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: A useful exercise for you at this point would be to implement any of the above
    example signatures, print out the values of those parameters, like we have done
    in previous exercises, and play around passing arguments in different ways.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Avoid the trap! Mutable defaults
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One thing to be aware of, in Python, is that default values are created at
    definition time; therefore, subsequent calls to the same function will possibly
    behave differently according to the mutability of their default values. Let us
    look at an example:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Both parameters have mutable default values. This means that, if you affect
    those objects, any modification will stick around in subsequent function calls.
    See if you can understand the output of those calls:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'While this behavior may seem weird at first, it actually makes sense, and it
    is very handy—when using **memoization** techniques, for example. Even more interesting
    is what happens when, between the calls, we introduce one that does not use defaults,
    such as this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When we run this code, this is the output:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This output shows us that the defaults are retained even if we call the function
    with other values. One question that comes to mind is, how do I get a fresh empty
    value every time? Well, the convention is the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note that, by using the preceding technique, if `a` is not passed when calling
    the function, we always get a brand new, empty list.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: After a thorough exposition of input parameters, it is now time to look at the
    other side of the coin, returning output values.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Return values
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already said that to return something from a function we need to use
    the `return` statement, followed by what we want to return. There can be as many
    `return` statements as needed in the body of a function.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if within the body of a function we do not return anything,
    or we invoke a bare `return` statement, the function will return `None` . This
    behavior is harmless when it is not needed, but allows for interesting patterns,
    and confirms Python as a very consistent language.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'We say it is harmless because you are never forced to collect the result of
    a function call. We will show you what we mean with an example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that the whole body of the function is composed only of the `pass` statement.
    As the official documentation tells us, `pass` is a null operation, as, when it
    is executed, nothing happens. It is useful as a placeholder when a statement is
    required syntactically but no code needs to be executed. In other languages, we
    would probably just indicate that with a pair of curly brackets ( `{}` ), which
    define an *empty scope* ; but in Python, a scope is defined by indenting code,
    therefore a statement such as `pass` is necessary.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Notice also that the first call to `func()` returns a value ( `None` ) that
    we do not collect. As we mentioned before, collecting the return value of a function
    call is not mandatory.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see a more interesting example. Remember that, in *Chapter 1* , *A Gentle
    Introduction to Python* , we talked about the *factorial* function. Let us write
    our own implementation here (for simplicity, we will assume the function is always
    called correctly with appropriate values, so we do not need to sanity-check the
    input argument):'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that we have two points of return. If `n` is either `0` or `1` , we return
    `1` . Otherwise, we perform the required calculation and return `result` .
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, it is common to use the `in` operator to do a membership check,
    as we did in the preceding example, instead of the more verbose:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let us now try to write this function a little bit more succinctly:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This simple example shows how Python is both elegant and concise. This implementation
    is readable even if we have never seen `reduce()` or `mul()` . If you cannot read
    or understand it, set aside a few minutes, and do some research in the Python
    documentation until its behavior is clear to you. Being able to look up functions
    in the documentation and understand code written by someone else is a task that
    every developer needs to be able to perform.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: To this end, make sure you look up the `help()` function, which proves quite
    helpful when exploring with the console.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Returning multiple values
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To return multiple values is easy: you just use tuples. Let us look at a simple
    example that mimics the `divmod()` built-in function:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We could have wrapped the part that is highlighted in the preceding code within
    brackets, but there is no need for that. The preceding function returns both the
    result and the remainder of the division, at the same time.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: In the source code for this example, we have left a simple example of a test
    function to make sure the code is doing the correct calculation.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: A few useful tips
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When writing functions, it is very useful to follow guidelines so that you
    write them well. We will quickly point some of them out:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '**Functions should do one thing** : Functions that do one thing are easy to
    describe in one short sentence; functions that do multiple things can be split
    into smaller functions that do one thing. These smaller functions are usually
    easier to read and understand.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions should be small** : The smaller they are, the easier it is to test
    and write them so that they do one thing.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The fewer input parameters, the better** : Functions that take a lot of parameters
    quickly become hard to manage (among other issues).'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions should be consistent in their return values** : Returning `False`
    and returning `None` are not the same thing, even if, within a Boolean context,
    they both evaluate to `False` . `False` means that we have information ( `False`
    ), while `None` means that there is no information. Try writing functions that
    return in a consistent way, no matter what happens in their logic.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions should have no side effects** : In functional programming, there
    is the concept of **pure functions** . This type of function adheres to two main
    principles:'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deterministic output** : This means that given the same set of inputs, the
    output produced will always be the same. In other words, the function’s behavior
    is not dependent on any external or global state that might change during execution.'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No side effects** : This means that pure functions do not cause any observable
    side effects in the system. That is, they do not alter any external state, like
    modifying global variables or performing I/O operations like reading from or writing
    to a file or the display.'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: While you should aim to write pure functions whenever possible, it is important
    that those you write should at least have no side effects. They should not affect
    the value of the arguments they are called with.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'This is probably the hardest statement to understand at this point, so we will
    give you an example using lists. In the following code, note how `numbers` is
    not sorted by the `sorted()` function, which returns a sorted copy of `numbers`
    . Conversely, the `list.sort()` method is acting on the `numbers` object itself,
    and that is fine because it is a method (a function that belongs to an object
    and therefore has the right to modify it):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Follow these guidelines and you will automatically shield yourself from certain
    types of bugs.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 3* of *Clean Code* , by Robert C. Martin, is dedicated to functions,
    and it is one of the best sets of guidelines we have ever read on the subject.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Recursive functions
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a function calls itself to produce a result, it is said to be **recursive**
    . Sometimes recursive functions are very useful, in that they make it easier to
    write the logic. Some algorithms are very easy to write using recursion, while
    others are not. There is no recursive function that cannot be rewritten in an
    iterative fashion, so it is usually up to the programmer to choose the best approach
    for the case at hand.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of a recursive function usually has two sections: one where the return
    value depends on a subsequent call to itself, and one where it does not (called
    the **base case** ).'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we can consider the (hopefully now familiar) **factorial** function,
    *N!* . The base case is when *N* is either 0 or 1—the function returns `1` with
    no need for further calculation. On the other hand, in the general case, *N!*
    returns the product:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If you think about it, *N!* can be rewritten like this: *N! = (N-1)! * N* .
    As a practical example, consider this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let us write this down in code:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Recursive functions are often used when writing algorithms, and they can be
    really fun to write. As an exercise, try to solve a couple of simple problems
    using both a recursive and an iterative approach. Good candidates for practice
    might be calculating Fibonacci numbers or the length of a string—things like that.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: When writing recursive functions, always consider how many nested calls you
    make, since there is a limit. For further information on this, check out `sys.getrecursionlimit()`
    and `sys.setrecursionlimit()` .
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One last type of function that we want to talk about is **anonymous** functions.
    These functions, which are called **lambdas** in Python, are usually used when
    a fully-fledged function with its own name would be overkill, and all we want
    is a quick, simple one-liner.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we wanted a list of all the numbers up to a certain value of *N*
    that are also multiples of five. We could use the `filter()` function for this,
    which will require a function and an iterable as input. The return value is a
    filter object that, when iterated over, yields the elements from the input iterable
    for which the function returns `True` . Without using an anonymous function, we
    might do something like this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Note how we use `is_multiple_of_five()` to filter through the first *n* natural
    numbers. This seems a bit excessive—the task is simple and we do not need to keep
    the `is_multiple_of_five()` function around for anything else. Let us rewrite
    it using a lambda function:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The logic is the same, but the filtering function is now a lambda. Defining
    a lambda is very easy and follows this form:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'A function object is returned, which is equivalent to this:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note that optional parameters are indicated following the common syntax of wrapping
    them in square brackets.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at another couple of examples of equivalent functions, defined
    in both forms:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The preceding examples are very simple. The first one adds two numbers, and
    the second one produces the uppercase version of a string. Note that we assigned
    what is returned by the `lambda` expressions to a name ( `adder_lambda` , `to_upper_lambda`
    ), but there is no need for that when you use lambdas in the way we did in the
    `filter()` example.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Function attributes
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every function is a fully fledged object and, as such, it has several attributes.
    Some of them are special and can be used in an introspective way to inspect the
    function object at runtime. The following script is an example that shows a few
    of them and how to display their value for an example function:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We used the built-in `getattr()` function to get the value of those attributes.
    `getattr(obj, attribute)` is equivalent to `obj.attribute` and comes in handy
    when we need to dynamically get an attribute at runtime, taking the name of the
    attribute from a variable (as in this example). Running this script yields:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We have omitted the value of the `__globals__` attribute, as it was too big.
    An explanation of the meaning of this attribute can be found in the *Callable
    types* section of the *Python Data Model* documentation page:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy](https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: You can use the built-in `dir()` function to get a list of all the attributes
    of any object.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to notice in the previous example is the use of this clause:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This line makes sure that whatever follows is only executed when the module
    is run directly. When you run a Python script, Python sets the `__name__` variable
    to `"__main__"` in that script. Conversely, when you import a Python script as
    a module into another script, the `__name__` variable is set to the name of the
    script/module being imported.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Built-in functions
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python comes with a lot of built-in functions. They are available anywhere,
    and you can get a list of them by inspecting the `builtins` module with `dir(__builtins__)`
    , or by going to the official Python documentation. Unfortunately, we do not have
    the room to go through all of them here. We have already seen some of them, such
    as `any` , `bin` , `bool` , `divmod` , `filter` , `float` , `getattr` , `id` ,
    `int` , `len` , `list` , `min` , `print` , `set` , `tuple` , `type` , and `zip`
    , but there are many more, which you should read about at least once. Get familiar
    with them, experiment, write a small piece of code for each of them, and make
    sure you have them at your fingertips so that you can use them when needed.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a list of built-in functions in the official documentation, here:
    [https://docs.python.org/3/library/functions.html](https://docs.python.org/3/library/functions.html)
    .'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Documenting your code
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are big fans of code that does not need documentation. When we write elegant
    code, following established principles, the code should come out as self-explanatory,
    with documentation being almost unnecessary. Nevertheless, adding a docstring
    to a function, or a comment with important information, can be very useful.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: You can find the guidelines for documenting Python in PEP 257 – Docstring conventions
    at [https://peps.python.org/pep-0257/](https://peps.python.org/pep-0257/) , but
    we will show you the basics here.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'Python is documented with strings, which are aptly called **docstrings** .
    Any object can be documented, and we can use either one-line or multi-line docstrings.
    One-liners are very simple. They should not provide another signature for the
    function, but instead state its purpose:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Using triple double-quoted strings allows you to expand easily later. Use sentences
    that end in a period, and do not leave blank lines before or after.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiline comments are structured in a similar way. There should be a one-liner
    that briefly gives you the gist of what the object is about, and then a more verbose
    description. As an example, we have documented a fictitious `connect()` function,
    using the **Sphinx** notation, in the following example:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Sphinx is one of the most widely used tools for creating Python documentation—in
    fact, the official Python documentation was written with it. It is definitely
    worth spending some time checking it out.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: The `help()` built-in function, which is intended for interactive use, creates
    a documentation page for an object using its docstring.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Importing objects
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know a lot about functions, let us look at how to use them. The
    whole point of writing functions is to be able to reuse them later and, in Python,
    this translates to importing them into the namespace where they are needed. There
    are many ways to import objects into a namespace, but the most common ones are
    `import module_name` and `from module_name import function_name` . Of course,
    these are quite simplistic examples, but bear with us for the time being.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'The `import module_name` form finds the `module_name` module and defines a
    name for it in the local namespace, where the `import` statement is executed.
    The `from module_name import identifier` form is a little bit more complicated
    than that but basically does the same thing. It finds `module_name` and searches
    for an attribute (or a submodule) and stores a reference to `identifier` in the
    local namespace. Both forms have the option to change the name of the imported
    object using the `as` clause:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Just to give you a flavor of what importing looks like, here is an example
    from a test module of one of Fabrizio’s projects (notice that the blank lines
    between blocks of imports follow the guidelines from PEP 8 at [https://peps.python.org/pep-0008/#imports](https://peps.python.org/pep-0008/#imports)
    : standard library first, then third party, and finally local code):'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: When we have a structure of files starting in the root of our project, we can
    use the dot notation to get to the object we want to import into our current namespace,
    be it a package, a module, a class, a function, or anything else.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: The `from module import` syntax also allows a catch-all clause, `from module
    import *` , which is sometimes used to get all the names from a module into the
    current namespace at once. This practice is frowned upon for several reasons,
    relating to performance and the risk of silently shadowing other names. You can
    read all that there is to know about imports in the official Python documentation
    but, before we leave the subject, let us give you a better example.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we have defined a couple of functions, `square(n)` and `cube(n)`
    , in a module, `funcdef.py` , which is in the `util` folder. We want to use them
    in a couple of modules that are at the same level as the `util` folder, called
    `func_import.py` and `func_from.py` . Showing the tree structure of that project
    produces something like this:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Before we show you the code of each module, please remember that in order to
    tell Python that it is actually a package, we need to put an `__init__.py` module
    in it.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: There are two things to note about the `__init__.py` file. First, it is a fully
    fledged Python module so you can put code into it as you would with any other
    module. Second, as of Python 3.3, its presence is no longer required to make a
    folder be interpreted as a Python package.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Both these files, when executed, print `100` and `1000` . You can see how differently
    we then access the `square` and `cube` functions, according to how and what we
    imported in the current scope.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Relative imports
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The type of import we have seen so far is called an **absolute import** ; that
    is, it defines the whole path of either the module that we want to import or from
    which we want to import an object. There is another way of importing objects into
    Python, which is called a **relative import** . Relative imports are done by adding
    as many leading dots in front of the module as the number of folders we need to
    backtrack, to find what we are searching for. Simply put, it is something such
    as this:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Relative imports are quite useful when restructuring projects. Not having the
    full path in the imports allows the developer to move things around without having
    to rename too many of those paths.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'For a complete explanation of relative imports, refer to PEP 328: [https://peps.python.org/pep-0328/](https://peps.python.org/pep-0328/)
    .'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: In later chapters, we will create projects using different libraries and use
    several different types of imports, including relative ones, so make sure you
    take a bit of time to read up about them in the official Python documentation.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: One final example
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we finish off this chapter, let us go through one last example. We could
    write a function to generate a list of prime numbers up to a limit; we have already
    seen the code for this in *Chapter 3* , *Conditionals and Iteration* , so let
    us make it a function and, to keep it interesting, let us optimize it a bit.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we do not need to divide by all the numbers from *2* to *N-1*
    to decide whether a number, *N* , is prime. We can stop at *√N* (the square root
    of *N* ). Moreover, we do not need to test the division for all the numbers from
    *2* to *√N* , as we can just use the primes in that range. We leave it up to you
    to figure out the math for why this works, if you are interested.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see how the code changes:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The code is the same as that in the previous chapter. We have changed the division
    algorithm so that we only test divisibility using the previously calculated primes,
    and we stopped once the testing divisor was greater than the root of the candidate.
    We used the `primelist` result list to get the primes for the division and calculated
    the root value using a fancy formula, the integer value of the ceiling of the
    root of the candidate. While a simple `int(k ** 0.5) + 1` would have also served
    our purpose, the formula we chose is cleaner and requires a couple of imports,
    which is what we wanted to show. Check out the functions in the `math` module—they
    are very interesting!
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the world of functions. They are very important
    and, from now on, we will use them in virtually everything we do. We talked about
    the main reasons for using them, the most important of which are code reuse and
    implementation hiding.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: We saw that a function object is like a box that takes optional inputs and may
    produce outputs. We can feed input arguments to a function in many different ways,
    using positional and keyword arguments, and using variable syntax for both types.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: You should now know how to write a function, document it, import it into your
    code, and call it.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be picking up the pace a little bit, so we suggest
    you spend a bit of time consolidating and enriching the knowledge you have gathered
    so far by experimenting with code and reading the Python official documentation.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_4.xhtml)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/QR_Code119001106417026468.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
