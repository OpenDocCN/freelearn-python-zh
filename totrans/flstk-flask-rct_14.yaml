- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Modular Architecture – Harnessing the Power of Blueprints
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化架构 – 利用蓝图的力量
- en: In a far-off kingdom called Flaskland, there lived a brave prince named Modular.
    He was known for his love of clean and organized programming code, and his dream
    was to create a kingdom where all the snippet code lived in harmony. One day,
    as he was wandering through the land, he came across a castle in disarray. The
    code snippets were scattered everywhere, and there was no clear structure to be
    found.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个名为Flaskland的遥远王国里，住着一个名叫模块化的勇敢王子。他以热爱干净、有序的编程代码而闻名，他的梦想是创造一个所有代码片段都能和谐共处的王国。有一天，当他漫步在这片土地上时，他发现了一座混乱的城堡。代码片段散落在各处，找不到任何清晰的结构。
- en: The prince knew that this was a challenge he had to take on. He rallied his
    army of helper functions and organized them into modules, each with a specific
    purpose. He then declared that these modules were the building blocks of the kingdom,
    and with them, they could conquer the chaos.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 王子知道这是一个他必须承担的挑战。他召集了他的助手函数军队，并将它们组织成模块，每个模块都有特定的目的。然后他宣布这些模块是王国的基石，有了它们，他们可以征服混乱。
- en: And so, the prince and his army of helper functions set out to build a kingdom
    of well-structured, reusable code. They worked day and night until, finally, the
    newly organized kingdom was born. The snippets were organized, and the kingdom
    was a beauty to behold. This story captures the heart of code modularity, the
    practice of breaking down a program or system into smaller, self-contained modules
    or components. Blueprints in Flask encourage this modular approach to building
    web applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，王子和他的助手函数军队着手建立一个由结构良好、可重用代码构成的王国。他们日夜不停地工作，直到新组建的王国终于诞生。代码片段被组织起来，这个王国看起来非常美丽。这个故事捕捉了代码模块化的精髓，即把程序或系统分解成更小、自包含的模块或组件的实践。Flask中的蓝图鼓励这种模块化的构建Web应用程序的方法。
- en: '**Modular architecture** has become increasingly important as web applications
    have become more complex in size and scope. Modular architecture is a modular
    programming paradigm that emphasizes breaking down large applications into smaller,
    reusable modules that can be developed and tested independently.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块化架构**随着Web应用程序在规模和范围上的日益复杂而变得越来越重要。模块化架构是一种模块化编程范式，它强调将大型应用程序分解成更小、可重用的模块，这些模块可以独立开发和测试。'
- en: The **object-oriented programming** (**OOP**) revolution of the 1980s also had
    a significant impact on the development of modular architecture. OOP encouraged
    the creation of self-contained, reusable objects that could be combined to form
    complex applications. This approach was well suited to the development of modular
    applications and helped to drive the widespread adoption of modular architecture.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 20世纪80年代的**面向对象编程**（OOP）革命也对模块化架构的发展产生了重大影响。OOP鼓励创建自包含、可重用的对象，这些对象可以组合成复杂的应用程序。这种方法非常适合开发模块化应用程序，并有助于推动模块化架构的广泛应用。
- en: The principles of modularity, separation of concerns, and encapsulation remain
    key elements of modular architecture, and the pattern continues to evolve and
    adapt to meet the changing needs of software development. Today, modular architecture
    is a widely accepted and widely used software design pattern.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化的原则、关注点的分离和封装仍然是模块化架构的关键要素，这种模式持续演变和适应，以满足软件开发不断变化的需求。如今，模块化架构是一种被广泛接受和广泛使用的软件设计模式。
- en: 'Modular architecture is used in a variety of contexts, from large-scale enterprise
    applications to small, single-page web applications. In Flask web applications,
    Blueprints refer to a way to organize a group of related views and other code
    into a single module. Blueprints resemble what components are to React: reusable
    pieces of UI that encapsulate a set of functions and states. But in the context
    of Flask, Flask allows you to organize your application into smaller, reusable
    components called Blueprints.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化架构在各种环境中得到应用，从大规模企业应用程序到小型单页Web应用程序。在Flask Web应用程序中，蓝图指的是将一组相关的视图和其他代码组织成一个单一模块的方法。蓝图类似于React中的组件：封装了一组函数和状态的UI可重用部件。但在Flask的上下文中，Flask允许你将应用程序组织成更小、可重用的组件，称为蓝图。
- en: In this chapter, we will explore modular architecture in web development. With
    Blueprints in perspective, we will discuss how Blueprints can help you to build
    decoupled, reusable, maintainable, and testable Flask web applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨网页开发中的模块化架构。在Blueprints的视角下，我们将讨论Blueprints如何帮助你构建解耦的、可重用的、可维护的和可测试的Flask网页应用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Understanding the benefits of modular architecture in web development
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解模块化架构在网页开发中的优势
- en: Understanding Flask Blueprints
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Flask Blueprints
- en: Setting up a Flask application with Blueprints
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Blueprints设置Flask应用
- en: Handling the React frontend with Flask Blueprints
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flask Blueprints处理React前端
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter14](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter14).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可在GitHub上找到：[https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter14](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter14)。
- en: Due to the page count constraints, most of the long code blocks have been snipped.
    Please refer to GitHub for the complete code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于页面数量的限制，大部分长代码块已被截断。请参阅GitHub以获取完整代码。
- en: Understanding the benefits of modular architecture in web development
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模块化架构在网页开发中的优势
- en: Modular architecture is a software development approach that involves breaking
    down a large, complex system into smaller, independent, and reusable modules.
    In the history of web development, modular architecture became more apparent.
    The traditional monolithic architecture involved having all the components of
    a web application tightly coupled, resulting in a large, unwieldy code base that
    was difficult to maintain and scale.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化架构是一种软件开发方法，它涉及将一个大型、复杂的系统分解成更小、独立且可重用的模块。在网页开发的历史中，模块化架构变得更加明显。传统的单体架构涉及将网络应用的各个组件紧密耦合在一起，导致代码库庞大、难以操控，难以维护和扩展。
- en: As web applications became more complex and the need for scalability increased,
    developers began to seek alternative approaches that would allow them to break
    down a web application into smaller, independent components.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 随着网络应用变得越来越复杂，对可扩展性的需求增加，开发者开始寻求替代方法，以便将网络应用分解成更小、更独立的组件。
- en: Modular architecture emerged as a solution to these limitations, as it allowed
    developers to create smaller, reusable components that could be combined to form
    a complete web application. This approach provided several benefits, including
    improved maintainability, easier scalability, and better separation of concerns.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化架构作为解决这些限制的方案出现，因为它允许开发者创建更小、可重用的组件，这些组件可以组合成一个完整的网络应用。这种方法提供了包括提高可维护性、更容易的可扩展性和更好的关注点分离在内的几个好处。
- en: With modular architecture, developers could work on individual components in
    isolation, which reduced the risk of breaking the entire application and made
    it easier to test and deploy changes independently. As a result, modular architecture
    quickly gained popularity among web developers, and many modern web development
    frameworks such as Flask, Django, Ruby on Rails, and Angular have embraced this
    architectural style. The popularity of modular architecture has continued to grow
    over the years, and it remains a crucial component of modern web development practices.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块化架构，开发者可以在隔离的情况下对单个组件进行工作，这降低了破坏整个应用的风险，并使得独立测试和部署更改变得更加容易。因此，模块化架构迅速在网页开发者中获得了流行，许多现代网页开发框架，如Flask、Django、Ruby
    on Rails和Angular，都采用了这种架构风格。模块化架构的流行度在过去几年中持续增长，并且仍然是现代网页开发实践中的一个关键组成部分。
- en: 'Let’s explore some of the benefits of modular architecture in web development:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些模块化架构在网页开发中的优势：
- en: '**Scalability**: In a traditional monolithic architecture, as an application
    grows, it becomes more difficult to manage, maintain, and scale. With modular
    architecture, each module is independent and can be developed, tested, and deployed
    independently, which makes it easier to scale individual components as needed.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：在传统的单体架构中，随着应用的成长，管理和维护变得越来越困难。使用模块化架构，每个模块都是独立的，可以独立开发、测试和部署，这使得根据需要扩展单个组件变得更加容易。'
- en: '**Reusability**: Modular architecture encourages code reuse, which leads to
    a more efficient development process. Modules can be reused across different projects,
    reducing the amount of time and effort required to develop new applications. Furthermore,
    modular architecture makes it easier to update and maintain existing code, as
    changes can be made to a single module without affecting the rest of the application.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：模块化架构鼓励代码重用，这导致开发过程更加高效。模块可以在不同的项目中重用，从而减少开发新应用程序所需的时间和精力。此外，模块化架构使得更新和维护现有代码变得更加容易，因为对单个模块的更改不会影响应用程序的其他部分。'
- en: '**Maintainability**: With modular architecture, the application is divided
    into smaller, manageable components, making it easier to identify and resolve
    issues. The modular design makes it easier to isolate problems and debug issues,
    reducing the time and effort required to resolve them. Furthermore, modular architecture
    makes it easier to test individual components, ensuring that the application remains
    reliable and maintainable over time.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：采用模块化架构，应用程序被划分为更小、更易于管理的组件，这使得识别和解决问题变得更加容易。模块化设计使得隔离问题和调试问题更加容易，从而减少了解决问题所需的时间和精力。此外，模块化架构使得测试单个组件变得更加容易，确保应用程序在长时间内保持可靠和可维护。'
- en: '**Flexibility**: Modular architecture allows developers to easily modify or
    extend the functionality of an application without affecting the rest of the system.
    This makes it easier to add new features, make changes, or integrate new technologies
    into the application. With modular architecture, developers can work on individual
    modules, ensuring that the application remains flexible and adaptable over time.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：模块化架构允许开发者轻松修改或扩展应用程序的功能，而不会影响整个系统。这使得添加新功能、进行更改或集成新技术到应用程序中变得更加容易。采用模块化架构，开发者可以专注于单个模块，确保应用程序在长时间内保持灵活和适应性强。'
- en: '**Improved collaboration**: Modular architecture enables developers to work
    on different parts of an application in parallel, improving collaboration and
    reducing the time required to complete projects. The modular design allows teams
    to divide the work into smaller, manageable components, making it easier to coordinate
    and integrate their efforts.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进协作**：模块化架构使得开发者能够并行工作于应用程序的不同部分，从而提高协作效率并减少完成项目所需的时间。模块化设计允许团队将工作分解成更小、更易于管理的组件，这使得协调和整合他们的工作变得更加容易。'
- en: '**Better performance**: Modular architecture can improve the performance of
    web applications by reducing the size of individual components and improving the
    load times of an application. With smaller, more focused components, the application
    can load faster, improving the user experience. Additionally, modular architecture
    allows for better resource allocation, ensuring that the application uses resources
    efficiently and effectively.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的性能**：模块化架构可以通过减少单个组件的大小和提高应用程序的加载时间来提高 Web 应用程序的性能。通过更小、更专注的组件，应用程序可以更快地加载，从而改善用户体验。此外，模块化架构允许更好的资源分配，确保应用程序高效、有效地使用资源。'
- en: In conclusion, modular architecture is becoming increasingly important in web
    development, as it provides several benefits over traditional monolithic architecture.
    With its ability to improve scalability, reusability, maintainability, flexibility,
    collaboration, and performance, modular architecture provides a compelling reason
    for developers to adopt this approach in their projects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，模块化架构在 Web 开发中变得越来越重要，因为它在传统单体架构之上提供了许多优势。凭借其提高可扩展性、可重用性、可维护性、灵活性、协作和性能的能力，模块化架构为开发者在其项目中采用这种方法提供了强有力的理由。
- en: By embracing modular architecture, developers can create better, more efficient
    applications that are easier to manage and maintain over time.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用模块化架构，开发者可以创建更好、更高效的程序，这些程序在长时间内更容易管理和维护。
- en: Next, we will discuss the big elephant in the Flask community – Blueprint. Blueprint
    is a powerful organizational tool that facilitates the structuring of a web application
    into modular and reusable components.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论 Flask 社区中的大问题——蓝图。蓝图是一个强大的组织工具，它促进了将 Web 应用程序结构化为模块化和可重用组件。
- en: Understanding Flask Blueprints
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Flask 蓝图
- en: As you may be aware, Flask is a simple and lightweight framework that allows
    developers to create web applications quickly and easily. Flask Blueprints are
    an important feature of Flask that help developers organize their applications
    into reusable components.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，Flask 是一个简单且轻量级的框架，允许开发者快速轻松地创建网络应用程序。Flask 蓝图是 Flask 的一个重要特性，有助于开发者将应用程序组织成可重用组件。
- en: Flask Blueprints are a way to organize your Flask application into smaller and
    reusable components. Essentially, Blueprints are a collection of routes, templates,
    and static files that can be registered and used in multiple Flask applications.
    Blueprints allow you to split your Flask application into smaller, modular components
    that can be easily maintained and scaled. This modular approach to building web
    applications makes it easier to manage the code base and collaborate with other
    developers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 蓝图是将 Flask 应用程序组织成更小、可重用组件的一种方式。本质上，蓝图是一组路由、模板和静态文件，可以在多个 Flask 应用程序中注册和使用。蓝图允许你将
    Flask 应用程序拆分成更小、模块化的组件，这些组件可以轻松维护和扩展。这种模块化的构建网络应用程序的方法使得管理代码库和与其他开发者协作变得更加容易。
- en: 'Let’s glance through some of the benefits of using Blueprints in your Flask
    application development:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下在 Flask 应用程序开发中使用蓝图的一些好处：
- en: '**Modular design**: Flask Blueprints allow developers to break down their applications
    into smaller, reusable components. This makes it easier to maintain and scale
    the code base over time.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化设计**：Flask 蓝图允许开发者将应用程序拆分成更小、可重用的组件。这使得随着时间的推移维护和扩展代码库变得更加容易。'
- en: '**Reusability**: Once you create a Blueprint, you can reuse it across different
    Flask applications. This saves you time and effort. Indeed, using Flask Blueprints
    can greatly simplify the process of building complex web applications, allowing
    developers to quickly and easily create reusable components with just a few clicks
    of the mouse.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：一旦创建了一个蓝图，你就可以在不同的 Flask 应用程序中重用它。这为你节省了时间和精力。实际上，使用 Flask 蓝图可以极大地简化构建复杂网络应用程序的过程，让开发者只需点击几下鼠标就能快速轻松地创建可重用组件。'
- en: '**Flexibility**: Flask Blueprints can be customized to suit the needs of your
    application. You can define your own URL prefixes for a Blueprint, which allows
    you to customize your application’s URL structure. This gives you more control
    over how your web application is structured and accessed.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：Flask 蓝图可以根据应用程序的需求进行定制。你可以为蓝图定义自己的 URL 前缀，这允许你自定义应用程序的 URL 结构。这让你能够更多地控制网络应用程序的结构和访问方式。'
- en: '**Template inheritance**: Blueprints can inherit templates from the main application,
    which allows you to reuse templates across multiple Blueprints. This makes it
    easier to create consistent and well-designed web applications.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板继承**：蓝图可以从主应用程序继承模板，这允许你在多个蓝图之间重用模板。这使得创建一致且设计良好的网络应用程序变得更加容易。'
- en: '**Namespaces**: Blueprints can define their own view functions, and these functions
    are namespaced within the Blueprint. This helps prevent naming conflicts between
    different parts of your application.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间**：蓝图可以定义自己的视图函数，并且这些函数在蓝图内部命名空间化。这有助于防止应用程序不同部分之间的命名冲突。'
- en: Flask Blueprints undoubtedly promote a clear separation of concerns within your
    application code base. By organizing your code into separate Blueprints, you can
    ensure that each component of your application is responsible for a specific area
    of functionality. This can make it easier to understand and debug your code, as
    well as ensure that your application is more maintainable over time.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 蓝图无疑促进了应用程序代码库中关注点的清晰分离。通过将代码组织成独立的蓝图，你可以确保应用程序的每个组件都负责特定的功能区域。这可以使代码更容易理解和调试，同时确保应用程序随着时间的推移更容易维护。
- en: In the next section, we will delve into setting up a Flask application with
    Blueprints in mind.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨在考虑蓝图的情况下设置 Flask 应用程序。
- en: Setting up a Flask application with Blueprints
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用蓝图设置 Flask 应用程序
- en: Blueprints in Flask are a way to organize and structure a Flask application
    into smaller, reusable components. To use Blueprints in a Flask application, you
    typically define your Blueprint in a separate Python file where you can define
    your routes, templates, and any other necessary logic specific to that Blueprint.
    Once defined, you can register the Blueprint with your Flask application, which
    allows you to use the Blueprint functionality within your main Flask application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Flask中的蓝图是一种将Flask应用程序组织成更小、可重用组件的方式。要在Flask应用程序中使用蓝图，你通常在一个单独的Python文件中定义你的蓝图，在那里你可以定义你的路由、模板以及任何其他特定于该蓝图的必要逻辑。一旦定义，你就可以将蓝图注册到你的Flask应用程序中，这允许你在主Flask应用程序中使用蓝图功能。
- en: With Blueprints, you can easily separate concerns between different parts of
    your application, making it easier to maintain and update over time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用蓝图，你可以轻松地在应用程序的不同部分之间分离关注点，使得随着时间的推移更容易维护和更新。
- en: Now, let’s dive deep into the heart of how you can set up Flask applications
    with Blueprints.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探讨如何使用蓝图设置Flask应用程序。
- en: Structuring Blueprint Flask applications
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构化蓝图Flask应用程序
- en: In web application development, efficient organization and modularity of the
    code base are essential for building robust and maintainable projects. One of
    the key structural elements in Flask is the concept of Blueprints. These Blueprints
    provide a structured way to compartmentalize and encapsulate various components
    of a web application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络应用开发中，代码库的高效组织和模块化对于构建健壮和可维护的项目至关重要。Flask中的一个关键结构元素是蓝图的概念。这些蓝图提供了一种结构化的方式来隔离和封装网络应用程序的各个组件。
- en: The approach invariably promotes clarity, reusability, and scalability. We are
    going to examine the structure of the `attendees` Blueprint – a crafted, organizational
    structure designed to streamline the development of attendee-related features
    within our web application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法始终促进清晰性、可重用性和可扩展性。我们将要检查`attendees`蓝图的结构——这是一个精心设计的组织结构，旨在简化我们网络应用中与参会者相关的功能开发。
- en: 'The `attendees` Blueprint is nestled within the `bizza\backend\blueprints\attendees`
    directory. Create a new directory inside the `bizza/backend` project directory
    for the Flask applications and name it `blueprints`. The Blueprints added to the
    project make the directory structure appear as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`attendees`蓝图位于`bizza\backend\blueprints\attendees`目录中。在`bizza/backend`项目目录内创建一个新的目录用于Flask应用程序，并将其命名为`blueprints`。添加到项目中的蓝图使得目录结构如下所示：'
- en: '**The** **attendees Blueprint**:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**参会者蓝图**：'
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Detailed structure**:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**详细结构**：'
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding `attendees` Blueprint contains the following components:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`attendees`蓝图包含以下组件：
- en: '`models`: This is a subdirectory containing a Python module named `attendee.py`
    that defines the data model for attendees. The `__init__.py` file is a blank Python
    module that indicates to Python that this directory should be treated as a package.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models`：这是一个包含名为`attendee.py`的Python模块的子目录，该模块定义了参会者的数据模型。`__init__.py`文件是一个空的Python模块，它指示Python将此目录视为一个包。'
- en: '`Templates`: This is a subdirectory containing HTML templates for the attendee
    views. The `base.html` template is a base template that other templates inherit
    from. The `attendee_form.html` template is used for creating or editing attendee
    profiles. The `attendee_list.html` template is used to display a list of all attendees.
    The `attendee_profile.html` template is used to display a single attendee’s profile.
    The `attendee_profile_edit.html` template is used to edit an attendee’s profile.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`模板`：这是一个包含用于参会者视图的HTML模板的子目录。`base.html`模板是一个基础模板，其他模板都继承自它。`attendee_form.html`模板用于创建或编辑参会者资料。`attendee_list.html`模板用于显示所有参会者的列表。`attendee_profile.html`模板用于显示单个参会者的资料。`attendee_profile_edit.html`模板用于编辑参会者的资料。'
- en: '`static`: This is a subdirectory containing static files used by the templates.
    The `css` directory contains an `attendees.css` file used to style the HTML templates.
    The `js` directory contains an `attendees.js` file used for client-side scripting.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static`：这是一个包含模板使用的静态文件的子目录。`css`目录包含一个`attendees.css`文件，用于美化HTML模板。`js`目录包含一个`attendees.js`文件，用于客户端脚本。'
- en: '`attendee_blueprint.py`: This is a Python module containing the Blueprint definition
    and the routing for the attendee views. This Blueprint defines routes for displaying
    a list of attendees, displaying an individual attendee’s profile, creating a new
    attendee profile, and updating an existing attendee profile. The Blueprint also
    contains database-related functions for handling attendee data, such as adding
    new attendees and updating attendee information.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attendee_blueprint.py`：这是一个包含蓝图定义和参会者视图路由的Python模块。此蓝图定义了显示参会者列表、显示单个参会者资料、创建新的参会者资料和更新现有参会者资料的路由。蓝图还包含处理参会者数据的数据库相关函数，例如添加新参会者和更新参会者信息。'
- en: Defining models and Blueprint modules
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义模型和蓝图模块
- en: Models serve as the foundation of a web application’s data structure. Models
    represent the essential entities and relationships within web applications. They
    encapsulate data attributes, business logic, and interactions, providing a coherent
    representation of real-world concepts.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是网络应用程序数据结构的基础。模型代表网络应用程序中的基本实体和关系。它们封装数据属性、业务逻辑和交互，为现实世界概念提供一致的表现。
- en: 'When defining models within a Blueprint module, you create a self-contained
    unit that encapsulates data-related logic. With the integration of models into
    Blueprint modules, you achieve a harmonious synergy, and benefits such as the
    following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图模块中定义模型时，你创建了一个封装数据相关逻辑的自包含单元。通过将模型集成到蓝图模块中，你实现了和谐的协同作用，并带来了以下好处：
- en: '**Clear separation**: Blueprint modules isolate various functionalities, while
    models encapsulate data handling. This separation simplifies code base maintenance
    and enhances readability.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清晰的分离**：蓝图模块隔离各种功能，而模型封装数据处理。这种分离简化了代码库维护并提高了可读性。'
- en: '**Coherent structure**: Blueprint modules provide a logical context for models,
    making it easier to navigate and understand data-related operations.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构清晰**：蓝图模块为模型提供逻辑上下文，使其更容易导航和理解数据相关操作。'
- en: '**Reusability**: Models defined within a Blueprint can be reused across other
    parts of the application through Blueprint integration, promoting a **Don’t Repeat
    Yourself** (**DRY**) coding approach.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：在蓝图内定义的模型可以通过蓝图集成在其他应用部分重用，促进**不要重复自己**（DRY）的编码方法。'
- en: 'Now, let’s delve into the attributes of the attendee model in a Blueprint module:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探讨蓝图模块中参会者模型的属性：
- en: '**Attendees Blueprint**:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**参会者蓝图**：'
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `attendee.py` model is defined as the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`attendee.py`模型定义如下：'
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding `Attendee` model represents attendees at the conference. It has
    columns for `id`, `name`, `email`, and `registration_date`. The `__repr__` method
    specifies how instances of the model should be represented as strings.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`Attendee`模型代表会议的参会者。它有`id`、`name`、`email`和`registration_date`列。`__repr__`方法指定了模型实例应如何表示为字符串。
- en: 'The attendee Blueprint is defined as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 参会者蓝图定义如下：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding snippet defines a Flask Blueprint for managing attendees. It imports
    the necessary modules, including the `Attendee` model, `AttendeeForm`, and `EditAttendeeForm`
    from the `attendees` package, and `db` from the `bizza.backend.blueprints` package.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段定义了一个用于管理参会者的Flask蓝图。它从`attendees`包中导入必要的模块，包括`Attendee`模型、`AttendeeForm`和`EditAttendeeForm`，以及从`bizza.backend.blueprints`包中的`db`。
- en: The Blueprint has a route for the attendee list that requires the user to be
    logged in. It retrieves all attendees from the database using the `Attendee.query.all()`
    method and renders the `attendee_list.html` template with the list of attendees.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图有一个需要用户登录的参会者列表路由。它使用`Attendee.query.all()`方法从数据库中检索所有参会者，并使用参会者列表渲染`attendee_list.html`模板。
- en: The Blueprint also has a route for adding attendees that is accessible via `GET`
    and `POST` requests. It creates an instance of `AttendeeForm`, and if the form
    is validated, it creates a new attendee object with the data submitted through
    the form, adds it to the database, and commits the changes. If successful, it
    flashes a message and redirects to the attendee list page. If the form is not
    valid, it re-renders the `attendee_form.html` template with the form and the *Add*
    action.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图还有一个通过`GET`和`POST`请求可访问的添加参会者路由。它创建一个`AttendeeForm`实例，如果表单验证通过，则使用通过表单提交的数据创建一个新的参会者对象，将其添加到数据库中，并提交更改。如果成功，它会显示一条消息并重定向到参会者列表页面。如果表单无效，它会重新渲染带有表单和*添加*操作的`attendee_form.html`模板。
- en: Registering the Blueprints
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册 Blueprint
- en: When you create a Blueprint, you define its routes, views, models, templates,
    and static files. Once you have defined your Blueprint, you need to register it
    with your Flask application using the `register_blueprint` method. This method
    tells Flask to include the views, templates, and static files of the Blueprint
    in the application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个 Blueprint 时，你定义其路由、视图、模型、模板和静态文件。一旦你定义了你的 Blueprint，你需要使用 `register_blueprint`
    方法将其注册到你的 Flask 应用程序中。此方法告诉 Flask 将 Blueprint 的视图、模板和静态文件包含到应用程序中。
- en: So, when the `app.register_blueprint` method is called, it adds the routes and
    views defined in the Blueprint to the application. This makes the functionality
    provided by the Blueprint available to the rest of the application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当调用 `app.register_blueprint` 方法时，它将 Blueprint 中定义的路由和视图添加到应用程序中。这使得 Blueprint
    提供的功能对应用程序的其他部分可用。
- en: 'Let’s use a basic Flask application factory function to create and configure
    a Flask application:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个基本的 Flask 应用程序工厂函数来创建和配置一个 Flask 应用程序：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code does the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行以下操作：
- en: Imports the `Flask` and `SQLAlchemy` modules.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `Flask` 和 `SQLAlchemy` 模块。
- en: Creates an instance of the Flask application.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 Flask 应用程序的实例。
- en: Loads the configuration from a configuration file.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从配置文件中加载配置。
- en: Initializes the `SQLAlchemy` object with the application.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用应用程序初始化 `SQLAlchemy` 对象。
- en: Imports the Blueprints from the different parts of the application.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从应用程序的不同部分导入 Blueprint。
- en: Registers the Blueprints with the Flask application.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Blueprint 注册到 Flask 应用程序中。
- en: Returns the Flask application object.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Flask 应用程序对象。
- en: Next, we will shift our focus to how Blueprints and the React frontend can be
    integrated seamlessly. We need to get creative and discover exciting ways to blend
    Blueprints with a React frontend and take our development to the next level.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将关注如何无缝地将 Blueprint 和 React 前端集成。我们需要发挥创意，发现将 Blueprint 与 React 前端融合的激动人心的方法，将我们的开发提升到新的水平。
- en: Handling the React frontend with Flask Blueprints
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Flask Blueprint 处理 React 前端
- en: In the case of a React frontend and Flask backend, Blueprints can be used to
    organize the different API routes and views that the frontend needs to communicate
    with the backend. The frontend can make requests to the backend API endpoints
    that are defined in the Blueprints, and the backend can respond with the appropriate
    data.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 前端和 Flask 后端的情况下，可以使用 Blueprint 来组织前端需要与后端通信的不同 API 路由和视图。前端可以向 Blueprint
    中定义的后端 API 端点发出请求，后端可以返回适当的数据。
- en: Additionally, using Flask for the backend and React for the frontend provides
    a flexible and powerful development environment. Flask is a lightweight and *easy-to-use*
    web framework that is ideal for building **RESTful** APIs, while React is a popular
    and powerful frontend library that allows for the creation of complex and dynamic
    user interfaces. With these technologies, you can create high-performance, scalable
    web applications that are easy to maintain and update.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用 Flask 作为后端和 React 作为前端提供了一个灵活且强大的开发环境。Flask 是一个轻量级且 *易于使用* 的 Web 框架，非常适合构建
    **RESTful** API，而 React 是一个流行且强大的前端库，允许创建复杂和动态的用户界面。使用这些技术，你可以创建高性能、可扩展的 Web 应用程序，易于维护和更新。
- en: 'It’s time to unleash our imagination and explore the limitless potential of
    combining a Blueprint with a React frontend. Integrating a Flask backend with
    a React frontend involves setting up the communication between the two using API
    endpoints. We set up a typical Flask Blueprint, for instance, the `attendees`
    Blueprint structure, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候发挥我们的想象力，探索将 Blueprint 与 React 前端结合的无限潜力了。将 Flask 后端与 React 前端集成涉及设置两者之间的通信，使用
    API 端点。例如，我们设置了一个典型的 Flask Blueprint，比如 `attendees` Blueprint 结构，如下所示：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This route should serve as the entry point to the React app. Modify the existing
    Flask routes in `attendees_blueprint.py` to return JSON data instead of HTML.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此路由应作为 React 应用的入口点。修改 `attendees_blueprint.py` 中现有的 Flask 路由，使其返回 JSON 数据而不是
    HTML。
- en: In the React frontend, we will create an `attendee` component and make API calls
    to the Flask routes using a library such as `axios` to retrieve the JSON data
    and render it in the UI.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 前端中，我们将创建一个 `attendee` 组件，并使用类似 `axios` 的库调用 Flask 路由进行 API 调用，以检索 JSON
    数据并在 UI 中渲染。
- en: 'The updated `attendee_blueprint.py` file is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的 `attendee_blueprint.py` 文件如下：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code defines a Flask Blueprint for managing attendees in the application.
    The Blueprint is registered at the `/api/v1/attendees` URL prefix. It includes
    routes for getting all attendees, adding a new attendee, getting a specific attendee,
    updating an existing attendee, and deleting an attendee.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个 Flask 蓝图，用于在应用程序中管理参会者。该蓝图在 `/api/v1/attendees` URL 前缀下注册。它包括获取所有参会者、添加新参会者、获取特定参会者、更新现有参会者和删除参会者的路由。
- en: The `get_attendees()` function is decorated with `@attendee_bp.route('/', methods=['GET'])`,
    which means it will handle `GET` requests to the `/api/v1/attendees/` URL. It
    queries the database for all attendees, converts them into a dictionary using
    the `to_dict()` method defined in the `Attendee` model, and returns a JSON representation
    of the list of attendees.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_attendees()` 函数被装饰为 `@attendee_bp.route(''/'', methods=[''GET''])`，这意味着它将处理对
    `/api/v1/attendees/` URL 的 `GET` 请求。它查询数据库以获取所有参会者，使用在 `Attendee` 模型中定义的 `to_dict()`
    方法将它们转换为字典，并返回参会者列表的 JSON 表示。'
- en: The `add_attendee()` function is decorated with `@attendee_bp.route('/', methods=['POST'])`,
    which means it will handle `POST` requests to the `/api/v1/attendees/` URL. It
    first creates an `AttendeeForm` object from the `POST` request data. If the form
    data is valid, a new attendee is created using the form data and added to the
    database.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_attendee()` 函数被装饰为 `@attendee_bp.route(''/'', methods=[''POST''])`，这意味着它将处理对
    `/api/v1/attendees/` URL 的 `POST` 请求。它首先从 `POST` 请求数据中创建一个 `AttendeeForm` 对象。如果表单数据有效，则使用表单数据创建一个新的参会者并将其添加到数据库中。'
- en: The new attendee is then converted into a dictionary using the `to_dict()` method
    and returned as a JSON response. If the form data is not valid, the errors are
    returned as a JSON response.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将新的参会者使用 `to_dict()` 方法转换为字典，并作为 JSON 响应返回。如果表单数据无效，则错误以 JSON 响应返回。
- en: The `get_attendee()` function is decorated with `@attendee_bp.route('/<int:attendee_id>',
    methods=['GET'])`, which means it will handle `GET` requests to the `/api/v1/attendees/<attendee_id>`
    URL, where `attendee_id` is the ID of the specific attendee being requested. It
    queries the database for the attendee with the specified ID, converts it into
    a dictionary using the `to_dict()` method, and returns a JSON representation of
    the attendee.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_attendee()` 函数被装饰为 `@attendee_bp.route(''/<int:attendee_id>'', methods=[''GET''])`，这意味着它将处理对
    `/api/v1/attendees/<attendee_id>` URL 的 `GET` 请求，其中 `attendee_id` 是请求的特定参会者的 ID。它查询数据库以获取具有指定
    ID 的参会者，使用 `to_dict()` 方法将其转换为字典，并返回参会者的 JSON 表示。'
- en: The `update_attendee()` function is decorated with `@attendee_bp.route('/<int:attendee_id>',
    methods=['PUT'])`, which means it will handle `PUT` requests to the `/api/v1/attendees/<attendee_id>`
    URL. It first queries the database for the attendee with the specified ID. It
    then creates an `EditAttendeeForm` object from the `PUT` request data, using the
    current attendee object as the default value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`update_attendee()` 函数被装饰为 `@attendee_bp.route(''/<int:attendee_id>'', methods=[''PUT''])`，这意味着它将处理对
    `/api/v1/attendees/<attendee_id>` URL 的 `PUT` 请求。它首先查询数据库以获取具有指定 ID 的参会者。然后，它从
    `PUT` 请求数据中创建一个 `EditAttendeeForm` 对象，使用当前参会者对象作为默认值。'
- en: If the form data is valid, the attendee object is updated with the new data
    and saved to the database. The updated attendee object is then converted into
    a dictionary using the `to_dict()` method and returned as a JSON response. If
    the form data is not valid, the errors are returned as a JSON response.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表单数据有效，则使用新数据更新参会者对象并将其保存到数据库中。然后，使用 `to_dict()` 方法将更新后的参会者对象转换为字典，并作为 JSON
    响应返回。如果表单数据无效，则错误以 JSON 响应返回。
- en: The `delete_attendee()` function is decorated with `@attendee_bp.route('/<int:attendee_id>',
    methods=['DELETE'])`, which means it will handle `DELETE` requests to the `/api/v1/attendees/<attendee_id>`
    URL. It queries the database for the attendee with the specified ID, deletes it
    from the database, and returns a JSON response indicating success.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete_attendee()` 函数被装饰为 `@attendee_bp.route(''/<int:attendee_id>'', methods=[''DELETE''])`，这意味着它将处理对
    `/api/v1/attendees/<attendee_id>` URL 的 `DELETE` 请求。它查询数据库以获取具有指定 ID 的参会者，将其从数据库中删除，并返回表示成功的
    JSON 响应。'
- en: The utilization of Flask Blueprints to handle the integration of a React frontend
    with a Flask backend offers numerous benefits in terms of code organization, modularity,
    scalability, and maintainability. This structured development approach facilitates
    seamless full stack development while maintaining a clear separation of concerns.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 利用Flask Blueprints来处理React前端与Flask后端的集成提供了许多好处，包括代码组织、模块化、可扩展性和可维护性。这种结构化的开发方法促进了无缝的全栈开发，同时保持了关注点的清晰分离。
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As we come to the end of this chapter, let’s take a moment to reflect on the
    exciting journey we’ve been on. The chapter explores modular architecture in web
    development and how Flask Blueprints can help build decoupled, reusable, maintainable,
    and testable Flask web applications.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们即将结束本章内容，让我们花一点时间回顾一下我们所经历的激动人心的旅程。本章探讨了网络开发中的模块化架构以及Flask Blueprints如何帮助构建解耦的、可重用的、可维护的和可测试的Flask网络应用程序。
- en: The benefits of modularity, separation of concerns, and encapsulation remain
    key elements of modular architecture. In Flask, Blueprints organize a group of
    related views and other code into a single module. This chapter also covers setting
    up a Flask application with Blueprints. Finally, we discussed a very flexible
    way to build full stack web applications at scale with React frontend and Flask
    Blueprints.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化、关注点分离和封装的好处仍然是模块化架构的关键要素。在Flask中，Blueprints将一组相关的视图和其他代码组织成一个单独的模块。本章还涵盖了使用Blueprints设置Flask应用程序的内容。最后，我们讨论了一种非常灵活的方法，即使用React前端和Flask
    Blueprints构建大规模的全栈网络应用程序。
- en: Next, we will explore unit testing in Flask. Fasten up and let’s delve into
    the exciting world of testing in Flask backend development.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨Flask中的单元测试。系好安全带，让我们深入探索Flask后端开发中令人兴奋的测试世界。
