<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Completing the Application, Embedded Devices, and Tests</h1>
                </header>
            
            <article>
                
<p class="mce-root">This chapter will complete this book. All of the main GUI elements that can be used at the start of development practice are described. Of course, the Qt library has more than 1,500 classes, and tools may vary depending on the GUI application tasks. However, the implementation principles are similar and the reader can implement them with ease. Within this book, we have created and demonstrated an application that provides the most useful functionality, and this chapter will pack this GUI app for presentation. We will also discuss mechanisms for realizing the GUI on the different devices and platforms and, where possible, without additional modifications. Qt currently supports the most popular and modern platforms and provides additional mechanisms for deploying the application with embedded devices. In addition, we will cover classes for implementing unit testing of Qt-based applications and libraries, using Qt library tools. This chapter will cover the following topics:</p>
<ul>
<li>Completing the application</li>
<li>Embedded devices</li>
<li>Tests</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Completing the application</h1>
                </header>
            
            <article>
                
<p>To complete the application, we need to run the <kbd>u_app.py</kbd> file and look at what sections/features are not completed. As we can see, some options in the top panel bar have not been completed, so let's do this.</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4e90404c-b505-4b35-8664-720fbc51fd0f.png"/></p>
<p>In the preceding screenshot, we have <kbd>Edit</kbd>, <kbd>Options</kbd>, <kbd>Help</kbd> and <kbd>Visualization</kbd> options which will be constructed as we proceed in the chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Edit option</h1>
                </header>
            
            <article>
                
<p>The <kbd>Edit</kbd> option in the top panel is usually used for editing some text in the text edit fields with simple operations such as undoing/redoing previous operations, cutting selected text from the text field, and copying and pasting to/from the buffer.</p>
<p>Some of the editing options are standard and replicate the option of the default popups, but we add the <kbd>Alignment</kbd> option with a sub-menu and font/color changing options for the text of the text edit field. First of all, open the <kbd>u_window.py</kbd> files and add/change the following lines:</p>
<ol>
<li>Add new options to the <kbd>Edit</kbd> menu and add a sub-menu, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UWindow(UWin):<br/><br/>    def __init__(self, parent=None):<br/>        ...<br/>        self.mb2 = UMenu(self.menubar)<br/>        self.mb2.addAction("Undo")<br/>        self.mb2.addAction("Redo")<br/>        self.mb2.addAction("Cut")<br/>        self.mb2.addAction("Copy")<br/>        self.mb2.addAction("Paste")<br/>        self.mb2_1 = self.mb2.addMenu("&amp;Alignment")<br/>        self.mb2_1.addAction("center")<br/>        self.mb2_1.addAction("left")<br/>        self.mb2_1.addAction("right")<br/>        self.mb2_1.addAction("justify")<br/>        self.mb2.addAction("Text Color")<br/>        self.mb2.addAction("Text Font")<br/>        self.mb2.setTitle("&amp;Edit")<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The <kbd>"&amp;Alignment"</kbd> option is added as a sub-menu of the <kbd>Edit</kbd> option. Options in terms of color and font of the selected text in the text field <span>are also added</span>.</p>
<ol start="2">
<li><span>Now we need to make some additions/changes to the</span> <kbd>UApp</kbd> <span>class of the</span> <kbd>u_app.py</kbd> <span>files.</span></li>
</ol>
<p style="padding-left: 60px">Make some changes to the signals of the <kbd>UApp</kbd> class for the <kbd>Edit</kbd> option:</p>
<pre style="padding-left: 60px">...<br/>class UApp(UWindow, UTools):<br/><br/>    def __init__(self, parent=None):<br/>        ...<br/>        self.mb1.triggered.connect(self.files)<br/>        self.mb2.triggered.connect(self.edit)<br/>        self.mb2_1.triggered.connect(self.edit_align)<br/>        self.mb3.triggered.connect(self.data)<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">The <kbd>Edit</kbd> <span>option (</span><kbd>self.mb2</kbd>) will connect the <kbd>triggered()</kbd> signal to the <kbd>edit()</kbd> function, and the <kbd>Alignment</kbd> <span>sub-menu option</span> will connect to the <kbd>edit_align()</kbd> function.</p>
<ol start="3">
<li>Now add the <kbd>edit()</kbd> function to the <kbd>UApp</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def edit(self, action):<br/>        if action.text() == "Undo":<br/>            self.text_edit.undo()<br/>        if action.text() == "Redo":<br/>            self.text_edit.redo()<br/>        if action.text() == "Cut":<br/>            self.text_edit.cut()<br/>        if action.text() == "Copy":<br/>            self.text_edit.copy()<br/>        if action.text() == "Paste":<br/>            self.text_edit.paste()<br/>        if action.text() == "Text Color":<br/>            fd = QtWidgets.QColorDialog(self)<br/>            if fd.exec_() == QtWidgets.QDialog.Accepted:<br/>                fc = fd.selectedColor()<br/>                self.text_edit.setTextColor(fc)<br/>        if action.text() == "Text Font":<br/>            fd = QtWidgets.QFontDialog()<br/>            if fd.exec_() == QtWidgets.QDialog.Accepted:<br/>                f = fd.selectedFont()<br/>                self.text_edit.setFont(f)<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This function will operate with simple edit options and incorporate functionality for changing the font/color of the selected text in the text edit field.</p>
<ol start="4">
<li>Now add the <kbd>edit_align()</kbd> function to the <kbd>UApp</kbd> class, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def edit_align(self, action):<br/>        if action.text() == "center":<br/>            self.text_edit.setAlignment(<br/>                              QtCore.Qt.AlignCenter)<br/>        if action.text() == "left":<br/>            self.text_edit.setAlignment(<br/>                                QtCore.Qt.AlignLeft)<br/>        if action.text() == "right":<br/>            self.text_edit.setAlignment(<br/>                               QtCore.Qt.AlignRight)<br/>        if action.text() == "justify":<br/>            self.text_edit.setAlignment(<br/>                             QtCore.Qt.AlignJustify)<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">In connection with this option, the text alignment of the text edit field will be changed with the <kbd>Alignment</kbd> flag of the <kbd>Qt</kbd> namespace of the <kbd>QtCore</kbd> module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Options option</h1>
                </header>
            
            <article>
                
<p>The next option is a <kbd>Run</kbd> sub-option. This can realize some functionality of the Python standard library in that part of script execution straight from the text edit field. This will demonstrate the essence of the Python interpreter very clearly. We will save the content of the text field to the file and run with it using the <kbd>subprocess</kbd> module. We will also realize another construction of the thread that was described previously. Let's implement the following steps:</p>
<ol>
<li>First of all, we need to add some lines to the <kbd>u_tools.py</kbd> files. Change the line of the <kbd>import</kbd> section by adding the <kbd>QObject</kbd> class as follows:</li>
</ol>
<ul>
<li style="padding-left: 30px">In the case of the PyQt5 <kbd>u_tools.py</kbd> file, add this line:</li>
</ul>
<pre style="padding-left: 90px">...<br/>from PyQt5.QtCore import QThread, QObject, QMutex<br/>...</pre>
<ul>
<li style="padding-left: 30px">And, in the case of the PySide2 <kbd>u_tools.py</kbd> file, add this line:</li>
</ul>
<pre style="padding-left: 90px">...<br/>from PySide2.QtCore import QThread, QObject, QMutex<br/>...</pre>
<ol start="2">
<li>Add the <kbd>RunThread</kbd> class that will realize the functionality:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class RunThread(QObject):<br/><br/>    sig1 = app_signal(object, object, str)<br/><br/>    def __init__(self, parent=None, datas=None):<br/>        super(RunThread, self).__init__(parent)<br/>        self.datas = datas<br/><br/>    def on_run_code(self):<br/>        try:<br/>            import subprocess<br/>            wf = open("temp.py", "w")<br/>            wf.write(self.datas)<br/>            wf.close()<br/>            sp = subprocess.Popen(<br/>                        ["python", "temp.py"],<br/>                         stdout=subprocess.PIPE,<br/>                         stderr=subprocess.PIPE)<br/>            out = sp.communicate()<br/>            self.sig1.emit(out[0].decode("utf-8"),<br/>                           out[1].decode("utf-8"), '')<br/>        except Exception as err:<br/>            self.sig1.emit('', '', str(err))<br/>...</pre>
<p style="padding-left: 60px">This is a simple class that inherits the <kbd>QObject</kbd> class of the <strong><kbd>QtCore</kbd></strong> module. When the <kbd>on_run_code()</kbd> <span>function </span>is called, it will write to the file and run the file with a sub-process.</p>
<ol start="3">
<li>Add the <kbd>run_code()</kbd> function to the <kbd>UTools</kbd> class of the <kbd>u_tools.py</kbd> files, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def run_code(self, datas=None):<br/>        self.run_thread = QThread()<br/>        self.run_obj = RunThread(datas=datas)<br/>        self.run_obj.moveToThread(self.run_thread)<br/>        self.run_thread.started.connect(self.run_obj.on_run_code)<br/>        self.run_thread.start()<br/>        return (self.run_thread, self.run_obj)<br/>    ...<br/>...</pre>
<p class="mce-root"/>
<p style="padding-left: 60px">This function, in relation to threads created previously, uses the <kbd>moveToThread()</kbd> method of the <strong><kbd>QObject</kbd></strong> class. It is important to note that we can see the need to start the <kbd>on_run_code()</kbd> <span>function </span>of the <kbd>RunThread</kbd> class using the <kbd>started()</kbd> signal of the thread.</p>
<p>Now we can realize the option in the <kbd>UApp</kbd> class of the <kbd>u_app.py</kbd> files. We need to add to the <kbd>import</kbd> section of the <kbd>u_app.py</kbd> files, the standard library time module for working with time and data, as follows:</p>
<ol start="1">
<li>Add the <kbd>time</kbd> module to the <kbd>u_app.py</kbd><span> files:</span></li>
</ol>
<pre style="padding-left: 60px">...<br/>import time<br/>...</pre>
<ol start="2">
<li>And now, we can add the new option to the <kbd>options()</kbd> function of the <kbd>UApp</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def options(self, action):<br/>        ...<br/>        if action.text() == "Run":<br/>            action.setEnabled(False)<br/>            datas = self.text_edit.toPlainText()<br/>            try:<br/>                self.text_edit.append(<br/>                        "\n\n\n\n\nRESULT -----------&gt; %s\n" %<br/>                            time.strftime("%Y.%m.%d %H:%M:%S"))<br/>                runs = self.run_code(datas=datas)<br/>                def to_field(sto, ste, er):<br/>                    if er == '':<br/>                        self.text_edit.append(<br/>                                  str(sto) + "\n" + str(ste))<br/>                    else:<br/>                        self.stat_bar.showMessage(er)<br/>                runs[1].sig1.connect(<br/>                        to_field, QtCore.Qt.QueuedConnection)<br/>                runs[0].quit()<br/>                def on_stop():<br/>                    action.setEnabled(True)<br/>                runs[0].finished.connect(on_stop)<br/>            except Exception as err:<br/>                self.stat_bar.showMessage(str(err))<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">In this option, we disable the <kbd>"Run"</kbd> item in the top panel menu. Then, we retrieve the text from the text field, call the function of the <kbd>UTools</kbd> class from the <kbd>u_tools.py</kbd> files, and receive a tuple that contains threads and used classes. We create two nested functions that receive the signals. The first receives signals from the <kbd>RunThread</kbd> class, and the second from the thread with the <kbd>finished()</kbd> signal.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Configuration option</h1>
                </header>
            
            <article>
                
<p>The <kbd>Configuration</kbd> item is optional and the reader can add their own favorite functionality. Using this option, we will provide some information about Python and its installed packages. For this, create the <kbd>u_widget.py</kbd> <span>file </span>in both the <kbd>App/App_PyQt5/</kbd> and <kbd>App/App_PySide2/</kbd> directories, and incorporate therein the widget that will be used for additional informative tasks in the application:</p>
<ol>
<li>We need to add the following lines to the <kbd>import</kbd> section of this file:</li>
</ol>
<ul>
<li style="padding-left: 30px">In the case of the PyQt5 <kbd>u_widget.py</kbd> file, add this:</li>
</ul>
<pre style="padding-left: 90px">...<br/>from PyQt5 import QtWidgets<br/>from u_style import UWid, UTextEd, UComBox, UListV<br/>...</pre>
<ul>
<li style="padding-left: 30px">And, in the case of the PySide2 <kbd>u_widget.py</kbd> file, add this:</li>
</ul>
<pre style="padding-left: 90px">...<br/>from PySide2 import QtWidgets<br/>from u_style import UWid, UTextEd, UComBox, UListV<br/>...</pre>
<p style="padding-left: 60px">The only difference entails the importing of the <kbd>QtWidgets</kbd> module.</p>
<ol start="2">
<li>Now add the <kbd>UWidget</kbd> class to these <kbd>u_widget.py</kbd> files, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UWidget(UWid):<br/><br/>    def __init__(self, parent=None):<br/>        super(UWidget, self).__init__(parent)<br/>        self.setWindowOpacity(0.95)<br/>        self.infotxt = UTextEd(self)<br/>        self.infocomb = UComBox(self)<br/>        self.infocomb.setView(UListV())<br/>        self.infolay = QtWidgets.QGridLayout()<br/>        self.infolay.addWidget(self.infotxt, 0, 0, 1, 1)<br/>        self.infolay.addWidget(self.infocomb, 1, 0, 1, 1)<br/>        self.infolay.setSpacing(0)<br/>        self.infolay.setContentsMargins(0, 0, 0, 0)<br/>        self.setLayout(self.infolay)<br/>...</pre>
<p style="padding-left: 60px">The simple class for a widget to be used depends on tasks.</p>
<p>Now add the lines to the <kbd>u_app.py</kbd> files of the application:</p>
<ol start="1">
<li>In the <kbd>import</kbd> section, add the line that will import the widget, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>from u_widget import UWidget<br/>...</pre>
<ol start="2">
<li>Then, add the option to the <kbd>options()</kbd> function of the <kbd>UApp</kbd> class that will show information about the version of Python used:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def options(self, action):<br/>        ...<br/>        if action.text() == "Configuration":<br/>            def get_info():<br/>                if self.uwid1.infocomb.currentIndex() == 0:<br/>                    try:<br/>                        condinf = subprocess.Popen(<br/>                                         ["conda", "list"],<br/>                                     stdout=subprocess.PIPE)<br/>                        conp = condinf.communicate()<br/>                        self.uwid1.infotxt.setText(<br/>                                   conp[0].decode("utf-8"))<br/>                    except Exception as err:<br/>                        self.uwid1.infotxt.setText(str(err))<br/>                if self.uwid1.infocomb.currentIndex() == 1:<br/>                    try:<br/>                        condinf = subprocess.Popen(<br/>                                            ["pip", "list"],<br/>                                     stdout=subprocess.PIPE)<br/>                        conp = condinf.communicate()<br/>                        self.uwid1.infotxt.setText(<br/>                                """Platform: %s\nPython %s version<br/>                                \nPython path list: %s<br/>                                \n\nRecursion limit: %s<br/>                                \nFilesystem encoding: %s<br/>                                \nDefault encoding: %s<br/>                                \nAvailable installed packages:<br/>                                 \n\n%s""" %<br/>                                (sys.platform, sys.version,<br/>                                 sys.path,<br/>                                 sys.getrecursionlimit(),<br/>                                 sys.getfilesystemencoding(),<br/>                                 sys.getdefaultencoding(),<br/>                                 conp[0].decode("utf-8")))<br/>                    except Exception as err:<br/>                        self.uwid1.infotxt.setText(str(err))<br/>            self.uwid1 = UWidget()<br/>            self.uwid1.setWindowTitle("Configuration")<br/>            self.uwid1.infocomb.addItems(["conda", "pip"])<br/>            self.uwid1.infotxt.setReadOnly(True)<br/>            self.uwid1.show()<br/>            self.uwid1.infocomb.activated.connect(get_info)<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">Selecting this option will show the imported widget with the title of the window set. Add the items to the combobox with options to run commands with subprocesses of your choice. If Anaconda is installed and used with this application, the <kbd>conda</kbd> packages <span>will be shown</span>, or the Python packages can be checked using the <kbd>pip</kbd> option. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Help option</h1>
                </header>
            
            <article>
                
<p>The next step that you need to complete is a <kbd>Help</kbd> option in the top panel. We will use some of the web functionality of the Qt library to demonstrate additional features. First, the <kbd>Online Help</kbd> sub-option will set HTML tags and then will load URLs. Let's implement the following steps:</p>
<ol>
<li>First of all, we need to add some lines to the <kbd>u_widget.py</kbd> files. In the <kbd>import</kbd> section, add the following line as follows:</li>
</ol>
<ul>
<li style="padding-left: 30px">In the case of the PyQt5 <kbd>u_widget.py</kbd> file, add this:</li>
</ul>
<pre style="padding-left: 90px">...<br/>from PyQt5.QtWebEngineWidgets import QWebEngineView<br/>from PyQt5.QtWebEngineWidgets import QWebEngineSettings<br/>...</pre>
<p class="mce-root"/>
<ul>
<li style="padding-left: 30px">And, in the case of the PySide2 <kbd>u_widget.py</kbd> file, add this:</li>
</ul>
<pre style="padding-left: 90px">...<br/>from PySide2.QtWebEngineWidgets import QWebEngineView<br/>from PySide2.QtWebEngineWidgets import QWebEngineSettings<br/>...</pre>
<p style="padding-left: 60px">The <kbd>QtWebEngineWidgets</kbd> module realizes web functionality in the Qt library by providing classes to represent content in the widget and additional settings.</p>
<ol start="2">
<li>Now we need to add the following lines to the <kbd>UWidget</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UWidget(UWid):<br/><br/>    def __init__(self, parent=None):<br/>        ...<br/>        self.wview = QWebEngineView(self)<br/>        self.wview.settings().setAttribute(<br/>                QWebEngineSettings.PluginsEnabled, True)<br/>        self.wview.settings().setAttribute(<br/>                QWebEngineSettings.AutoLoadImages, True)<br/>        self.wview.settings().setAttribute(<br/>                QWebEngineSettings.JavascriptEnabled, True)<br/>        self.wview.setVisible(False)<br/>        ...<br/>        self.infolay = QtWidgets.QGridLayout()<br/>        self.infolay.addWidget(self.wview, 0, 0, 1, 1)<br/>        self.infolay.addWidget(self.infotxt, 0, 0, 1, 1)<br/>        self.infolay.addWidget(self.infocomb, 1, 0, 1, 1)<br/>        ...<br/>...</pre>
<p style="padding-left: 60px">Add the <strong><kbd>QWebEngineView</kbd></strong> with settings to the layout in the first position. Also, this renders this view invisible. </p>
<ol start="3">
<li><span>For the realization of the </span><kbd>Help</kbd><span class="packt_screen"> </span><span>option in the application, we need to add the signal and function to the </span><kbd>UApp</kbd><span> class of the </span><kbd>u_app.py</kbd><span> files. </span></li>
</ol>
<p style="padding-left: 60px">Add the signal to the <kbd>UApp</kbd> class, as follows:</p>
<pre style="padding-left: 60px">...<br/>class UApp(UWindow, UTools):<br/><br/>    def __init__(self, parent=None):<br/>        ...<br/>        self.mb3.triggered.connect(self.data)<br/>        self.mb4.triggered.connect(self.options)<br/>        self.mb5.triggered.connect(self.on_help)<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This signal will connect to the <kbd>on_help()</kbd> <span>function </span>when the <kbd>Help</kbd> option is selected. Now, we need to add the <kbd>on_help()</kbd> function to the <kbd>UApp</kbd> class.</p>
<ol start="4">
<li>Add the <kbd>on_help()</kbd> function and the first <kbd>Online Help</kbd> option, as follows:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def on_help(self, action):<br/>        if action.text() == "Online Help":<br/>            self.uwid2 = UWidget()<br/>            self.uwid2.setWindowTitle("Online Help")<br/>            self.uwid2.infocomb.setVisible(False)<br/>            self.uwid2.infotxt.setReadOnly(True)<br/>            self.uwid2.infotxt.setVisible(False)<br/>            self.uwid2.wview.setVisible(True)<br/>            html = open("help.html", "r").read()<br/>            self.uwid2.wview.setHtml(html)<br/>            self.uwid2.show()<br/>...</pre>
<p style="padding-left: 60px">This option selection will set HTML from the file and show the widget. The <kbd>help.html</kbd> <span>file </span>can be any created HTML file that represents a link to some helpful resources.</p>
<ol start="5">
<li>And now, complete the <kbd>on_help()</kbd> function by adding the <kbd>Documentation</kbd> option:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def on_help(self, action):<br/>        ...<br/>        if action.text() == "Documentation":<br/>            def get_docs():<br/>                if self.uwid3.infocomb.currentIndex() == 0:<br/>                    try:<br/>                        self.uwid3.wview.load(<br/>                                QtCore.QUrl(<br/>                            "https://docs.python.org/3/"))<br/>                    except Exception as err:<br/>                        self.stat_bar.showMessage(str(err))<br/>                if self.uwid3.infocomb.currentIndex() == 1:<br/>                    try:<br/>                        self.uwid3.wview.load(<br/>                                QtCore.QUrl(<br/>        "https://www.riverbankcomputing.com/static/Docs/PyQt5/"))<br/>                    except Exception as err:<br/>                        self.stat_bar.showMessage(str(err))<br/>                if self.uwid3.infocomb.currentIndex() == 2:<br/>                    try:<br/>                        self.uwid3.wview.load(<br/>                                QtCore.QUrl(<br/>                    "https://doc.qt.io/qtforpython/index.html"))<br/>                    except Exception as err:<br/>                        self.stat_bar.showMessage(str(err))<br/>            self.uwid3 = UWidget()<br/>            self.uwid3.setWindowTitle("Documentation")<br/>            self.uwid3.infocomb.addItems(<br/>                             ["Python", "PyQt5", "PySide2"])<br/>            self.uwid3.infotxt.setReadOnly(True)<br/>            self.uwid3.infotxt.setVisible(False)<br/>            self.uwid3.wview.setVisible(True)<br/>            self.uwid3.show()<br/>            self.uwid3.infocomb.activated.connect(get_docs)<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This option will load URLs according to the combo box options selected and visualize these sources in the widget. These examples are use cases that we have not covered before, such as the web functionality of Qt, and it is recommended that you learn about these classes using the related documentation. Moreover, depending on the environment <span>used,</span> additional configurations and settings may be required.</p>
<p>The <kbd>help.html</kbd> file can be found on the GitHub repository of this book at: <a href="https://github.com/PacktPublishing/Hands-On-Qt-for-Python-Developers/tree/master/Chapter17/App/App_PyQt5">https://github.com/PacktPublishing/Hands-On-Qt-for-Python-Developers/tree/master/Chapter17/App/App_PyQt5</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Visualization tab</h1>
                </header>
            
            <article>
                
<p>We will consolidate the material of this book by adding a simple example of the possibility of viewing the data used by the application and fill the<span> </span><kbd>Visualization</kbd><span> </span>tab component. This is a demonstration of data visualization and can be further improved at any time. To create this data visualization, we will use an existing CSV file and use the values from one of its columns. Let's implement the following steps:</p>
<ol>
<li>Open the<span> </span><kbd>u_tools.py</kbd><span> </span>file and add the following lines after all the used classes with threading implementations:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class PaintThread(QThread):<br/> <br/>    sig1 = app_signal(object, str)<br/> <br/>    def __init__(self, parent=None):<br/>        super(PaintThread, self).__init__(parent)<br/> <br/>    def on_source(self, datas):<br/>        self.datas = datas<br/> <br/>    def run(self):<br/>        try:<br/>            import pandas<br/>            df = pandas.read_csv("data/bigtests.csv",<br/>                                 chunksize=1000,<br/>                                 engine="python")<br/>            r = self.datas[1]<br/>            h = self.datas[1] / 1000<br/>            for ch in df:<br/>                wx = self.datas[0] / 1000000<br/>                w = ch["User_Name"].values[777] * wx<br/>                xy = (float(r), float(w))<br/>                self.sig1.emit(xy, '')<br/>                time.sleep(0.05)<br/>                r -= h<br/>            if self.isFinished():<br/>                self.quit()<br/>        except Exception as err:<br/>            self.sig1.emit('', str(err))<br/>            if self.isFinished():<br/>                self.quit()<br/> ...</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p style="padding-left: 60px">This  <kbd>PaintThread</kbd><span> </span>class will realize the thread that will read data with pandas, transform the received data into a form that can interpret the position from these values, and emit these values for the realization on the graphical scene of the application.</p>
<ol start="2">
<li>Add the signal to the<span> </span><kbd>UTools</kbd><span> </span>class of the<span> </span><kbd>u_tools.py</kbd><span> </span>file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UTools(object):<br/>    ...<br/>    paint_sig = app_signal(list)<br/>    ...<br/> ...</pre>
<p style="padding-left: 60px">This signal will be used to emit data to the<span> </span><kbd>PaintThread</kbd><span> </span>class, such as width and height.</p>
<ol start="3">
<li>Now, add the<span> </span><kbd>draws()</kbd><span> </span>function to the<span> </span><kbd>UTools</kbd><span> </span>class. This will manipulate and communicate with the<span> </span><kbd>PaintThread</kbd><span> </span>class:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def draws(self, w=None, h=None):<br/>        datas = [w, h]<br/>        self.paint_thread = PaintThread()<br/>        self.paint_sig.connect(self.paint_thread.on_source)<br/>        self.paint_sig.emit(datas)<br/>        self.paint_thread.start()<br/>        return self.paint_thread<br/>...</pre>
<p style="padding-left: 60px">This function will start the thread and get it to draw on the graphics scene, while emitting data with the width and height that was retrieved from the<span> </span><kbd>PaintThread</kbd><span> </span>class. This construction of threading is similar to the previous constructions. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="4">
<li>Now, we need to open the<span> </span><kbd>u_app.py</kbd><span> </span>file and complete this task by adding some lines. Let's add the scene, view, and painter to the<span> </span><kbd>__init__()</kbd><span> </span>function of the<span> </span><kbd>UApp</kbd><span> </span>class:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UApp(UWindow, UTools):<br/> <br/>    def __init__(self, parent=None):<br/>        ...<br/>        self.gscene = QtWidgets.QGraphicsScene()<br/>        self.gview = UGraphView(self.twid2)<br/>        self.painter = QtGui.QPainter()<br/>        self.gvlay = QtWidgets.QGridLayout()<br/>        self.gvlay.addWidget(self.gview, 0, 0, 1, 1)<br/>        self.gvlay.setContentsMargins(0, 0, 0, 0)<br/>        self.twid2.setLayout(self.gvlay)<br/>        ...<br/>        self.push_but2.clicked.connect(self.vis)<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This will declare the graphics scene, graphics view, the painter that can be used, and will add a scene with a view to the second tab widget, and arrange these elements with a grid layout. We also need to change the calling function of the second push button signal connection.</p>
<ol start="5">
<li>Now, add the<span> </span><kbd>vis()</kbd><span> </span>function to the<span> </span><kbd>UApp</kbd><span> </span>class:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def vis(self):<br/>        self.tabwid.setCurrentIndex(1)<br/>        desktop = QtWidgets.QApplication.desktop()<br/>        self.setGeometry(desktop.availableGeometry())<br/>        self.visualize()<br/>    ...<br/> ...</pre>
<p style="padding-left: 60px">This function will set the second tab widget as the current tab widget. The geometry of the application will be changed to the desktop device’s available size. We will run this function to visualize data.</p>
<p class="mce-root"/>
<ol start="6">
<li>Finally, add the<span> </span><kbd>visualize()</kbd><span> </span>function to the<span> </span><kbd>UApp</kbd><span> </span>class:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def visualize(self):<br/>        self.gscene.clear()<br/>        self.gview.resetCachedContent()<br/>        self.gview.setScene(self.gscene)<br/>        self.gview.setSceneRect(self.gscene.sceneRect())<br/>        self.pen = QtGui.QPen()<br/>        self.scw = float(self.tabwid.currentWidget().width() - 30)<br/>        self.sch = float(self.tabwid.currentWidget().height() - 30)<br/>        try:<br/>            dline = self.draws(w=self.scw, h=self.sch)<br/><br/>            def to_line(xy, er):<br/>                if er == '':<br/>                    color = QtGui.QColor("#00D9FF")<br/>                    cmyk = color.toCmyk()<br/>                    c = cmyk.cyanF()<br/>                    m = cmyk.magentaF() * float(1/xy[1])<br/>                    y = cmyk.yellowF() * float(1/xy[1])<br/>                    k = cmyk.blackF() * float(1/xy[1])<br/>                    a = cmyk.alphaF()<br/>                    color.setCmykF(c, m, y, k, a)<br/>                    self.pen.setColor(color)<br/>                    self.gscene.addLine(QtCore.QLineF(xy[1],<br/>                    self.sch, xy[1], xy[0]), self.pen)<br/>                else:<br/>                    self.stat_bar.showMessage(self.actx + ' ' + er)<br/><br/>            dline.sig1.connect(to_line, QtCore.Qt.QueuedConnection)<br/>        except Exception as err:<br/>            self.stat_bar.showMessage(self.actx + ' ' + str(err))<br/>    ...<br/>...</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p style="padding-left: 60px">This function will use the graphics view and graphics scene to visualize data on the tab widget. Lines will be added to the scene with the color specified in the pen, position, and height that have been interpreted from data values. On clicking the <span class="packt_screen">Ok</span>, we can see the following result:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e61983d1-ff6c-4652-b590-e3cea26518b2.png"/></p>
<p>Since we only have linear data, the visualization will be somewhat ordinary, but, if some data is to be used with various values and not in such a linear form, we will get a different result. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying to embedded devices</h1>
                </header>
            
            <article>
                
<p>The Qt library provides a varied toolset that supports the realization of the GUI application with most modern platforms and embedded devices. For example, on Linux systems, we can easily create the desktop file and start this file, if necessary, to run the application from the desktop workplace or any favorite folder. The <kbd>uapp.desktop</kbd> <span>file </span>looks like the following example, which realizes desktop entry for the application:</p>
<pre>[Desktop Entry]<br/>Path=/Path/to/the/App/App_PyQt5/<br/>Exec=/Path/to/the/installed/python /Path/to/the/App/App_PyQt5/u_app.py<br/>Icon=/Path/To/the/App/App_PyQt5/Icons/python1.png<br/>Name=UAPP<br/>StartupNotify=true<br/>Terminal=false<br/>Type=Application</pre>
<p>In terms of the binding used, PyQt5 can be changed to PySide2. On Windows systems, this can be done (not so simply) by using third-party Python packages such as PyInstaller and py2exe, which convert Python scripts to executable (<kbd>.exe</kbd> files) and realize functionality accordingly. Also, the PyInstaller tool can be used for macOS X systems. It is recommended that you become familiar with the documentation pertaining to PyInstaller by visiting <a href="https://pythonhosted.org/PyInstaller/">https://pythonhosted.org/PyInstaller/</a>. These tools provide simple operations to create the executable quickly and easily. Another case involves deploying applications to mobile devices. The tools and libraries that can help to do this are usually available under a commercial license and, actually, PyQt and PySide bindings are not so well suited to these tasks.</p>
<p>A better way to realize mobile versions of the application is to use the Kivy framework, the Toga cross-platform GUI toolkit, and so on, which specialize in mobile development. The official Qt source provides embedded tooling and solutions under a commercial license that help to build and deploy Qt GUI applications with Android and iOS mobile platforms. The QML-based applications can easily be implemented with Qt, incidentally, along the lines of the example provided in the <a href="9de812dc-9446-4955-8437-4aebb2d991b3.xhtml">Chapter 1</a>, <em>Introduction to Python and Qt</em>.</p>
<p>The source at <a href="https://www.riverbankcomputing.com">https://www.riverbankcomputing.com</a> provides mobile solutions with the <kbd>pyqtdeploy</kbd> library for PyQt5 GUIs accordingly. This realizes deployment of the PyQt5 application on the iOS and Android platforms. The <kbd>pyqtdeploy</kbd> library is realized in order to convert the Python GUI application, the Python interpreter, the Python standard library, Python C extensions, and third-party extensions and packages, to the single, target-specific executable that can be run with most popular desktop and mobile platforms. The <kbd>pyqtdeploy</kbd> mechanism is released under the BSD license and will be demonstrated in detail. To use it, we need to install this package with <kbd>pip</kbd> on the Python installation that contains the PyQt5 binding:</p>
<ol>
<li>Install <kbd>pyqtdeploy</kbd> in Anaconda using the Python 3.x version and PyQt5 with <kbd>pip</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; pip install pyqtdeploy</strong></pre>
<ol start="2">
<li>Then, we need to create, for example, in the <kbd>App/</kbd> folder (optional), the <kbd>pyqtdeploy</kbd> project by typing these commands in the command line/Terminal:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; cd Path/to/the/App</strong><br/><strong>&gt; pyqtdeploy pqtd.pdy</strong></pre>
<p style="padding-left: 60px"><kbd>pqtd</kbd><strong> </strong>is the name of the project and <kbd>pqtd.pdy</kbd> is a file with this project. When hitting the <em>Enter</em> button, the <kbd>pyqtdeploy</kbd> <span>GUI </span>window will be displayed with the option to include the parameters required, such as the following:</p>
<ul>
<li style="padding-left: 30px"><span class="packt_screen">Name</span>: The name of the application executable that will be created.</li>
<li style="padding-left: 30px"><span class="packt_screen">Main script file</span>: The filename of the executable Python script file that will be used to invoke this application.</li>
<li style="padding-left: 30px"><span class="packt_screen">Entry point</span>: The entry point of a Setuptools-based application that should not be specified if the main script file is specified.</li>
<li style="padding-left: 30px"><span class="packt_screen">sys.path</span>: Additional paths that will be used to specify additional directories for <kbd>sys.path</kbd>, such as application directories, ZIP files, and EGG. The list contains strings of paths, such as <kbd>['/Path/to/the/App', '/path/to/the/App/App_PyQt5', '/path/to/the/App/App_PyQt5/qmls', ...]</kbd>, and so on.</li>
</ul>
<ol start="3">
<li>Now we need to hit the <span class="packt_screen">Scan...</span> button, select the <kbd>App/App_PyQt5/</kbd> directory, and push <span class="packt_screen">Include all</span>. We will have the application directory trees similar to the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b299594d-87f5-4b0d-8b8f-2eb5ae60b042.png"/></p>
<ol start="4">
<li>Uncheck the <kbd>data</kbd> folder of this tree. Then, we need to define the PyQt5 modules that will be used. For this, select the <strong><em><span class="packt_screen">PyQt Modules</span></em></strong> tab and choose modules that were used in the application, similar to the following:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5c12dc17-e7e2-4746-b83a-7d02935e38f4.png"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="5">
<li>Some of them are selected by hints, and this is easy to do. Go to the <span class="packt_screen">Standard Library</span> tab and select all the Python standard library modules and packages that will be used, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5ed21215-ee72-40c9-aabf-c313482aa76b.png"/></p>
<p style="padding-left: 60px">We can choose all and uncheck the <kbd>sysconfig</kbd> module.</p>
<ol start="6">
<li>Then, go to the <span class="packt_screen">Other Packages</span> tab and select all the additional packages that are required for the application. As we recall, there are <kbd>pymysql</kbd>, <kbd>couchdb</kbd>, and so on. For this, click on the top of the <span class="packt_screen">Packages Directory</span> section, open the directory that will be scanned for packages (usually, this is <kbd>/Path/to/the/installed/Python/site-packages</kbd>), look at the ones available, and select what is needed. Then, hit <span class="packt_screen">Scan</span>, and all packages of the <kbd>site-packages/directory</kbd> will be shown. We need to select the packages that were used, such as <kbd>pandas</kbd>, <kbd>pymysql</kbd>, <kbd>psycopg2</kbd>, <kbd>pymongo</kbd>, and <kbd>couchdb</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0c72d238-6eee-4263-8760-23faf3157e9b.png"/></p>
<ol start="7">
<li>In the <span class="packt_screen">Locations</span> tab, we will configure the host and target Python locations similar to the following:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ef8b3120-83a5-45f3-a98e-94afb2d05faa.png"/></p>
<p style="padding-left: 60px">Your paths will be relative to the installed Python interpreter directories. And now, we need to save previous operations to the XML document by clicking the <span class="packt_screen">Save</span> option of the <span class="packt_screen">File</span> menu. This file will be saved to the <kbd>App/</kbd> folder with the name <kbd>pqtd.pdy</kbd>.</p>
<ol start="8">
<li>So, now that the features are selected and saved, we need to build this project using commands in the cmd/Terminal as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; cd Path/to/the/App/pqtd.pdy</strong><br/><strong>&gt; pyqtdeploy-build pqtd.pdy --target=android-32</strong></pre>
<p style="padding-left: 60px">The architectures that can be used with the <kbd>--target</kbd> option are the <kbd>android-32</kbd>, <kbd>android-64</kbd>, <kbd>ios-64</kbd>, <kbd>linux-64</kbd>, <kbd>macos-64</kbd>, <kbd>win-32</kbd>, and <kbd>win-64</kbd> platforms. Now the generated package can be used for further deployment with different platforms.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tests</h1>
                </header>
            
            <article>
                
<p>Any completed application requires testing of the working parts and components inside. In this section, we will cover unit testing of the created application with Qt's library instruments, such as the <strong><kbd>QtTest</kbd></strong> module. In addition, this module allows extensions for testing GUIs. The Python standard library unit testing framework, <kbd>unittest</kbd>, or third-party tools, such as <kbd>pytest</kbd>, can also be used. In the real world of testing, the <kbd>unittest</kbd> module is usually used in conjunction with the <strong><kbd>QtTest</kbd></strong> module. The <strong><kbd>QSignalSpy</kbd></strong> class of PyQt5's <strong><kbd>QtTest</kbd></strong> module introspects the emissions of the signals.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QtTest</h1>
                </header>
            
            <article>
                
<p>This module provides a realization of the unit testing of Qt applications and libraries. To use this module, we need to add the following import statements to the files where testing functions <span>will be used</span>. The best way is to create the <kbd>u_tests.py</kbd> files in both the <kbd>App/App_PyQt5/</kbd> and <kbd>App/App_PySide2/</kbd> directories of the applications and add the <kbd>import</kbd> sections, respectively, as follows:</p>
<ul>
<li>In the case of the PyQt5 <kbd>u_tests.py</kbd> file, add this:</li>
</ul>
<pre style="padding-left: 60px">...<br/>from PyQt5 import QtTest<br/>...</pre>
<ul>
<li>And, in the case of the PySide2 <kbd>u_tests.py</kbd> file, add this:</li>
</ul>
<pre style="padding-left: 60px">...<br/>from PySide2 import QtTest<br/>...</pre>
<p>The <kbd>QtTest</kbd> module provides the <kbd>QTest</kbd> class that can be used for the unit testing of the application. It should be noted that the PySide2 <kbd>QTest</kbd> namespace and the PyQt5 <kbd>QTest</kbd> class are different. The <kbd>QTest</kbd> namespace of the PySide2 binding realizes functions and declarations of the framework for unit testing Qt-based applications and libraries with extensions for GUIs. The PyQt5's <kbd>QTest</kbd> class does not implement the complete Qt unit test framework and assumes that Python's <kbd>stdlib</kbd> <kbd>unittest</kbd> module will be used with <kbd>QTest</kbd>. Therefore, PyQt5's <kbd>QTest</kbd> cannot be instantiated.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QTest (PySide2)</h1>
                </header>
            
            <article>
                
<p>This namespace realizes the unit testing framework of the Qt library. The declaration syntax is as follows:</p>
<pre><strong>test</strong> = QtTest.QTest()</pre>
<p>The <kbd>QTest</kbd> improves functionality by means of the following commonly used functions. A full list is available with the official PySide2 documentation (<a href="https://doc.qt.io/qtforpython/PySide2/QtTest/index.html">https://doc.qt.io/qtforpython/PySide2/QtTest/index.html</a>):</p>
<ul>
<li><kbd>test.asciiToKey("ascii")</kbd>: This converts the ASCII character key value, specified in the parameter, to a Qt key value.</li>
<li><kbd>test.currentAppName()</kbd>: This returns the name of the currently executed binary.</li>
<li><kbd>test.currentDataTag()</kbd>: This returns the name of the current test data.</li>
<li><kbd>test.currentTestFailed()</kbd>: This returns <kbd>True</kbd> if the test function failed.</li>
<li><kbd>test.currentTestFunction()</kbd>: This returns the name of the current test function.</li>
<li><kbd>test.ignoreMessage(QtMsgType, message)</kbd>: This ignores <kbd>qDebug()</kbd>, <kbd>qInfo()</kbd>, or <kbd>qWarning()</kbd> messages. In the instance when a message (the second parameter) of the global type (the first parameter) is returned in the output, it will be removed from the test log. If the test finishes and the message was not displayed in the output, it will be appended to the test log.</li>
<li><kbd>test.keyToAscii(key)</kbd>: This converts the Qt key value, specified in the parameter, to the ASCII character key value.</li>
<li><kbd>test.qExtractTestData("dirName")</kbd>: This extracts a directory, specified in the parameter, from resources to disk.</li>
<li><kbd>test.setBenchmarkResult(float, QTest.QBenchmarkMetric)</kbd>: This sets the benchmark result (the first parameter) with a metric (the second parameter) that specifies how the Qt test should interpret the results in relation to this test function.</li>
<li><kbd>test.toPrettyCString(str, int)</kbd>: This returns the same <kbd>QtCore.QByteArray</kbd>, but with only the ASCII characters.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QTest (PyQt5)</h1>
                </header>
            
            <article>
                
<p>This class contains functions that enable unit testing of the PyQt5 applications. The <kbd>QTest</kbd> class improves functionality by means of the following commonly used functions. <span>A full list is available with the official</span><span> </span>PyQt5 documentation (<a href="https://www.riverbankcomputing.com/static/Docs/PyQt5/">https://www.riverbankcomputing.com/static/Docs/PyQt5/</a>):</p>
<p><kbd>test.keyClick(QtWidgets.QWidget, QtCore.Qt.Key, QtCore.Qt.KeyboardModifiers, int)</kbd>: This simulates clicking a key (the second parameter) with a modifier (the third parameter) on a widget (the first parameter), with a test delay (the fourth parameter) in milliseconds.</p>
<p><kbd>test.keyClicks(QtWidgets.QWidget, str, QtCore.Qt.KeyboardModifiers, int)</kbd>: This simulates clicking a sequence of keys (the second parameter) with a modifier (the third parameter) on a widget (the first parameter), with a test delay (the fourth parameter) in milliseconds.</p>
<p><kbd>test.keyEvent(QtTest.QTest.KeyAction, QtWidgets.QWidget, QtCore.Qt.Key, QtCore.Qt.KeyboardModifiers, int)</kbd>: This sends a Qt key event to a widget (the second parameter) with a key (the third parameter) and associated action (the first parameter), as well as with a modifier (the fourth parameter), and a test delay (the fifth parameter) in milliseconds.</p>
<p><kbd>test.keyPress(QtWidgets.QWidget, QtCore.Qt.Key, QtCore.Qt.KeyboardModifiers, int)</kbd>: This simulates pressing a key (the second parameter) with a modifier (the third parameter) on a widget (the first parameter), with a test delay (the fourth parameter) in milliseconds.</p>
<p><kbd>test.keyRelease(QtWidgets.QWidget, QtCore.Qt.Key, QtCore.Qt.KeyboardModifiers, int)</kbd>: This simulates releasing a key (the second parameter) with a modifier (the third parameter) on a widget (the first parameter), with a test delay (the fourth parameter) in milliseconds.</p>
<p><kbd>test.mouseClick(QtWidgets.QWidget, QtCore.Qt.MouseButton, QtCore.Qt.KeyboardModifiers, QtCore.QPoint, int)</kbd>: This simulates clicking a mouse button (the second parameter) with a modifier (the third parameter) on a widget (the first parameter), with a test delay (the fifth parameter) in milliseconds. The position of the click (the fourth parameter), by default, is the center of the widget.</p>
<p><kbd>test.mouseDClick(QtWidgets.QWidget, QtCore.Qt.MouseButton, QtCore.Qt.KeyboardModifiers, QtCore.QPoint, int)</kbd>: This simulates double-clicking a mouse button (the second parameter) with a modifier (the third parameter) on a widget (the first parameter), with a test delay (the fifth parameter) in milliseconds. The position (the fourth parameter), by default, is the center of the widget.</p>
<p><kbd>test.mouseMove(QtWidgets.QWidget, QtCore.QPoint, int)</kbd>: This moves the mouse pointer to a widget (the first parameter), with a test delay (the fifth parameter) in milliseconds. It will be moved to a position (the fourth parameter), by default, to the center of the widget.</p>
<p><kbd>test.mouseRelease(QtWidgets.QWidget, QtCore.Qt.MouseButton, QtCore.Qt.KeyboardModifiers, QtCore.QPoint, int)</kbd>: This simulates releasing a mouse button (the second parameter) with a modifier (the third parameter) on a widget (the first parameter), with a test delay (the fifth parameter) in milliseconds. The position (the fourth parameter), by default, is the center of the widget.</p>
<p><kbd>test.qSleep(int)</kbd>: This sleeps for a number of milliseconds, specified in the parameter, blocking execution of this test.</p>
<p><kbd>test.qWait(int)</kbd>: This waits for a number of milliseconds, <span>specified in the parameter; the </span>events will be processed and this test will stay responsive to events.</p>
<p><kbd>test.qWaitForWindowActive(QtWidgets.QWidget, int)</kbd>: This waits for a number of milliseconds (the second parameter) until the widget's window (the first parameter) is active.</p>
<p><kbd>test.qWaitForWindowExposed(QtWidgets.QWidget, int)</kbd>: This waits for a number of milliseconds (the second parameter) until the widget's window (the first parameter) is exposed.</p>
<p><kbd>test.touchEvent(QtWidgets.QWidget, QtGui.QTouchDevice)</kbd>: This creates and returns a sequence of the  <kbd>QtTest.QTest.QTouchEventSequence</kbd> type for the device (the second parameter) to simulate events for the widget (the first parameter).</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QTest examples</h1>
                </header>
            
            <article>
                
<p>As we can see, the PyQt5 binding realizes just a part of the Qt test framework. The tests of the GUI app can be demonstrated with PyQt5-related construction of the simple example, which can also be used with the PySide2 binding. It should be noted that the methods described in the <em>QTest (PyQt5)</em> section are available for the PySide2 binding. By way of a simple example, add the following lines to the <kbd>import</kbd> sections of the <kbd>u_tests.py</kbd> files:</p>
<ol>
<li>In the case of the PyQt5 <kbd>u_tests.py</kbd> file, add this:</li>
</ol>
<pre style="padding-left: 60px">...<br/>from PyQt5.QtWidgets import QApplication<br/>from PyQt5.Qt import Qt<br/>from u_window import UWindow<br/>import unittest<br/>...</pre>
<ol start="2">
<li>And, in the case of the PySide2 <kbd>u_tests.py</kbd> file, add this:</li>
</ol>
<pre style="padding-left: 60px">...<br/>from PySide2.QtWidgets import QApplication<br/>from PySide2.QtCore import Qt<br/>from u_window import UWindow<br/>import unittest<br/>...</pre>
<p style="padding-left: 60px">The test element will be elements of the <kbd>UWindow</kbd> class that realizes the application window of the GUI. We can add any widget to this import line. </p>
<ol start="3">
<li><span>Now add to the </span><kbd>u_tests.py</kbd><span> files the class that inherits the </span><kbd>TestCase</kbd><span> </span><span>base </span><span>class of the Python standard library </span><kbd>unittest</kbd><span> module.</span></li>
</ol>
<p style="padding-left: 60px">Add the<span> </span><kbd>UTests</kbd><span> </span>class to the<span> </span><kbd>u_tests.py</kbd><span> </span>files by completing the file with the line that will call the <kbd>main()</kbd> function of the<span> </span><kbd>unittest</kbd><span> </span>module:</p>
<pre style="padding-left: 60px">...<br/>class UTests(unittest.TestCase):<br/><br/>    def setUp(self):<br/>        self.app = QApplication([])<br/>        self.uwin = UWindow() <br/>        self.menu = self.uwin.menuBar()<br/><br/>    def test_menu(self):<br/>        self.assertEqual(self.uwin.mb1.title(), "&amp;File")<br/>        self.menu.actions()[0].trigger()<br/>        QtTest.QTest.keyPress(self.uwin, Qt.Key_Enter,<br/>                                     Qt.ControlModifier)<br/>        return<br/><br/>    def tear_down(self):<br/>        pass<br/><br/><br/>unittest.main()<br/>...</pre>
<p style="padding-left: 60px">The <kbd>setUp()</kbd> method operates with instances that are required to start the test, such as application, the class instance of the imported <kbd>UWindow</kbd> class, and the window menu bar. The <kbd>test_menu()</kbd> function realizes this test and completes it with <kbd>tear_down()</kbd>.</p>
<ol start="4">
<li>Now we can run the <kbd>u_tests.py</kbd> files in the cmd/Terminal by typing the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt; python u_tests.py -v</strong></pre>
<p style="padding-left: 60px">And we will see output similar to the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c3b47eff-7d52-4c81-877d-cf35eb5d7aa8.png"/></p>
<p>We can test any widget in this way, and enhance the current construction depending on our own tasks.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter completes the GUI application that we created within this book. This application does not pretend to be a special tool to solve special tasks, but it can be easily extended and modernized for <span>almost </span>all GUI implementations commonly used today. Almost all of the useful graphical elements were described previously in this book. The process of deploying the GUI to the various platforms and architectures is not easy, and requires additional knowledge of the material and examples. Also, some restrictions <span>may arise, </span>depending on the versions and supported environments of the device. Hence, learning the requirements related to using the devices is recommended. Testing the application requires a thorough understanding of the elements that can be tested, and why, and how. Correct implementation of the tests can help to avoid a lot of the mistakes and errors associated with application development.</p>
<p>This chapter completes this book, and the reader must know what to learn next. Moreover, the Python world is so very vast.</p>


            </article>

            
        </section>
    </body></html>