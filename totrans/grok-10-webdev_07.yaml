- en: Indexing different kinds of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we can search the title and description fields of the `Project` class
    and nothing more. Both lists and items have a description field as well, so it
    would be nice if the simple search query we are using could also look inside lists
    and their items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, we are using `IProject` as the context for the search. The `context`
    class annotation does not accept more than one parameter, so we can''t just pass
    `ITodoList` and `ITodoItem` and be done. Here is where the concept of interfaces
    can shine. We can define a general search interface and make all of our objects
    implement it. They don''t even need to provide every attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice how instead of using a schema for the attribute definition, we simply
    use the `Attribute` class from the `interface` package. We are not going to generate
    forms from this interface and it is easy to just describe its attributes without
    worrying about field properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we define this interface and include all of the attributes that we want
    to be indexed in the catalog, we just declare that every model implements it.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Then, we replace the `context` annotation argument to use it as well. This is
    very powerful, and means that any of the objects that declare themselves to be
    searchable via the `grok.implements(ISearchable)` class annotation will be automatically
    indexed by Grok, or the call to `catalog.searchResults` will take them into account.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we use `ISearchable` as context now and also create all of the remaining
    indexes that we could use. As these indexes will contain references to different
    kinds of models, we add a `content_type` attribute to each model to hold the kind
    of model it represents. As an example, here is the improved `TodoList` class definition.
    We add `ISearchable` to the `grok.implements` declaration, and that's enough to
    make our search view work with todo items as well as projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Again, we are implementing `ISearchable,` which marks the `TodoList` model indexable.
    Then we define `content_type` with the value `list`, so that when a search result
    has multiple types of objects, we can find out if one of them is a list just by
    looking at this attribute. Notice how the rest of the metadata attributes are
    now assigned some value at creation time, via the `__init__` method, so that the
    result display is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `searchableText` method for full text searches is defined. In this
    case, the code is the same as for the method of the same name in the `Project`
    class, but it could be different, as indeed it is in the `TodoItem` class, which
    is not shown here.
  prefs: []
  type: TYPE_NORMAL
- en: The catalog admin UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When your catalog begins to grow, it can be useful to find out how many objects
    it has and how populated each index is. Grok includes a package for performing
    simple introspection into the catalog, which allows us to take a look inside.
  prefs: []
  type: TYPE_NORMAL
- en: 'The catalog UI is not integrated into the Grok admin UI. However, we can still
    access the catalog from the Zope side by using a direct URL. Let''s do that. Create
    some projects and lists in the `todo` application and then point your browser
    to: `http://localhost:8080/todo/++etc++site/Catalog/@@advanced.html`. The list
    of project indexes will appear in the browser, along with some statistics, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The catalog admin UI](img/7481_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is the statistics screen of the catalog UI, so we can't do much more here
    than take a look at the numbers, but it does give us a good sense of how our application
    data is stored in the catalog.
  prefs: []
  type: TYPE_NORMAL
- en: There are other tabs, the most important of which is the **Contents** tab, from
    where we can visit the information screens for each of the indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Types of indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we can see from the code of the `ProjectIndexes` class, there is more than
    one kind of index. So far, we have worked with a `text` index, which allows us
    to make full-text searches. However, not all searches are equal; text searches
    allow us to look for words or even fragments of words inside a field value, but
    there are cases where we would need to match a field value exactly or return no
    match at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Grok offers three ready-to-use index classes, which are summarized in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Index | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Field` | Matches against an entire field. Used for indexing orderable values
    and querying for a range. Supports sorting and limiting the number of results.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Text` | Supports full-text searches of a field. Queries can include the
    ''and'' and ''or'' Boolean operators. It''s also possible to search for fragments
    of strings by using an asterisk (globbing). |'
  prefs: []
  type: TYPE_TB
- en: '| `Set` | Supports keyword searches of a field. The index allows searches for
    documents that contain any one set of values; all of a set of values; or between
    a set of values. |'
  prefs: []
  type: TYPE_TB
- en: 'We are not going to add search options for using the other indexes in our application
    right now, but here are a few examples of how to use them. For the sake of completeness,
    let''s start with the `Text` field:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding objects containing the word ''caveman'' in the title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finding all objects with either ''spear'' or ''club'' in their description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finding objects containing any word starting with ''cave'' in their title (caveman,
    caved, caveat, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Field` index works differently. It''s necessary to always use a tuple
    for the query, even if we are only interested in a single value. If we want all
    of the objects created by the user ''Manager'':'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'All objects created between March 31, 2009 and today:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `Set` index allows us to find matches in lists of values, which is useful
    for finding objects that share some keywords or tags, but do not necessarily have
    the same list of keywords or tags applied to them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use a catalog for searching and categorizing
    content. We are now able to add indexes and custom search queries to our applications.
    In the next chapter, we will turn our attention to security.
  prefs: []
  type: TYPE_NORMAL
